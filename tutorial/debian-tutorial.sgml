<!doctype debiandoc system>
<debiandoc>
  <book> <title>Debian Tutorial</title>
      <author><name>Havoc Pennington</name><email>hp@debian.org</email>

      <version><date>

      <copyright> &copy; 1998 Software in the Public Interest and 
	  individual contributors. 

	<p>Permission is granted to make and distribute verbatim
	  copies of this manual provided the copyright notice and this
	  permission notice are preserved on all copies.
	  
	<p>Permission is granted to copy and distribute modified
	  versions of this manual under the conditions for verbatim
	  copying, provided also that the sections that reprint "The
	  GNU General Public License," "The GNU Library General
	  Public License," and other clearly marked sections held
	  under separate copyright are reproduced under the conditions
	  given within them, and provided that the entire resulting
	  derived work is distributed under the terms of a permission
	  notice identical to this one.

	<p>Permission is granted to copy and distribute translations
	  of this manual into another language under the conditions
	  for modified versions.  "The GNU General Public License"
	  and "The GNU Library General Public License" may be
	  included in a translation approved by the Free Software
	  Foundation instead of in the original English.
	  
	<p>At your option, you may distribute verbatim and modified
	  versions of this document under the terms of the GNU General
	  Public License, excepting the clearly marked sections held
	  under separate copyright.
	  
      </copyright>

    <toc>	  


    <chapt id="about"> <heading> About this manual </heading>

      <p>This is the Debian Tutorial. It is aimed at readers who are
	new to Debian GNU/Linux. It assumes no prior knowledge of
	GNU/Linux or other Unix-like systems, but it does assume very
	basic general knowledge about computers and hardware (you
	should know what the basic parts of a computer are, and what
	one might use a computer to do).

      <p>This manual is meant to be read in order; each chapter
	assumes some knowledge of prior chapters, though you may find
	it useful to skip around.

      <p>There is also a Debian Reference Guide planned, which will be
	more comprehensive but less introductory.
	
      <p>This tutorial assumes that you have already installed and
	configured Debian GNU/Linux according to the installation
	manual (which is incomplete as of this writing). However, you
	may want to look over the tutorial before you install, in
	order to learn more about Debian.

      <p>In general this tutorial tries to explain the reasons for
	things, and help you understand what's going on inside the
	system. The idea is to empower you to solve new problems and
	get the most out of your computer. Thus there's plenty of
	theory, history, and fun facts thrown in with the "How To"
	aspects of the manual.
	
      <p>Please send comments about this manual tothe Debian
	Documentation Project mailing list
	<email>debian-doc@lists.debian.org</email>.  We're especially
	interested in whether it was helpful to you, and how we could
	make it better. If you get confused while reading, or notice
	that we use a term without explaining it first, please email
	us.
	
      <p>Please, DO NOT send the authors technical questions about
	Debian, as there are other forums for that. See <ref
	id="docs-support">.  Only send mail regarding the manual
	itself to the above address.
	  
      <p>To find the latest version of this manual, go to <url
	    id="http://www.debian.org/doc/"
	    name="http://www.debian.org/doc/"> and follow the links.
    
      <sect id="acknowldgements"> Acknowledgements
	<p> Many people have helped with this manual.

	<p>The biggest thanks go to Larry Greenfield and his Linux
	  User's Guide, which formed the basis for the manual. The
	  Linux User's Guide is a part of the Linux Documentation
	  Project.

	<p>Many thanks to those who have helped me edit the manual;
	  they have made it far, far better. If you thought this
	  manual was pleasant to read, send your thanks to Thalia
	  Hooker and Day Irmiter.

	<p>Thanks to Richard Stallman of the Free Software Foundation
	  for advice, editing, and offering to publish the text.

	<p>Thanks to James Treacy for letting me borrow some of his
	  writings from the Debian web site.

	<p>Thanks to everyone who has written parts of the manual:
	  craig@happy.digitaldune.net, Ole Tetlie, Oliver Elphick.

	<p>Many people have submitted patches and comments, including
	  Eric Fischer and Mike Touloumtzis.

	<p>Many thanks to Ardo van Rangelrooij for getting things
	  started and maintaining the DebianDoc DTD used to write the
	  manual.

	<p>Of course, it's impossible to thank the hundreds of Debian
	  developers and thousands of free software authors that gave
	  us something to write about and use.

	<p>Thanks also to anyone I left out, since I'm sure I screwed
	  this up. I hope no one will take offense --- please email me
	  and let me know if your name should be here.

    <chapt id="introduction"> <heading> Introduction </heading>
      
      <sect id="introduction-debian"> What is Debian? 
	<p>
	  <em>Debian</em> is a free operating system (OS) for your
	  computer. An operating system is the set of basic programs
	  and utilities that make your computer run. At the core of an
	  operating system is the <em>kernel</em>. The kernel is the
	  most fundamental program on the computer: it does all the
	  basic housekeeping and lets you start other programs. Debian
	  uses the <em>Linux</em> kernel, a completely free piece of
	  software started by Linus Torvalds and supported by
	  (probably over 1000) programmers worldwide. A large part of
	  the basic tools that fill out the operating system come from
	  the (<url id="http://www.gnu.org" name="GNU project">), and
	  these tools are also free. Of course, what people
	  want is application software: programs to help them get what
	  they want to do done, from editing documents to running a
	  business to playing games to writing more software. Debian
	  comes with over 1000 <em>packages</em> (precompiled software
	  bundled up in a nice format for easy installation on your
	  machine) --- all of it free.

	<p>It's a bit like a tower. At the base is Linux. On top of
	  that are all the basic tools, mostly from GNU. Next is all
	  the application software that you run on the computer: much
	  of this is also from GNU. The Debian developers act as
	  architects and coordinators --- carefully organizing the
	  system and fitting everything together into an integrated,
	  stable operating system: Debian GNU/Linux.

	<sect1 id="introduction-debian-os">What's an operating system,
	    and what sort of operating system is Debian?

	  <p>An operating system is the set of basic programs and
	    utilities that makes your computer run. 

	  <p>Debian GNU/Linux is based on the Unix operating system,
	    which has a long history (see <ref
	    id="unix-history">). Debian is basically compatible with
	    Unix, but adds a significant number of additional
	    features.

	  <p>The design philosophy of GNU/Linux (and Unix) is to
	    distribute its functionality into small, multipurpose
	    parts. That way, you can easily achieve new functionality
	    and new features by combining the small parts (programs)
	    in new ways. Debian is like an erector set; you can build
	    all sorts of things with it.

	  <p>When you're using an operating system, you want to
	    minimize the amount of work you put into getting your job
	    done.  Debian supplies many tools that can help you, but
	    only if you know what these tools do.  Spending an hour
	    trying to get something to work and then finally giving up
	    isn't very productive.  This manual will teach you about
	    the core tools that make up Debian: what tools to use in
	    what situations, and how to tie these various tools
	    together.
	    
	<sect1 id="introduction-debian-how"> Who creates Debian?

	  <p> Debian is an all-volunteer internet development
	    project. There are hundreds of volunteers working on
	    it. Most are in charge of a small number of software
	    packages and are intimately familiar with the software
	    they package.

	  <p>These volunteers work together by following a strict set
	    of guidelines governing how packages are assembled. These
	    guidelines are developed cooperatively in discussions on
	    internet mailing lists and <em>internet relay chat</em>
	    (IRC) forums.
	    
	</sect1>

      <sect id="introduction-DFSG"> What's free software?  

	<p>When Debian developers and users speak of "free software,"
	  they refer to <em>freedom</em> rather than price. Debian is
	  free in this sense: you are free to modify and redistribute
	  it, and will always have access to the source code for this
	  purpose.  The <url
	  id="http://www.debian.org/social_contract#guidelines"
	  name="Debian Free Software Guidelines"> describe in more
	  detail exactly what is meant by "free." The <url
	  id="http://www.fsf.org" name="Free Software Foundation">,
	  originator of the GNU project, is another source of
	  information. You can find a more detailed discussion of free
	  software on <url id="http://www.debian.org/intro/free"
	  name="the Debian web site">.

	<p>Free software is sometimes called Open Source (R) software
	  --- Open Source is a certification mark. Since Open Source (R)
	  is trademarked, only truly free software can call itself
	  Open Source (R). You may encounter vendors who try to
	  mislead you by claiming their software is "free," while in
	  reality it has significant strings attached.  The Open
	  Source (R) trademark gives you some assurance that the
	  software really is free software. 'Open Source software' is
	  occasionally abbreviated 'OSS'.

	<p>You may be wondering: why would people spend hours of their
	  own time to write software, carefully package it, and then
	  give it all away? The answers are as varied as the people
	  who contribute.

	<p> Many believe in sharing information and having the freedom
	  to cooperate with one another, and feel that free software
	  encourages this. There's a long tradition starting in the
	  1950s upholding these values, sometimes called the Hacker
	  Ethic.  (You can read more about it in Steven Levy's
	  enjoyable book, <em>Hackers: Heroes of the Computer
	  Revolution</em>.)

	<p>Others want to learn more about computers. More and more
	  people are looking for ways to avoid the inflated price of
	  commercial software. A growing crowd contribute as a thank
	  you for all the great free software they've received from
	  others.

	<p>Many in academia create free software to help get the
	  results of their research into wider use. Businesses help
	  maintain free software so they can have a say in how it
	  develops --- there's no quicker way to get a new feature
	  than to implement it yourself or hire a consultant to do so!
	  Business is also interested in greater reliability and the
	  ability to choose between support vendors.  

	<p>Still others see free software as a social good,
	  democratizing access to information and preventing excessive
	  centralization of the world's information infrastructure. Of
	  course, a lot of us just find it great fun.

	<p>Debian is so committed to free software that we thought it
	  would be useful if it was formalized in a document of some
	  sort. Our <url id="http://www.debian.org/social_contract"
	  name="Social Contract"> promises that Debian will always be
	  100% free software. When you download a package from the
	  Debian main distribution, you can be sure it meets our Free
	  Software Guidelines.
	  
	<p>Although Debian believes in free software, there are cases
	  where people want or need to put proprietary software on
	  their machine. Whenever possible Debian will support this;
	  though proprietary software is not included in the main
	  distribution, it is sometimes available on the ftp site in
	  the <tt>non-free</tt> directory, and there are a growing
	  number of packages whose sole job is to install proprietary
	  software we are not allowed to distribute ourselves.

	<p>It is important to distinguish <em>commercial</em> software
	  from <em>proprietary</em> software. Proprietary software is
	  non-free software, while commercial software is software
	  sold for money. Debian permits commercial software to be a
	  part of the main distribution, but not proprietary software.
	  Remember that the phrase "free software" does not refer to
	  price; it is quite possible to sell free software. For more
	  clarification of the terminology, see <url
	  id="http://www.opensource.org"
	  name="http://www.opensource.org"> or <url
	  id="http://www.fsf.org/philosophy/categories.html"
	  name="http://www.fsf.org/philosophy/categories.html">. 
	  
      <sect id="introduction-why"> Why should I use Debian? 

	<p>What Debian is good for, and what it isn't good for. 
	  
      <sect id="introduction-how">How to Read This Book

	<p>The best way to learn about almost any computer program is
	  at your computer.  Most people find that reading a book
	  without using the program isn't beneficial.  The best way to
	  learn Unix and GNU/Linux is by using them.  Use GNU/Linux
	  for everything you can.  Experiment.  Don't be afraid ---
	  it's <em>possible</em> to mess things up, but you can always
	  reinstall. Keep backups and have fun!
	  
	<p>Debian isn't as intuitively obvious as some other operating
	  systems.  Thus, you will probably end up reading at least
	  the first few chapters.  GNU/Linux is like a race car, a
	  master chef's kitchen, or a classic novel; its power and
	  complexity make it difficult to approach at first, but far
	  more rewarding in the long run.
	  
	<p>The suggested way to learn is to read a little, then play a
	  little.  Keep playing until you're comfortable with the
	  concepts, and then start skipping around in the book.
	  You'll find a variety of topics are covered, some of which
	  you might find interesting and some of which you'll find
	  boring.  After a while, you should feel confident enough to
	  start using commands without knowing exactly what they do.
	  This is a good thing.

	<p>A helpful thing to know: if you ever mistakenly type a
	  command, or don't know how to exit a program, C-c (the Ctrl
	  key and the lowercase letter c held simultaneously) will
	  often stop the program.

      <sect id="introduction-ldp">The Linux Documentation Project
	  
	<p>This manual borrows heavily from the Linux Documentation
	  Project's <em>Linux User's Guide</em>, by Larry
	  Greenfield. Thanks Larry! That project has a number of other
	  excellent manuals, many of them targetted at more
	  experienced users and system administrators. The LDP also
	  maintains the Linux HOWTOs, an invaluable resource you
	  should become familiar with. You can find the LDP at their
	  <url id="http://sunsite.unc.edu/LDP/" name="homepage">.

    <chapt id="start"> <heading> Getting started </heading>

      <p> So you've just finished installing Debian!
	Congratulations. Dive right in and start learning to use it.

      <p> As a part of the install process, you should have figured
	out how to boot the Debian system (with a special floppy disk,
	by simply turning your computer on, or by holding down the
	<tt>Alt</tt> key at the LILO prompt and selecting Linux).

      <sect id="start-multi"> A multiuser, multitasking operating
	  system

	<p>As we mentioned earlier (<ref id="introduction-debian">),
	  the design of Debian GNU/Linux comes from the Unix operating
	  system. Unlike common desktop OS's such as DOS, Windows, and
	  MacOS, Unix is usually found on large servers and
	  <em>multiuser</em> systems.

	<p>This means that Debian has features those other OS's
	  lack. It allows a large number of people to use the same
	  computer at once, as long as each user has their own
	  <em>terminal</em>

	  <footnote>(A terminal is just a keyboard and a screen,
	      connected to the computer through the network, over a
	      modem, or directly. Your keyboard and monitor form a
	      terminal which is directly attached to the computer:
	      this special terminal is often called the
	      <em>console</em>.)</footnote>.

	  To permit many users to work at once, Debian must permit
	  many programs and applications to run simultaneously. This
	  feature is called <em>multitasking</em>. 

	<p>Much of the complexity (and power) of Unix-like systems
	  stems from these two features. For example, the system must
	  have a way to keep users from accidentally deleting each
	  other's files, and it has to coordinate the many programs
	  running at once, e.g. to ensure that they don't all use the
	  hard drive at the same time.

	<p>If you keep in mind what Debian was originally designed to
	  do, many aspects of it will make a lot more sense. You'll
	  learn to take advantage of the power of these features.

      <sect id="start-login">Logging in

	<p>To use Debian you must identify yourself to the
	  system. This is so it knows who you are, what you have
	  permission to do, and what your preferences are.

	<p>To this end, you have a <em>user name</em> or
	  <em>login</em> --- if you installed Debian yourself, you
	  should have been asked to give such a name during
	  installation. If you are logging on to a system administered
	  by someone else, you'll have to ask them for an account on
	  the system, and a corresponding username.

	<p>You also have a password, so no one else can pretend to be
	  you. If you don't have a password, anyone can log on to your
	  computer from the Internet, and do bad things (see <ref
	  id="advanced-security">). If you're worried about security,
	  you should have a password.

	<p>Many people prefer to trust others not to do anything
	  malicious with their account; hopefully your work
	  environment doesn't encourage paranoia. This is a perfectly
	  reasonable attitude; it depends on your personal priorities,
	  and your environment. Obviously a home system does not need
	  to be as secure as a military installation. Debian allows
	  you to be as secure or as insecure as you like.

	<p>When you start Debian, you'll see a <em>prompt</em>; a
	  request from the computer for some information. In this
	  case, the prompt is <tt>login:</tt>.

	<p>You should enter your username, and when requested, your
	  password. The password does not appear on the screen as you
	  type it --- that's so no one can look over your shoulder and
	  see what it is. Press <tt>Enter</tt> after both the username
	  and the password. If you type your username or password
	  incorrectly, you'll have to start over.

	<p>If you do it correctly, you'll see a brief message and then
	  a <tt>&dollar;</tt> prompt. The <tt>&dollar;</tt> is printed
	  by a special program called the <em>shell</em>, and is thus
	  called a <em>shell prompt</em>: this is where you give
	  commands to the system.
	  
	<p>Try entering the command <tt>whoami</tt> now. There is a
	  <em>cursor</em> to the right of the shell prompt. Your
	  cursor is a small underscore or rectangle which indicates
	  where you're typing; it should move as you type. Always
	  press <tt>RET</tt> (the Enter or Return key) when you're
	  done typing a shell command.

	<p><tt>whoami</tt> tells your username. You'll then get a new
	  shell prompt.

	<p>For the rest of the manual, when we say to enter a command,
	  you should type it at the shell prompt and press the
	  <tt>RET</tt> key. On some keyboards, this key is labeled
	  <tt>Enter</tt> and on others it's <tt>Return</tt>. Same key,
	  different name.

	<p>When you're done working, you may want to log out of the
	  system. To exit the shell, enter the <tt>exit</tt>
	  command. Keep in mind that if you remain logged in, someone
	  could come along and use your account. Hopefully you can
	  trust those in your office or home not to do this; but if
	  you do not trust your environment, you should be certain to
	  log out when you leave.

      <sect id="start-keys"> Keys
	<p>Before going on, it's important to be familiar with the
	  conventions in this manual for describing key commands. 
	 
	<p>When you should simultaneously hold down multiple keys, a
	  notation like <tt>C-a</tt> will be used. This means "hold
	  the control key, and type lowercase letter a." Other
	  abbreviations include the Alt key, <tt>A</tt>, and the Meta
	  key <tt>M</tt>. Some keyboards have both Alt and Meta; most
	  home computers have only Alt, but the Alt key behaves like a
	  Meta key. So if you have no Meta key, try the Alt key
	  instead.

	<p>Keys like Alt and Meta are called <em>modifier</em> keys
	  because they change the meaning of standard keys like the
	  letter A. Sometimes you need to hold down more than one
	  modifier; for example, <tt>M-C-a</tt> means to
	  simultaneously press Meta, Ctrl, and lowercase a.

	<p>Some keys have a special notation; for example,
	  <tt>RET</tt> (Return/Enter), <tt>DEL</tt> (Delete or
	  sometimes Backspace), <tt>ESC</tt> (Escape). These should be
	  fairly self-explanatory.
	  
	<p>Spaces instead of hyphens mean to type the keys in
	  sequence. So, for example, <tt>C-a x RET</tt> means to
	  simultaneously type Control and lowercase a, followed by the
	  letter x, followed by pressing Return.

      <sect id="start-commandline"> Command history and editing
	  the command line

	<p>Whatever you type after the shell prompt before pressing
	  <tt>RET</tt> is called a <em>command line</em> --- it's a
	  line of text that commands the computer to do something. The
	  Debian default shell offers several features to make
	  entering command lines easy.

	<p>You can scroll up to previous commands to run them again,
	  or modify them slightly and <em>then</em> run them again.
	  Try this: enter any command, such as <tt>whoami</tt>; then
	  press the up arrow key. The <tt>whoami</tt> command will
	  reappear at the prompt. You can then press <tt>RET</tt> to
	  run <tt>whoami</tt> a second time.

	<p>If you've entered several commands, you can keep pressing
	  the up arrow key to go back through them. This feature is
	  handy if you're doing the same thing several times, or if
	  you type a command incorrectly and want to go back to fix it.  You
	  can press the down arrow key to move in the other direction,
	  toward your more recent commands. If there are no more
	  commands to move to, the computer will beep.

	<p>You can also move around on the command line to make
	  changes. The easiest way is with the left and right arrow
	  keys --- try typing <tt>whoasmi</tt> instead of
	  <tt>whoami</tt>, then use the left arrow key to move back to
	  the <tt>s</tt>. You can erase the <tt>s</tt> with the
	  Backspace or Delete keys.

	<p>There are more advanced features as well (no need to
	  memorize them all now, though). Try typing
	  <tt>C-a</tt>. This moves you to the beginning of the
	  line. <tt>C-k</tt> (the <tt>k</tt> stands for "kill")
	  deletes until the end of the line --- try it from the middle
	  of the command line. Using <tt>C-a</tt> followed by
	  <tt>C-k</tt>, you can delete the entire command
	  line. <tt>C-y</tt> pastes the last thing you killed,
	  inserting it at the current cursor position (<tt>y</tt>
	  stands for "yank," as in "yank it back").

	<p>Go ahead and play around with command line editing to get a
	  feel for it. Experiment.

      <sect id="start-root"> Logging in as root

	<p>Since Debian is a multiuser system, it's designed to keep
	  any one user or program from breaking the entire system. The
	  kernel will not allow normal users to change important
	  system files. This means that things stay the way they're
	  supposed to, safe from accidents, viruses, and even
	  malicious pranks. Unlike other OS's, Debian is safe from
	  these threats. You won't need an antivirus program.
	 
	<p>However, sometimes you need to change important system
	  files --- for example, you might want to install new
	  software, or configure your network connection. To do so,
	  you have to have greater powers than a normal user; you must
	  become the <em>root user</em> (also called the
	  <em>superuser</em>).

	<p>To become root, just log on with the username <tt>root</tt>
	  and the root password, if you have one. Hopefully you
	  remember the password from when you installed the system ---
	  if not, you have a problem.  <footnote>The solution to this
	  problem is fairly technical. You have to boot with a rescue
	  disk, mount your normal root partition, and edit
	  <tt>/etc/passwd</tt> to remove the old root password. Ask
	  for help if this doesn't make sense to you (see <ref
	  id="docs-support">). </footnote>

	<p>At many sites, only the system administrator has the root
	  password, and only the system administrator can do the
	  things that one must be root to do. If you're using your own
	  personal computer, <em>you</em> are the system
	  administrator, of course. If you don't have root privileges,
	  you will have to rely on your system administrator to
	  perform any tasks that require root privileges.

	<p>Sometimes you'll have the root password even on a shared
	  corporate or educational server, because the sysadmin trusts
	  you to use it properly. In that case, you'll be able to help
	  administer the system and customize it for your needs. But
	  you should be sure to use the password responsibly,
	  respecting other users at all times.

	<p>If you have the password, try logging on as root now.
	  Enter the <tt>whoami</tt> command to verify your identity.
	  Then <em>log out immediately</em>. When you're root, the
	  kernel will not protect you from yourself, because root has
	  permission to do anything at all to the system. For example,
	  you can type <tt>rm -rf /</tt> and erase your <em>entire
	  system</em> in a few keystrokes. (Needless to say, you
	  should NOT type this).  Don't experiment while you're
	  root. In fact, don't do anything as root, unless absolutely
	  necessary. This isn't a matter of security, but rather of
	  stability. Your system will run much better if it can keep
	  you from making silly mistakes.

	<p>You may find the <prgn>su</prgn> command more convenient
	  than logging in as root. <prgn>su</prgn> allows you to
	  assume the identity of another user, usually root unless you
	  specify someone else. (You can remember that <prgn>su</prgn>
	  stands for Super User, though some say it stands for Set
	  UserID.) Try this:

	  <enumlist>
	    <item> Log on as yourself, i.e. not as root.  

	    <item>
		<tt>whoami</tt> <p> Confirm your username.  

	    <item>
		<tt>su</tt> <p> Enter the <tt>su</tt> command. It will
		prompt for a password; enter the root password. If you
		give the correct password, you should see a new shell
		prompt. By default, root's shell prompt is <tt>#</tt>
		rather than <tt>&dollar;</tt>.

	    <item>
		<tt>whoami</tt> <p> This should give "root" as your
		new username.

	    <item> 
		<tt>exit</tt> <p> Exit the root shell. Your prompt
		will return to <tt>&dollar;</tt>.

	    <item> 
		<tt>exit</tt> <p> Exit your own shell.
	  </enumlist>

	<p>
	  When you're doing system administration tasks, you should do
	  as much as possible as yourself. Then <tt>su</tt>, do the
	  part that requires root privileges, and <tt>exit</tt> to
	  turn off privileges so you can no longer harm anything.

	<p>You can use <tt>su</tt> to assume the identity of any user
	  on the system, not just root. To do this, type <tt>su
	  <var>user</var></tt> where <var>user</var> is the user
	  you want to become. You'll have to know their password, of
	  course, unless you're root at the time or they have no
	  password.

      <sect id="start-VC"> Virtual consoles
	  
	<p>The Linux kernel supports <em>virtual consoles</em>.  These
	  are a way of making your single screen and keyboard seem
	  like multiple terminals, all connected to the same
	  system. Thankfully, using virtual consoles is one of the
	  simplest things about Debian: there are "hot keys" for
	  switching among the consoles quickly.  To try it, log in to
	  your system, and type <tt>A-F2</tt> (simultaneously press
	  the <tt>Alt</tt> key, and <tt>F2</tt>, that is, function key
	  number 2).

	<p>You should find yourself at another login prompt.  Don't
	  panic: you are now on virtual console (VC) number 2!  Log in
	  here and do some things --- more <tt>whoami</tt>'s or
	  whatever --- to confirm that this is a real login shell.
	  Now you can return to VC number 1, with <tt>A-F1</tt>.  Or
	  you can move on to a <em>third</em> VC, in the obvious way
	  (<tt>A-F3</tt>).

	<p>Debian comes with six VCs enabled by default, accessed with
	  the Alt key and function
	  keys <tt>F1-F6</tt> (technically, there are more
	  VC's enabled, but only 6 of them allow you to log in. The
	  others are used for the X Window System or other special
	  purposes).

	<p>If you're using the X Window System, it will generally
	  start up on the first unused VC --- probably VC 7. Also, to
	  switch from the X VC to one of the first six, you'll have to
	  add <tt>Ctrl</tt> to the key sequence. So that's
	  <tt>C-A-F1</tt> to get to VC 1. But you can go from a text
	  VC to the X VC using only <tt>Alt</tt>. If you never leave
	  X, you won't have to worry about this; X automatically
	  switches you to its VC when it starts up.

	<p>Once you get used to them, VC's will probably become an
	  indispensable tool for getting many things done at once.
	  (The X Window System serves much the same purpose, providing
	  multiple windows rather than multiple consoles). You can run
	  a different program on each VC, or log on as root on one VC
	  and as yourself on another. Or everyone in the family can
	  use their own VC --- this is especially handy if you use X,
	  in which case you can run several X sessions at once, on
	  different VC's.

      <sect id="start-shutdown"> Shutting down
	<p>

	  <em>Do not just turn off the computer! You risk losing
	    valuable data!</em>

	<p>If you are the only user of your computer, you might want
	  to turn the computer off when you're done with it.

	  <footnote>To avoid possibly weakening some hardware
	      components, only turn off the computer when you're done
	      for the day. Power up and power down are the two
	      greatest contributors to wear and tear on computer
	      components. Turning the computer on and off once a day
	      is probably the best compromise between your electric
	      bill and your computer's lifespan.
	  </footnote>

	<p>
	  Unlike most versions of DOS, it's a bad thing to just hit
	  the power switch when you're done using the computer.  It is
	  also bad to reboot the machine (with the reset button)
	  without first taking proper precautions.  The Linux kernel,
	  in order to improve performance, has a <em>disk cache</em>.
	  This means it temporarily stores information meant for
	  permanent storage in RAM: since memory is thousands of times
	  faster than a disk, this makes many file operations move
	  more quickly.  Periodically, the information Linux has in
	  memory is actually written to the disk. This is called
	  <em>syncing</em>.  In order to turn off or reboot the
	  computer, you'll have to tell the computer to clear
	  everything out of memory and put it in permanent storage.

	<p> To reboot, just type <tt>reboot</tt>, or press
	  <tt>C-A-DEL</tt> (that's Control, Alt, and Delete).

	<p> To shut down, you'll have to be <tt>root</tt>. As root,
	  just type the command <tt>shutdown -h now</tt>. This will go
	  through the entire shutdown procedure, including the
	  <tt>sync</tt> command which clears the disk cache as
	  described above. When you see <tt>System halted</tt>, it's
	  safe to turn off the computer. If you have Advanced Power
	  Management (APM) support in your kernel and BIOS, the
	  computer might shut itself off and save you the trouble. APM
	  is common in laptops and is also found in certain desktop
	  mainboards.

	<p> Some people find it simplest to shut down by typing
	  <tt>C-A-DEL</tt> to reboot, then powering off the computer
	  before the Linux kernel begins to reload. However, once the
	  kernel begins to load, you have to wait for it to finish and
	  then properly reboot or shutdown again. 

    <chapt id="basics"> <heading> The Basics </heading>

      <p>FIXME write a little intro here.

      <sect id="basics-commandline"> The command line and <tt>man</tt>
	  pages

	<p>We've already discussed the <em>command line</em>, that is,
	  commands you type after the shell prompt. This section
	  describes the structure of more complicated command lines.

	<p>A minimal command line contains just a command name, such
	  as <tt>whoami</tt>. But other things are possible. For
	  example, you might type:
<example>
man whoami
</example>
	  This command requests the online manual for the
	  <tt>whoami</tt> program (you may have to press the space bar
	  to scroll through the documentation, or press <tt>q</tt> to
	  quit). A more complicated example:

<example>
 man -k Postscript
</example>

	  This command line has three parts. It begins with the
	  command name, <tt>man</tt>. Then it has an <em>option</em>
	  or <em>switch</em>, <tt>-k</tt>, followed by an
	  <em>argument</em>, <tt>Postscript</tt>. Some people refer to
	  everything except the command name as the
	  <em>parameters</em> of the command. So, options and
	  arguments are both parameters.

	<p> Options change the behavior of a command, switching on
	  particular features or functionality. They usually have a
	  <tt>-</tt> before them. The GNU utilities also have "long
	  forms" for the options; the long form of <tt>-k</tt> is
	  <tt>--apropos</tt>. Enter <tt>man -h</tt> or <tt>man
	  --help</tt> to get a full list of options for the
	  <tt>man</tt> command. Every command will have its own set of
	  options, though most have <tt>--help</tt> and
	  <tt>--version</tt> options. Some commands are bizarre;
	  <tt>tar</tt>, for example, does not require the <tt>-</tt>
	  before its options, for historical reasons.

	<p>Anything which isn't an option and isn't the command name
	  is an <em>argument</em>. In this case,
	  <tt>Postscript</tt>. Arguments can serve many purposes; most
	  commonly, they are filenames that the command should operate
	  on. In this case, <tt>Postscript</tt> is the word you want
	  <prgn>man</prgn> to search for. In the case of <tt>man
	  whoami</tt>, the argument was the command you wanted
	  information about.

	<p>Breaking down the <tt>man -k Postscript</tt> command line:

	  <list>

	    <item> <tt>man</tt>, the command name, tells the computer
		to look at the manual pages. These provide
		documentation for commands. For example, <tt>man
		whoami</tt> will give you documentation on the
		<tt>whoami</tt> command.

	    <item> <tt>-k</tt>, the option, changes the behavior of
		<tt>man</tt>. Normally <tt>man</tt> expects a command
		name for an argument, such as <tt>whoami</tt>, and
		looks for documentation of that command. But with the
		<tt>-k</tt> or <tt>--apropos</tt> option, it expects
		the argument to be a keyword. It then gives a list of
		all manual pages with that keyword in their
		description.

	    <item> <tt>Postscript</tt> is the argument; since we used
		the <tt>-k</tt> option, it's the keyword to search
		for.

	    <item> <tt>-k</tt> and <tt>Postscript</tt> are both
		parameters.
	  </list>
	
	<p>Go ahead and type <tt>man -k Postscript</tt>, and you
	  will see a list of all the manual pages on your system
	  that have something to do with Postscript. If you haven't
	  installed much software, you might see <tt>Postscript:
	  nothing appropriate</tt> instead.
	  
	<sect1 id="basics-commandline-description"> Describing the
	    command line

	  <p>Note: This is a skippable section, if you want to move
	  on.

	  <p>There's a traditional concise way of describing command
	    <em>syntax</em> <footnote><em>Syntax</em> means the
	    permissible ways to combine various options and
	    arguments.</footnote> that you should know. For example,
	    if you type <tt>man man</tt> to get the manual page about
	    <tt>man</tt>, you'll see several syntax descriptions
	    beginning with the command name <tt>man</tt>. One of them
	    will look like this:
	    
<example>
 man -k [-M path] keyword ...      
</example>
	    
	  <p>Anything in brackets (<tt>[]</tt>) is an optional
	    unit. So you don't have to use the <tt>-M</tt> option, but
	    if you do, you must use a <tt>path</tt> argument. You must
	    use the <tt>-k</tt> option and the <tt>keyword</tt>
	    argument.  The <tt>...</tt> means that you could have more
	    of whatever came before it, so you could look up several
	    keywords.

	  <p>Let's look at one of the more complex descriptions from
	    the <tt>man</tt> manual page:

<example>
  man  [-c|-w|-tZT  device]  [-adhu7V] [-m system[,...]] [-L
       locale] [-p string] [-M path] [-P pager] [-r  prompt]  [-S
       list] [-e extension] [[section] page ...] ...
</example>
	    
	    There's no need to go through all of this (and don't worry
	    about what it all means), but do pay attention to the
	    organization of the description.
	    
	  <p>First, clusters of options usually mean you can use one
	    or more of them in different combinations, so
	    <tt>-adhu7V</tt> means you can also use
	    <tt>-h</tt>. However, you can't always use all
	    combinations; this description doesn't make that
	    clear. For example, <tt>-h</tt> is incompatible with other
	    options, but you could do <tt>man -du</tt>. Unfortunately
	    the description's format does not make this clear.

	  <p>Second, the <tt>|</tt> symbol means "or". So you can use
	    <em>either</em> the <tt>-c</tt>, the <tt>-w</tt>,
	    <em>or</em> the <tt>-tZT</tt> options, followed by a
	    <tt>device</tt> argument.

	  <p>Third, notice that you can nest the brackets, since they
	    indicate an optional <em>unit</em>. So if you have a
	    <tt>section</tt>, you must also have a <tt>page</tt>,
	    since <tt>page</tt> is not optional within the
	    <tt>[[section] page]</tt> unit.

	  <p>There's no need to memorize any of this, just refer to
	    this section as you read documentation.

      <sect id="basics-files"> Files and Directories

	<sect1 id="basics-files-intro"> Introduction to files
	    
	  <p> <em>Files</em> are a facility for storing and organizing
	    information, analagous to paper documents.  They're
	    organized into <em>directories</em>, which are called
	    <em>folders</em> on some other systems. Let's look at the
	    organization of files on a Debian system:

	    <taglist>

	      <tag> <tt>/</tt> <item> A simple <tt>/</tt> represents
		  the root directory. All other files and directories
		  are contained in the root directory.

	      <tag> <tt>/home/janeq</tt> <item> This is the home
		  directory of user "janeq". Reading left to right, to
		  get to this directory you start in the root
		  directory, enter directory <tt>home</tt>, then enter
		  directory <tt>janeq</tt>.

	      <tag> <tt>/etc/X11/XF86Config</tt> <item> This is the
		  configuration file for the X Window System. It
		  resides in the <tt>X11</tt> subdirectory of the
		  <tt>/etc</tt> directory. <tt>/etc</tt> is in turn a
		  subdirectory of the root directory, <tt>/</tt>.
		  
	    </taglist>
	    
	  <p> Things to note:
	    <list>

	      <item> Filenames are case sensitive. That is,
		  <tt>MYFILE</tt> and <tt>MyFile</tt> are different
		  files.

	      <item> The root directory is referred to as simply
		  <tt>/</tt>. Don't confuse this "root" with the root
		  user, the user on your system with "super powers." 

	      <item> Every directory has a name which can contain any
		  letters or symbols <em>except</em> <tt>/</tt>. The
		  root directory is an exception; its name is
		  <tt>/</tt> (pronounced "slash" or "the root
		  directory") and it cannot be renamed.

		  <footnote> While you <em>can</em> use almost any
		      letters or symbols in a file name, in practice
		      it's a bad idea. It is better to avoid any
		      characters that often have special meanings,
		      including: 
		      <tt>{ } ( ) [ ] ' ` " \ / &gt &lt | ; ! # & ^ *
			% @</tt>
		    <p> Also avoid putting spaces
		      in filenames. If you want to separate words in a
		      name, good choices are the period, hyphen, and
		      underscore. You could also capitalize each word,
		      <tt>LikeThis</tt>.
		  </footnote>

	      <item>Each file or directory is designated by a
		  <em>fully-qualified filename</em>, <em>absolute
		  filename</em>, or <em>path</em>, giving the sequence
		  of directories which must be passed through to reach
		  it. The three terms are synonymous. All absolute
		  filenames begin with the <tt>/</tt> directory, and there's
		  a <tt>/</tt> between each directory or file in the
		  filename. The first <tt>/</tt> is the name of a
		  directory, but the others are simply separators to
		  distinguish the parts of the filename.

		<p>The words used here can be confusing. Take the
		  following example:
<example>
/usr/share/keytables/us.map.gz
</example>

		  This is a fully-qualified filename; some people call
		  it a <em>path</em>. However, people will also refer
		  to <tt>us.map.gz</tt> alone as a
		  filename. <footnote> There is also another use for
		  the word "path" --- see FIXME xref. The intended
		  meaning is usually clear from the
		  context. </footnote>

	      <item> Directories are arranged in a tree structure. All
		  absolute filenames start with the root
		  directory. The root directory has a number of
		  branches, such as <tt>/etc</tt> and
		  <tt>/usr</tt>. These subdirectories in turn branch,
		  into still more subdirectories, such as
		  <tt>/etc/init.d</tt> and <tt>/usr/local</tt>. The
		  whole thing together is called the "directory tree."

		<p>You can think of an absolute filename as a route
		  from the base of the tree (<tt>/</tt>) to the end of
		  some branch (a file). You'll also hear people talk
		  about the directory tree as if it were a
		  <em>family</em> tree: thus subdirectories have
		  "parents," and a path shows the complete ancestry of
		  a file.

	      <item> There's no directory that corresponds to a
		  physical device, such as your hard disk. This
		  differs from DOS and Windows, where all paths begin
		  with a device name such as <tt>C:\</tt>. The
		  directory tree is meant to be an abstraction of the
		  physical hardware, so you can use the system without
		  knowing what the hardware is. All your files could
		  be on one disk --- or you could have 20 disks, some
		  of them connected to a different computer elsewhere
		  on the network. You can't tell just by looking at
		  the directory tree, and nearly all commands work
		  just the same way no matter what physical device(s)
		  your files are really on.

	    </list>

	  <p> Don't worry if all this isn't completely clear
	    yet. There are many examples to come.

	<sect1 id="basics-files-using"> Using files: a tutorial

	  <p>
	    To use your system you'll have to know how to create,
	    move, rename, and delete files and directories. This
	    section describes how to do so with the standard Debian
	    commands.
	    
	  <p> The best way to learn is to try things. As long as you
	    aren't root (and haven't yet created any important
	    personal files), there's nothing you can mess up too
	    seriously. Jump in --- type each of these commands at
	    the prompt and press enter:

	    <enumlist>
	      <item> <tt>pwd</tt> <p> One directory is always
		  considered the <em>current working directory</em>
		  for the shell you're using. You can view this
		  directory with the <tt>pwd</tt> command, which
		  stands for Print Working Directory. <tt>pwd</tt>
		  prints the name of the directory you're working in
		  --- probably <tt>/home/yourname</tt>.

	      <item> <tt>ls</tt> <p> <tt>ls</tt> stands for "list," as
		  in "list files." When you type <tt>ls</tt>, the
		  system displays a list of all the files in your
		  current working directory. If you've just installed
		  Debian, your home directory may well be empty. If
		  your working directory is empty, <tt>ls</tt>
		  produces no output, since there are no files to
		  list.

	      <item> <tt>cd /</tt> <p> <tt>cd</tt> means Change
		  Directory. In this case, you've asked to change to
		  the root directory. 

	      <item> <tt>pwd</tt> <p> Verify that you're working
		  in the root directory. 

	      <item> <tt>ls</tt> <p> See what's in <tt>/</tt>.

	      <item> <tt>cd</tt> <p> Typing <tt>cd</tt> with no
		  arguments selects your home directory as the current
		  working directory --- <tt>/home/yourname</tt>. Try
		  <tt>pwd</tt> to verify this.

	    </enumlist>
	    
	  <p>Before continuing, you should know that there are
	    actually two different kinds of filename. Some of them
	    begin with <tt>/</tt>, the root directory, such as
	    <tt>/etc/profile</tt>. These are called <em>absolute</em>
	    filenames because they refer to the same file no matter
	    what your current directory is. The other kind of filename
	    is <em>relative</em>.

	  <p>Two directory names are used <em>only</em> in relative
	    filenames: <tt>.</tt> and <tt>..</tt>.  The directory
	    <tt>.</tt> refers to the current directory and <tt>..</tt>
	    is the parent directory.  These are "shortcut"
	    directories.  They exist in <em>every</em> directory.
	    Even the root directory has a parent directory --- it's
	    its own parent!
	    
	  <p>So filenames which include <tt>.</tt> or <tt>..</tt> are
	    <em>relative</em>, because their meaning depends on the
	    current directory. If I'm in <tt>/usr/bin</tt> and type
	    <tt>../etc</tt>, then I'm referring to <tt>/usr/etc</tt>.
	    If I'm in <tt>/var</tt> and type <tt>../etc</tt>, then I'm
	    referring to <tt>/etc</tt>. Note that a filename without
	    the root directory at the front implicitly has <tt>./</tt>
	    at the front. So you can type <tt>local/bin</tt> or
	    <tt>./local/bin</tt> and it means the same
	    thing.

	  <p>A final handy tip: the tilde <tt>~</tt> is equivalent to
	    your home directory. So typing <tt>cd ~</tt> is the same
	    as typing <tt>cd</tt> with no arguments. Also, you can
	    type things like <tt>cd ~/practice/mysubdirectory</tt> to
	    change to the directory
	    <tt>/home/yourname/practice/mysubdirectory</tt>.

	  <p>Here are some more file commands to try out, now that you
	    know about relative filenames. <tt>cd</tt> to your home
	    directory before you begin.
	    
	    <enumlist>
	      
	      <item> <tt>mkdir practice</tt> <p> In your home
		  directory, make a directory called
		  <tt>practice</tt>. You'll use this directory to try
		  out some other commands. You might type <tt>ls</tt>
		  to verify that your new directory exists.
		  
	      <item> <tt>cd practice</tt> <p> Change directory to
		  <tt>practice</tt>.

	      <item> <tt>mkdir mysubdirectory</tt> <p> Create a
		  subdirectory of <tt>practice</tt>.

	      <item> <tt>cp /etc/profile .</tt> <p> <tt>cp</tt> is
		  short for "copy."  <tt>/etc/profile</tt> is just a
		  random file on your system, don't worry about what
		  it is for now. We've copied it to <tt>.</tt> ---
		  recall that <tt>.</tt> just means "the directory I'm
		  in now," or the current working directory. So we've
		  created a copy of <tt>/etc/profile</tt>, and put it
		  in our <tt>practice</tt> directory. Try typing
		  <tt>ls</tt> to verify that there's indeed a file
		  called <tt>profile</tt> in your working directory,
		  alongside the new <tt>mysubdirectory</tt>.

	      <item> <tt>more profile</tt> <p> View the contents of
		  the file <tt>profile</tt>. <tt>more</tt> is used to
		  view the contents of text files. It's called
		  <tt>more</tt> because it shows a page of the file at
		  a time, and you press the space bar to see
		  more. <tt>more</tt> will exit when you get to the
		  end of the file, or when you type <tt>q</tt>
		  (quit). 

	      <item> <tt>more /etc/profile</tt> Verify that the
		  original looks just like the copy you made.

	      <item> <tt>mv profile mysubdirectory</tt> <p>
		  <tt>mv</tt> stands for "move." We've moved the file
		  <tt>profile</tt> from the current directory into the
		  subdirectory we created earlier. 

	      <item> <tt>ls</tt> <p> Verify that <tt>profile</tt> is
		  no longer in the current directory.

	      <item> <tt>ls mysubdirectory</tt> <p> Verify that
		  <tt>profile</tt> has moved to
		  <tt>mysubdirectory</tt>.

	      <item> <tt>cd mysubdirectory</tt> <p> Change to the
		  subdirectory.

	      <item> <tt>mv profile myprofile</tt> <p>Note that unlike
		  some operating systems, there is no difference
		  between moving a file and renaming it. Thus there's
		  no separate <tt>rename</tt> command. Note that the
		  second argument to <tt>mv</tt> can be a directory to
		  move the file or directory into, or a new
		  filename. <tt>cp</tt> works the same way.  <p>As
		  usual, you can type <tt>ls</tt> to see the result of
		  <tt>mv</tt>.

	      <item> <tt>mv myprofile ..</tt> <p> Just as <tt>.</tt>
		  means "the directory I'm in now," <tt>..</tt> means
		  "parent of the current directory," in this case the
		  <tt>practice</tt> directory we created earlier. Use
		  <tt>ls</tt> to verify that that's where
		  <tt>myprofile</tt> is now.

	      <item> <tt>cd ..</tt> <p> Change directories to the
		  parent directory --- in this case <tt>practice</tt>,
		  where you just put <tt>myprofile</tt>.

	      <item> <tt>rm myprofile</tt> <p><tt>rm</tt> means
		  "remove" --- this deletes <tt>myprofile</tt>. Be
		  careful!  Deleting a file on a GNU/Linux system is
		  <em>permanent</em> --- there is no undelete. If you
		  <tt>rm</tt> it, it's gone, forever.

	      <item> <tt>rmdir mysubdirectory</tt> <p><tt>rmdir</tt>
		  is just like <tt>rm</tt>, only it's for
		  directories. Notice that <tt>rmdir</tt> only works
		  on empty directories --- if the directory contains
		  files, you must delete those files first, or
		  alternatively use <tt>rm -r</tt> in place of
		  <tt>rmdir</tt>.

	      <item> <tt>rmdir .</tt> <p> Oops! That didn't work. You
		  can't delete a directory you're currently working
		  in.

	      <item> <tt>cd ..</tt> <p> So move out of the current
		  directory, and into its parent directory. Now you
		  can type:

	      <item> <tt>rmdir practice</tt> <p> This will delete the
		  last remnants of your practice session.

	    </enumlist>

	  <p>So now you know how to create, copy, move, rename, and
	    delete files and directories. You also learned some
	    shortcuts, like typing simply <tt>cd</tt> to jump to your
	    home directory, and <tt>.</tt> and <tt>..</tt> to refer to
	    the current directory and its parent, respectively. You
	    should also remember the concept of the <em>root
	    directory</em>, or <tt>/</tt>, and the alias <tt>~</tt>
	    for your home directory.

      <sect id="basics-processes"> Processes 

	<p>We mentioned before that GNU/Linux is a
	  <em>multitasking</em> system. It can do many tasks at
	  once. Each of these tasks is called a <em>process</em>.  The
	  best way to get a sense of this is to type <tt>top</tt> at
	  the shell prompt. You'll get a list of processes, sorted
	  according to how much of the computer's processing time
	  they're using. The order will continuously change before
	  your eyes. At the top of the display, there's some
	  information about the system: how many users are logged in,
	  how many total processes there are, how much memory you have
	  and how much you're using.

	<p>In the far left column, you'll see the user owning each
	  process. The far right column shows which command invoked
	  the process. You'll probably notice that <tt>top</tt>
	  itself, invoked by you, is near the top of the list (since
	  anytime <tt>top</tt> checks on CPU usage, it will be active
	  and using CPU to do the check). 

	<p>Note all the commands ending in <tt>d</tt> --- such as
	  <tt>kflushd</tt> and <tt>inetd</tt> --- the <tt>d</tt>
	  stands for <em>daemon</em>. A daemon is a non-interactive
	  process, that is, it's run by the system and users never
	  have to worry about it. Daemons provide services like
	  internet connectivity, printing, or email.

	<p>Now press <tt>u</tt> and give <tt>top</tt> your user name
	  when it asks. The <tt>u</tt> command asks to see only those
	  processes belonging to you; it allows you to ignore all the
	  daemons and whatever other people are doing. You might
	  notice <tt>bash</tt>, the name of your shell. You'll pretty
	  much always be running <tt>bash</tt>.

	<p>Note that column two of the <tt>top</tt> display shows you
	  the <em>PID</em>, or process ID number. Each process is
	  assigned a unique PID. You can use the PID to control
	  individual processes --- more on that later. Another useful
	  trick: type "?" to get a list of <tt>top</tt> commands.

	<p>You may wonder about the difference between a "process" and
	  a "program" --- in practice people use the terms
	  interchangeably. Technically, the <em>program</em> is the
	  set of instructions written by a programmer, and kept on
	  disk. The <em>process</em> is the working instantiation of
	  the program kept in memory by Linux. But it's not that
	  important to keep the terms straight.

	<p>Much of your interaction with a computer involves
	  controlling processes. You'll want to start them, stop them,
	  and see what they're up to. Your primary tool for this is
	  the <em>shell</em>.

      <sect id="basics-shell"> The shell 

        <p>The <em>shell</em> is a program that allows you to interact
	  with your computer.  It's called a shell because it provides
	  an environment for you to work in --- sort of a little
	  electronic home for you as you compute. (Think
	  hermit crab.) 

	<p>The simplest function of the shell is to launch other
	  programs. You type the name of the program you want to 
	  run, followed by the arguments you want, and the shell 
	  asks the system to run the program for you.

	<p>Of course, graphical windowing systems also fill this
	  need. Technically, Windows 95 provides a graphical shell,
	  and the X Window System is another kind of graphical shell
	  --- but "shell" is commonly used to mean "command line
	  shell."

	<p>Needless to say, the hackers who work on shells aren't
	  satisfied with simply launching commands. Your shell has 
	  a bewildering number of convenient features if you want to
	  take advantage of them.

	<P>There are countless different shells available; most are
	  based on either the <em>Bourne shell</em> or the <em>C
	  shell</em>, two of the oldest shells. The original Bourne
	  shell's program name is <prgn>sh</prgn> while
	  <prgn>csh</prgn> is the C shell. Bourne shell variants
	  include the Bourne Again Shell from the GNU project
	  (<tt>bash</tt>, the Debian default), the Korn shell
	  (<prgn>ksh</prgn>), and the Z shell
	  (<prgn>zsh</prgn>). There is also <prgn>ash</prgn>, a
	  traditionalist implementation of the Bourne shell. The most
	  common C shell variant is <prgn>tcsh</prgn> (the <tt>t</tt>
	  pays tribute to the TENEX and TOPS-20 operating systems,
	  which inspired some of <tt>tcsh</tt>'s improvements over
	  <tt>csh</tt>).

	<p>Bash is probably the best choice for new users. It is the
	  default, and has all the features you're likely to need. But
	  all the shells have loyal followings; if you want to
	  experiment, install some different shell packages and change
	  your shell with the <prgn>chsh</prgn> command. Just type
	  <tt>chsh RET</tt>, supply a password when asked, and chose a
	  shell. When you next log in, you'll be using the new shell.

      <sect id="basics-jobs"> Managing processes with
	  Bash
	  
	<p>Debian is a multitasking system, so you need a way to do
	  more than one thing at once. Graphical environments like X
	  provide a natural way to do this; they allow multiple
	  windows on the screen at any one time. Naturally, Bash (or
	  any other shell) provides similar facilities.
	  
	<p>Earlier you used <prgn>top</prgn> to look at the different
	  processes on the system. Your shell provides some convenient
	  ways to keep track of only those processes you've started
	  from the command line. Each command line starts a
	  <em>job</em> (also called a <em>process group</em>) to be
	  carried out by the shell. A job can consist of a single
	  process or a set of processes in a <em>pipeline</em> ---
	  more on pipelines later. [FIXME xref]

	<p>Entering a command line will start a job. Try typing
	  <tt>man cp</tt> and the <tt>cp</tt> man page will appear on
	  the screen. The shell will go into the background, and
	  return when you finish reading the man page (or type
	  <tt>q</tt> to quit rather than scrolling through the whole
	  thing).

	<p>But say you're reading the man page, and you want to do
	  something else for a minute. No problem. Type <tt>C-z</tt>
	  while you're reading to <em>suspend</em> the currently
	  foregrounded job, and put the shell in the foreground.  When
	  you suspend a job, Bash will first give you some information
	  on it, and then a shell prompt. You will see something like
	  this on the screen:

<example>
NAME
       cp - copy files

SYNOPSIS
       cp [options] source dest
       cp [options] source... directory
       Options:
       [-abdfilprsuvxPR]  [-S backup-suffix] [-V {numbered,exist
       ing,simple}]   [--backup]   [--no-dereference]   [--force]
       [--interactive] [--one-file-system] [--preserve] [--recur
       sive]  [--update]   [--verbose]   [--suffix=backup-suffix]
       [--version-control={numbered,existing,simple}] [--archive]
       [--parents] [--link]  [--symbolic-link]  [--help]  [--ver
       sion]

DESCRIPTION
--More--
[1]+  Stopped                 man cp
&dollar; 
</example>
	  
	<p>Note the last two lines. The next-to-last is the job
	  information, and then you have a shell prompt.

	<p>Bash assigns a <em>job number</em> to each command line you
	  run from the shell. This allows you to refer to the process
	  easily. In this case, <tt>man cp</tt> is job number 1,
	  displayed as <tt>[1]</tt>. The <tt>+</tt> means that this is
	  the last job you had in the foreground. Bash also tells you
	  the current state of the job --- <tt>Stopped</tt> --- and
	  the job's command line.
	  
	<p>There are many things you can do with jobs. With <tt>man
	cp</tt> still suspended, try this:
	  
	  <enumlist>
	    <item><tt>man ls</tt> <p> Start a new job.
		
	    <item><tt>C-z</tt> <p> Suspend the <tt>man ls</tt> job by
		pressing Control and lowercase <tt>z</tt>; you should
		see its job information.

	    <item><tt>man mv</tt> <p> Start yet another job.

	    <item><tt>C-z</tt> <p> Suspend it.
		
	    <item><tt>jobs</tt> <p> Ask Bash for a display of current
	    jobs:

<example>
&dollar; jobs
[1]   Stopped                 man cp
[2]-  Stopped                 man ls
[3]+  Stopped                 man mv
&dollar; 
</example>

		Notice the <tt>-</tt> and <tt>+</tt>, denoting the
		last and next-to-last foregrounded jobs.

	    <item><tt>fg</tt> <p> Place the last foregrounded job
		(<tt>man mv</tt>, the one with the <tt>+</tt>) in the
		foreground again. If you press the spacebar, the man
		page will continue scrolling.

	    <item><tt>C-z</tt> <p> Re-suspend <tt>man mv</tt>.

	    <item><tt>fg %1</tt> <p>You can refer to any job by
		  placing a <tt>%</tt> in front of its number. If you
		  use <tt>fg</tt> without specifying a job, the last
		  active one is assumed.

	    <item><tt>C-z</tt> <p> Re-suspend <tt>man cp</tt>.

	    <item><tt>kill %1</tt> <p> Kill off job 1. Bash will
		report the job information:
<example>
&dollar; kill %1
[1]-  Terminated              man cp
&dollar; 
</example>

		Bash is only asking the job to quit, and sometimes a
		job will not want to do so. If the job doesn't
		terminate, you can add the <tt>-9</tt> option to kill
		to stop asking and start demanding. For example:

<example>
&dollar; kill -9 %1
[1]-  Killed                  man mv
&dollar; 
</example>

		The <tt>-9</tt> option forcibly and unconditionally
		kills off the job. <footnote>In technical terms,
		<tt>kill</tt> simply sends a signal. By default it
		sends a signal which requests termination
		(<tt>TERM</tt>, or signal 15); but you can also
		specify a signal, and signal 9 (<tt>KILL</tt>) is the
		signal which forces termination. The command name
		<tt>kill</tt> is not necessarily appropriate to the
		signal sent; for example, sending the <tt>TSTP</tt>
		(terminal stop) signal suspends the process but allows
		it to be continued later.</footnote>

	    <item><tt>top</tt> <p> Bring the <tt>top</tt> display back
		up. Give the <tt>u</tt> command in <tt>top</tt> to see
		only your processes.  Look in the right-hand column
		for the <tt>man ls</tt> and <tt>man mv</tt>
		commands. <tt>man cp</tt> won't be there since you
		killed it. <tt>top</tt> is showing you the system
		processes corresponding to your jobs; notice that the
		PID on the left of the screen does not correspond to
		the job number.

	      <p>You may not be able to find your processes because
		they're off the bottom of the screen; if you're using
		X, you can resize the <tt>xterm</tt> to solve this
		problem.

	      <p>Even these simple jobs actually consist of multiple
		processes, including the <tt>man</tt> process and the
		pager <tt>more</tt> which handles scrolling a page at
		a time. You may notice the <tt>more</tt> processes are
		also visible in <tt>top</tt>.

	  </enumlist>

	<p>You can probably figure out how to clean up the remaining
	  two jobs. You can either kill them (with the <tt>kill</tt>
	  command) or foreground each one (with <tt>fg</tt>) and exit
	  it. Remember that the <tt>jobs</tt> command will tell you 
	  the list existing jobs and their status.

	<p>One final note: the documentation for Bash is quite good,
	  but it is found in the Info help system rather than the man
	  pages. To read it, type <tt>info bash</tt>. See <ref
	  id="docs-info"> for instructions on using the <tt>info</tt>
	  program. 

      <sect id="basics-bash"> A few Bash features
	
	  <p>This section mentions just a few of the most commonly
	  used Bash features; for a more complete discussion see <ref
	  id="shell">.

	<sect1 id="basics-bash-completion"> Tab Completion

	  <p>The Bash shell can guess what filename or command you are
	    trying to type, and automatically finish typing it for
	    you. Just type the beginning of a command or filename, and
	    press <tt>TAB</tt>. If Bash finds a single unique
	    completion, it will finish the word and put a space after
	    it. If it finds multiple possible completions, it will
	    fill out the part all completions have in common and
	    beep. You can then enter enough of the word to make it
	    unique, and press <tt>TAB</tt> again. If it finds no
	    completions, it will simply beep.

	<sect1> More features? If not then eliminate this section.

      <sect id="basics-identity"> Managing your identity
	  
	<p>Unix-like systems are multiuser, and so you have your own
	  electronic identity as a user on the system. Type <tt>finger
	  <var>yourusername</var></tt> to have a look at some of the
	  information about you that's publically available. To change
	  the name and shell listed there, you can use the commands
	  <tt>chfn</tt> and <tt>chsh</tt>. Only the superuser can
	  change your login (username) and directory. You'll notice
	  that it says "No plan" --- a "plan" is just some information
	  you can make available to others. To create a plan, put
	  whatever information you want people to see in a file called
	  <tt>.plan</tt> --- to do this you'll use a text editor (see
	  <ref id="editor">). Then finger yourself to see your
	  plan. Others can finger you to see your plan, and to check
	  whether you've received new mail or read your mail.

	<p>Note that this finger information is available to the
	  entire Internet by default. If you don't want this, read
	  about configuring <tt>inetd</tt> and the file
	  <tt>/etc/services</tt> --- eventually the installation
	  manual will describe this configuration, for now you might
	  try the man pages, or just put nonsense in for your finger
	  information.

    <chapt id="docs"> <heading>  Reading documentation and getting
	help </heading>

      <sect id="docs-sources"> Kinds of documentation 

	<p>Unfortunately documentation on Unix-like systems is a
	little disorganized. On Debian, you can find documentation in
	at least the following places:
	  <list>
	   
	    <item> <tt>man</tt> pages, read with the <tt>man</tt>
		command.
		
	    <item> <tt>info</tt> pages, read with the <tt>info</tt>
		command.

	    <item>The <tt>/usr/doc/<var>package</var></tt>
		directories, where <var>package</var> is the name of
		the Debian package.
	    
	    <item><tt>/usr/doc/HOWTO/</tt> contains the Linux
		Documentation Project's HOWTO documents, if you've
		installed the Debian packages containing them.

	    <item> Many commands have a <tt>-h</tt> or <tt>--help</tt>
		option. Type the command name followed by one of these
		options to try it.

	    <item>The Debian Documentation Project has written some
		manuals, including this one. Check out <url
		name="their home page" id="
		http://www.debian.org/~elphick/ddp/">.

	    <item>The <url id="http://www.debian.org/support/"
			   name="Debian support page"> has a FAQ and
		other resources. You can also try the 
		<url id="http://www.linux.org" name="Linux web site">.
	    
	    <item>You can buy many proprietary books with helpful
		information. Most people praise the O'Reilly brand
		very highly. However, do consider supporting freely
		modifiable and redistributable manuals such as this
		one when possible.  If you want hard copy, purchasing
		free manuals from the Free Software Foundation
		(available at many bookstores, such as Borders, and
		direct from the FSF) supports the creation of more
		free software.
	  </list>
	  
	<p>The confusing variety of documentation sources exists for
	  many reasons. For example, <tt>info</tt> is supposed to
	  replace <tt>man</tt>, but <tt>man</tt> hasn't disappeared
	  yet. However, it's nice to know that so much documentation
	  exists!

	<p>So where to look for help? Here are some suggestions:
	  <list>

	    <item> Use the <tt>man</tt> pages and the <tt>--help</tt>
		option to get a quick summary of a command's syntax
		and options. Also use <tt>man</tt> if a program
		doesn't yet have an <tt>info</tt> page.

	    <item> Use <tt>info</tt> if a program has <tt>info</tt>
		documentation.

	    <item> If neither of those work, look in
		<tt>/usr/doc/<var>packagename</var></tt>.

	    <item> <tt>/usr/doc/<var>packagename</var></tt> often has
		Debian-specific information, even if there's a man
		page or info page.

	    <item> Use the <tt>HOWTOs</tt> for instructions on how to
		set up a particular thing, or information on your
		particular hardware. For example, the Ethernet HOWTO
		has a wealth of information on ethernet cards, and the
		PPP HOWTO explains in detail how to set up PPP.

	    <item> Use the Debian Documentation Project manuals for
		conceptual explanations and Debian-specific
		information.

	    <item> If all else fails, ask someone. See <ref
		id="docs-support">.
	  </list>

	<p>Using <tt>man</tt> pages is discussed above in <ref
	    id="basics-commandline">. (It's very simple: press the
	    spacebar to go to the next page, and press <tt>q</tt> to
	    quit reading.) <tt>info</tt>, viewing files in
	    <tt>/usr/doc</tt>, and asking for help from a person are
	    all discussed in this chapter.

      <sect id="docs-info"> Using info

	<p>A brief keystroke summary/tutorial, mention TkInfo,
	  apologize for ridiculous keystrokes.

      <sect id="docs-textfiles"> Viewing text files with more and less

	<p>Use these to view some docs. Mention zless and when to use
	it.


      <sect id="docs-howtos">HOWTOs 
	  
	<p>In addition to their books, the Linux Documentation Project
	  has made a series of short documents describing how to set
	  up a particular aspect of GNU/Linux. For instance, the
	  SCSI-HOWTO describes some of the complications of using SCSI
	  --- a standard way of talking to devices --- with
	  GNU/Linux. In general, the HOWTOs have more specific
	  information about particular hardware configurations, and
	  will be more up to date than this manual.

	<p>There is a Debian package for the HOWTOs. If you've
	  installed it, you should have them in
	  <tt>/usr/doc/HOWTO</tt>. However, you may be able to find
	  more recent versions on the net on the <url name="LDP
	  Project home page" id="http://sunsite.unc.edu/LDP/">.

      <sect id="docs-support"> Getting help from a person

	<p>The correct place to ask for help with Debian is the
	  debian-user mailing list
	  <email>debian-user@lists.debian.org</email>.  If you know
	  how to use IRC (Internet Relay Chat), there is a
	  <tt>#debian</tt> channel on <tt>irc.debian.org</tt>. You can
	  find general GNU/Linux help on the <tt>comp.os.linux.*</tt>
	  Usenet hierarchy. You can search past Usenet questions and
	  answers with the <url id="http://www.dejanews.com"
	  name="DejaNews service">. It is also possible to hire paid
	  consultants to provide guaranteed support services.  <url
	  id="http://www.debian.org" name="The Debian web site"> has
	  more information on many of these resources.
	  
	<p>Again, please <em>do not</em> ask the authors of this
	  tutorial for help. We probably don't know the answer to your
	  specific problem anyway; if you mail <tt>debian-user</tt>,
	  you will get higher-quality responses, and more quickly.

	<p>Always be polite and make an effort to help yourself by
	  reading the documentation. Remember, Debian is a volunteer
	  effort and people are doing you a favor by giving their time
	  to help you. Many of them charge hundreds of dollars for the
	  same services during the day. 

	<sect1 id="docs-support-posting"> Dos and Don'ts of asking a
	    question
	 
	  <p>
	    <list>

	      <item> DO read the obvious documentation first. Things
		  like command options and what a command does will be
		  there.

	      <item> DO check the HOWTO documents if your question is
		  about setting up something, such as PPP or Ethernet.

	      <item> DO try to be sure the answer isn't in this
		  tutorial (though we realize an index would be
		  helpful---we're working on it!).

	      <item> DON'T be afraid to ask, after you've made a basic
		  effort to look it up.

	      <item> DON'T be afraid to ask for conceptual
		  explanations, advice, and other things not often
		  found in the documentation.

	      <item> DO include any information that seems
		  relevant. You'll almost always want to mention the
		  version of Debian you're using. You may also want to
		  mention the version of any pertinent packages: the
		  command <tt>dpkg --status
		  <var>packagename</var></tt> will tell you this. It's
		  also useful to say what you've tried so far and what
		  happened. Please include the exact error messages,
		  if any.

	      <item> DON'T apologize for your ignorance, or make
		  excuses for being a newbie. There's no reason
		  everyone should be a GNU/Linux expert to use it, any
		  more than everyone should be a mechanic to use a
		  car.

	      <item> DON'T post or mail in HTML. Some versions of
		  Netscape and Internet Explorer will post in HTML
		  rather than plain text. Most people will not even
		  read these posts, because they are difficult to read
		  in most mail programs. There should be a setting
		  somewhere in the preferences to disable HTML.

	      <item> DO be polite. Remember that Debian is an
		  all-volunteer effort, and anyone who helps you is
		  doing it just because they're a nice person. 

	      <item> DO re-mail your question to the list if you've
		  gotten no responses after several days. Perhaps
		  there were lots of messages and it was
		  overlooked. Or perhaps no one knows the answer ---
		  if no one answers the second time, this is a good
		  bet. You might want to try including more
		  information the second time.
		 
	      <item> DO answer questions yourself, when you know the
		  answer. Debian depends on everyone doing their part
		  --- if you ask a question, and later on someone else
		  asks the same question, you'll know how to answer
		  it. Do so!
	    </list>

      <sect id="docs-sysinfo"> Getting information from the system

	<p> When diagnosing problems or asking for help, you'll need
	  to get information about your system. Here are some ways to
	  do so.

	<p> /var/log/*, dmesg, uname -a


    <chapt id="shell"> <heading>  Using the shell </heading>

      <sect id="shell-jobs"> More on job control

	<p>Fill in job control details not covered earlier, kill -9.
	  Kill works on the PID.

      <sect id="shell-variables"> Environment variables
	  
	<p>Every process has an <em>environment</em> associated with
	  it. An environment is a collection of <em>environment
	  variables</em>. A variable is a changeable value with a
	  fixed name. For example, the name <tt>EMAIL</tt> could refer
	  to the value <tt>joe@nowhere.com</tt>. The value can vary
	  --- <tt>EMAIL</tt> could also refer to
	  <tt>jane@somewhere.com</tt>.

	<p>Since your shell is a process like any other, it has an
	  environment. You can view your shell's environment by
	  entering the <tt>printenv</tt> command. Here's some example
	  output:

	<p>

<example>
PAGER=less
HOSTNAME=icon
MAILCHECK=60
MOZILLA_HOME=/usr/local/lib/netscape
PS1=$ 
USER=hp
MACHTYPE=i486-pc-linux-gnu
EDITOR=jed
DISPLAY=:0.0
LOGNAME=hp
EMAIL=hp@pobox.com
SHELL=/bin/bash
HOSTTYPE=i486
OSTYPE=linux-gnu
HISTSIZE=150
HOME=/home/hp
TERM=xterm-debian
TEXEDIT=jed
PATH=/home/hp/local/bin:/usr/sbin:/home/hp/.bin:/home/hp/local/bin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:.
_=/usr/bin/printenv
</example>

	<p>On your system, the output will be different, but similar.

	<p>Environment variables are one way to configure the
	  system. For example, the <tt>EDITOR</tt> variable lets you
	  select your preferred editor for posting news, writing
	  email, and so on. The <tt>HISTSIZE</tt> variable tells Bash
	  how many command lines to keep in its history; you can
	  return to that many command lines with the up arrow key.

	<p>Setting environment variables is simple. Once you learn
	  how, you'll probably want to set them automatically whenever
	  you log on; see <ref id="custom_shell"> for instructions.

	<p>For practice, try customizing your shell's prompt and your
	  text file viewer with environment variables:
	  
	<p><enumlist>

	    <item><tt>man less</tt> <p> View the online manual for the
		<tt>less</tt> command. In order to show you the text
		one screenful at a time, <tt>man</tt> invokes a
		<em>pager</em> which shows you a new page of text each
		time you press the space bar. By default, it uses the
		pager called <tt>more</tt>. 

	      <p>Go ahead and glance over the man page for
		<tt>less</tt>, which is an enhanced pager. Scroll to a
		new page by pressing space; press <tt>q</tt> to
		quit. <tt>more</tt> will also quit automatically when
		you reach the end of the man page.

	    <item><tt>export PAGER=less</tt><p>After reading about
		the advantages of <tt>less</tt>, you might want to use
		it to read man pages. To do this, you set the
		environment variable <tt>PAGER</tt>. 

	      <p>The command to set an environment variable always
		has this format: <tt>export
		  <var>NAME</var>=<var>value</var></tt>.
		
	      <p> <tt>export</tt> means to move the variable from the
		shell into the environment. This means that programs
		other than the shell will be able to access it.

	    <item><tt>echo $PAGER</tt> <p> This is the easiest way to
		see the value of a variable. <tt>$PAGER</tt> tells the
		shell to insert the value of the <tt>PAGER</tt>
		variable <em>before</em> invoking the
		command. <tt>echo</tt> echoes back its argument: in
		this case, the it echoes the current <tt>PAGER</tt>
		value, <tt>less</tt>.

	    <item><tt>man more</tt> <p> Read the <tt>more</tt>
		manual. This time, <tt>man</tt> should have invoked the
		<tt>less</tt> pager. 

	      <p><tt>less</tt> has lots of features <tt>more</tt>
		lacks. For example, you can scroll backward with the
		<tt>b</tt> key. You can also move up and down (even
		sideways) with the arrow keys. <tt>less</tt> won't
		exit when it reaches the end of the man page; it will
		wait for you to press <tt>q</tt>.

	    <item><tt>PAGER=more man more</tt> <p> If you want a
		different setting temporarily, you can put a new value
		in effect for the current command line only. Put the
		<tt><var>NAME</var>=<var>value</var></tt> at the start
		of the command line, followed by the command to
		execute. Be sure to omit <tt>export</tt>.

	      <p>You can try out some <tt>less</tt>-specific commands,
		like <tt>b</tt>, to verify that they don't work with
		<tt>more</tt> and you are indeed using <tt>more</tt>.

	    <item><tt>echo $PAGER</tt> <p> The value of <tt>PAGER</tt>
		should still be <tt>less</tt>; the above setting was
		only temporary.

	    <item><tt>unset PAGER</tt> <p>If you don't want to specify
		a pager anymore, you can <tt>unset</tt> the
		variable. <tt>man</tt> will then use <tt>more</tt> by
		default, just as it did before you set the variable.
		
	    <item><tt>echo $PAGER</tt> <p>Since <tt>PAGER</tt> has
		been unset, <tt>echo</tt> won't print anything.

	    <item><tt>PS1=hello:</tt> <p> Just for fun, change your
		shell prompt. <tt>$</tt> should become
		<tt>hello:</tt>. 

	      <p><tt>export</tt> is not necessary, because we're
		changing the shell's own behavior. There's no reason
		to export the variable into the environment for other
		programs to see. Technically, <tt>PS1</tt> is a
		<em>shell variable</em> rather than an environment
		variable.

	      <p>If you wanted to, you could <tt>export</tt> the shell
		variable, transforming it into an environment
		variable. Then other programs could see it:
		specifically, the <em>children</em> of the current
		shell process. The next section explains this.

	  </enumlist>
	  
	<sect1 id="shell-variables-parents"> Parent and child processes

	  <p>All processes come from an earlier process, called
	    their <em>parent process</em>. 

	    <footnote> You may see a chicken and egg problem
		here. There is an original process that starts all the
		others; it's process number 1, <tt>init</tt>. You can
		see it running by typing <tt>ps u 1</tt>.  
	    </footnote>

	    The <prgn>ps</prgn> command is a useful tool for exploring
	    processes, and it can be used to examine parent-child
	    relationships.
	  
	    <enumlist>
	      <item><tt>ps f</tt> <p> This command asks to see a list of
		  processes belonging to you, in a format that shows how
		  processes are related. 
	    </enumlist>
	    
	  <p><tt>ps f</tt> might produce output like this:
	  
<example>
$ ps f
$ ps f
  PID  TT STAT   TIME
 7270  p5 S      0:00 bash
15980  p5 R      0:00  \_ ps f
19682  p4 S      0:00 bash
15973  p4 S      0:00  \_ man ps
15976  p4 S      0:00      \_ sh -c /bin/gzip -dc '/var/catman/cat1/ps.1.gz' | { export MAN_PN LESS; MAN_PN='ps(1)'; LESS="$LESS\$-Pm\:\$i
15977  p4 S      0:00          \_ /bin/gzip -dc /var/catman/cat1/ps.1.gz
15978  p4 S      0:00          \_ sh -c /bin/gzip -dc '/var/catman/cat1/ps.1.gz' | { export MAN_PN LESS; MAN_PN='ps(1)'; LESS="$LESS\$-Pm\
15979  p4 S      0:00              \_ less
$ 
</example>
	  
	  <p> Here you can see that I have a number of processes
	    running, including two shells. The shells have child
	    processes: shell process 7270 has child process 15980
	    (<tt>ps f</tt>) and shell 19682 has child process 15973
	    (<tt>man ps</tt>).  <tt>man ps</tt> has in turn invoked a
	    complex set of subprocesses in order to display a man
	    page. Don't worry about what these subprocesses do for
	    now.
	    
	  <p> Parents and children have a complex relationship. Most
	    of the time, when a parent dies the child will die as
	    well. So you can kill a whole set of processes --- for
	    example, all the <tt>man ps</tt> children in the above
	    example --- by killing the parent process, 15973.

	  <p> Children inherit the environment variables of their
	    parents, and some other attributes such as the current
	    working directory.

	  <p> When a shell runs a command, it spawns the command as a
	    child process. So the <tt>man</tt> command inherits the
	    shell's environment; if you've set the <tt>PAGER</tt>
	    variable, <tt>man</tt> will be able to see it. 

	  <p>If you fail to <tt>export</tt> a variable, only the shell
	    itself will see it, and it will not be passed on to
	    children such as <tt>man</tt>.

      <sect id="shell-path"> Where commands live: the <tt>PATH</tt>
	  variable

	<p>When you type a command into the shell, it has to find the
	  program on your hard disk before executing it. If the shell
	  had to look all over the disk, it would be very slow;
	  instead, it looks in a list of directories contained in the
	  <tt>PATH</tt> environment variable. This list of directories
	  makes up the shells' <em>search path</em>; when you enter a
	  command, it goes through each one in turn looking for the
	  program you asked to run.

	<p>You may need to change the <tt>PATH</tt> variable if you
	  install programs yourself in a nonstandard location.

	<p>The value of <tt>PATH</tt> is a colon-separated list of
	  directories. The default value on Debian systems is:
	  
<example>
/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games  
</example>

	<p>This value is defined in the file <tt>/etc/profile</tt> and
	  applies to all users. You can easily change the value, just
	  as you can change any environment variable.

	<p>If you type the command <tt>ls</tt>, the shell will first
	  look in <tt>/usr/local/bin</tt>; <tt>ls</tt> isn't there, so
	  it will try <tt>/usr/bin</tt>; when that fails, it will
	  check <tt>/bin</tt>. There it will discover
	  <tt>/bin/ls</tt>, stop its search, and execute the program
	  <tt>/bin/ls</tt>. If <tt>/usr/bin/X11/ls</tt> existed (it
	  doesn't, but pretend), it would be ignored.

	<p>You can see which <tt>ls</tt> the shell is going to use
	  with the <tt>type</tt> command. <tt>type ls</tt> will give
	  you the answer <tt>/bin/ls</tt> --- try it yourself.

	<p>Try asking where <tt>type</tt> itself resides:

<example>
$ type type
type is a shell builtin
</example>

	<p><tt>type</tt> isn't actually a program; it's a function
	  provided by the shell. However, you use it just like an
	  external program. 

	<p>There are a number of commands like this; type <tt>man
	    builtins</tt> to read the man page describing them. In
	    general, you don't need to know whether a command is a
	    builtin or a real program; however, builtins will not show
	    up in the output of <tt>ps</tt> or <tt>top</tt> since they
	    aren't separate processes. They're just part of the shell.


      <sect id="custom_shell-aliases"> Aliases and shell functions

	<p>If you use the same command often, you might get tired of
	  typing it. <tt>bash</tt> lets you write shorter
	  <em>aliases</em> for your commands. You can also write
	  <em>shell functions</em>, which are custom commands made up
	  of several other commands.

	<p>Say you always use the <tt>--almost-all</tt> and
	  <tt>--color=auto</tt> options to <tt>ls</tt>. You quickly
	  get tired of typing <tt>ls --almost-all
	  --color=auto</tt>. So you make an alias:

	<p>

<example>
alias myls='ls --almost-all --color=auto'   
</example>

	<p>Now you can type <tt>myls</tt> instead of the full command.
	  To see what <tt>myls</tt> really is, run the command
	  <tt>type myls</tt>. To see a list of aliases you've defined,
	  type simply <tt>alias</tt> on a line by itself.

	<p>Shell functions are a little more flexible than aliases. An
	  alias simply substitutes a longer command when you type a
	  shorter one. Functions let you use a series of commands to
	  perform some action.

	<p>First let's see how a shell function could be used in place
	  of the above alias:

<example>
myls() {
    ls --almost-all --color=auto $*
}
</example>

	<p>The above is called a <em>function definition</em>, because
	  it gives a function name (<tt>myls</tt>), then defines the
	  meaning of the name (some commands to execute).  To define a
	  function, write its name, followed by <tt>()</tt>. Then
	  include the commands to execute inside braces
	  (<tt>{}</tt>). The portion inside braces is known as the
	  <tt>body</tt> of the function.

	<p>The arguments to the function can be referred to as
	  <tt>$*</tt>. So if you type:

<example>
myls /usr  /etc
</example>

	  <tt>$*</tt> will be <tt>/usr  /etc</tt>, the two
	  arguments. If there are no arguments, <tt>$*</tt> will be
	  empty. 

	<p>You can also refer to the arguments by number. So
	  <tt>$1</tt> in the function body would be replaced by
	  <tt>/usr</tt>, and <tt>$2</tt> would be replaced by
	  <tt>/etc</tt>. Type in this function (you can type it at the
	  shell prompt; hit return after each line):

	<p>

<example>
print_arguments() {
    echo "First argument:   $1"
    echo "Second argument:  $2"
    echo "All arguments:    $*"
}
</example>

	<p>You can verify you entered the function definition
	  correctly with the <tt>type</tt> command; <tt>type
	  print_arguments</tt> should say:

	<p>

<example>
print_arguments is a function
print_arguments () 
{ 
    echo "First argument:   $1";
    echo "Second argument:  $2";
    echo "All arguments:    $*"
}
</example>

	<p>Try the function out. If you enter <tt>print_arguments one
	  two</tt> it will display:
	  
	<p>

<example>
First argument:   one
Second argument:  two
All arguments:    one two
</example>

	<p>There are many more complex things you can do in a shell
	  function; you're limited only by your imagination.  For
	  more, see <ref id="advanced-scripting">. 

      <sect id="shell-io"> Controlling input and output
	<p>Stdin, stdout, pipelines, and redirection

	<p>Every process has at least three connections to the outside
	  world. The <em>standard input</em> is one source of the
	  process's data; the <em>standard output</em> is one place
	  the process sends data; and the <em>standard error</em> is a
	  place the process can send error messages. (These are often
	  abbreviated <tt>stdin</tt>, <tt>stdout</tt>, and
	  <tt>stderr</tt>.)
	  
	<p>The words `source' and `place' are intentionally
	  vague. These standard input and ouput locations can be
	  changed by the user; they could be the screen, the keyboard,
	  a file, even a network connection. The user can specify
	  which locations to use.

	<p>When you run a program from the shell, usually standard
	  input comes from your keyboard and standard output and error
	  both go to your screen. However, you can ask the shell to
	  change these defaults.

	<p>For example, the <tt>echo</tt> command sends it output to
	  standard output, normally the screen. But you can send it to
	  a file instead, with the <em>output redirection
	  operator</em>, '<tt>&gt;</tt>'. For example, to put the word
	  "Hello" in the file <tt>myfile</tt>:

<example>
echo Hello &gt; myfile
</example>

	<p>Use <tt>cat</tt> or your text file pager to view
	  <tt>myfile</tt>'s contents.

	<p>You can change the standard input of a command with the
	  <em>input redirection operator</em>, '<tt>&lt;</tt>'. For
	  example, <tt>more &lt; myfile</tt> will display the contents
	  of <tt>myfile</tt>. This is not useful in practice; for
	  convenience, the <tt>more</tt> command accepts a filename
	  argument. So you can simply say <tt>more myfile</tt> and 
	  the effect will be the same. 

	<p>Under the hood, <tt>more &lt; myfile</tt> means that the
	  shell opens <tt>myfile</tt>, then feeds its contents to the
	  standard input of <tt>more</tt>. <tt>more myfile</tt>,
	  without the redirection operator, means that the
	  <tt>more</tt> command receives one argument,
	  <tt>myfile</tt>, opens the file itself, and then displays
	  the file.

	<p>There's a reason for the double functionality, however. For
	  example, you can connect the standard output of one command
	  to the standard input of another. This is called a
	  <em>pipeline</em>, and it uses the <em>pipe operator</em>,
	  '<tt>|</tt>'.

	<p>Perhaps you want to see the GNU General Public
	  License in reverse. To do this, you use the <tt>tac</tt>
	  command (it's <tt>cat</tt>, only backward). Try it out:
<example>
tac /usr/doc/copyright/GPL
</example>

	<p>Unfortunately, it goes by too quickly to read. So you only
	  get to see a couple of paragraphs. The solution is a
	  pipeline:

<example>
tac /usr/doc/copyright/GPL | more
</example>

	<p>This takes the standard output of <tt>tac</tt>, which is
	  the GPL in reverse, and sends it to the standard input of
	  <tt>more</tt>.

	<p>You can chain as many commands together as you like. Say
	  you have an inexplicable desire to replace every <tt>G</tt>
	  with <tt>Q</tt>; for this you use the command <tt>tr G
	  Q</tt>, like this:

<example>
tac /usr/doc/copyright/GPL | tr G Q | more
</example>

	<p>You could get the same effect using temporary files and
	  redirection. For example:

<example>
tac /usr/doc/copyright/GPL > tmpfile
tr G Q < tmpfile > tmpfile2
more < tmpfile2
rm tmpfile tmpfile2
</example>
	  
	<p>Clearly a pipeline is more convenient. 

      <sect id="shell-modifiers"> Specifying how and when to run
	commands <p>"modifiers" like batch, at, nohup, nice
	  
      <sect id="shell-wildcards"> Filename expansion ("Wildcards")

	<p>Often you want a command to work with a group of files.
	  "Wildcards" are used to create a <em>filename expansion
	  pattern</em>: a series of characters and wildcards that
	  expands to a list of filenames. For example, the pattern
	  <tt>/etc/*</tt> expands to a list of all the files in
	  <tt>/etc</tt> <footnote>Actually, files beginning with
	  <tt>.</tt> are not included in the expansion of
	  <tt>*</tt></footnote>. <tt>*</tt> is a wildcard which can
	  stand for any series of characters, so the pattern
	  <tt>/etc/*</tt> will expand to a list of all the filenames
	  beginning with <tt>/etc/</tt>.

	<p>This filename list is most useful as a a set of arguments
	  for a command. For example, the <tt>/etc</tt> directory
	  contains a series of subdirectories called <tt>rc0.d</tt>,
	  <tt>rc1.d</tt>, etc. Normally to view the contents of these,
	  you would type:

<example>
ls /etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d /etc/rc5.d /etc/rc6.d /etc/rcS.d
</example>

	<p>This is tedious. Instead, you can use the <tt>?</tt>
	  wildcard:

<example>
ls /etc/rc?.d
</example>

	<p><tt>/etc/rc?.d</tt> expands to a list of filenames which
	  begin with <tt>rc</tt>, followed by any single character,
	  followed by <tt>.d</tt>.

	<p>Available wildcards are:
	  
	  <taglist>
	    <tag><tt>*</tt><item>Matches any group of 0 or more
		characters

	    <tag><tt>?</tt><item>Matches exactly one character

	    <tag><tt>[...]</tt><item>If you enclose some characters in
		brackets, the result is a wildcard which matches those
		characters. For example, <tt>[abc]</tt> matches either
		a, or b, or c. If you add a <tt>^</tt> after the first
		bracket, the sense is reversed; so <tt>[^abc]</tt>
		matches any character that is not a, b, or c. You can
		include a range, such as <tt>[a-j]</tt>, which matches
		anything between a and j. The match is case sensitive, 
		so to allow any letter, you must use
		<tt>[a-zA-Z]</tt>.

	  </taglist>

	<p>Expansion patterns are simple, once you see some concrete
	  examples:

	  <taglist>

	    <tag><tt>*.txt</tt><item>This will give you a list of 
		any filename which ends in <tt>.txt</tt>, since the 
		<tt>*</tt> matches anything at all.

	    <tag><tt>*.[hc]</tt><item>This gives a list of filenames
		which end in either <tt>.h</tt> or <tt>.c</tt>.

	    <tag><tt>a??</tt><item>This gives you all three-letter
		filenames that begin with <tt>a</tt>.

	    <tag><tt>[^a]??</tt><item>This gives you all three-letter
		filenames that do <em>not</em> begin with <tt>a</tt>.

	    <tag><tt>a*</tt> <item> This gives you every filename that
		starts with <tt>a</tt>, regardless of how many letters
		there are.

	  </taglist>

      <sect id="shell-quoting"> Quoting
	<p> When to quote and why 

      <sect> Interactive/non-interactive FIXME move this

	<P>Bash has two different modes: <em>interactive</em> and
	  <em>non-interactive</em>.  Interactive means you can type
	  into them, and have them do things for you.  Non-interactive
	  shells interpret shell scripts, similar to DOS batch files.
	  You give it a list of commands to carry out, and it goes and
	  does them, but without your intervention. You don't see all
	  the commands being typed in, Of course any output will be
	  recorded somewhere (the standard output, or stdout, normally
	  the screeen or a log file).  We will get more into
	  non-interactive shells a little later on.
	
	<sect1 id="interactive-shells">Interactive shells

	  <P>Interactive shells will take a very long time for one to
	    master, just because they're so powerful --- you'll
	    probably never learn everything!  There is just so much
	    out there that a shell can do, and of course it's always
	    changing.  We will talk about <tt>bash</tt> here, and some
	    basic commands that will make your life with a
	    shell easier.  In bash, one can have several different
	    things going on all at once, and this can get confusing.

	  <P>A shell is a Line Oriented or command line environment.
	    The shell will always prompt you with a prompt, whenever
	    it is waiting on you to do things.  The default debian
	    prompt is a $.
	    At the $ prompt is where you can type in
	    commands to tell linux to do things, it can be a program
	    name, or it can be a "builtin" command that the shell
	    provides for your convenience.

    <chapt id="files"> <heading>  More on files </heading>

      <p> In <ref id="basics-files"> we covered moving/renaming files
	with <tt>mv</tt>, copying them with <tt>cp</tt>, removing them
	with <tt>rm</tt>, removing directories with <tt>rmdir</tt>,
	and creating directories with <tt>mkdir</tt>. This chapter
	will cover some more aspects of files.

      <sect id="files-permissions"> Permissions

	<p> GNU and Unix systems are set up to allow many people to
	  use the same computer, while keeping certain files private
	  or keeping certain people from modifying certain files. You
	  can verify this for yourself:

	  <enumlist>
	    <item> Log in as yourself, i.e. <em>NOT</em> as root. 

	    <item> <tt>whoami</tt> <p> Verifies that you are not root.

	    <item> <tt>rm /etc/resolv.conf</tt> <p> You should be told
		"Permission denied." <tt>/etc/resolv.conf</tt> is an
		essential system configuration file --- you aren't
		allowed to change or remove it unless you're
		root. This keeps you from accidentally messing up the
		system, and if the computer is a public one such as at
		an office or school, it keeps users from messing up
		the system on purpose.

	  </enumlist>

	<p>Now type <tt>ls -l /etc/resolv.conf</tt> <p> This will give
	  you output that looks something like this:
	  
	<p>

<example>
-rw-r--r-- 1 root root 119 Feb 23 1997 /etc/resolv.conf
</example>
	  
	<p>The <tt>-l</tt> option to <tt>ls</tt> requests all that
	  additional information.  The info on the right is easy - the
	  size of the file is 119 bytes, the date the file was last
	  changed is Feb 23 1997, the file's name is
	  <tt>/etc/resolv.conf</tt>. On the left side of the screen,
	  things get a little more complicated.

	<p> First, the brief, technical explanation: the
	  <tt>-rw-r--r--</tt> is the <em>mode</em> of the file, the
	  <tt>1</tt> is the number of hard links to this file (or the
	  number of files in a directory), and the two <tt>root</tt>
	  are the user and group owning the file.

	<p> So that was cryptic. Let's go through it slowly (except
	  the hard links part --- for that see <ref
	  id="advanced-files-hardlinks">).

	<sect1 id="files-permissions-groups"> File Ownership
	    
	  <p> Every file has two owners --- a user, and a group. The
	    above case is a little confusing, since there's a group
	    called <tt>root</tt> in addition to the <tt>root</tt>
	    user. Groups are just collections of users who are
	    collectively permitted access to some part of the system.
	    A good example is a <tt>games</tt> group. Just to be mean,
	    you might set up your system so that only people in a
	    <tt>games</tt> group are allowed to play games.

	  <p> A more practical example: say you're setting up a
	    computer for a school.  You might want certain files to be
	    accessible only to teachers, not students, so you put all
	    the teachers in a single group. Then you can tell the
	    system that certain files belong to members of the group
	    <tt>teachers</tt>, and that no one else can access those
	    files. 

	  <p>Here are some things you can do to explore groups on
	    your system:
	    
	  <enumlist>

	    <item> <tt>groups</tt> <p> Typing this at the shell prompt
		will tell you what groups you're a member of. It's
		likely that you're a member of only one group, which
		is identical to your username.

	    <item> <tt>more /etc/group</tt> <p> This file lists the
		groups that exist on your system. Notice the
		<tt>root</tt> group (the only member of this group is
		the root user), and the group which corresponds to
		your username. There are also groups like
		<tt>dialout</tt> (users who are allowed to dial out on
		the modem), and <tt>floppy</tt> (users who can use the
		floppy drive). However, your system is probably not
		configured to make use of these groups --- it's likely
		that only root can use the floppy or the modem right
		now. For details about this file, try reading <tt>man
		group</tt>.

	    <item> <tt>ls -l /home</tt> <p> Observe how every user's
		directory is owned by that user and that user's
		personal group. (If you just installed Debian, you may
		be the only user.)

	  </enumlist>

	</sect1>
	
	<sect1 id="files-permissions-mode"> Mode
 
	  <p> In addition to being owned by one user and one group,
	    every file and directory also has a mode, which determines
	    who's allowed to read, write, and execute the file. There
	    are a few other things also determined by the mode, but
	    they're advanced topics so we'll skip them for now.
	    
	  <p> The mode looks like this in the <tt>ls</tt> output:
	    <tt>-rw-r--r--</tt>. There are ten "spaces" here, and the
	    mode actually consists of twelve bits (think of bits as
	    switches which can be on or off). But for now, we'll
	    consider only nine of these bits: those that control
	    <em>read</em>, <em>write</em>, and <em>execute</em>
	    permissions for the <em>user</em> owning the file, the
	    <em>group</em> owning the file, and <em>others</em>
	    (everyone on the system, sometimes called <em>world</em>).
	    
	  <p>Notice that three kinds of permission (read, write,
	    execute) times three sets of people who can have permission
	    (user, group, others) makes a total of nine combinations.
	    
	  <p> In the mode line, the first "space" gives the type of the
	    file. The <tt>-</tt> in this case means it's a regular
	    file. If it was <tt>d</tt>, we'd be looking at a
	    directory. There are other possibilities too complex to go
	    into now (see <ref id="advanced-files-permissions">).

	  <p> The remaining nine "spaces" are used to display the 12
	    bits that make up the file's mode. The basic 9 bits (read,
	    write, and execute for user, group, and other) are displayed
	    as three blocks of <tt>rwx</tt>. 

	  <p>So if all permissions are turned on and this is a regular
	    file, the mode will look like this:
	    <tt>-rwxrwxrwx</tt>. If it was a directory with all
	    permissions turned off for others and full permissions for
	    user and group, it would be <tt>drwxrwx---</tt>.

	    (The remaining three bits are displayed
	    by changing the <tt>x</tt> to <tt>s</tt>, <tt>t</tt>,
	    <tt>S</tt>, or <tt>T</tt>, but this is a complex topic we're
	    saving for <ref id="advanced-files-permissions">.)

	  <p> For regular files, "read", "write", and "execute" have
	    the following meanings:

	    <list>
	      <item> Read permission, indicated by <tt>r</tt>, gives
		  permission to examine the contents of a file. For
		  directories, it gives permission to list the contents
		  of the directory.

	      <item> Write permission, indicated by <tt>w</tt>, gives
		  permission to make changes to a file. For directories,
		  it gives permission to create and remove files in the
		  directory.

	      <item> Execute permission, indicated by <tt>x</tt>, gives
		  permission to run the file as a command. Clearly it
		  only makes sense to set execute permission if the file
		  actually is a command.

		<p> Since directories can never be executed, the
		  execute bit has a different meaning. For
		  directories, execute permission means permission to
		  access files in the directory. Note that this
		  interacts with write permissions: execute
		  permissions must be set to be able to access files
		  in a directory <em>at all</em>, so without execute
		  permission on a directory, write permission is
		  useless. Execute permission for directories is often
		  called "search" permission, since it really has
		  nothing to do with execution. "File access"
		  permission would probably be a still better name.
	    </list>

	  <p> Directory modes are a little confusing, so here are some
	    examples of the effects of various combinations:

	    <list>
	      <item> <tt>r--</tt> <p> The user, group, or other with
		  these permissions may list the contents of the
		  directory, but nothing else. The files in the
		  directory can't be read, changed, deleted, or
		  manipulated in any way. The only permitted action is
		  reading the directory itself, that is, seeing what
		  files it contains.

	      <item> <tt>rw-</tt> <p> Write permission has no effect in
		  the absence of execute permission, so this mode behaves
		  just like the above mode.

	      <item> <tt>r-x</tt> <p> This mode permits the files in a
		  directory to be listed, and permits access to those
		  files. However, files can't be created or
		  deleted. <em>Access</em> means that you can view,
		  change, or execute the files as permitted by the
		  files' own permissions.

	      <item> <tt>--x</tt> <p> Files in this directory can be
		  accessed, but the contents of the directory can't be
		  listed, so you have to know what filename you're
		  looking for in advance (unless you're a good
		  guesser). Files can't be created or deleted.

	      <item> <tt>rwx</tt> <p> You can do anything you want with
		  the files in this directory, as long as it's permitted
		  by the permissions on the files themselves.

	    </list>

	  <p> Directory write permission determines whether you can
	    delete files in a directory --- a read-only file can be
	    deleted, if you have permission to write to the directory
	    containing it. You can't delete a file from a read-only
	    directory, even if you're allowed to make changes to the
	    file. File permissions have nothing to do with deleting
	    files.
	    
	  <p> This also means that if you own a directory you can
	    always delete files from it, even if those files belong to
	    root.
	    
	  <p>Directory execute permission determines whether you have
	    access to files --- and thus whether file permissions come
	    into play.  <em> If </em> you have execute permissions to
	    a directory, file permissions for that directory become
	    relevant. Otherwise file permissions just don't matter;
	    you can't access the files anyway.
	    
	  <p> If you have execute permission for the directory, file
	    permissions determine whether you can read the contents of
	    the file, change the file, and/or execute the file as a
	    command.
	    
	  <p> FIXME: Are the next two paragraphs correct?
	    
	  <p> Finally, permission to change permissions on a file or
	    directory is not affected by the permissions of that file
	    or directory. Rather, you can always change the
	    permissions on files or directories that you own, but not
	    on files owned by someone else, as long as you are
	    permitted access to the file. So if you can access a file
	    you own at all (that is, you have execute permission for
	    the directory containing it) then you can change its
	    permissions.
	    
	  <p> This means that you can't permanently remove permissions
	    from yourself because you can always give them back. Say
	    you remove user write permission from a file you own, then
	    try to change the file. It won't be permitted, but you can
	    always give yourself write permission again and
	    <em>then</em> change the file. The only way to lose the
	    ability to change permissions back is to lose access to
	    the file entirely.
	    
	</sect1>

	<sect1 id="files-permissions-tutorial"> Permissions in
	    practice
	    
	  <p> This section goes through a short example session to
	    demonstrate how permissions are used.

	  <p> To change permissions, we'll use the <tt>chmod</tt> command.

	    <enumlist>
	      
	      <item> <tt>cd; touch myfile</tt> <p> There are a couple
		  of new tricks here. First, you can use <tt>;</tt> to
		  put two commands on one line.  You can type the
		  above as:

<p>
<example>
&dollar cd 
&dollar touch myfile
</example>
<p>
		or as:
<p>
<example>
&dollar cd; touch myfile
</example>

		<p>and the same thing will end up happening.

		<p> Recall that <tt>cd</tt> by itself returns you to
		  your home directory.  <tt>touch</tt> is normally
		  used to change the modification time of the file to
		  the current time, but it has another interesting
		  feature: if the file doesn't exist, <tt>touch</tt>
		  creates the file. So we're using it to create a file
		  to practice with.  Use <tt>ls -l</tt> to confirm
		  that the file has been created, and notice the
		  permissions mode:

<p>
<example>
&dollar ls -l 
-rw-r--r-- 1 havoc havoc 0 Nov 18 22:04 myfile
</example>

		<p>Obviously the time and user/group names will be
		  different when you try it. The size of the file is
		  0, since <tt>touch</tt> creates an empty
		  file. <tt>-rw-r--r--</tt> is the default permissions
		  mode on Debian (you can change this - see FIXME: add
		  ref to umask).

	      <item> <tt>chmod u+x myfile</tt> <p> This command means
		  to add (<tt>+</tt>) execute (<tt>x</tt>) permissions
		  for the user (<tt>u</tt>) who owns the file. Use
		  <tt>ls -l</tt> to see the effects.
		  
	      <item> <tt>chmod go-r myfile</tt> <p> Here we've
		  subtracted (<tt>-</tt>) read permission (<tt>r</tt>)
		  from the group (<tt>g</tt>) owning the file, and
		  from everyone else (others, <tt>o</tt>). Again, use
		  <tt>ls -l</tt> to verify the effects.
		  
	      <item> <tt>chmod ugo=rx myfile</tt> <p> Here we've set
		  (<tt>=</tt>) user, group, and other permissions to
		  read and execute. This sets permissions to
		  <em>exactly</em> what you've specified, and unsets
		  any other permissions. So all <tt>rx</tt> should be
		  set, and all <tt>w</tt> should be unset. Now no one
		  can write to the file.
		  
	      <item><tt>chmod a-x myfile</tt> <p> <tt>a</tt> is a
		  shortcut for <tt>ugo</tt>, or "all". So all the
		  <tt>x</tt> permissions should now be unset.
		  
	      <item> <tt>rm myfile</tt> <p> We're removing the file,
		  but without write permissions.  <tt>rm</tt> will ask
		  if you're sure:
<example>
rm: remove `myfile', overriding mode 0444?
</example>
		  
		  You should respond by typing <tt>y</tt> and pressing
		  enter.  This is a feature of <tt>rm</tt>, not a fact
		  of permissions - permission to delete a file comes
		  from the directory permissions, and you have write
		  permission in the directory. However, <tt>rm</tt>
		  tries to be helpful, figuring that if you didn't
		  want to change the file (and thus removed write
		  permission), you don't want to delete it either, so
		  it asks you.

	  </enumlist>

	  <p> What was that <tt>0444</tt> business in the question from
	    <tt>rm</tt>?  The permissions mode is a twelve-digit
	    binary number, like this: <tt>000100100100</tt>.
	    <tt>0444</tt> is this binary number represented as an
	    octal (base 8) number, which is the conventional way to
	    write a mode. So you can type <tt>chmod 444 myfile</tt>
	    instead of <tt>chmod ugo=r myfile</tt>.  This is fully
	    explained in <ref id="advanced-files-permissions">.

	</sect1>


      <sect id="files-tour"> What files are on my system? Where can I
	put my own files?

	<p>Now that you can navigate the directory tree, let's take a
	  guided tour of the files and directories you created when
	  you installed Debian. If you're curious, <tt>cd</tt> to each
	  directory and type <tt>ls</tt> to see its contents. If the
	  listing doesn't fit on the screen, try <tt>ls | more</tt>,
	  where <tt>|</tt> is the "pipe" character, generally found on
	  the same key with backslash.

	  <taglist>
	    <tag><tt>/</tt> <item> As already mentioned, this is the
		root directory, which contains every other directory.

	    <tag><tt>/root</tt> <item> But don't get <tt>/</tt>
		confused with <tt>/root</tt>! <tt>/root</tt> is the
		home directory of the root user, or superuser. It's a
		directory called <tt>/root</tt>, but it isn't
		<em>the</em> root directory <tt>/</tt>.

	    <tag> <tt>/home</tt> 

	    <item> This is where all normal users --- that is, all
		users except root --- have their home
		directories. Home directories are named after the user
		who owns them, for example, <tt>/home/jane</tt>. If
		you're using a large system at a school or business,
		your system administrator may create additional
		directories to contain home directories:
		<tt>/home1</tt> and <tt>/home2</tt> for example.

	      <p> Your home directory is where you put all your
		personal work, email and other documents, and personal
		configuration preferences. It's your home on the 
		system.

	    <tag> <tt>/bin</tt> <item> This directory contains
		"binaries," executable files which are essential to
		the operation of the system. Examples are the shell
		(<tt>bash</tt>), and file commands such as
		<tt>cp</tt>.

	    <tag> <tt>/sbin</tt> <item> This directory contains
		"system binaries," utilities that the root user or
		system administrator might want to use, but probably
		you won't want to use in your day-to-day activities.

	    <tag> <tt>/usr</tt> <item> <tt>/usr</tt> contains most of
		the files you'll be interested in. It has many
		subdirectories: <tt>/usr/bin</tt> and
		<tt>/usr/sbin</tt> are pretty much like <tt>/bin</tt>
		and <tt>/sbin</tt>, except that the directories in
		<tt>/usr</tt> are not considered "essential to the
		operation of the system." 

	      <p> While not essential to get the computer
		working,<tt>/usr</tt> does contain the applications
		you'll use to get real work done. Also in
		<tt>/usr</tt> you'll find the <tt>/usr/man</tt>,
		<tt>/usr/info</tt>, and <tt>/usr/doc</tt> directories
		--- these contain manual pages, info pages, and other
		documentation, respectively. And don't forget
		<tt>/usr/games</tt>!

	    <tag> <tt>/usr/local</tt> <item> The Debian system doesn't
		install anything in this directory. You should use it
		if you want to install software that you compile
		yourself, or any software not contained in a Debian
		package. You can also install software in your home
		directory, if you'll be the only one using it.

	    <tag> <tt>/etc</tt> <item> <tt>/etc</tt> contains all the
		system-wide configuration files. Whenever you want to
		change something that affects all users of your
		computer --- such as how you connect to the internet,
		or what kind of video card you have --- you'll
		probably have to log on as root and change a file in
		<tt>/etc</tt>.

	    <tag> <tt>/tmp</tt> <item> Here you'll find temporary
		files, most of them created by the system. This
		directory is generally erased on a regular basis, or
		every time you reboot the system. You can create files
		here if you want, just be aware they might get deleted
		automatically.

	    <tag> <tt>/var</tt> <item> <tt>/var</tt> contains
		"variable" files, that the system changes
		automatically. For example, incoming mail is stored
		here. The system keeps a log of its actions
		here. There are a number of other automatically
		generated files here as well. You'll mostly be
		interested in the contents of <tt>/var/log</tt>, where
		you can find error messages and try to figure out what
		you're system's up to if something goes wrong.

	  </taglist>

	<p>
	  Clearly there are many more directories on the system, too
	  many to describe every one.

	<p>
	  For changing things, you'll usually want to confine yourself
	  to your home directory and <tt>/etc</tt>. On a Debian
	  system, there's rarely an occasion to change anything else,
	  because everything else is automatically installed for you.

	<p> <tt>/etc</tt> is used to configure the <em>system</em> as
	  a whole. You'll use your own home directory, a subdirectory
	  of <tt>/home</tt>, for configuring your own preferences, and
	  storing your personal data. The idea is that on a day-to-day
	  basis you confine yourself to <tt>/home/yourname</tt>, so
	  there's no way you can break anything. Occasionally you log
	  in as root to change something in a system-wide directory,
	  but only when absolutely necessary. Of course, if you're
	  using Debian at a school or business and someone else is the
	  system administrator, you won't have root access and will
	  only be able to change your home directory. This limits what
	  you can do with the system.

      <sect id="files-manager"> Using a filemanager 

	<p>Instead of moving files around by hand, you can use a
	  <em>file manager</em>. If you move a lot of files around a
	  file manager can make your work more efficient. There are
	  text-based file managers, such as the GNU Midnight
	  Commander (type <tt>mc</tt>), and a number of file managers
	  for the X Window System. 
	  
	<p>Describing each of these is outside the scope of this
	  manual; but you may want to try them out if the command line
	  doesn't meet your needs.

    <chapt id="editor"> <heading> Creating and editing text files
    </heading>

      <sect id="editor-textfile"> What's a text file?  

	<p>A <em>text file</em> is simply a normal file that happens
	  to contain human-readable text. There's nothing special
	  about it otherwise. The other kind of file, a binary file,
	  is meant to be interpreted by the computer.
	  
	<p>You can view either kind of file with the <prgn>less</prgn>
	  file pager, if you have it installed (install it if you
	  haven't, it's quite useful). Type <tt>less /etc/profile</tt>
	  to view a sample text file --- notice that you can read the
	  characters, even if their meaning is obscure. Type <tt>less
	  /bin/ls</tt> to view a binary file; as you can see, the
	  <tt>ls</tt> program is not meant to be read by humans.

	<p>The difference between the two kinds of files is purely a
	  matter of what they contain, unlike some other systems (such
	  as DOS or MacOS) which actually treat the files differently.

	<p>Text files can contain shell scripts, documentation,
	  copyright notices, or any other human-readable
	  text. 

	<p>Incidentally, this illustrates the difference between
	  <em>source code</em> and <em>binary
	  executables</em>. <tt>/bin/ls</tt> is a binary executable
	  you can download from Debian, but you can also download a
	  text file which tells the computer how to create
	  <tt>/bin/ls</tt>. This text file is the source
	  code. Comparing <tt>/bin/ls</tt> to <tt>/etc/profile</tt>
	  illustrates how important source code is if someone wants to
	  understand and modify a piece of software. Free software
	  provides you or your consultants with this all-important
	  source code.

      <sect id="editor-editor"> Text editors 

	<p>A <em>text editor</em> is a program used to create and
	  change the contents of text files. Most operating systems
	  have a text editor; DOS has <prgn>edit</prgn>, Windows has
	  <prgn>Notepad</prgn>, and MacOS has <prgn>SimpleText</prgn>.

	<p>Debian provides a bewildering variety of text
	  editors. <prgn>vi</prgn> and Emacs are the classic two,
	  probably both the most powerful and the most widely used.
	  Both <prgn>vi</prgn> and Emacs are quite complex and require
	  some practice, but they can make editing text extremely
	  efficient. Emacs runs both in a terminal and under the X
	  Window System; <prgn>vi</prgn> normally runs in a terminal
	  but the <prgn>vim</prgn> variant has a <tt>-g</tt> option
	  which allows it to work with X.

	<p>Simpler editors include <prgn>nedit</prgn>,
	  <prgn>ae</prgn>, <prgn>jed</prgn>, and
	  <prgn>xcoral</prgn>. <prgn>nedit</prgn> and
	  <prgn>xcoral</prgn> provide easy-to-use X Window System
	  graphical interfaces. There are also several <prgn>vi</prgn>
	  variants, and an Emacs variant called XEmacs.

	<p>This tutorial will not cover the use of any particular
	  editor in detail, though we will briefly introduce
	  <prgn>vi</prgn> since it is small, fast, nearly always
	  available, and you may need to use it sometime regardless of
	  your preferred editor. Emacs provides an excellent
	  interactive tutorial of its own; to read it, load Emacs with
	  the <tt>emacs</tt> command and type <tt>F1 t</tt>.  Emacs is
	  an excellent choice for new users interested in a
	  general-purpose or programming editor.

      <sect id="editor-vi"> Creating and editing a text file
	  with <prgn>vi</prgn>

	<p><prgn>vi</prgn> (pronounced "vee eye") is really the only
	  editor that comes with almost every Unix-like operating
	  system, and Debian is no exception. <prgn>vi</prgn> was
	  originally written at the University of California at
	  Berkeley. The editor's name is short for "visual," referring
	  to the fact that <prgn>vi</prgn> provides a visual display
	  of the text file; this was once considered a unique feature,
	  giving you an idea how old the program is.

	<p><prgn>vi</prgn> is somewhat hard to get used to, but has
	  many powerful features. In general, we suggest that a new
	  user use Emacs for daily tasks such as programming. However,
	  <prgn>vi</prgn> is sometimes more convenient or the only
	  available editor; it is also a much smaller file to
	  download. 

	<p>The following discussion of <prgn>vi</prgn> should also
	  apply to <prgn>vi</prgn> variants such as <prgn>elvis</prgn>
	  and <prgn>vim</prgn>.

	<sect1 id="editor-vi-creating">Creating a file

	  <p>
	    <enumlist>
	      
	      <item><tt>vi testfile</tt> 
		<p>In your home directory, invoke vi by typing
		<tt>vi</tt> followed by the name of the file you wish
		to create. You will see a screen with a column of
		tildes (<tt>~</tt>) along the left
		side. <prgn>vi</prgn> is now in command mode.
		Anything you type will be understood as a command, not
		as content to add to the file. In order to input text,
		you must type a command.
		  
	      <item><tt>i</tt> <p>The two basic input commands are
		  <tt>i</tt>, which means "insert the text I'm about
		  to type to the left of the cursor," and <tt>a</tt>,
		  which means "append the text I'm about to type to
		  the right of the cursor." Since you are at the
		  beginning of an empty file, either of these would
		  work. We picked <tt>i</tt> arbitrarily.

	      <item>Type in some text; here's a profound statement
		  from philosopher Charles Sanders Peirce, if you
		  can't think of your own:
		<p>

<example>
And what, then, is belief? It is the demi-cadence 
which closes a musical phrase in the symphony of our 
intellectual life.  We have seen that it has just 
three properties: First, it is something that we are
aware of; second, it appeases the irritation of doubt; 
and, third, it involves the establishment in our 
nature of a rule of action, or, say for short, a 
habit.
</example>

		<p>Press <tt>RET</tt> after each line, since
		  <tt>vi</tt> will not move to the next line
		  automatically; when you finish typing, press the
		  <tt>ESC</tt> key to leave insert or append mode and
		  return to command mode.

	      <item><tt>:wq</tt> <p> If you've done everything
		  correctly, when you type this command it should
		  appear at the bottom of your screen, below all the
		  <tt>~</tt> characters. The <tt>:</tt> tells
		  <prgn>vi</prgn> you're about to give a series of
		  commands; the <tt>w</tt> means to write the file
		  you've just typed in --- in most new programs this
		  is called "save" --- and the <tt>q</tt> means to
		  quit <prgn>vi</prgn>. So you should be back at the
		  shell prompt. 
		  
	      <item><tt>cat testfile</tt> <p> <tt>cat</tt> will
		  display the file you typed on the screen. 

	    </enumlist>
		  
	  <p> Don't remove <tt>testfile</tt>, we'll use it in the next 
	    tutorial section.
	    
	  <p> As you use <prgn>vi</prgn>, always remember that
	    pressing <tt>ESC</tt> will return you to command mode. So
	    if you get confused, press <tt>ESC</tt> a couple times and
	    start over.

	  <p> <prgn>vi</prgn> has an annoying tendency to beep
	    whenever you do something you aren't supposed to, like
	    type an unknown command; don't be alarmed by this.

	<sect1 id="editor-vi-editing"> Editing an existing file

	  <p>To use <tt>vi</tt>, you only need to read 
	    <ref id="editor-vi-editing-movement">
	    and <ref id="editor-vi-editing-deletion">. Later sections
	    explain advanced features, but they are not strictly 
	    necessary, though often more efficient and less tedious.
	    
	  <sect2 id="editor-vi-editing-movement"> Moving around in a
	      file
	      
	    <p> To move around in a file, Debian's <prgn>vi</prgn>
	      allows you to use the arrow keys. The traditional keys
	      also work, however; they are <tt>h</tt> for left,
	      <tt>j</tt> for down, <tt>k</tt> for up, and <tt>l</tt>
	      for right. These keys were chosen because they are
	      adjacent on on the home row of the keyboard, and thus
	      easy to type. Many people use them instead of the arrow
	      keys since they're faster to reach with your fingers.

	    <p> <enumlist>

		<item><tt>vi testfile</tt><p> Open the file you
		    created earlier with <prgn>vi</prgn>. You should
		    see the text you typed before.
		    
		<item>Move around the file with the arrow keys or the
		    <tt>hjkl</tt> keys. If you try to move to far in
		    any direction, <prgn>vi</prgn> will beep and
		    refuse to do so; if you want to put text there,
		    you have to use an insertion command like
		    <tt>i</tt> or <tt>a</tt>.

		<item><tt>:q</tt><p>Exit <prgn>vi</prgn>.

	      </enumlist>

	  <sect2 id="editor-vi-editing-deletion"> Deleting text
	      
	    <p>
	      <enumlist>
		
		<item><tt>vi testfile</tt> <p>Open your practice file
		again.
		    
		<item><tt>dd</tt> <p> The <tt>dd</tt> command deletes
		    a line; the top line of the file should be gone
		    now.
		    
		<item><tt>x</tt> <p> <tt>x</tt> deletes a single
		    character; the first letter of the second line
		    will be erased. Delete and backspace don't work in
		    <prgn>vi</prgn>, for historical reasons. Some
		    <prgn>vi</prgn> variants, such as <prgn>vim</prgn>
		    will let you use backspace and delete.
		    
		<item><tt>10x</tt> <p> If you type a number before a
		    command, it will repeat the command that many
		    times. So this will delete 10 characters.
		    
		<item><tt>2dd</tt> <p> You can use a number with the
		    <tt>dd</tt> command as well, deleting two lines.
		    
		<item><tt>:q</tt> <p> This will cause an error,
		    because you've changed the file but haven't saved 
		    yet. There are two ways to avoid this; you can 
		    <tt>:wq</tt>, thus writing the file as you quit,
		    or you can quit without saving:

		<item><tt>:q!</tt> <p>With an exclamation point, you
		    tell <prgn>vi</prgn> that you really mean it,
		    and it should quit even though the file isn't
		    saved. If you use <tt>:q!</tt> your deletions will
		    not be saved to <tt>testfile</tt>; if you use
		    <tt>:wq</tt>, they will be. 

		<item><tt>cat testfile</tt><p>Back at the shell
		    prompt, view <tt>testfile</tt>. It should be
		    shorter now, if you used <tt>:wq</tt>, or be
		    unchanged if you used <tt>:q!</tt>.
		    
	      </enumlist>

	    <p><tt>:q!</tt> is an excellent command to remember,
	      because you can use it to bail out if you get hopelessly
	      confused and feel you've ruined the file you were
	      editing. Just press <tt>ESC</tt> a few times to be sure
	      you're in command mode and then type <tt>:q!</tt>. This
	      is guaranteed to get you out of <prgn>vi</prgn> with no
	      damage done.

	    <p>You now know everything you need to do basic editing;
	      insertion, deletion, saving, and quitting. The following
	      sections describe useful commands for doing things
	      faster; you can skip over them if you like.

	  <sect2 id="editor-vi-editing-moremoving"> Sophisticated
	      movement

	    <p>There are many motion commands, here's a quick summary:

	    <p>
	      <taglist>

		<tag><tt>w</tt> <item> Move to the start of the next
		    word

		<tag><tt>e</tt> <item>Move to the end of the next word
		    
		<tag><tt>E</tt> <item> Move to the end of the next
		    word before a space

		<tag><tt>b</tt> <item> Move to the start of the
		previous word
		    
		<tag><tt>0</tt> (zero) <item> Move to the start of the
		    line
		    
		<tag><tt>^</tt> <item> Move to the first word of the
		    current line

		<tag><tt>$</tt> <item> Move to the end of the line

		<tag><tt>RET</tt> <item> Move to the start of the next
		    line

		<tag><tt>-</tt> <item> Move to the start of the
		    previous line
		    
		<tag><tt>G</tt> <item> Move to the end of the file
		    
		<tag><tt>1G</tt> <item> Move to the start of the file
		    
		<tag><tt><var>n</var>G</tt> <item> Move to line number
		<var>n</var>

		<tag><tt>C-G</tt> <item> Display the current line
		    number
		    
		<tag><tt>H</tt> <item> Top line of the screen
		    
		<tag> <tt>M</tt> <item> Middle line of the screen

		<tag><tt>L</tt> <item> Bottom of the screen
		    
		<tag><tt><var>n</var>|</tt><item> Move cursor to
		    column <var>n</var>

	      </taglist>

	    <p>The screen will automatically scroll when the cursor
	      reaches either the top or the bottom of the
	      screen. There are alternative commands which can control
	      scrolling the text.

	      <p>
	      <taglist>

		<tag><tt>C-f</tt> <item> Scroll forward a screen

		<tag><tt>C-b</tt> <item> Scroll backward a screen

		<tag><tt>C-d</tt> <item> Scroll down half a screen

		<tag><tt>C-u</tt> <item> Scroll down half a screen
		    
	      </taglist>

	    <p>

	  <sect2 id="editor-vi-editing-numbers"> Repeating commands

	    <p>As mentioned above you can often prefix a command with
	      a number to repeat that command multiple times. For
	      example, the <tt>l</tt> key moves left; <tt>10l</tt>
	      moves you left 10 positions to the left. 

	    <p>If you wanted to enter a number of spaces in front of
	      the some text you could use a number with the insert
	      command. Enter the number <var>n</var> then <tt>i</tt>
	      followed by <tt>SPACE</tt> and <tt>ESC</tt>. You should
	      get <var>n</var> spaces.

	    <p>The commands that deal with lines use a number to refer
	      to line numbers.  The <tt>G</tt> is a good example; if
	      you preface it with a number it will go to that line.

	  <sect2 id="editor-vi-editing-advanced"> Advanced reference 
	      <p>FIXME move to appendix?

	    <p> This section gives a more comprehensive list of
	      commands you can use. It is just a reference; if you
	      want, try the commands out to see what they do.

	    <p>Insertion commands:
	      
	      <taglist>

		<tag><tt>a</tt><item> Append to the right of the
		cursor

		<tag><tt>A</tt><item> Append at the end of the line

		<tag><tt>i</tt><item> Insert text to the left of the
		cursor

		<tag><tt>I</tt><item> Insert text to the left of the
		first non-blank character on current line
		

		<tag><tt>o</tt><item> Open a new line below the
		current line and insert text 

		<tag><tt>O</tt><item> Open a new line above the
		current line and insert text

	      </taglist>

	    <p>Deletion commands:
	      
	      <taglist>
		
		<tag><tt>x</tt> <item>Delete the character under the
		cursor

		<tag><tt>dw</tt> <item>Delete from the current
		position to the end of the word

		<tag><tt>dd</tt><item>Delete the current line.
		    
		<tag><tt>D</tt><item>Delete from the current position
		to the end of the line

	      </taglist>

	    <p>Commands in combination can be more powerful. In
	      particular, <tt>d</tt> followed by a motion command
	      deletes from the cursor to wherever you asked to
	      move. Some examples:
	      <taglist>
		
		<tag>
		  <tt>d<var>n</var>w</tt><item>Deletes <var>n</var>
		    words (<tt><var>n</var>dw</tt> works too)

		<tag><tt>dG</tt><item>Delete from the current position
		to the end of the file
		
		<tag><tt>d1G</tt><item>Delete from the current postion
		to the start of the file
		
		<tag><tt>d$</tt> <item>Delete from current postion to
                    the end of the line (same as <tt>D</tt>)
		    
		<tag><tt>d<var>n</var>$</tt><item>Delete from current
		    line the end of the <var>n</var>th line
		    
	      </taglist>

	    <p>Undo commands:

	      <taglist>

		<tag><tt>u</tt><item> Undo the last command
		    
		<tag><tt>U</tt><item> Undo all change to the current
		    line
		    
		<tag><tt>:e!</tt><item> "Edit again." Like quitting
		    with <tt>:q!</tt> and restarting --- returns you
		    to the last time you did a <tt>:w</tt> to save.
		    
	      </taglist>

	    <p>You can undo an undo, so <tt>uu</tt> results in an
	      undone undo, or no change.
	      
	    <p>Replacement commands:
	      
	      <taglist>

		<tag><tt>r<var>c</var></tt><item> Replace the
                    character under the cursor with <var>c</var> 

		<tag><tt>R</tt><item> Overwrites text

		<tag><tt>cw</tt><item> Changes the current
                    word

		<tag><tt>c$</tt><item> Changes text from current
                    position to end of the line

		<tag><tt>c<var>n</var>w</tt><item> Changes next
                    <var>n</var> words.(same as <var>n</var>cw)

		<tag><tt>c<var>n</var>$</tt><item> Changes to the end
                    of the <var>n</var>th line

		<tag><tt>C</tt><item> Changes to
                    the end of the line (same as <var>c$</var>)
		    
		<tag><tt>cc</tt><item> Changes the current line

		<tag><tt>s</tt><item> Substitutes text you type
                    for the current character 

		<tag><tt><var>n</var>s</tt><item> Substitutes text you
                    type for the next <var>n</var> characters
		    
	      </taglist>

	    <p>The commands in the above list which allow you to enter 
	      more than a single character of text have to be exited
	      with the <tt>ESC</tt> key, returning you to command mode.

	    <p>Cut and paste involves first <em>yanking</em> (cutting
	      or copying) some text and placing it in a buffer (or
	      "clipboard"); then moving to the desired new location;
	      then pasting the text.
	      
	    <p>To cut text use the <tt>y</tt> command and its
	      variants:
	      
	      <taglist>

		<tag><tt>yy</tt><item>Yank a copy of the current line

		<tag><tt><var>n</var>yy</tt><item> Yank the next
		    <var>n</var> lines

		<tag><tt> yw</tt><item> Yank a word

		<tag><tt> y<var>n</var>w</tt><item> Yank <var>n</var>
		    words

		<tag><tt> y$</tt><item> Yank the text between the
		    cursor and the end of the line

	      </taglist>

	      <p>Paste commands:

	      <taglist>

		<tag><tt>p</tt><item>    Paste to the right of the cursor

		<tag><tt>P</tt><item>    Paste to the left of the cursor

		<tag><tt><var>n</var>P</tt><item> Paste <var>n</var>
		    copies to the left of the cursor

	      </taglist>

	    <p> When using <prgn>vi</prgn> within an xterm or using a
	      variant of <prgn>vi</prgn> that supports X, you can
	      also use the mouse to copy text. See <ref id="X"> for
	      how to copy and paste in X; be sure you're in insert
	      mode when you paste, or the pasted text will be
	      interpreted as a command.

	    <p>When you delete, the deleted text is copied to the
	      buffer (clipboard); you can then use the paste commands.
	      This allows you to cut-and-paste, while the <tt>y</tt>
	      commands result in copy-and-paste.

	    <p><prgn>vi</prgn> has commands to search for text. You
	      can also use these as movement commands, if you want to
	      move to a particular word or character.

	    <p> The simplest search commands look for characters.

	      <taglist>

		<tag><tt> f<var>c</var></tt><item> Find the next
		    character <var>c</var> to the right of or below the
		    current position

		<tag><tt>F<var>c</var></tt><item> Find the next
		    character <var>c</var> to the left of or above the
		    current position

		<tag><tt>t<var>c</var></tt><item>  Move right to character
		    before the next <var>c</var>.

		<tag><tt>T<var>c</var></tt><item>  Move left to the character
		    following the preceding <var>c</var>.

		<tag><tt>;</tt><item>Repeats the last character search
		    command

		<tag><tt>,</tt><item>Same as <tt>;</tt> but reverses
		    the direction of the orginal command.

	      </taglist>

	    <p>If the character you were searching for was not found,
	      <prgn>vi</prgn> will beep or give some other sort of signal.

	      <prgn>vi</prgn> allows you to search for any text, not
	      just a character.

	      <taglist>

		<tag><tt>/<var>text</var></tt><item>Searches right
		    and down for the next occurence of <var>text</var>.

		<tag><tt>?<var>text</var></tt><item>Searches left and
		up for the next occurance of <var>text</var>.

		<tag><tt>n</tt><item> Repeat the last<tt>/</tt> or
		<tt>?</tt> command

		<tag><tt>N</tt><item> Repeats the last <tt>/</tt> or
		<tt>?</tt> in the reverse direction

	      </taglist>

	    <p>When using the \key{/} or \key{?} commands a line will
	      be cleared along the bottom of the screen. You enter the
	      text to search for followed by <tt>RET</tt>.

	      <p>The text in the command \key{/} or \key{?} is
	      actually a <em>regular expression</em>, see <ref
	      id="text_tools-regexps">.

    <chapt id="custom_shell"> <heading> Customizing the shell
    </heading>

      <sect id="custom_shell-dotfiles"> .rc files and ls -a
	<p>What they're for, why they're hidden, etc.

      <sect id="custom_shell-login"> Login shell vs. non-login shell
	<p> The difference, which files to edit for each

      <sect id="custom_shell-profile"> Editing .bash_profile <p>A
	little tutorial, perhaps set up some common environment
	variables or handy aliases.  <p>Use some neat text-editing
	tricks.  <p>describe <tt>umask</tt>

      <sect id="custom_shell-etc"> Setting system-wide defaults <p>How
	  to edit shell config files in /etc, and the difference
	  between doing that and doing it in one's own directory.

      <sect id="custom_shell-changing"> Changing your shell

	<p>Just mention the possibility, and why one might want to do
	it.

    <chapt id="X"> <heading> The X Window System </heading>

      <p>This chapter describes the X Window System graphical user
	interface. It assumes that you have already successfully
	configured X as described in the Installation Manual (again,
	the install manual is not yet written; for now you will need
	to use the XFree86 HOWTO, the contents of
	<tt>/usr/doc/X11</tt>, and this chapter). Once you install X,
	you can enter the X environment by typing <tt>startx</tt> or
	via <tt>xdm</tt>, depending on your choice during
	configuration.
		  
      <sect id="X-starting"> Starting the X environment

	<p>There are two ways of starting X. The first is to start X
	  manually when you feel like using it. To do so, log in to
	  one of the text consoles, and type <tt>startx</tt>. This
	  will start X and switch you to its VC.

	<p>The second (and recommended) way to use X is with
	  <prgn>xdm</prgn>, or X Display Manager. Basically
	  <prgn>xdm</prgn> gives you a nice graphical login
	  prompt on the X VC (probably VC 7), and you log in
	  there.

	<p>By default, either method will also start an
	  <tt>xterm</tt>, which is a small window containing a shell
	  prompt. At the shell prompt, you can type any commands just
	  as you would on a text VC. So you can follow all the
	  examples in this tutorial using <tt>xterm</tt>; the only
	  difference between an <tt>xterm</tt> and the text console is
	  that you don't have to log on to the <tt>xterm</tt>, since
	  you already logged on to X. 

	<p>There are also a lot of things you can do only in X, which
	  are covered in this chapter.
	  
	<p>One note: the default <tt>xterm</tt> has a smallish
	  font. If you have a small monitor or very high resolution or
	  bad eyesight, you may want to fix this. Follow these steps:
	  <enumlist>
	    <item> Move the mouse pointer into the center of the
		<tt>xterm</tt> window.
	    <item> Hold down the <tt>Control</tt> key and the
		<em>right</em> mouse button simultaneously. This will
		give you a font menu.
	    <item> Point to the font you want and release the mouse
		button. 
	  </enumlist>

      <sect id="X-intro"> Intro: What is X

	<p>A GUI (Graphical User Interface) is part and parcel of the
	  Windows or Mac operating systems. It's basically impossible
	  to write an application for those systems which does not use
	  the GUI, and the systems can't be used effectively from the
	  command line. GNU/Linux is more <em>modular</em>, that is,
	  made up of many small, independent components which can be
	  used or not according to one's needs and preferences. One of
	  these components is the X Window System, or simply X.
	  
	<p>X itself is a means for programs to talk to your mouse and
	  video card, without knowing what kind of mouse and video
	  card you have. That is, it's an <em>abstraction</em> of the
	  graphics hardware. User applications talk to X, in X's
	  language; X then translates into the language of your
	  particular hardware. This means that programs only have to
	  be written once, and they work on everyone's computer.

	<p>In X jargon, the program which speaks to the hardware is
	  known as an <em>X server</em>. User applications that ask
	  the X server to show windows or graphics on the screen are
	  called <em>X clients</em>. The X server includes a <em>video
	  driver</em>, so you must have an X server which matches
	  your video card.

	<p>The X server doesn't provide any of the features one might
	  expect from a GUI, such as resizing and rearranging
	  windows. A special X client, called a <em>window
	  manager</em>, draws borders and titlebars for
	  windows, resizes and arranges windows, and provides
	  facilities for starting other X clients from a menu. 
	  Specific window managers may have additional
	  features. 

	<p>Window managers available on a Debian system include
	  <tt>fvwm</tt>, <tt>fvwm2</tt>, <tt>icewm</tt>,
	  <tt>afterstep</tt>, <tt>olvwm</tt>, <tt>wmaker</tt>,
	  <tt>mwm</tt>, <tt>twm</tt>, <tt>enlightenment</tt> and
	  others. You'll probably want to try them all and pick your
	  favorite. (For information on window managers, and other fun
	  stuff about X, <url name="X11.org" id="http://www.x11.org"> is a
	  nice site.) 

	<p>Neither the X server nor the window manager provide a
	  <em>file manager</em>; that is, there aren't any windows
	  containing icons for your files and folders. You can launch
	  a file manager as a separate application; there are many
	  available, though unfortunately there aren't yet any good
	  icon-based ones.  The Gnome desktop project is developing an
	  icon-based file manager and other GUI facilities,
	  however. See <url name="the Gnome project home page"
	  id="http://www.gnome.org"> for the latest news on this.

	<p>A final feature of X is its <em>network
	    transparency</em>, meaning that X clients don't care if
	  they're talking to an X server on the same machine or an X
	  server somewhere on the network. In practical terms, this
	  means you can run a program on a more powerful remote
	  machine, but display it on your desktop computer. 
	  
      <sect id="X-basics"> Basic X operation

	<sect1 id="X-basics-mouse"> The mouse

	  <p>The mouse in X works pretty much the same as the mouse
	    on other systems, except that it has three buttons. If
	    your mouse only has two, you can simulate the third
	    (middle) button by clicking both buttons
	    simultaneously. This is kind of tricky and annoying, so
	    investing in a &dollar;15 3-button mouse probably isn't
	    a bad idea. These are available at Best Buy, MediaPlay,
	    and similar stores, as well as from dedicated computer
	    retailers.

	  <p>The buttons are numbered from left to right, assuming
	    you have a right-handed mouse, so button one is on the
	    left, two in the middle, three on the right. You may see
	    either the numbers or the locations in documentation.

	  <p>X has a simple built-in copy-and-paste facility. To
	    select text to copy, you click and drag with the left
	    mouse button. This should select the text to copy,
	    assuming the application you're using has copy-and-paste
	    support. To paste the text, you click the middle mouse
	    button in a different X application. For example, if you
	    receive an email containing an URL, you can select the URL
	    with the left button, then click in your web browser's
	    "Location" field with the middle button to paste it in.

	  <sect1 id="X-basics-clients"> X clients
	      
	  <p> Programs that communicate with the X server are called
	    X clients. Most of these programs will ask the X server
	    to display windows on the screen.
	    
	  <p> You start an X client the same way you start any other
	    Debian program. Simply type the name of the client on the
	    command line. Try typing <tt>xterm</tt> into an existing
	    xterm, and a new xterm client will appear on the screen.

	  <p> You may notice that the original xterm is now useless,
	    since your shell is waiting for the second xterm to
	    finish. To avoid this problem, you can run the X client in
	    the background --- add a <tt>&amp;</tt> after the command
	    name, like this: <tt>xterm &</tt>. If you forget, you can
	    place a running process in the background.  First suspend
	    the process with <tt>C-z</tt>, and then place it in the
	    background with the <tt>bg</tt> command.

	  <p> If you use a program often, your window manager will
	    generally provide a way to put that program on a
	    convenient graphical menu.

	<sect1 id="X-basics-trouble"> Troubleshooting 

	  <p> Sometimes when you launch an X client from a graphical
	    menu, you won't be able to see any error messages if it
	    fails. You can find any error messages in the file
	    <tt>~/.xsession-errors</tt>.
	      
	<sect1 id="X-basics-leaving"> Leaving the X environment
	    
	  <p>To leave X, you will need to use a menu. Unfortunately
	    for beginners, this is different for every window manager,
	    and for most window managers can be configured in many
	    ways.  If there's an obvious menu, look for an entry like
	    "Exit" or "Close Window Manager." If you don't see a menu,
	    try clicking each of the mouse buttons on the background
	    of the screen. If all else fails, you can forcibly kill
	    the X server by pressing <tt>C-A-Backspace</tt>. Forcibly
	    killing the server will destroy any unsaved data in open
	    applications.

      <sect id="X-startup"> Customizing your X startup 

	<p> When you start X, Debian will run some shell scripts which
	  start your window manager and other X clients.  By default,
	  a window manager, an <tt>xconsole</tt> and an <tt>xterm</tt>
	  will be started for you.
	  
	<p> To customize your X startup, the file
	  <tt>/etc/X11/config</tt> must contain the line
	  <tt>allow-user-xsession</tt>. If it does not, become root
	  and add the line now. Then log back in as yourself and
	  continue the tutorial. <footnote>You can see how Debian's X
	  startup works in the file <tt>/etc/X11/Xsession</tt>. Note
	  that the behavior of <tt>/etc/X11/Xsession</tt> can be
	  changed by modifying the file <tt>/etc/X11/config</tt>,
	  which specifies a few system-wide preferences.</footnote>

	<p> To run the clients of your choice when X starts, you
	  create an executable shell script called <tt>.xsession</tt>
	  in your home directory.
	  
	  <enumlist>
	    <item><tt>touch ~/.xsession</tt> <p> This creates the
		file.  

	    <item><tt>chmod u+x ~/.xsession</tt> <p> Make the file
		executable.
	  </enumlist>

	<p> Once <tt>.xsession</tt> is created, you need to edit it 
	  to do something useful with your favorite text editor. 
	  You can do anything you want to in this script. However,
	  when the script's process terminates, X will also
	  terminate. 

	<p> In practical terms this means that you often end the
	  script with a call to <tt>exec</tt>. [FIXME xref explaining
	  exec vs. backgrounded vs. normal] Whatever program you
	  <tt>exec</tt> will replace the script process with itself,
	  so commands found after the <tt>exec</tt> line will be
	  ignored. The program you exec will become the new "owner" of
	  the script process, which means that X will terminate when
	  this new program's process terminates.

	<p> Say you end your .xsession with the line: <tt>exec
	    fvwm</tt>.  This means that the <tt>fvwm</tt> window
	  manager will be run when X starts. When you quit the fvwm
	  window manager, your X session will end and all other
	  clients will be shut down. You do not have to use a window
	  manager here; you could <tt>exec xterm</tt>, in which case
	  typing <tt>exit</tt> in that particular xterm would cause
	  the entire X session to end.

	<p> If you want to run other clients before doing your
	  <tt>exec</tt>, you will need to run them in the
	  background. Otherwise <tt>.xsession</tt> will pause until
	  each client exits, then continue to the next line. See the
	  previous section on running jobs in the background [FIXME
	  xref] (basically you want to put an ampersand at the end,
	  e.g. <tt>xterm &amp;</tt>).

	<p> You can take advantage of this behavior, though. If you
	  want to run commands at the end of your X session, you can
	  have your <tt>.xsession</tt> run a window manager or the
	  like and wait for it to finish. That is, leave off the
	  <tt>exec</tt> and the <tt>&amp;</tt>, just put <tt>fvwm</tt>
	  by itself. Then put the commands of your choice after
	  <tt>fvwm</tt>.

	<p> It would probably help to look at a few sample
	  <tt>.xsession</tt> files. In all the examples, replace
	  <tt>fvwm</tt> with the window manager of your choice. 

	<p> The simplest <tt>.xsession</tt> just runs a window
	  manager:

<example>
exec fvwm
</example>

	  This will run fvwm, and the X session will end when fvwm
	  exits. If you do it without the <tt>exec</tt>, everything
	  will appear to behave the same way, but behind the scenes
	  <tt>.xsession</tt> will hang around waiting for fvwm, and
	  <tt>.xsession</tt> will exit after fvwm does. Using
	  <tt>exec</tt> is slightly better because fvwm replaces
	  <tt>.xsession</tt> instead of leaving it waiting. You can
	  use the <tt>ps</tt> or <tt>top</tt> command to verify this.

	<p> A more useful <tt>.xsession</tt> runs a few clients before
	  starting the window manager. For example, you might want
	  some xterms and an xclock whenever you
	  start X. No problem:

<example>
xterm &
xterm &
xclock &
exec fvwm
</example>
	  
	  Two xterms and an xclock start up in the background, and
	  then the window manager is launched. When you quit the
	  window manager, you'll also quit X.

	<p> You might try it without the backgrounding just to see
	  what happens. Do this:

<example>
xterm
xclock
exec fvwm
</example>

	  xterm will start, and wait for you to exit it. Then xclock
	  will start; you'll have to exit xclock before fvwm will
	  start. The commands are run in sequence, since the script
	  waits for each one to exit.

	<p> You can use sequential execution to your
	  advantage. Perhaps you want to keep track of when you stop
	  working every day:

<example>
xterm &
xclock &
fvwm
date &gt&gt ~/logout-time
</example>

	  This will fork off an xterm and an xclock, then run fvwm and
	  wait for it to finish. When you exit fvwm, it will move on
	  to the last line, which appends the current date and time to
	  the file <tt>~/logout-time</tt>.

	<p> Finally, you can have a program other than the window
	  manager determine when X exits:

<example>
xclock &
fvwm &
exec xterm
</example>

	  This script will run xclock and fvwm in the background, and
	  then replace itself with xterm. When you exit the xterm,
	  your X session will end.

	<p> The best way to learn how to use <tt>.xsession</tt> is to
	  try some of these things out. Again, be sure you use
	  <tt>chmod</tt> to make it executable --- this is a common
	  error.

      <sect id="X-custom"> Customizing X <p>How to customize keymap,
	concept of X resources <p>What's in /etc/X11/config (or
	perhaps just a reference to the /usr/doc/ file on this).

      <sect id="X-wm"> Customizing the window manager <p>A little
	  tutorial. Pretty much have to pick a particular one to
	  discuss for this section.
	  
    <chapt id="text_tools"> <heading>  Text tools </heading>

      <p>head, tail, grep, wc and so on
	
      <sect id="text_tools-regexps"> Regular expressions
	<p>A regular expression is a description of a set of
	  characters. The description is build using text intermixed
	  with special characters. The special characters in regular
	  expressions include: <tt> . * [] - \ ^ &dollar;</tt>; they are
	  defined as follows:
	  
	<p>
	  <taglist>
	    
	    <tag><tt>  .          </tt><item>matches any single
		character except newline.
		
	    <tag><tt>  \ </tt><item> Escapes any special characters.

	    <tag><tt>  *          </tt><item>matches 0 or More
		occurances of the preceding character.

	    <tag><tt>  []         </tt><item>matches exactly one of the
		enclosed characters.

	    <tag><tt>  ^          </tt><item>match of the next character
		must be at the begining of the line.

	    <tag><tt>  $          </tt><item>matches characters
		preceding at the end of the line.

	    <tag><tt>  [^]        </tt><item>matches anything not
		enclosed after the not character.

	    <tag><tt>  [-]        </tt><item>matches a range of characters.
	  </taglist>	
	  
	<p>The only way to get use to the regular expression is to use them.
	  Following is a series of examples.

	  <taglist>

	    <tag><tt>c.pe       </tt><item>matches cope, cape, caper etc

	    <tag><tt>c\.pe      </tt><item>matches c.pe, c.per etc
		
	    <tag><tt>sto*p      </tt><item>matches stp, stop, stoop etc

	    <tag><tt>car.*n     </tt><item>matches carton, cartoon,
		carmen etc

	    <tag><tt>xyz.*      </tt><item>matches xyz to the end of the
		line.

	    <tag><tt>^The       </tt><item>matches any line starting
		with The.

	    <tag><tt>atime$     </tt><item>matches any line ending with
		atime.

	    <tag><tt>^Only$     </tt><item>matches any line with Only as
		the only word in the line.

	    <tag><tt>  b[aou]rn   </tt><item>matches barn, born, burn.

	    <tag><tt>Ver[D-F]   </tt><item>matches VerD, VerE, VerF.

	    <tag><tt>Ver[^1-9]  </tt><item>matches Ver followed by any
		non digit.

	    <tag><tt>the[ir][re] </tt><item>matches their,therr, there,
		theie.

	    <tag><tt>[A-Za-z][A-Za-z]* </tt><item>matches any word.

	  </taglist>

    <chapt id="file_tools"> <heading>  File tools </heading>

      <sect id="file_tools-backup"> Backup tools

	<p> FIXME this section is clearly incomplete

	<p>tar, cpio, dump; also large-scale copying, cp -a etc.
	  
	<p> (Perhaps something on how to back up only /home and /etc
	  if you only have a floppy drive, since many home users won't
	  have a tape drive)
	    
	  <p> How to use tar to copy lots of files, or back up your
	    files.  Tarballs. I'm thinking this should be a brief
	    section aimed at single-user systems, with a more thorough
	    sysadmin discussion in a different manual.

	    <p>Backup commands (contributed by Oliver Elphick, section
	    to be cleaned up and elaborated):

	    <p>dump - dumps one filesystem at a time; its command
	    options assume that you are using half-inch tape (maximum
	    45Mb per reel) so it's a bit annoying when using DAT (2Gb
	    or more). Probably the best for regular backups.  Can't be
	    used for NFS-mounted filesystems.

	    <p>cpio - `find [directories] -print | cpio -ovH newc -B
	    >/dev/st0'

	    <p>tar - `tar cvf /dev/st0 [directories]'

	    <p>afio - like cpio; supports pre-compression of files
	    before archiving.

	    <p>tob - front-end for afio


      <sect id="file_tools-compression"> File compression with
      <tt>gzip</tt>
	  
	  <p> Often it would be nice to make a file smaller: say to
	    download it faster, or so it takes up less space on your
	    disk. The program to do this is called <tt>gzip</tt> (GNU
	    Zip).

	    <enumlist>

	      <item> <tt>cd; cp /etc/profile ./mysamplefile</tt> <p>
		  Switch to your home directory, then copy an
		  arbitrarily chosen file (<tt>/etc/profile</tt>) to
		  your current directory in the process renaming it
		  <tt>mysamplefile</tt>. This gives us a file to play
		  with using <tt>gzip</tt>.

	      <item> <tt>ls -l</tt> <p> List the contents of the
		  current directory.  Note the size of
		  <tt>mysamplefile</tt>.

	      <item> <tt>gzip mysamplefile</tt> <p> Compress <tt>
		    mysamplefile</tt>.

	      <item> <tt>ls -l</tt> <p> Observe the results: <tt>
		    mysamplefile</tt> is now called
		    <tt>mysamplefile.gz </tt>. It's also a good bit
		    smaller.

	      <item> <tt>gunzip mysamplefile.gz; ls -l</tt> <p>
		  Uncompress. Observe that <tt>mysamplefile</tt> has
		  returned to its original state. Notice that to
		  uncompress one uses <tt>gunzip</tt>, not
		  <tt>gzip</tt>.

	      <item> <tt>rm mysamplefile</tt> <p> Remove the file,
		  since it was just to practice with.

	    </enumlist>

      <sect id="file_tools-split"> Splitting files into smaller pieces

	  <p> Sometimes a file is too big to fit on a disk, or you
	    don't want to send a huge file over the net in a single
	    chunk. You can split the file using the <tt>split</tt>
	    utility, and reassemble it using the <tt>cat</tt>
	    (con<em>cat</em>enate) utility.
	    
	  <enumlist>
	      <item> <tt>cd; cp /bin/bash myfile; ls -l myfile</tt>
		<p> Copy the <tt>bash</tt> executable to a file in
		your home directory called <tt>myfile</tt>. Observe
		that <tt>myfile</tt> occupies a little over 300,000
		bytes, or around 300 kilobytes.

	      <item> <tt>split -b100k myfile myprefix</tt>
		<p> Splits the file into sections of 100
		kilobytes, naming the sections <tt>myprefixaa</tt>,
		<tt>myprefixab</tt>, etc. Type <tt>ls -l</tt> so see
		the results.

		<p> You can specify any number after the
		  <tt>-b</tt>: choose one that makes sense. If you
		  leave off the <tt>k</tt>, it will be understood as
		  bytes instead of kilobytes. If you use <tt>m</tt>
		  instead of <tt>k</tt>, it will be understood as
		  megabytes. 

	      <item> <tt>cat myprefix* &gt mynewfile</tt> <p>
		Concatenate all the files and write them to
		<tt>mynewfile</tt>. (The <tt>*</tt> and <tt>&gt</tt>
		are tricks you'll learn in another chapter FIXME
		xref.)

	      <item> <tt>rm myfile mynewfile myprefix*</tt>
		  <p> Remove everything.

	    </enumlist>

      <sect id="file_tools-find"> Finding files
	  
	  <p>There are two different facilities for finding files:
	    <tt>find</tt> and <tt>locate</tt>. <tt>find</tt> searches
	    the actual files in their present state. <tt>locate</tt>
	    searches an index generated by the system every morning at
	    6:42 a.m. (this is a <tt>cron</tt> job, explained
	    elsewhere in this manual FIXME xref). <tt>locate</tt>
	    won't find any files which were created after the index
	    was generated. However, since <tt>locate</tt> searches an
	    index, it's much faster - like using the index of a book
	    rather than looking through the whole thing.

	  <p>To compare the two ways of finding files, pretend you
	    can't remember where the X configuration file
	    <tt>XF86Config</tt> resides.

	    <enumlist>

	      <item> <tt>locate XF86Config</tt> <p> This should be pretty
		  fast. You'll get a list of filenames which <em>contain</em>
		  <tt>XF86Config</tt>, something like this:
<example>
/etc/X11/XF86Config 
/usr/X11R6/lib/X11/XF86Config
/usr/X11R6/lib/X11/XF86Config.eg
/usr/X11R6/man/man5/XF86Config.5x.gz
</example>

	      <item> <tt>find / -name XF86Config</tt> 

		<p> You will hear a lot of disk activity, and this
		  will take a lot longer.  Results will look
		  something like this:

<example>
/etc/X11/XF86Config 
/usr/X11R6/lib/X11/XF86Config 
find: /var/spool/cron/atjobs: Permission denied 
find: /var/spool/cron/atspool: Permission denied
find: /var/lib/xdm/authdir: Permission denied
</example>

		<p> Notice that <tt>find</tt> only found files which
		  were named <em>exactly</em> <tt>XF86Config</tt>,
		  rather than any files containing that string of
		  letters. Also, <tt>find</tt> actually tried to look
		  in every directory on the system - including some
		  where you didn't have read permissions. Thus the
		  "Permission denied" messages.  <p> The syntax is
		  different as well. You had to specify what directory
		  to search in --- <tt>/</tt> --- while
		  <tt>locate</tt> automatically chose the root
		  directory. And you had to specify a search by name,
		  using the <tt>-name</tt> option.  You could also
		  have searched for files using many other criteria,
		  such as modification date or owner.

	    </enumlist>

	  <p> In general <tt>find</tt> is a more powerful utility, and
	    <tt>locate</tt> is faster for everyday quick searches. The
	    full range of possible searches would take a long time to
	    explain; for more details type <tt>info find</tt>, which
	    will bring up the very thorough info pages on
	    <tt>find</tt> and <tt>locate</tt>.

      <sect id="file_tools-file"> Determining a file's contents
	  
	<p> Debian comes with a utility which can guess at the
	    contents of a file for you. It is not always
	    correct. However, it is reasonably accurate, and you can
	    use it to explore your system.
	    
	    <enumlist> 
	      <item><tt>file /bin/cp</tt> <p> You should see
		  something like this:

<example>
/bin/cp: ELF 32-bit LSB executable, Intel 386, version 1, stripped
</example>

		  Skipping the technical parts, this is an executable
		  file for Intel machines.

	      <item><tt>file /etc/init.d/boot</tt>
		<p> Gives this response: 

<p>
<example>
/etc/init.d/boot: Bourne shell script text
</example>

		  Meaning that this is a text file, containing a
		  Bourne shell script. 
	    </enumlist>

    <chapt id="disks"> <heading>  Using disks </heading>
      
      <sect id="disks-concepts"> Concepts
	  
	<p> It's probably a good idea to explain a little theory
	  before discussing the mechanics of using disks. In
	  particular, the concept of a <em>filesystem</em>. 
	  <footnote>Some people spell it as two words, i.e. "file
	  system". A quick poll of man pages (<tt>man -k
	  filesystem</tt>, <tt>man -k 'file system'</tt>) reveals
	  about an even split. So I'm spelling it as one word.
	    </footnote>
	  This is confusing, because it has several meanings.

	  <list>

	    <item> <em>The</em> filesystem refers to the whole
		directory tree, starting with the root directory
		<tt>/</tt>, as described above.

	    <item> A "filesystem" in general means any organization of
		files and directories on a particular physical
		device. "Organization" means the hierarchical
		directory structure, and any other information about
		files one might want to keep track of: their size, who
		has permission to change them, etc. So you might have
		one filesystem on your hard disk, and another one on
		each floppy disk.

	    <item> "Filesystem" is also used to mean a <em>type</em>
		of filesystem.  For example, MS-DOS and Windows 3.1
		organize files in a particular way, with particular
		rules: filenames can only have 8 characters, for
		example, and no permissions information is
		stored. Linux calls this the <tt>msdos</tt>
		filesystem. Linux also has its own filesystem, called
		the <tt>ext2</tt> filesystem (version two of the
		<tt>ext</tt> filesystem). You'll use the <tt>ext2</tt>
		filesystem pretty much all the time, unless you're
		accessing files from another operating system or have
		other special needs.
	  </list>

	<p> Any physical device you wish to use for storing files must
	  have at least one filesystem on it.  This means a filesystem
	  in the second sense - a hierarchy of files and directories,
	  along with information about them. Of course, any filesystem
	  has a type, so the third sense will come into play as
	  well. If you have more than one filesystem on a single
	  device, each filesystem can have a different type --- for
	  example, you might have both a DOS partition and a Linux
	  partition on your hard disk.

	<p>It's important to distinguish the filesystem from the
	  low-level format of the disk. In the DOS and Macintosh
	  worlds, the filesystem is called the high-level format. When
	  you format a disk using one of those operating systems,
	  generally you both perform a low-level format and create a
	  file system (high-level format).  On GNU and Unix systems,
	  one generally says simply "format" to mean low-level format,
	  and "making a filesystem" to mean high-level format.

	<p>Formatting has to do with the particulars of the physical
	  device, such as the exact physical location of your data on
	  a floppy disk (on the edge or in the center of the disk for
	  example). The filesystem is the level of organization you
	  have to worry about --- names of directories and files,
	  their sizes, etc.

      </sect>

      <sect id="disks-mount">  <tt>mount</tt>
	  and <tt>/etc/fstab</tt>
	  
	<p> This section describes how to mount a floppy or Zip disk,
	  the <tt>/dev</tt> directory, and distributing the directory
	  tree over multiple physical devices or partitions.

	<sect1 id="disks-mount-mounting"> Mounting a filesystem

	  <p> On a GNU/Linux system there's no necessary
	    correspondence between directories and physical devices,
	    as there is in Windows where each drive has its own
	    directory tree beginning with a letter (such as
	    <tt>C:\</tt>).

	  <p> Instead, each physical device such as a hard disk or
	    floppy disk has one or more filesystems on it. In order to
	    make a filesystem accessible, it's assigned to a
	    particular directory in another filesystem. To avoid
	    circularity, the root filesystem (which contains the root
	    directory <tt>/</tt>) is not contained by any other
	    filesystem --- you have access to it automatically when
	    you boot Debian.

	    <p> A directory in one filesystem which contains another
	    filesystem is known as a <em>mount point</em>. A mount
	    point is a directory in a first filesystem on one device
	    (such as your hard disk) which "contains" a second
	    filesystem, perhaps on another device (such as a floppy
	    disk). To access a filesystem, you must mount it at some
	    mount point.

	  <p> So, for example, you might mount a CD at the mount point
	    <tt>/cdrom</tt>. This means that if you look in the
	    directory <tt>/cdrom</tt>, you'll see the contents of the
	    CD. The <tt>/cdrom</tt> directory itself is actually
	    on your hard disk.  For all practical purposes
	    the contents of the CD become a part of the root
	    filesystem, and when typing commands and using programs it
	    doesn't make any difference what the actual physical
	    location of the files is. You could have created a
	    directory on your hard disk called <tt>/cdrom</tt>, and
	    put some files in it, and everything would behave in
	    exactly the same way. Once you mount a filesystem, there's
	    no need to pay any attention to physical devices.

	  <p> However, before mounting a filesystem, or to actually
	    create a filesystem on a disk that doesn't have one yet,
	    it's necessary to refer to the devices themselves. All
	    devices have names, and these are located in the
	    <tt>/dev</tt> directory. If you type <tt>ls /dev</tt> now,
	    you'll see a pretty lengthy list of every possible device
	    you could have on your Debian system.

	  <p> Possible devices include: 

	    <footnote> This isn't a comprehensive list. Generally the
	    documentation for a particular device or program will tell
	    you what device name you want to use. There are hundreds
	    of different device names.</footnote>

	    <list>

	      <item> <tt>/dev/hda</tt> is IDE drive A.  In general,
		  this will be a hard drive. IDE refers to the type of
		  drive - if you don't know what it means, you
		  probably have this kind of drive, because it's the
		  most common. Your DOS/Windows <tt>C:\</tt> partition
		  is likely to be on this drive.

	      <item> <tt>/dev/hdb</tt> is IDE drive B, as you might
		  guess. This could be a second hard drive, or perhaps
		  a CD-ROM drive. Drives A and B are the first and
		  second (master and slave) drives on the primary IDE
		  controller. Drives C and D are the first and second
		  drives on the secondary controller.

	      <item> <tt>/dev/hda1</tt> is the first
		  <em>partition</em> of IDE drive A, usually called
		  <tt>C:\</tt> on a DOS or Windows system.  Notice
		  that different drives are lettered, while specific
		  partitions of those drives are numbered as well.

	      <item> <tt>/dev/sda</tt> is SCSI disk A. SCSI is like
		  IDE, only if you don't know what it is you probably
		  <em>don't</em> have one of these drives. They're not
		  very common in home Intel PC's, though they're often
		  used in servers and Macintoshes often have SCSI
		  disks.

		  <footnote> SCSI devices have a more complicated
		  naming scheme than IDE devices, mostly because SCSI
		  has more uses. The partitions of a SCSI disk have
		  the form <tt>/dev/sda[1-9a-f]</tt>, that is,
		  <tt>/dev/sda</tt> (or <tt>sdb</tt> or <tt>sdc</tt>,
		  etc.) followed by a number or letter from
		  <tt>1--9</tt> or <tt>a--f</tt>. <tt>/dev/sr0</tt> is
		  the first SCSI CDROM device; general devices such as
		  scanners might look like <tt>/dev/sg0</tt>;
		  <tt>/dev/st0</tt> is a SCSI tape drive. </footnote>

	      <item> <tt>/dev/fd0</tt> is the first floppy drive,
		  generally <tt>A:\</tt> under DOS. Since floppy disks
		  don't have partitions, they only have numbers,
		  rather than the letter-number scheme used for hard
		  drives. However, for floppy drives the numbers refer
		  to the drive, and for hard drives the numbers refer
		  to the partitions.

	      <item> <tt>/dev/ttyS0</tt> is one of your serial
		  ports. <tt>/dev</tt> contains the names of many
		  devices, not just disk drives.
	    </list>

	  <p> To mount a filesystem, we want to tell Linux to
	    associate whatever filesystem it finds on a particular
	    device with a particular mount point. In the process, we
	    might have to tell Linux what kind of filesystem to look
	    for.

	</sect1>

	<sect1 id="disks-mount-cdromexample"> Example: Mounting a
	CD-ROM
	  
	  <p> As a simple demonstration, we'll go through mounting a
	    CD-ROM, such as the one you may have used to install
	    Debian. You'll need to be root to do this, so be careful;
	    whenever you're root you have the power to mess up the
	    whole system, rather than just your own files. Also, these
	    commands assume there's a CD in your drive; you should put
	    one in the drive now.
	    
	    <enumlist>

	      <item> <tt>su</tt>
		  <p> If you haven't already, you need to either log
		  in as root or gain root privileges with the
		  <tt>su</tt> (super user) command. If you use
		  <tt>su</tt>, enter the root password when prompted.

	      <item> <tt>ls /cdrom</tt> <p> See what's in the
		<tt>/cdrom</tt> directory before you start. If you
		don't have a <tt>/cdrom</tt> directory, you may have
		to make one using <tt>mkdir /cdrom</tt>.

	      <item> <tt>mount</tt> <p> Typing simply
		  <tt>mount</tt> with no arguments lists the 
		  currently mounted filesystems.

	      <item> <tt>mount -t iso9660 <var>CD device</var>
		  /cdrom</tt> <p> For this command, you should
		  substitute the name of your CD-ROM device for
		  <tt><var>CD device</var></tt> in the above command
		  line. If you aren't sure, <tt>/dev/hdc</tt> is a
		  good guess. If that fails, try the different IDE
		  devices: <tt>/dev/hda</tt>, etc.  You should see a
		  message like:

<example>
mount: block device /dev/hdc is write-protected, mounting read-only
</example>

		<p>The <tt>-t</tt> option specifies the type of the
		  filesystem, in this case <tt>iso9660</tt>. Most CDs
		  are <tt>iso9660</tt>. The next argument is the name
		  of the device to mount, and the final argument is
		  the mount point. There are many other arguments to
		  <tt>mount</tt>; see the man page for details.

		<p> Once a CD is mounted, you may find that your
		  drive tray will not open. You must unmount the CD
		  before removing it.

	      <item> <tt>ls /cdrom</tt> <p> Confirm that
		  <tt>/cdrom</tt> now contains whatever is on the CD
		  in your drive.

	      <item> <tt>mount</tt> <p> Look at the list of
		  filesystems again, noticing that your CD drive is
		  now mounted.

	      <item> <tt>umount /cdrom</tt> <p> This unmounts the
		  CD. It's now safe to remove the CD from the drive. 
		  Notice that the command is <tt>umount</tt> with no
		  "n", even though it's used to u<em>n</em>mount the 
		  filesystem.
		  
	      <item> <tt>exit</tt> <p> Don't leave yourself logged
		  on as root. Log out immediately, just to be safe.

	    </enumlist>

	</sect1>

	<sect1 id="disks-mount-fstab"> <tt>/etc/fstab</tt>:
	Automating the mount process
	    
	  <p> The file <tt>/etc/fstab</tt> (it stands for
	    "file system table") contains descriptions of
	    filesystems that you mount often. These filesystems can
	    then be mounted with a shorter command, such as <tt>mount
	      /cdrom</tt>. You can also configure filesystems to mount
	    automatically when the system boots. You'll probably want
	    to mount all of your hard disk filesystems when you boot.
	   
	  <p> Look at this file now, by typing <tt>more
	    /etc/fstab</tt>. It will have two or more entries that
	    were configured automatically when you installed the
	    system. It probably looks something like this:

<example>
# /etc/fstab: static file system information.
#
# &lt;file system&gt     &lt;mount point&gt   &lt;type&gt  &lt;options&gt   &lt;dump &gt  &lt;pass&gt

/dev/hda1            /               ext2    defaults    0       1
/dev/hda3            none            swap    sw          0       0
proc                 /proc           proc    defaults    0       0

/dev/hda5            /tmp            ext2    defaults    0       2
/dev/hda6            /home           ext2    defaults    0       2
/dev/hda7            /usr            ext2    defaults    0       2

/dev/hdc             /cdrom          iso9660 ro          0       0
/dev/fd0             /floppy         auto    noauto,sync 0       0
</example>

	  <p> The first column lists the device the filesystem resides
	    on. The second lists the mount point, the third the
	    filesystem type. The line beginning <tt>proc</tt> is a
	    special filesystem explained in FIXME xref. Notice that
	    the swap partition (<tt>/dev/hda3</tt> in the example) has
	    no mount point, so the mount point column contains
	    <tt>none</tt>.
	    
	  <p>The last three columns may require some explanation.

	  <p> The fifth column is used by the <tt>dump</tt> utility to
	    decide when to back up the filesystem. In most cases you
	    can put <tt>0</tt> here.

	  <p> The sixth column is used by <tt>fsck</tt> to decide in
	    what order to check filesystems when you boot the
	    system. The root filesystem should have a <tt>1</tt> in
	    this field, filesystems which don't need to be checked
	    (such as the swap partition) should have a <tt>0</tt>, and
	    all other filesystems should have a <tt>2</tt>. FIXME:
	    cross ref to <tt>fsck</tt>, also, is the swap partition
	    really a filesystem?
	    
	  <p> Column four contains one or more options to use when
	    mounting the filesystem. Here's a brief summary (some of
	    these probably won't make much sense yet --- they're here
	    for future reference):

	    <taglist>
	      
	      <tag> <tt>async</tt> and <tt>sync</tt> 
	      
	      <item> Do I/O synchronously or
		  asynchronously. Synchronous I/O writes changes to
		  files immediately, while asynchronous I/O may keep
		  data in buffers and write it later, for efficiency
		  reasons.  FIXME: cross ref to section on sync for
		  full explanation. Also, should recommend when to
		  choose one or the other.

	      <tag> <tt>ro</tt> and <tt>rw</tt> 
		
	      <item> Mount the filesystem read-only or read-write.
		  If you don't need to make any changes to the
		  filesystem, it's a good idea to mount it read-only
		  so you don't accidentally mess something up. Also,
		  read-only devices (such as CD-ROM drives and floppy
		  disks with write protection tabs) should be mounted
		  read-only.
		  
	      <tag> <tt>auto</tt> and <tt>noauto</tt> 

	      <item> When the system boots, or whenever you type
		  <tt>mount -a</tt>, <tt>mount</tt> tries to mount all
		  the filesystems listed in <tt>/etc/fstab</tt>. If
		  you don't want it to automatically mount a
		  filesystem, you should use the <tt>noauto</tt>
		  option. It's probably a good idea to use
		  <tt>noauto</tt> with removable media such as floppy
		  disks, because there may or may not be a disk in the
		  drive. You'll want to mount these filesystems
		  manually after you put in a disk.

	      <tag> <tt>dev</tt> and <tt>nodev</tt>
		
	      <item> Use or ignore device files on this
		  filesystem. You might use <tt>nodev</tt> if you
		  mount the root directory of another system on your
		  system --- you don't want your system to try to use
		  the devices on the other machine.

	      <tag> <tt>user</tt> and <tt>nouser</tt>

	      <item> Permit or forbid ordinary users to mount the
		  filesystem. <tt>nouser</tt> means that only root can
		  mount the filesystem. This is the normal
		  arrangement. You might use the <tt>user</tt> option
		  to access the floppy drive without having to be root.

	      <tag> <tt>exec</tt> and <tt>noexec</tt> 
		
	      <item> Allow or do not allow the execution of files on
		  this filesystem. Probably you won't need these
		  options.
		  
	      <tag> <tt>suid</tt> and <tt>nosuid</tt> 
		
	      <item> Allow or do not allow the suid bit to take
		  effect. Probably you won't need these options.

	      <tag> <tt>defaults</tt> 
		
	      <item> Equivalent to: <tt>rw</tt>, <tt>dev</tt>,
		  <tt>suid</tt>, <tt>exec</tt>, <tt>auto</tt>,
		  <tt>nouser</tt>, <tt>async</tt>. You can specify
		  <tt>defaults</tt> followed by other options to
		  override specific aspects of <tt>defaults</tt>.

	    </taglist>
		  
	</sect1>
	
	<sect1 id="disks-mount-removable"> Removable disks
	    (floppies, Zip disks, etc.)

	  <p> How to use them - setting things up so you can
	  access them nicely from userspace.

	  <p> FIXME I'm actually not sure how to write this. What's in
	    fstab on a default installation? Should we do the manual
	    su root thing, or one of those EZ floppy mounting
	    packages?  Perhaps do something with group permissions? Or
	    just the <tt>user</tt> option in fstab?
				  
	</sect1>

	<sect id="disks-preparing"> Preparing disks
	    for use: formatting and creating a filesystem
	  <p>
	</sect>

      <sect id="disks-lilo"> LILO
	<p>How to configure it, just the basics

    <chapt id="printers"> <heading>  Using printers </heading>

      <sect id="printers-commands"> lpr and friends
	<p>lprm, lpq

      <sect id="printers-setup"> Setting up printers

    <chapt id="network"> <heading>  Setting up networking </heading>

      <p>(single-user dialup or single-user office machine. any other
	possibilities we should cover?)

      <sect id="network-config"> Relevant files in /etc

      <sect id="network-ethernet"> ethernet

      <sect id="network-ppp"> ppp

    <chapt id="dpkg"> <heading>  Removing and installing software

      <p> This should be about Apt and dpkg

      <sect id="dpkg-dpkg"> The <prgn>dpkg</prgn> package utility 
	  
      <sect id="dpkg-what"> What a package maintenance utility does

	<p>An application or utility program usually involves quite a
	  few files. It might involve libraries, data files like game
	  scenarios or icons, configuration files, and
	  documentation. When you install the program, you want to
	  make sure you have all the files you need in the right
	  place.

	<p>You'd also like to be able to uninstall the program. When
	  you uninstall, you want to be sure all the associated files
	  are deleted. However, if a program you still have on the
	  system needs those files, you want to be sure you keep them.

	<p>Finally, you'd like to be able to upgrade a program. When
	  you upgrade, you want to delete obsolete files and add new
	  ones, without breaking any part of the system.

	<p>The Debian package system solves these problems. It allows
	  you to install, remove, and upgrade software
	  <em>packages</em>, which are neat little bundles containing
	  the program files and information that helps the computer
	  manage them properly. Debian packages have filenames ending
	  in the extension <tt>.deb</tt>, and they're available on the
	  ftp site or on your official Debian CD-ROM.

      <sect id="dpkg-ftp"> Getting the files
	<p> Organization of the ftp site, CD
	<p> Mention non-us packages.
	<p> Describe stable vs. unstable distributions.

      <sect id="dpkg-dselect"> Using Apt
	<p> Help! I don't know how to use apt, so someone else 
	  has to write this.

      <sect id="dpkg-commandline">Using dpkg manually
	<p>The simplest way to install a single package you've
	downloaded is the command <tt>dpkg -i</tt> (short for <tt>dpkg
	--install</tt>. Say you've downloaded the package
	<tt>icewm_0.8.12-1.deb</tt> and you'd like to install
	it. First log on as root, then type: 
<example>
dpkg -i icewm_0.8.12-1.deb
</example>
	  and icewm version 0.8.12 will be installed. If you already
	  had an older version, dpkg will upgrade it rather than
	  installing both versions at once.

	<p>If you want to remove a package, you have two options. The
	  first is most intuitive: 
<example>
dpkg -r icewm
</example>
	  This will remove the icewm package (<tt>-r</tt> is short for
	 <tt>--remove</tt>). Note that you give only the 'icewm' for
	 <tt>--remove</tt>, while <tt>--install</tt> requires the
	 entire .deb filename.

	<p><tt>--remove</tt> will leave configuration files for the
	  package on your system. A configuration file is defined as any
	  file you might have edited in order to customize the program
	  for your system or your preferences. This way, if you later
	  reinstall the package, you won't have to set everything up a
	  second time.

	<p>However, you might want to erase the configuration files
	  too, so dpkg also provides a <tt>--purge</tt>
	  option. <tt>dpkg --purge icewm</tt> will permanently delete
	  every last file associated with the icewm package.

      <sect id="dpkg-compiling"> Compiling software yourself
	<p>You'll have to have -dev packages installed.
	<p>Put it in /usr/local, /opt, or your home directory.
	<p> The configure --prefix; make; make install routine.

      <sect id="dpkg-proprietary"> Proprietary software not in .deb
	  format <p>What to do with this annoying stuff (wrapper
	  packages, /usr/local)

    <chapt id="troubleshooting"> Troubleshooting

      <sect id="troubleshooting-frozen"> Debian is frozen or crashed!
	
	<p>If your Debian system freezes up, it is possibly a bug and
	  the system has crashed. However, it's fair to say that this
	  doesn't happen very often --- many people go for months or
	  even years without a crash, even under heavy use.  GNU/Linux
	  is extremely reliable. If you have problems more often than
	  this, something is probably wrong; ask for help (see <ref
	  id="docs-support">).

	<p>However, it is much more common for the screen to freeze
	  due to a bug in the X server, especially when switching
	  to and from the X virtual console. The newer X servers are
	  more likely to do this, or simply crash; it's hard for the
	  XFree86 project to keep up with the latest features of every
	  video card available.

	<p>If the screen freezes, the system is usually still alive,
	  you simply can't interact with it from the console. If
	  you're on a network, you should be able to log in from
	  another workstation. Once logged in you can reboot in an
	  orderly way (i.e. type <tt>reboot</tt>). If you aren't on a
	  network, pressing <tt>C-A-DEL</tt> will work most of the
	  time. If neither of these works, you may have to simply shut
	  down the system and let <tt>fsck</tt> repair the disk on
	  your next boot.

      <sect id="troubleshooting-termgarbage"> My terminal isn't
	  behaving properly

	<p> Sometimes you terminal will get stuck in reverse video
	  mode, will refuse to move to a new line when you press
	  return, will print garbage characters, or otherwise not work
	  properly. This is almost always the result of attempting to
	  view a binary file with <tt>cat</tt> or <tt>more</tt>
	  (sometimes it's also caused by a bug in a program). You can
	  try to recover by entering the <tt>reset</tt> command. If
	  that fails, log out and back in.

	<p> The problem is that terminals are controlled with special
	  <em>control sequences</em> which tell them to enter reverse
	  video mode, position the cursor, etc. If you send a binary
	  file to the terminal, the file may happen to contain these
	  control sequences. Thus the terminal will get confused.

      <sect id="troubleshooting-vi"> The computer beeps when I press a
	  key, and my screen shows a text file and/or a lot of
	  <tt>~</tt> symbols.  

	<p>You've inadvertently gotten stuck in <tt>vi</tt>. See <ref
	  id="editor-vi">.

    <chapt id="advanced"> <heading>  Advanced topics

	<p>(Should advanced topics be here? I think it would be nice
	to have some of these, just to show people the possibilities
	and give some conceptual explanation that won't really be in a
	reference manual.  Also it always feels nice to make it to a
	chapter called "advanced topics." Self-esteem booster for the
	newbie. :)

      <sect id="advanced-scripting"> Introduction to shell scripting

	<sect1 id="advanced-scripting-why"> What and why
	    <p>Automate simple tasks.

	<sect1 id="advanced-scripting-example"> A simple example
	    <p>Ideas?  

      <sect id="advanced-files"> Advanced files

	<sect1 id="advanced-files-hardlinks"> The real nature of files:
	    hard links and inodes

	  <p> Each file on your system is represented by an
	    <em>inode</em> (eye-node): an inode contains all the
	    information about the file. However, the inode is not
	    directly visible. Instead, each inode is linked into the
	    filesystem by one or more <em>hard links</em>. Hard links
	    contain the name of the file, and the inode number. The
	    inode contains the file itself, i.e., the location of the
	    information being stored on disk, its access permissions,
	    the type of the file, and so on. The system can find any
	    inode once it has the inode number.

	  <p> A single file can have more than one hard link. What
	    this means is that multiple filenames refer to the same
	    file (that is, they are associated with the same inode
	    number). However, you can't make hard links across
	    filesystems: all hard references to a particular file
	    (inode) must be on the same filesystem. This is because
	    each filesystem has its own set of inodes, and there can
	    be duplicate inode numbers between filesystems.

	  <p> Since all hard links to a given inode are referring to
	      <em>the same file</em>, you can make changes to the
	      file, referring to it by one name, and then see those
	      changes when referring to it by a different name. Try
	      this:
	    
	    <enumlist>
	      <item> <tt>cd; echo "hello" &gt firstlink</tt>
		<p> <tt>cd</tt> to your home directory and create
		  a file called <tt>firstlink</tt> containing the word
		  "hello". What you've actually done is redirect the
		  output of <tt>echo</tt> (<tt>echo</tt> just echoes
		  back what you give to it), placing the output in
		  <tt>firstlink</tt>. See the chapter on shells for a
		  full explanation. FIXME xref
		  
	      <item> <tt>cat firstlink</tt> 
		<p> Confirm the contents of <tt>firstlink</tt>.
		  
	      <item> <tt>ln firstlink secondlink</tt> <p> Create a
		hard link: <tt>secondlink</tt> now points to the same
		inode as <tt>firstlink</tt>.
		  
	      <item> <tt>cat secondlink</tt> 
		<p> Confirm that <tt>secondlink</tt> is the same as
		  <tt>firstlink</tt>
		  
	      <item> <tt>ls -l</tt> 
		<p> Notice that the number of hard links listed for
		  <tt>firstlink</tt> and <tt>secondlink</tt> is 2.
		  
	      <item> <tt>echo "change" &gt&gt secondlink</tt> 
		<p> This is another shell redirection trick - don't
		  worry about the details. We've appended the word
		  "change" to <tt>secondlink</tt>. Confirm this with
		  <tt>cat secondlink</tt>.
		  
	      <item> <tt>cat firstlink</tt> 
		<p> <tt>firstlink</tt> also has the word "change"
		  appended! It's because <tt>firstlink</tt> and
		  <tt>secondlink</tt> refer to <em>the same
		    file</em>. It doesn't matter what you call it
		  when you change it.
		  
	      <item> <tt>chmod a+rwx firstlink</tt> 
		<p> Change permissions on <tt>firstlink</tt>. Do
		  <tt>ls -l</tt> to confirm that permissions on
		  <tt>secondlink</tt> were also changed. This means
		  that permissions information is stored in the
		  inode, not in links.
		  
	      <item> <tt>rm firstlink</tt> <p> Delete this link. This
		is a subtlety of <tt>rm</tt> --- it really removes
		links, not files. Now type <tt>ls -l</tt> and notice
		that <tt>secondlink</tt> is still there. Also notice
		that the number of hard links for <tt>secondlink</tt>
		has been reduced to one.
		  
	      <item> <tt>rm secondlink</tt> 
		<p> Delete the other link. When there are no more
		  links to a file, Linux deletes the file itself, that
		  is, its inode. 
	    </enumlist>

	  <p>All files work like this --- even special types of files
	    such as devices (e.g. <tt>/dev/hda</tt>).
	    
	  <p> A directory is simply a list of filenames and inode
	    numbers, that is, a list of hard links. When you create a
	    hard link, you're just adding a name-number pair to a
	    directory. When you delete a file, you're just removing a
	    hard link from a directory.

	<sect1 id="advanced-files-types"> Types of files

	  <p> One detail we've been concealing up to now is that
	    Debian considers nearly everything to be a file. That
	    includes directories and devices: they're just special
	    kinds of files.
	    
	    <p> As you may remember, the first character of an <tt>ls
	      -l</tt> display represents the type of the file. For 
	    an ordinary file, this will be simply <tt>-</tt>. Other 
	    possibilities are:

	    <list> 

	      <item> <tt>d</tt> (directory) 

	      <item> <tt>l</tt> (symbolic link) 

	      <item> <tt>b</tt> (block device) 

	      <item> <tt>c</tt> (character device) 

	      <item> <tt>p</tt> (named pipe) 

	      <item> <tt>s</tt> (socket)

	    </list>

	  <sect2 id="advanced-files-types-symlinks"> Symbolic links

	    <p> Symbolic links (also called symlinks or soft links)
	      are the other kind of link besides hard links. A symlink
	      is a special file that "points to" a hard link on any
	      mounted filesystem. When you try to read the contents of
	      a symlink, it gives the contents of the file it's
	      pointing to rather than the contents of the symlink
	      itself. Since directories, devices, and other symlinks
	      are types of files, you can point a symlink at any of
	      those things.

	    <p> So a hard link is a filename and an inode number. A
	      file is really an inode: a location on disk, file type,
	      permissions mode, etc. A symlink is an inode that
	      contains the name of a hard link. A symlink pairs one
	      filename with a second filename, while a hard link pairs
	      a filename with an inode number.

	    <p> All hard links to the same file have equal
	      status. That is, one is as good as the other; if
	      you perform any operation on one it's just the
	      same as performing that operation on any of the
	      others. This is because the hard links all refer to
	      the same inode. Operations on symlinks, on the other
	      hand, sometimes affect the symlink's own inode (the one
	      containing the name of a hard link) and sometimes affect
	      the hard link being pointed to.

	    <p> There are a number of important differences between
	      symlinks and hard links:

	      <list>
		<item> Symlinks can cross filesystems.  This is
		    because they contain complete filenames, starting
		    with the root directory, and all complete
		    filenames are unique. Since hard links point to
		    inode numbers, and inode numbers are unique only
		    within a single filesystem, they would be
		    ambiguous if the filesystem wasn't known.

		<item> You can make symlinks to directories, but you
		    can't make hard links to them.  Each directory has
		    hard links --- its listing in its parent
		    directory, its <tt>.</tt> entry, and the
		    <tt>..</tt> entry in each of its subdirectories
		    --- but to impose order on the filesystem, no
		    other hard links to directories are
		    allowed. Consequently, the number of files in a
		    directory is equal to the number of hard links to
		    that directory minus two (you subtract the
		    directory's name and the <tt>.</tt> link).

		<item> You can only make a hard link to a file that
		    exists, because there must be an inode number to
		    refer to. However, you can make a symlink to any
		    filename, whether or not there actually is such a
		    filename.

		<item> Removing a symlink removes only the link. It
		    has no effect on the linked-to file. Removing the
		    only hard link to a file removes the file.
		    
	      </list>

	      <p> Try this:
	      <enumlist>
		<item> <tt>cd; ln -s /tmp/me MyTmp</tt> <p>
		  <tt>cd</tt> to your home directory. <tt>ln</tt> with
		  the <tt>-s</tt> option makes a symbolic link; in
		  this case, one called <tt>MyTmp</tt> which points to
		  the filename <tt>/tmp/me</tt>.

		<item> <tt>ls -l MyTmp</tt> 
		    <p> Output should look like this:

<example>
lrwxrwxrwx   1 havoc    havoc           7 Dec  6 12:50 MyTmp -> /tmp/me
</example>

		    The date and user/group names will be different
		    for you, of course. Notice that the file type is
		    <tt>l</tt>, indicating that this is a symbolic
		    link. Also notice the permissions - symbolic links
		    always have these permissions. If you attempt to
		    <tt>chmod</tt> a symlink, you'll actually change
		    the permissions on the file being pointed to.
		    
		<item> <tt>chmod 700 MyTmp</tt>
		  <p> You will get a "No such file or directory"
		    error, because the file <tt>/tmp/me</tt> doesn't
		    exist. Notice that you could create a symlink to
		    it anyway.
		    
		<item> <tt>mkdir /tmp/me</tt>
		  <p> Create the directory <tt>/tmp/me</tt>.
		    
		<item> <tt>chmod 700 MyTmp</tt>
		  <p> Should work now.
		    
		<item> <tt>touch MyTmp/myfile</tt>
		  <p> Create a file in <tt>MyTmp</tt>.
		    
		<item> <tt>ls /tmp/me</tt>
		  <p> The file was actually created in
		  <tt>/tmp/me</tt>.

		<item> <tt>rm MyTmp</tt>
		  <p> Remove the symbolic link. Notice that this
		    removes the link, not what it points to. Thus you
		    use <tt>rm</tt> not <tt>rmdir</tt>.

		<item> <tt>rm /tmp/me/myfile; rmdir /tmp/me</tt>
		  <p> Clean up after ourselves.

	      </enumlist>

	  </sect2>

	  <sect2 id="files-misc-types-devices"> Device files

	    <p> Device files refer to physical or virtual devices on
	      your system, such as your hard disk, video card, screen,
	      or keyboard. An example of a virtual device is the
	      console, represented by <tt>/dev/console</tt>.

	    <p> There are two kinds of devices: <em>character
		devices</em> can be accessed one character at a time,
	      that is, the smallest unit of data which can be
	      written to or read from the device is a character
	      (byte).
	      
	    <p> <em>Block devices</em> must be accessed in larger
	      units called blocks, which contain a number of
	      characters. Your hard disk is a block device.
	      
	    <p> You can read and write device files just as you can
	      from other kinds of files, though the file may well
	      contain some strange incomprehensible-to-humans
	      gibberish. Writing random data to these files is
	      probably a Bad Idea. Sometimes it's useful, though: for
	      example, you can dump a postscript file into the printer
	      device <tt>/dev/lp0</tt>, or send modem commands to the
	      device file for the appropriate serial port.

	    <sect3 id="advanced-files-types-devices-creating"> How to
		create device files. <p> <tt>MAKEDEV</tt>
	    </sect3>

	    <sect3 id="advanced-files-types-devices-null">
	    <tt>/dev/null</tt>
		
	      <p> <tt>/dev/null</tt> is a special device file that
		discards anything you write to it. If you don't want
		something, throw it in <tt>/dev/null</tt>. It's
		essentially a bottomless pit. If you read
		<tt>/dev/null</tt>, you'll get an end-of-file (EOF)
		character immediately. <tt>/dev/zero</tt> is similar,
		only if you read from it you get the <tt>\0</tt>
		character (not the same as the number zero).
	    </sect3>

	  <sect2 id="advanced-files-types-pipes"> Named pipes
	      (FIFOs)
	      
	    <p> A named pipe is a file that acts like a pipe. You
	      put something into the file, and it comes out the other
	      end. Thus it's called a FIFO, or First-In-First-Out: the
	      first thing you put in the pipe is the first thing to
	      come out the other end.

	    <p> If you write to a named pipe, the process which is
	      writing to the pipe doesn't terminate until the
	      information being written is read from the pipe. If you
	      read from a named pipe, the reading process waits until
	      there's something to read before terminating. The size
	      of the pipe is always zero --- it doesn't store data, it
	      just links two processes like the shell
	      <tt>|</tt>. However, since this pipe has a name, the two
	      processes don't have to be on the same command line or
	      even be run by the same user.

	    <p> You can try it by doing the following:
	      <enumlist> 
		<item> <tt>cd; mkfifo mypipe</tt>
		    <p> Makes the pipe.

		<item> <tt>echo "hello" > mypipe &</tt>
		    <p> Puts a process in the background which tries
		    to write "hello" to the pipe. Notice that the
		    process doesn't return from the background; it is
		    waiting for someone to read from the pipe.

		<item> <tt>cat mypipe</tt> <p> At this point the
		  <tt>echo</tt> process should return, since
		  <tt>cat</tt> read from the pipe, and the
		  <tt>cat</tt> process will print <tt>hello</tt>.

		<item> <tt>rm mypipe</tt> 
		    <p> You can delete pipes just like any other file.
	      </enumlist>

	  </sect2>

	  <sect2 id="advanced-files-types-sockets"> Sockets 

	    <p> Sockets are similar to pipes, only they work over the
	      network. This is how your computer does networking: you
	      may have heard of "WinSock", which is sockets for
	      Windows.

	    <p> We won't go into these further, because you probably
	      won't have occasion to use them unless you're
	      programming. However, if you see a file marked with type
	      <tt>s</tt> on your computer, you know what it is.

	  </sect2>

	</sect1>

	<sect1 id="advanced-files-proc"> The <tt>proc</tt> filesystem

	  <p> The Linux kernel makes a special filesystem available,
	    which is mounted under <tt>/proc</tt> on Debian
	    systems. This is a "pseudo-filesystem" --- it doesn't
	    really exist on any of your devices.

	  <p> The <tt>proc</tt> filesystem contains information
	    about the system and running processes. Some of the
	    "files" in <tt>/proc</tt> are reasonably understandable to
	    humans (try typing <tt>cat /proc/meminfo</tt>) and others
	    are arcane collections of numbers. Often, system utilities
	    use these to gather information and present it to you in a
	    more understandable way.

	  <p> People frequently panic when they notice one file in
	    particular --- <tt>/proc/kcore</tt> --- which is generally
	    huge. This is (more or less) a copy of the contents of
	    your computer's memory. It's used to debug the kernel. It
	    doesn't actually exist anywhere, so don't worry about its
	    size.

	  <p> If you want to know about all the things in
	    <tt>/proc</tt>, type <tt>man 5 proc</tt>.

	</sect1>

	<sect1 id="advanced-files-permissions"> Advanced aspects of
	file permissions

	  <sect2 id="advanced-files-permissions-absolute"> Using
	  numeric arguments with <tt>chmod</tt>

	    <p>Earlier in this chapter, we briefly mentioned that you
	      can set file permissions using numbers. The numeric
	      notation is called an absolute mode, as opposed to the
	      symbolic notation (e.g. <tt>u+rx</tt>) which is often
	      called a relative mode. This is because the number
	      specifies an exact mode to set, and the symbol just
	      specifies a change to make (e.g. "add user read and
	      execute permissions"). 

	    <p>The numeric mode is a series of four octal digits or
	      twelve binary digits. Each octal (base eight) digit
	      represents three binary digits: one octal digit and
	      three binary digits are two ways to represent the
	      decimal digits 0 through 7.

	    <p>Deriving a particular mode is pretty
	      straightforward. You simply add up the modes you want to
	      combine, or subtract modes you don't want. For example,
	      user permissions, with only read permission turned on,
	      would be <tt>100</tt> in binary. User permissions with
	      write only would be <tt>010</tt> binary. User
	      permissions with read and write both turned on would be
	      <tt>100 + 010 = 110</tt>. Alternatively, you could put
	      it in octal: <tt>4 + 2 = 6</tt>.

	      <p> For the full mode, simply add up digits from this
	      table:

<example>
0001        others, execute
0002        others, write
0004        others, read
0010        group, execute
0020        group, write
0040        group, read
0100        user, execute
0200        user, write
0400        user, read
1000        sticky bit
2000        set group id
4000        set user id
</example>

	    <p>To use the table, first decide what permissions you
	    want to set. Then add up the numbers for those
	    permissions. The total is your mode. For example, to get
	    mode <tt>0755</tt>:

<example>
  0001   o=x
  0004   o=r
  0010   g=x 
  0040   g=r
  0100   u=x
  0200   u=w
+ 0400   u=r
-------
  0755  u=rwx go=rw
</example>

	    <p>You'd actually call this mode simply <tt>755</tt>,
	      without the leading <tt>0</tt>, because <tt>chmod</tt>
	      automatically adds zeroes at the beginning of the mode
	      --- <tt>7</tt> means mode <tt>0007</tt>.

	    <p> To set a file to <tt>755</tt>, you'd type <tt>chmod
	      755 myfile</tt>.

	    <p><tt>755</tt> is a very common mode for directories, as
	      it allows anyone to use the directory but only the owner
	      to create and delete files in the directory. <tt>644</tt>
	      is the analogous mode for files, and it is also very
	      common. It allows anyone to use the file but only the
	      owner can change it. For executable files, <tt>755</tt>
	      is a common mode; this is just <tt>644</tt> plus execute
	      permissions (<tt>644 + 111 = 755</tt>).

	  </sect2>

	  <sect2 id="advanced-files-permissions-suid"> Making files
	  suid/sgid
	    <p>
	  </sect2>

	  <sect2 id="advanced-files-permissions-sticky"> Setting the
	  sticky bit
	    <p>
	  </sect2>
	  
	</sect1>


	<sect1 id="advanced-files-chattr"> chattr
	    <p>A useful tip?

	<sect1 id="advanced-files-copying"> Large-scale copying
	  <p>cp -a and variants on the theme. 
	  <p>how to copy an old system to a new one.
	  <p>FIXME whoops, I also listed this topic under Backup
	  Tools. need to decide.

	<sect1 id="advanced-files-undocumented"> Other concepts not
	    yet covered, but should be

	  <p> fsck, dd, fdisk, etc. <p> what package is a file in? <p>
	    MSDOS vs. Mac vs. Unix text files <p> sync </sect1>

      <sect id="advanced-kernel"> Compiling the kernel
	  <p>How, what, and why


      <sect id="advanced-security"> A few words on security
	<p> The basics of security from a user standpoint. Maintaining
	  one's privacy. What other users can see of your account. 

      <sect id="advanced-programming"> Programming on Linux
	<p> Something about the Linux programming environment. Aimed
	  at, say, people taking CS101. Nothing on <em>how</em> to
	  program, just Emacs, gcc, gdb, ddd, etc. as programming
	  tools.
	  
	<p> Likely based on debug.tex 

    <chapt id="next"> <heading>  Where to from here?

      <sect id="next-manuals"> Other Debian manuals to read

      <sect id="next-resources"> Other resources
	  <p>A few good URLs, directions to meta-documents.

    <chapt id="helping"> <heading>  Contributing to Debian: How can I
    help? </heading>

      <sect id="helping-bugs"> Submit bug reports
	  <p>How to do that with the "bug" package

      <sect id="helping-other"> Other things
	  <p>Whatever we want to say here.

    <chapt id="A_apps"> <heading>  Appendix A: A brief survey of
    available applications </heading>

      <p>(Would this be useful? Or does dselect really do the job? It
	seems like there are a significant number of debian-user and
	newsgroup questions to the effect of "I'm looking for an
	application that does X". We could just list what exists, more
	or less, maybe recommend one option over another when there's
	an obvious choice.)

      <sect id="A_apps-whatever"> (Subheadings could copy the
      structure of the menu system)

    </chapt>

    <chapt id="B_components"> <heading> Appendix B: Summary of
	GNU/Linux system components
    </heading>

      <p>You may be a little confused about exactly what GNU/Linux
	is. What's the Linux kernel, vs. the GNU utilities, vs. the X
	Window System? Here's a little ASCII art diagram to show you
	how it all relates (apologies, it's not very attractive).

<example>

 Window Manager ----- Gnome Programs/Libraries (in development)
 |   |	    ----------/                     \
 |   |     /                                 ---------\
 | X Clients         Programs/Applications ---- Shared Libraries
 |   |   \                    |                 /
  \  |    ---------------\    |     /-----------       
  X Server -------------- Linux Kernel 
      |                   /    |
      |   /---------------     |
  Video Card -------- Other Computer Hardware (Memory, disk, etc.)

</example>

      <p>Note that the X Server and X Clients <em>are</em>
	applications, but they are applications which interact in
	special ways with the video hardware and other
	applications.

      <p>The window manager is a special X Client, and thus also an
	application.  All the X programs use the Shared Libraries, but
	no line appears in the diagram.

      <p>When the Gnome (GNU Network Object Model Environment) project
	is completed, it will help to unify the X environment with a
	special set of programs and libraries, interacting with the
	window manager and other X Clients.

      <p>The GNU utilities are small programs that do simple tasks:
	<tt>mv</tt>, <tt>cp</tt>, <tt>tar</tt> for example.

    </chapt>

    <chapt id="C_booting"> 
      <heading>Appendix C: Booting the system </heading>

      <p>[FIXME really this section requires finding out exactly
	what options the install disks offer, and how the install
	disks word things. "Boot from hard disk," "make a floppy,"
	etc.]
	
      <p>[FIXME really also they've already figured out how to
	boot, since it's part of installation, so perhaps ditch this
	section entirely - it's too long anyway.]
	
      <p>This appendix describes what happens during the GNU/Linux
	boot process.
	
      <p>
	How you boot your system depends on how you set things up
	when you installed Debian. Most likely, you just turn the
	computer on. But you may have to insert a floppy disk first.
	
      <p>Linux is loaded by a program called LILO, or LInux
	LOader. LILO can also load other operating systems, and ask
	you which system you'd like to load.
	
      <p> The first thing that happens when you turn on an Intel PC
	is that the BIOS executes. BIOS stands for Basic Input
	Output System.  It's a program permenantly stored in the
	computer on read-only chips.  It performs some minimal
	tests, and then looks for a floppy disk in the first disk
	drive.  If it finds one, it looks for a "boot sector" on
	that disk, and starts executing code from it, if any.  If
	there is a disk, but no boot sector, the BIOS will print a
	message like:
<example>
Non-system disk or disk error
</example>
	Removing the disk and pressing a key will cause the boot
	process to continue.

      <p>If there isn't a floppy disk in the drive, the BIOS looks
	for a master boot record (MBR) on the hard disk.  It will
	start executing the code found there, which loads the
	operating system.  On GNU/Linux systems, LILO, the LInux
	LOader, can occupy the MBR, and will load GNU/Linux.

      <p>Thus, if you opted to install LILO on your hard drive, you
	should see the word LILO as your computer starts up. At that
	point you can press the left <tt>Shift</tt> key [FIXME or is
	it Alt?] to select which operating system to load - press
	<tt>Tab</tt> to see a list of options. Type in one of those
	options, and press return.  LILO will boot the requested
	operating system.

      <p>If you don't press the <tt>Shift</tt> key, LILO will
	automatically load the default operating system after about
	5 seconds. If you like, you can change what system LILO
	loads automatically, which systems it knows how to load, and
	how long it waits before loading one automatically - see
	[FIXME crossref].

      <p>If you didn't install LILO on your hard drive, you probably
	created a <em>boot disk</em>. The boot disk will have LILO
	on it. All you have to do is insert the disk before you turn
	on your computer and the BIOS will find it before it checks
	the MBR on the hard drive. To return to a non-Linux OS, take
	out the boot disk and restart the computer (from Linux, be
	sure you follow the proper procedure for restarting: see
	<ref id="start-shutdown"> for details.)
	
      <p> LILO loads the Linux kernel from disk, and then lets the
	kernel take over. (The kernel is the central program of the
	operating system, in control of all other programs.) The
	kernel discards the BIOS and LILO.

      <p> On non-Intel platforms, things work a little
	differently. But once you boot, everything is more or less
	the same.

      <p>Linux looks at the type of hardware it's running on.
	It wants to know what type of hard disks you have, whether
	or not you have a bus mouse, whether or not you're on a
	network, and other bits of trivia like that.  Linux can't
	remember things between boots, so it has to ask these
	questions each time it starts up.  Luckily, it isn't asking
	<em>you</em> these questions---it's asking the hardware!
	While it boots, the Linux kernel will print messages on the
	screen describing what it's doing.

      <p>The query process can cause problems with your system, but if
	it was going to, it probably would have when you first
	installed GNU/Linux.  If you're having problems, consult the
	installation instructions, or ask on a mailing list.

      <p>The kernel merely manages other programs, so once it is
	satisfied everything is okay, it must start another program
	to do anything useful. The program the kernel starts is
	called <prgn>init</prgn>. After the kernel starts
	<prgn>init</prgn>, it never starts another program. The
	kernel becomes a manager and a provider of services.

      <p>Once <prgn>init</prgn> is started, it runs a number of
	scripts (files containing commands), which prepare the
	system to be used: they do some routine maintenance and
	start up a lot of programs which do things like display a
	login prompt, listen for network connections, and keep a log
	of the computer's activities.

      <p>FIXME describe boot scripts here.

    </chapt>

    <chapt id="Z_misc"> <heading> Appendix Z: Miscellaneous
    </heading>
      <p>This chapter contains interesting information that didn't fit
      in the rest of the manual, such as historical notes. It may be
      moved to another manual in the future, or made into a coherent
      chapter.

      <sect id="unix-history">Unix History 

	<p>In 1969, Bell Telephone Laboratories (Bell Labs, a division
	  of AT&amp T) was working with General Electric and Project
	  MAC of MIT to write an operating system called Multics. To
	  make a long story slightly shorter, Bell Labs decided the
	  project wasn't going anywhere and broke out of the group.
	  This left Bell Labs without a good operating system.

	<p>Ken Thompson and Dennis Ritchie decided to sketch out an
	  operating system that would meet their needs. Bell Labs had
	  an unused PDP-7 computer that Thompson wanted to put to use,
	  so he implemented the system they had designed on that
	  machine.  As a pun on Multics, Brian Kernighan, another Bell
	  Labs researcher, gave the system the name Unix.  The group
	  was able to get funding to buy a better computer, a PDP-11,
	  by proposing a plan to write a word processing system.
	  Rather than write the word processor from scratch, they made
	  it an application that ran under Unix, which they ported to
	  the PDP-11.


	<p>Later, Dennis Ritchie invented the "C" programming
	  language. In 1973, Unix was rewritten in C instead of the
	  original assembly language.<footnote>"Assembly language" is
	  a very basic computer language that is tied to a particular
	  type of computer.  It is usually considered a challenge to
	  program in.</footnote> In 1977, Unix was moved to a new
	  machine through a process called <em>porting</em> away from
	  the PDP machines it had run on previously.  This was aided
	  by the fact Unix was written in C since much of the code
	  could simply be recompiled and didn't have to be rewritten.

	<p>In the late 1970's, AT&amp T was forbidden from competing
	  in the computing industry, so it licensed Unix to various
	  colleges and universities very cheaply.  It was slow to
	  catch on outside of academic institutions but was eventually
	  popular with businesses as well. The Unix of today is
	  different from the Unix of 1970.  It has two major
	  variations: System V, from Unix System Laboratories (USL), a
	  subsidiary of SCO<footnote>Previously, USL was owned by
	  AT&amp T and later Novell</footnote>, and the Berkeley
	  Software Distribution (BSD).  The USL version is now up to
	  its forth release, or SVR4<footnote>A cryptic way of saying
	  "System Five, Release Four".</footnote>, while BSD's latest
	  version is 4.4.  However, there are many different versions
	  of Unix besides these two.  Most proprietary versions of Unix
	  derive from one of the two groupings. The versions of Unix
	  that are actually used usually incorporate features from
	  both variations.

	<p>Current proprietary versions of Unix for Intel PCs cost
	  between $500 and $2000, with the exception of Solaris x86
	  which has been crushed by free Unix clones and forced to
	  lower prices.

      <sect>GNU/Linux History

	<p>Debian traces its roots to the founding of the GNU project
	  in 1984 by Richard M. Stallman. GNU (GNU's Not Unix) is a
	  project of the Free Software Foundation; their goal was and
	  is to replace the Unix operating system with free
	  software. They had written almost an entire operating system
	  by the early 1990s, but the kernel was missing. Fortunately,
	  Linux appeared to fill this gap.

	<p>The primary author of the Linux kernel is Linus Torvalds.
	  Since his original versions, it has been improved by
	  countless numbers of people around the world.  It is a
	  clone, written entirely from scratch, of the Unix operating
	  system. Neither USL, nor the University of California,
	  Berkeley, were involved in writing Linux.  One of the more
	  interesting facts about Linux is that development occurs
	  simultaneously around the world.  People from Australia to
	  Finland contributed to Linux and will hopefully continue to
	  do so.

	<p>Linux began with a project to explore the 386 chip. One of
	  Linus's earlier projects was a program that would switch
	  between printing <tt>AAAA</tt> and <tt>BBBB</tt>. This later
	  evolved into Linux.

	<p>Linux has been copyrighted under the terms of the GNU
	  General Public License (GPL).  This is a license written by
	  the Free Software Foundation (FSF) that is designed to keep
	  software free. In brief, it says that although you can
	  charge as much as you'd like for a copy, you can't prevent
	  the person you sold it to from selling it, giving it away,
	  or modifying it. It also means that the source
	  code<footnote>The <em>source code</em> of a program is what
	  the human programmer reads and writes.  It is later
	  translated into machine code that the computer
	  interprets.</footnote> must also be available.  This is
	  useful for programmers.  Anybody can modify Linux and even
	  distribute their modifications, provided that they keep the
	  code under the same copyright --- the GPL.

	<p>Debian is called GNU/Linux because it is a product of two
	  massive efforts, the Linux kernel and the GNU
	  project. Still, focusing on only these two contributions
	  leaves out tens of thousands of contributors. It's
	  impossible to keep track of everyone who's made Debian what
	  it is today.

	<p> The following two lists, of leaders and release
	  milestones, are copyrighted by Software in the Public
	  Interest and may be redistributed but not modified.

	<p> Debian has had several leaders since its beginnings in 1993. 

	  <list>

	    <item>Ian Murdock founded Debian in August 1993 and led it
		until March 1996. This effort was sponsored by the
		FSF's GNU project for one year (November 1994 to
		November 1995).

	  <item>Bruce Perens led Debian from April 1996 until December
		1997
		
	    <item>Ian Jackson led Debian from January 1998 until the
		present

	  </list>

	  <p>Here are a few of the major Debian release milestones: 
	  
	  <list>

	    <item>0.01-0.90 were released between August 1993 and December 1993 

	    <item>0.91 released January 1994 (around 30 developers, primitive packager) 

	    <item>0.93R5 released in March 1995 (dpkg makes its first appearance) 

	    <item>0.93R6 released in November 1995 (around 60 developers, a.out, first dselect) 

	    <item>1.0 was never released. It later became version 1.1 

	    <item>1.1 'Buzz' released June 1996 (474 packages, 2.0 kernel, fully ELF, dpkg) 

	    <item>1.2 'Rex' released December 1996 (848 packages, 120
		developers) 
		
	    <item>1.3 'Bo' released July 1997 (974 packages, 200 developers) 

	    <item>2.0 'Hamm' released July 1998 (1500+ packages, 400+ developers, glibc2) 

	    <item>2.1 'Slink' is scheduled to be frozen in October or November 1998. 

	  </list>

      <sect>The Linux kernel's version numbering
	<p>
	  The first number in Linux's version number indicates truly
	  huge revisions.  These change very slowly: right now version
	  2 is the latest.  The second number indicates less major
	  revisions.  Even second numbers signify more stable,
	  dependable versions of Linux while odd numbers are
	  developer's versions that are more prone to bugs.  The final
	  version number is the minor release number---every time a
	  new version is released that may just fix small problems or
	  add minor features, that number is increased by one. Right
	  now the stable kernel is 2.0, and the developer's kernel is
	  2.1. When 2.1 is ready, it will become stable kernel
	  2.2. The latest version of the stable kernel is currently
	  2.0.35, though that may well change by the time you read
	  this. The 2.2 stable release is expected soon.

    </chapt>

    

  </book>
</debiandoc>

