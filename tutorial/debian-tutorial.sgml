<!doctype debiandoc system>
<debiandoc>
  <book> <title>Debian Tutorial</title>
      <author><name>Oliver Elphick</name><email></email>

      <author><name>Havoc Pennington</name><email>hp@debian.org</email>

      <author><name>Ole Tetlie</name><email></email>

      <author><name>James Treacy</name><email>treacy@debian.org</email>

      <author><name>Craig ???</name>
	<email>craig@happy.digitaldune.net</email>

      <author><name>Thanks to Larry Greenfield and his Linux User's
	 Guide</name><email>leg+@andrew.cmu.edu</email>

      <author><name>Thanks to Richard Stallman for advice and
	  editing</name><email>rms@gnu.org</email>

      <version><date>

      <abstract> This is the Debian Tutorial. You should read it after
	you install Debian according to the instructions in
	<tt>install.txt</tt> and do the basic configuration covered in
	the Installation Manual (which has not been written at this
	time; apologies and please bear with us). It covers all the
	basics of using your new system in an introductory/tutorial
	format.

      <copyright> &copy; 1998 Software in the Public Interest and 
	  individual contributors. 

	<p>Permission is granted to make and distribute verbatim
	  copies of this manual provided the copyright notice and this
	  permission notice are preserved on all copies.
	  
	<p>Permission is granted to copy and distribute modified
	  versions of this manual under the conditions for verbatim
	  copying, provided also that the sections that reprint ``The
	  GNU General Public License'', ``The GNU Library General
	  Public License'', and other clearly marked sections held
	  under separate copyright are reproduced under the conditions
	  given within them, and provided that the entire resulting
	  derived work is distributed under the terms of a permission
	  notice identical to this one.
	  
	<p>Permission is granted to copy and distribute translations
	  of this manual into another language under the conditions
	  for modified versions.  ``The GNU General Public License''
	  and ``The GNU Library General Public License'' may be
	  included in a translation approved by the Free Software
	  Foundation instead of in the original English.
	  
	<p>At your option, you may distribute verbatim and modified
	  versions of this document under the terms of the GNU General
	  Public License, excepting the clearly marked sections held
	  under separate copyright.
	  
      </copyright>

    <toc>	  


    <chapt id="about"> <heading> About this manual </heading>

      <p>This is the Debian Tutorial. It is aimed at readers who are
	new to Debian GNU/Linux. It assumes no prior knowledge of
	GNU/Linux or other Unix-like systems, but it does assume very
	basic general knowledge about computers and hardware (you
	should know what the basic parts of a computer are, and what
	one might use a computer to do).

      <p>This manual is meant to be read in order; each chapter
	assumes some knowledge of prior chapters, though you may find
	it useful to skip around.

      <p>There is also a Debian Reference Guide planned, which will be
	more comprehensive but less introductory.
	
      <p>This tutorial assumes that you have already installed and
	configured Debian GNU/Linux according to the installation
	manual (which is incomplete as of this writing). However, you
	may want to look over the tutorial before you install, in
	order to learn more about Debian.

      <p>In general this tutorial tries to explain the reasons for
	things, and help you understand what's going on inside the
	system. The idea is to empower you to solve new problems and
	get the most out of your computer. Thus there's plenty of
	theory, history, and fun facts thrown in with the "How To"
	aspects of the manual.
	
      <p>Please send comments about this manual to <url
	id="mailto:debian-doc@lists.debian.org"
	name="debian-doc@lists.debian.org">.  We're especially
	interested in whether it was helpful to you, and how we could
	make it better. If you get confused while reading, or notice
	that we use a term without explaining it first, please email
	us.  [FIXME or should we ask for bug reports?]
	
      <p>DO NOT send the authors technical questions about Debian, as
	there are other forums for that. See [FIXME insert reference
	to appropriate chapter] Only send mail regarding the manual
	itself to the above address.

      <p>To find the latest version of this manual, go to <url
      id="http://www.debian.org/doc/"
      name="http://www.debian.org/doc/"> and follow the links.
    
    <chapt id="introduction"> <heading> Introduction </heading>

      <sect id="introduction-debian"> What is Debian? 
	<p>
	  <em>Debian</em> is a free operating system (OS) for your
	  computer. An operating system is the set of basic programs
	  and utilities that make your computer run. At the core of an
	  operating system is the kernel. The kernel is the most
	  fundamental program on the computer: it does all the basic
	  housekeeping and lets you start other programs. Debian uses
	  the <em>Linux</em> kernel, a completely free piece of
	  software started by Linus Torvalds and supported by
	  (probably over 1000) programmers worldwide. A large part of
	  the basic tools that fill out the operating system come from
	  the <em>GNU project</em> (<url id="http://www.gnu.org"
	  name="www.gnu.org">), and these tools are also free. Of
	  course, the thing that people want is application
	  software. Programs to help them get what they want to do
	  done, from editing documents to running a business to
	  playing games to writing more software. Debian comes with
	  over 1000 <em>packages</em> (precompiled software bundled up
	  in a nice format for easy installation on your machine) ---
	  all of it free.

	<p>It's a bit like a tower. At the base is Linux. On top of
	  that are all the basic tools, mostly from GNU. Next is all
	  the application software that you run on the computer: much
	  of this is also from GNU. The Debian developers act as
	  architects and coordinators --- carefully organizing the
	  system and fitting everything together into an integrated,
	  stable operating system: Debian GNU/Linux.

	<sect1 id="introduction-debian-os">What's an operating system,
	    and what sort of operating system is Debian?

	  <p>An operating system is a collection of programs that make
	    your computer useful. It's the software system that
	    allows you to create and organize files, communicate over
	    the network, coexist with other users on the system, and
	    do your work. 

	  <p>Debian GNU/Linux is based on the Unix operating system,
	    defined by the Posix and X/Open specifications. Unix has a
	    long history (FIXME see appendix). Debian is almost fully
	    compliant with these standards, though the certification
	    process costs a significant amount of money so it is not
	    officially certified.

	  <p>Operating systems can be simple and minimalist, like DOS,
	    or big and complex, like OS/2 or VMS.  Debian tries to be
	    a middle ground.  While it supplies more resources and
	    does more than early operating systems, it doesn't try to
	    do <em>everything</em>.  Unix was originally designed as a
	    simplification of an operating system named Multics (note
	    the pun: Multics, Unix).

	  <p>The original design philosophy for Unix was to distribute
	    functionality into small parts, the programs. That way,
	    you can easily achieve new functionality and new features
	    by combining the small parts (programs) in new ways. And
	    if new utilities appear (and they do), you can integrate
	    them into your old toolbox.  

	  <p>To write a document like this
	    one, for example, one might use many programs actively:
	    <prgn>fvwm</prgn> to manage my "windows," <prgn> Emacs
	    </prgn> to edit the text, <prgn>LaTeX</prgn> to format it,
	    <prgn>xdvi</prgn> to preview it, <prgn>dvips</prgn> to
	    prepare it for printing and then <prgn>lpr</prgn> to print
	    it.  If there were a different dvi previewer available, I
	    could use that instead of <prgn>xdvi</prgn> without
	    changing my other programs.  

	  <p>At any given time, the system could be running dozens of
	    programs to support a single user. With enough users,
	    you'd expect hundreds of programs to be active.  Of
	    course, most of these are started automatically by the
	    system, so you don't have to worry about them.

	  <p>When you're using an operating system, you want to
	    minimize the amount of work you put into getting your job
	    done.  Debian supplies many tools that can help you, but
	    only if you know what these tools do.  Spending an hour
	    trying to get something to work and then finally giving up
	    isn't very productive.  This manual will teach you what
	    tools to use in what situations, and how to tie these
	    various tools together.

	  <p>The central part of an operating system is called the
	    <em>kernel</em>.  The Linux kernel is a program which
	    coordinates the other programs, distributing resources
	    among them and providing basic services such as files and
	    networking for programs to use.  A kernel is always
	    running: it is the first program to start when the system
	    is turned on, and the last program to do anything when the
	    system is halted.
	    
	<sect1 id="introduction-debian-how"> Who creates Debian?

	  <p>Debian is an all-volunteer internet development
	    project. There are hundreds of volunteers producing the
	    distribution; most volunteers are in charge of a small
	    number of software packages. In general, volunteers are
	    intimately familiar with the software they package, and
	    use it themselves in their work.

	  <p>These volunteers work together by following a strict set
	    of guidelines governing how packages are assembled.  These
	    guidelines are developed cooperatively, by discussing how
	    the system as a whole should work on internet mailing
	    lists and <em>internet relay chat</em> (IRC) forums.
	    
	</sect1>

      <sect id="introduction-DFSG"> What's free software?  

	<p>When Debian developers and users speak of "free software,"
	  they refer to <em>freedom</em> rather than price. Debian is
	  free in this sense: you are free to modify and redistribute
	  it, and will always have access to the source code for this
	  purpose.  The <url
	  id="http://www.debian.org/social_contract#guidelines"
	  name="Debian Free Software Guidelines"> describe in more
	  detail exactly what is meant by "free." The <url
	  id="http://www.fsf.org" name="Free Software Foundation">,
	  originator of the GNU project, is another source of
	  information. You can find a more detailed discussion of free
	  software at <url id="http://www.debian.org/intro/free"
	  name="http://www.debian.org/intro/free">.

	<p>Free software is sometimes called Open Source (TM) software
	  --- Open Source is a trademark registered by Software in the
	  Public Interest. Since Open Source is trademarked, only
	  truly free software can call itself Open Source. You may
	  encounter vendors who try to mislead you by claiming their
	  software is "free," while in reality it has significant
	  strings attached.  The Open Source trademark gives you some
	  assurance that the software really is free software.

	<p>You may be wondering: why would people spend hours of their
	  own time to write software, carefully package it, and then
	  give it all away? The answers are as varied as the people
	  who contribute.

	<p> Many believe in sharing information and having the freedom
	  to cooperate with one another, and feel that free software
	  encourages this. There's a long tradition starting in the
	  1950s upholding these values, sometimes called the Hacker
	  Ethic.  (You can read more about it in Steven Levy's
	  enjoyable book, <em>Hackers: Heroes of the Computer
	  Revolution</em>.)

	<p>Others want to learn more about computers. More and more
	  people are looking for ways to avoid the inflated price of
	  commercial software. A growing crowd contribute as a thank
	  you for all the great free software they've received from
	  others.

	<p>Many in academia create free software to help get the
	  results of their research into wider use. Businesses help
	  maintain free software so they can have a say in how it
	  develops --- there's no quicker way to get a new feature
	  than to implement it yourself or hire a consultant to do so!
	  Business is also interested in greater reliability and the
	  ability to choose between support vendors.  

	<p>Still others see free software as a social good,
	  democratizing access to information and preventing excessive
	  centralization of the world's information infrastructure. Of
	  course, a lot of us just find it great fun.

	<p>Debian is so committed to free software that we thought it
	  would be useful if it was formalized in a document of some
	  sort. Our <url id="http://www.debian.org/social_contract"
	  name="Social Contract"> promises that Debian will always be
	  100% free software. When you download a package from the
	  Debian main distribution, you can be sure it meets our Free
	  Software Guidelines.
	  
	<p>Although Debian believes in free software, there are cases
	  where people want or need to put proprietary software on
	  their machine. Whenever possible Debian will support this;
	  though proprietary software is not included in the main
	  distribution, it is sometimes available on the ftp site in
	  the <tt>non-free</tt> directory, and there are a growing
	  number of packages whose sole job is to install proprietary
	  software we are not allowed to distribute ourselves.

	<p>It is important to distinguish <em>commercial</em> software
	  from <em>proprietary</em> software. Proprietary software is
	  non-free software, while commercial software is software
	  sold for money. Debian permits commercial software to be a
	  part of the main distribution, but not proprietary software.
	  Remember that the phrase "free software" does not refer to
	  price; it is quite possible to sell free software. For more
	  clarification of the terminology, see <url
	  id="http://www.opensource.org"
	  name="http://www.opensource.org"> or <url
	  id="http://www.fsf.org/philosophy/categories.html"
	  name="http://www.fsf.org/philosophy/categories.html">. 
	  
      <sect id="introduction-why"> Why should I use Debian? 

	<p>What Debian is good for, and what it isn't good for. 

      <sect id="introduction-easy"> Is Debian easy to use?

	<p>The common wisdom about Debian and other Unix-like systems
	  is that they're hard to use. So you may be a little
	  worried. Don't be.

	<p>Yes, you have to type some commands, where you'd use the
	  mouse on some other systems (at least for now ---
	  development of a free graphical desktop is moving quickly,
	  see <url id="www.gnome.org" name="the Gnome project web
	  page"> for details). But keep an open mind --- commands can
	  often be easier to learn and use than the mouse. It depends
	  on what you're trying to do.

	<p>Don't be intimidated. Take your time, try things out, read
	  the documentation. If you have any questions, ask them (see
	  <ref id="docs-support">). Familiarize yourself with the
	  system <em>before</em> that critical deadline, so you can
	  learn at an enjoyable pace without frustration. Soon you'll
	  be doing real work quickly and easily.
	  
      <sect id="introduction-how">How to Read This Book

	<p>The best way to learn about almost any computer program is
	  at your computer.  Most people find that reading a book
	  without using the program isn't beneficial.  The best way to
	  learn Unix and GNU/Linux is by using them.  Use GNU/Linux
	  for everything you can.  Experiment.  Don't be afraid ---
	  it's <em>possible</em> to mess things up, but you can always
	  reinstall. Keep backups and have fun!
	  
	<p>Debian isn't as intuitively obvious as some other operating
	  systems.  Thus, you will probably end up reading at least
	  the first few chapters.

	<p>The number one way to avoid using this book is to use the
	  on-line documentation that's available, using commands like
	  <prgn>man</prgn> and <prgn>info</prgn>. These are described
	  in FIXME xref.
	  
	<p>The suggested way to learn is to read a little, then play a
	  little.  Keep playing until you're comfortable with the
	  concepts, and then start skipping around in the book.
	  You'll find a variety of topics are covered, some of which
	  you might find interesting and some of which you'll find
	  boring.  After a while, you should feel confident enough to
	  start using commands without knowing exactly what they do.
	  This is a good thing.

	<p>A helpful thing to know: if you ever mistakenly type a
	  command, or don't know how to exit a program, C-c (the Ctrl
	  key and the lowercase letter c held simultaneously) will
	  often stop the program.

      <sect id="introduction-ldp">The Linux Documentation Project
	  
	<p>This manual borrows heavily from the Linux Documentation
	  Project's <em>Linux User's Guide</em>, by Larry
	  Greenfield. Thanks Larry! That project has a number of other
	  excellent manuals, many of them targetted at more
	  experienced users and system administrators. The LDP also
	  maintains the Linux HOWTOs, an invaluable resource you
	  should become familiar with. (FIXME LDP URL here.)

    <chapt id="start"> <heading> Getting started </heading>

      <p> So you've just finished installing Debian!
	Congratulations. Dive right in and start learning to use it.

      <p> As a part of the install process, you should have figured
	out how to boot the Debian system (with a special floppy disk,
	by simply turning your computer on, or by holding down the Alt
	key at the LILO prompt and selecting the Linux kernel image).

      <sect id="start-multi"> A multiuser, multitasking operating
	  system

	<p>As we mentioned earlier (<ref id="introduction-debian">),
	  the design of Debian GNU/Linux comes from the Unix operating
	  system. Unlike common desktop OS's such as DOS, Windows, and
	  MacOS, Unix was originally designed for large servers and
	  multiuser systems.

	<p>This means that Debian has features those other OS's
	  lack. It allows a large number of people to use the same
	  computer at once, as long as each user has their own
	  <em>terminal</em>

	  <footnote>(A terminal is just a keyboard and a screen,
	      connected to the computer through the network, over a
	      modem, or directly. Your keyboard and monitor form a
	      terminal which is directly attached to the computer:
	      this special terminal is often called the
	      <em>console</em>.)</footnote>.

	  To permit many users to work at once, Debian must permit
	  many programs and applications to run simultaneously. This
	  feature is called <em>multitasking</em>. 

	<p>Much of the complexity (and power) of Unix-like systems
	  stems from these two features. For example, the system must
	  have a way to keep users from accidentally deleting each
	  other's files, and it has to coordinate the many programs
	  running at once, e.g. to ensure that they don't all use the
	  hard drive at the same time.

	<p>If you keep in mind what Debian was originally designed to
	  do, many aspects of it will make a lot more sense. You'll
	  learn to take advantage of the power of these features.

      <sect id="start-login">Logging in

	<p>To use Debian you must identify yourself to
	  the system. This is so it knows who you are, what you have
	  permission to do, and what your preferences are. 

	<p>To this end, you have a <em>user name</em> or
	  <em>login</em> --- if you installed Debian yourself, you
	  should have been asked to give such a name when you
	  installed. If you are logging on to a system administered by
	  someone else, you'll have to ask them for an account on the
	  system, and a corresponding username.

	<p>You also have a password, so no one else can pretend to be
	  you. This is important, even if you're the only one using
	  your computer: otherwise, anyone could log on to your
	  computer from the internet, and do bad things (see <ref
	  id="advanced-security">). If you're worried about security,
	  you should have a password.

	<p>However, many people prefer to trust others not to do
	  anything malicious with their account; they consider
	  security a barrier to sharing information and cooperating
	  with others, since it fosters an environment of hierarchy
	  and suspicion. This is a perfectly reasonable attitude; it
	  depends on your personal priorities, and your
	  environment. Obviously a home system does not need to be as
	  secure as a military installation. Debian allows you to be
	  as secure or as insecure as you like.

	<p>(Note: This next part will be slightly different if you're 
	  using the X Window System. If you see a login prompt in a
	  box in the middle of the screen, this is X. For now, press
	  <tt>Ctrl</tt>, <tt>Alt</tt>, and <tt>F1</tt> (function key
	  1) all at once to get to a text console. You can return to X
	  later by typing <tt>A-F7</tt>. See <ref id="X"> for
	  details on X.)

	<p>When you start Debian, you'll see a <em>prompt</em> (a
	  prompt is just a request from the computer for some
	  particular information). In this case, the prompt is
	  <tt>login:</tt>.

	<p>You should enter your username, and then your password when
	  it's requested. The password does not appear on the screen
	  as you type it --- that's so no one can look over your
	  shoulder and see what it is. Press <tt>Enter</tt> after both
	  the username and the password. If you type your username or
	  password incorrectly, you'll have to start over.

	<p>If you do it correctly, you'll see a brief message and then
	  a <tt>&dollar;</tt>. The <tt>&dollar;</tt> is the <em>shell
	  prompt</em>: this is where you give commands to the system.
	  
	<p>Try typing the command <tt>whoami</tt> now. To enter a
	  command, type it at the shell prompt --- you should see a
	  <em>cursor</em> to the right of the prompt (a small
	  underscore or rectangle which indicates where you're
	  typing). Always press <tt>RET</tt> (the Enter or Return key)
	  when you're done typing the command.

	<p><tt>whoami</tt> tells your username. You'll then get a new
	  shell prompt.

	<p>For the rest of the manual, when we say to enter a command,
	  you should type it at the shell prompt and press the
	  <tt>RET</tt> key. On some keyboards, this key is labeled
	  <tt>Enter</tt> and on others it's <tt>Return</tt>. Same key,
	  different name.

	<p>When you're done working, you may want to log out of the
	  system. To exit the shell, enter the <tt>exit</tt>
	  command. Keep in mind that if you remain logged in, someone
	  could come along and use your account. Hopefully you can
	  trust those in your office or home not to do this; but if
	  you do not trust your environment, you should be certain to
	  log out when you leave.

      <sect id="start-keys"> Keys
	<p>Before going on, it's important to be familiar with the
	  conventions in this manual for describing key commands. 
	 
	<p>When you should hold down a modifier key and press another
	  key simultaneously, a notation like <tt>C-a</tt> will be
	  used. This means "hold the control key, and type lowercase
	  letter a." Other keys include the Alt key, <tt>A</tt>, and
	  the Meta key <tt>M</tt>. Some keyboards have both Alt and
	  Meta; most home computers have only Alt, but the Alt key
	  behaves like a Meta key. So if you have no Meta key, try the
	  Alt key instead.

	<p>Sometimes you need to hold down more than one modifier;
	  that is written like this: <tt>M-C-a</tt> which means to
	  press Meta, Ctrl, and lowercase a, all at the same time.

	<p>Some keys have a special notation; for example,
	  <tt>RET</tt> (Return/Enter), <tt>DEL</tt> (Delete),
	  <tt>ESC</tt> (Escape). These should be fairly
	  self-explanatory.
	  
	<p>Spaces instead of hyphens mean to type the keys in
	  sequence. So, for example, <tt>C-a x RET</tt> means to type
	  Control and lowercase a at the same time, followed by the
	  letter x, followed by pressing Return.

      <sect id="start-commandline"> Command history and editing
	  the command line

	<p>Whatever you type after the shell prompt before pressing
	  <tt>RET</tt> is called a <em>command line</em> --- it's a
	  line of text that commands the computer to do something. The
	  shell offers several features to make entering command lines
	  easy.

	<p>You can scroll up to previous commands to run them again,
	  or modify them slightly and <em>then</em> run them again.
	  Try this: enter any command, such as <tt>whoami</tt>; then
	  press the up arrow key. The <tt>whoami</tt> command will
	  reappear at the prompt. You can then press <tt>RET</tt> to
	  run <tt>whoami</tt> a second time.

	<p>If you've entered several commands, you can keep pressing
	  the up arrow key to go back through them. This feature is
	  handy if you're doing the same thing several times, or if
	  you type a command wrong and want to go back to fix it.  You
	  can press the down arrow key to move in the other direction,
	  toward your more recent commands. If there are no more
	  commands to move to, the computer will beep.

	<p>You can also move around on the command line to make
	  changes. The easiest way is with the left and right arrow
	  keys --- try typing <tt>whoasmi</tt> instead of
	  <tt>whoami</tt>, then use the left arrow key to move back to
	  the <tt>s</tt>. You can erase the <tt>s</tt> with the
	  <tt>Backspace</tt> or <tt>Delete</tt> keys.

	<p>There are more advanced features as well (no need to
	  memorize them all now, though). Try typing
	  <tt>C-a</tt>. This moves you to the beginning of the
	  line. <tt>C-k</tt> (the <tt>k</tt> stands for "kill")
	  deletes until the end of the line --- try it from the middle
	  of the command line. Using <tt>C-a</tt> followed by
	  <tt>C-k</tt>, you can delete the entire command
	  line. <tt>C-y</tt> pastes the last thing you killed,
	  inserting it at the current cursor position (<tt>y</tt>
	  stands for "yank," as in "yank it back").

	<p>Go ahead and play around with command line editing to get a
	  feel for it. Experiment.

      <sect id="start-root"> Logging in as root

	<p>Since Debian is a multiuser system, it's designed to keep
	  any one user or program from breaking the entire system. The
	  kernel will not allow normal users to change important
	  system files. This means that things stay the way they're
	  supposed to, safe from accidents, viruses, and even
	  malicious pranks. Unlike other OS's, Debian is safe from
	  these threats. You won't need an antivirus program.
	 
	<p>However, sometimes you need to change the important system
	  files --- for example, you might want to install new
	  software, or configure your network connection. To do so,
	  you have to have greater powers than a normal user; you must
	  become the <em>root user</em> (also called the
	  <em>superuser</em>).

	<p>To become root, just log on with the username <tt>root</tt>
	  and the root password, if you have one. Hopefully you
	  remember the password from when you installed the system ---
	  if not, you have a problem.  See FIXME xref.

	<p>At many sites, only the system administrator has the root
	  password, and only the system administrator can do the
	  things that one must be root to do. If you're using your own
	  personal computer, <em>you</em> are the system
	  administrator, of course. If you don't have root privileges,
	  you will have to rely on your system administrator to to
	  perform any tasks that require root privileges.

	<p>Sometimes you'll have the root password even on a shared
	  corporate or educational server, because the sysadmin trusts
	  you to use it properly. In that case, you'll be able to help
	  administer the system and customize it for your needs. But
	  you should be sure to use the password responsibly,
	  respecting other users at all times.

	<p>If you have the password, try logging on as root now.
	  Enter the <tt>whoami</tt> command to verify your identity.
	  Then <em>log out immediately</em>. When you're root, the
	  kernel will not protect you from yourself, because root has
	  permission to do anything at all to the system. For example,
	  you can type <tt>rm /*</tt> and erase your <em>entire
	  system</em> in five keystrokes. (Needless to say, you should
	  NOT type this).  Don't experiment while you're root. In
	  fact, don't do anything as root, unless absolutely
	  necessary. This isn't a matter of security, but rather of
	  stability. Your system will run much better if it can keep
	  you from making silly mistakes.

	<p>You may find the <prgn>su</prgn> command more convenient
	  than logging in as root. <prgn>su</prgn> allows you to
	  assume the identity of another user, usually root unless you
	  specify someone else. (You can remember that <prgn>su</prgn>
	  stands for Super User, though some say it stands for Set
	  UserID.) Try this:

	  <enumlist>
	    <item> Log on as yourself, i.e. not as root.  

	    <item>
		<tt>whoami</tt> <p> Confirm your username.  

	    <item>
		<tt>su</tt> <p> Enter the <tt>su</tt> command. It will
		prompt for a password; enter the root password. If you
		give the correct password, you should see a new shell
		prompt. By default, root's shell prompt is <tt>#</tt>
		rather than <tt>$</tt>.

	    <item>
		<tt>whoami</tt> <p> This should give "root" as your
		new username.

	    <item> 
		<tt>exit</tt> <p> Exit the root shell.
	    <item> 
		<tt>exit</tt> <p> Exit your own shell.
	  </enumlist>

	  When you're doing system administration tasks, you should do
	  as much as possible as yourself. Then <tt>su</tt>, do the
	  part that requires root privileges, and <tt>exit</tt> to
	  turn off privileges so you can no longer harm anything.

	<p>You can use <tt>su</tt> to assume the identity of any user
	  on the system, not just root. To do this, type <tt>su
	  <var>user</var></tt> where <var>user</var> is the user
	  you want to become. You'll have to know their password, of
	  course, unless you're root at the time or they have no
	  password.

      <sect id="start-VC"> Virtual consoles
	  
	<p>The Linux kernel supports <em>virtual consoles</em>.  These
	  are a way of making your single screen and keyboard seem
	  like multiple terminals, all connected to the same
	  system. Thankfully, using virtual consoles is one of the
	  simplest things about Debian: there are "hot keys" for
	  switching among the consoles quickly.  To try it, log in to
	  your system, and type <tt>A-F2</tt> (hold down the left
	  <tt>Alt</tt> key, and press <tt>F2</tt>, that is, function
	  key number 2).

	<p>You should find yourself at another login prompt.  Don't
	  panic: you are now on virtual console (VC) number 2!  Log in
	  here and do some things --- more <tt>whoami</tt>'s or
	  whatever --- to confirm that this is a real login shell.
	  Now you can return to VC number 1, with <tt>A-F1</tt>.  Or
	  you can move on to a <em>third</em> VC, in the obvious way
	  (<tt>A-F3</tt>).

	<p>Debian comes with six VCs enabled by default, accessed with
	  the Alt key and function
	  keys <tt>F1-F6</tt> (technically, there are more
	  VC's enabled, but only 6 of them allow you to log in. The
	  others are used for the X Window System or other special
	  purposes).

	<p>If you're using the X Window System, it will generally
	  start up on the first unused VC --- probably VC 7. Also, to
	  switch from the X VC to one of the first six, you'll have to
	  add <tt>Ctrl</tt> to the key sequence. So that's
	  <tt>C-A-F1</tt> to get to VC 1. But you can go from a text
	  VC to the X VC using only <tt>Alt</tt>. If you never leave
	  X, you won't have to worry about this; X automatically
	  switches you to its VC when it starts up.

	<p>Once you get used to them, VC's will probably become an
	  indispensable tool for getting many things done at once.
	  (The X Window System serves much the same purpose, providing
	  multiple windows rather than multiple consoles). You can run
	  a different program on each VC, or log on as root on one VC
	  and as yourself on another. Or everyone in the family can
	  use their own VC --- this is especially handy if you use X,
	  in which case you can run several X sessions at once, on
	  different VC's.

      <sect id="start-shutdown"> Shutting down
	<p>

	  <em>Do not just turn off the computer! You risk losing
	    valuable data!</em>

	<p>If this is a single user system, you might want to turn the
	  computer off when you're done with it.  

	  <footnote>To avoid possibly weakening some hardware
	      components, only turn off the computer when you're done
	      for the day. Power up and power down are the two
	      greatest contributors to wear and tear on computer
	      components. Turning the computer on and off once a day
	      is probably the best compromise between your electric
	      bill and your computer's lifespan.
	  </footnote>

	<p>
	  Unlike most versions of DOS, it's a bad thing to just hit
	  the power switch when you're done using the computer.  It is
	  also bad to reboot the machine (with the reset button)
	  without first taking proper precautions.  The Linux kernel,
	  in order to improve performance, has a <em>disk cache</em>.
	  This means it temporarily stores information meant for
	  permanent storage in RAM: since memory is thousands of times
	  faster than a disk, this makes many file operations move
	  more quickly.  Periodically, the information Linux has in
	  memory is actually written to the disk. This is called
	  <em>syncing</em>.  In order to turn off or reboot the
	  computer, you'll have to tell the computer to clear
	  everything out of memory and put it in permanent storage.

	<p> To shut down, you'll have to be <tt>root</tt>. As root,
	  just type the command <tt>shutdown -h now</tt>. This will go
	  through the entire shutdown procedure, including the
	  <tt>sync</tt> command which clears the disk cache as
	  described above. When you see <tt>System halted</tt>, it's
	  safe to turn off the computer. If you have Advanced Power
	  Management (APM) support in your kernel and BIOS, the
	  computer might shut itself off and save you the trouble. APM
	  is common in laptops and is also found in certain desktop
	  mainboards.

	<p> To reboot, just type <tt>reboot</tt>, or press C-A-DEL
	  (that's Control, Alt, and Delete). This more or less does
	  the same thing as <tt>reboot</tt>. Some people find it
	  simplest to shut down by typing <tt>C-A-DEL</tt> to reboot,
	  then powering off the computer before the Linux kernel
	  begins to reload. However, once the kernel begins to load,
	  you have to wait for it to finish and properly reboot or
	  shutdown again.

    <chapt id="basics"> <heading> The Basics </heading>

      <sect id="basics-commandline"> The command line and <tt>man</tt>
	  pages

	<p>We've already discussed the <em>command line</em>, that is,
	  commands you type at the shell prompt before you press
	  enter. This section describes the structure of more
	  complicated command lines.

	<p>A minimal command line contains just a command name, such
	  as <tt>whoami</tt>. But other things are possible. For
	  example, you might type:
<example>
man whoami
</example>
	  This command requests the online manual for the
	  <tt>whoami</tt> program (you may have to press the space bar
	  to scroll through the documentation, or press <tt>q</tt> to
	  quit). A more complicated example:

<example>
 man -k Postscript
</example>

	  This command line has three parts. It begins with the
	  command name, <tt>man</tt>. Then it has an <em>option</em>
	  or <em>switch</em>, <tt>-k</tt>. Options change the behavior
	  of a command, invoking particular features or functionality.

	<p>Options are usually indicated with a <tt>-</tt> before
	  them. The GNU utilities also have "long forms" for the
	  options; the long form of <tt>-k</tt> is
	  <tt>--apropos</tt>. Enter <tt>man -h</tt> or <tt>man
	  --help</tt> to get a full list of options for the
	  <tt>man</tt> command. Every command will have its own set of
	  options, though most have <tt>--help</tt> and
	  <tt>--version</tt> options. Some commands are bizarre;
	  <tt>tar</tt>, for example, does not require the <tt>-</tt>
	  before its options, for historical reasons.

	<p>Anything which isn't an option and isn't the command name
	  is an <em>argument</em>. In this case,
	  <tt>Postscript</tt>. Arguments can serve many purposes; most
	  commonly, they are filenames that the command should operate
	  on. In this case, <tt>Postscript</tt> is the word you want
	  <prgn>man</prgn> to search for. In the case of <tt>man
	  whoami</tt>, the argument was the command you wanted
	  information about.

	<p>Some people refer to everything except the command name as
	  the <em>parameters</em> of the command. So options and
	  arguments are both parameters.

	<p>Breaking down the <tt>man -k Postscript</tt> command line:
	  <list>
	    <item> <tt>man</tt>, the command name, tells the computer
		to look at the manual pages. These provide
		documentation for commands. For example, <tt>man
		whoami</tt> will give you documentation on the
		<tt>whoami</tt> command.

	    <item> <tt>-k</tt>, the option, changes the behavior of
		<tt>man</tt>. Normally <tt>man</tt> expects a command
		name for an argument, such as <tt>whoami</tt>, and
		looks for documentation of that command. But with the
		<tt>-k</tt> or <tt>--apropos</tt> option, it expects
		the argument to be a keyword. It then gives a list of
		all manual pages with that keyword in their
		description. Single-letter options can be grouped; so
		to use both the <tt>-a</tt> and the <tt>-u</tt>
		option, you might type <tt>-ua</tt>.

	    <item> <tt>Postscript</tt> is the argument; since we used
		the <tt>-k</tt> option, it's the keyword to search
		for.

	    <item> <tt>-k</tt> and <tt>Postscript</tt> are both
		parameters.
	  </list>
	
	<p>So go ahead and type <tt>man -k Postscript</tt>, and you
	  should see a list of all the manual pages on your system
	  that have something to do with Postscript. If you haven't
	  installed much software, you might see <tt>Postscript:
	  nothing appropriate</tt> instead.
	  
	<sect1 id="basics-commandline-description"> Describing the
	    command line

	  <p>Note: This is a skippable section, if you want to move
	  on.

	  <p>There's a traditional concise way of describing command
	    syntax <footnote><em>Syntax</em> means the permissible
	    ways to combine various options and arguments.</footnote>
	    that you should know. For example, if you type <tt>man
	    man</tt> to get the manual page about <tt>man</tt>, you'll
	    see several syntax descriptions beginning with the command
	    name <tt>man</tt>. One of them will look like this:
	    
<example>
 man -k [-M path] keyword ...      
</example>
	    
	  <p>This is really pretty simple. Anything in brackets
	    (<tt>[]</tt>) is an optional unit. So you don't have to
	    use the <tt>-M</tt> option, but if you do, you must use a
	    <tt>path</tt> argument. For this description, you must use
	    the <tt>-k</tt> option and the <tt>keyword</tt> argument.
	    The <tt>...</tt> means that you could have more of
	    whatever came before it, so you could look up several
	    keywords.

	  <p>Let's look at one of the more complex descriptions from
	    the <tt>man</tt> manual page:

<example>
  man  [-c|-w|-tZT  device]  [-adhu7V] [-m system[,...]] [-L
       locale] [-p string] [-M path] [-P pager] [-r  prompt]  [-S
       list] [-e extension] [[section] page ...] ...
</example>
	    
	    There's no need to go through all of this (and don't worry
	    about what it all means), but do pay attention to the
	    organization of the description.
	    
	  <p>First, clusters of options usually mean you can use one
	    or more of them in different combinations, so
	    <tt>-adhu7V</tt> means you can also use
	    <tt>-h</tt>. However, you can't always use all
	    combinations; this description doesn't make that
	    clear. For example, <tt>-h</tt> is incompatible with other
	    options, but you could do <tt>man -du</tt>. This is an
	    unfortunate inconsistency in this description.

	  <p>Second, the <tt>|</tt> symbol means "or". So you can use
	    <em>either</em> the <tt>-c</tt>, the <tt>-w</tt>,
	    <em>or</em> the <tt>-tZT</tt> options, followed by a
	    <tt>device</tt> argument.

	  <p>Third, notice that you can nest the brackets, since they
	    indicate an optional <em>unit</em>. So if you have a
	    <tt>section</tt>, you must also have a <tt>page</tt>,
	    since <tt>page</tt> is not optional within the
	    <tt>[[section] page]</tt> unit.

	  <p>There's no need to memorize any of this, just keep it
	    in mind as you read documentation.

      <sect id="basics-files"> Files 

	<sect1 id="basics-files-intro"> Introduction to files
	    
	  <p> <em>Files</em> are simply a facility for storing and
	    organizing information, analagous to paper file
	    folders. They're organized into <em>directories</em>,
	    which are called <em>folders</em> on some other
	    systems. Let's look at the organization of files on a
	    Debian system:

	    <taglist>
	      <tag> <tt>/</tt> <item> A simple <tt>/</tt> represents
		  the root directory. All other files and directories
		  are contained in the root directory.

	      <tag> <tt>/home/janeq</tt> <item> This is the home
		  directory of user "janeq". Reading left to right, to
		  get to this directory you start in the root
		  directory, enter directory <tt>home</tt>, then enter
		  directory <tt>janeq</tt>.

	      <tag> <tt>/etc/X11/XF86Config</tt> <item> This is the
		  configuration file for the X Window System. It
		  resides in the <tt>X11</tt> subdirectory of the
		  <tt>/etc</tt> directory. <tt>/etc</tt> is in turn a
		  subdirectory of the root directory, <tt>/</tt>.
		  
	    </taglist>
	    
	  <p> Things to note:
	    <list>
	      <item>Each file or directory is designated by a
		  <em>fully-qualified filename</em>, <em>absolute
		  filename</em>, or <em>path</em>, giving the sequence
		  of directories which must be passed through to reach
		  it. The three terms are synonymous. All absolute
		  filenames begin with the "root" directory.  There's
		  a <tt>/</tt> between each directory or file in the
		  filename.

		<p>The words used here can be confusing. Take the
		  following example:
<example>
/usr/share/keytables/us.map.gz
</example>

		  This is a fully-qualified filename; some people call
		  it a path. However, people will also refer to
		  <tt>us.map.gz</tt> alone as a filename. 
		  There is also another use for the word "path" ---
		  see FIXME xref. The intended meaning is usually
		  clear from the context.

	      <item> The root directory is referred to as simply
		  <tt>/</tt>. Don't confuse this "root" with the root
		  user, the user on your system with "super powers." 

	      <item> Directories are arranged in a tree structure. All
		  absolute filenames start with the root
		  directory. The root directory has a number of
		  branches, such as <tt>/etc</tt> and
		  <tt>/usr</tt>. These subdirectories in turn branch,
		  into still more subdirectories, such as
		  <tt>/etc/init.d</tt> and <tt>/usr/local</tt>. The
		  whole thing together is called the "directory tree."

		<p>You can think of an absolute filename as a route
		  from the base of the tree (<tt>/</tt>) to the end of
		  some branch (a file). You'll also hear people talk
		  about the directory tree as if it were a
		  <em>family</em> tree: thus subdirectories have
		  "parents," and a path shows the complete ancestry of
		  a file.

		<p>There are also relative paths that begin somewhere
		  other than the root directory. More on this later.

	      <item> There's no directory that corresponds to a
		  physical device, such as your hard disk. This
		  differs from DOS and Windows, where all paths begin
		  with a device name such as <tt>C:\</tt>. The
		  directory tree is meant to be an abstraction of the
		  physical hardware, so you can use the system without
		  knowing what the hardware is. All your files could
		  be on one disk --- or you could have 20 disks, some
		  of them connected to a different computer elsewhere
		  on the network. You can't tell just by looking at
		  the directory tree, and nearly all commands work
		  just the same way no matter what physical device(s)
		  your files are really on.

	      <item> Every directory has a name which can contain any
		  letters or symbols <em>except</em> <tt>/</tt>. The
		  root directory is an exception; its name is
		  <tt>/</tt> (pronounced "slash" or "the root
		  directory") and it cannot be renamed.

		  <footnote> While you <em>can</em> use almost any
		      letters or symbols in a file name, in practice
		      it's a bad idea. It is better to avoid any
		      characters that often have special meanings,
		      including: 
		      <tt>{ } ( ) [ ] ' ` " \ / &gt &lt | ; ! # & ^ *
			% @</tt>
		    <p> Also avoid putting spaces
		      in filenames. If you want to separate words in a
		      name, good choices are the period, hyphen, and
		      underscore. You could also capitalize each word,
		      <tt>LikeThis</tt>.
		  </footnote>

	      <item> Filenames are case sensitive. That is,
		  <tt>MYFILE</tt> and <tt>MyFile</tt> are different
		  files.

	    </list>

	  <p> Don't worry if all this isn't completely clear
	    yet. There are many examples to come.

	<sect1 id="basics-files-using"> Using files: a tutorial

	  <p>
	    To use your system you'll have to know how to create,
	    move, rename, and delete files and directories. This
	    section describes how to do so with the standard Debian
	    commands.
	    
	  <p> The best way to learn is to try things. As long as you
	    aren't root (and haven't yet created any important
	    personal files), there's nothing you can mess up too
	    seriously. So jump in -- type each of these commands at
	    the prompt and press enter:

	    <enumlist>
	      <item> <tt>pwd</tt> <p> One directory is always
		  considered the <em>current working directory</em>
		  for the shell you're using. You can view this
		  directory with the <tt>pwd</tt> command, which
		  stands for Print Working Directory. You should see
		  the name of the directory you're working in on the
		  screen - probably <tt>/home/yourname</tt>.

	      <item> <tt>ls</tt> <p> <tt>ls</tt> stands for "list," as
		  in "list files." When you type <tt>ls</tt>, the
		  system displays a list of all the files in your
		  current working directory. If you've just installed
		  Debian, your home directory may well be empty. If
		  your working directory is empty, <tt>ls</tt>
		  produces no output, since there are no files to
		  list.

	      <item> <tt>cd /</tt> <p> <tt>cd</tt> means Change
		  Directory. In this case, you've asked to change to
		  the root directory. Type <tt>pwd</tt> again, and
		  verify that you're working in the root
		  directory. Type <tt>ls</tt>, and see what's in
		  <tt>/</tt>.

	      <item> <tt>cd</tt> <p> Typing <tt>cd</tt> with no
		  arguments selects your home directory as the current
		  working directory --- <tt>/home/yourname</tt>. Try
		  <tt>pwd</tt> to verify this.

	    </enumlist>
	    
	  <p>Before continuing, you should know that there are
	    actually two different kinds of filename. Some of them
	    begin with <tt>/</tt>, the root directory, such as
	    <tt>/etc/profile</tt>. These are called <em>absolute</em>
	    filenames because they refer to the same file no matter
	    what your current directory is. The other kind of filename
	    is <em>relative</em>.

	  <p>Two directory names are used <em>only</em> in relative
	    filenames: <tt>.</tt> and <tt>..</tt>.  The directory
	    <tt>.</tt> refers to the current directory and <tt>..</tt>
	    is the parent directory.  These are "shortcut"
	    directories.  They exist in <em>every</em> directory.
	    Even the root directory has a parent directory --- it's
	    its own parent!
	    
	  <p>So filenames which include <tt>.</tt> or <tt>..</tt> are
	    <em>relative</em>, because their meaning depends on the
	    current directory. If I'm in <tt>/usr/bin</tt> and type
	    <tt>../etc</tt>, then I'm referring to <tt>/usr/etc</tt>.
	    If I'm in <tt>/var</tt> and type <tt>../etc</tt>, then I'm
	    referring to <tt>/etc</tt>. Note that a filename without
	    the root directory at the front implicitly has <tt>./</tt>
	    at the front. So you can type <tt>local/bin</tt> or
	    <tt>./local/bin</tt> and it means the same
	    thing<footnote>There's one exception. If you are using the
	    filenames as the name of a command to run, and <tt>.</tt> is
	    not in your shell's command search path (see FIXME xref),
	    <tt>commandname</tt> won't work but <tt>./commandname</tt>
	    will. But don't worry about it for now. </footnote>

	  <p>A final handy tip: the tilde <tt>~</tt> is equivalent to
	    your home directory. So typing <tt>cd ~</tt> is the same
	    as typing <tt>cd</tt> with no arguments. Also, you can
	    type things like <tt>cd ~/practice/mysubdirectory</tt> to
	    change to the directory
	    <tt>/home/yourname/practice/mysubdirectory</tt>.

	  <p>Here are some more file commands to try out, now that you
	    know about relative filenames. <tt>cd</tt> to your home
	    directory before you begin.
	    
	    <enumlist>
	      
	      <item> <tt>mkdir practice</tt> <p> In your home
		  directory, let's make a directory called
		  <tt>practice</tt>. We'll use this directory to try
		  out some other commands. You might type <tt>ls</tt>
		  to verify that your new directory exists.
		  
	      <item> <tt>cd practice</tt> <p> Change directory to
		  <tt>practice</tt>.

	      <item> <tt>mkdir mysubdirectory</tt> <p> Create a
		  subdirectory of <tt>practice</tt>.

	      <item> <tt>cp /etc/profile .</tt> <p> <tt>cp</tt> is
		  short for "copy."  <tt>/etc/profile</tt> is just a
		  random file on your system, don't worry about what
		  it is for now. We've copied it to <tt>.</tt> ---
		  recall that <tt>.</tt> just means "the directory I'm
		  in now," or the current working directory. So we've
		  created a copy of <tt>/etc/profile</tt>, and put it
		  in our <tt>practice</tt> directory. Try typing
		  <tt>ls</tt> to verify that there's indeed a file
		  called <tt>profile</tt> in your working directory.

	      <item> <tt>more profile</tt> <p> View the contents of
		  the file <tt>profile</tt>. <tt>more</tt> is used to
		  view the contents of text files. It's called
		  <tt>more</tt> because it shows a page of the file at
		  a time, and you press the space bar to see
		  more. <tt>more</tt> will exit when you get to the
		  end of the file, or when you type <tt>q</tt>
		  (quit). 

	      <item> <tt>more /etc/profile</tt> Verify that the
		  original looks just like the copy you made.

	      <item> <tt>mv profile mysubdirectory</tt> <p>
		  <tt>mv</tt> stands for "move." We've moved the file
		  <tt>profile</tt> from the current directory into the
		  subdirectory we created earlier. 

	      <item> <tt>ls</tt> 

	      <item> <tt>ls mysubdirectory</tt> <p> Verify that
		  <tt>profile</tt> is no longer in the current
		  directory, and has moved to <tt>mysubdirectory</tt>.

	      <item> <tt>cd mysubdirectory</tt> <p> Change to the
		  subdirectory.

	      <item> <tt>mv profile myprofile</tt> <p>Note that unlike
		  some operating systems, there is no difference
		  between moving a file and renaming it. Thus there's
		  no separate <tt>rename</tt> command. Note that the
		  second argument to <tt>mv</tt> can be a directory to
		  move the file or directory into, or a new
		  filename. <tt>cp</tt> works the same way.  <p>As
		  usual, you can type <tt>ls</tt> to see the result of
		  <tt>mv</tt>.

	      <item> <tt>mv myprofile ..</tt> <p> Just as <tt>.</tt>
		  means "the directory I'm in now," <tt>..</tt> means
		  "parent of the current directory," in this case the
		  <tt>practice</tt> directory we created earlier. Use
		  <tt>ls</tt> to verify that that's where
		  <tt>myprofile</tt> is now.

	      <item> <tt>cd ..</tt> <p> Change directories to the
		  parent directory --- in this case <tt>practice</tt>,
		  where you just put <tt>myprofile</tt>.

	      <item> <tt>rm myprofile</tt> <p><tt>rm</tt> means
		  "remove" --- this deletes <tt>myprofile</tt>. Be
		  careful!  Deleting a file on a GNU/Linux system is
		  <em>permanent</em> --- there is no undelete. If you
		  <tt>rm</tt> it, it's gone, forever.

	      <item> <tt>rmdir mysubdirectory</tt> <p><tt>rmdir</tt>
		  is just like <tt>rm</tt>, only it's for
		  directories. Notice that <tt>rmdir</tt> only works
		  on empty directories --- if the directory contains
		  files, you must delete those files first, or
		  alternatively use <tt>rm -r</tt> in place of
		  <tt>rmdir</tt>.

	      <item> <tt>rmdir .</tt> <p> Oops! That didn't work. You
		  can't delete a directory you're currently working
		  in.

	      <item> <tt>cd ..</tt> <p> So move out of the current
		  directory, and into its parent directory. Now you
		  can type:

	      <item> <tt>rmdir practice</tt> <p> This will delete the
		  last remnants of your practice session.

	    </enumlist>

	  <p>So now you know how to create, copy, move, rename, and
	    delete files and directories. You also learned some
	    shortcuts, like typing simply <tt>cd</tt> to jump to your
	    home directory, and <tt>.</tt> and <tt>..</tt> to refer to
	    the current directory and its parent, respectively. You
	    should also remember the concept of the <em>root
	    directory</em>, or <tt>/</tt>, and the alias <tt>~</tt>
	    for your home directory.

      <sect id="basics-processes"> Processes 

	<p>We mentioned before that GNU/Linux is a
	  <em>multitasking</em> system. It can do many tasks at
	  once. Each of these tasks is called a <em>process</em>.  The
	  best way to get a sense of this is to type <tt>top</tt> at
	  the shell prompt. You'll get a list of processes, sorted
	  according to how much of the computer's processing time
	  they're using. The order will continuously change before
	  your eyes. At the top of the display, there's some
	  information about the system: how many users are logged in,
	  how many total processes there are, how much memory you have
	  and how much you're using.

	<p>In the far left column, you'll see the user owning each
	  process. The far right column shows which command invoked
	  the process. You'll probably notice that <tt>top</tt>
	  itself, invoked by you, is near the top of the list (since
	  anytime <tt>top</tt> checks on CPU usage, it will be active
	  and using CPU to do the check). 

	<p>Note all the commands ending in "d" --- such as
	  <tt>kflushd</tt> and <tt>inetd</tt> --- the "d" stands for
	  <em>daemon</em>. A daemon is a non-interactive process, that
	  is, it's run by the system and users never have to worry
	  about it. Daemons provide services like internet
	  connectivity, printing, or email.

	<p>Quit <tt>top</tt> now by pressing "q", and reenter top by
	  typing: <tt>top -u <var>yourusername</var></tt>. This asks
	  to see only those processes belonging to you; it's more
	  useful because you can ignore all the daemons and whatever
	  other people are doing. You might notice <tt>bash</tt>, the
	  name of your shell. You'll pretty much always be running a
	  <tt>bash</tt>.

	<p>Note that column two of the <tt>top</tt> display shows you
	  the <em>PID</em>, or process ID number. Each process is
	  assigned a unique PID. You can use the PID to control
	  individual processes --- more on that later. Another useful
	  trick: type "?" to get a list of <tt>top</tt> commands.

	<p>You may wonder about the difference between a "process" and
	  a "program" --- in practice people use the terms
	  interchangeably. Technically, the <em>program</em> is the
	  set of instructions written by a programmer, and kept on
	  disk. The <em>process</em> is the working instantiation of
	  the program kept in memory by Linux. But it's not that
	  important to keep the terms straight.

	<p>Much of your interaction with a computer involves
	  controlling processes. You'll want to start them, stop them,
	  and see what they're up to. Your primary tool for this is
	  the <em>shell</em>.

      <sect id="basics-shell"> What's the shell 

        <p>The <em>shell</em> is a program that allows you to interact
	  with your computer.  It's called a shell because it provides
	  an environment for you to work in --- sort of a little
	  electronic home for you to live in as you compute. (Think
	  hermit crab.) Without some sort of shell, your computer
	  would be pretty useless, as you couldn't tell it what to do.

	<p>The simplest function of the shell is to launch other
	  programs. You type the name of the program you want to 
	  run, followed by the arguments you want, and the shell 
	  asks the system to run the program for you.

	<p>Of course, graphical windowing systems also fill this
	  need. Technically, Windows 95 provides a graphical shell,
	  and the X Window System is another kind of graphical shell
	  --- but "shell" is commonly used to mean "command line
	  shell."

	<p>Needless to say, the hackers who work on shells aren't
	  satisfied with simply launching commands. Your shell has 
	  a bewildering number of convenient features if you want to
	  take advantage of them --- have a look at the man pages for
	  your shell.

	<P>There are countless different shells available; most are
	  based on either the <em>Bourne shell</em> or the <em>C
	  shell</em>, two of the oldest shells. The original Bourne
	  shell's program name is <prgn>sh</prgn> while
	  <prgn>csh</prgn> is the C shell. Bourne shell variants
	  include <prgn>bash</prgn> (Bourne Again Shell from the
	  GNU project, the Debian default), <prgn>ksh</prgn>,
	  <prgn>ash</prgn>, and <prgn>zsh</prgn>. The most common C
	  shell variant is <prgn>tcsh</prgn>.

	<p>Bash is probably the best choice for new users. It is the
	  default, and has all the features you're likely to need. But
	  all the shells have loyal followings; if you want to
	  experiment, install some different shell packages and change
	  your shell with the <prgn>chsh</prgn> command. Just type
	  <tt>chsh RET</tt>, supply a password when asked, and chose a
	  shell. When you next log in, you'll be using the new shell.

      <sect id="basics-jobs"> Managing processes with
	  Bash
	  
	<p>Debian is a multitasking system, so you need a way to do
	  more than one thing at once. Graphical environments like X
	  provide a natural way to do this; they allow multiple
	  windows on the screen at any one time. Naturally, Bash (or
	  any other shell) provides similar facilities.
	  
	<p>Earlier you used <prgn>top</prgn> to look at the different
	  processes on the system. Your shell provides some convenient
	  ways to keep track of only those processes you've started
	  from the command line. Each command line is a <em>job</em>
	  to be carried out by the shell. A job can consist of a
	  single process or a set of processes in a <em>pipeline</em>
	  --- more on pipelines later.

	<p>For now, typing a simple command line will start a
	  one-process job. Try typing <tt>man cp</tt> and the
	  <tt>cp</tt> man page will appear on the screen. The shell
	  will go into the background, and return when you finish
	  reading the man page (or type <tt>q</tt> to quit rather than
	  scrolling through the whole thing).

	<p>But say you're reading the man page, and you want to do
	  something else for a minute. No problem. Type <tt>C-z</tt>
	  while you're reading to <em>suspend</em> the currently
	  foregrounded job, and put the shell in the foreground.  When
	  you suspend a job, Bash will first give you some information
	  on it, and then a shell prompt. You will see something like
	  this on the screen:

<example>
NAME
       cp - copy files

SYNOPSIS
       cp [options] source dest
       cp [options] source... directory
       Options:
       [-abdfilprsuvxPR]  [-S backup-suffix] [-V {numbered,exist
       ing,simple}]   [--backup]   [--no-dereference]   [--force]
       [--interactive] [--one-file-system] [--preserve] [--recur
       sive]  [--update]   [--verbose]   [--suffix=backup-suffix]
       [--version-control={numbered,existing,simple}] [--archive]
       [--parents] [--link]  [--symbolic-link]  [--help]  [--ver
       sion]

DESCRIPTION
--More--
[1]+  Stopped                 man cp
&dollar; 
</example>
	  
	<p>Note the last two lines. The next-to-last is the job
	  information, and then you have a shell prompt.

	<p>Bash assigns a <em>job number</em> to each command line you
	  run from the shell. This allows you to refer to the process
	  easily. In this case, <tt>man cp</tt> is job number 1,
	  displayed as <tt>[1]</tt>. The <tt>+</tt> means that this is
	  the last job you had in the foreground. Bash also tells you
	  the current state of the job --- <tt>Stopped</tt> --- and
	  the corresponding command line.
	  
	<p>There are many things you can do with jobs. With <tt>man
	cp</tt> still suspended, try this:
	  
	  <enumlist>
	    <item><tt>man ls</tt> <p> Start a new job.
		
	    <item><tt>C-z</tt> <p> Suspend the <tt>man ls</tt> job by
		pressing Control and lowercase <tt>z</tt>; you should
		see its job information.

	    <item><tt>man mv</tt> <p> Start yet another job.

	    <item><tt>C-z</tt> <p> Suspend it.
		
	    <item><tt>jobs</tt> <p> Ask Bash for a display of current
	    jobs:

<example>
&dollar; jobs
[1]   Stopped                 man cp
[2]-  Stopped                 man ls
[3]+  Stopped                 man mv
&dollar; 
</example>

		Notice the <tt>-</tt> and <tt>+</tt>, denoting the
		last and next-to-last foregrounded jobs.

	    <item><tt>fg</tt> <p> Place the last foregrounded job (the
		one with the <tt>+</tt> in the foreground again. If
		you press the spacebar, the man page will continue
		scrolling.

	    <item><tt>C-z</tt> <p> Re-suspend <tt>man mv</tt>.

	    <item><tt>%1</tt> <p> This is a shortcut for <tt>fg
		  %1</tt>. You can refer to any job by placing a
		  <tt>%</tt> in front of its number. If you don't
		  specify a command, <tt>fg</tt> is assumed.

	    <item><tt>C-z</tt> <p> Re-suspend <tt>man cp</tt>.

	    <item><tt>kill %1</tt> <p> Kill off job 1. Bash will
		report the job information:
<example>
&dollar; kill %1
[1]-  Terminated              man cp
&dollar; 
</example>

		Bash is only asking the job to quit, and sometimes it
		will not want to do so. For future reference, you
		should know that you can add the <tt>-9</tt> option to
		kill to stop asking and start demanding. You'll get
		output like:

<example>
&dollar; kill -9 %1
[1]-  Killed                  man mv
&dollar; 
</example>

	    <item><tt>top -u <var>yourusername</var></tt> <p> Bring
		the <tt>top</tt> display back up with your processes.
		Look in the right-hand column for the <tt>man ls</tt>
		and <tt>man mv</tt> commands. <tt>man cp</tt> won't be
		there since you killed it. <tt>top</tt> is showing you
		the system processes corresponding to your jobs;
		notice that the PID on the left of the screen does not
		correspond to the job number. 

	      <p>You may not be able to find your processes because
		they're off the bottom of the screen; if you're using
		X, you can resize the <tt>xterm</tt>, otherwise
		[FIXME].

	      <p>Even these simple jobs actually consist of two
		processes, the <tt>man</tt> process and the pager
		<tt>more</tt> which handles scrolling a page at a
		time. You may notice the <tt>more</tt> processes are
		also visible in <tt>top</tt>.

	  </enumlist>

	<p>You can probably figure out how to clean up the remaining
	  two jobs. You can either kill them or foreground each one
	  and exit it.

	<p>One final note: the documentation for Bash is quite good,
	  but it is found in the Info help system rather than the man
	  pages. To read it, type <tt>info bash</tt>. [FIXME xref]
	  There is also more discussion of shell usage in chapter
	  [FIXME xref].

	<p> [FIXME integrate the following, maybe in the later chapter:]
	  
	<p>In the <tt>bash</tt> shell there are lots of different
	   things to do.  First lets use <em>Command Completion</em>.
	   Command Completion is probably The best thing a Unix shell
	   could offer.  Lets see how this works.  From the $ prompt
	   try typing in <em>whoa</em> then hitting the <tt>tab</tt>
	   key.  What should happen is you should see the command
	   <tt>whoami</tt> show up.  Then you can hit the
	   <tt>enter</tt>key, and the <tt>whoami</tt> command will
	   run.  Of course this command should tell you who you are,
	   and should return your login name.  <p>Lets try this out
	   some more, and in the process add some more commands for us
	   to do. From the command prompt type in: <tt>man ali</tt>
	   then the <tt>tab</tt> key once again. Bash should then give
	   you <tt>man alias</tt>.  If you then hit enter, you will
	   see a Manual page on the command alias.  Alias as you can
	   see, allows you set up some of your own special commands,
	   or to always give you special command lines for each
	   command.
	
      <sect id="basics-identity"> Managing your identity

	<p>Note: if you're on a single-user system, e.g. in your
	  home, you probably won't care much about this section.
	  
	<p>Unix-like systems are multiuser, and so you have your own
	  electronic identity as a user on the system. Type <tt>finger
	  <var>yourusername</var></tt> to have a look at some of the
	  information about you that's publically available. To change
	  the name and shell listed there, you can use the commands
	  <tt>chfn</tt> and <tt>chsh</tt>. Only the superuser can
	  change your login (username) and directory. You'll notice
	  that it says "No plan" --- a "plan" is just some information
	  you can make available to others. To create a plan, put
	  whatever information you want people to see in a file called
	  <tt>.plan</tt> --- to do this you'll use a text editor,
	  FIXME xref. Then finger yourself to see your plan. Others
	  can finger you to see your plan, or to check whether you've
	  received new mail or read your mail.

	<p>Note that this finger information is available to the
	  entire internet by default. If you don't want this, read
	  about configuring <tt>inetd</tt> and the file
	  <tt>/etc/services</tt> --- eventually the installation
	  manual will describe this configuration, for now you might
	  try the man pages, or just put nonsense in for your finger
	  information.

    <chapt id="docs"> <heading>  Reading documentation and getting
	help </heading>

      <sect id="docs-sources"> Kinds of documentation <p>
	Unfortunately documentation on Unix-like systems is a little
	disorganized. On Debian, you can find documentation in at
	least the following places:
	  <list>
	   
	    <item> <tt>man</tt> pages, read with the <tt>man</tt>
		command 
		
	    <item> <tt>info</tt> pages, read with the <tt>info</tt>
		command <item>The <tt>/usr/doc/<var>package</var></tt>
		directories, where <var>package</var> is the name of
		the Debian package.
	    
	    <item><tt>/usr/doc/HOWTO/</tt> contains the Linux
		Documentation Project's HOWTO documents.

	    <item> Many commands have a <tt>-h</tt> or <tt>--help</tt>
		option. Type the command name followed by the option.
	    

	    <item>The Debian Documentation Project has written some
		manuals, including this one.

	    <item><url id="http://www.debian.org" name="The Debian web
		site"> has a FAQ and other resources. You can also try
		the <url id="http://www.linux.org" name="Linux web
		site">.
	    
	    <item>You can also buy many proprietary books with helpful
		information. Most people praise the O'Reilly brand
		very highly. However, do consider supporting freely
		modifiable and redistributable manuals when possible.
		If you want hard copy, purchasing free manuals from
		the Free Software Foundation (available at many
		bookstores, such as Borders, and direct from the FSF)
		supports the creation of more free software.
	  </list>
	  
	<p>The diversity exists for many reasons. <tt>info</tt> is
	  supposed to replace <tt>man</tt>, but <tt>man</tt> hasn't
	  disappeared yet, for example.

	<p>So where to look for help? Here are some suggestions:
	  <list>

	    <item> Use the <tt>man</tt> pages and the <tt>--help</tt>
		option to get a quick summary of a command's syntax
		and options. Also use <tt>man</tt> if a program
		doesn't yet have an <tt>info</tt> page.

	    <item> Use <tt>info</tt> if a program has <tt>info</tt>
		documentation.

	    <item> If neither of those work, look in
		<tt>/usr/doc/<var>packagename</var></tt>.

	    <item> <tt>/usr/doc/<var>packagename</var></tt> often has
		Debian-specific information, even if there's a man
		page or info page.

	    <item> Use the <tt>HOWTOs</tt> for instructions on how to
		set up a particular thing, or information on your
		particular hardware. For example, the Ethernet HOWTO
		has a wealth of information on ethernet cards, and the
		PPP HOWTO explains in detail how to set up PPP.

	    <item> Use the Debian Documentation Project manuals for
		conceptual explanations and Debian-specific
		information.

	    <item> If all else fails, ask someone. See <ref
		id="docs-support">.
	  </list>

	<p>Using <tt>man</tt> pages is discussed above in <ref
	    id="basics-commandline">. <tt>info</tt>, viewing files in
	  <tt>/usr/doc</tt>, and asking for help from a person are
	  all discussed in this chapter.

      <sect id="docs-info"> Using info

	<p>A brief keystroke summary/tutorial, mention TkInfo,
	  apologize for ridiculous keystrokes.

      <sect id="docs-textfiles"> Viewing text files with more and less

	<p>Use these to view some docs. Mention zless and when to use
	it.


      <sect id="docs-howtos">HOWTOs 
	  
	<p>In addition to their books, the Linux Documentation Project
	  has made a series of short documents describing how to setup
	  a particular aspect of GNU/Linux. For instance, the
	  SCSI-HOWTO describes some of the complications of using
	  SCSI---a standard way of talking to devices---with
	  GNU/Linux. In general, the HOWTOs have more specific
	  information about particular hardware configuration, and
	  will be more up to date than this manual.

	<p>There is a Debian package for the HOWTOs. If you've
	  installed it, you should have them in
	  /usr/doc/HOWTO. However, you may be able to find more recent
	  versions on the net --- try sunsite.unc.edu.

      <sect id="docs-support"> Getting help from a person

	<p>The correct place to ask for help with Debian is <url
	    id="mailto:debian-user@lists.debian.org" name="the
	    debian-user mailing list">.  If you know how to use IRC
	    (Internet Relay Chat), there is a <tt>#debian</tt> channel
	    on <tt>irc.debian.org</tt>. You can find general GNU/Linux
	    help on the <tt>comp.os.linux.*</tt> Usenet hierarchy. You
	    can search Usenet with <url id="http://www.dejanews.com"
	    name="the DejaNews service">. It is also possible to hire
	    paid consultants to provide guaranteed support services.
	    <url id="http://www.debian.org" name="The Debian web
	    site"> has more information on many of these resources.
	  
	<p>Again, please <em>do not</em> ask the authors of this
	  tutorial for help. We probably don't know the answer to your
	  specific problem anyway; if you mail debian-user, you will
	  get higher-quality responses, and more quickly.

	<p>Always be polite and make an effort to help yourself by
	  reading the documentation. Remember, Debian is a volunteer
	  effort and people are doing you a favor by giving their time
	  to help you. Many of them charge hundreds of dollars for the
	  same services during the day. 

	<sect1 id="docs-support-posting"> Dos and Don'ts of asking a
	    question
	 
	  <p>
	    <list>

	      <item> DO read the obvious documentation first. Things
		  like command options and what a command does will be
		  there.

	      <item> DO check the HOWTO documents if your question is
		  about setting up something, such as PPP or Ethernet.

	      <item> DO try to be sure the answer isn't in this
		  tutorial (though we realize an index would be
		  helpful---we're working on it!).

	      <item> DON'T be afraid to ask, after you've made a basic
		  effort to look it up.

	      <item> DON'T be afraid to ask for conceptual
		  explanations, advice, and other things not often
		  found in the documentation.

	      <item> DO include any information that seems
		  relevant. You'll almost always want to mention the
		  version of Debian you're using. You may also want to
		  mention the version of any pertinent packages: the
		  command <tt>dpkg --status
		  <var>packagename</var></tt> will tell you this. It's
		  also useful to say what you've tried so far and what
		  happened.

	      <item> DON'T apologize for your ignorance, or make
		  excuses for being a newbie. There's no reason
		  everyone should be a GNU/Linux expert to use it, any
		  more than everyone should be a mechanic to use a
		  car.

	      <item> DON'T post or mail in HTML. Some versions of
		  Netscape and Internet Explorer will post in HTML
		  rather than plain text. Most people will not even
		  read these posts, because they are difficult to read
		  in most mail programs. There should be a setting
		  somewhere in the preferences to disable HTML.

	      <item> DO be polite. Remember that Debian is an
		  all-volunteer effort, and anyone who helps you is
		  doing it just because they're a nice person.

	      <item> DO re-mail your question to the list if you've
		  gotten no responses after several days. Perhaps
		  there were lots of messages and it was
		  overlooked. Or perhaps no one knows the answer ---
		  if no one answers the second time, this is a good
		  bet. You might want to try including more
		  information the second time.
		 
	      <item> DO answer questions yourself, when you know the
		  answer. Debian depends on everyone doing their part
		  --- if you ask a question, and later on someone else
		  asks the same question, you'll know how to answer
		  it. Do so!
	    </list>

      <sect id="docs-sysinfo"> Getting information from the system

	<p> When diagnosing problems or asking for help, you'll need
	  to get information about your system. Here are some ways to
	  do so.

	<p> /var/log/*, dmesg, uname -a

    <chapt id="files"> <heading>  More on files </heading>

      <p> In <ref id="basics-files"> we covered moving/renaming files
	with <tt>mv</tt>, copying them with <tt>cp</tt>, removing them
	with <tt>rm</tt> (removing directories with <tt>rmdir</tt>),
	and creating directories with <tt>mkdir</tt>. This chapter
	will cover some more aspects of files.

      <sect id="files-permissions"> Permissions

	<p> GNU and Unix systems are set up to allow many people to
	  use the same computer, while keeping certain files private
	  or keeping certain people from modifying certain files. You
	  can verify this for yourself:

	  <enumlist>
	    <item> Log in as yourself, i.e. <em>NOT</em> as root. 
	           a <tt>whoami</tt> command will tell you who you are

	    <item> <tt>rm /etc/resolv.conf</tt> <p> You should be told
		"Permission denied." <tt>/etc/resolv.conf</tt> is an
		essential system configuration file - you aren't
		allowed to change or remove it unless you're
		root. This keeps you from accidentally messing up the
		system, and if the computer is a public one such as at
		an office or school, it keeps users from messing up
		the system on purpose.

	  </enumlist>

	<p>Now type <tt>ls -l /etc/resolv.conf</tt>  <p> This should
	  give you output that looks something like this:
	  
<example>
-rw-r--r-- 1 root root 119 Feb 23 1997 /etc/resolv.conf
</example>
	  
	  The <tt>-l</tt> option to <tt>ls</tt> requests all that
	  additional information.  The info on the right is easy - the
	  size of the file is 119 bytes, the date the file was last
	  changed is Feb 23 1997, the file's name is
	  <tt>/etc/resolv.conf</tt>. On the left side of the screen,
	  things get a little more complicated.

	<p> First, the brief, technical explanation: the
	  <tt>-rw-r--r--</tt> is the <em>mode</em> of the file, the
	  <tt>1</tt> is the number of hard links to this file (or the
	  number of files in a directory), and the two <tt>root</tt>
	  are the user and group owning the file.

	<p> So that was cryptic. Let's go through it slowly (except
	the hard links part - for that see FIXME xref).

	<sect1 id="files-permissions-groups"> Groups
	    
	  <p> Every file has two owners - a user, and a group. The
	    above case is a little confusing, since there's a group
	    called <tt>root</tt> in addition to the <tt>root</tt>
	    user. Groups are just collections of users who are
	    collectively permitted access to some part of the system.
	    A good example is a <tt>games</tt> group. Just to be mean,
	    you might set up your system so that only people in a
	    <tt>games</tt> group are allowed to play games.

	  <p> A more practical example: say you're setting up a
	    computer for a school.  You might want certain files to be
	    accessible only to teachers, not students, so you put all
	    the teachers in a single group. Then you can tell the
	    system that certain files belong to members of the group
	    <tt>teachers</tt>, and that no one else can access those
	    files. Here are some things you can do to explore groups
	    on your system:
	    
	  <enumlist>

	    <item> <tt>groups</tt> <p> Typing this at the shell prompt
		wiqll tell you what groups you're a member of. It's
		likely that you're a member of only one group, which
		is identical to your username. (FIXME: find what the
		explanation for this is)

	    <item> <tt>more /etc/group</tt> <p> This file lists the
		groups that exist on your system. Notice the
		<tt>root</tt> group (the only member of this group is
		the root user), and the group which corresponds to
		your username. There are also groups like
		<tt>dialout</tt> (users who are allowed to dial out on
		the modem), and <tt>floppy</tt> (users who can use the
		floppy drive). However, your system is probably not
		configured to make use of these groups - it's likely
		that only root can use the floppy or the modem right
		now. For details about this file, try typing <tt>man
		group</tt>.

	    <item> <tt>ls -l /home</tt> <p> Observe how every user's
		directory is owned by that user and that user's
		personal group. (If you just installed Debian, you may
		be the only user.)

	  </enumlist>

	</sect1>
	
	<sect1 id="files-permissions-mode"> Mode
 
	<p> In addition to being owned by one user and one group,
	  every file and directory also has a mode, which determines
	  who's allowed to read, write, and execute the file. There
	  are a few other things also determined by the mode, but
	  they're advanced topics so we'll skip them for now.

	<p> The mode looks like this in the <tt>ls</tt> output:
	  <tt>-rw-r--r--</tt>. There are ten "spaces" here, but the
	  mode actually consists of twelve bits (think of bits as
	  switches which can be on or off). For now, we'll consider
	  only nine of these bits: those that control read, write, and
	  execute permissions for the user owning the file, the group
	  owning the file, and everyone on the system (sometimes
	  called "world"). Notice that three kinds of permission
	  (read, write, execute) times three sets of people who can
	  have permission (user, group, others) makes a total of nine
	  combinations.

	<p> In the mode line, the first "space" gives the type of the
	  file. The <tt>-</tt> in this case means it's a regular
	  file. If it was <tt>d</tt>, we'd be looking at a
	  directory. There are other possibilities too complex to go
	  into now (see FIXME).

	<p> The remaining nine "spaces" are used to display the 12
	  bits that make up the file's mode. The basic 9 bits (read,
	  write, and execute for user, group, and other) are displayed
	  as three blocks of <tt>rwx</tt>. So if all permissions are
	  turned on, the mode will look like this:
	  <tt>-rwxrwxrwx</tt>. (The remaining three bits are displayed
	  by changing the <tt>x</tt> to <tt>s</tt>, <tt>t</tt>,
	  <tt>S</tt>, or <tt>T</tt>, but this is a complex topic we're
	  saving for later.)

	<p> In this context, "read", "write", and "execute" have the
	  following meanings:

	  <list>
	    <item> Read permission, indicated by <tt>r</tt>, gives
		permission to examine the contents of a file. For
		directories, it gives permission to list the contents
		of the directory.

	    <item> Write permission, indicated by <tt>w</tt>, gives
		permission to make changes to a file. For directories,
		it gives permission to create and remove files in the
		directory.

	    <item> Execute permission, indicated by <tt>x</tt>, gives
		permission to run the file as a command. Clearly it
		only makes sense to set execute permission if the file
		actually is a command.

		<p> Since directories can never be executed, the
		  execute bit has a different meaning. For
		  directories, execute permission means permission to
		  access files in the directory. Note that this
		  interacts with write permissions: execute
		  permissions must be set to be able to access files
		  in a directory <em>at all</em>, so without execute
		  permission on a directory, write permission is
		  useless. Execute permission for directories is often
		  called "search" permission, since it really has
		  nothing to do with execution. "File access"
		  permission would probably be a still better name,
		  but no one uses it.
	  </list>

	  <p> Directory modes are a little confusing, so here are some
	  examples of the effects of various combinations:

	    <list>
	    <item> <tt>r--</tt> <p> The user, group, or other with
		these permissions may list the contents of the
		directory, but nothing else. The files in the
		directory can't be read, changed, deleted, or
		manipulated in any way. The only permitted action is
		reading the directory itself, that is, seeing what
		files it contains.

	    <item> <tt>rw-</tt> <p> Write permission has no effect in
		the absence of execute permission, so this mode behaves
		just like the above mode.

	    <item> <tt>r-x</tt> <p> This mode permits the files in a
		directory to be listed, and permits access to those
		files. However, files can't be created or
		deleted. <em>Access</em> means that you can view,
		change, or execute the files as permitted by the
		files' own permissions.

	    <item> <tt>--x</tt> <p> Files in this directory can be
		accessed, but the contents of the directory can't be
		listed, so you have to know what filename you're
		looking for in advance (unless you're a good
		guesser). Files can't be created or deleted.

	    <item> <tt>rwx</tt> <p> You can do anything you want with
		the files in this directory, as long as it's permitted
		by the permissions on the files themselves.

	  </list>

	  <p> Directory write permission determines whether you can
	    delete files in a directory - a read-only file can be
	    deleted, if you have permission to write to the directory
	    containing it. You can't delete a file from a read-only
	    directory, even if you're allowed to make changes to the
	    file. File permissions have nothing to do with deleting
	    files.
	    
	  <p> This also means that if you own a directory you can
	    always delete files from it, even if those files belong to
	    root.
	    
	  <p>Directory execute permission determines whether you have
	    access to files - and thus whether file permissions come
	    into play.  <em> If </em> you have execute permissions to
	    a directory, file permissions for that directory become
	    relevant. Otherwise file permissions just don't matter;
	    you can't access the files anyway.
	    
	  <p> If you have execute permission for the directory, file
	    permissions determine whether you can read the contents of
	    the file, change the file, and/or execute the file as a
	    command.
	    
	  <p> FIXME: Are the next two paragraphs correct?
	    
	  <p> Finally, permission to change permissions on a file or
	    directory is not affected by the permissions of that file
	    or directory. Rather, you can always change the
	    permissions on files or directories that you own, but not
	    on files owned by someone else, as long as you are
	    permitted access to the file. So if you can access a file
	    you own at all (that is, you have execute permission in
	    the directory containing it) then you can change its
	    permissions.
	    
	  <p> This means that you can't permanently remove permissions
	    from yourself because you can always give them back. Say
	    you remove user write permission from a file you own, then
	    try to change the file. It won't be permitted, but you can
	    always give yourself write permission again and
	    <em>then</em> change the file. The qonly way to lose the
	    ability to change permissions back is to lose access to
	    the file entirely.
	    
	</sect1>

	<sect1 id="files-permissions-tutorial"> Permissions in
	practice

	  <p> FIXME: This isn't very thorough. However, it seems like
	    it thorough would make it really long and involve making
	    files as root to show the effects of different ownership,
	    etc. and perhaps it's not worth it.
	    
	  <p> This section goes through a short example session to
	    demonstrate how permissions are used. You can skip this
	    section without loss of continuity.

	  <p> To change permissions, we'll use the <tt>chmod</tt> command.

	    <enumlist>
	      
	      <item> <tt>cd; touch myfile</tt> <p> There are a couple
		  of new tricks here. First, you can use <tt>;</tt> to
		  put two commands on one line.  You can type the
		  above as:

<example>
&dollar cd 
&dollar touch myfile
</example>
		or as:
<example>
&dollar cd; touch myfile
</example>

		and the same thing will end up happening.

		<p> Recall that <tt>cd</tt> by itself returns you to
		  your home directory.  <tt>touch</tt> is normally
		  used to change the modification time of the file to
		  the current time, but it has another interesting
		  feature: if the file doesn't exist, <tt>touch</tt>
		  creates the file. So we're using it to create a file
		  to practice with.  Use <tt>ls -l</tt> to confirm
		  that the file has been created, and notice the
		  permissions mode:

<example>
&dollar ls -l 
-rw-r--r-- 1 havoc havoc 0 Nov 18 22:04 myfile
</example>

		  Obviously the time and user/group names will be
		  different when you try it. The size of the file is
		  0, since <tt>touch</tt> creates an empty
		  file. <tt>-rw-r--r--</tt> is the default permissions
		  mode on Debian (you can change this - see FIXME: add
		  ref to umask).

	      <item> <tt>chmod u+x myfile</tt> <p> This command means
		  to add (<tt>+</tt>) execute (<tt>x</tt>) permissions
		  for the user (<tt>u</tt>) who owns the file. Use
		  <tt>ls -l</tt> to see the effects.
		  
	      <item> <tt>chmod go-r myfile</tt> <p> Here we've
		  subtracted read permission from the group owning the
		  file, and from everyone else (others,
		  <tt>o</tt>). Again use <tt>ls -l</tt> to verify the
		  effects.
		  
	      <item> <tt>chmod ugo=rx myfile</tt> <p> Here we've set
		  (<tt>=</tt>) user, group, and other permissions to
		  read and execute. This sets permissions to
		  <em>exactly</em> what you've specified, and unsets
		  any other permissions. So all <tt>rx</tt> should be
		  set, and all <tt>w</tt> should be unset. Now no one
		  can write to the file.
		  
	      <item><tt>chmod a-x myfile</tt> <p> <tt>a</tt> is a
		  shortcut for <tt>ugo</tt>, or "all". So all the
		  <tt>x</tt> permissions should now be unset.
		  
	      <item> <tt>rm myfile</tt> <p> We're removing the file,
		  but without write permissions.  <tt>rm</tt> will ask
		  if you're sure:
<example>
rm: remove `myfile', overriding mode 0444?
</example>
		  
		  You should respond by typing <tt>y</tt> and pressing
		  enter.  This is a feature of <tt>rm</tt>, not a fact
		  of permissions - permission to delete a file comes
		  from the directory permissions, and you have write
		  permission in the directory. However, <tt>rm</tt>
		  tries to be helpful, figuring that if you didn't
		  want to change the file (and thus removed write
		  permission), you don't want to delete it either, so
		  it asks you.

	  </enumlist>

	<p> What was that <tt>0444</tt> business in the question from
	    <tt>rm</tt>?  Recall that the permissions mode is a
	    twelve-digit binary number, like this:
	    <tt>000100100100</tt>.
	    <tt>0444</tt> is this binary number represented as an
	    octal (base 8) number, which is the conventional way to
	    write a mode. So you can type <tt>chmod 444
	    myfile</tt> instead of <tt>chmod ugo=r myfile</tt>. 
	    See <ref id="advanced-files-permissions">.

	</sect1>


      <sect id="files-tour"> What files are on my system? Where can I
	put my own files?

	<p>Now that you can navigate the directory tree, let's take a
	  guided tour of the files and directories you created when
	  you installed Debian. If you're curious, <tt>cd</tt> to each
	  directory and type <tt>ls</tt> to see its contents. If the
	  listing doesn't fit on the screen, try <tt>ls | more</tt>,
	  where <tt>|</tt> is the "pipe" character, generally found on
	  the same key with backslash.

	  <taglist>
	    <tag> <tt>/</tt> <item> As already mentioned, this is the
		root directory, which contains every other directory.

	    <tag> <tt>/root</tt> <item> But don't get <tt>/</tt>
		confused with <tt>/root</tt>! <tt>/root</tt> is the
		home directory of the root user, or superuser. It's a
		directory called <tt>/root</tt>, but it isn't
		<em>the</em> root directory <tt>/</tt>.

	    <tag> <tt>/home</tt> <item> This is where all normal users
		- that is, all users except root - have their home
		directories. Home directories are named after the user
		who owns them. If you're using a large system at a
		school or business, your system administrator may
		create additional directories to contain home
		directories: <tt>/home1</tt> and <tt>/home2</tt> for
		example.

	      <p> Your home directory is where you put all your
		personal work, email and other information, and
		personal configuration preferences.

	    <tag> <tt>/bin</tt> <item> This directory contains
		"binaries," executable files which are essential to
		the operation of the system. Examples are: the shell
		(<tt>bash</tt>), and the commands you just learned
		such as <tt>cp</tt>.

	    <tag> <tt>/sbin</tt> <item> This directory contains
		"system binaries," things that the root user or system
		administrator might want to use, but probably you
		won't want to use in your day-to-day activities.

	    <tag> <tt>/usr</tt> <item> <tt>/usr</tt> contains most of
		the files you'll be interested in. It has many
		subdirectories: <tt>/usr/bin</tt> and
		<tt>/usr/sbin</tt> are pretty much like <tt>/bin</tt>
		and <tt>/sbin</tt>, except that the directories in
		<tt>/usr</tt> are not considered "essential to the
		operation of the system." 

		<p> While not essential to get the computer
		operating,<tt>/usr</tt> does contain the applications
		you'll use to get real work done. Also in
		<tt>/usr</tt> you'll find the <tt>/usr/man</tt>,
		<tt>/usr/info</tt>, and <tt>/usr/doc</tt> directories
		- these contain manual pages, info pages, and other
		documentation, respectively. And don't forget
		<tt>/usr/games</tt>!

	    <tag> <tt>/usr/local</tt> <item> The Debian system doesn't
		install anything in this directory. You should use it
		if you want to install software that you compile
		yourself, or any software not contained in a Debian
		package. You can also install software in your home
		directory, if you'll be the only one using it.

	    <tag> <tt>/etc</tt> <item> <tt>/etc</tt> contains all the
		system-wide configuration files. Whenever you want to
		change something that affects all users of your
		computer - such as how you connect to the internet, or
		what kind of video card you have - you'll probably
		have to log on as root and change a file in
		<tt>/etc</tt>.

	    <tag> <tt>/tmp</tt> <item> Here you'll find temporary
		files, most of them created by the system. This
		directory is generally erased on a regular basis, or
		every time you reboot the system. You can create files
		here if you want, just be aware they might get deleted
		automatically.

	    <tag> <tt>/var</tt> <item> <tt>/var</tt> contains
		"variable" files, that the system changes
		automatically. For example, incoming mail is stored
		here. The system keeps a log of its actions
		here. There are a number of other automatically
		generated files here as well. You'll mostly be
		interested in the contents of <tt>/var/log</tt>, where
		you can find error messages and try to figure out what
		you're system's up to if something goes wrong.

	  </taglist>

	<p>
	  Clearly there are many more directories on the system, too
	  many to describe every one. We'll get to some of them later
	  in the manual.

	<p>
	  For changing things, you'll usually want to confine yourself
	  to your home directory and <tt>/etc</tt>. On a Debian
	  system, there's rarely an occasion to change anything else,
	  because everything else is automatically installed for you.

	<p> <tt>/etc</tt> is used to configure the <em>system</em> as
	  a whole. You'll use your own home directory, a subdirectory
	  of <tt>/home</tt>, for configuring your own preferences, and
	  storing your personal data. The idea is that on a day-to-day
	  basis you confine yourself to <tt>/home/yourname</tt>, so
	  there's no way you can break anything. Occasionally you log
	  in as root to change something in a system-wide directory,
	  but only when absolutely necessary. Of course, if you're
	  using Debian at a school or business and someone else is the
	  system administrator, you won't have root access and will
	  only be able to change your home directory. This limits what
	  you can do with the system.

      <sect id="files-manager"> Using a filemanager <p>Using Midnight
	Commander or the like instead of manipulating files by hand.
	<p>Not a thorough tutorial, just a mention of the possibility.

    <chapt id="shell"> <heading>  Using the shell </heading>

      <sect id="shell-jobs"> More on job control

	<p>Fill in job control details not covered earlier, kill -9.

      <sect id="shell-variables"> Environment variables

	<p>What they are, how they're inherited. Setting them. 
	  Maybe PAGER as an example, or changing the prompt

	<p>Every process on a Debian system has an <em>environment</em>
	  in which it runs. 
	  
	<sect1 id="shell-variables-parents">

	  FIXME what to do with this section

	  <p>All processes come from an earlier process, called
	    their <em>parent process</em>. 

	    <footnote> You may see a chicken and egg problem
		here. Actually, there is an original process that
		starts all the others; it's process number 1,
		<tt>init</tt>. You can see it running by typing <tt>ps
		u 1</tt>.
	    </footnote>

	    The <prgn>ps</prgn> is a useful tool for exploring
	    processes, and it can be used to examine parent-child
	    relationships.
	  
	    <enumlist>
	      <item><tt>ps f</tt> <p> This command asks to see a list of
		  processes belonging to you, in a format that shows how
		  processes are related. 
	    </enumlist>
	    
	  <p><tt>ps f</tt> might produce output like this:
	  
<example>
$ ps f
$ ps f
  PID  TT STAT   TIME
 7270  p5 S      0:00 bash
15980  p5 R      0:00  \_ ps f
19682  p4 S      0:00 bash
15973  p4 S      0:00  \_ man ps
15976  p4 S      0:00      \_ sh -c /bin/gzip -dc '/var/catman/cat1/ps.1.gz' | { export MAN_PN LESS; MAN_PN='ps(1)'; LESS="$LESS\$-Pm\:\$i
15977  p4 S      0:00          \_ /bin/gzip -dc /var/catman/cat1/ps.1.gz
15978  p4 S      0:00          \_ sh -c /bin/gzip -dc '/var/catman/cat1/ps.1.gz' | { export MAN_PN LESS; MAN_PN='ps(1)'; LESS="$LESS\$-Pm\
15979  p4 S      0:00              \_ less
$ 
</example>
	  
	  <p> Here you can see that I have a number of processes
	    running, including four shells. Two of the shells have child
	    processes: shell process 7270 has child process 15980
	    (<tt>ps f</tt>) and shell 19682 has child process 15973
	    (<tt>man ps</tt>).  <tt>man ps</tt> has in turn invoked a complex
	    set of subprocesses in order to display a man page,
	    fortunately without your intervention.
	    
	  <p> Parents and children have a complex relationship. In
	    general, when a parent dies the child will die as well. So
	    you can kill a whole set of processes --- for example, all
	    the <tt>man ps</tt> children in the above output
	    --- by killing the parent process, 15973.

	  <p> Children also inherit the <em>environment</em> of their
	    parents --- the current working directory, and some
	    special bits of data called <em>environment variables</em>.

      <sect id="shell-path"> Where commands live
	<p>builtins vs. program names, PATH, "type", "whereis"
	  
      <sect id="shell-io"> Controlling input and output
	<p>Stdin, stdout, pipelines, and redirection

      <sect id="shell-modifiers"> Specifying how and when to run
	commands <p>"modifiers" like batch, at, nohup, nice
	  
      <sect id="shell-wildcards"> Filename expansion ("Wildcards")
	<p> ? * []
	  
      <sect id="shell-quoting"> Quoting
	<p> When to quote and why 

      <sect> Interactive/non-interactive FIXME move this

	<P>Bash has two different modes: <em>interactive</em> and
	  <em>non-interactive</em>.  Interactive means you can type
	  into them, and have them do things for you.  Non-interactive
	  shells interpret shell scripts, similar to DOS batch files.
	  You give it a list of commands to carry out, and it goes and
	  does them, but without your intervention. You don't see all
	  the commands being typed in, Of course any output will be
	  recorded somewhere (the standard output, or stdout, normally
	  the screeen or a log file).  We will get more into
	  non-interactive shells a little later on.
	
	<sect1 id="interactive-shells">Interactive shells

	  <P>Interactive shells will take a very long time for one to
	    master, just because they're so powerful --- you'll
	    probably never learn everything!  There is just so much
	    out there that a shell can do, and of course it's always
	    changing.  We will talk about <tt>bash</tt> here, and some
	    basic commands that will make your life with a
	    shell easier.  In bash, one can have several different
	    things going on all at once, and this can get confusing.

	  <P>A shell is a Line Oriented or command line environment.
	    The shell will always prompt you with a prompt, whenever
	    it is waiting on you to do things.  The default debian
	    prompt is a $.
	    At the $ prompt is where you can type in
	    commands to tell linux to do things, it can be a program
	    name, or it can be a "builtin" command that the shell
	    provides for your convenience.


    <chapt id="editor"> <heading> Creating and editing text files
    </heading>

      <sect id="editor-textfile"> What's a text file?  

	<p>A <em>text file</em> is simply a normal file that happens
	  to contain human-readable text. There's nothing special
	  about it otherwise. The other kind of file, a binary file,
	  is meant to be interpreted by the computer.
	  
	<p>You can view either kind of file with the <prgn>less</prgn>
	  file pager, if you have it installed (you should install it
	  if you haven't, it's quite useful). Type <tt>less
	  /etc/profile</tt> to view a sample text file --- notice that
	  you can read the characters, even if their meaning is
	  obscure. Type <tt>less /bin/ls</tt> to view a binary file;
	  as you can see, the <tt>ls</tt> program is clearly not meant
	  to be read by humans. 

	<p>The difference between the two kinds of files is purely a
	  matter of what they contain, unlike some other systems (such
	  as DOS) which actually treat the files differently. 

	<p>Text files can contain shell scripts, documentation,
	  copyright notices, or any other human-readable
	  text. 

	<p>Incidentally, this illustrates the difference between
	  <em>source code</em> and <em>binary
	  executables</em>. <tt>/bin/ls</tt> is a binary executable
	  you can download from Debian, but you can also download a
	  text file which tells the computer how to create
	  <tt>/bin/ls</tt>. This text file is the source
	  code. Comparing <tt>/bin/ls</tt> to <tt>/etc/profile</tt>
	  should tell you how important the source code is if someone
	  wants to understand and modify a piece of software. Free
	  software provides you or your consultants with this
	  all-important source code.

      <sect id="editor-editor"> Text editors
	<p>Used to create and make changes to a text file.
	<p>There are lots.
	<p>We'll be using [some editor, which one?] in this tutorial

      <sect id="editor-tutorial"> Creating and editing a text file
	<p> A little tutorial on this.

    <chapt id="custom_shell"> <heading> Customizing the shell
    </heading>

      <sect id="custom_shell-aliases"> aliases and shell functions
	<p>How to make shortcuts

      <sect id="custom_shell-dotfiles"> .rc files and ls -a
	<p>What they're for, why they're hidden, etc.

      <sect id="custom_shell-login"> Login shell vs. non-login shell
	<p> The difference, which files to edit for each

      <sect id="custom_shell-profile"> Editing .bash_profile <p>A
	little tutorial, perhaps set up some common environment
	variables or handy aliases.  <p>Use some neat text-editing
	tricks.  <p>describe <tt>umask</tt>

      <sect id="custom_shell-etc"> Setting system-wide defaults <p>How
	  to edit shell config files in /etc, and the difference
	  between doing that and doing it in one's own directory.

      <sect id="custom_shell-changing"> Changing your shell

	<p>Just mention the possibility, and why one might want to do
	it.

    <chapt id="X"> <heading> The X Window System </heading>

      <p>This chapter describes the X Window System graphical user
	interface. It assumes that you have already successfully
	configured X as described in the Installation Manual [FIXME
	the install manual is not yet written], and can thus enter the
	X environment by typing <tt>startx</tt> or via <tt>xdm</tt>,
	depending on your choice during configuration.
		  
      <sect id="X-starting"> Starting the X environment

	<p>There are two ways of starting X. The first is to start X
	  manually when you feel like using it. To do so, log in to
	  one of the text consoles, and type <tt>startx</tt>. This
	  will start X and switch you to its VC.

	<p>The second (and recommended) way to use X is with
	  <prgn>xdm</prgn>, or X Display Manager. Basically
	  <prgn>xdm</prgn> just gives you a nice graphical login
	  prompt on the X VC (probably VC 7), and you log in
	  there.

	<p>By default, either method will also start an
	  <tt>xterm</tt>, which is a small window containing a shell
	  prompt. At the shell prompt, you can type any commands just
	  as you would on a text VC. So you can follow all the
	  examples in this tutorial using <tt>xterm</tt>; the only
	  difference between an <tt>xterm</tt> and the text console is
	  that you don't have to log on to the <tt>xterm</tt>, since
	  you already logged on to X. 

	<p>There are also a lot of things you can do only in X, which
	  are covered in this chapter.
	  
	<p>One note: the default <tt>xterm</tt> has a smallish
	  font. If you have a small monitor or very high resolution or
	  bad eyesight, you may want to fix this. Follow these steps:
	  <enumlist>
	    <item> Move the mouse pointer into the center of the
		<tt>xterm</tt> window.
	    <item> Hold down the <tt>Control</tt> key and the
		<em>right</em> mouse button simultaneously. This will
		give you a font menu.
	    <item> Point to the font you want and release the mouse
		button. 
	  </enumlist>

      <sect id="X-intro"> Intro: What is X

	<p>A GUI (Graphical User Interface) is part and parcel of the
	  Windows or Mac operating systems. It's basically impossible
	  to write an application for those systems which does not use
	  the GUI, and the systems can't be used effectively from the
	  command line. GNU/Linux is more <em>modular</em>, that is,
	  made up of many small, independent components which can be
	  used or not according to one's needs and preferences. One of
	  these components is the X Window System, or simply X.
	  
	<p>X itself is a means for programs to talk to your mouse and
	  video card, without knowing what kind of mouse and video
	  card you have. That is, it's an <em>abstraction</em> of the
	  graphics hardware. User applications talk to X, in X's
	  language; X then translates into the language of your
	  particular hardware. This means that programs only have to
	  be written once, and they work on everyone's computer.

	<p>In X jargon, the program which speaks to the hardware is
	  known as an <em>X server</em>. User applications that ask
	  the X server to show windows or graphics on the screen are
	  called <em>X clients</em>.

	<p>The X server doesn't provide any of the features one might
	  expect from a GUI, such as resizing and rearranging
	  windows. A special X client, called a <em>window
	  manager</em>, draws borders and titlebars for
	  windows, resizes and arranges windows, and provides
	  facilities for starting other X clients from a menu. 
	  Specific window managers may have additional
	  features. 

	<p>Window managers available on a Debian system include
	  <tt>fvwm</tt>, <tt>fvwm2</tt>, <tt>icewm</tt>,
	  <tt>afterstep</tt>, <tt>olvwm</tt>, <tt>wmaker</tt>,
	  <tt>mwm</tt>, <tt>twm</tt> and others. You'll probably want
	  to try them all and pick your favorite. <tt>ls
	  /usr/X11R6/bin/*wm*</tt> is an excellent way to see what
	  window managers are on the system (you'll also see a few
	  other things that happen to have <tt>wm</tt> in the name).

	<p>Neither the X server nor the window manager provide a
	  <em>file manager</em>; that is, there aren't any windows
	  containing icons for your files and folders. You can launch
	  a file manager as a separate application; there are many
	  available, though unfortunately there aren't yet any good
	  icon-based ones.  The Gnome desktop project is developing an
	  icon-based file manager and other GUI facilities,
	  however. See <url name="the Gnome project home page"
	  id="www.gnome.org"> for the latest news on this.

	<p>A final feature of X is its <em>network
	    transparency</em>, meaning that X clients don't care if
	  they're talking to an X server on the same machine or an X
	  server somewhere on the network. In practical terms, this
	  means you can run a program on a more powerful remote
	  machine, but display it on your desktop X server. 
	  
      <sect id="X-basics"> Basic X operation

	<sect1 id="X-basics-mouse"> The mouse

	  <p>The mouse in X works pretty much the same as the mouse
	    on other systems, except that it has three buttons. If
	    your mouse only has two, you can simulate the third
	    (middle) button by clicking both buttons
	    simultaneously. This is kind of tricky and annoying, so
	    investing in a &dollar;15 3-button mouse probably isn't
	    a bad idea. These are available at Best Buy, MediaPlay,
	    and similar stores, as well as from dedicated computer
	    retailers.

	  <p>The buttons are numbered from left to right, assuming
	    you have a right-handed mouse, so button one is on the
	    left, two in the middle, three on the right. You may see
	    either the numbers or the locations in documentation.

	  <p>X has a simple built-in copy-and-paste facility. To
	    select text to copy, you click and drag with the left
	    mouse button. This should select the text to copy,
	    assuming the application you're using has copy-and-paste
	    support. To paste the text, you click the middle mouse
	    button in a different X application. For example, if you
	    receive an email containing an URL, you can select the URL
	    with the left button, then click in your web browser's
	    "Location" field with the middle button to paste it in.

	  <sect1 id="X-basics-clients"> X clients
	      
	  <p> Programs that communicate with the X server are called
	    X clients. Most of these programs will ask the X server
	    to display windows on the screen.
	    
	  <p> You start an X client the same way you start any other 
	    Debian program. Simply type the name of the client on the 
	    command line. Try typing <tt>xterm</tt> into an existing 
	    xterm, and a new xterm will appear on the screen.

	  <p> You may notice that the original xterm is now useless,
	    since your shell is waiting for the second xterm to
	    finish. To avoid this problem, you can run the X client in
	    the background --- add a <tt>&amp;</tt> after the command
	    name, like this: <tt>xterm &</tt>. If you forget, you can
	    place a running process in the background.  First suspend
	    the process with <tt>C-z</tt>, and then place it in the
	    background with the <tt>bg</tt> command.

	  <p> If you use a program often, your window manager will
	    generally provide a way to put that program on a
	    convenient graphical menu.

	<sect1 id="X-basics-trouble"> Troubleshooting 

	  <p> Sometimes when you launch an X client from a graphical
	    menu, you won't be able to see any error messages if it
	    fails. You can find any error messages in the file
	    <tt>~/.xsession-errors</tt>.
	      
	<sect1 id="X-basics-leaving"> Leaving the X environment
	    
	  <p>To leave X, you will need to use a menu. Unfortunately
	    for beginners, this is different for every window manager,
	    and for most window managers can be configured in many
	    ways.  If there's an obvious menu, look for an entry like
	    "Exit" or "Close Window Manager." If you don't see a menu,
	    try clicking each of the mouse buttons on the background
	    of the screen.

      <sect id="X-startup"> Customizing your X startup 

	<p> When you start X, Debian will run some shell scripts which
	  start your window manager and other X clients.  By default,
	  a window manager, an <tt>xconsole</tt> and an <tt>xterm</tt>
	  will be started for you.
	  
	<p> You can see what Debian does by default by examining the
	  file <tt>/etc/X11/Xsession</tt>. Note that the behavior of
	  <tt>/etc/X11/Xsession</tt> can be changed by modifying the
	  file <tt>/etc/X11/config</tt>, which specifies a few
	  system-wide preferences. If <tt>/etc/X11/config</tt>
	  contains the line <tt>allow-user-xsession</tt>, then you can
	  customize your X startup.

	<p> To run the clients of your choice when X starts, you
	  create an executable shell script called <tt>.xsession</tt>
	  in your home directory.
	  
	  <enumlist>
	    <item><tt>touch ~/.xsession</tt> <p> This creates the
		file.  

	    <item><tt>chmod u+x ~/.xsession</tt> <p> Make the file
		executable.
	  </enumlist>

	<p> Once <tt>.xsession</tt> is created, you need to edit it 
	  to do something useful with your favorite text editor. 
	  You can do anything you want to in this script. However,
	  when the script's process terminates, X will also
	  terminate. 

	<p> In practical terms this means that you often end the
	  script with a call to <tt>exec</tt>. [FIXME xref explaining
	  exec vs. backgrounded vs. normal] Whatever program you
	  <tt>exec</tt> will replace the script process with itself,
	  so commands found after the <tt>exec</tt> line will be
	  ignored. The program you exec will become the new "owner" of
	  the script process, which means that X will terminate when
	  this new program terminates and the script process
	  disappears.

	<p> Say you end your .xsession with the line: <tt>exec
	    fvwm</tt>.  This means that the <tt>fvwm</tt> window
	  manager will be run when X starts. When you quit the fvwm
	  window manager, your X session will end and all other
	  clients will be shut down. You do not have to use a window
	  manager here; you could <tt>exec xterm</tt>, in which case
	  typing <tt>exit</tt> in that particular xterm would cause
	  the entire X session to end.

	<p> If you want to run other clients before doing your
	  <tt>exec</tt>, you will need to run them in the
	  background. Otherwise <tt>.xsession</tt> will pause until
	  each client exits, then continue to the next line. See the
	  previous section on running jobs in the background [FIXME
	  xref] (basically you want to put an ampersand at the end,
	  e.g. <tt>xterm &amp;</tt>).

	<p> You can take advantage of this behavior, though. If you
	  want to run commands at the end of your X session, you can
	  have your <tt>.xsession</tt> run a window manager or the
	  like and wait for it to finish. That is, leave off the
	  <tt>exec</tt> and the <tt>&amp;</tt>, just put <tt>fvwm</tt>
	  by itself. Then put the commands of your choice after
	  <tt>fvwm</tt>.

	<p> It would probably help to look at a few sample
	  <tt>.xsession</tt> files. In all the examples, replace
	  <tt>fvwm</tt> with the window manager of your choice. 

	<p> The simplest <tt>.xsession</tt> just runs a window
	  manager:

<example>
exec fvwm
</example>

	  This will run fvwm, and the X session will end when fvwm
	  exits. If you do it without the <tt>exec</tt>, everything
	  will appear to behave the same way, but behind the scenes
	  <tt>.xsession</tt> will hang around waiting for fvwm, and
	  <tt>.xsession</tt> will exit after fvwm does. Using
	  <tt>exec</tt> is slightly better because fvwm replaces
	  <tt>.xsession</tt> instead of leaving it waiting. You can
	  use the <tt>ps</tt> or <tt>top</tt> command to verify this.

	<p> A more useful <tt>.xsession</tt> runs a few clients before
	  starting the window manager. For example, you might want an
	  xterm and an xlock whenever you start X. No problem:

<example>
xterm &
xterm &
xclock &
exec fvwm
</example>
	  
	  Two xterms and an xclock start up in the background, and
	  then the window manager is launched. When you quit the
	  window manager, you'll also quit X.

	<p> You might try it without the backgrounding just to see
	  what happens. Do this:

<example>
xterm
xclock
exec fvwm
</example>

	  xterm will start, and wait for you to exit it. Then xclock
	  will start; you'll have to exit xclock before fvwm will
	  start. The commands are run in sequence, since the script
	  waits for each one to exit. In constrast, backgrounding
	  causes the commands to fork off from the main script and
	  continue unsupervised.

	<p> You can use sequential execution to your
	  advantage. Consider the following <tt>.xsession</tt>:

<example>
xterm &
xclock &
fvwm
date &gt&gt ~/logout-time
</example>

	  This will fork off an xterm and an xclock, then run fvwm and
	  wait for it to finish. When you exit fvwm, it will move on
	  to the last line, which appends the current date and time to
	  the file <tt>~/logout-time</tt>. Perhaps you want to keep
	  track of when you stop working every day.

	<p> Finally, you can have a program other than the window
	  manager determine when X exits:

<example>
xclock &
fvwm &
exec xterm
</example>

	  This script will run xlock and fvwm in the background, and
	  then replace itself with xterm. When you exit the xterm,
	  your X session will end.

	<p> The best way to learn how to use <tt>.xsession</tt> is to
	  try some of these things out. Again, be sure you use
	  <tt>chmod</tt> to make it executable --- this is a common
	  error.

      <sect id="X-custom"> Customizing X <p>How to customize keymap,
	concept of X resources <p>What's in /etc/X11/config (or
	perhaps just a reference to the /usr/doc/ file on this).

      <sect id="X-wm"> Customizing the window manager <p>A little
	  tutorial. Pretty much have to pick a particular one to
	  discuss for this section.
	  
    <chapt id="text_tools"> <heading>  Text tools </heading>

      <p>head, tail, grep, wc and so on
	
      <p>(I think this should include "Basic Regular Expressions", as
	they are hard to learn from a man page.)
	
    <chapt id="file_tools"> <heading>  File tools </heading>

      <sect id="file_tools-backup"> Backup tools

	<p> FIXME this section is clearly incomplete

	<p>tar, cpio, dump; also large-scale copying, cp -a etc.
	  
	<p> (Perhaps something on how to back up only /home and /etc
	  if you only have a floppy drive, since many home users won't
	  have a tape drive)
	    
	  <p> How to use tar to copy lots of files, or back up your
	    files.  Tarballs. I'm thinking this should be a brief
	    section aimed at single-user systems, with a more thorough
	    sysadmin discussion in a different manual.

	    <p>Backup commands (contributed by Oliver Elphick, section
	    to be cleaned up and elaborated):

	    <p>dump - dumps one filesystem at a time; its command
	    options assume that you are using half-inch tape (maximum
	    45Mb per reel) so it's a bit annoying when using DAT (2Gb
	    or more). Probably the best for regular backups.  Can't be
	    used for NFS-mounted filesystems.

	    <p>cpio - `find [directories] -print | cpio -ovH newc -B
	    >/dev/st0'

	    <p>tar - `tar cvf /dev/st0 [directories]'

	    <p>afio - like cpio; supports pre-compression of files
	    before archiving.

	    <p>tob - front-end for afio


      <sect id="file_tools-compression"> File compression with
      <tt>gzip</tt>
	  
	  <p> Often it would be nice to make a file smaller: say to
	    download it faster, or so it takes up less space on your
	    disk. The program to do this is called <tt>gzip</tt> (GNU
	    Zip).

	    <enumlist>

	      <item> <tt>cd; cp /etc/profile ./mysamplefile</tt> <p>
		  Switch to your home directory, then copy an
		  arbitrarily chosen file (<tt>/etc/profile</tt>) to
		  your current directory in the process renaming it
		  <tt>mysamplefile</tt>. This gives us a file to play
		  with using <tt>gzip</tt>.

	      <item> <tt>ls -l</tt> <p> List the contents of the
		  current directory.  Note the size of
		  <tt>mysamplefile</tt>.

	      <item> <tt>gzip mysamplefile</tt> <p> Compress <tt>
		    mysamplefile</tt>.

	      <item> <tt>ls -l</tt> <p> Observe the results: <tt>
		    mysamplefile</tt> is now called
		    <tt>mysamplefile.gz </tt>. It's also a good bit
		    smaller.

	      <item> <tt>gunzip mysamplefile.gz; ls -l</tt> <p>
		  Uncompress. Observe that <tt>mysamplefile</tt> has
		  returned to its original state. Notice that to
		  <em>uncompress</em> one uses <tt>gunzip</tt>, not
		  <tt>gzip</tt>.

	      <item> <tt>rm mysamplefile</tt> <p> Remove the file,
		  since it was just to practice with.

	    </enumlist>

      <sect id="file_tools-split"> Splitting files into smaller pieces

	  <p> Sometimes a file is too big to fit on a disk, or you
	    don't want to send a huge file over the net in a single
	    chunk. You can split the file using the <tt>split</tt>
	    utility, and reassemble it using the <tt>cat</tt>
	    (con<em>cat</em>enate) utility.
	    
	  <enumlist>
	      <item> <tt>cd; cp /bin/bash myfile; ls -l myfile</tt>
		<p> Copy the <tt>bash</tt> executable to a file in
		your home directory called <tt>myfile</tt>. Observe
		that <tt>myfile</tt> occupies a little over 300,000
		bytes, or around 300 kilobytes.

	      <item> <tt>split -b100k myfile myprefix</tt>
		<p> Splits the file into sections of 100
		kilobytes, naming the sections <tt>myprefixaa</tt>,
		<tt>myprefixab</tt>, etc. Type <tt>ls -l</tt> so see
		the results.

		<p> You can specify any number after the
		  <tt>-b</tt>: choose one that makes sense. If you
		  leave off the <tt>k</tt>, it will be understood as
		  bytes instead of kilobytes. If you use <tt>m</tt>
		  instead of <tt>k</tt>, it will be understood as
		  megabytes. 

	      <item> <tt>cat myprefix* &gt mynewfile</tt>
		<p> Concatenate all the files and write them to
		<tt>mynewfile</tt>. the <tt>*</tt> and <tt>&gt</tt>
		are tricks you'll learn in a later chapter.

	      <item> <tt>rm myfile mynewfile myprefix*</tt>
		  <p> Remove everything.

	    </enumlist>

      <sect id="file_tools-find"> Finding files
	  
	  <p>There are two different facilities for finding files:
	    <tt>find</tt> and <tt>locate</tt>. <tt>find</tt> searches
	    the actual files in their present state. <tt>locate</tt>
	    searches an index generated by the system every morning at
	    6:42 a.m. (this is a <tt>cron</tt> job, explained
	    elsewhere in this manual). <tt>locate</tt> won't find any
	    files which were created after the index was
	    generated. However, since <tt>locate</tt> searches an
	    index, it's much faster - like using the index of a
	    book rather than looking through the whole thing.

	  <p>To compare the two ways of finding files, pretend you
	    can't remember where the X configuration file
	    <tt>XF86Config</tt> resides.

	    <enumlist>

	      <item> <tt>locate XF86Config</tt> <p> This should be pretty
		  fast. You'll get a list of filenames which <em>contain</em>
		  <tt>XF86Config</tt>, something like this:
<example>
/etc/X11/XF86Config 
/usr/X11R6/lib/X11/XF86Config
/usr/X11R6/lib/X11/XF86Config.eg
/usr/X11R6/man/man5/XF86Config.5x.gz
</example>

	      <item> <tt>find / -name XF86Config</tt> 

		<p> You will hear a lot of disk activity, and this
		  will take a lot longer. If hearing your disk grind
		  for a long time pains you, you may not want to
		  actually type this command.  Results will look
		  something like this:

<example>
/etc/X11/XF86Config 
/usr/X11R6/lib/X11/XF86Config 
find: /var/spool/cron/atjobs: Permission denied 
find: /var/spool/cron/atspool: Permission denied
find: /var/lib/xdm/authdir: Permission denied
</example>

		<p> Notice that <tt>find</tt> only found files which
		  were named <em>exactly</em> <tt>XF86Config</tt>,
		  rather than any files containing that string of
		  letters. Also, <tt>find</tt> actually tried to look
		  in every directory on the system - including some
		  where you didn't have read permissions. Thus the
		  "Permission denied" messages.  <p> The syntax is
		  different as well. You had to specify what directory
		  to search in - <tt>/</tt> - while locate
		  automatically chose the root directory. And you had
		  to specify a search by name, using the
		  <tt>-name</tt> option.  You could also have searched
		  for files using many other criteria, such as
		  modification date or owner.

	    </enumlist>

	  <p> In general <tt>find</tt> is a more powerful utility, and
	    <tt>locate</tt> is faster for everyday quick searches. The
	    full range of possible searches would take a long time to
	    explain; for more details type <tt>info find</tt>, which
	    will bring up the very thorough info pages on
	    <tt>find</tt> and <tt>locate</tt>.

      <sect id="file_tools-file"> Determining a file's contents
	  
	<p> Debian comes with a utility which can guess at the
	    contents of a file for you. It is not always
	    correct. However, it is reasonably accurate, and you can
	    use it to explore your system.
	    
	    <enumlist> 
	      <item><tt>file /bin/cp</tt> <p> You should see
		  something like this:

<example>
/bin/cp: ELF 32-bit LSB executable, Intel 386, version 1, stripped
</example>

		  Skipping the technical parts, this is an executable
		  file for Intel machines.

	      <item><tt>file /etc/init.d/boot</tt>
		<p> Gives this response:

<example>
/etc/init.d/boot: Bourne shell script text
</example>

		  Meaning that this is a text file, containing a
		  Bourne shell script. 
	    </enumlist>

    <chapt id="disks"> <heading>  Using disks </heading>
      
      <sect id="disks-concepts"> Concepts
	  
	<p> It's probably a good idea to explain a little theory
	  before discussing the mechanics of using disks. In
	  particular, the concept of a <em>filesystem</em>. 
	  <footnote>Some people spell it as two words, i.e. "file
	  system". A quick poll of man pages (<tt>man -k
	  filesystem</tt>, <tt>man -k 'file system'</tt>) reveals
	  about an even split. So I'm spelling it as one word. You can
	  do it however you like. :)
	    </footnote>
	  This is confusing, because it has several meanings.

	  <list>

	    <item> <em>The</em> filesystem refers to the whole
		directory tree, starting with the root directory
		<tt>/</tt>, as described above.

	    <item> A "filesystem" in general means any organization of
		files and directories on a particular physical
		device. "Organization" means the hierarchical
		directory structure, and any other information about
		files one might want to keep track of: their size, who
		has permission to change them, etc. So you might have
		one filesystem on your hard disk, and another one on
		each floppy disk.

	    <item> "Filesystem" is also used to mean a <em>type</em>
		of filesystem.  For example, MS-DOS and Windows 3.1
		organize files in a particular way, with particular
		rules: filenames can only have 8 characters, for
		example, and no permissions information is
		stored. Linux calls this the <tt>msdos</tt>
		filesystem. Linux also has its own filesystem, called
		the <tt>ext2</tt> filesystem (version two of the
		"extended" filesystem). You'll use the <tt>ext2</tt>
		filesystem pretty much all the time, unless you're
		accessing files from another operating system or have
		other special needs.
	  </list>

	<p> Any physical device you wish to use for storing files must
	  have at least one filesystem on it.  This means a filesystem
	  in the second sense - a hierarchy of files and directories,
	  along with information about them. Of course, any filesystem
	  has a type, so the third sense will come into play as
	  well. If you have more than one filesystem on a single
	  device, each filesystem can have a different type - for
	  example, you might have both a DOS partition and a Linux
	  partition on your hard disk.

	<p>It's important to distinguish the filesystem from the
	  low-level format of the disk. In the DOS and Macintosh
	  worlds, the filesystem is called the high-level format. When
	  you format a disk using one of those operating systems,
	  generally you both perform a low-level format and create a
	  file system (high-level format).  On GNU and Unix systems,
	  one generally says simply "format" to mean low-level format,
	  and "making a filesystem" to mean high-level format.

	<p>Formatting has to do with the particulars of the physical
	  device, such as the exact physical location of your data on
	  a floppy disk (on the edge or in the center of the disk for
	  example). The filesystem is the level of organization you
	  have to worry about - names of directories and files, their
	  sizes, etc.

      </sect>

      <sect id="disks-mount">  <tt>mount</tt>
	  and <tt>/etc/fstab</tt>
	  
	<p> This section describes how to mount a floppy or Zip disk,
	  the <tt>/dev</tt> directory, and distributing the directory
	  tree over multiple physical devices or partitions.

	<sect1 id="disks-mount-mounting"> Mounting a filesystem

	  <p> As we said earlier, on a GNU/Linux system there's no
	    necessary correspondence between directories and physical
	    devices, as there is in DOS for example where each drive
	    has its own directory tree beginning with a letter (such
	    as <tt>C:\</tt>).

	  <p> Instead, each physical device such as a hard disk or
	    floppy disk has one or more filesystems on it. In order to
	    make a filesystem accessible, it's assigned to a
	    particular directory in another filesystem. To avoid
	    circularity, the root filesystem (which contains the root
	    directory <tt>/</tt>) is not contained by any other
	    filesystem - you have access to it automatically when you
	    boot Debian.

	    <p> A directory in one filesystem which contains another
	    filesystem is known as a <em>mount point</em>. A mount
	    point is a directory in a first filesystem on one device
	    (such as your hard disk) but which contains a second
	    filesystem, perhaps on another device (such as a floppy
	    disk). To access a filesystem, you must mount it at some
	    mount point.

	  <p> So, for example, you might mount a CD at the mount point
	    <tt>/cdrom</tt>. This means that if you look in the
	    directory <tt>/cdrom</tt>, you'll see the contents of the
	    CD. The <tt>/cdrom</tt> directory itself is actually
	    on your hard disk.  For all practical purposes
	    the contents of the CD become a part of the root
	    filesystem, and when typing commands and using programs it
	    doesn't make any difference what the actual physical
	    location of the files is. You could have created a
	    directory on your hard disk called <tt>/cdrom</tt>, and
	    put some files in it, and everything would behave in
	    exactly the same way. Once you mount a filesystem, there's
	    no need to pay any attention to physical devices.

	  <p> However, before mounting a filesystem, or to actually
	    create a filesystem on a disk that doesn't have one yet,
	    it's necessary to refer to the devices themselves. All
	    devices have names, and these are located in the
	    <tt>/dev</tt> directory. If you type <tt>ls /dev</tt> now,
	    you'll see a pretty lengthy list of every possible device
	    you could have on your Debian system.

	  <p> Possible devices include: 

	    <footnote> This isn't a comprehensive list. Generally the
	    documentation for a particular device or program will tell
	    you what device name you want to use. There are hundreds
	    of different device names.</footnote>

	    <list>

	      <item> <tt>/dev/hda</tt> is IDE drive A.  In general,
		  this will be a hard drive. IDE refers to the type of
		  drive - if you don't know what it means, you
		  probably have this kind of drive, because it's the
		  most common. Your DOS/Windows <tt>C:\</tt> partition
		  is likely to be on this drive.

	      <item> <tt>/dev/hdb</tt> is IDE drive B, as you might
		  guess. This could be a second hard drive, or perhaps
		  a CD-ROM drive. Drives A and B are the first and
		  second (master and slave) drives on the primary IDE
		  controller. Drives C and D are the first and second
		  drives on the secondary controller.

	      <item> <tt>/dev/hda1</tt> is the first
		  <em>partition</em> of IDE drive A, usually called
		  <tt>C:\</tt> on a DOS or Windows system.  Notice
		  that different drives are lettered, while specific
		  partitions of those drives are numbered as well.

	      <item> <tt>/dev/sda</tt> is SCSI disk A. SCSI is like
		  IDE, only if you don't know what it is you probably
		  <em>don't</em> have one. They're not very common in
		  home Intel PC's, though they're often used in
		  servers and Macintoshes often have SCSI disks. 

		  <footnote> SCSI devices have a more complicated
		  naming scheme than IDE devices, mostly because SCSI
		  has more uses. The partitions of a SCSI disk have
		  the form <tt>/dev/sda[1-9a-f]</tt>, that is,
		  <tt>/dev/sda</tt> (or <tt>sdb</tt> or <tt>sdc</tt>,
		  etc.) followed by a number or letter from 1--9 or
		  a--f. <tt>/dev/sr0</tt> is the first SCSI CDROM
		  device; general devices such as scanners might look
		  like <tt>/dev/sg0</tt>; <tt>/dev/st0</tt> is a SCSI
		  tape drive. </footnote>

	      <item> <tt>/dev/fd0</tt> is the first floppy drive,
		  generally <tt>A:\</tt> under DOS. Since floppy disks
		  don't have partitions, they only have numbers,
		  rather than the letter-number scheme used for hard
		  drives. However, for floppy drives the numbers refer
		  to the drive, and for hard drives the numbers refer
		  to the partitions.

	      <item> <tt>/dev/ttyS0</tt> is one of your serial
		  ports. <tt>/dev</tt> contains the names of many
		  devices, not just disk drives.
	    </list>

	  <p> To mount a filesystem, we want to tell Linux to
	    associate whatever filesystem it finds on a particular
	    device with a particular mount point. In the process, we
	    might have to tell Linux what kind of filesystem to look
	    for.

	</sect1>

	<sect1 id="disks-mount-cdromexample"> Example: Mounting a
	CD-ROM
	  
	  <p> As a simple demonstration, we'll go through mounting a
	    CD-ROM, such as the one you may have used to install
	    Debian. You'll need to be root to do this, so be careful;
	    whenever you're root you have the power to mess up the
	    whole system, rather than just your own files. Also, these
	    commands assume there's a CD in your drive; you should put
	    one in the drive now.
	    
	    <enumlist>

	      <item> <tt>su</tt>
		  <p> If you haven't already, you need to either log
		  in as root or gain root privileges with the
		  <tt>su</tt> (super user) command. If you use
		  <tt>su</tt>, enter the root password when prompted.

	      <item> <tt>ls /cdrom</tt> <p> See what's in the
		<tt>/cdrom</tt> directory before you start. If you
		don't have a <tt>/cdrom</tt> directory, you may have
		to make one using <tt>mkdir /cdrom</tt>.

	      <item> <tt>mount</tt> <p> Typing simply
		  <tt>mount</tt> with no arguments lists the 
		  currently mounted filesystems.

	      <item> <tt>mount -t iso9660 <var>CD device</var>
		  /cdrom</tt> <p> For this command, you should
		  substitute the name of your CD-ROM device for
		  <tt><var>CD device</var></tt> in the above command
		  line. If you aren't sure, <tt>/dev/hdc</tt> is a
		  good guess. If that fails, try the different IDE
		  devices: <tt>/dev/hda</tt>, etc.  You should see a
		  message like:

<example>
mount: block device /dev/hdc is write-protected, mounting read-only
</example>

		<p>The <tt>-t</tt> option specifies the type of the
		  filesystem, in this case <tt>iso9660</tt>. Most CDs
		  are <tt>iso9660</tt>. The next argument is the name
		  of the device to mount, and the final argument is
		  the mount point. There are many other arguments to
		  <tt>mount</tt>; see the man page for details. (For
		  example, you could avoid the above message by
		  specifying read-only on the command line.)

		<p> Once a CD is mounted, you may find that your
		  drive tray will not open. You must unmount the CD
		  before removing it.

	      <item> <tt>ls /cdrom</tt> <p> Confirm that
		  <tt>/cdrom</tt> now contains whatever is on the CD
		  in your drive.

	      <item> <tt>mount</tt> <p> Look at the list of
		  filesystems again, noticing that your CD drive is
		  now mounted.

	      <item> <tt>umount /cdrom</tt> <p> This unmounts the
		  CD. It's now safe to remove the CD from the drive. 
		  Notice that the command is <tt>umount</tt> with no
		  "n", even though it's used to u<em>n</em>mount the 
		  filesystem.
		  
	      <item> <tt>exit</tt> <p> Don't leave yourself logged
		  on as root. Log out immediately, just to be safe.

	    </enumlist>

	</sect1>

	<sect1 id="disks-mount-fstab"> <tt>/etc/fstab</tt>:
	Automating the mount process
	    
	  <p> The file <tt>/etc/fstab</tt> (it stands for
	    "file system table") contains descriptions of
	    filesystems that you mount often. These filesystems can
	    then be mounted with a shorter command, such as <tt>mount
	      /cdrom</tt>. You can also configure filesystems to mount
	    automatically when the system boots. You'll probably want
	    to mount all of your hard disk filesystems when you boot.
	   
	  <p> Look at this file now, by typing <tt>more
	    /etc/fstab</tt>. It will have two or more entries that
	    were configured automatically when you installed the
	    system. It probably looks something like this:

<example>
# /etc/fstab: static file system information.
#
# &lt;file system&gt     &lt;mount point&gt   &lt;type&gt  &lt;options&gt   &lt;dump &gt  &lt;pass&gt

/dev/hda1            /               ext2    defaults    0       1
/dev/hda3            none            swap    sw          0       0
proc                 /proc           proc    defaults    0       0

/dev/hda5            /tmp            ext2    defaults    0       2
/dev/hda6            /home           ext2    defaults    0       2
/dev/hda7            /usr            ext2    defaults    0       2

/dev/hdc             /cdrom          iso9660 ro          0       0
/dev/fd0             /floppy         auto    noauto,sync 0       0
</example>

	  <p> The first column lists the device the filesystem resides
	    on. The second lists the mount point, the third the
	    filesystem type. The line beginning <tt>proc</tt> is a
	    special filesystem explained in FIXME xref. Notice that
	    the swap partition (<tt>/dev/hda3</tt> in the example) has
	    no mount point, so the mount point column contains
	    <tt>none</tt>.
	    
	  <p>The last three columns may require some explanation.

	  <p> The fifth column is used by the <tt>dump</tt> utility to
	    decide when to back up the filesystem. FIXME: cross ref to
	    <tt>dump</tt>

	  <p> The sixth column is used by <tt>fsck</tt> to decide in
	    what order to check filesystems when you boot the
	    system. The root filesystem should have a <tt>1</tt> in
	    this field, filesystems which don't need to be checked
	    (such as the swap partition) should have a <tt>0</tt>, and
	    all other filesystems should have a <tt>2</tt>. FIXME:
	    cross ref to <tt>fsck</tt>, also, is the swap partition
	    really a filesystem?
	    
	  <p> Column four contains one or more options to use when
	    mounting the filesystem. Here's a brief summary (some of
	    these probably won't make much sense yet - they're here
	    for future reference):

	    <taglist>
	      
	      <tag> <tt>async</tt> and <tt>sync</tt> 
	      
	      <item> Do I/O synchronously or
		  asynchronously. Synchronous I/O writes changes to
		  files immediately, while asynchronous I/O may keep
		  data in buffers and write it later, for efficiency
		  reasons.  FIXME: cross ref to section on sync for
		  full explanation. Also, should recommend when to
		  choose one or the other.

	      <tag> <tt>ro</tt> and <tt>rw</tt> 
		
	      <item> Mount the filesystem read-only or read-write.
		  If you don't need to make any changes to the
		  filesystem, it's a good idea to mount it read-only
		  so you don't accidentally mess something up. Also,
		  read-only devices (such as CD-ROM drives and floppy
		  disks with write protection tabs) should be mounted
		  read-only.
		  
	      <tag> <tt>auto</tt> and <tt>noauto</tt> 

	      <item> When the system boots, or whenever you type
		  <tt>mount -a</tt>, <tt>mount</tt> tries to mount all
		  the filesystems listed in <tt>/etc/fstab</tt>. If
		  you don't want it to automatically mount a
		  filesystem, you should use the <tt>noauto</tt>
		  option. It's probably a good idea to use
		  <tt>noauto</tt> with removable media such as floppy
		  disks, because there may or may not be a disk in the
		  drive. You'll want to mount these filesystems
		  manually after you put in a disk.

	      <tag> <tt>dev</tt> and <tt>nodev</tt>
		
	      <item> Use or ignore device files on this
		  filesystem. You might use <tt>nodev</tt> if you
		  mount the root directory of another system on your
		  system - you don't want your system to try to use
		  the devices on the other system.

	      <tag> <tt>user</tt> and <tt>nouser</tt>

	      <item> Permit or forbid ordinary users to mount the
		  filesystem. <tt>nouser</tt> means that only root can
		  mount the filesystem. This is the normal
		  arrangement. You might use the <tt>user</tt> option
		  to access the floppy drive without having to be root.

	      <tag> <tt>exec</tt> and <tt>noexec</tt> 
		
	      <item> Allow or do not allow the execution of files on
		  this filesystem. Probably you won't need these
		  options.
		  
	      <tag> <tt>suid</tt> and <tt>nosuid</tt> 
		
	      <item> Allow or do not allow the suid bit to take
		  effect. Probably you won't need these options. See
                  FIXME xref.

	      <tag> <tt>defaults</tt> 
		
	      <item> Equivalent to: <tt>rw</tt>, <tt>dev</tt>,
		  <tt>suid</tt>, <tt>exec</tt>, <tt>auto</tt>,
		  <tt>nouser</tt>, <tt>async</tt>. You can specify
		  <tt>defaults</tt> followed by other options to
		  override specific aspects of <tt>defaults</tt>.

	    </taglist>
		  
	</sect1>
	
	<sect1 id="disks-mount-removable"> Removable disks
	    (floppies, Zip disks, etc.)

	  <p> How to use them - setting things up so you can
	  access them nicely from userspace.

	  <p> FIXME I'm actually not sure how to write this. What's in
	    fstab on a default installation? Should we do the manual
	    su root thing, or one of those EZ floppy mounting
	    packages?  Perhaps do something with group permissions? Or
	    just the <tt>user</tt> option in fstab?
				  
	</sect1>

	<sect id="disks-preparing"> Preparing disks
	    for use: formatting and creating a filesystem
	  <p>
	</sect>

      <sect id="disks-lilo"> LILO
	<p>How to configure it, just the basics

    <chapt id="printers"> <heading>  Using printers </heading>

      <sect id="printers-commands"> lpr and friends
	<p>lprm, lpq

      <sect id="printers-setup"> Setting up printers

    <chapt id="network"> <heading>  Setting up networking </heading>

      <p>(single-user dialup or single-user office machine. any other
	possibilities we should cover?)

      <sect id="network-config"> Relevant files in /etc

      <sect id="network-ethernet"> ethernet

      <sect id="network-ppp"> ppp

    <chapt id="terminals"> <heading>  Terminals </heading>

      <p>Somewhere in the manual we should have "what to do if you
	accidentally try to read a binary file and trash your
	screen". Not sure it's worth a whole chapter.
	
      <p>We could also mention:
      <p>What to do if you have a mono display
      <p>A little of the theory behind terminals, terminfo, etc.

    <chapt id="dpkg"> <heading>  Removing and installing software

      <p> This should be about Apt and dpkg

      <sect id="dpkg-dpkg"> The <prgn>dpkg</prgn> package utility 
	  
      <sect id="dpkg-what"> What a package maintenance utility does

	<p>An application or utility program usually involves quite a
	  few files. It might involve libraries, data files like game
	  scenarios or icons, configuration files, and
	  documentation. When you install the program, you want to
	  make sure you have all the files you need in the right
	  place.

	<p>You'd also like to be able to uninstall the program. When
	  you uninstall, you want to be sure all the associated files
	  are deleted. However, if a program you still have on the
	  system needs those files, you want to be sure you keep them.

	<p>Finally, you'd like to be able to upgrade a program. When
	  you upgrade, you want to delete obsolete files and add new
	  ones, without breaking any part of the system.

	<p>The Debian package system solves these problems. It allows
	  you to install, remove, and upgrade software
	  <em>packages</em>, which are neat little bundles containing
	  the program files and information that helps the computer
	  manage them properly. Debian packages have filenames ending
	  in the extension <tt>.deb</tt>, and they're available on the
	  ftp site or on your official Debian CD-ROM.

      <sect id="dpkg-ftp"> Getting the files
	<p> Organization of the ftp site, CD
	<p> Mention non-us packages.
	<p> Describe stable vs. unstable distributions.

      <sect id="dpkg-dselect"> Using Apt
	<p> Help! I don't know how to use apt, so someone else 
	  has to write this.

      <sect id="dpkg-commandline">Using dpkg manually
	<p>The simplest way to install a single package you've
	downloaded is the command <tt>dpkg -i</tt> (short for <tt>dpkg
	--install</tt>. Say you've downloaded the package
	<tt>icewm_0.8.12-1.deb</tt> and you'd like to install
	it. First log on as root, then type: 
<example>
dpkg -i icewm_0.8.12-1.deb
</example>
	  and icewm version 0.8.12 will be installed. If you already
	  had an older version, dpkg will upgrade it rather than
	  installing both versions at once.

	<p>If you want to remove a package, you have two options. The
	  first is most intuitive: 
<example>
dpkg -r icewm
</example>
	  This will remove the icewm package. Note that you give only
	  the 'icewm' for <tt>--remove</tt>, while <tt>--install</tt>
	  requires the entire .deb filename.

	<p><tt>--remove</tt> will leave configuration files for the
	  package on your system. A configuration file is defined as any
	  file you might have edited in order to customize the program
	  for your system or your preferences. This way, if you later
	  reinstall the package, you won't have to set everything up a
	  second time.

	<p>However, you might want to erase the configuration files
	  too, so dpkg also provides a <tt>--purge</tt>
	  option. <tt>dpkg --purge icewm</tt> will permanently delete
	  every last file associated with the icewm package.

      <sect id="dpkg-compiling"> Compiling software yourself
	<p>You'll have to have -dev packages installed.
	<p>Put it in /usr/local, /opt, or your home directory.
	<p> The configure --prefix; make; make install routine.

      <sect id="dpkg-proprietary"> Proprietary software not in .deb
	  format <p>What to do with this annoying stuff (wrapper
	  packages, /usr/local)

    <chapt id="advanced"> <heading>  Advanced topics

	<p>(Should advanced topics be here? I think it would be nice
	to have some of these, just to show people the possibilities
	and give some conceptual explanation that won't really be in a
	reference manual.  Also it always feels nice to make it to a
	chapter called "advanced topics." Self-esteem booster for the
	newbie. :)

      <sect id="advanced-scripting"> Introduction to shell scripting

	<sect1 id="advanced-scripting-why"> What and why
	    <p>Automate simple tasks.

	<sect1 id="advanced-scripting-example"> A simple example
	    <p>Ideas?  

      <sect id="advanced-files"> Advanced files

	<sect1 id="advanced-files-hardlinks"> The real nature of files:
	    hard links and inodes

	  <p> Each file on your system is represented by an
	    <em>inode</em> (eye-node): an inode contains all the
	    information about the file. However, the inode is not
	    directly visible. Instead, each inode is linked into the
	    filesystem by one or more <em>hard links</em>. Hard links
	    contain the name of the file, and the inode number. The
	    inode contains the file itself, i.e., the location of the
	    information being stored on disk, its access permissions,
	    the type of the file, and so on. The system can find any
	    inode once it has the inode number.

	  <p> A single file can have more than one hard link. What
	    this means is that multiple filenames refer to the same
	    file (that is, they are associated with the same inode
	    number). However, you can't make hard links across
	    filesystems: all hard references to a particular file
	    (inode) must be on the same filesystem. (I'm guessing this
	    is because each filesystem has its own set of inodes, and
	    there will be duplicate inode numbers between filesystems.
	    FIXME: find out why for real)

	  <p> Since all hard links to a given inode are referring to
	      <em>the same file</em>, you can make changes to the
	      file, referring to it by one name, and then see those
	      changes referring to it by a different name. Try this:
	    
	    <enumlist>
	      <item> <tt>cd; echo "hello" &gt firstlink</tt>
		<p> <tt>cd</tt> to your home directory and create
		  a file called <tt>firstlink</tt> containing the word
		  "hello". What you've actually done is redirect the
		  output of <tt>echo</tt> (<tt>echo</tt> just echoes
		  back what you give to it), placing the output in
		  <tt>firstlink</tt>. See the chapter on shells for a
		  full explanation.
		  
	      <item> <tt>cat firstlink</tt> 
		<p> Confirm the contents of <tt>firstlink</tt>.
		  
	      <item> <tt>ln firstlink secondlink</tt> <p> Create a
		hard link: <tt>secondlink</tt> now points to the same
		inode as <tt>firstlink</tt>.
		  
	      <item> <tt>cat secondlink</tt> 
		<p> Confirm that <tt>secondlink</tt> is the same as
		  <tt>firstlink</tt>
		  
	      <item> <tt>ls -l</tt> 
		<p> Notice that the number of hard links listed for
		  <tt>firstlink</tt> and <tt>secondlink</tt> is 2.
		  
	      <item> <tt>echo "change" &gt&gt secondlink</tt> 
		<p> This is another shell redirection trick - don't
		  worry about the details. We've appended the word
		  "change" to <tt>secondlink</tt>. Confirm this with
		  <tt>cat secondlink</tt>.
		  
	      <item> <tt>cat firstlink</tt> 
		<p> <tt>firstlink</tt> also has the word "change"
		  appended! It's because <tt>firstlink</tt> and
		  <tt>secondlink</tt> refer to <em>the same
		    file</em>. It doesn't matter what you call it
		  when you change it.
		  
	      <item> <tt>chmod a+rwx firstlink</tt> 
		<p> Change permissions on <tt>firstlink</tt>. Do
		  <tt>ls -l</tt> to confirm that permissions on
		  <tt>secondlink</tt> were also changed. This means
		  that permissions information is stored in the
		  inode, not in links.
		  
	      <item> <tt>rm firstlink</tt> <p> Delete this link. This
		is a subtlety of <tt>rm</tt> - it really removes
		links, not files. Now type <tt>ls -l</tt> and notice
		that <tt>secondlink</tt> is still there. Also notice
		that the number of hard links for <tt>secondlink</tt>
		has been reduced to one.
		  
	      <item> <tt>rm secondlink</tt> 
		<p> Delete the other link. When there are no more
		  links to a file, Linux deletes the file itself, that
		  is, its inode. 
	    </enumlist>

	  <p>All files work like this - even special types of files
	    such as devices (e.g. <tt>/dev/hda</tt>). 
	    
	  <p> A directory is simply a list of filenames and inode
	    numbers, that is, a list of hard links. When you create a
	    hard link, you're just adding a name-number pair to a
	    directory. When you delete a file, you're just removing a
	    hard link from a directory.

	<sect1 id="advanced-files-types"> Types of files

	  <p> One detail we've been concealing up to now is that
	    Debian considers nearly everything to be a file. That
	    includes directories and devices: they're just special
	    kinds of files.
	    
	    <p> As you may remember, the first letter of an <tt>ls
	    -l</tt> display represents the type of the file. For an
	    ordinary file, this will be simply <tt>-</tt>. Other
	    possibilities are:
	    <list> 
	      <item> <tt>d</tt> (directory)
	      <item> <tt>l</tt> (symbolic link)
	      <item> <tt>b</tt> (block device)
	      <item> <tt>c</tt> (character device)
	      <item> <tt>p</tt> (named pipe)
	      <item> <tt>s</tt> (socket)
	    </list>

	  <sect2 id="advanced-files-types-symlinks"> Symbolic links

	    <p> Symbolic links (also called symlinks or soft links)
	      are the other kind of link besides hard links. A symlink
	      is a file (with its own inode and hard link!) that
	      "points to" a hard link on any mounted filesystem. When
	      you try to read the contents of a symlink, it gives the
	      contents of the file it's pointing to rather than the
	      contents of the symlink itself. Since directories,
	      devices, and other symlinks are types of files, you can
	      point a symlink at any of those things.

	    <p> So a hard link is a filename and an inode number. A
	      file is really an inode: a location on disk, file type,
	      permissions mode, etc. A symlink is an inode that
	      contains the name of a hard link.

	    <p> All hard links to the same file have equal
	      status. That is, one is as good as the other; if
	      you perform any operation on one it's just the
	      same as performing that operation on any of the
	      others. This is because the hard links all refer to
	      the same inode. Operations on symlinks, on the other
	      hand, sometimes affect the symlink's own inode (the one
	      containing the name of a hard link) and sometimes affect
	      the hard link being pointed to.

	    <p> There are a number of important differences between
	      symlinks and hard links:

	      <list>
		<item> Symlinks can cross filesystems. (I'm guessing
		    this is because they contain complete filenames,
		    starting with the root directory, and all complete
		    filenames are unique. Since hard links contain
		    inode numbers, they would be ambiguous if the
		    filesystem wasn't known. FIXME: find out for real)

		<item> You can make symlinks to directories, but you
		    can't make hard links to them. Directories can
		    have only one hard link: they can be listed in
		    their parent directory. You can't create
		    additional hard links to a directory. Thus, the
		    output of <tt>ls -l</tt> lists the number of hard
		    links <em>in</em> a directory, and the number of
		    hard links <em>to</em> a file.

		<item> You can only make a hard link to a file that
		    exists, because there must be an inode number to
		    refer to. However, you can make a symlink to any
		    filename, whether or not there actually is such a
		    filename.

		<item> Removing a symlink removes only the link. It
		    has no effect on the linked-to file. Removing the
		    only hard link to a file removes the file.
		    
	      </list>

	      <p> Try this:
	      <enumlist>
		<item> <tt>cd; ln -s /tmp/me MyTmp</tt> <p>
		  <tt>cd</tt> to your home directory. <tt>ln</tt> with
		  the <tt>-s</tt> option makes a symbolic link; in
		  this case, one called <tt>MyTmp</tt> which points to
		  the filename <tt>/tmp/me</tt>.

		<item> <tt>ls -l MyTmp</tt> 
		    <p> Output should look like this:

<example>
lrwxrwxrwx   1 havoc    havoc           7 Dec  6 12:50 MyTmp -> /tmp/me
</example>

		    The date and user/group names will be different
		    for you, of course. Notice that the file type is
		    <tt>l</tt>, indicating that this is a symbolic
		    link. Also notice the permissions - symbolic links
		    always have these permissions. If you attempt to
		    <tt>chmod</tt> a symlink, you'll actually change
		    the permissions on the file being pointed to.
		    
		<item> <tt>chmod 700 MyTmp</tt>
		  <p> You should get a "No such file or directory"
		    error, because the file <tt>/tmp/me</tt> doesn't
		    exist. Notice that you could create a symlink to
		    it anyway.
		    
		<item> <tt>mkdir /tmp/me</tt>
		  <p> Create the directory <tt>/tmp/me</tt>.
		    
		<item> <tt>chmod 700 MyTmp</tt>
		  <p> Should work now.
		    
		<item> <tt>touch MyTmp/myfile</tt>
		  <p> Create a file in <tt>MyTmp</tt>.
		    
		<item> <tt>ls /tmp/me</tt>
		  <p> The file was actually created in
		  <tt>/tmp/me</tt>.

		<item> <tt>rm MyTmp</tt>
		  <p> Remove the symbolic link. Notice that this
		    removes the link, not what it points to. Thus you
		    use <tt>rm</tt> not <tt>rmdir</tt>.

		<item> <tt>rm /tmp/me/myfile; rmdir /tmp/me</tt>
		  <p> Clean up after ourselves.

	      </enumlist>

	  </sect2>

	  <sect2 id="files-misc-types-devices"> Device files

	    <p> Device files refer to physical or virtual devices on
	      your system, such as your hard disk, video card, screen,
	      or keyboard. An example of a virtual device is the
	      console, represented by <tt>/dev/console</tt>.

	    <p> There are two kinds of devices: <em>character
		devices</em> can be accessed one character at a time,
	      that is, the smallest unit of data which can be
	      written to or read from the device is a character
	      (byte).
	      
	    <p> <em>Block devices</em> must be accessed in larger
	      units called blocks, which contain a number of
	      characters. Your hard disk is a block device.
	      
	    <p> You can read and write device files just as you can
	      from other kinds of files, though the file may well
	      contain some strange incomprehensible-to-humans
	      gibberish. Writing random data to these files is
	      probably a Bad Idea. Sometimes it's useful, though: for
	      example, you can dump a postscript file into the printer
	      device <tt>/dev/lp0</tt>, or send modem commands to the
	      device file for the appropriate serial port.

	    <sect3 id="advanced-files-types-devices-creating"> How to
		create device files. <p> <tt>MAKEDEV</tt>
	    </sect3>

	    <sect3 id="advanced-files-types-devices-null">
	    <tt>/dev/null</tt>
		
	      <p> <tt>/dev/null</tt> is a special device file that
		discards anything you write to it. If you don't want
		something, throw it in <tt>/dev/null</tt>. It's
		essentially a bottomless pit. If you read
		<tt>/dev/null</tt>, you'll get an end-of-file (EOF)
		character immediately. <tt>/dev/zero</tt> is similar,
		only if you read from it you get the <tt>\0</tt>
		character (not the same as the number zero).
	    </sect3>

	  <sect2 id="advanced-files-types-pipes"> Named pipes
	      (FIFOs)
	      
	    <p> A named pipe is a file that acts like a pipe. You
	      put something into the file, and it comes out the other
	      end. Thus it's called a FIFO, or First-In-First-Out: the
	      first thing you put in the pipe is the first thing to
	      come out the other end.
	      
	    <p> NOTE: The following explanation probably won't make
	      much sense until you've read about processes and using
	      the shell.

	    <p> If you write to a named pipe, the process which is
	      writing to the pipe doesn't terminate until the
	      information being written is read from the pipe. If you
	      read from a named pipe, the reading process waits until
	      there's something to read before terminating. The size
	      of the pipe is always zero - it doesn't store data, it
	      just links two processes like the shell
	      <tt>|</tt>. However, since this pipe has a name, the two
	      processes don't have to be on the same command line or
	      even be run by the same user.

	    <p> You can try it by doing the following:
	      <enumlist> 
		<item> <tt>cd; mkfifo mypipe</tt>
		    <p> Makes the pipe.

		<item> <tt>echo "hello" > mypipe &</tt>
		    <p> Puts a process in the background which tries
		    to write "hello" to the pipe. Notice that the
		    process doesn't return from the background. Try
		    simply <tt>echo "hello"</tt> without the
		    redirection to see the difference.

		<item> <tt>cat mypipe</tt> 
		  <p> At this point the <tt>echo</tt> process should
		    return, and the <tt>cat</tt> process will print
		    <tt>hello</tt>. 

		<item> <tt>rm mypipe</tt> 
		    <p> You can delete pipes just like any other file.
	      </enumlist>

	  </sect2>

	  <sect2 id="advanced-files-types-sockets"> Sockets 

	    <p> Sockets are similar to pipes, only they work over the
	      network. This is how your computer does networking, and
	      forms the basis for the internet: you may have heard of
	      "WinSock", which is sockets for Windows.

	    <p> We won't go into these further, because you probably
	      won't have occasion to use them unless you're
	      programming. However, if you see a file marked with type
	      <tt>s</tt> on your computer, you know what it is.

	  </sect2>

	</sect1>

	<sect1 id="advanced-files-proc"> The <tt>proc</tt> filesystem

	  <p> The Linux kernel makes a special filesystem available,
	    which is mounted under <tt>/proc</tt> on Debian
	    systems. This is a "pseudo-filesystem" - it doesn't really
	    exist on any of your devices. 

	  <p> The <tt>proc</tt> filesystem contains information
	    about the system and running processes. Some of the
	    "files" in <tt>/proc</tt> are reasonably understandable to
	    humans (try typing <tt>cat /proc/meminfo</tt>) and others
	    are arcane collections of numbers. Often, system utilities
	    use these to gather information and present it to you in a
	    more understandable way.

	  <p> People frequently panic when they notice one file in
	    particular - <tt>/proc/kcore</tt> - which is generally
	    huge. This is (more or less) a copy of the contents of
	    your computer's memory. It's used to debug the kernel. It
	    doesn't actually exist anywhere, so don't worry about its
	    size.

	  <p> If you want to know about all the things in
	    <tt>/proc</tt>, type <tt>man 5 proc</tt>.

	</sect1>

	<sect1 id="advanced-files-permissions"> Advanced aspects of
	file permissions

	  <sect2 id="advanced-files-permissions-absolute"> Using
	  numeric arguments with <tt>chmod</tt>

	    <p>Earlier in this chapter, we briefly mentioned that you
	      can set file permissions using numbers. The numeric
	      notation is called an absolute mode, as opposed to the
	      symbolic notation (e.g. <tt>u+rx</tt>) which is often
	      called a relative mode. This is because the number
	      specifies an exact mode to set, and the symbol just
	      specifies a change to make (e.g. "add user read and
	      execute permissions"). 

	    <p>The numeric mode is a series of four octal digits or
	      twelve binary digits. Each octal (base eight) digit
	      represents three binary digits: one octal digit and
	      three binary digits are two ways to represent the
	      decimal digits 0 through 7.

	    <p>Deriving a particular mode is pretty
	      straightforward. You simply add up the modes you want to
	      combine, or subtract modes you don't want. For example,
	      user permissions, with only read permission turned on,
	      would be <tt>100</tt> in binary. User permissions with
	      write only would be <tt>010</tt> binary. User
	      permissions with read and write both turned on would be
	      <tt>100 + 010 = 110</tt>. Alternatively, you could put
	      it in octal: <tt>4 + 2 = 6</tt>.

	      <p> For the full mode, simply add up digits from this
	      table:

<example>
0001        others, execute
0002        others, write
0004        others, read
0010        group, execute
0020        group, write
0040        group, read
0100        user, execute
0200        user, write
0400        user, read
1000        sticky bit
2000        set group id
4000        set user id
</example>

	    <p>To use the table, first decide what permissions you
	    want to set. Then add up the numbers for those
	    permissions. The total is your mode. For example, to get
	    mode <tt>0755</tt>:

<example>
  0001   o=x
  0004   o=r
  0010   g=x 
  0040   g=r
  0100   u=x
  0200   u=w
+ 0400   u=r
-------
  0755  u=rwx go=rw
</example>

	    <p>You'd actually call this mode simply <tt>755</tt>,
	      without the leading <tt>0</tt>, because <tt>chmod</tt>
	      automatically adds zeroes at the beginning of the mode -
	      so simply <tt>7</tt> becomes mode <tt>0007</tt>. 

	    <p> To set a file to <tt>755</tt>, you'd type <tt>chmod
	      755 myfile</tt>.

	    <p><tt>755</tt> is a very common mode for directories, as
	      it allows anyone to use the directory but only the owner
	      to create and delete files in the directory. <tt>644</tt>
	      is the analogous mode for files, and it is also very
	      common. It allows anyone to use the file but only the
	      owner can change it. For executable files, <tt>755</tt>
	      is a common mode; this is just <tt>644</tt> plus execute
	      permissions (<tt>644 + 111 = 755</tt>).

	  </sect2>

	  <sect2 id="advanced-files-permissions-suid"> Making files
	  suid/sgid
	    <p>
	  </sect2>

	  <sect2 id="advanced-files-permissions-sticky"> Setting the
	  sticky bit
	    <p>
	  </sect2>
	  
	</sect1>


	<sect1 id="advanced-files-chattr"> chattr
	    <p>A useful tip?

	<sect1 id="advanced-files-copying"> Large-scale copying
	  <p>cp -a and variants on the theme. 
	  <p>how to copy an old system to a new one.
	  <p>FIXME whoops, I also listed this topic under Backup
	  Tools. need to decide.

	<sect1 id="advanced-files-undocumented"> Other concepts not
	    yet covered, but should be

	  <p> fsck, dd, fdisk, etc. <p> what package is a file in? <p>
	    MSDOS vs. Mac vs. Unix text files <p> sync </sect1>

      <sect id="advanced-kernel"> Compiling the kernel
	  <p>How, what, and why


      <sect id="advanced-security"> A few words on security
	<p> The basics of security from a user standpoint. Maintaining
	  one's privacy. What other users can see of your account. 

      <sect id="advanced-programming"> Programming on Linux
	<p> Something about the Linux programming environment. Aimed
	  at, say, people taking CS101. Nothing on <em>how</em> to
	  program, just Emacs, gcc, gdb, ddd, etc. as programming
	  tools.
	  
	<p> Likely based on debug.tex 

    <chapt id="next"> <heading>  Where to from here?

      <sect id="next-manuals"> Other Debian manuals to read

      <sect id="next-resources"> Other resources
	  <p>A few good URLs, directions to meta-documents.

    <chapt id="helping"> <heading>  Contributing to Debian: How can I
    help? </heading>

      <sect id="helping-bugs"> Submit bug reports
	  <p>How to do that with the "bug" package

      <sect id="helping-other"> Other things
	  <p>Whatever we want to say here.

    <chapt id="A_apps"> <heading>  Appendix A: A brief survey of
    available applications </heading>

      <p>(Would this be useful? Or does dselect really do the job? It
	seems like there are a significant number of debian-user and
	newsgroup questions to the effect of "I'm looking for an
	application that does X". We could just list what exists, more
	or less, maybe recommend one option over another when there's
	an obvious choice.)

      <sect id="A_apps-whatever"> (Subheadings could copy the
      structure of the menu system)

    </chapt>

    <chapt id="B_components"> <heading> Appendix B: Summary of
	GNU/Linux system components
    </heading>

      <p>You may be a little confused about exactly what GNU/Linux
	is. What's the Linux kernel, vs. the GNU utilities, vs. the X
	Window System? Here's a little ASCII art diagram to show you
	how it all relates (apologies, it's not very attractive).

<example>

 Window Manager ----- Gnome Programs/Libraries (in development)
 |   |	    ----------/                     \
 |   |     /                                 ---------\
 | X Clients         Programs/Applications ---- Shared Libraries
 |   |   \                    |                 /
  \  |    ---------------\    |     /-----------       
  X Server -------------- Linux Kernel 
      |                   /    |
      |   /---------------     |
  Video Card -------- Other Computer Hardware (Memory, disk, etc.)

</example>

      <p>Note that the X Server and X Clients <em>are</em>
	applications, but they are applications which interact in
	special ways with the video hardware and other
	applications. You may wonder why the video card is treated
	specially: applications can speak to it directly, bypassing
	the kernel. This is a historical artifact, being remedied by
	the GGI (General Graphics Interface) project.

      <p>The window manager is a special X Client, and thus also an
	application.  All the X programs use the Shared Libraries, but
	no line appears in the diagram to make it simpler.

      <p>When the Gnome (GNU Network Object Model Environment) project
	is completed, it will help to unify the X environment with a
	special set of programs and libraries, interacting with the
	window manager and other X Clients.

      <p>The GNU utilities are small programs that do simple tasks:
	<tt>mv</tt>, <tt>cp</tt>, <tt>tar</tt> for example.

    </chapt>

    <chapt id="C_booting"> 
      <heading>Appendix C: Booting the system </heading>

      <p>[FIXME really this section requires finding out exactly
	what options the install disks offer, and how the install
	disks word things. "Boot from hard disk," "make a floppy,"
	etc.]
	
      <p>[FIXME really also they've already figured out how to
	boot, since it's part of installation, so perhaps ditch this
	section entirely - it's too long anyway.]
	
      <p>The appendix describes what happens during the GNU/Linux
	boot process.
	
      <p>
	How you boot your system depends on how you set things up
	when you installed Debian. Most likely, you just turn the
	computer on. But you may have to insert a floppy disk first.
	
      <p>Linux is loaded by a program called LILO, or LInux
	LOader. LILO can also load other operating systems, and ask
	you which system you'd like to load.
	
      <p> The first thing that happens when you turn on an Intel PC
	is that the BIOS executes. BIOS stands for Basic Input
	Output System.  It's a program permenantly stored in the
	computer on read-only chips.  It performs some minimal
	tests, and then looks for a floppy disk in the first disk
	drive.  If it finds one, it looks for a "boot sector" on
	that disk, and starts executing code from it, if any.  If
	there is a disk, but no boot sector, the BIOS will print a
	message like:
<example>
Non-system disk or disk error
</example>
	Removing the disk and pressing a key will cause the boot
	process to continue.

      <p>If there isn't a floppy disk in the drive, the BIOS looks
	for a master boot record (MBR) on the hard disk.  It will
	start executing the code found there, which loads the
	operating system.  On GNU/Linux systems, LILO, the LInux
	LOader, can occupy the MBR, and will load GNU/Linux.

      <p>Thus, if you opted to install LILO on your hard drive, you
	should see the word LILO as your computer starts up. At that
	point you can press the left <tt>Shift</tt> key [FIXME or is
	it Alt?] to select which operating system to load - press
	<tt>Tab</tt> to see a list of options. Type in one of those
	options, and press return.  LILO will boot the requested
	operating system.

      <p>If you don't press the <tt>Shift</tt> key, LILO will
	automatically load the default operating system after about
	5 seconds. If you like, you can change what system LILO
	loads automatically, which systems it knows how to load, and
	how long it waits before loading one automatically - see
	[FIXME crossref].

      <p>If you didn't install LILO on your hard drive, you probably
	created a <em>boot disk</em>. The boot disk will have LILO
	on it. All you have to do is insert the disk before you turn
	on your computer and the BIOS will find it before it checks
	the MBR on the hard drive. To return to a non-Linux OS, take
	out the boot disk and restart the computer (from Linux, be
	sure you follow the proper procedure for restarting: see
	<ref id="start-shutdown"> for details.)
	
      <p> LILO loads the Linux kernel from disk, and then lets the
	kernel take over. (The kernel is the central program of the
	operating system, in control of all other programs.) The
	kernel discards the BIOS and LILO.

      <p> On non-Intel platforms, things work a little
	differently. But once you boot, everything is more or less
	the same.

      <p>Linux looks at the type of hardware it's running on.
	It wants to know what type of hard disks you have, whether
	or not you have a bus mouse, whether or not you're on a
	network, and other bits of trivia like that.  Linux can't
	remember things between boots, so it has to ask these
	questions each time it starts up.  Luckily, it isn't asking
	<em>you</em> these questions---it's asking the hardware!
	While it boots, the Linux kernel will print messages on the
	screen describing what it's doing.

      <p>The query process can some cause problems with your system,
	but if it was going to, it probably would have when you
	first installed GNU/Linux.  If you're having problems,
	consult the installation instructions, or ask on a mailing
	list. FIXME add ref to help chapter.

      <p>The kernel merely manages other programs, so once it is
	satisfied everything is okay, it must start another program
	to do anything useful. The program the kernel starts is
	called <prgn>init</prgn>. After the kernel starts
	<prgn>init</prgn>, it never starts another program. The
	kernel becomes a manager and a provider of services.

      <p>Once <prgn>init</prgn> is started, it runs a number of
	scripts (files containing commands), which prepare the
	system to be used: they do some routine maintenance and
	start up a lot of programs which do things like display a
	login prompt, listen for network connections, and keep a log
	of the computer's activities.

      <p> Whew! Anyway, so you've got Debian booted. That was a lot
	of explanation for something that required no intervention
	on your part whatsoever. :)
    </chapt>

    <chapt id="Z_misc"> <heading> Appendix Z: Miscellaneous
    </heading>
      <p>This chapter contains interesting information that didn't fit
      in the rest of the manual, such as historical notes. It may be
      moved to another manual in the future, or made into a coherent
      chapter.

      <sect>Unix History <p>In 1965, Bell Telephone Laboratories (Bell
	Labs, a division of AT&amp T) was working with General
	Electric and Project MAC of MIT to write an operating system
	called Multics. To make a long story slightly shorter, Bell
	Labs decided the project wasn't going anywhere and broke out
	of the group.  This left Bell Labs without a good operating
	system.

	<p>Ken Thompson and Dennis Ritchie decided to sketch out an
	  operating system that would meet Bell Labs' needs.  When
	  Thompson needed a development environment (1970) to run on a
	  PDP-7, he implemented their ideas.  As a pun on Multics,
	  Brian Kernighan, another Bell Labs researcher, gave the
	  system the name Unix.

	<p>Later, Dennis Ritchie invented the "C" programming
	  language. In 1973, Unix was rewritten in C instead of the
	  original assembly language.<footnote>"Assembly language" is
	  a very basic computer language that is tied to a particular
	  type of computer.  It is usually considered a challenge to
	  program in.</footnote> In 1977, Unix was moved to a new
	  machine through a process called <em>porting</em> away from
	  the PDP machines it had run on previously.  This was aided
	  by the fact Unix was written in C since much of the code
	  could simply be recompiled and didn't have to be rewritten.

	<p>In the late 1970's, AT&amp T was forbidden from competing
	  in the computing industry, so it licensed Unix to various
	  colleges and universities very cheaply.  It was slow to
	  catch on outside of academic institutions but was eventually
	  popular with businesses as well. The Unix of today is
	  different from the Unix of 1970.  It has two major
	  variations: System V, from Unix System Laboratories (USL), a
	  subsiderary of Novell<footnote>It was recently sold to
	  Novell.  Previously, USL was owned by AT&amp T.</footnote>,
	  and the Berkeley Software Distribution (BSD).  The USL
	  version is now up to its forth release, or SVR4<footnote>A
	  cryptic way of saying "system five, release
	  four".</footnote>, while BSD's latest version is 4.4.
	  However, there are many different versions of Unix besides
	  these two.  Most commercial versions of Unix derive from one
	  of the two groupings. The versions of Unix that are actually
	  used usually incorporate features from both variations.

	<p>Current commercial versions of Unix for Intel PCs cost
	  between $500 and $2000.

      <sect>GNU/Linux History

	<p>Debian traces its roots to the founding of the GNU project
	  in 1984 by Richard M. Stallman. GNU (GNU's Not Unix) is a
	  project of the Free Software Foundation; their goal was and
	  is to replace the Unix operating system with free
	  software. They had written almost an entire operating system
	  by the early 1990s, but the kernel was missing. Fortunately,
	  Linux appeared to fill this gap.

	<p>The primary author of the Linux kernel is Linus Torvalds.
	  Since his original versions, it has been improved by
	  countless numbers of people around the world.  It is a
	  clone, written entirely from scratch, of the Unix operating
	  system. Neither USL, nor the University of California,
	  Berkeley, were involved in writing Linux.  One of the more
	  interesting facts about Linux is that development occurs
	  simulataneously around the world.  People from Australia to
	  Finland contributed to Linux and will hopefully continue to
	  do so.

	<p>Linux began with a project to explore the 386 chip. One of
	  Linus's earlier projects was a program that would switch
	  between printing <tt>AAAA</tt> and <tt>BBBB</tt>. This later
	  evolved into Linux.

	<p>Linux has been copyrighted under the terms of the GNU
	  General Public License (GPL).  This is a license written by
	  the Free Software Foundation (FSF) that is designed to keep
	  software free. In brief, it says that although you can
	  charge as much as you'd like for a copy, you can't prevent
	  the person you sold it to from selling it, giving it away,
	  or modifying it. It also means that the source
	  code<footnote>The <em>source code</em> of a program is what
	  the human programmer reads and writes.  It is later
	  translated into machine code that the computer
	  interprets.</footnote> must also be available.  This is
	  useful for programmers.  Anybody can modify Linux and even
	  distribute their modifications, provided that they keep the
	  code under the same copyright --- the GPL.

	<p>Debian is called GNU/Linux because it is a product of two
	  massive efforts, the Linux kernel and the GNU
	  project. Still, focusing on only these two contributions
	  leaves out tens of thousands of contributors. It's
	  impossible to keep track of everyone who's made Debian what
	  it is today.

      <sect>The Linux kernel's version numbering
	<p>
	  The first number in Linux's version number indicates truly
	  huge revisions.  These change very slowly: right now version
	  2 is the latest.  The second number indicates less major
	  revisions.  Even second numbers signify more stable,
	  dependable versions of Linux while odd numbers are
	  developer's versions that are more prone to bugs.  The final
	  version number is the minor release number---every time a
	  new version is released that may just fix small problems or
	  add minor features, that number is increased by one. Right
	  now the stable kernel is 2.0, and the developer's kernel is
	  2.1. When 2.1 is ready, it will become stable kernel
	  2.2. The latest version of the stable kernel is currently
	  2.0.34, though that may well change by the time you read
	  this.

	<p>Linux is a large system and unfortunately contains bugs
	  which are found and then fixed.  Although some people still
	  experience bugs regularly, it is normally because of
	  non-standard or faulty hardware; bugs that effect everyone
	  are now few and far between.

	<p>Of course, those are just the kernel bugs.  Bugs can be
	  present in almost every facet of the system, and
	  inexperienced users have trouble separating different
	  programs from each other. For instance, a problem might
	  arise that all the characters are some type of
	  gibberish---is it a bug or a "feature"?  Surprisingly, this
	  is a feature---the gibberish is caused by certain control
	  sequences that somehow appeared.  Hopefully, this book will
	  help you to tell the different situations apart.

      <sect>Proprietary Software for GNU/Linux 

	<p> There is a lot of proprietary software available for
	  GNU/Linux.  Starting with Motif, a user interface for the X
	  Window System that vaguely resembles Microsoft Windows,
	  GNU/Linux is supported more and more proprietary products.
	  These days you can buy anything from WordPerfect
	  (a popular word processor) to Maple, a complex symbolic
	  manipulation package, for GNU/Linux. In most cases, however,
	  if a free software equivalent exists it will be a superior
	  product.

	<p>For readers interested in the legalities of GNU/Linux, the
	  use of proprietary software is allowed by the GNU/Linux
	  license.  While the GNU General Public License covers the
	  GNU/Linux kernel and would seemingly bar commercial
	  software, the GNU Library General Public License covers most
	  of the computer code applications depend on.  This allows
	  commercial software providers to sell their applications and
	  withhold the source code.

	<p>Please note that the GPL and LGPL are copyright notices,
	  and not licenses to use. They do <em>not</em> regulate how
	  you may use the software, merely under what circumstances
	  you can copy it and any derivative works.  To the Free
	  Software Foundation, this is an important distinction:
	  GNU/Linux doesn't involve any "shrink-wrap" licenses but is
	  merely protected by the same law that keeps you from
	  photocopying a book.

    </chapt>

  </book>
</debiandoc>

