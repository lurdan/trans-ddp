  <!doctype debiandoc system>
  <debiandoc>
    <book>
      <titlepag>
	<title>Iniciación a  Debian (Obsolete Documentation)</title>
	<author><name>Havoc Pennington</name><email>hp@debian.org</email>

	<version><date>

	<copyright>
	  <copyrightsummary> &copy; 1998 Software para el Interés
	    Público y colaboradores individuales.</copyrightsummary>

	  <p>Se autoriza la distribución de copias literales de este
	    manual siempre que el copyright y esta licencia se
	    incluyan en todas las copias.

	  <p>Se autoriza la copia y distribución de versiones
	    modificadas de este manual bajo las condiciones para la
	    copia literal, siempre que las separatas "La Licencia
	    Pública General de GNU", "La Licencia Pública General de GNU
	    para bibliotecas", y otras secciones claramente señaladas
	    bajo copyright independiente se reproduzcan de acuerdo con
	    las condiciones especificadas por ellas mismas, y siempre
	    que el trabajo resultante, en su totalidad, se distribuya
	    bajo los términos de una licencia idéntica a esta.

	  <p>Se autoriza la copia y distribución de traducciones de
	    este manual a otro idioma en las condiciones establecidas
	    para las versiones modificadas.  Pueden incluirse "La
	    Licencia Pública General de GNU" y "La Licencia Pública
	    General de GNU para bibliotecas" en la traducción aprobada
	    por la Fundación para el Software Libre en lugar del
	    original inglés.

	  <p>A su elección, puede distribuir versiones literales y
	    modificadas de este documento en los términos de la Licencia
	    Pública General de GNU, excepto las secciones claramente
	    señaladas que se mantienen bajo copyright independiente.

	</copyright>

      </titlepag>

      <toc>

      <chapt id="about"> <heading> Acerca de este manual </heading>

	<p>Este es el manual de Iniciación a Debian.  Está dirigido a
	  lectores recién llegados a Debian GNU/Linux.  No asume
	  conocimientos previos de GNU/Linux u otros sistemas
	  semejantes a Unix, pero sí asume un conocimiento básico y
	  general sobre ordenadores y hardware (usted debería saber
	  cuáles son los componentes básicos de un ordenador, y para
	  qué puede utilizarse una computadora).

	<p>Este manual está estructurado para ser leído en orden; cada
	  capítulo supone cierto conocimiento de los capítulos
	  anteriores, aunque KKKK puede resultarle útil.

	<p>Hay también planes para una Guía de Referencia de Debian, que
	  será más exhaustiva pero menos introductoria.

	<p>Esta introducción a Debian presume que usted ya ha
	  instalado y configurado Debian GNU/Linux según el manual de
	  instalación (que está incompleto en el momento en que esto
	  se escribe).  Sin embargo, puede querer examinarla antes de
	  instalar, para aprender más sobre Debian.

	<p>En general, este manual intenta explicar las razones de las
	  cosas, y ayudarle a comprender cómo funciona el interior del
	  sistema.  La idea es proporcionarle la capacidad de resolver
	  nuevos problemas y sacar el máximo provecho de su ordenador.
	  Por tanto, hay una buena cantidad de teoría, historia, y
	  hechos divertidos incluidos en los aspectos del "Cómo"

	  <footnote>(N. del T.: "How To" --- Cómo --- es una expresión
	    inglesa bien asentada en el mundo de la informática que
	    designa las explicaciones prácticas necesarias para
	    realizar una tarea.</footnote>

          del manual.

	<p>Por favor envíe sus comentarios acerca de este manual a la
	  lista de distribución del Proyecto de Documentación de Debian
	  <email>debian-doc@lists.debian.org</email>.  Estamos
	  especialmente interesados en si le ha sido de ayuda, y en cómo
	  podríamos mejorarlo.  Si se siente confuso al leerlo, o se da
	  cuenta de que utilizamos un término sin explicarlo primero,
	  envíenos un correo electrónico.

	<p>Por favor, NO envíe preguntas técnicas sobre Debian a los
	  autores, puesto que hay otros foros para eso.  Vea <ref
	  id="docs-support">.  A la dirección anterior, envíe solamente
	  correo referido al manual en sí.

	<p>Para encontrar la última versión de este manual, vaya a <url
	  id="http://www.debian.org/doc/"
	  name="http://www.debian.org/doc/"> y siga este enlace.

	<sect id="acknowldgements"> Reconocimientos
	  <p> Muchas personas han ayudado a elaborar este manual.

	  <p>El mayor agradecimiento corresponde a Larry Greenfield y su
	    Guía del Usuario de Linux, que integra la base del manual.
	    La Guía del Usuario de Linux es parte del Proyecto de
	    Documentación de Linux.

	  <p>Muchas gracias a aquellos que me han ayudado a editar el
	    manual; lo han hecho mucho, mucho mejor.  Si opina que este
	    manual fue agradable de leer, envíe su agradecimiento a
	    Thalia Hooker y Day Irmiter.

	  <p>Gracias a Richard Stallman de la Fundación para el Software
	    Libre por su consejo, por editar y ofrecerse a publicar el
	    texto.

	  <p>Gracias a James Treacy por permitirme tomar prestados
	    algunos de sus escritos del sitio web de Debian.

	  <p>Gracias a todos los que han escrito partes del manual:
	    Craig Saywer escribió sobre las shells, Ole Tetlie está
	    escribiendo sobre programación, Oliver Elphick aportó la
	    explicación de algunas utilidades básicas, Ivan E. Moore
	    II aportó la explicación de PPP.

	  <p>Mucha gente ha contribuido con parches y comentarios,
	    entre ellos, Eric Fisher y Mike Touloumtzis.

	  <p>Muchas gracias a Ardo van Rangelrooij por hacer que esto
	    empezara y mantener el DTD DebianDoc, utilizado para
	    escribir el manual.

	  <p>Por supuesto, es imposible dar las gracias a los cientos
	    de desarrolladores de Debian y los miles de autores de
	    software libre que nos dieron algo sobre lo que escribir y
	    para usar.

	  <p>Gracias también a todo el que haya olvidado, puesto que
	    estoy seguro de que he fastidiado esto.  Espero que no se
	    ofenderá nadie; por favor, si su nombre debería estar
	    aquí, envíeme un correo electrónico y hágamelo saber.

      <chapt id="introduction"> <heading> Introducción </heading>

	<sect id="introduction-debian"> ¿Qué es Debian?

	  <p><em>Debian</em> es un sistema operativo (SO) libre para
	    su ordenador.  Un sistema operativo es el conjunto de
	    programas y utilidades básicos que hacen que su
	    computadora funcione.  En el corazón de un sistema
	    operativo está el <em>kernel</em>.  El kernel es el
	    programa fundamental en el ordenador: se ocupa de toda la
	    gestión interna básica y le permite iniciar otros
	    programas.  Debian utiliza el kernel <em>Linux</em>, una
	    programa completamente libre escrito por Linus Thorvalds y
	    mantenido por (probablemente más de 1000) programadores de
	    todo el mundo.  Una gran parte de las herramientas básicas
	    que dan cuerpo al sistema operativo proceden de (<url
	    id="http://www.gnu.org" name="Proyecto GNU">), y esas
	    herramientas también son libres.  Por supuesto, lo que la
	    gente quiere es aplicaciones informáticas: programas que
	    les ayuden a realizar lo que quieren hacer, desde editar
	    documentos a llevar un negocio o jugar o escribir más
	    programas.  Debian viene con más de 1000 <em>paquetes</em>
	    (software precompilado ensamblado en un formato adecuado
	    para su fácil instalación en su máquina); todo ello libre.

	  <p>Es un poco como una torre.  En la base está Linux.
	    Encima están todas las herramientas básicas, la mayoría de
	    GNU.  Lo siguiente son todas las aplicaciones que usted
	    utiliza en el ordenador: muchas de estas también de GNU.
	    Los desarrolladores de Debian actúan como arquitectos y
	    coordinadores, organizando cuidadosamente el sistema y
	    ajustándolo todo para formar un sistema estable e
	    integrado: Debian GNU/Linux.

    <sect1 id="introduction-debian-os">¿Qué es un sistema
	     operativo, y qué clase de sistema operativo es Debian?

	  <p>Un sistema operativo es el conjunto de software que hace
	    a un ordenador utilizable.  Gestiona los dispositivos de
	    hardware y aporta utilidades y aplicaciones.

	  <p>Debian GNU/Linux está basado en el sistema operativo Unix,
	    que tiene una larga historia (vea <ref
	    id="unix-history">).  Debian es básicamente compatible con
	    Unix, pero añade un número significativo de
	    características adicionales.

	  <p>La filosofía de diseño de GNU/Linux (y Unix) consiste en
	    distribuir sus funciones entre pequeñas programas
	    multipropósito.  De este modo, pueden fácilmente lograrse
	    nuevas funciones y características mediante la combinación
	    de esos pequeños programas en formas nuevas.  Debian es
	    como un juego de construcción; usted puede construir toda
	    clase de cosas con ella.

	  <p>Al utilizar un sistema operativo, se busca minimizar la
	    cantidad de trabajo que se emplea en una tarea.  Debian
	    aporta muchas herramientas que pueden ayudarle, pero sólo
	    si sabe qué hacen esas herramientas.  Gastar un hora
	    intentando que algo funcione y acabar finalmente por
	    abandonar no es muy productivo.  Este manual le enseñará
	    acerca de las herramientas esenciales que forman Debian:
	    qué herramientas usar en qué situaciones, y cómo ligar
	    esas distintas herramientas.

	<sect1 id="introduction-debian-how">¿Quién crea Debian?

	  <p> Debian es un proyecto de desarrollo exclusivamente de
	    voluntarios a través de internet.  Hay cientos de
	    voluntarios trabajando en ella.  La mayoría están a cargo
	    de un pequeño número de paquetes de software y están
	    íntimamente familiarizados con el software que empaquetan.

	  <p>La integración del trabajo de estos voluntarios se logra
	    al seguir un estricto conjunto de líneas maestras que
	    determinan cómo se ensamblan los paquetes.  Estas líneas
	    maestras se desarrollan conjuntamente en discusiones en
	    listas de distribución de internet y en foros <em>internet
	    relay chat</em> (IRC).

	  </sect1>

	<sect id="introduction-DFSG"> ¿Qué es el software libre?

	  <p>Cuando los desarrolladores y usuarios de Debian hablan de
	    "software libre", se refieren a la <em>libertad</em> más que
	    al precio

	    <footnote>(N. del. T.: en inglés los conceptos "libre" y
	    "gratuito" se expresan con una misma palabra: "free".  De
	    ahí que "free software" pueda entenderse tanto como
	    "software libre" o "software gratis".  Esto ha ocasionado
	    malentendidos a lo largo de los años, y provocado
	    aclaraciones como ésta, que carecen de significado en
	    otras lenguas.)</footnote>.

	    Debian es libre en este sentido: usted es libre para
	    modificarla y redistribuirla, y siempre tendrá acceso al
	    código fuente para este propósito.  Las <url
	    id="http://www.debian.org/social_contract#guidelines"
	    	   name="Líneas Maestras de Debian sobre el Software Libre">
	   describe con más detalles qué se quiere decir con "libre".
	   La <url id="http://www.fsf.org" name="Fundación para el
	   Software Libre">, creadora del Proyecto GNU, es otra fuente
	   de información.  Puede encontrar una discusión más detallada
	   acerca del software libre en el <url
	   id="http://www.debian.org/intro/free" name="sitio web de
	   Debian">.

	 <p>El software libre es llamado a veces software Open Source
	   (R); Open Source es una marca certificada.

	   <footnote>(N. del T.: software de Fuente Abierta, por
	     contraposición al software "cerrado", que sólo distribuye
	     ejecutables y no permite examinar el código fuente.
	     Todos estos conceptos se le aclararán a lo largo del
	     manual.)</footnote>


	   Puesto que Open Source (R) es una marca registrada, sólo el
	   software auténticamente libre puede llamarse Open Source
	   (R).  Puede encontrarse con vendedores que intentan
	   confundirle afirmando que su software es "libre", cuando en
	   realidad está sujeto a importantes restricciones.  La marca
	   registrada Open Source (R) le da cierta garantía de que el
	   software es realmente software libre.  'Open Source
	   software' se abrevia ocacionalmente como 'OSS'.

	 <p>Quizá se pregunte: ¿por qué debería la gente gastar horas
	   de su propio tiempo para escribir software, empaquetarlo
	   cuidadosamente, y después regalarlo?  Las respuestas son tan
	   variadas como la gente que contribuye.

	 <p>Muchos creen en compartir la información y tener la
	   libertad de cooperar con los demás, y sienten que el
	   software libre fomenta esto.  Hay una larga tradición que
	   comienza en los años 50 que de sostener estos valores,
	   denominada algunas veces la Ética Hacker.  (Puede leer más
	   sobre ello en el agradable libro de Steven Levy,
	   <em>Hackers: Héroes de la Revolución Informática</em>.)

	 <p>Otros quieren aprender más sobre los ordenadores.  Más y
	   más gente está buscando maneras de evitar el precio
	   desorbitado del software comercial.  Una creciente multitud
	   contribuye como agradecimiento al magnífico software libre
	   que han recibido de otros.

	 <p>Dentro del mundo académico, muchos crean software libre
	   para ayudar a dar a los resultados de su investigación un
	   uso más extenso.  Los negocios ayudan a mantener software
	   libre para tener voz y voto en cómo se desarrolla: ¡no hay
	   modo más rápido de conseguir una nueva característica que
	   implementarla uno mismo o contratar a un técnico para que
	   lo haga!  Los negocios están también interesados en una
	   mayor fiabilidad y en la posibilidad de elegir entre
	   proveedores de asistencia técnica.


	 <p>Y aún hay otros que consideran el software libre como un
	   bien social, que democratiza el acceso a la información y
	   evita la excesiva centralización de la infraestructura de
	   la información mundial.  Por supuesto, muchos de nosotros
	   simplemente lo encontramos muy divertido.

	 <p>Debian está tan comprometida con el software libre que
	   pensamos que sería útil si estuviera formalizado en alguna
	   clase de documento.  Nuestro <url
	   id="http://www.debian.org/social_contract" name="Contrato
	   Social"> promete que Debian siempre será 100% software
	   libre.  Cuando usted descarga un paquete de la distribución
	   principal de Debian (<tt>main</tt>), puede estar seguro de
	   que cumple nuestras Líneas Maestras del Software Libre.

	 <p>Aunque Debian cree en el software libre, hay casos en los
	   que la gente quiere o necesita software registrado

	   <footnote>(N. del T.: registrado en el sentido de sujeto a
	     derechos de copia y, por lo tanto, cuya libre
	     distribución es imposible.)</footnote>

	   en su máquina.  Siempre que sea posible Debian apoyará
	   esto; aunque el software registrado no se incluye en la
	   distribución principal (<tt>main</tt>), está a veces
	   disponible en el sitio ftp en el directorio
	   <tt>non-free</tt>, y hay un creciente número de paquetes
	   cuya única función es instalar software registrado que no
	   se nos permite distribuir por nosotros mismos.

	 <p>Es importante distinguir entre software <em>comercial</em>
	   y software <em>registrado</em>.  Software registrado es
	   software no-libre, mientras que software comercial es
	   software que se vende por dinero.  Debian permite que el
	   software comercial forme parte de la distribución
	   principal, pero no el software registrado.  Recuerde que la
	   frase "software libre" no se refiere al precio; es por
	   tanto posible vender software libre.  Para mayores
	   aclaraciones acerca e la terminología, vea <url
	   id="http://www.opensource.org"
	   name="http://www.opensource.org"> o <url
	   id="http://www.fsf.org/philosophy/categories.html"
	   name="http://www.fsf.org/philosophy/categories.html">


 <!-- FIXME TO COMPLETE
       <sec id="introduction-why"> ¿Por qué debería usar Debian?

	 <p>Para qué es buena Debian, y para qué no.

 -->

       <sect id="introduction-how">Cómo Leer Este Libro

	 <p>La mejor forma de aprender sobre casi cualquier programa
	   informático es hacerlo en su ordenador.  La mayoría de la
	   gente encuentra que leer un libro sin utilizar el programa
	   no es beneficioso.  La mejor manera de aprender Unix y
	   GNU/Linux es usándolos.  Utilice GNU/Linux para todo lo que
	   pueda.  Experimente.  No tenga miedo: es <em>posible</em>
	   estropear las cosas, pero siempre puede reinstalar.
	   ¡Guarde copias de seguridad y diviértase!

	 <p>Debian no es tan obviamente intuitivo como algunos otros
	   sistemas operativos.  Por lo tanto, probablemente terminará
	   leyendo al menos los primeros capítulos de esta
	   introducción.  GNU/Linux es como un coche de carreras, la
	   cocina de un maestro chef, o una novela clásica; su
	   potencia y complejidad hacen difícil acercarse al
	   principio, pero es muchísimo más provechoso a largo plazo.

	 <p>La manera que sugerimos de aprender es leer un poco,
	   después practicar un poco.  Siga practicando hasta que esté
	   cómodo con los conceptos, y luego empiece a hojear el
	   libro.  Encontrará que cubre un conjunto de temas, algunos
	   de los cuales puede encontrar interesantes y algunos de los
	   cuales encontrará aburridos.  Después de un tiempo, debería
	   sentir la confianza suficiente para empezar a usar órdenes
	   sin saber exactamente lo que hacen.  Esto es bueno.

	 <p>Debe saber algo que puede ayudarle: si por error alguna
	   vez teclea una orden, o no sabe cómo abandonar un programa,
	   C-c (apretar al mismo tiempo la tecla Ctrl y la letra c
	   minúscula) con frecuencia detendrán el programa.

       <sect id="introduction-lpd">El Proyecto de Documentación de
         Linux

	 <p>Este manual está basado en buena medida en la <em>Guía del
	   Usuario de Linux</em>, de Larry Greenfield, del Proyecto de
	   Documentación de Linux.  ¡Gracias Larry!  Este proyecto
	   tiene otros varios manuales excelentes, muchos de los cuales
	   están dirigidos a usuarios más experimentados y
	   administradores de sistemas.  El PDL también mantiene los
	   CÓMOs de Linux, un inestimable recurso con el que debería
	   familiarizarse.  Puede encontrar el PDL en su <url
	   id="http://sunsite.unc.edu/LDP/" name="página principal">.

	    <footnote>(N. del T.: The Linux Documentation Project,
	      LDP.)</footnote>


     <chapt id="start"> <heading> Empezando </heading>

       <p>¡Así que acaba de terminar de instalar Debian!  Felicidades.
	 Métase de lleno y comience a aprender a usarla.

       <p>Como parte del proceso de instalación, debería haber
	 comprendido cómo arrancar el sistema Debian (con un disquete
	 especial, simplemente encendiendo el ordenador, o presionando
	 la tecla <tt>Alt</tt> al prompt del LILO y escogiendo Linux).

<!-- ARREGLAR : debería haber una referencia al apéndice -->

       <sect id="start-multi"> Un sistema operativo multiusuario y
	   multitarea

	 <p>Como mencionábamos antes (<ref id="introduction-debian">),
	   el diseño de Debian GNU/Linux proviene del sistema operativo
	   Unix.  Al contrario que los sistemas operativos comunes en
	   ordenadores personales como DOS, Windows, y MacOS, Unix se
	   encuentra usualmente en grandes servidores y sistemas
	   <em>multiusuario</em>.

	 <p>Esto significa que Debian posee rasgos de los que carecen
	   esos otros sistemas operativos.  Permite a un gran número de
	   personas utilizar la computadora a la vez, en tanto cada
	   usuario tenga su propia <em>terminal</em>

	   <footnote>Una terminal es sólo un teclado y una pantalla
	   conectados al ordenador a través de una red, de módem, o
	   directamente.  Su teclado y monitor forman una terminal que
	   está directamente unida a la computadora: esta terminal
	   especial se denomina con frecuencia la
	   <em>consola</em>.</footnote>.

	   Para permitir a muchos usuarios trabajar a la vez, Debian
	   debe permitir a muchos programas y aplicaciones funcionar
	   simultáneamente.  Esta característica se llama
	   <em>multitarea</em>.

	 <p>Gran parte de la complejidad (y la potencia) de los
	   sistemas operativos al estilo Unix resultan de estas dos
	   características.  Por ejemplo, el sistema debe tener un
	   modo de evitar que los usuarios se borren accidentalmente
	   unos a otros los archivos, y tiene que coordinar los muchos
	   programas que funcionan a la vez, por ejemplo para asegurar
	   que no utilizan el disco duro al mismo tiempo.

	 <p>Si tiene en mente lo que Debian fue originalmente diseñada
	   para hacer, muchos de sus aspectos cobrarán un sentido más
	   claro.  Aprenderá a sacar provecho de la potencia de estas
	   características.

       <sect id="start-login">Ingresar

	 <p>Para utilizar Debian tiene que identificarse ante el
	   sistema.  Esto es así para que sepa quién es usted, qué
	   tiene permiso para hacer, y cuáles son sus preferencias.

	 <p>A este fin, usted tiene un <em>nombre de usuario</em> o
	   <em>ingreso</em>

	   <footnote>(N. del T.: login.)</footnote>

	   ; si ha instalado usted mismo Debian, debería habérsele
	   pedido tal nombre durante la instalación.  Si está
	   ingresando en un sistema administrado por algún otro,
	   tendrá que pedirle una cuenta en el sistema, y su
	   correspondiente nombre de usuario.

	 <p>También tiene una contraseña, de modo que nadie más puede
	   fingir ser usted.  Si no tuviera una contraseña, cualquiera
	   podría ingresar en su ordenador desde Internet, y preparar
	   un desaguisado (vea <ref id="advanced-security">).  Si le
	   preocupa la seguridad, debería tener una contraseña.

	 <p>Mucha gente prefiere confiar en que los demás no harán nada
	   malo con sus cuentas; es de esperar que su entorno de
	   trabajo no fomente la paranoia.  Esta es una actitud
	   perfectamente razonable; depende de sus prioridades
	   personales, y su entorno.  Obviamente un sistema personal en
	   casa no precisa ser tan seguro como una instalación militar.
	   Debian le permite ser tan seguro o tan inseguro como
	   prefiera.

	 <p>Cuando arranca Debian, verá un <em>prompt</em>; la
	   computadora le pide cierta información.  En este caso, el
	   prompt es <tt>login:</tt>.

	 <p>Debe introducir su nombre de usuario, y cuando se lo
	   solicite, su contraseña.  La contraseña no aparece en la
	   pantalla según la teclea; es para que nadie pueda observar
	   sobre su hombre y ver cuál es.  Apriete <tt>Intro</tt>
	   después de ambos, nombre de usuario y contraseña.  Si
	   teclea su nombre de usuario o contraseña incorrectamente,
	   tendrá que comenzar de nuevo

	 <p>Si lo hace correctamente, verá un breve mensaje y después
	   un prompt <tt>&dollar;</tt>.  El <tt>&dollar;</tt> lo
	   imprime

	   <footnote>(N. del T.: si procede de sistemas operativos
	     basados en entornos gráficos es posible que esta
	     terminología le sorprenda un poco al principio.  Cuando
	     hablamos de imprimir, en este contexto, nos referimos a
	     "imprimir en pantalla".)</footnote>

	   un programa especial llamado la <em>shell</em> y por lo
	   tanto se llama <em>prompt de la shell</em>: aquí es donde
	   le da órdenes al sistema.

	 <p>Pruebe ahora a introducir la orden <tt>whoami</tt>

	   <footnote>(N. del T.: "quiensoyyo".)</footnote>

	   .  Hay un
	   <em>cursor</em> a la derecha del prompt de la shell.  El
	   cursor es un pequeño subrayado o un rectángulo que indica
	   dónde está tecleando; debería moverse cuando usted escribe.
	   Presione siempre <tt>RET</tt> (la tecla Intro, o Retorno)
	   cuando haya terminado de escribir una instrucción en la
	   shell.

	 <p><tt>whoami</tt> dice su nombre de usuario.  Después
	   obtendrá un nuevo prompt de la shell.

	 <p>Para el resto del manual, cuando decimos que introduzca
	   una orden, debería escribirla en el prompt de la shell y
	   apretar la tecla <tt>RET</tt>.  En algunos teclados está
	   etiquetada como <tt>Return</tt> y en otros es
	   <tt>Return</tt>.  Misma tecla, distinto nombre.

	    <footnote>(N. del T.: en español "Intro".)</footnote>

	 <p>Cuando haya terminado de trabajar, querrá abandonar el
	   sistema.  Para salir de la shell, introduzca la instrucción
	   <tt>exit</tt>.  Recuerde que si permanece ingresado, podría
	   presentarse alguien y utilizar su cuenta.  En el mejor de
	   los casos, puede confiar en que la gente de su oficina o su
	   casa no lo hará; pero si no confía en su entorno, debería
	   asegurarse de que abandona el sistema cuando se marcha.

       <sect id="start-keys"> Teclas

	 <p>Antes de continuar, es importante familiarizarse con las
	   convenciones utilizadas en este manual para describir las
	   órdenes que consisten en presionar series de teclas.

	 <p>Cuando deba apretar simultáneamente varias teclas, se
	   utilizará una notación como <tt>C-a</tt>.  Esto significa
	   "apriete la tecla de control, y teclee la a minúscula".
	   Otras abreviaturas incluyen la tecla Alt, <tt>A</tt>, y la
	   tecla Meta <tt>M</tt>.  Algunos teclados tienen ambas Alt y
	   Meta; la mayoría de los ordenadores personales tienen sólo
	   Alt, pero la tecla Alt se comporta como una tecla Meta.  Así
	   que si no tiene tecla Meta, pruebe la tecla Alt en su lugar.

	 <p>Teclas como Alt y Meta se denominan
	   <em>modificadores</em>, porque alteran el significado de
	   las teclas estándar como la letra A.  A veces necesitará
	   presionar más de un modificador; por ejemplo,
	   <tt>M-C-a></tt> significa apretar simultáneamente Meta,
	   Ctrl, y la a minúscula.

	 <p>Algunas teclas tienen una notación especial; por ejemplo,
	   <tt>RET</tt> (Retorno/Intro), <tt>BORR</tt> (Borrar o a
	   veces, espacio atrás)

	   <footnote>(N. de. T.: "Borrar" se encuentra en la parte
	   superior derecha del cuadro principal de su teclado, y
	   suele estar etiquetada con una flecha que apunta hacia la
	   izquierdas.  Es "Borrar" o "espacio atrás".  Existe otra
	   tecla, a la derecha de ésta, denominada "Suprimir".  El
	   comportamiento de ambas puede resultar algo confuso a
	   veces, debido a las diferencias existentes entre el
	   estándar estadounidense y europeo.)</footnote>

	   <tt>ESC</tt> (Escape).  Éstas se explican por sí mismas.

	 <p>Espacios en lugar de guiones significa presionar las teclas
	   formando una secuencia.  Así, por ejemplo, <tt>C-a x RET</tt> quiere decir apretar simultáneamente Control y a
	   minúscula, seguidas de la letra x, seguidas de apretar
	   Intro.


       <sect id="start-commandline"> Historial de órdenes y editar la línea de instrucciones

	 <p>Cualquier cosa que teclee después del prompt de la shell y
	   antes de apretar <tt>RET</tt> se llama <em>línea de
	   instrucciones</em>: es una línea de texto que ordena a la
	   computadora hacer algo.  La shell por defecto de Debian
	   tiene varias características que facilitan la introducción
	   de líneas de comandos.

	 <p>Puede desplazarse por las órdenes anteriores para
	   ejecutarlos de nuevo, o modificarlas ligeramente y
	   <em>después</em> ejecutarlas de nuevo.  Pruebe esto:
	   introduzca cualquier instrucción, como <tt>whoami</tt>;
	   luego presione la tecla de flecha superior.  La orden
	   <tt>whoami</tt> reaparecerá en el prompt.  Puede entonces
	   apretar <tt>RET</tt> para ejecutar <tt>whoami</tt> por
	   segunda vez.

	 <p>Si ha introducido varias órdenes, puede mantener apretada
	   la tecla de flecha superior para volver a ellas.  Esta
	   característica es útil si hace lo mismo varias veces, o si
	   teclea incorrectamente una orden y quiere volver atrás para
	   corregirla.  Puede presionar la flecha inferior para
	   desplazarse en la otra dirección, hacia sus instrucciones
	   más recientes.  Si no hay más órdenes hacia las que
	   moverse, la computadora dará un pitido.

	 <p>También puede moverse por la línea de instruccioness para
	   hacer cambios.  La forma más sencilla es con las teclas de
	   flecha izquierda y derecha: escriba <tt>whoasmi</tt> en
	   lugar de <tt>whoami</tt>, después utilice la tecla de
	   flecha izquierda para volver hasta la <tt>s</tt>.  Puede
	   borrar la <tt>s</tt> con las teclas de Borrar o Suprimir.

	 <p>Hay también funciones más avanzados (sin embargo, no hace
	   falta memorizarlos todas ahora).  Escriba <tt>C-a</tt>.
	   Esto le llevará al principio de la línea.  <tt>C-k</tt> (la
	   <tt>k</tt> se refiere a "kill"

	   <footnote>(N. del T.: "matar".)</footnote>)

	   borra hasta el final de la línea; pruébelo desde la mitad
	   de la línea de instrucciones.  Utilizando <tt>C-a</tt>
	   seguido de <tt>C-k</tt>, puede borrar la línea entera.
	   <tt>C-y</tt> pega la última línea que borró, insertándola en
	   la posición actual del cursor (<tt>y</tt> se refiere a
	   "yank", como en "yank it back"

	   <footnote>(N. del T.: "yank" significa en inglés "tirar" o
	   "dar un tirón"; "yank it back" vendría a ser "vuelve a
	   ponerlo en su sitio".)</footnote>).

	   <tt>C-e</tt> llevará el cursor al final de la línea de
	   instrucciones.

	 <p>Vaya y juegue con la línea de instrucciones, editando,
	   para cogerle el tranquillo.  Experimente.

       <sect id="start-root"> Ingresando como root

	 <p>Puesto que Debian es un sistema multiusuario, está
	   diseñado para evitar que cualquier usuario o programa
	   estropee todo el sistema.  El kernel no permitirá a los
	   usuarios normales modificar archivos importantes del sistema.
	   Esto significa que las cosas permanecen del modo en que se
	   supone que tienen que estar, a salvo de accidentes, virus,
	   e incluso bromas maliciosas.  Al contrario que otros
	   sistemas operativos, Debian está a salvo de esas amenazas.
	   No necesitará un programa antivirus.

	 <p>Sin embargo, a veces se necesita cambiar importantes
	   ficheros del sistema: por ejemplo, puede querer instalar
	   nuevo software, o configurar la conexión de red.  Para
	   hacerlo, usted precisa poderes mayores que los de un usuario
	   normal; debe convertirse en el <em>usuario root</em>
	   (también llamado el <em>superusuario</em>

	   <footnote>(N. del T.: en inglés, "root" significa
	   "raíz".)</footnote>).

	 <p>Para hacerse root, simplemente ingrese con el nombre de
	   usuario <tt>root</tt> y la contraseña de root, si la tiene.
	   Esperemos que recuerde la contraseña de cuando instaló el
	   sistema: si no, tiene un problema

	   <footnote>La solución a este problema es bastante
	   técnica. Tiene que arrancar con un disco de rescate, montar
	   la partición root normal, y editar <tt>/etc/passwd</tt> para
	   eliminar la contraseña de root anterior.  Pida ayuda si no
	   le encuentra sentido a esto (vea <ref
	   id="docs-support">). </footnote>.

 <!-- FIXME ¿No es mucho más fácil/rápido arrancar con -->
 <!-- 'init=/bin/bash'? -->

<!-- ARREGLAR sí, si tienes acceso a la consola.  Como estés haciendo -->
<!-- administración remota estás listo. -->

	 <p>En muchos sitios, sólo el administrador del sistema tiene
	   la contraseña de root, y sólo el administrador del sistema
	   puede hacer las cosas que uno tiene que ser root para hacer.
	   Si usted está usando su propio ordenador personal,
	   <em>usted</em> es el administrador del sistema, por
	   supuesto.  Si no tiene privilegios de root, tendrá que
	   confiar en el administrador del sistema para realizar
	   cualquier tarea que requiera privilegios de root.

	 <p>A veces tendrá la contraseña de root incluso en un
	   servidor compartido corporativo o educativo, porque el
	   administrador confía en que la utilizará apropiadamente.
	   En ese caso, podrá ayudar a administrar el sistema y
	   personalizarlo para que se adapte a sus necesidades.  Pero
	   debería asegurarse de utilizar la contraseña de manera
	   responsable, respetando a los otros usuarios en todo
	   momento.

	 <p>Si tiene la contraseña, ingrese ahora como root.
	   Introduzca la orden <tt>whoami</tt> para verificar su
	   identidad.  Después <em>abandone el sistema
	   inmediatamente</em>.  Cuando uno es root, el kernel no le
	   protege de sí mismo, porque root tiene permiso para hacerle
	   absolutamente cualquier cosa al sistema.  Por ejemplo,
	   puede teclear <tt>rm -rf /</tt> y borrar <em>el sistema
	   entero</em> con unas pocas pulsaciones.  (No hace falta
	   decir que <em>NO</em> debería teclear esto.)  No
	   experimente mientras es root.  En realidad, no haga nada
	   como root, a menos que sea absolutamente necesario.  Esto
	   no es una cuestión de seguridad, sino más bien de
	   estabilidad.  Su sistema funcionará mucho mejor si puede
	   evitar que usted cometa errores tontos.

	 <p>Puede encontrar la orden <prgn>su</prgn> más conveniente
	   que ingresar como root.  <prgn>su</prgn> permite asumir la
	   identidad de otro usuario, normalmente root a menos que se
	   especifique alguien más.  (Puede recordar que
	   <prgn>su</prgn> se refiere a Super User, aunque algunos
	   dicen que viene de Set UserID.)

	   <footnote>(N. del T.: Set (establecer) User (usuario) ID
	   (identidad).  Por tanto, establecer la identidad del
	   usuario.  De la documentación podría añadirse incluso otra
	   interpretación: Substitute User, susituir al usuario.)
	   </footnote>

	 <p>Practique:

	       <enumlist>

		 <item> Ingrese como usted mismo, esto es, no como
		     root.

		 <item><tt>whoami</tt> <p> Confirme su nombre de
		     usuario.

		 <item><tt>su</tt> <p> Introduzca la orden <tt>su</tt>.
		     Le pedirá una contraseña; introduzca la contraseña
		     de root.  Si le da la contraseña correcta, debería
		     ver un nuevo prompt de la shell.  Por defecto, el
		     prompt de la shell de root es <tt>#</tt> en lugar
		     de <tt>&dollar;</tt>.


		 <item><tt>whoami</tt> <p> Esto debería darle "root"
		     como su nuevo nombre de usuario.

		 <item><tt>exit</tt> <p> Abandone la shell de root.  El
		     prompt volverá a ser <tt>&dollar;</tt>.

	      </enumlist>

	 <p>Cuando esté realizando tareas de administración del
	   sistema, debería hacer tanto como pueda como usted mismo.
	   Después, <tt>su</tt>, haga la parte que requiera privilegios
	   de root, y <tt>exit</tt> para eliminar los privilegios de
	   modo que ya no pueda dañar nada.

	 <p>Puede utilizar <tt>su</tt> para asumir la identidad de
	   cualquier usuario del sistema, no sólo root.  Para hacer
	   esto, teclee <tt>su <var>usuario</var></tt> donde
	   <var>usuario</var> es el usuario en el que se quiere
	   convertir.  Tendrá que conocer su contraseña, por supuesto,
	   a menos que sea root en ese momento o no tenga contraseña.

       <sect id="start-VC"> Consolas virtuales

	 <p>El kernel Linux permite el uso de <em>consolas
	   virtuales</em>.  Estas consisten en un modo de hacer que
	   una única pantalla y teclado se comporten como múltiples
	   terminales, conectadas todas al mismo sistema.  Menos mal,
	   usar consolas virtuales es una de las cosas más sencillas
	   sobre Debian: hay teclas calientes para alternar entre las
	   consolas rápidamente.  Para practicar, ingrese en su
	   sistema, y teclee <tt>A-F2</tt> (presione simultáneamente
	   la tecla <tt>Alt</tt>, y <tt>F2</tt>, esto es, la tecla de
	   función número 2).

	 <p>Debería encontrarse con otro prompt de ingreso.  No se
	   asuste: ¡ahora está en la consola virtual (CV) número 2!
	   Ingrese aquí y haga algunas cosas --- más <tt>whoami</tt> o
	   lo que sea --- para confirmar que esta es una auténtica
	   shell de ingreso.  Ahora puede regresar a la consola virtual
	   número 1, con <tt>A-F1</tt>.  O puede moverse a una
	   <em>tercera</em> consola virtual, con el procedimiento obvio
	   (<tt>A-F3</tt>).

	 <p>Debian viene con seis consolas virtuales habilitadas por
	   defecto, a las que se accede con la tecla Alt y las teclas
	   de función <tt>F1-F6</tt> (técnicamente, hay más consolas
	   virtuales habilitadas, pero sólo seis de ellas permiten el
	   ingreso.  Las otras se utilizan en el Sistema X Window o
	   para otros propósitos especiales).

	 <p>Si está usando el Sistema X Window, empezará generalmente
	   en la primera consola virtual no utilizada, probablemente
	   CV 7.  Para alternar de la consola virtual X a una de las
	   seis primeras, habrá que añadir <tt>Ctrl</tt> a la
	   secuencia de teclas.  Así que será <tt>C-A-F1</tt> para ir
	   a CV 1.  Pero se puede ir de una CV de texto a la consola
	   virtual X utilizando solamente <tt>Alt</tt>.  Si usted
	   nunca abandona las X, no tendrá que preocuparse acerca de
	   esto; X automáticamente le llevará a su consola virtual al
	   iniciarse.

	 <p>Una vez que se haya acostumbrado a ellas, las consolas
	   virtuales se convertirán probablemente en una herramienta
	   indispensable para hacer muchas cosas a la vez.  (El
	   Sistema X Window sirve para el mismo propósito,
	   proporcionando múltiples ventanas en lugar de consolas
	   múltiples.)  Puede ejecutar un programa diferente en cada
	   CV o ingresar como root en una CV y como usted mismo en
	   otra.  O cada miembro de la familia puede utilizar su
	   propia CV; es especialmente útil si utiliza las X, en cuyo
	   caso puede ejecutar varias sesiones X a la vez, en
	   diferentes consolas virtuales.

       <sect id="start-shutdown"> Cerrar el sistema

	 <p><em>¡No apague el ordenador sin más!  ¡Se arriesga a perder
	   datos valiosos!"</em>

	 <p>Si usted es el único usuario de su computadora, puede
	   querer apagarlo cuando ha terminado con él.

	   <footnote>Para evitar el posible menoscabo de ciertos
	   componentes del hardware, apague la computadora solamente
	   cuando haya concluido para el resto del día.  Encender y
	   apagar son los dos mayores responsables del desgaste por el
	   uso de los componentes informáticos.  Encender y apagar el
	   ordenador una vez al día es probablemente el mejor
	   compromiso entre la factura eléctrica y la esperanza de vida
	   de su computadora.</footnote>

	 <p>Al contrario que en la mayoría de las versiones del DOS, es
	   mala cosa apretar el interruptor sin más cuando ha terminado
	   de utilizar el ordenador.  También es malo rearrancar la
	   máquina (con el botón de reinicio

	   <footnote>(N. del T.: el botón "reset".)</footnote>)

	   sin adoptar primero las precauciones adecuadas.  El kernel
	   Linux, para mejorar el rendimiento, tiene una <em>caché de
	   disco</em>.  Esto significa que almacena temporalmente en
	   RAM información destinada a ser almacenada de manera
	   permanente: ya que la memoria es miles de veces más veloz
	   que un disco, esto hace que las operaciones con ficheros
	   vayan con mayor rapidez.  Periódicamente, la información que
	   Linux tiene en la memoria se escribe de verdad en el disco.
	   Esto se llama <em>sincronización</em>.  Para apagar o
	   reiniciar la computadora, debe decirle que vacíe la memoria
	   y almacene los datos de manera permanente.

	 <p>Para reiniciar, simplemente teclee <tt>reboot</tt>, o
	   presione <tt>C-A-BORR</tt> (esto es, Control, Alt, y
	   Borrar).

	 <p>Para cerrar el sistema, hay que ser <tt>root</tt>.  Como
	   root, simplemente teclee la orden <tt>shutdown -h now</tt>.
	   Esto ejecutará completo el procedimiento de cierre,
	   incluyendo la orden <tt>sync</tt>

	   <footnote>(N. del T.: sicronización.)</footnote>

	   que vacía la caché de disco como se describió antes.  Cuando
	   vea <tt>System halted</tt>, es seguro apagar el ordenador.
	   Si el kernel y la BIOS admiten la Gestión Avanzada de
	   Energía (GAE)

	   <footnote>(N. del T.: Advanced Power Management,
	   APM.)</footnote>,

	   la computadora se apagará sola y le ahorrará la molestia.
	   GAE es común en portátiles y también se encuentra en ciertas
	   placas madres de escritorio.

	 <p>Algunas personas encuentran más simple cerrar el sistema
	   tecleando <tt>C-A-BORR</tt> para reiniciar, después apagar
	   el ordenador antes de que el kernel Linux empiece a
	   recargarse.  Sin embargo, una vez que el kernel empieza a
	   cargarse, deberá esperar a que termine y entonces reiniciar
	   apropiadamente o cerrar el sistema de nuevo.

     <chapt id="basics"> <heading> Los fundamentos </heading>

       <!-- FIXME escribir aquí una pequeña introducción. -->

       <sect id="basics-commandline"> La línea de instrucciones y las
         páginas <tt>man</tt>

	  <p>Ya hemos hablado de la <em>línea de instrucciones</em>,
	    esto es, las órdenes que se escriben tras el prompt de la
	    shell.  Esta sección describe la estructura de líneas de
	    órdenes más complejas.

	  <p>Una línea de órdenes mínima contiene nada más un nombre de
	    instrucción, como en <tt>whoami</tt>.  Pero se pueden hacer
	    otras cosas.  Por ejemplo, se puede escribir:

<example>
man whoami
</example>

	  <p>Esta orden pide el manual en línea

	    <footnote>(N. del T.: "online manual".)</footnote>

	    para el programa <tt>whoami</tt> (puede que tenga que
	    apretar la barra espaciadora para desplazarse por la
	    documentación, o <tt>q</tt> para salir

	    <footnote>(N. del T.: "q" de "quit", salir,
	    abandonar.)</footnote>).

	    Un ejemplo más complicado:

<example>
man -k Postscript
</example>

	    Esta línea de órdenes tiene tres partes.  Comienza con el
	    nombre de la instrucción, <tt>man</tt>.  Después tiene una
	    <em>opción</em> o <em>conmutador</em>, <tt>-k</tt>,
	    seguido de un <em>argumento</em>, <tt>Postscript</tt>.
	    Algunas personas designan todo excepto el nombre de la
	    orden como <em>parámetros</em> de la instrucción.  Así
	    que, ambos, opciones y argumentos, son parámetros.

	  <p>Las opciones cambian el comportamiento de la orden,
	    activando caracteres o funciones particulares.  Usualmente
	    llevan antepuesto un <tt>-</tt>.  Las utilidades GNU
	    tienen también "formas largas" para las opciones; la forma
	    larga de <tt>-k</tt> es <tt>--apropos</tt>.  Introduzca
	    <tt>man -h</tt> o <tt>man --help</tt> para obtener la
	    lista completa de opciones para la instrucción
	    <tt>man</tt>.  Cada orden tendrá su propio conjunto de
	    opciones, aunque la mayoría dispone de las opciones
	    <tt>--help</tt> y <tt>--version</tt>.  Hay excepciones;
	    <tt>tar</tt>, por ejemplo, no requiere el <tt>-</tt> antes
	    de las opciones, por razones históricas.

	  <p>Cualquier cosa que no sea una opción y no sea el nombre
	    de la orden es un <em>argumento</em>.  En este caso,
	    <tt>Postscript</tt>.  Los argumentos pueden servir a
	    muchos propósitos; con mayor frecuencia, son los nombres
	    de los ficheros sobre los que la orden debería operar.  En
	    este caso, <tt>Postscript</tt> es la palabra que usted
	    quiere que <prgn>man</prgn> busque.  In el caso de <tt>man
	    whoami</tt>, el argumento era la orden sobre la que quería
	    información.

	  <p>Fraccionando la línea de órdenes <tt>man -k
	  Postscript</tt>:

	     <list>

		 <item> <tt>man</tt>, el nombre de la orden, le dice a
		   la computadora que busque en las páginas de manual.
		   Éstas proporcionan documentación sobre las
		   instrucciones.  Por ejemplo, <tt>man whoami</tt> le
		   da información sobre la orden <tt>whoami</tt>.

		 <item> <tt>-k</tt>, la opción, altera el
		   comportamiento de <tt>man</tt>.  Normalmente,
		   <tt>man</tt> espera un nombre de instrucción como
		   argumento, tal como <tt>whoami</tt>, y busca la
		   documentación de ese comando.  Pero con la opción
		   <tt>-k</tt> o <tt>--apropos</tt>, espera que el
		   argumento sea una palabra clave.  Entonces
		   proporciona una lista de todas las páginas de manual
		   con esa palabra clave en su descripción.

		 <item> <tt>-k</tt>y <tt>Postscript</tt> es el argumento;
		   puesto que hemos utilizado la opción <tt>-k</tt>, es
		   la palabra clave que hay que buscar.

		 <item> <tt>-k</tt> y <tt>Postscript</tt> son ambos
		   parámetros.

	     </list>

	 <p>Vaya y escriba <tt>man -k Postscript</tt>, y verá una
	   lista de todas las páginas de manual en su sistema que
	   tienen algo que ver con Postscript.  Si no ha instalado
	   demasiado software, puede que vea <tt>Postscript: nada
	   apropiado</tt> en su lugar.

       <sect id="basics-commandline-description"> Describiendo la línea
		 de instrucciones

	 <p>Nota: esta es una sección que puede omitir, si quiere
	   avanzar.

	 <p>Hay una breve forma tradicional de describir la
	   <em>sintaxis</em> de las órdenes

	   <footnote><em>Sintaxis</em> significa la forma correcta de
	   combinar opciones y argumentos.</footnote>

	   que debería conocer.  Por ejemplo, si escribe <tt>man
	   man</tt> para obtener la página de manual sobre
	   <tt>man</tt>, verá varias varias descripciones sintácticas
	   que comienzan con el nombre de la instrucción <tt>man</tt>.
	   Una de ellas presenta el siguiente aspecto:

<example>
man -k [-M camino] palabra clave ...
</example>

	 <p>Cualquier cosa entre corchetes (<tt>[]</tt>) es un bloque
	   opcional.  Así que no tiene que utilizar la opción
	   <tt>-M</tt>, pero si lo hace, debe usar un argumento
	   <tt>camino</tt>.  Debe usar la opción <tt>-k</tt> y el
	   argumento <tt>palabra clave</tt>.  Los <tt>...</tt>
	   significan que podría tener más de lo que sea que vaya antes
	   de ellos, de manera que podría buscar varias palabras clave.

	 <p>Vamos a ver una de las descripciones más complejas de la
	 página de manual de <tt>man</tt>:

<example>
man [-c|-w|-tZT dispositivo] [-adhu7V] [-m sistema[,...]] [-L locale]
[-p cadena] [-M camino] [-P paginador] [-r prompt] [-S lista] [-e
extensión] [[sección] página ...] ...
</example>

	   No hay necesidad de examinar todo esto (y no se preocupe de
	   lo que significa), pero preste atención a la organización
	   de la descripción.

	 <p>Primero, lo grupos de opciones significan usualmente que
	   puede usar una o más de ellas en diferentes combinaciones,
	   así que <tt>-adhu7V</tt> quiere decir que puede también usar
	   <tt>-h</tt>.  No obstante, no siempre se pueden usar todas
	   las combinaciones; esta descripción no lo deja tan claro.
	   Por ejemplo, <tt>-h</tt> es incompatible con otras opciones,
	   pero usted podría hacer <tt>man -du</tt>.
	   Desafortunadamente, el formato de la descripción no lo deja
	   tan claro.

	 <p>Segundo, el símbolo <tt>|</tt> significa "o".  Así que
	   puede usar <em>alguna</em> de las opciones <tt>-c</tt>,
	   <tt>-w</tt> o <tt>-tZT</tt>, seguidas por un argumento
	   <tt>dispositivo</tt>.

	 <p>Tercero, dése cuenta de que puede anidar los corchetes,
	   puesto que indican un <em>bloque</em> opcional.  De modo
	   que si tiene una <tt>sección</tt>, también ha de tener una
	   <tt>página</tt>, puesto que <tt>página</tt> no es opcional
	   en el interior del bloque <tt>[[sección] página]</tt>.

	 <p>No hay necesidad de memorizar todo esto, simplemente
	   utilice esta sección como referencia cuando lea
	   documentación.

       <sect id="basics-files"> Ficheros y Directorios

	 <sect1 id="basics-files-intro"> Introducción a los ficheros

	   <p> Los <em>ficheros</em> son unos instrumentos que permiten
	   almacenar y organizar información, análogos a los documentos
	   en papel.  Están organizados en <em>directorios</em>, que se
	   llaman <em>carpetas</em> en algunos otros sistemas.  Vamos a
	   examinar la organización de los ficheros en un sistema
	   Debian:

	   <taglist>

	     <tag> <tt>/</tt> <item> Una simple <tt>/</tt> representa
	       el directorio raíz.  Todos los demás ficheros y
	       directorios están contenidos en el directorio raíz.  Si
	       procede del mundo DOS/Windows, <tt>/</tt> es muy similar
	       a lo que <tt>C:</tt> es para DOS, que es ser la raíz del
	       sistema de ficheros.  Una notable diferencia entre DOS y
	       Linux, sin embargo, es que DOS mantiene varios sistemas
	       de ficheros: <tt>C:</tt> (primer disco duro),
	       <tt>A:</tt> (primer disquete), <tt>D:</tt> (o un CD-ROM
	       o un segundo disco duro) mientras que Linux tiene todos
	       sus ficheros organizados sobre el mismo <tt>/</tt>
	       directorio raíz.  Vea <ref id="disks-mount"> para más
	       detalles.

	     <tag> <tt>/home/janeq/</tt> <item> Este es el directorio
	       principal del usuario "janeq".  Leyendo de izquierda a
	       derecha, para llegar a este directorio se comienza en el
	       directorio raíz, se entra en el directorio
	       <tt>home</tt>, y luego se entra en el directorio
	       <tt>janeq</tt>.

	     <tag> <tt>/etc/X11/XF86Config</tt> <item> Este es el
	       archivo de configuración para el Sistema X Window.
	       Reside en el subdirectorio <tt>X11</tt> del directorio
	       <tt>/etc</tt>.  <tt>/etc</tt> es en cambio un
	       subdirectorio del directorio raíz, <tt>/</tt>.

	   </taglist>

	 <p>Cosas que deben destacarse:

	   <list>

	     <item> Los nombres de ficheros distinguen entre
	       mayúsculas y minúsculas.  Esto es, <tt>MIFICHERO</tt> y
	       <tt>MiFichero</tt> son archivos <em>diferentes</em>.

	     <item> El directorio raíz se designa simplemente con
	       <tt>/</tt>.  No confunda este "root", con el usuario
	       "root", el usuario con "super poderes" en su sistema.

	     <item> Cada directorio tiene un nombre que puede contener
	       cualesquiera letras o símbolos <em>excepto</em>
	       <tt>/</tt>.  El directorio raíz es una excepción; su
	       nombre es <tt>/</tt> (pronunciado "barra"

	       <footnote>(N. del T.: "barra" o "slash" es el nombre que
	       adopta este símbolo en tipografía.)</footnote>

	       o "el directorio raíz") y no puede cambiarse su nombre.

	       <footnote>(Aunque <em>se pueden</em> utilizar casi
	       cualesquiera letras o símbolos en el nombre de un
	       archivo, en la práctica es una mala idea.  Es mejor
	       evitar cualquier carácter que tenga con frecuencia
	       significados especiales en la línea de órdenes, entre
	       ellos: <tt>{ } ( ) ' ` " \ / &gt &lt | ; ! # & ^ * %
	       @</tt>

	     <p>Evite también poner espacios en los nombres de los
	       archivos.  Si quiere separar palabras en un nombre, son
	       buenas elecciones el punto, el guión, y el subrayado.
	       También puede poner mayúsculas en cada palabra,
	       <tt>ComoEsto</tt>.</footnote>

	       <footnote>(N. del T.: está igualmente desaconsejado
	       utilizar acentos.)</footnote>

	     <item>Cada archivo o directorio se designa por <em>nombre
	       de archivo completo</em>, <em>nombre absoluto de
	       archivo</em>, o <em>camino</em>

	       <footnote>(N. del T.: "path".)</footnote>

	       que contiene la secuencia de directorios que hay que
	       recorrer para alcanzarlo.  Los tres términos son
	       sinónimos.  Todos los nombres de archivo absolutos
	       comienzan con el directorio <tt>/</tt>, y hay un
	       <tt>/</tt> entre cada directorio o archivo en el nombre
	       de fichero.  El primer <tt>/</tt> es el nombre de un
	       directorio, pero los demás son simplemente separadores
	       para distinguir las partes del nombre de archivo.

	     <p>Las palabras utilizadas pueden resultar confusas.
	       Tomemos el siguiente ejemplo:

<example>
/usr/share/keytables/us.map.gz
</example>

	       Este es un nombre de archivo completo; algunas personas
	       lo llaman <em>camino</em>.  Sin embargo, la gente
	       también se referirá a <tt>us.map.gz</tt> como a un
	       nombre de archivo.

 <!-- FIXME crossref -->.
	       <footnote> Hay también otro uso de la palabra "camino"
	       El significado que se busca normalmente queda claro a
	       partir del contexto.</footnote>

	     <item> Los directorios se disponen en una estructura en
	       árbol.  Todos los nombres de archivo absolutos comienzan
	       con el directorio raíz.  El directorio raíz tiene un
	       cierto número de ramas, como <tt>/etc</tt> y
	       <tt>/usr</tt>.  Estos subdirectorios, a su vez, se
	       ramifican en más subdirectorios, como
	       <tt>/etc/init.d</tt> y <tt>/usr/local</tt>.  Al conjunto
	       se le llama "el árbol de directorios".

	     <p>Puede pensarse en un nombre de archivo absoluto como en
	       una ruta desde la base del árbol <tt>/</tt> hasta el
	       final de una rama (un fichero).  También se oye hablar a
	       la gente del árbol de directorios como si se tratara de
	       un <em>árbol genealógico</em>: así, los subdirectorios
	       tienen "padres", y un camino muestra todos los
	       antecesores de un fichero.

	     <p>También existen los caminos relativos que comienzan en
	       cualquier punto distinto del directorio raíz.
	       Trataremos esto más a fondo más tarde.

	   <item> No hay directorios que se correspondan con
	     dispositivos físicos, como su disco duro.  En esto se
	     difiere de DOS y Windows, donde todos los caminos
	     comienzan con el nombre de un dispositivo, como
	     <tt>C:</tt>.  Se pretende que el árbol de directorios sea
	     una abstracción del equipo físico, de modo que se pueda
	     usar el sistema sin saber cuál es su hardware.  Todos sus
	     ficheros pueden podrían hallarse en un disco, o podría
	     tener 20 discos, algunos de ellos conectados a una
	     computadora diferente en algún lugar de la red.  No se
	     puede decir, sólo mirando el árbol de directorios, y
	     prácticamente todas las órdenes funcionan exactamente
	     igual sin importar en qué dispositivo(s) físico(s) se
	     encuentran en realidad los ficheros.

	 </list>

	 <p> No se preocupe si todo esto no le queda completamente
	   claro aún.  Aún han de llegar muchos ejemplos.

       <sect id="basics-files-using"> Utilizar ficheros: los primeros
         pasos


	 <p>Para usar su sistema tendrá que saber cómo crear, mover,
	   renombrar, y borrar ficheros y directorios.  Esta sección
	   describe cómo hacerlo con las órdenes estándar en Debian.

	 <p>La mejor manera de aprender es practicar.  Siempre que
	   no sea root (y no haya creado aún archivos personales
	   importantes), no hay nada que pueda estropear demasiado
	   seriamente.  Póngase a ello; escriba cada una de estos
	   instrucciones en el prompt y apriente Intro:

	   <enumlist>

	     <item> <tt>pwd</tt> <p> La shell que está usando considera
	       siempre a un directorio el <em>directorio activo de
	       trabajo</em>.  Puede ver cuál es este directorio con la
	       orden <tt>pwd</tt>, que proviene de Print Working
	       Directory

	       <footnote>(N. del T.: Imprimir el Directorio
	       Activo.)</footnote>.

	       <tt>pwd</tt> imprime el nombre del directorio en el que
	       usted está trabajando,  probablemente
	       <tt>/home/sunombre</tt>.

	     <item> <tt>ls</tt> <p> <tt>ls</tt> procede de "listar",
	       como en "listar archivos".  Cuando teclea <tt>ls</tt>,
	       el sistema muestra una lista de todos los ficheros en su
	       directorio activo de trabajo.  Si usted se ha limitado a
	       instalar Debian, su directorio principal de usuario bien
	       podría estar vacío.  Si su directorio activo de trabajo
	       está vacío, <tt>ls</tt> no produce resultado alguno,
	       puesto que no hay archivos que listar.

	     <item> <tt>cd /</tt> <p> <tt>cd</tt> significa Cambiar
	       Directorio.  En este caso, ha pedido cambiar al
	       directorio raíz.

	     <item> <tt>pwd</tt> <p> Verifique que se encuentra en
	       el directorio raíz.

	     <item> <tt>ls</tt> <p> Vea lo que hay en <tt>/</tt>.

	     <item> <tt>cd</tt> <p> Escribir <tt>cd</tt> sin
	       argumentos selecciona su directorio principal de
	       usuario como directorio activo de trabajo:
	       <tt>/home/sunombre</tt>.  Utilice <tt>pwd</tt> para
	       verificarlo.

	  </enumlist>

	 <p>Antes de proseguir, debería saber que hay en realidad dos
	   clases diferentes de nombres de fichero.  Algunos de ellos
	   comienzan por <tt>/</tt>, el directorio raíz, como
	   <tt>/etc/profile</tt>.  Estos se llaman nombres de archivo
	   <em>absolutos</em> porque se refieren al mismo archivo no
	   importa cuál sea su directorio activo de trabajo.  La otra
	   clase de nombres de fichero es <em>relativa</em>.

	 <p>Dos nombres de directorio se utilizan <em>solamente</em>
	   en nombres de archivo relativos: <tt>.</tt> y <tt>..</tt>.
	   El directorio <tt>.</tt> se refiere al directorio de
	   trabajo y <tt>..</tt> es el directorio padre.  Estos son
	   "atajos" para los directorios.  Existen en <em>cada</em>
	   directorio.  Incluso el directorio raíz tiene un directorio
	   padre: ¡él es su propio padre!

	 <p>Así que los nombres de fichero que incluyen <tt>.</tt> o
	   <tt>..</tt> son <em>relativos</em>, porque su significado
	   depende del directorio de trabajo.  Si estoy en
	   <tt>/usr/bin</tt> y escribo <tt>../etc</tt>, entonces me
	   estoy refiriendo a <tt>/usr/etc</tt>.  Si estoy en
	   <tt>/var</tt> y escribo <tt>../etc</tt>, entonces me estoy
	   refiriendo a <tt>/etc</tt>.  Dése cuenta de que un nombre de
	   fichero sin el directorio raíz precediéndolo implícitamente
	   tiene un <tt>./</tt> al frente.  Así que puede teclear
	   <tt>local/bin</tt> o <tt>./local/bin</tt> y significan lo
	   mismo.

	 <p>Un último consejo útil: la tilde <tt>~</tt> equivale a su
	   directorio principal de usuario.  De forma que escribir
	   <tt>cd ~</tt> es lo mismo que escribir <tt>cd</tt> sin
	   argumentos.  Además, puede escribir cosas como <tt> cd
	   ~/ejercicios/misubdirectorio</tt>.  De modo análogo,
	   <tt>~vicente</tt> equivale al directorio principal del
	   usuario "vicente", que probablemente se parece
	   a<tt>/home/vicente</tt>; así,
	   <tt>~vicente/docs/debian.ps</tt> equivale a
	   <tt>/home/vicente/doc/debian.ps</tt>.

	 <p>Aquí hay más órdenes de ficheros para probar, ahora que ya
	   sabe acerca de los nombres de fichero relativos.
	   <tt>cd</tt> a su directorio principal antes de comenzar.

	   <enumlist>

	     <item> <tt>cd ejercicios</tt> <p> Cambie al directorio
	       <tt>ejercicios</tt>.

	     <item> <tt>mkdir misubdirectorio</tt> <p> Cree un
	       subdirectorio de <tt>ejercicios</tt>.

	     <item> <tt>cp /etc/profile .</tt> <p> <tt>cp</tt> es la
	       versión corta de "copy".  <tt>/etc/profile</tt> es tan
	       sólo un fichero elegido al azar en su sistema, no se
	       preocupe de lo que es por ahora.  Lo hemos copiado en
	       <tt>.</tt>; recuerde que <tt>.</tt> significa
	       simplemente "el directorio en el que estoy ahora", o el
	       directorio activo de trabajo.  Así que hemos creado una
	       copia de <tt>/etc/profile</tt>, y la hemos puesto en
	       nuestro directorio <tt>ejercicios</tt>.  Pruebe a
	       introducir <tt>ls</tt> para comprobar que de veras hay
	       un fichero llamado <tt>profile</tt> en su directorio
	       activo de trabajo, al lado de <tt>misubdirectorio</tt>.

	       <item> <tt>more profile</tt> <p> Vea el contenido del
	       fichero <tt>profile</tt>.  <tt>more</tt> se utiliza para
	       ver el contenido de archivos de texto.  Se llama
	       <tt>more</tt>

	       <footnote>(N. del T.: "más".)</footnote>

	       porque muestra una pantalla del fichero cada vez, y
	       usted aprieta la barra espaciadora para ver más.
	       <tt>more</tt> termina cuando se llega al final del
	       archivo o cuando se aprieta <tt>q</tt> (quit).

	     <item> <tt>more /etc/profile</tt> Verifique que el
	       original tiene el mismo aspecto que la copia que hizo.

	     <item> <tt> mv profile misubdirectorio</tt> <p>
	       <tt>mv</tt> procede de "mover".  Hemos movido el
	       fichero <tt>profile</tt> del directorio de trabajo al
	       subdirectorio que creamos antes.

	     <item> <tt>ls</tt> <p>  Verifique que <tt>profile</tt> no
	       está ya en el directorio de trabajo.

	     <item> <tt>ls misubdirectorio</tt> <p> Verifique que
	       <tt>profile</tt> se ha movido a
	       <tt>misubdirectorio</tt>.

	     <item> <tt>cd misubdirectorio</tt> <p> Cambie al
	       subdirectorio.

	     <item> <tt>mv profile miprofile</tt> <p> Dése cuenta de
	       que al contrario de lo que sucede en algunos sistemas
	       operativos, no hay diferencia entre mover un fichero y
	       cambiarle el nombre.  Por tanto, no hay una orden
	       independiente <tt>rename</tt>

		 <footnote>(N. del T.: cambiar el nombre.)</footnote>
      
	       .  Dése cuenta de que el segundo argumento de
	       <tt>mv</tt> puede ser un directorio al que mover el
	       fichero o directorio, o un nuevo nombre de fichero.
	       <tt>cp</tt> funciona de la misma manera.

	     <p>Como de costumbre, introduzca <tt>ls</tt> para ver el
	       resultado de <tt>mv</tt>.

	     <item> <tt>mv miprofile ..</tt> <p> Igual que <tt>.</tt>
	       significa "el directorio en que me encuentro ahora",
	       <tt>..</tt> quiere decir "padre del directorio de
	       trabajo", en este caso el directorio <tt>ejercicios</tt>
	       que creamos antes.  Utilice <tt>ls</tt> para verificar
	       que es ahí donde <tt>miprofile</tt> está ahora.

	     <item> <tt>cd ..</tt> <p> Cambie directorios al directorio
	       padre, en este caso <tt>ejercicios</tt>, donde acaba
	       de poner <tt>miprofile</tt>.

	     <item> <tt>rm miprofile</tt> <p><tt>rm</tt> quiere decir
	     "borrar"

	     <footnote>(N. del T.: "remove".)</footnote>;

	     esto borra <tt>miprofile</tt>.  ¡Cuidado!  Borrar un
	     fichero en un sistema GNU/Linux es <em>permanente</em>,
	     no hay "recuperar"

	     <footnote>(N. del T.: "undelete".)</footnote>.

	     Si usted usa <tt>rm</tt>, el fichero habrá
	     <em>desaparecido</em> para <em>siempre</em>.

 <!-- Sí, dos veces para asegurarse de que el usuario lo entiende... ;) -->

	   <item> <tt>rmdir misubdirectorio</tt> <p> <tt>rmdir</tt> es
	     igual que <tt>rm</tt>, sólo que para directorios.  Dése
	     cuenta de que <tt>rmdir</tt> sólo funciona en directorios
	     vacíos: si el directorio contiene archivos, debe borrar
	     esos ficheros primero, o utilizar, en lugar de
	     <tt>rmdir</tt>, <tt>rm -r</tt>.

	   <item> <tt>cd ..</tt> <p> Salga del directorio de trabajo, y
	     entre en su directorio padre.  Ahora puede escribir:

	   <item> <tt>rmdir ejercicios</tt> <p> Esto borrará el último
	     resto de su sesión de prácticas.

	 </enumlist>

	 <p>Así que ahora ya sabe cómo crear, copiar, mover, renombrar,
	 y borrar archivos y directorios.  También ha aprendido algunos
	 atajos, como teclear simplemente <tt>cd</tt> para saltar a su
	 directorio principal de usuario, y <tt>.</tt> y <tt>..</tt>
	 para referirse al directorio de trabajo y su padre,
	 respectivamente.  También debería recordar el concepto de
	 <em>directorio raíz</em>, o <tt>/</tt>, y el alias <tt>~</tt>
	 para su directorio de usuario.

     <sect id="basics-processes"> Procesos

	 <p>Mencionábamos antes que GNU/Linux es un sistema
	   <em>multitarea</em>.  Puede realizar muchas tareas a la
	   vez.  Cada una de esas tareas se denomina <em>proceso</em>.
	   La mejor manera de sacar algo en claro de todo esto es
	   escribir <tt>top</tt> en el prompt de la shell.  Obtendrá
	   una lista de procesos, ordenados en función de la cantidad
	   de tiempo de proceso del ordenador están usando.  El orden
	   cambiará continuamente ante sus ojos.  En lo alto de la
	   pantalla, aparece cierta información sobre el sistema:
	   cuántos usuarios han ingresado, cuántos procesos hay en
	   total, de cuánta memoria dispone y cuánta está utilizando.

	 <p>En la columna del extremo de la izquierda, verá al usuario
	   propietario de cada proceso.  La columna del extremo de la
	   derecha muestra qué orden invocó el proceso.  Se dará
	   cuenta, probablemente, de que <tt>top</tt> mismo, llamado
	   por usted, está cerca de lo alto de la lista (puesto que
	   <tt>top</tt> comprueba constantemente la utilización de la
	   UCP, estará activo y usará la UCP para hacer la
	   comprobación).

	 <p>Note que todas las órdenes que terminan en <tt>d</tt> ---
	   como <tt>kflushd</tt> e <tt>inetd</tt> --- derivan de
	   <em>demonio</em>

	   <footnote>daemon significa en su origen "Disks And
	     Extensions MONitor"

	     <footnote>(N. del T.: por alguna curiosa razón, muchos
	       nombres Unix/Linux tienden a tener, esto... iniciales
	       comprometedoras: daemon, rat (rata, Robust-Audio Tool),
	       SATAN (Security Auditing Tool for Analysing Networks) o
	       sex (Simple Editor for X), son algunos
	       ejemplos).</footnote>

	   </footnote>.

	   Un demonio es un proceso no-interactivo, esto es, lo
	   ejecuta el sistema y los usuarios nunca tienen que
	   preocuparse por él.  Los demonios proveen servicios como la
	   conexión a internet, impresión, o correo electrónico.

	 <p>Ahora apriete <tt>u</tt> y dé a <tt>top</tt> su nombre de
	   usuario cuando pregunte.  La orden <tt>u</tt> pide ver
	   solamente aquellos procesos que le pertecen a usted; le
	   permite ignorar todos los demonios y cualquier cosa que
	   otras personas estén haciendo.  Puede advertir
	   <tt>bash</tt>, el nombre de su shell.  En general, casi
	   siempre estará ejecutando <tt>bash</tt>.

	 <p>Dése cuenta de que la columna dos de la pantalla de
	   <tt>top</tt> le muestra el <em>PID</em>, o número de
	   identificación de procesos

	   <footnote>(N. del T.: Process IDentification
	   number.)</footnote>.

	   A cada proceso se le asigna un único PID.  Usted puede
	   utilizar el PID para controlar procesos individuales
	   (trataremos esto más tarde).  Otro truco útil; teclee "?"
	   para obtener una lista de las órdenes de <tt>top</tt>.

	 <p>Puede preguntarse por la diferencia entre un "proceso" y
	   un "programa".  En la práctica los términos se usan de modo
	   intercambiable.  Técnicamente, el <em>programa</em> es el
	   conjunto de instrucciones escrito por un programador, y
	   mantenido en el disco.  El <em>proceso</em> es la
	   particularización funcional del programa que Linux mantiene
	   en la memoria.  Pero no es tan importante tener claros
	   estos términos.

	 <p>Buena parte de su interacción con la computadora implica el
	   control de procesos.  Querrá iniciarlos, detenerlos, y ver
	   qué pueden hacer.  Su instrumento primario para esto es la
	   <em>shell</em>.

       <sect id="basics-shell"> La shell

	 <p>La <em>shell</em> es un programa que le permite interactuar
	   con su ordenador.  Se llama shell porque proporciona un
	   entorno para que usted trabaje en él,  una suerte de
	   casita electrónica para usted cuando utiliza la computadora.
	   (Piense en el cangrejo ermitaño.)

	   <footnote>(N. del T.: "shell" significa "concha".)</footnote>

	 <p>La función más simple de la shell consiste en iniciar
	   otros programas.  Usted escribe el nombre del programa que
	   quiere ejecutar, seguido de los argumentos que quiere, y la
	   shell le pide al sistema que ejecute el programa para
	   usted.

	 <p>Por supuesto, los sistemas gráficos de ventanas también
	   hacen frente a esta necesidad.  Técnicamente, Windows 95
	   proporciona una shell gráfica, y el Sistema X Window es
	   otra clase de shell gráfica, pero "shell" se utiliza
	   comúnmente para referirse a la "shell de línea de
	   instrucciones".

	 <p>No es preciso decirlo, los hackers que trabajan con shells
	   no se conforman con introducir órdenes nada más.  La shell
	   dispone de un desconcertante número de características
	   útiles de las que puede querer aprovecharse.

	 <p>Hay disponibles incontables shells; la mayoría está basada
	   bien en la <em>shell Bourne</em> o en la <em>shell C</em>,
	   dos de las más antiguas.  El nombre de programa de la shell
	   Bourne original es <prgn>sh</prgn>, mientras que
	   <prgn>csh</prgn> es la shell C.  Las variantes de la shell
	   Bourne incluyen la Bourne Again Shell del proyecto GNU
	   (<tt>bash</tt>, la shell por defecto de Debian), la shell
	   Korn (<prgn>ksh</prgn>), y la shell Z (<prgn>zsh</prgn>).
	   También está <prgn>ash</prgn>, una adaptación
	   tradicionalista de la shell Bourne.  La variante más común
	   de la shell C es <prgn>tcsh</prgn> (la <tt>t</tt> rinde
	   homenaje a los sistemas operativos TENEX y TOPS-20, que
	   inspiraron algunas de las mejoras que <tt>tcsh</tt>
	   introduce sobre <tt>csh</tt>).

	 <p>Bash es probablemente la mejor opción para los nuevos
	   usuarios.  Es la shell por defecto, y recoge todas las
	   características que es probable que necesite.  Pero todas
	   las shells tienen sus leales seguidores; si quiere
	   experimentar, instale varios paquetes diferentes de shells y
	   cambie la suya con el comando <tt>chsh</tt>.  Simplemente
	   escriba <tt>chsh</tt>, proporcione la contraseña cuando se le
	   solicite, y elija una shell.  Cuando vuelva a ingresar,
	   estará usando la nueva shell.

       <sect id="basics-jobs"> Gestionando procesos con Bash

	 <p>Debian es un sistema multitarea, de modo que precisa de un
	   modo de hacer más de una cosa al mismo tiempo.  Los
	   entornos gráficos como las X proporcionan una forma natural
	   de hacer esto; permiten múltiples ventanas en la pantalla a
	   un mismo tiempo.  Naturalmente, Bash (o cualquier otra
	   shell) proporciona recursos semejantes.

	 <p>Antes, usted utilizó <prgn>top</prgn> para observar los
	   diferentes procesos en el sistema.  La shell ofrece algunas
	   formas útiles de rastrear sólo aquellos procesos que usted
	   ha iniciado desde la línea de instrucciones.  Cada línea de
	   instrucciones comienza un <em>trabajo</em> (también llamado
	   un <em>grupo de procesos</em>) para que la shell lo
	   ejecute.  Un trabajo puede consistir en un único proceso o
	   un conjunto de procesos en una <em>tubería</em> (más sobre
	   las tuberías más tarde).

<!-- [FIXME xref] -->

	 <p>Introducir una orden empezará un trabajo.  Escriba <tt>man
	   cp</tt> y la página de manual de <tt>cp</tt> aparecerá en
	   la pantalla.  La shell pasará a segundo plano, y regresará
	   cuando haya terminado de leer la página de manual (o
	   apriete <tt>q</tt> para salir en lugar de desplazarse a
	   través de todo el asunto).

	 <p>Pero digamos que está leyendo la página de manual, y
	   quiere hacer algo más durante un momento.  Ningún problema.
	   Apriete <tt>C-z</tt> mientras lee para <em>suspender</em>
	   el trabajo que se encuentra actualmente en primer plano, y
	   poner la shell en primer plano.  Cuando se suspende un
	   trabajo, Bash primero da cierta información sobre él, y
	   luego el prompt de la shell.  Verá algo como esto en la
	   pantalla:

<example>
KKKK
</example>


	 <p>Fíjese en las últimas dos líneas.  La penúltima es la
	   información sobre el trabajo, y después tiene el prompt de
	   la shell.

	 <p>Bash asigna un <em>número de trabajo</em> a cada línea de
	   órdenes que se ejecute desde la shell.  Esto le permite a
	   usted designar el proceso fácilmente.  En este caso,
	   <tt>man cp</tt> es el trabajo número 1, mostrado como
	   <tt>[1]</tt>.  El <tt>+</tt> quiere decir que este es el
	   último trabajo que tuvo en el primer plano.  Bash le
	   informa también sobre el estado actual del trabajo ---
	   <tt>Detenido</tt> --- y la línea de instrucciones del
	   trabajo.

	 <p>Hay muchas cosas que pueden hacerse con los trabajos.  Con
	   <tt>man cp</tt> aún suspendido, escriba:

	   <enumlist>

	     <item><tt>man ls</tt> <p> Comience un nuevo trabajo.

	     <item><tt>C-z</tt> <p> Suspenda el trabajo <tt>man
	       ls</tt> apretando las teclas Control y <tt>z</tt>
	       minúscula; debería ver la información del trabajo.

	     <item><tt>man mv</tt> <p> Inicie otro trabajo más.

	     <item><tt>C-z</tt> <p> Suspéndalo.

	     <item><tt>jobs</tt> <p> Pida a Bash que muestre los
	       trabajos actuales:

<example>
&dollar; jobs
[1]   Detenido           man cp
[2]-  Detenido           man ls
[3]+  Detenido           man mv
&dollar;
</example>

		Fíjese en <tt>-</tt> y <tt>+</tt>, que señalan
		respectivamente el penúltimo y último trabajos en
		primer plano.

	     <item><tt>fg</tt> <p> Coloque el último trabajo en haber
	       estado en primer plano (<tt>man mv</tt>, el que tiene
	       el <tt>+</tt>) en el primer plano de nuevo.  Si aprieta
	       la barra espaciadora, la página de manual continuará
	       desplazándose.

	     <item><tt>C-z</tt> <p> Suspenda de nuevo <tt>man mv</tt>.

	     <item><tt>fg %1</tt> <p> Puede referirse a cualquier
	       trabajo colocando un <tt>%</tt> frente a su número.  Si
	       utiliza <tt>fg</tt> sin especificar un trabajo, se
	       asume el último activo.

	     <item><tt>kill %1</tt> <p> Finalice el trabajo 1.  Bash
	       devolverá la información del trabajo:

<example>
&dollar; kill %1
[1]-  Terminado          man cp
&dollar;
</example>

	       Bash sólo le pide al trabajo que termine, y a veces un
	       trabajo no querrá hacerlo.  Si el trabajo no termina,
	       puede añadir la opción <tt>-9</tt> a kill para dejar de
	       pedir y empezar a exigir.  Por ejemplo:

<example>
&dollar; kill -9 %1
[1]- Terminado            man mv
&dollar;
</example>

	       La opción <tt>-9</tt> elimina el trabajo por la fuerza y
	       sin condiciones.

	       <footnote>En términos técnicos, <tt>kill</tt>
	         simplemente envía una señal.  Por defecto envía una
	         señal que solicita la terminación (<tt>TERM</tt>, o
	         señal 15); pero usted puede especificar una señal, y
	         la señal 9 (<tt>KILL</tt>) es la señal que fuerza la
	         terminación.  El nombre de instruccion <tt>kill</tt>
	         no se adecúa necesariamente a la señal enviada; por
	         ejemplo, enviar la señal <tt>TSTP</tt> (stop
	         terminal) suspende el proceso pero le permite ser
	         retomado más tarde.</footnote>

	       <footnote>(N. del T.: debe tener en cuenta, respecto de
	         los ejemplos que aquí se incluyen, que los mensajes
	         difieren en español e inglés de bash difieren.  Así,
	         en el caso anterior, la línea "[1]- Terminado man mv"
	         es en inglés "[1]- Killed man mv", más informativa
	         pero sin equivalencia en nuestro idioma.)</footnote>

 <!-- FIXME ¿Cuál es la diferencia (¡¿si la hay?!) entre SIGSTOP (19) Y -->
 <!-- SIGTSTP (20) ???
 Dímelo (vincent@debian.org) si lo sabes...
 -->

	     <item><tt>top</tt> <p> Traiga de vuelta la pantalla de
	       <tt>top</tt> para ver sólo sus procesos.  Busque en la
	       columna a mano derecha las instrucciones <tt>man ls</tt>
	       y <tt>man mv</tt>. <tt>man cp</tt> no estará aquí puesto
	       que la cerró.  <tt>top</tt> le muestra los procesos del
	       sistema que corresponden a sus trabajos; fíjese en que
	       el PID a la izquierda de la pantalla no se corresponde
	       con el número de trabajo.

	     <p>Puede que no sea capaz de encontrar sus procesos porque
	       se encuentren por debajo de la parte inferior de la
	       pantalla; si está utilizando las X, puede redimensionar
	       la <tt>xterm</tt>

	     <footnote>(N. del T.: "xterm" deriva de "xterminal" o
	       "terminal de las X".)</footnote>

	       para resolver este problema.

	     <p>Incluso estos trabajos simples consisten en realidad en
	       múltiples procesos, que incluyen el proceso <tt>man</tt> y
	       el paginador <tt>more</tt> que maneja el desplazamiento
	       de una página cada vez.  Puede notar que los procesos
	       <tt>more</tt> aparecen también en <tt>top</tt>.

	   </enumlist>

	 <p>Probablemente puede figurarse cómo eliminar los dos
	   trabajos restantes.  Puede, o bien cerrarlos (con la orden
	   <tt>kill</tt>) o traerlos a primer plano (con <tt>fg</tt>)y
	   salir de cada uno de ellos.  Recuerde que la instrucción
	   <tt>jobs</tt> le informará de la lista de trabajos
	   existentes y su estado.

	 <p>Una última nota: la documentación de Bash es bastante
	   buena, pero se encuentra en el sistema de ayuda Info más que
	   en las páginas de manual.  Para leerla, teclee <tt>info
	   bash</tt>.  Vea <ref id="docs-info"> para las instrucciones
	   acerca del uso del programa <tt>info</tt>.  Bash también
	   contiene un muy buen resumen de sus órdenes, accesible
	   mediante la instrucción <tt>help nombredeltema</tt>;
	   escriba

<!-- ARREGLAR : la documentación de referencia de Bash está en las -->
<!-- páginas de manual, como dice la propia página info.  Lo que hay -->
<!-- en info es una introducción para principiantes. -->

<example>
help cd
</example>

	   por ejemplo.  Esto le proporcionará detalles sobre los
	   argumentos <tt>-P</tt> y <tt>-L</tt>, reconocidos por
	   <tt>cd</tt>.

       <sect id="basics-bash"> Algunas características de Bash

	 <p>Esta sección menciona solamente algunas de las
	   características más utilizadas de Bash; para una
	   explicación más completa vea <ref id="shell">.

       <sect1 id="basics-bash-completion"> Compleción Tab

	 <p>La shell Bash puede adivinar que nombre de fichero u orden
	   está usted tratando de escribir, y terminarlos
	   automáticamente.  Escriba nada más el principio de una
	   instrucción o nombre de archivo, y apriete <tt>TAB</tt>.  Si
	   Bash encuentra una sola manera de completarla, concluirá la
	   palabra y colocará un espacio tras ella.  Si encuentra
	   varias formas posibles de completarla, rellenará la parte
	   que todas esas formas tienen en común y dará un pitido.
	   Usted podrá entonces introducir un fragmento de la palabra
	   que baste para hacerla única, y apretar <tt>TAB</tt> de
	   nuevo.  Si no encuentra ninguna forma de completar, se
	   limitará a pitar.

 <!-- FIXME XXX
 <sect1> ¿Más características? Si no eliminar esta sección.
 -->

      <sect id="basics-identity"> Gestionando la identidad

	 <p>Los sistemas al estilo Unix son multiusuario, y por tanto
	   usted posee su propia identidad electrónica como usuario
	   del sistema.  Escriba
	   <tt>finger<var>sunombredeusuario</var></tt> para darle un
	   vistazo a algunas de las informaciones sobre usted que
	   están a disposición de todos

	   <footnote>(N. del T.: "finger", señalar o
	   identificar.)</footnote>.

	   Para cambiar el nombre y la shell listados ahí, puede
	   utilizar las órdenes <tt>chfn</tt> y <tt>chsh</tt>.  Sólo
	   el superusuario puede cambiar su nombre de ingreso (nombre
	   de usuario) y directorio principal.  Se dará cuenta de que
	   dice "No Plan" --- un "plan" consiste simplemente en cierta
	   información que usted puede hacer disponible para los
	   demás.  Para crear un plan, coloque cualquier información
	   que quiera que vea la gente en un fichero llamado
	   <tt>.plan</tt> --- para hacer esto tendrá que utilizar un
	   editor de txto (vea <ref id="editor">).  Luego hágase
	   finger a sí mismo para ver su plan.  Los demás pueden
	   hacerle finger a usted para ver su plan, y comprobar si ha
	   recibido nuevo correo o si lo ha leído.

	 <p>Dése cuenta de que esta información de finger está
	   disponible por defecto para Internet entera.  Si no lo
	   quiere así, lea sobre la configuración de <tt>inetd</tt> y
	   el archivo <tt>/etc/services</tt>.  En su día, el manual
	   de instalación describirá esta configuración, por ahora
	   puede intentarlo con las páginas de manual, o limitarse a
	   poner tonterías en su información de finger.

     <chapt id="docs"> <heading> Leer la documentación y conseguir ayuda </heading>

      <sect id="docs-sources"> Clases de documentación	

	 <p>Desgraciadamente, la documentación en los sistemas al
	   estilo Unix está un poco desorganizada.  En Debian, usted
	   puede encontrar documentación en al menos los siguientes
	   sitios:

	   <list>

	     <item> Páginas de <tt>manual</tt>, que se leen con la orden
	       <tt>man</tt>.

	     <item> Páginas <tt>info</tt>, que se leen con la orden
	       <tt>info</tt>.

	     <item> Los directorios
	       <tt>/usr/doc/<var>paquete</var></tt>, donde
	       <var>paquete</var> es el nombre del paquete Debian.

	     <item> <tt>/usr/doc/HOWTO</tt> contiene los documentos
	       CÓMO del Proyecto de Documentación de Linux, si ha
	       instalado los paquetes de Debian que los incluyen.

	       <footnote>(N. del T.: en el caso de que haya instalado
	       el correspondiente paquete español de documentos CÓMO,
	       los encontrará en el directorio
	       <tt>/usr/doc/HOWTO/spanish</tt>.)</footnote>

	     <item> Muchos comandos disponen de las opciones
	       <tt>-h</tt> o <tt>--help</tt>

	       <footnote>(N. del T.: "help", ayuda.)</footnote>

	     <item> El Proyecto de Documentación de Debian ha escrito
	       algunos manuales, incluido éste.  Compruebe
	       <url id="http://www.debian.org/doc/ddp" name="su página principal">.

	     <item> La <url id="http://www.debian.org/support/"
	       name="página de apoyo de Debian"> tiene una FAQ

	       <footnote>(N. del. T.: "FAQ" procede de Frecuently Asked
	       Questions, o Preguntas Frecuentes, o, como se suele
	       traducir por simetría, Preguntas Más Frecuentes.)</footnote>

	       y otros recursos.  También puede intentar <url
	       id="http://www.linux.org" name="el sitio web de Linux">.

	     <item>Puede adquirir muchos libros sujetos a derechos de
	       autor con información útil.  Mucha gente habla muy bien
	       de la marca O'Reilly.  Sin embargo, plantéese apoyar
	       cuando sea posible manuales de libre modificación y
	       redistribución como éste.  Si quiere una copia en papel,
	       adquirir los manuales libres de la Fundación para el
	       Software Libre (disponibles en muchas librerías, como
	       Borders, y directamente de la FSF) apoya la creación de
	       más software libre.

		 <footnote>(N. del T.: fuera de Estados Unidos un modo
		 sencillo de adquirirlos es a través de internet, en
		 <url id="http://www.amazon.com" name="Amazon"> o <url
		 id="http://www.borders.com"
		 name="Borders">.)</footnote>

	   </list>

	 <p>La confusa variedad de fuentes de documentación se debe a
	   muchas razones.  Por ejemplo, se supone que <tt>info</tt>
	   está llamado a reemplazar a <tt>man</tt>, pero <tt>man</tt>
	   aún no ha desaparecido.  Sin embargo, ¡está bien saber que
	   existe tanta documentación!

	 <p>Así que, ¿dónde buscar ayuda?  Aquí van algunas
	   sugerencias:

	   <list>

	     <item> Utilice las páginas <tt>man</tt> y las opciones
	       <tt>--help</tt> o <tt>-h</tt> para obtener un rápido
	       resumen de la sintaxis de los comandos y sus opciones.
	       Use también <tt>man</tt> si un programa no tiene aún una
	       página <tt>info</tt>.

	     <item> Utilice <tt>info</tt> si un programa tiene
	       documentación <tt>info</tt>.

	     <item> Si ninguno de estos funciona, mire en
	       <tt>/usr/doc/<var>nombredelpaquete</var></tt>.

	     <item> <tt>/usr/doc/<var>nombredelpaquete</var></tt>
	       recoge con frecuencia información específica de Debian,
	       incluso si existen páginas de manual o info.

	     <item> Utilice los <tt>CÓMO</tt>

	       <footnote>(N. del T.: "HOWTO".)</footnote>

	       para las instrucciones acerca de cómo configurar una
	       cosa determinada, o en busca de información sobre su
	       hardware particular.  Por ejemplo, el Ethernet-CÓMO
	       contiene valiosa información sobre las tarjetas
	       ethernet, y el PPP-CÓMO explica con detalle cómo
	       configurar PPP.

	     <item> Utilice los manuales del Proyecto de Documentación
	       de Debian para explicaciones conceptuales e información
	       específica de Debian.

	     <item> Si falla todo lo demás, pregúntele a alguien.  Vea
	       <ref id="docs-support">.

	   </list>

	 <p>Utilizar las páginas de manual se ha explicado antes en
	   <ref id="basics-commandline">.  (Es muy simple: apriete la
	   barra espaciadora para ir a la página siguiente, y apriete
	   <tt>q</tt> para dejar de leer.)  En este capítulo se tratan
	   <tt>info</tt>, ver archivos
	   en <tt>/usr/doc</tt>, y pedir ayuda a otras personas

      <sect id="docs-textfiles"> Ver archivos de texto con more y less

 <!-- FIXME Utilizarlos para ver algunos documentos.  Mencionar zless y -->
 <!-- cuándo usarlo -->

<!-- ARREGLAR : a lo mejor es demasiado avanzado, pero creo que sería -->
<!-- conveniente citar los preprocesadores -->

      <sect id="docs-howtos"> CÓMOs

	 <p>Además de sus libros, el Proyecto de Documentación de Linux
	   ha creado una serie de breves documentos que describen cómo
	   configurar un aspecto particular de GNU/Linux.  Por ejemplo,
	   el SCSI-CÓMO describe algunas de las complicaciones de usar
	   SCSI --- un modo estándar de comunicarse con los
	   dispositivos --- con GNU/Linux.  En general, los CÓMO tienen
	   información más específica sobre configuraciones de hardware
	   en particular, y estarán más al día que este manual.

	 <p>Hay paquetes Debian para los CÓMO.
	   <var>doc-linux-text</var> contiene los distintos CÓMO en
	   formato texto; mientras que el paquete
	   <var>doc-linux-html</var> contiene los CÓMO en (¡sorpresa!)
	   formato HTML que puede ser visualizado en un navegador.
	   Fíjese también en que Debian ha empaquetado traducciones de
	   los CÓMO en distintos idiomas que usted puede preferir si el
	   inglés no es su lengua materna.

	   <footnote>Debian tiene paquetes para las versiones alemana, francesa,
	   española, italiana, japonesa, koreana, polaca, sueca y china
	   de los CÓMO; normalmente se encuentran en el paquete
	   <var>doc-linux-códigodeidioma</var>, donde
	   <var>códigodeidioma</var> es <tt>fr</tt> para el francés,
	   <tt>es</tt> para el español, etc...</footnote>

	   <footnote>(N. del T.: el español es <var>doc-linux-es</var>,
	   por tanto.  Asimismo, existen <var>doc-debian-es</var> (la
	   FAQ de Debian), <var>manpages-es</var> (páginas de manual) y
	   un <var>user-es</var> con elementos de configuración
	   apropiados para hispanohablantes, entre otros.)</footnote>

	   Si usted ha instalado alguno de ellos, debería tenerlos en
	   <tt>/usr/doc/HOWTO</tt>.  Sin embargo, puede encontrar
	   versiones más recientes en la red en la <url
	   id="http://sunsite.unc.edu/LDP/" name="Página Principal del
	   Proyecto de Documentación de Linux">.

      <sect id="docs-support"> Obtener ayuda de otras personas

	 <p>El lugar correcto para pedir ayuda sobre Debian es la
	   lista de correo del usuario de Debian
	   <email>debian-user@lists.debian.org</email>.  Si sabe cómo
	   utilizar IRC (Internet Relay Chat), hay un canal
	   <tt>#debian</tt> en <tt>irc.debian.org</tt>.  Puede
	   encontrar ayuda sobre GNU/Linux en general en la jerarquía
	   <tt>comp.os.linux.*</tt> de Usenet.  Puede buscar preguntas
	   y respuestas hechas en Usenet con el <url
	   id="http://www.dejanews.com" name="Servicio DejaNews">.
	   También es posible contratar a asesores profesionales para
	   que le proporcionen servicios garantizados de asistencia
	   técnica. <url id="http://www.debian.org" name="El sitio web
	   de Debian"> tiene más información sobre muchos de estos
	   recursos.

	   <footnote>(N. del T.: para los hispanohablantes existe una
	   lista específica de usuarios de Debian
	   <email>debian-user-spanish@lists.debian.org</email> y
	   jerarquías propias en Usenet.  Es particularmente activo
	   <tt>es.comp.os.linux</tt>.)</footnote>

	 <p>Otra vez, por favor <em>no</em> pida ayuda a los autores
	   de este manual.  En cualquier caso, probablemente no
	   conocemos la respuesta a su problema específico; si envía
	   un correo electrónico a <tt>debian-user</tt> recibirá
	   respuestas de más calidad y más rápidamente.

	 <p>Sea siempre educado y haga un esfuerzo por ayudarse a sí
	   mismo leyendo la documentación.  Recuerde, Debian es un
	   esfuerzo voluntario y la gente le está haciendo un favor al
	   dedicar su tiempo a ayudarle.  Muchos de ellos cobran
	   cientos de dólares por los mismos servicios durante el día.

      <sect1 id="docs-support-posting"> Lo que hay que hacer y lo que
      no al preguntar

	 <p>

	   <list>

	     <item> LEA la documentación obvia primero.  Cuestiones
	       como las opciones de las órdenes y lo que hace una
	       instrucción estarán ahí.

	     <item> COMPRUEBE los documentos CÓMO si su pregunta trata
	       acerca de configurar algo, como PPP o Ethernet.

	     <item> INTENTE asegurarse de que la respuesta no está en
	       este manual (aunque nos damos cuenta de que un índice
	       sería útil, ¡estamos trabajando en ello!).

	     <item> NO TENGA MIEDO DE PREGUNTAR, después de haber hecho
	       un esfuerzo básico para descubrirlo por usted mismo.

	     <item> NO TENGA MIEDO DE PEDIR EXPLICACIONES sobre
	       conceptos, consejo, y otras cosas que no se encuentran
	       con frecuencia en la documentación.

	     <item> INCLUYA cualquier información que parezca
	       relevante.  Casi siempre tendrá que mencionar la
	       versión de Debian que está usando.  También debería
	       mencionar la versión de cualquier paquete pertinente:
	       la orden <tt>dpkg --status
	       <var>nombredelpaquete</var></tt> se lo dirá.  También
	       es útil decir qué ha intentado hasta ahora y qué
	       sucedió.  Por favor, incluya los mensajes exactos de
	       error, si es que los hay.

	     <item> NO SE DISCULPE por su ignorancia, o presente
	       excusas por ser un novato.  No hay razón alguna por la
	       que todo el mundo deba ser un experto en GNU/Linux para
	       usarlo, no más de las que hay para tener que ser un
	       mecánico si quiere utilizar un coche.

	     <item> NO POSTEE O ENVÍE CORREO EN HTML.  Algunas
	       versiones de Netscape e Internet Explorer utilizarán
	       HTML en lugar del formato texto.  La mayoría de la gente
	       ni siquiera lee esos mensajes, porque son difíciles de
	       leer en la mayor parte de los programas de correo.
	       Debería haber en alguna parte una opción de
	       configuración en las preferencias para deshabilitar el
	       HTML.

	     <item> SEA EDUCADO.  Recuerde que Debian es un esfuerzo
	       exclusivamente voluntario, y cualquiera que le ayude lo
	       hace sólo porque es una persona amable.

	     <item> REENVÍE SU PREGUNTA a la lista si no ha obtenido
	       respuesta después de varios días.  Quizás había montones
	       de mensajes y el suyo pasó desapercibido.  O quizás
	       nadie conoce la respuesta.  Si nadie responde la
	       segunda vez, esto es lo más probable.  Puede tratar de
	       incluir más información la segunda vez.

	     <item> RESPONDA usted mismo a las preguntas, cuando sepa
	       la respuesta.  Debian depende de que todo el mundo
	       cumpla su parte.  Si usted hace una pregunta, y más
	       tarde algún otro pregunta lo mismo, usted sabrá cómo
	       responder.  ¡Hágalo!

	   </list>

     <sect id="docs-sysinfo"> Obtener información del sistema

	 <p>Cuando diagnostique un problema o pida ayuda, necesitará
	   obtener información sobre su sistema.  Aquí hay algunas
	   formas de hacerlo.

 <!-- FIXME detallar estar órdenes un poco más ;) -->

	 <p> /var/log/*, dmesg, uname -a

     <chapt id="shell"> <heading> Usar la shell </heading>

 <!-- FIXME XXX
 <sect id="shell-jobs"> Más sobre el control de trabajos

 <p>Completar el control de trabajos con los detalles no cubiertos
 antes, kill -9.  Kill funciona sobre el PID.

 -->

      <sect id="shell-variables"> Variables de entorno

	 <p>Cada proceso tiene un <em>entorno</em> asociado a él.  Un
	   entorno es una colección de <em>variables de entorno</em>.
	   Una variable es un valor susceptible de ser modificado que
	   tiene un nombre fijo.  Por ejemplo, el nombre
	   <tt>EMAIL</tt> podría referirse al valor
	   <tt>juan@nadie.com</tt> El valor puede cambiar: también
	   <tt>EMAIL</tt> podría referirse a
	   <tt>juana@alguien.com</tt>.

	 <p>Dado que la shell es un proceso como cualquier otro, tiene
	   un entorno.  Puede ver el entorno de su shell introduciendo
	   la orden <tt>printenv</tt>.  Aquí está un resultado de
	   ejemplo:

 <example>
 PAGER=less
 HOSTNAME=icon
 MAILCHECK=60
 MOZILLA_HOME=/usr/local/lib/netscape
 PS1=$ 
 USER=hp
 MACHTYPE=i486-pc-linux-gnu
 EDITOR=jed
 DISPLAY=:0.0
 LOGNAME=hp
 EMAIL=hp@pobox.com
 SHELL=/bin/bash
 HOSTTYPE=i486
 OSTYPE=linux-gnu
 HISTSIZE=150
 HOME=/home/hp
 TERM=xterm-debian
 TEXEDIT=jed
 PATH=/home/hp/local/bin:/usr/sbin:/home/hp/.bin:/home/hp/local/bin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:.
 _=/usr/bin/printenv
 </example>


	 <p>En su sistema, el resultado será diferente, pero similar.

	 <p>Las variables de entorno son una forma de configurar el
	   sistema.  Por ejemplo, la variable <tt>EDITOR</tt> le
	   permite seleccionar su editor preferido para envíar
	   mensajes a los grupos de noticias, escribir correo
	   electrónico, y demás.  La variable <tt>HISTSIZE</tt> le
	   dice a Bash cuántas líneas de órdenes debe mantener en su
	   historial; usted puede volver a ese número de líneas de
	   órdenes con la flecha superior.

	 <p>Establecer variables de entorno es simple.  Una vez que
	   aprenda cómo, querrá probablemente definirlas
	   automáticamente siempre que ingrese; vea <ref id="custom
	   shell"> para más instrucciones.

	 <p>Para practicar, pruebe a personalizar el prompt de su shell
	   y su visualizador de archivos de texto con variables de
	   entorno:

	 <p><enumlist>

	   <item><tt>man less</tt> <p> Vea el manual en línea de la
	     orden <tt>less</tt>.  Para mostrarle el texto a razón de
	     una pantalla por vez, <tt>man</tt> llama a un
	     <em>paginador</em> que le muestra una nueva página cada ez
	     que aprieta la barra espaciadora.  Por defecto, utiliza el
	     paginador llamado <tt>more</tt>.

	   <item><tt>export PAGER=less</tt><p>Después de leer acerca
	     de las ventajas de <tt>less</tt>, podría querer usarlo
	     para leer las páginas de manual.  Para hacerlo, establece
	     la variable de entorno <tt>PAGER</tt>

	     <p>La orden que configura una variable de entorno dentro
	       de bash siempre tiene este formato: <tt>export
	       <var>NOMBRE</var>=<var>valor</var></tt>.  En caso de
	       que utilice <tt>tcsh</tt> u otra derivada de la shell
	       C, la instrucción equivalente es <tt>setenv
	       <var>NOMBRE</var> <var>valor</var></tt>.

	     <p> <tt>export</tt> quiere decir pasar la variable de
	       la shell al entorno.  Esto significa que programas
	       distintos de la shell pueden acceder a ella.

	   <item><tt>echo <var>$PAGER</var></tt> <p> Esta es la forma
	     más sencilla de ver el valor de una variable.
	     <tt>$PAGER</tt> le dice a la shell que inserte el valor
	     de la variable <tt>PAGER</tt> <em>antes</em> de ejecutar
	     la instrucción.  <tt>echo</tt> devuelve su argumento: en
	     este caso, devuelve el valor actual de <tt>PAGER</tt>,
	     <tt>less</tt>.

	   <item><tt>man more</tt> <p> Lea el manual de <tt>more</tt>.
	     Esta vez, <tt>man</tt> debería haber llamado al paginador
	     <tt>less</tt>.

	 <p><tt>less</tt> es capaz de un buen número de funciones de
	   las que <tt>more</tt> carece.  Por ejemplo, usted podrá
	   desplazarse hacia atrás con la tecla <tt>b</tt>.  También
	   puede moverse arriba y abajo (incluso hacia los lados) con
	   las teclas de flecha.  <tt>less</tt> no terminará cuando
	   alcance el final de la página de manual; esperará que usted
	   apriete la <tt>q</tt>.

	 <item><tt>PAGER=more man more</tt> <p> Si quiere establecer
	   temporalmente un valor diferente, puede activarlo sólo para
	   la línea de instrucciones actual.  Ponga el
	   <tt><var>NOMBRE</var>=<var>valor</var></tt> al principio de
	   la línea de órdenes, seguida de la instrucción que quiere
	   ejecutar.  Asegúrese de omitir <tt>export</tt>.

	 <p>Puede ensayar algunas de las órdenes específicas de
	   <tt>less</tt>, para verificar que no funcionan con
	   <tt>more</tt> y usted está utilizando <tt>more</tt>
	   realmente.

<!-- FIXME
En mi Debian 2.1, /bin/more *tiene* una 'b' funcional.  Necesitamos
encontrar otro rasgo específico de 'less'.
-->

<!-- ARREGLAR ya de antes.  Pero, por ejemplo, en el more de lftp esa 'b' -->
<!-- no existe.  En todo caso, '?' muestra las opciones  -->

	 <item><tt>echo $PAGER</tt> <p> El valor de <tt>PAGER</tt>
	   debería ser aún <tt>less</tt>; la configuración anterior
	   era sólo temporal.

	 <item><tt>unset PAGER</tt> <p>Si no quiere definir ya un
	   paginador, puede hacer <tt>unset</tt> con la variable

	   <footnote>(N. del T.: "unset", desconfigurar.)</footnote>.

	   <tt>man</tt> usará entonces <tt>more</tt> por defecto, tal
	   como lo hacía antes de que definiera la variable.

	 <item><tt>echo $PAGER</tt> <p>Puesto que se ha eliminado la
	   definición de <tt>PAGER</tt>, <tt>echo</tt> no devolverá
	   nada.

	 <item><tt>PS1=hola:</tt> <p> Por pura diversión, cambie el
	   prompt de su shell. <tt>$</tt> debería convertirse en
	   <tt>hola:</tt>.

	 <p><tt>export</tt> no es necesario, porque estamos cambiando
	   el comportamiento de la propia shell.  No hay razón para
	   exportar la variable al entorno para que la vean otros
	   programas.  Técnicamente, <tt>PS1</tt> es una <em>variable
	   de la shell</em> más que una variable del entorno.

	 <p>Si quisiera, podría exportar la variable de la shell,
	   transformándola en una variable del entorno.  Entonces
	   otros programas podrían verla: específicamente, los
	   <em>hijos</em> del proceso actual de la shell.  La sección
	   siguiente lo explica.

	</enumlist>

    <sect1 id="shell-variables-parents"> Procesos padres e hijos

	<p>Todos los procesos proceden de un proceso anterior, llamado
	  su <em>proceso padre</em>.

	  <footnote> Puede que crea que aquí se plantea el problema de
	    la gallina y el huevo.  Hay un proceso original que inicia
	    todos los demás; es el proceso número 1, <tt>init</tt>.
	    Puede verlo ejecutarse escribiendo <tt>ps u
	    1</tt>.</footnote>

	  La orden <prgn>ps</prgn> es una herramienta útil para
	  explorar los procesos, y puede emplearse para examinar las
	  relaciones entre procesos padres e hijos.

	<enumlist>

	  <item><tt>ps f</tt> <p> Esta orden solicita ver una lista de
	    los procesos que le pertenecen a usted, en un formato que
	    muestra cómo se relacionan entre sí.

	</enumlist>

	<p><tt>ps f</tt> puede devolver un resultado como este:

<example>
$ ps f
  PID  TT STAT   TIME
 7270  p5 S      0:00 bash
15980  p5 R      0:00  \_ ps f
19682  p4 S      0:00 bash
15973  p4 S      0:00  \_ man ps
15976  p4 S      0:00      \_ sh -c /bin/gzip -dc '/var/catman/cat1/ps.1.gz' | { export MAN_PN LESS; MAN_PN='ps(1)'; LESS="$LESS\$-Pm\:\$i
15977  p4 S      0:00          \_ /bin/gzip -dc /var/catman/cat1/ps.1.gz
15978  p4 S      0:00          \_ sh -c /bin/gzip -dc '/var/catman/cat1/ps.1.gz' | { export MAN_PN LESS; MAN_PN='ps(1)'; LESS="$LESS\$-Pm\
15979  p4 S      0:00              \_ less
export MAN_PN LESS; MAN_PN='ps(1)'; LESS="$LESS\$-Pm\
15979  p4 S      0:00              \_ less
$ 
</example>

	<p>Aquí puede ver que tengo un cierto número de procesos
	  ejecutándose, incluidas dos shells.  Las shells tienen
	  procesos hijos: el proceso de la shell 7270 tiene el proceso
	  hijo 15980 (<tt>ps f</tt>) y la shell 19682 tiene el proceso
	  hijo 15973 (<tt>man ps</tt>).  <tt>man ps</tt>, a su vez, ha
	  invocado un complejo conjunto de subprocesos para mostrar
	  una página de manual.  No se preocupe de lo que hacen esos
	  procesos por ahora.

	<p>Padres e hijos mantienen una compleja relación.  La mayor
	  parte del tiempo, cuando muere un padre el hijo morirá
	  también.  De este modo, se puede cerrar un conjunto entero
	  de procesos --- por ejemplo, todos los hijos de <tt>man
	  ps</tt> en el ejemplo superior --- matando al proceso padre,
	  15973.

	<p>Los hijos heredan las variables de entorno de sus padres, y
	  algunos otros atributos, como el directorio activo de
	  trabajo.

	<p>Cuando una shell ejecuta una orden, inicia la instrucción
	  como un proceso hijo.  Así, la orden <tt>man</tt> hereda el
	  entorno de la shell; si usted ha definido la variable
	  <tt>PAGER</tt>, <tt>man</tt> será capaz de verla.

	<p>Si no llega a exportar una variable, sólo la shell misma la
	  verá, y no se la pasará a los hijos como <tt>man</tt>.

     <sect id="shell-path"> Donde viven las órdenes: la variable
       <tt>PATH</tt>

	<p>Cuando usted escribe una orden en la shell, ésta tiene que
	  encontrar el programa en su disco duro antes de ejecutarlo.
	  Si la shell tuviera que mirar en todo el disco, sería
	  demasiado lenta; en su lugar, mira en una lista de
	  directorios contenida en la variable de entorno
	  <tt>PATH</tt>.  Esta lista de directorios forma el
	  <em>camino de búsqueda</em> de las shells; cuando usted
	  introduce una instrucción, pasa por cada uno, en orden, en
	  busca del programa que le ha pedido ejecutar.

	<p>Puede que usted necesite cambiar la variable <tt>PATH</tt>
	  si instala programas por sí mismo en una localización no
	  estándar.

	<p>El valor de <tt>PATH</tt> es una lista de directorios
	  separados por dos puntos (:).  El valor por defecto en los
	  sistemas Debian es:

<example>
/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games  
</example>

	<p>Este valor se encuentra definido en el archivo
	  <tt>/etc/profile</tt>

	  <footnote>(N. del T.: "profile", perfil, por referencia a
	  "perfil de usuario".)</footnote>

	  y se aplica a todos los usuarios.  Puede cambiar el valor
	  fácilmente, tal como puede cambiar el valor de cualquier
	  variable de entorno.

	<p>Si introduce la orden <tt>ls</tt>, la shell primero mirará
	  en <tt>/usr/local/bin</tt>; <tt>ls</tt> no está ahí, así que
	  intentará <tt>/usr/bin</tt>; cuando esto falle, comprobará
	  <tt>/bin</tt>.  Ahí descubrirá <tt>/bin/ls</tt>, detendrá la
	  búsqueda, y ejecutará el programa <tt>bin/ls</tt>.  Si
	  <tt>/usr/bin/X11/ls</tt> existiera (no existe, pero
	  imagínelo), sería ignorado.

	<p>Puede ver qué <tt>ls</tt> va a utilizar la shell con la
	  orden <tt>type</tt>.  <tt>type ls</tt> le dará la respuesta
	  <tt>/bin/ls</tt>.  Pruébelo usted mismo.

	<p>Pregunte dónde se encuentra el propio <tt>type</tt>:

<example>
$ type type
type is a shell builtin
</example>

	<p><tt>type</tt> no es en realidad un programa; es una función
	  provista por la shell.  Sin embargo, se utiliza 
	  exactamente igual que un programa externo.

	<footnote>Si está utilizando un derivado de la shell C, la
	  función interna equivalente a <tt>type</tt> es
	  <tt>which</tt>.</footnote>

	<p>Hay un cierto número de instrucciones como ésta; escriba
	  <tt>man builtins</tt> para leer la página de manual que los
	  describe.  En general, no necesita saber si una orden es
	  interna o un auténtico programa; sin embargo, las
	  instrucciones internas no aparecen en el resultado de
	  <tt>ps</tt> o <tt>top</tt> puesto que no son procesos
	  separados.  Son solamente parte de la shell.

    <sect id="custom_shell-aliases"> Alias y funciones de la shell

	<p>Si usted utiliza con frecuencia la misma orden, puede
	  cansarse de teclearla. <tt>bash</tt> le permite escribir
	  <em>alias</em> más breves para sus instrucciones.  También
	  puede escribir <em>funciones de la shell</em>, que son
	  instrucciones personalizadas compuestas de otras varias
	  órdenes.

	<p>Supongamos que usted siempre utiliza las opciones
	  <tt>--almost-all</tt> y <tt>--color=auto</tt> con
	  <tt>ls</tt>.  Rápidamente se cansaré de escribir <tt>ls
	  --almost-all --color=auto</tt>.  Así que hace un alias:

	<p>

<example>
alias mils='ls --almost-all --color=auto'   
</example>

	<p>Ahora puede escribir <tt>mils</tt> en lugar de la orden
	  completa.  Para ver lo que es realmente <tt>mils</tt>,
	  ejecute la instrucción <tt>type mils</tt>.  Para ver una
	  lista de los alias que ha definido, escriba simplemente
	  <tt>alias</tt> en una línea independiente.

	<p>Las funciones de la shell son un poco más flexibles que los
	  alias.  Un alias se limita a sustituir una orden más larga
	  cuando usted teclea una corta.  Las funciones le permiten
	  utilizar series de órdenes para realizar alguna acción.

	<p>Veamos primero cómo podría usarse una función de la shell
	  en lugar del alias de arriba:

<example>
mils() {
    ls --almost-all --color=auto $*
}
</example>

	<p>Lo anterior se denomina <em>definición de función</em>,
	  porque da un nombre de función (<tt>mils</tt>), y después
	  define el significado del nombre (algunas órdenes que deben
	  ejecutarse).  Para definir una función, escriba su nombre,
	  seguido de <tt>()</tt>.  Después incluya las instrucciónes
	  que hay que ejecutar entre llaves (<tt>{}</tt>).  La parte
	  dentro de las llaves se conoce como el <tt>cuerpo</tt> de la
	  función.

	<p>Los argumentos de la función pueden designarse como
	  <tt>$*</tt>.  Así que si escribe:

<example>
mils /usr  /etc
</example>

	  <tt>$*</tt> será <tt>/usr /etc</tt>, los dos argumentos.  Si
	  no hay argumentos, <tt>$*</tt> estará vacío.

	<p>También puede designarse a los argumentos mediante un
	  número.  Así que <tt>$1</tt> en el cuerpo de la función
	  será reemplazado por <tt>/usr</tt>, y <tt>$2</tt> será
	  reemplazado por <tt>/etc</tt>.  Escriba esta función (puede
	  hacerlo en el prompt de la shell; apriete Intro después de
	  cada línea):

	<p>

<example>
imprime_argumentos() {
    echo "Primer argumento:          $1"
    echo "Segundo argumento:         $2"
    echo "Todos los argumentos:      $*"
}
</example>

	<p>Puede verificar si ha introducido la definición de función
	  correctamente con la orden <tt>type</tt>; <tt>type
	  imprime_argumentos</tt> debería devolver:


<example>
imprime_argumentos es una función
imprime_argumentos() {
    echo "Primer argumento:   $1"
    echo "Segundo argumento:  $2"
    echo "Todos los argumentos:    $*"
}
</example>

	<p>Prueba la función.  Si introduce <tt>imprime_argumentos uno
	  dos</tt> mostrará:

<example>
Primer argumento:       uno
Segundo argumento:      dos
Todos los argumentos:   uno dos
</example>

	<p>Hay cosas más complejas que usted puede hacer en una
	  función de la shell; sólo está limitado por su imaginación.
	  Para más información, vea <ref id="advanced-scripting">.

    <sect id="shell-io"> Controlar la entrada y salida

	  <footnote>(N. del T.: el presente capítulo se refiere a
	  operaciones de entrada y salida de datos.  En español, suele
	  abreviarse como "E/S".  En inglés, se trata de operaciones
	  "input/output", abreviadamente, "I/O".)</footnote>

	<p>Stdin, stdout, tuberías, y redirección

	  <footnote>(N. del T.: "stdin" = "standard input", "stdout" =
	  "standard output", "stderr" = "standard error".)</footnote>

	<p>Cada proceso tiene al menos tres conexiones con el mundo
	  exterior.  La <em>entrada estándar</em> es la fuente de
	  datos del proceso; la <em>salida estándar</em> el es lugar
	  al que el proceso envía los datos; y el <em>error
	  estándar</em> es un lugar al que el proceso puede enviar
	  mensajes de error.  (Con frecuencia se abrevian en
	  <tt>stdin</tt>, <tt>stdout</tt>, y <tt>stderr</tt>.)

	<p>Las palabras `fuente' y `lugar' son deliberadamente vagas.
	  El usuario puede cambiar estas localizaciones de entrada y
	  salida estándar; podrían serlo la pantalla, el teclado, un
	  fichero, incluso una conexión de red.  El usuario puede
	  especificar la localización que ha de utilizarse.

	<p>Cuando usted ejecuta un programa desde la shell, usualmente
	  la entrada estándar procede de su teclado y la salida
	  estándar y el error estándar van a la pantalla.  Sin
	  embargo, puede pedirle a la shell que cambie estos valores
	  por defecto.

	<p>Por ejemplo, la orden <tt>echo</tt> envía su salida a la
	  salida estándar, normalmente la pantalla.  Pero usted puede
	  enviarla en su lugar a un archivo, con el <em>operador de
	  redirección de salida</em>, '<tt>&gt;</tt>'.  Por ejemplo,
	  para poner la palabra "Hola" en el archivo
	  <tt>miarchivo</tt>:

<example>
echo Hola &gt; miarchivo
</example>


	<p>Utilice <tt>cat</tt> en su paginador de ficheros de texto
	  (<tt>more</tt> o <tt>less</tt>) para ver el contenido de
	  <tt>miarchivo</tt>.

	<p>Puede cambiar la entrada estándar de un programa con el
	  <em>operador de redirección de entrada</em>,
	  '<tt>&lt;</tt>'.  Por ejemplo, <tt>more &lt; miarchivo</tt>
	  mostrará el contenido de <tt>miarchivo</tt>.  Esto, en la
	  práctica, no resulta útil; por comodidad, la orden
	  <tt>more</tt> acepta como argumento un nombre de fichero.
	  Así que usted puede limitarse a decir <tt>more
	  miarchivo</tt> y el efecto será el mismo.

	<p>En cuanto a su funcionamiento interno, <tt>more &lt;
	  miarchivo</tt> significa que la shell abre
	  <tt>miarchivo</tt>, después envía su contenido a la entrada
	  estándar de <tt>more</tt>.  <tt>more miarchivo</tt>, sin el
	  operador de redirección, significa que la orden
	  <tt>more</tt> recibe un argumento, <tt>miarchivo</tt>, abre
	  el archivo mismo, y después lo muestra.

	<p>Existe una razón para la doble funcionalidad, no obstante.
	  Por ejemplo, usted puede conectar la salida estándar de una
	  instrucción a la entrada estándar de otra.  Esto se llama
	  <em>tubería</em>, y utiliza el <em>operador de tubería</em>,
	  '<tt>|</tt>'.

	<p>Tal vez quiera ver la Licencia Pública General de GNU al
	  revés.  Para hacerlo, se utiliza la orden <tt>tac</tt> (es
	  <tt>cat</tt>, sólo que al revés).  Inténtelo:

<example>
tac /usr/doc/copyright/GPL
</example>

	<p>Desafortunadamente, pasa demasiado rápido como para leerla,
	  así que solamente puede ver un par de párrafos.  La solución
	  está en una tubería:

<example>
tac /usr/doc/copyright/GPL | more
</example>

	<p>Esto toma la salida estándar de <tt>tac</tt>, que es la LGP
	  al revés, y la envía a la entrada estándar de <tt>more</tt>.

	<p>Puede encadenar tantas instrucciones como quiera.  Pongamos
	  que tiene un inexplicable deseo de reemplazar cada
	  <tt>G</tt> por una <tt>Q</tt>; para esto se utiliza la orden
	  <tt>G Q</tt>, de este modo:

<example>
tac /usr/doc/copyright/GPL | tr G Q | more
</example>

	<p>Podría obtener el mismo efecto empleando archivos
	  temporales y la redirección.  Por ejemplo:

<example>
tac /usr/doc/copyright/GPL > tmpfile
tr G Q < tmpfile > tmpfile2
more < tmpfile2
rm tmpfile tmpfile2
</example>

	<p>Es evidente que una tubería es más cómoda.

     <sect id="shell-wildcards"> Expansión de nombres de ficheros
       ("Comodines")

	<p>Con frecuencia querrá que una orden funcione con un grupo
	  de ficheros.  Los "comodines" se utilizan para crear una
	  <em>pauta de expansión de nombres de ficheros</em>: una
	  serie de caracteres y comodines que se expande para formar
	  una lista de nombres de archivo.  Por ejemplo, la pauta
	  <tt>/etc/*</tt> se expande para convertirse en una lista de
	  todos los archivos en <tt>/etc</tt>

	  <footnote>En realidad, los archivos que comienzan con un
	    punto (.) no se incluyen en la expansión de
	    <tt>*</tt>.</footnote>.

	<p><tt>*</tt> es un comodín, que puede referirse a cualquier
	  serie de caracteres, de modo que la pauta <tt>/etc/*</tt> se
	  expandirá para formar una lista con todos los nombres de
	  archivos que empiecen con <tt>/etc/</tt>.

	<p>Esta lista de nombres de archivo es útil principalmente
	  como conjunto de argumentos para una instrucción.  Por
	  ejemplo, el directorio <tt>/etc</tt> contiene una serie de
	  subdirectorios llamados <tt>rc0.d</tt>, <tt>rc1.d</tt>, etc.
	  Normalmente, para ver sus contenidos, tendría que
	  introducir:

<example>
ls /etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d /etc/rc5.d /etc/rc6.d /etc/rcS.d
</example>

	<p>Esto es tedioso.  En su lugar, puede utilizar el comodín
	<tt>?</tt>:

<example>
ls /etc/rc?.d
</example>

	<p><tt>/etc/rc?.d</tt> se expande para formar una lista con
	  los nombres de archivo que comiencen con <tt>rc</tt>,
	  seguidos de un sólo carácter (cualquiera), seguido de
	  <tt>.d</tt>.

	<p>Los comodines disponibles son:

	  <taglist>

	    <tag><tt>*</tt><item>Equivale a cualquier grupo de 0 o más
	      caracteres

	    <tag><tt>?</tt><item>Equivale exactamenta a un carácter

	    <tag><tt>[...]</tt><item>Si encierra algunos caracteres
	      entre corchetes, el resultado es un comodín que equivale
	      a esos caracteres.  Por ejemplo, <tt>[abc]</tt> equivale
	      bien a a, o a b, o a c.  Si añade un <tt>^</tt> tras el
	      primer corchete, el sentido se invierte; de modo que
	      <tt>[^abc]</tt> equivale a cualquier carácter que no sea
	      ni a, ni b, ni c.  Puede incluir un intervalo, como
	      <tt>[a-j]</tt>, lo que equivale a cualquier cosa entre
	      la a y la j.  La equivalencia tiene en cuenta las
	      mayúsculas, de modo que para permitir cualquier letra,
	      debe utilizar <tt>[a-zA-Z]</tt>.

	  </taglist>

	<p>Las pautas de expansión son simples, una vez que se han
	  visto algunos ejemplos concretos:

	  <taglist>

	    <tag><tt>*.txt</tt><item>Esto le dará una lista de
	      cualquier nombre de fichero que termine en
	      <tt>.txt</tt>, puesto que <tt>*</tt> equivale a
	      cualquier cosa en absoluto.

	    <tag><tt>*.[hc]</tt><item>Esto dará una lista de nombres
	      de fichero que terminen en <tt>.h</tt> o en <tt>.c</tt>.

	    <tag><tt>??</tt><item>Esto le proporcionará todos los
	      nombres de archivo de tres letras que comiencen con
	      <tt>a</tt>.

	    <tag><tt>[^a]??</tt><item>Esto le dará todos los nombres
	      de archivo de tres letras que <em>no</em> comiencen con
	      <tt>a</tt>.

	    <tag><tt>a*</tt><item>Esto le dará todos los nombres de
	      archivo que comiencen con <tt>a</tt>, sin importar de
	      cuántas letras consten.

	  </taglist>


<!-- FIXME XXX
<sect id="shell-quoting"> Citar
<p>Cuándo citar y por qué
-->

    <sect> Shell interactiva/no-interactiva  <!-- FIXME mover esto -->

	<p>Bash tiene dos modos diferentes: <em>interactivo</em> y
	  <em>no-interactivo</em>.  Interactivo significa que puede
	  escribir en ella, y hacer que haga cosas para usted.  Las
	  shells no-interactivas interpretan guiones de shell,
	  similares a los archivos de procesamiento por lotes de DOS.
	  Le da una lista de órdenes que tiene que cumplir, y va y las
	  realiza, pero sin su intervención.  Usted no ve cómo se
	  escriben las instrucciones.  Por supuesto, cualquier salida
	  será registrada en alguna parte (la salida estándar, o
	  stdout, normalmente la pantalla o un archivo de registro).
	  Un poco más tarde trataremos más a fondo las shells no
	  interactivas.

     <sect1 id="interactive-shells">Shells interactivas

	<p>Dominar las shells interactivas lleva mucho tiempo,
	  simplemente porque tan poderosas que... ¡probablemente nunca
	  lo aprenda todo!  Es sólo que hay tanto que una shell puede
	  hacer, y por supuesto, siempre están cambiando.  Aquí
	  hablaremos sobre <tt>bash</tt>, y algunas órdenes básicas
	  que harán su vida con la shell más fácil.  En bash, uno
	  puede tener varias actividades desarrollándose a la vez, y
	  esto puede volverse confuso.

	<p>Una shell está orientada al texto, es un entorno de línea
	  de instrucciones.  La shell siempre le presentará un prompt
	  cuando esté esperando que usted haga cosas.  El prompt por
	  defecto de Debian es un signo $.

	<p>Es en el prompt $ donde puede introducir órdenes para
	  decirle a Linux que haga cosas, que pueden ser el nombre de
	  un programa, o bien un comando interno que la shell
	  proporciona para su comodidad.

<!-- FIXME
<sect1 id="non-interactive-shells">Shells no-interactivas
-->

   <chapt id="files"> <heading> Más sobre ficheros </heading>

	<p>En <ref id="basics-files"> nos ocupamos de de
	  mover/renombrar ficheros con <tt>mv</tt>, copiarlos con
	  <tt>cp</tt>, borrarlos con <tt>rm</tt>, borrar directorios
	  con <tt>rmdir</tt>, y crear directorios con <tt>mkdir</tt>.
	  Este capítulo cubrirá algunos aspectos más sobre los
	  archivos.

     <sect id="files-permissions"> Permisos

	<p> Los sistemas GNU y Unix están configurados para permitir a
	  mucha gente utilizar la misma computadora, manteniendo
	  reservados algunos ficheros o evitando que algunas personas
	  puedan modificar ciertos archivos.  Puede verificarlo por sí
	  mismo:

	<enumlist>

	  <item> Ingrese como usted mismo, esto es, <em>NO</em> como
	    root.

	  <item> <tt>whoami</tt> <p> Compruebe que no es root.

	  <item> <tt>rm /etc/resolv.conf</tt> <p> Debería obtener un
	    "Permiso denegado".  <tt>/etc/resolv.conf</tt> es un
	    archivo esencial de configuración del sistema; usted no
	    está autorizado para alterarlo o borrarlo a menos que sea
	    root.  Esto evita que accidentalmente estropear el
	    sistema, y si la computadora es pública, como en una
	    oficina o escuela, evita que los usuarios dañen el sistema
	    a propósito.

	</enumlist>

	<p>Ahora escriba <tt>ls -l /etc/resolv.conf</tt> <p>Le
	  devolverá una salida que se asemeja a algo como esto:

	<p>

<example>
-rw-r--r-- 1 root root 119 Feb 23 1997 /etc/resolv.conf
</example>

	<p>La opción <tt>-l</tt> de <tt>ls</tt> solicita toda esa
	  información adicional.  La información a la derecha es
	  fácil: el tamaño del archivo es <tt>119</tt> bytes, la fecha
	  en que el archivo cambió por última vez es <tt>Feb 23
	  1997</tt>, el nombre del fichero es
	  <tt>/etc/resolv.conf</tt>.  En el lado izquierdo de la
	  pantalla las cosas son un poco más complicadas.

	<p>Primero la explicación técnica, más breve: el
	  <tt>-rw-r--r--</tt> es el <tt>modo</tt> del archivo, el
	  <tt>1</tt> es el número de enlaces duros para este fichero
	  (o el número de archivos en un directorio), y los dos
	  <tt>root</tt> son el usuario y el grupo que poseen este
	  archivo.

	<p>Eso ha sido bastante críptico.  Volvamos despacio sobre
	  ello (excepto para la parte de los enlaces duros: para eso
	  vea <ref id="advanced-files-hardlinks">).

     <sect1 id="files-permissions-groups"> Propiedad de los ficheros

	<p>Cada fichero tiene dos propietarios: un usuario, y un
	  grupo.  El caso de arriba es un poco confuso, puesto que hay
	  un grupo llamado <tt>root</tt> además del usuario
	  <tt>root</tt>.  Los grupos son simplemente conjuntos de
	  usuarios a los que se permite colectivamente el acceso a una
	  parte del sistema.  Un buen ejemplo es el grupo
	  <tt>games</tt>

	  <footnote>(N. del T.: "games", juegos.)</footnote>.

	  Por el gusto de ser mezquino, puede configurar su sistema de
	  modo que sólo las personas en un grupo <tt>games</tt> estén
	  autorizadas para jugar.

	<p>Un ejemplo más práctico: digamos que está usted
	  configurando una computadora para un colegio.  Puede querer
	  que a ciertos archivos sólo puedan acceder los profesores,
	  no los estudiantes, de modo que pone a todos los profesores
	  en un único grupo.  Después puede decirle al sistema que
	  ciertos ficheros pertenecen a los miembros del grupo
	  <tt>profesores</tt>, y que nadie más puede acceder a ellos.

	<p>Aquí hay algunas cosas que puede hacer para explorar los
	  grupos de su sistema:

	<enumlist>

	  <item> <tt>groups</tt> <p> Escribir esta orden en el prompt
	    de la shell le dirá de qué grupos es usted miembro.  Es
	    probable que sea miembro de un único grupo, con el mismo
	    nombre que su nombre de usuario.

	  <item> <tt>more /etc/group</tt> <p> Este archivo lista los
	    grupos que existen en su sistema.  Fíjese en el grupo
	    <tt>root</tt> (el único miembro de este grupo es el
	    usuario root), y en el grupo que se corresponde con su
	    nombre de usuario.  Hay también grupos como
	    <tt>dialout</tt> (usuarios que están autorizados a marcar
	    con el módem), y <tt>floppy</tt> (usuarios que pueden
	    utilizar la disquetera).  Sin embargo, probablemente su
	    sistema no está configurado para hacer uso de esos grupos;
	    es probable que sólo root pueda usar la disquetera o el
	    módem ahora mismo.  Para más detalles sobre este fichero,
	    pruebe a leer <tt>man group</tt>.

	  <item> <tt>ls -l /home</tt> <p> Observe cómo el directorio
	    principal de cada usuario pertenece a ese usuario y al
	    grupo personal de ese usuario.  (Si acaba de instalar la
	    Debian, puede que usted sea el único usuario).

	</enumlist>

    </sect1>

    <sect1 id="files-permissions-mode"> Modo

	<p>Además de pertenecer a un usurio y un grupo, cada archivo y
	  directorio tienen también un modo, que determina quién está
	  autorizado a leerlo, escribir en él, y ejecutarlo.  El modo
	  también determina algunas otras cosas, pero son temas
	  avanzados, de modo que los saltaremos por ahora.

	<p>En la salida de <tt>ls</tt> el modo tiene este aspecto:
	  <tt>-rw-r--r--</tt>.  Hay diez "elementos" aquí, y el modo
	  consiste en realidad en doce bits (piense en los bits como
	  en interruptores que pueden estar encendidos o apagados).
	  Pero por ahora, nosotros consideraremos sólo nueve de esos
	  bits: aquellos que controlan los permisos de
	  <em>lectura</em>, <em>escritura</em> y <em>ejecución</em>
	  para el <em>usuario</em> propietario del archivo, el
	  <em>grupo</em> propietario, y los <em>demás</em> (cualquier
	  otro en el sistema, denominado a veces el <em>mundo</em>

	  <footnote>(N. del T.: todo lo relacionado con los permisos
	    depende profundamente del inglés.  Fíjese y
	    recuerde las letras resaltadas en cada palabra: lectura ->
	    "Read", escritura -> "Write", ejecución -> "eXecution",
	    usuario -> "User", grupo -> "Group", los demás ->
	    "Others".)</footnote>.

	<p>Fíjese en que las tres clases de permisos (lectura,
	  escritura y ejecución) se multiplican por los tres grupos de
	  personas que pueden tener permiso (usuario, grupo y otros),
	  lo que da un total de nueve elementos.

	<p>En la línea de modo, el primer "elemento" informa del tipo
	  de fichero.  En este caso, el <tt>-</tt> significa que es un
	  archivo normal.  Si fuera <tt>d</tt>, estaríamos ante un
	  directorio.  Hay otras posibilidades demasiado complejas
	  como para que nos adentremos ahora en ellas (vea <ref
	  id="advanced-file-permissions">).

	<p>Los nueve "elementos" restantes se utilizan para mostrar
	  los 12 bits que forman el modo del fichero.  Los 9 bits
	  básicos (lectura, escritura y ejecución para el usuario, el
	  grupo y los demás) aparecen como tres bloques de
	  <tt>rwx</tt>.

	<p>De modo que si todos los permisos estuvieran activados y se
	  tratara de un archivo normal, el modo sería algo como esto:
	  <tt>-rwxrwxrwx</tt>.  Si fuera un directorio con todos los
	  permisos retirados para los demás y permisos completos para
	  el usuario y el grupo, sería <tt>drwxrwx---</tt>.

	<p>Los tres bits que restan se representan mediante el cambio
	  de <tt>x</tt> por <tt>s</tt>, <tt>t</tt>, <tt>S</tt> o
	  <tt>T</tt>, pero es un asunto complejo que estamos
	  reservando para <ref id="advanced-files-permissions">.)

	<p>Para los archivos normales, "lectura", "escritura" y
	  "ejecución" tienen los siguientes significados.

	<list>

	  <item> El permiso de lectura, indicado por <tt>r</tt>, da
	    permiso para examinar el contenido de un fichero.  Para
	    los directorios, da permiso para listar el contenido del
	    directorio.

	  <item> El permiso de escritura, indicado por <tt>w</tt>, da
	    permiso para modificar el archivo.  Para los directorios,
	    da permiso para crear y borrar ficheros en el directorio.

	  <item> El permiso de ejecución, indicado por <tt>x</tt>, da
	    permiso para iniciar el archivo como una instrucción.  Es
	    evidente que sólo tiene sentido establecer el permiso de
	    ejecución si el archivo es de verdad una orden.

	  <p>Puesto que los directorios nunca pueden ser ejecutados,
	    el bit de ejecución tiene para ellos un significado
	    diferente.  Para los directorios, el bit de ejecución
	    significa el permiso para acceder a archivos en el
	    directorio.  Dése cuenta de que esto interactúa con los
	    permisos de escritura: los permisos de ejecución tienen
	    que estar activados para permitir acceder <em>de cualquier
	    modo</em> a los archivos en un directorio, de modo que sin
	    permiso de ejecución en un directorio, el permiso de
	    escritura es inútil.  El permiso de ejecución en los
	    directorios se denomina con frecuencia permiso de
	    "búsqueda", puesto que en realidad no tiene nada que ver
	    con la ejecución. Permiso de "acceso a ficheros" sería
	    probablemente un nombre aún mejor.

	</list>

	<p>Los modos de los directorios son un poco desconcertantes,
	  así que aquí hay algunos ejemplos de los efectos de diversas
	  combinaciones:

	<list>

	  <item> <tt>r--</tt> <p> El usuario, grupo u otros con estos
	    permisos pueden listar el contenido de un directorio, pero
	    nada más.  No se puede leer, modificar, borrar o manipular
	    los archivos en el directorio de ninguna manera.  La única
	    acción permitida es la de leer el directorio mismo, esto
	    es, ver qué archivos contiene.

	  <item> <tt>rw-</tt> <p> El permiso de escritura no tiene
	    efecto alguno en ausencia del permiso de ejecución, de
	    forma que este modo se comporta como el anteriormente
	    descrito.

	  <item> <tt>r-x</tt> <p> Este modo permite listar los
	    ficheros en un directorio, y permite acceder a ellos.  Sin
	    embargo, no pueden crearse o borrarse
	    archivos. <em>Acceder</em> significa que puede ver,
	    modificar, o ejecutar los archivos en función de lo que
	    autoricen los propios permisos de los ficheros.

	  <item> <tt>--x</tt> <p> Se puede acceder a los archivos en
	    este directorio, pero no se pueden listar los contenidos
	    del mismo, de modo que tiene que conocer previamente el
	    nombre del fichero (a no ser que sea un buen adivinador).
	    No pueden crearse o borrarse archivos.

	  <item> <tt>rwx</tt> <p> Usted puede hacer lo que quiera con
	    los archivos de este directorio, siempre que se lo
	    permitan los permisos de los propios ficheros.

	</list>

	<p>El permiso de escritura de los directorios determina si se
	  pueden borrar los ficheros en su interior: un fichero de
	  sólo lectura puede borrarse, si se tiene permiso de
	  escritura en el directorio que lo contiene.  No se puede
	  borrar un archivo de un directorio de sólo lectura, incluso
	  si se está autorizado para introducir cambios en él.  Los
	  permisos de los archivos no tienen nada que ver con la
	  acción de borrarlos.

	<p>Esto significa también que si se posee un directorio
	  siempre se pueden borrar los archivos en su interior,
	  incluso si estos archivos pertenecen a root.

	<p>Los permisos de ejecución de directorios determinan si se
	  tiene acceso a los archivos; y por tanto si los permisos de
	  los archivos se ponen en juego.  <em>Si</em> se tiene
	  permiso de ejecución en un directorio, los permisos de los
	  archivos en ese directorio se vuelven relevantes.  En caso
	  contrario los permisos de archivo simplemente no importan;
	  no se puede acceder a los archivos en ningún caso.

	<p>Si se tiene permiso de ejecución en el directorio, los
	  permisos de los archivos determinan si puede leer el
	  contenido de un archivo, modificarlo, y/o ejecutarlo si el
	  archivo es una orden.

	<p>Para terminar, los permisos de un archivo o directorio no
	  afectan al permiso para cambiar los permisos de ese archivo
	  o directorio.  Sin embargo, siempre se pueden cambiar los
	  permisos de los archivos o directorios que uno posee (pero
	  no de los ficheros que pertenecen a alguien más), si que se
	  esté autorizado para acceder al archivo.  Así que si se
	  puede acceder a un archivo que se posee por completo (esto
	  es, si se tiene permiso de ejecución en el directorio que lo
	  contiene) entonces se pueden cambiar sus permisos.

	<p>Esto significa que uno no puede quitarse de modo permanente
	  los permisos a sí mismo, porque siempre puede devolvérselos.
	  Supogamos que usted se quita el permiso de escritura de un
	  archivo que posee, y después intenta modificar el archivo.
	  No le estará permitido, pero siempre podrá darse a sí mismo
	  permiso de escritura de nuevo y <em>entonces</em> modificar
	  el archivo.  La única forma de perder la capacidad de
	  cambiar de nuevo los permisos es perder por completo acceso
	  al archivo.

    </sect1>

    <sect1 id="files-permissions-tutorial"> Los permisos en la práctica

	<p>Esta sección desarrolla una breve sesión de ejemplo para
	  mostrar cómo se utilizan los permisos.

	<p>Para cambiar los permisos, utilizamos la orden
	  <tt>chmod</tt>

	  <footnote>(N. del T.: "chmod", de "CHange MODe", cambiar el
	    modo.)</footnote>.

	<enumlist>

	  <item> <tt>cd; touch miarchivo</tt> <p> Aquí hay un par de
	    trucos nuevos.  Primero, puede utilizar <tt>;</tt> para
	    poner dos órdenes en una línea.  Puede escribir lo anterior
	    como:
<p>
<example>
&dollar cd 
&dollar touch miarchivo
</example>
<p>
	    o como:
<p>
<example>
&dollar cd; touch miarchivo
</example>

	  <p>y al final sucederá lo mismo.

	  <p>Recuerde que, por sí mismo, <tt>cd</tt> le devolverá a su
	    directorio principal de usuario.  <tt>touch</tt> se
	    utiliza normalmente para cambiar la fecha de modificación
	    de un archivo al momento actual, pero tiene otra
	    característica interesante: si el archivo no existe,
	    <tt>touch</tt> lo crea.  Así que lo estamos utilizando
	    para crear un fichero con el que practicar.  Utilice
	    <tt>ls -l</tt> para confirmar que se ha creado el archivo,
	    y fíjese en el modo de sus permisos:

<p>
<example>
&dollar ls -l 
-rw-r--r-- 1 havoc havoc 0 Nov 18 22:04 miarchivo
</example>

	  <p>Evidentemente el tiempo y los nombres de usuario y de
	    grupo serán diferentes cuando usted lo intente.  El tamaño
	    del archivo es 0, puesto que <tt>touch</tt> crea un
	    fichero vacío.  <tt>-rw-r--r--</tt> es el modo por defecto
	    de los permisos en Debian

<!-- FIXME (usted puede cambiar esto: vea FIXME: añadir una referencia -->
<!-- a umask) -->

	  .

	<item> <tt>chmod u+x miarchivo</tt> <p> Esta orden significa
	  añadir (<tt>+</tt>) permisos de ejecución (<tt>x</tt>) para
	  el usuario (<tt>u</tt>) propietario del archivo.  Utilice
	  <tt>ls -l</tt> para ver los efectos.

	<item> <tt>chmod go-r miarchivo</tt> <p> Aquí hemos sustraído
	  el permiso de lectura (<tt>r</tt>) del grupo (<tt>g</tt>) al
	  que pertenece el archivo, y de todos los demás (otros,
	  <tt>o</tt>).  De nuevo, utilice <tt>ls -l</tt> para
	  verificar los efectos.

	<item> <tt>chmod ugo=rx miarchivo</tt> <p> Aquí hemos
	  determinado (<tt>=</tt>) que los permisos del usuario, el
	  grupo y los otros serán de lectura y ejecución.  Esta opción
	  establece que los permisos sean <em>exactamente</em> los
	  especificados, y elimina cualesquiera otros.  De modo que
	  deberían estar activados todos los <tt>rx</tt> y no estarlo
	  todos los <tt>w</tt>.  Ahora, nadie puede escribir en el
	  fichero.

	<item><tt>chmod a-x miarchivo</tt> <p> <tt>a</tt> es un atajo
	  para <tt>ugo</tt>, derivado de "all"

	  <footnote>(N. del T.: "all" significa "todos".)</footnote>.

	  De modo que todos los permisos <tt>x</tt> deberían estar
	  ahora desactivados.

	<item> <tt>rm miarchivo</tt> <p> Estamos borrando el fichero,
	  pero sin permiso de escritura.  <tt>rm</tt> le preguntará si
	  está seguro:

<example>
rm: ¿borrar el fichero protegido contra escritura `miarchivo'? (s/n)
</example>

	  Debería responder a esto apretando la <tt>s</tt> y después
	  Intro.  Esta es una característica de <tt>rm</tt>, no una
	  cuestión de permisos: el permiso para borrar un archivo
	  procede de los permisos del directorio, y usted tiene
	  permiso de escritura en el directorio.  Sin embargo,
	  <tt>rm</tt> intenta ayudar, figurándose que si no quería
	  modificar el fichero (y por eso retiró el permiso de
	  escritura), no quiere tampoco borrarlo, y por tanto
	  pregunta.

	</enumlist>

<!-- ARREGLAR
Tenemos un problema: el rm traducido al español no habla de códigos
numéricos.
-->

	<p>En ocasiones, verá que las órdenes relacionadas con los
	  permisos aparecen en la forma siguiente:

<example>
chmod 0444 miarchivo
</example>

	  ¿Qué significa ese <tt>0444</tt> que siggue a
	  <tt>chmod</tt>?  El modo de los permisos es un número
	  binario de doce dígitos, como este: <tt>000100100100</tt>.
	  <tt>0444</tt> es este número binario representado como
	  número octal (base 8), lo que constituye la forma
	  convencional de escribir un modo.  De forma que puede
	  escribir <tt>chmod 444 miarchivo</tt> en lugar de <tt>chmod
	  ugo=r miarchivo</tt>.  Esta cuestión se explica por completo
	  en <ref id="advanced-files-permissions">.

    </sect1>

    <sect id="files-tour"> ¿Qué archivos se encuentran en mi sistema?
      ¿Dónde puedo poner mis propios archivos?

	<p>Ahora que ya puede navegar por el árbol de directorios,
	  vamos a iniciar una visita guiada de los archivos y
	  directorios que creó Debian al instalarse.  Si es usted
	  curioso, haga <tt>cd</tt> a cada directorio y escriba
	  <tt>ls</tt> para ver su contenido.  Si el listado sobrepasa
	  el tamaño de la pantalla, intente <tt>ls | more</tt>, donde
	  <tt>|</tt> es el símbolo de la "tubería", generalmente
	  situado en la misma tecla que el `1'.

<!-- ARREGLAR : en los teclados españoles.  El original dice otra cosa -->

	<taglist>

	  <tag><tt>/</tt> <item> Como ya hemos mencionado, este es el
	    directorio raíz, que contiene a todos los demás
	    directorios.

	  <tag><tt>/root</tt> <item> ¡No confunda <tt>/</tt> con
	    <tt>/root</tt>!  <tt>/root</tt> es el directorio principal
	    de usuario del usuario root, o superusuario.  Es un
	    directorio llamado <tt>/root</tt>, pero no es el
	    directorio raíz

	    <footnote>(N. del T.: la confusión se produce en inglés,
	      donde "root" significa raíz y se utiliza indistintamente
	      para ambas expresiones.  En español, un medio sencillo
	      de evitar este inconveniente es hablar de "directorio
	      raíz" y "directorio del root".)</footnote>

	  <tag><tt>/home</tt> <item> Aquí es donde todos los usuarios
	    corrientes --- esto es, todos excepto root --- tienen sus
	    directorio principal de usuario.  Los directorios de
	    usuario reciben su denominación de acuerdo con el nombre
	    del usuario al que pertenecen, por ejemplo,
	    <tt>/home/juana</tt>.  Si está usted usando un sistema de
	    ciertas dimensiones en un colegio o empresa, el
	    administrador de su sistema puede crear directorios
	    adicionales para contener los directorios de usuario:
	    <tt>/home1</tt> y <tt>/home2</tt>, por ejemplo.  En
	    algunos otros sistemas, verá un nivel adicional de
	    subdirectorios:
	    <tt>/home/estudiantes/<var>nombredeusuario</var></tt>,
	    <tt>/home/personal/<var>nombredeusuario</var></tt>, etc...

	  <p>Su directorio principal de usuario es donde pondrá todo
	    su trabajo personal, correo electrónico y otros
	    documentos, y las preferencias personales de
	    configuración.  Es su hogar en el sistema.

	  <tag> <tt>/bin</tt> <item> Este directorio contiene
	    "binarios", archivos ejecutables esenciales para el
	    funcionamiento del sistema.  Ejemplos son la shell
	    (<tt>bash</tt>), y órdenes de ficheros como <tt>cp</tt>.

	  <tag> <tt>/sbin</tt> <item> Este directorio contiene
	    "binarios del sistema"

	  <footnote>(N. del T.: "sbin" procede de "System
	    BINaries".)</footnote>,

	    utilidades que el usuario root o el administrador del
	    sistema pueden querer utilizar, pero que probablemente
	    usted no necesitará en sus actividades cotidianas.

	  <tag> <tt>/usr</tt> <item> <tt>/usr</tt> contiene la mayoría
	    de los archivos en los que estará interesado.  Tiene
	    muchos subdirectorios: <tt>/usr/bin</tt> y
	    <tt>/usr/sbin</tt> son muy semejantes a <tt>/bin</tt> y
	    <tt>/sbin</tt>, con la excepción de que los directorios en
	    <tt>/usr</tt> no se consideran "esenciales para el
	    funcionamiento del sistema".

	  <p>Aunque no es esencial para que el ordenador funcione,
	    <tt>/usr</tt> contiene las aplicaciones que se utilizan
	    para el trabajo real.  También encontrará en <tt>/usr</tt>
	    los directorios <tt>/usr/man</tt>, <tt>/usr/info</tt> y
	    <tt>/usr/doc</tt>, que contienen las páginas de manual,
	    las páginas info, y otra documentación, respectivamente.
	    ¡Y no olvide <tt>/usr/games</tt>!

	  <tag> <tt>/usr/local</tt> <item> El sistema Debian no
	    instala nada en este directorio.  Debería utilizarlo si
	    quiere instalar software que compile usted mismo, o
	    cualquier software no contenido en un paquete Debian.
	    También puede instalar software en su directorio principal
	    de usuario, si va a ser el único que lo utilice

	  <footnote>(N. del T.: aunque pueda parecerlo al principio,
	    la existencia de este directorio no es un capricho, o una
	    mera cuestión de estética de Debian.  Su fin es muy
	    concreto: si mantiene aquí el software que no procede de
	    Debian, sabrá en todo momento qué programas puede
	    necesitar que no se encuentran en una distribución Debian.
	    De este modo, si por alguna razón se decide a reinstalar
	    el sistema, para actualizarlo por ejemplo, y mantiene
	    <tt>/usr/local</tt> en una partición separada, no perderá
	    en la reinstalación ninguna de sus
	    aplicaciones.</footnote>.

	  <tag> <tt>/etc</tt> <item> <tt>/etc</tt> contiene todos los
	    archivos de configuración del sistema.  Siempre que quiera
	    hacer un cambio que afecte a todos los usuarios de su
	    computadora --- como la forma de conexión a internet, o la
	    clase de tarjeta de vídeo de que dispone --- probablemente
	    tendrá que ingresar como root y cambiar un archivo en
	    <tt>/etc</tt>.

	  <tag> <tt>/tmp</tt> <item> Aquí encontrará los archivos
	    temporales, la mayor parte de los cuales los crea el
	    sistema.  Este directorio por lo general se borra de
	    manera periódica, o cada vez que reinicia el sistema.
	    Usted puede crear ficheros aquí si lo desea, pero debe ser
	    consciente de que pueden resultar borrados
	    automáticamente.

	  <tag> <tt>/var</tt> <item> <tt>/var</tt> contiene ficheros
	    "variables", que el sistema modifica de forma automática.
	    Por ejemplo, el correo entrante se almacena aquí.  El
	    sistema mantiene aquí un registro de sus actuaciones.
	    También hay cierto número de otros archivos generados
	    Automáticamente.  A usted le interesarán principalmente el
	    contenido de <tt>/var/log</tt>, donde puede encontrar los
	    mensajes de error y tratar de descubrir qué le pasa a su
	    sistema si algo va mal.

	</taglist>

	<p>Es evidente que hay muchos más directorios en el sistema,
	  demasiados para describirlos individualmente.

<!-- FIXME ¿incluir referencias a FHS? -->

	<p>A la hora de hacer modificaciones, usted normalmente se
	  limitará a su directorio principal de usuario y a
	  <tt>/etc</tt>.  En un sistema Debian, las ocasiones para
	  alterar cualquier otra cosa son escasas, porque todo lo
	  demás se instala automáticamente para usted.

	<p> <tt>/etc</tt> se utiliza para configurar el
	  <em>sistema</em> en su conjunto.  Usted utilizará su
	  directorio de ususario, un subdirectorio de <tt>/home</tt>,
	  para configurar sus propias preferencias y almacenar sus
	  archivos personales.  La idea es que para su actividad
	  cotidiana se limite a <tt>/home/nombredeusuario</tt>, de
	  modo que no haya forma de que pueda estropear nada.
	  Ocasionalmente ingresará como root para alterar algo en un
	  directorio que afecte al sistema, pero sólo cuando sea
	  absolutamente necesario.  Por supuesto, si está usted usando
	  Debian en un colegio o empresa y el administrador del
	  sistema es otra persona, no tendrá acceso de root y sólo le
	  será posible modificar su directorio personal.  Esto
	  limitará lo que puede hacer con el sistema.

    <sect id="file-manager"> Utilizando un gestor de ficheros

	<p>En vez de mover los archivos a mano, puede utilizar un
	  <em>gestor de ficheros</em>.  Si mueve muchos archivos un
	  gestor de ficheros puede hacer más eficiente su trabajo.
	  Hay gestores de ficheros basados en texto, como el Midnight
	  Commander de GNU

	  <footnote>(N. del T.: "comandante de
	    medianoche".)</footnote>

	  (escriba <prgn>mc</prgn>), y algunos para el Sistema X
	  Window (por ejemplo, <prgn>gmc</prgn> para la versión X
	  Window del Midnight Commander de GNU).

	<p>Describir cada uno de ellos queda fuera del ámbito de este
	  manual; pero querrá probarlos si la línea de instrucciones
	  no satisface sus necesidades.

    <chapt id="editor"> <heading> Crear y editar archivos de texto
      </heading>

     <sect id="editor-textfile"> ¿Qué es un archivo de texto?

	<p>Un <em>archivo de texto</em> es simplemente un archivo
	  normal que contiene texto legible para las personas.  Aparte
	  de esto, no hay nada especial en él.  La otra clase de
	  archivo, un archivo binario, está destinado a ser
	  interpretado por el ordenador.

	<p>Puede ver ambas clases de ficheros con el paginador
	  <prgn>less</prgn>, si lo tiene instalado (si no es así,
	  instálelo, es bastante útil).  Escriba <tt>less
	  /etc/profile</tt> para ver un ejemplo de un archivo de
	  texto; fíjese en que puede leer los caracteres, incluso si
	  su significado le resulta oscuro.  Escriba <tt>less
	  /bin/ls</tt> para ver un archivo binario; como puede ver, el
	  programa <tt>ls</tt> no está destinado a ser leído por las
	  personas.

	<p>La diferencia entre ambas clases de ficheros es solamente
	  cuestión de lo que contienen, al contrario de lo que sucede
	  en otros sistemas (como DOS o MacOS) que tratan los archivos
	  de distinto modo.

	<p>Los archivos de texto pueden contener guiones de la shell,
	  documentación, licencias, o cualquier otro texto
	  legible para las personas.

	<p>Dicho sea de paso, esto ilustra la diferencia entre
	  <em>código fuente</em> y <em>binarios ejecutables</em>.
	  <tt>/bin/ls</tt> es un binario ejecutable que usted puede
	  descargar de Debian, pero también puede descargar el archivo
	  de texto que le dice a la computadora cómo crear
	  <tt>/bin/ls</tt>.  Este fichero de texto es el código
	  fuente.  Comparar <tt>/bin/ls</tt> con <tt>/etc/profile</tt>
	  enseña lo importante que es el código fuente si alguien
	  quiere entender y modificar un programa.  El software libre
	  le proporciona a usted o sus asesores todo este código
	  fuente fundamental.

    <sect id="editor-editor"> Editores de texto

	<p>Un <em>editor de texto</em> es un programa utilizado para
	  crear y modificar el contenido de archivos de texto.  La
	  mayoría de los sistemas operativos tienen un editor de
	  texto; DOS tiene <prgn>edit</prgn>, Windows tiene
	  <prgn>Notepad</prgn>, MacOS tiene <prgn>SimpleText</prgn>.

	<p>Debian proporciona una asombrosa variedad de editores de
	  texto.  <prgn>vi</prgn> y <prgn>emacs</prgn> son los dos
	  clásicos, ambos probablemente los más potentes y más
	  ampliamente utilizados.  Tanto <prgn>vi</prgn> como
	  <prgn>emacs</prgn> son bastante complejos y requieren cierta
	  práctica, pero pueden hacer la edición de textos
	  extremadamente eficiente.  <prgn>emacs</prgn> funciona tanto
	  en terminal como en el Sistema X Window; <prgn>vi</prgn>
	  normalmente funciona en una terminal, pero la variante
	  <prgn>vim</prgn> tiene una opción <tt>-g</tt> que le permite
	  trabajar con X.

	<p>Editores más simples incluyen <prgn>nedit</prgn>,
	  <prgn>ae</prgn>, <prgn>jed</prgn>, y <prgn>xcoral</prgn>.
	  <prgn>nedit</prgn> y <prgn>xcoral</prgn> proporcionan
	  sencillas interfaces gráficas para el Sistema X Window. Hay
	  también diversas variantes de <prgn>vi</prgn>, y una de
	  Emacs llamada <prgn>XEmacs</prgn>.

	<p>Este manual no cubrirá el uso de ningún editor particular
	  en detalle, aunque presentaremos brevemente a
	  <prgn>vi</prgn>, puesto que es pequeño, rápido y está casi
	  siempre disponible, y necesitará usarlo en ocasiones sin
	  importar cuál sea su editor preferido.  Emacs proporciona
	  por sí mismo una excelente introducción interactiva; para
	  leerla, inicie Emacs con la orden <tt>emacs</tt> y presione
	  <tt>F1 t</tt>.  Emacs es una elección excelente para los
	  nuevos usuarios interesados en un editor de propósito
	  general o para programar.

   <sect id="editor-vi"> Crear y editar un archivo de texto con
     <prgn>vi</prgn>

	<p><prgn>vi</prgn> (pronunciado "uve i") es en realidad el
	  único editor incluido en casi cada sistema operativo al
	  estilo Unix, y Debian no es una excepción.  <prgn>vi</prgn>
	  se escribió originalmente en Berkeley, en la Universidad
	  de California.  El nombre del editor es una abreviatura de
	  "visual", y hace referencia al hecho de que <prgn>vi</prgn>
	  muestra de manera visual el archivo de texto; esto se
	  consideró en su tiempo un rasgo único, lo que le dará un
	  idea de lo viejo que es el programa.

	<p>Resulta un tanto duro acostumbrarse a <prgn>vi</prgn>, pero
	  dispone de muchas funciones potentes .  En general,
	  sugerimos que un nuevo usuario utilice Emacs para las tareas
	  cotidianas, como programar.  Sin embargo, <prgn>vi</prgn> es
	  a veces más cómodo o el único editor disponible; además es
	  un fichero mucho más pequeño para descargar.

	<p>La explicación que sigue sobre <prgn>vi</prgn> se 
	  aplica también a sus variantes, como <prgn>elvis</prgn> y
	  <prgn>vim</prgn>.

<!-- ARREGLAR : alguna de las funciones que se explican no son aplicables -->
<!-- a vim -->


      <sect1 id="editor-vi-creating">Crear un archivo

	<p>

	<enumlist>

	  <item><tt>vi fichprueba</tt>

	  <p>En su directorio de usuario, invoque a vi escribiendo
	    <tt>vi</tt>, seguido del nombre del archivo que desea
	    crear.  Verá una pantalla con una columna de tildes
	    (<tt>~</tt>) a lo largo de todo el lado izquierdo.
	    <prgn>vi</prgn> está ahora en modo de órdenes

	    <footnote>(N. del T.: es muy frecuente encontrar la
	      expresión "command mode" en libros de Unix y Linux
	      traducida como "modo comando".)</footnote>.

	    Cualquier cosa que teclee ahora será interpretada como una
	    orden, no como un contenido que deba añadirse al fichero.
	    Para introducir texto, debe teclear una orden.

	  <item><tt>i</tt> <p>Las dos instrucciones básicas para
	    introducir texto son <tt>i</tt>, que significa "inserta el
	    texto que estoy a punto de escribir a la izquierda del
	    cursor", y <tt>a</tt>, que significa "añade el texto que
	    estoy a punto de escribir la derecha del cursor".  Puesto
	    que usted se halla al principio de un fichero vacío,
	    cualquiera de ellas funcionará.  Nosotros hemos escogido arbitrariamente
	    <tt>i</tt>.

	  <item>Escriba un texto; aquí está una profunda afirmación
	    del filósofo Nicolás Maquiavelo, si no puede pensar en
	    una propia:

	  <p>

<example>
Dedíquese, pues, el príncipe a superar las dificultades
y a conservar su Estado.  Si logra con acierto su fin
se tendrán por honrosos los medios conducentes al mismo,
pues el vulgo se paga únicamente de exterioridades y se
deja seducir por el éxito.  Y como el vulgo es lo que
más abunda en las sociedades, los escasos espíritus
clarividentes que existen no exteriorizan lo que
vislumbran hasta que la inmensa legión de los torpes
no sabe ya a qué atenerse.
</example>

<!-- ARREGLAR : er... el original contiene un texto de un tal Charles -->
<!-- Sanders Peirce, que reza así:

<example>
And what, then, is belief? It is the demi-cadence 
which closes a musical phrase in the symphony of our 
intellectual life.  We have seen that it has just 
three properties: First, it is something that we are
aware of; second, it appeases the irritation of doubt; 
and, third, it involves the establishment in our 
nature of a rule of action, or, say for short, a 
habit.
</example>

-->

<!-- ¿Razones para sustituirlo?  Más entretenido el segundo :) -->


	  <p>Apriete <tt>RET</tt> después de cada línea, puesto que
	    <tt>vi</tt> no se desplazará a la línea siguiente de
	    manera automática; cuando termine de escribir, apriete la
	    tecla <tt>ESC</tt> para abandonar el modo de insertar o
	    añadir y volver al modo de instrucciones.

	  <item><tt>:wq</tt> <p> Si lo ha hecho todo correctamente,
	    cuando teclee esta orden, debería aparecer en la parte
	    inferior de su pantalla, bajo todos los caracteres
	    <tt>~</tt>.  Los <tt>:</tt> le dicen a <tt>vi</tt> que
	    está usted a punto de darle una serie de órdenes; la
	    <tt>w</tt> significa que grabe el fichero que acaba de
	    escribir --- en la mayoría de los nuevos programas esto se
	    denomina "guardar" --- y la <tt>q</tt> quiere decir
	    abandonar <tt>vi</tt>.  Así que usted debería estar de
	    vuelta frente al prompt de la shell

	    <footnote>(N. del T.: las denominaciones originales,
	      útiles para recordar las instrucciones, son, "write,
	      grabar; "save", guardar; "quit", abandonar.)</footnote>.

	  <item><tt>cat fichprueba</tt> <p> <tt>cat</tt> mostrará en
	  la pantalla el fichero que ha escrito.

	</enumlist>

	<p> No borre <tt>fichprueba</tt>, lo utilizaremos en la
	  siguiente sección.

	<p> Cuando utilice, <tt>vi</tt> recuerde siempre que apretar
	  <tt>ESC</tt> le devolverá al modo de órdenes.  Así que si se
	  siente confuso, apriete <tt>ESC</tt> un par de veces y
	  empiece de nuevo.

	<p> <prgn>vi</prgn> tiene una desagradable tendencia a pitar
	  siempre que usted hace algo que se supone que no tiene que
	  hacer, como teclear una orden desconocida; no se alarme por
	  ello.

    <sect1 id="editor-vi-editing"> Editar un archivo existente

	<p>Para usar <tt>vi</tt>, usted sólo precisa leer <ref
	  id="editor-vi-editing-movement"> y <ref
	  id="editor-vi-editing-deletion">.  Secciones posteriores
	  explican características avanzadas, pero no son
	  estrictamente necesarias, aunque harán su tarea más
	  eficiente y menos tediosa.

    <sect2 id="editor-vi-editing-movement"> Moverse por un fichero

	<p>Para moverse por un fichero, el <tt>vi</tt> de Debian le
	  permite utilizar las teclas de dirección (flechas).  No
	  obstante, también funcionan las teclas tradicionales; son
	  <tt>h</tt> para la izquierda, <tt>j</tt> para
	  descender, <tt>k</tt> para ascender, y <tt>l</tt> para
	  la derecha.  Se eligieron estas teclas debido a que son
	  adyacentes y se encuentran en la línea de partida del
	  teclado, y por lo tanto, son fáciles de utilizar.  En su
	  lugar, muchas personas utilizan las teclas de dirección,
	  puesto que son más fáciles de alcanzar con los dedos.

	<p>

	<enumlist>

	  <item><tt>vi fichprueba</tt><p> Abra el archivo que creó
	    antes con <prgn>vi</prgn>.  Debería ver el texto que
	    escribió.

	  <item>Muévase por el archivo con las teclas de dirección o
	    <tt>hjkl</tt>.  Si intenta moverse demasiado lejos en
	    cualquier dirección, <prgn>vi</prgn> pitará y rehusará
	    hacerlo; si quiere introducir texto allí, habrá de hacerlo
	    con una orden de insercion, como <tt>i</tt> o <tt>a</tt>.

	  <item><tt>:q</tt><p>Salga de <prgn>vi</prgn>.

	</enumlist>

     <sect2 id="editor-vi-editing-deletion"> Borrar texto

	<p>

	<enumlist>

	  <item><tt>vi fichprueba</tt> <p>Abra de nuevo su archivo de
	    prácticas.

	  <item><tt>dd</tt> <p> La orden <tt>dd</tt> borra una línea;
	    la línea superior ahora debería haber desaparecido.

	  <item><tt>x</tt> <p> <tt>x</tt> borra un único carácter; se
	    borrará la primera letra de la segunda línea.  BORR y Supr
	    no funcionan en <prgn>vi</prgn> por razones históricas

	    <footnote>El teclado de algunos terminales muy viejos (de
	      los 60) no tenía las teclas BORR o Supr.</footnote>.

	    Algunas variantes de <prgn>vi</prgn> le permitirán usar
	    BORR y Supr, como <prgn>vim</prgn>.

<!-- ARREGLAR : vi permite utilizar Supr -->

	  <item><tt>10x</tt> <p> Si escribe un número antes de una
	    orden, la orden se repetirá otras tantas veces.  Por
	    tanto, ésta borrará diez caracteres.

	  <item><tt>2dd</tt> <p> Puede también usar un número
	    con la orden <tt>dd</tt>, para borrar dos líneas.

	  <item><tt>:q</tt> <p> Ocasionará un error, puesto que ha
	    modificado el fichero pero aún no lo ha guardado.  Hay dos
	    formas de evitarlo; puede escribir <tt>:wq</tt>, con lo
	    que graba el archivo al salir, o puede salir sin grabar:

	  <item><tt>:q!</tt> <p>Con un signo de exclamación, informa a
	    <prgn>vi</prgn> de que usted lo dice en serio, y debería
	    salir incluso aunque no haya guardado el archivo.  Si
	    utiliza <tt>:q!</tt> lo que haya borrado no se guardará en
	    <tt>fichprueba</tt>; si utiliza <tt>:wq</tt>, si lo será.

	  <item><tt>cat fichprueba</tt> <p>De regreso en el prompt de
	  la shell, vea <tt>fichprueb</tt>.  Ahora debería ser más
	  corto, si utilizó <tt>:wq</tt>, o permanecer igual si usó
	  <tt>:q!</tt>.

	</enumlist>

	<p><tt>:q!</tt> es una excelente orden para recordar, porque
	  puede utilizarla para salir del lío si se encuentra
	  totalmente confundido y cree que ha arruinado el archivo que
	  estaba editando.  Limítese a apretar <tt>ESC</tt> unas
	  cuantas veces para asegurarse de que se encuentra en modo de
	  instrucciones y después escriba <tt>:q!</tt>.  Esto le
	  garantiza salir de <prgn>vi</prgn> sin causar daño.

	<p>Ahora sabe todo lo que necesita para hacer edición básica;
	  inserción, borrado, guardar y salir.  Las secciones
	  siguientes describen instrucciones útiles para hacer las
	  cosas más rápido; puede saltárselas todas si quiere.

    <sect2 id="editor-vi-editing-moremoving"> Movimiento avanzado

	<p>Hay muchas órdenes de movimiento, este es un breve resumen:

	<p>

	<taglist>

	  <tag><tt>w</tt> <item> Desplaza el cursor hasta el principio
	    de la siguiente palabra

	  <tag><tt>e</tt> <item> Desplaza el cursor hasta el final de
	    la siguiente palabra

	  <tag><tt>E</tt> <item> Desplaza el cursor hasta la última
	    letra de la siguiente palabra

	  <tag><tt>b</tt> <item> Desplaza el cursor hasta el principio
	    de la palabra anterior

	  <tag><tt>0</tt> (cero) <item> Desplaza el cursor hasta el
	    principio de la línea

	  <tag><tt>^</tt> <item> Desplaza el cursor hasta la primera
	    palabra de la línea actual

	  <tag><tt>$</tt> <item> Desplaza el cursor hasta el final de
	    la línea

	  <tag><tt>-</tt> <item> Desplaza el cursor hasta el principio
	    de la línea anterior

	  <tag><tt>G</tt> <item> Desplaza el cursor hasta el final del
	    archivo

	  <tag><tt>1G</tt> <item> Desplaza el cursor hasta el
	    principio del archivo

	  <tag><tt><var>n</var>G</tt> <item> Desplaza el cursor hasta
	    la línea número <var>n</var>

	  <tag><tt>C-G</tt> <item> Muestra el número de la línea
	    actual

	  <tag><tt>H</tt> <item> Desplaza el cursor a la línea
	    superior de la pantalla

	  <tag><tt><var>n</var>|</tt> <item> Desplaza el cursor a la
	    columna <var>n</var>

	</taglist>

	<p>La pantalla se desplazará automáticamente cuando el cursor
	  alcance la parte superior o la parte inferior.  Hay órdenes
	  alternativas que pueden controlar el desplazamiento del
	  texto.

	<p>

	<taglist>

	  <tag><tt>C-f</tt> <item> Se desplaza una pantalla hacia
	    adelante

	  <tag><tt>C-b</tt> <item> Se desplaza una pantalla hacia
	    atrás

	  <tag><tt>C-d</tt> <item> Se desplaza media pantalla hacia
	    abajo

	  <tag><tt>C-u</tt> <item> Se desplaza media pantalla hacia
	    abajo

	</taglist>

	<p>

    <sect2 id="editor-vi-editing-numbers"> Repetición de órdenes

	<p>Como quedó mencionado antes, con frecuencia se puede
	  preceder una orden de un número para repetir esa orden.  Por
	  ejemplo, la tecla <tt>l</tt> desplaza el cursor a la
	  izquierda; <tt>10l</tt> lo desplazará 10 posiciones a la
	  izquierda.

	<p>Si quisiera introducir un cierto número de espacios frente
	  al texto podría utilizar un número junto con la orden de
	  inserción.  Introduzca el número <var>n</var>, después
	  <tt>i</tt> seguido de <tt>ESPACIO</tt> y <tt>ESC</tt>.
	  Debería obtener <var>n</var> espacios.

	<p>Las órdenes que tratan con líneas utilizan un número para
	  referirse a los números de línea.  La <tt>G</tt> es buen
	  ejemplo; si la precede de un número, irá a esa línea.

    <sect2 id="editor-vi-editing-advanced"> Referencia avanzada

<!-- FIXME ¿trasladarlo al apéndice? (V: en mi humilde opinión, sí) -->

	<p>Esta sección proporciona una lista más completa de órdenes
	  que puede usar.  Es sólo una referencia; si quiere, pruebe
	  las órdenes para ver lo que hacen.

	<p>Órdenes de inserción:

	<taglist>

	  <tag><tt>a</tt><item> Añade texto a la derecha del cursor

	  <tag><tt>A</tt><item> Añade texto al final de la línea

	  <tag><tt>i</tt><item> Inserta texto a la izquierda del
	    cursor

	  <tag><tt>I</tt><item> Inserta texto a la izquierda del
	    primer carácter distinto de un espacio en la línea actual

	  <tag><tt>o</tt><item> Abre una nueva línea bajo la línea
	    actual e inserta el texto

	  <tag><tt>O</tt><item> Abre una nueva línea sobre la línea
	    actual e inserta el texto

	</taglist>

	<p>Órdenes de borrado:

	<taglist>

	  <tag><tt>x</tt> <item>Borra el carácter bajo el cursor

	  <tag><tt>dw</tt> <item>Borra desde la posición actual del
	    cursor hasta el final de la palabra

	  <tag><tt>dd</tt><item>Borra la línea actual

	  <tag><tt>D</tt><item>Borra desde la posición actual del
	    cursor hasta el final de la línea

	</taglist>

	<p>Las combinaciones de órdenes pueden ser más potentes.  En
	  particular, <tt>d</tt> seguida de una instrucción de
	  movimiento borra desde la posición actual del cursor hasta
	  el punto señalado por la orden de movimiento.  Algunos
	  ejemplos:

	<taglist>

	  <tag><tt>d<var>n</var>w</tt><item>Borra <var>n</var>
	    palabras (<tt><var>n</var>dw</tt> también funciona)

	  <tag><tt>dG</tt><item>Borra desde la posición actual del
	    cursor hasta el final del archivo

	  <tag><tt>d1G</tt><item>Borra desde la posición actual del
	    cursor hasta el principio del archivo

	  <tag><tt>d$</tt><item>Borra desde la posición actual del
	    cursor hasta el final de la línea (igual que <tt>D</tt>)

	  <tag><tt>d<var>n</var>$</tt><item>Borra desde la posición
	    actual hasta el final de la línea <var>n</var>

	</taglist>

	<p>Órdenes de deshacer:

	<taglist>

	  <tag><tt>u</tt><item> Deshace la última orden

	  <tag><tt>U</tt><item> Deshace todos los cambios efectuados
	    en la línea actual

	  <tag><tt>:e!</tt><item> "Editar de nuevo".  Como salir con
	    <tt>:q!</tt> y reiniciar: le devuelve a la última vez que
	    grabó con <tt>:w</tt>

	</taglist>

	<p>Puede deshacer y deshacer, de modo que <tt>uu</tt> resulta
	  en un deshacer deshecho, o sin cambios.

	<p>Órdenes de reemplazar:

	<taglist>

	  <tag><tt>r<var>c</var></tt><item> Reemplazar el carácter
	    bajo el cursor por una <var>c</var>

	  <tag><tt>R</tt><item> Entra en modo de sobreescritura

	  <tag><tt>cw</tt><item> Modifica la palabra en la que se
	    encuentra el cursor

	  <tag><tt>c$</tt><item> Modifica el texto desde la posición
	    actual del cursor hasta el final de la línea

	  <tag><tt>c<var>n</var>w</tt><item> Modifica las siguientes
	    <var>n </var> palabras (igual que <var>n</var>cw)

	  <tag><tt>c<var>n</var>$</tt><item> Modifica desde la posición
	    actual del cursor hasta el final de la línea <var>n</var>

	  <tag><tt>C</tt><item> Modifica el texto desde la posición
	    actual del cursor hasta el final de la línea (igual que
	    <var>c$</var>)

	  <tag><tt>cc</tt><item> Modifica la línea actual

	  <tag><tt>s</tt><item> Sustituye el texto sobre el que se
	    encuentra el cursor por el carácter que se introduzca

	  <tag><tt><var>n</var>s</tt><item> Sustituye el texto
	    existente por el introducido durante los siguientes
	    <var>n</var> caracteres

<!-- ARREGLAR Todos mis comandos <tt>c</tt> derivan de `cut'.  Claro que
podría ser vim
En efecto, es vim: debería mencionarse este comportamiento que se
separa del estándar, porque puede causar un buen número de confusiones -->



	</taglist>

	<p>Las órdenes en la lista anterior que permiten introducir
	  más de un carácter se abandonan con la tecla <tt>ESC</tt>,
	  que devuelve al modo de instrucciones.

	<p>Cortar y pegar implica primero <em>tirar</em>

	  <footnote>(N. del T.: "yanking", dar un tirón.)</footnote>

	  (cortar o copiar) una parte del texto y colocarla en un
	  búfer o espacio de memoria intermedia (o "portapapeles");
	  después moverla a la nueva localización que se desee;
	  después pegar el texto.

	<p>Para cortar el texto utilice la orden <tt>y</tt> y sus
	  variantes:

	<taglist>

	  <tag><tt>yy</tt><item>Copia la línea actual y la almacena en
	    un búfer

	  <tag><tt><var>n</var>yy</tt><item> Copia en un búfer las
	    siguientes <var>n</var> líneas

	  <tag><tt>yw</tt><item> Copia una palabra en un búfer

	  <tag><tt>y<var>n</var>w</tt> Copia en un búfer <var>n</var>
	    palabras

	  <tag><tt>y$</tt><item> Copia en un búfer el texto entre el
	    cursor y el final de la línea

	</taglist>

	<p>Órdenes de pegar:

	<taglist>

	  <tag><tt>p</tt><item> Pegar a la derecha del cursor

	  <tag><tt>P</tt><item> Pegar a la izquierda del cursor

	  <tag><tt><var>n</var>P</tt><item> Pegar <var>n</var> copias
	    del búfer a la izquierda del cursor

	</taglist>

	<p>Cuando utiliza <prgn>vi</prgn> en una xterm o usa una
	  variante de <prgn>vi</prgn> susceptible de ser utilizada en
	  X, puede también utilizar el ratón para copiar texto.  Vea
	  <ref id="X"> para aprender a copiar y pegar en X; asegúrese
	  de que está en modo de inserción cuando pegue, o el texto
	  pegado será interpretado como una orden.

	<p>Cuando borra, el texto borrado se copia en el búfer
	  (portapapeles); entonces puede utilizar las órdenes de
	  copia.  Esto le permite cortar-y-pegar, mientras que las
	  órdenes <tt>y</tt> resultan en copiar-y-pegar.

<!-- ARREGLAR Esto es cierto para vi, pero no para vim -->

	<p><prgn>vi</prgn> dispone de órdenes para buscar en el texto.
	  También puede utilizarlas como órdenes de movimiento, si
	  quiere desplazarse hasta una palabra o carácter en
	  particular.

	<p>Las órdenes de búsqueda más simples buscan caracteres:

	<taglist>

	  <tag><tt>f<var>c</var></tt><item> Encuentra el siguiente
	    carácter <var>c</var> a la derecha o debajo de la posición
	    actual del cursor

	  <tag><tt>F<var>c</var></tt><item> Encuentra el siguiente
	    carácter <var>c</var> a la izquierda o sobre la posición
	    actual del cursor

	  <tag><tt>t<var>c</var></tt><item> Se desplaza hacia la
	    derecha hasta el carácter anterior al siguiente
	    <var>c</var>

	  <tag><tt>T<var>c</var></tt><item> Se desplaza hacia la
	    izquierda hasta el carácter siguiente al <var>c</var>
	    anterior

	  <tag><tt>;</tt><item> Repite la última orden de búsqueda de
	    caracteres

	  <tag><tt>,</tt><item> Igual que <tt>;</tt>, pero invierte la
	    dirección de la orden original

	</taglist>

	<p>Si no encuentra el carácter que estaba buscando,
	  <prgn>vi</prgn> pitará o le dará alguna otra clase de señal.

	<prgn>vi</prgn> le permite buscar cualquier clase de texto, no
	  solamente un carácter.

	<taglist>

	  <tag><tt>/<var>texto</var></tt><item>Busca a la derecha y
	    hacia abajo la próxima aparición de <var>texto</var>

	  <tag><tt>?<var>texto</var></tt><item>Busca a la izquierda y
	    hacia arriba la aparición anterior de <var>texto</var>

	  <tag><tt>n</tt><item>Repite la última orden <tt>/</tt> o
	    <tt>?</tt>

	  <tag><tt>N</tt><item>Repite la última orden <tt>/</tt> o
	    <tt>?</tt> en el sentido opuesto.

	</taglist>

	<p>Al utilizar las órdenes <tt>/</tt> o <tt>?</tt> se
	  despejará una línea en la parte inferior de la pantalla.
	  Ahí se introduce el texto que se desea buscar seguido de
	  <tt>RET</tt>.

	<p>El texto en las órdenes <tt>/</tt> o <tt>?</tt> es en
	  realidad una <em>expresión regular</em>, vea <ref
	  id="text_tools-regexps">.

   <chapt id="custom_shell"> <heading> Personalizar la shell
     </heading>

     <sect id="custom_shell-dotfiles"> Archivos .rc y <tt>ls -a</tt>

	<p>Cuando utiliza <tt>ls</tt>, los archivos cuyo nombre
	  comienza con un punto no aparecen listados.
	  Tradicionalmente, los ficheros que contienen información
	  sobre la configuración, las preferencias del usuario, y
	  demás, empiezan con un punto; permanecen ocultos y fuera de
	  su camino en su actividad cotidiana.  Ejemplos de archivos
	  de configuración

	  <footnote>(N. del T.: la expresión original es "dotfiles",
	    esto es, "archivos de punto".  Sin embargo, suele hablarse
	    de ellos como de "archivos de configuración", y así nos
	    referiremos a ellos de aquí en adelante.)</footnote>

	  con <tt>~/.emacs</tt>, <tt>~/.newsrc</tt>,
	  <tt>~/.bashrc</tt>, <tt>~/.xsession</tt>,
	  <tt>~/.fvwmrc</tt>, etc...  Los anteriores los utilizan
	  Emacs, los lectores de noticias, la shell Bash, el Sistema X
	  Window, y el gestor de ventanas <prgn>fvwm</prgn>,
	  respectivamente.  Convencionalmente el nombre de estos
	  ficheros termina en <tt>rc</tt>, aunque no siempre.  Hay
	  también directorios cuyo nombre comienza por un punto, como
	  <tt>~/.gimp</tt> y <tt>~/.netscape</tt>, que almacenan las
	  preferencias para Gimp y Netscape.

	<p>En ocasiones un programa creará un archivo de configuración
	  automáticamente; por ejemplo, Netscape le permite editar sus
	  preferencias a través de cuadros gráficos de diálogo y
	  después guarda su selección.  Otras veces los creará usted
	  mismo utilizando un editor de texto; esta es la forma
	  tradicional de hacerlo, pero tiene que haber aprendido el
	  formato particular de cada fichero; incómodo al principio,
	  pero puede proporcionarle mucho poder.

	<p>Para ver los archivos de configuración, ha de usar la
	  opción <tt>-a</tt> con <tt>ls</tt>.  La forma larga de
	  <tt>-a</tt> es <tt>--all</tt>, que puede encontrar más fácil
	  de recordar.  Puede usar también, <tt>-A</tt> o
	  <tt>--almost-all</tt>

	  <footnote>(N. del T.: "all", todos; "almost all", casi
	  todos.)</footnote>,

	  que incluye todos los archivos cuyo nombre comienza por un
	  punto excepto <tt>.</tt> y <tt>..</tt>; recuerde que
	  <tt>.</tt> es el directorio de trabajo, y <tt>..</tt> el
	  padre del directorio de trabajo; puesto que éstos es seguro
	  que aparecen en cada directorio, no hay una auténtica razón
	  para listarlos con <tt>ls</tt>.  Usted ya sabe que están
	  ahí.

    <sect id="custom_shell-etc"> Configuración del sistema contra
      configuración del usuario

	<p>Es importante recordar que hay dos clases distintas de
	  configuración en un sistema Debian.  La <em>configuración
	  del sistema</em> afecta a todos los usuarios.  Las
	  especificaciones del sistema se establecen en el directorio
	  <tt>/etc</tt>.  Puede configurar el modo en que el sistema
	  se conecta a internet, por ejemplo; o hacer que los
	  navegadores del sistema siempre se inicien en la página
	  principal de la empresa.  Puesto que quiere que estas
	  especificaciones se apliquen a todos los usuarios, hace las
	  modificaciones en <tt>/etc</tt>.  Ejemplos de archivos de
	  configuración en <tt>/etc</tt> incluyen
	  <tt>/etc/X11/XF86Config</tt>, <tt>/etc/lynx.cfg</tt>, y
	  <tt>/etc/ppp/options</tt>.  De hecho, casi todos los
	  ficheros en <tt>/etc</tt> son archivos de configuración

	  <footnote>(N. del T.: una peculiaridad que notará en los
	  ficheros de este directorio es que, a pesar de que se trata
	  de archivos de configuración, su nombre no está precedido de
	  un punto, y por tanto, sí aparecen en los listados de
	  <tt>ls</tt>.  La razón consiste en que <tt>/etc</tt> no
	  contiene más que estos ficheros, y en él no se desarrolla
	  otro trabajo que el de la configuración.  Por lo tanto, no
	  hay que sacarlos del camino de su trabajo diario, porque no
	  hay trabajo diario que hacer en <tt>/etc</tt>.)</footnote>.

	<p>Normalmente, debe ser root para alterar especificaciones
	  que afectan al sistema en su totalidad.

	<p>La <em>configuración del usuario</em> afecta solamente a un
	  único usuario.  Esta configuración se realiza a través de
	  archivos de configuración.  Por ejemplo, el archivo
	  <tt>~/.newsrc</tt> almacena una lista de qué artículos de
	  Usenet (grupos de discusión) ha leído, y a qué grupos está
	  suscrito.  Esto permite a los lectores de noticias como
	  <tt>trn</tt> o Netscape mostrar los artículos no leídos de
	  los grupos en los que está interesado.  Esta información
	  será diferente para cada usuario del sistema, de modo que
	  cada usuario tiene su propio archivo <tt>.newsrc</tt> en su
	  directorio de usuario.

<!-- FIXME : hay que escribir
<sect id="custom_shell-login"> Shell de ingreso contra shell no de
ingreso.
<p>La diferencia, qué archivos editar para cada una.

<sect id="custom_shell-profile"> Editar .bash_profile
<p>Un pequeño manual, quizás establecer algunas variables de entorno
comunes o alias útiles.
<p>Utilizar algunos trucos ingeniosos de edición de textos.
<p>Describir <tt>umask</tt>

<sect id="custom_shell-changing"> Cambiar la shell
<p>Simplemente mencionar la posibilidad, y por qué alguien podría
querer hacerlo.

-->

   <chapt id="X"> <heading> El Sistema X Window </heading>

	<p>Este capítulo describe la interfaz de usuario del Sistema
	  gráfico X Window.  Presupone que usted ha configurado ya
	  X con éxito, según las instrucciones del Manual de
	  Instalación (de nuevo, el manual de instalación no está
	  escrito aún; por ahora necesitará utilizar el XFree86-CÓMO,
	  el contenido de <tt>/etc/doc/X11</tt>, y este capítulo).
	  Una vez instalado X, puede entrar en el entorno X
	  escribiendo <tt>startx</tt> o vía <tt>xdm</tt>, en función
	  de las elecciones hechas durante la configuración.

    <sect id="X-starting"> Arrancando el entorno X

	<p>Hay dos formas de arrancar X.  La primera es iniciarlo
	  manualmente cuando tenga ganas de usarlo.  Para hacerlo,
	  ingrese en una de las consolas de texto, y escriba
	  <tt>startx</tt>.  Esto iniciará X y le llevará a una
	  consola virtual.

	<p>La segunda forma (recomendada) de utilizar X es con
	  <prgn>xdm</prgn>, o X Display Manager

	  <footnote>(N. del T.: Gestor de Visualización de
	    X)</footnote>.

	  Básicamente, <prgn>xdm</prgn> le proporciona un agradable
	  prompt gráfico para el ingreso en la consola virtual de X
	  (probablemente CV 7

	  <footnote>(N. del T.: recuerde que CV procedía de "Consola
	    Virtual".  Habrá observado que en Debian, por defecto
	    dispone de seis consolas virtuales en modo texto.  Al
	    arrancar X se inicia, pues, la consola virtual número
	    7.)</footnote>


	  ), y usted ingresa ahí.

	<p>Por defecto, cualquiera de ambos métodos iniciará una
	  <tt>xterm</tt>, que es una pequeña ventana que contiene un
	  prompt de shell.  En el prompt de la shell, usted puede
	  introducir cualesquiera instrucciones, tal como lo haría en
	  una consola virtual de texto.  Así que puede seguir todos
	  los ejemplos de este manual utilizando <tt>xterm</tt>,
	  puesto que ya ha ingresado en X.

	<p>Hay también muchas cosas que pueden solamente hacerse en X,
	  cubiertas en este capítulo.

	<p>Una nota: por defecto, <tt>xterm</tt> tiene una fuente más
	  bien pequeña.  Si tiene un monitor pequeño o una resolución
	  muy alta o mala vista, puede querer arreglarlo.  Siga estos
	  pasos:

	<enumlist>

	  <item> Mueva el puntero del ratón al centro de la ventana de
	    la <tt>xterm</tt>.

	  <item> Mantenga apretados la tecla <tt>Control</tt> y el
	    botón <em>derecho</em> del ratón simultáneamente.  Esto le
	    dará un menú de fuentes.

	  <item> Señale la fuente que quiere y libere el botón del
	    ratón.

	</enumlist>

     <sect id="X-intro"> Introducción: Qué es X

	<p>Una GUI (Interfaz Gráfica de Usuario)

	  <footnote>(N. del T.: esto es, "Graphical User Interface".
	    Se mantiene la abreviatura original debido a su gran
	    difusión.)</footnote>

	  es una parte esencial de los sistemas operativos Windows y
	  Mac.  Es básicamente imposible escribir una aplicación para
	  esos sistemas que no utilice la GUI, y los sistemas no se
	  pueden utilizar de manera efectiva desde la línea de
	  instrucciones.  GNU/Linux es más <em>modular</em>, esto es,
	  compuesto de muchos componentes pequeños e independientes
	  que pueden usarse o no según las necesidades o preferencias
	  propias.  Uno de esos componentes es el Sistema X Window, o
	  simplemente X

	  <footnote>También se le llama a veces X11 o X Window.  Dése
	    cuenta, por favor, de que "X Windows" <em>no</em> es
	    correcto, y es probable que ofenda a los puristas si
	    utiliza este término incorrecto.</footnote>.

	<p>X en sí mismo constituye un medio de que los programas
	  hablen con su ratón y tarjeta de vídeo, sin saber qué clase
	  de ratón o tarjeta de vídeo tiene.  O sea, se trata de una
	  <em>abstracción</em> del equipo físico gráfico.  Las
	  aplicaciones de usuario hablan a X, en el lenguaje de X; X
	  después traduce al lenguaje de su equipo físico particular.
	  Esto quiere decir que los programas sólo tienen que
	  escribirse una vez, y funcionan en las computadoras de
	  todos.

	<p>En la jerga de X, el programa que habla con el equipo
	  físico se denomina <em>servidor</em>.  Las aplicaciones de
	  usuario que solicitan al servidor X que muestre ventanas o
	  gráficos en la pantalla se denominan <em>clientes</em>.  El
	  servidor X incluye un <em>controlador de vídeo</em>, de modo
	  que usted debe tener un servidor X que se corresponda con su
	  tarjeta de vídeo.

	<p>El servidor X no proporciona ninguna de las características
	  que uno esperaría de una GUI, como redimensionado y
	  resdistribución de ventanas.  Un cliente X especial,
	  denominado <em>gestor de ventanas</em>, dibuja bordes y
	  barras de título en las ventanas, redimensiona y coloca las
	  ventanas, y proporciona recursos para iniciar otros clientes
	  X desde un menú.  Algunos gestores de ventanas pueden
	  ofrecer características adicionales.

	<p>Los gestores de ventanas disponibles en un sistema Debian
	  comprenden <tt>fvwm</tt>, <tt>fvwm2</tt>, <tt>icewm</tt>,
	  <tt>afterstep</tt>, <tt>olvwm</tt>, <tt>wmaker</tt>,
	  <tt>mwm</tt>, <tt>twm</tt>, <tt>enlightenment</tt> y otros.
	  Probablemente querrá probarlos todos y escoger su favorito.
	  (Para más información sobre los gestores de ventanas, y más
	  material interesante sobre X, <url id="http://www.x11.org"
	  name="X11.org"> es un buen sitio.)

	<p>Ni el servidor X ni el gestor de ventanas proporcionan un
	  <em>gestor de ficheros</em>; esto es, no hay ventanas que
	  contengan iconos que representen sus archivos y directorios.
	  Usted puede iniciar un gestor de ficheros como aplicación
	  independiente; hay disponibles muchos de ellos, aunque
	  desafortunadamente aún no los hay buenos que estén basados
	  en iconos.  El proyecto de escritorio GNOME está
	  desarrollando un gestor de ficheros basado en iconos y otros
	  recursos GUI, sin embargo.  En <url
	  id="http://www.gnome.org" name="la página principal del
	  proyecto GNOME"> puede leer las últimas noticias al
	  respecto.

	<p>Una última característica de X es su <em>transparencia en
	  la red</em>, lo que quiere decir que los clientes X no se
	  preocupan de si están hablando a un servidor X en la misma
	  máquina o en cualquier otra de la red.  En la práctica, esto
	  significa que pueden iniciar un programa en una máquina
	  remota más potente, pero mostrarlo en su ordenador de
	  escritorio.

    <sect id="X-basics"> Operaciones básicas en X

      <sect1 id="X-basics-mouse"> El ratón

	<p>El ratón en X funciona prácticamente igual que el ratón en
	  otros sistemas, excepto que tiene tres botones.  Si su ratón
	  tiene sólo dos, puede simular el tercer botón (central)
	  picando simultáneamente los otros dos.  Esto es una especie
	  de apaño algo molesto, de modo que invertir unas dos mil
	  pesetas en un ratón de tres botones probablemente no es mala
	  idea.  Están disponibles en cualquier tienda de informática.

	<p>Los botones se numeran de izquierda a derecha, asumiendo
	  que usted tenga un ratón para diestros, de manera que el
	  botón uno está a la izquierda, el dos en el centro, el tres
	  a la derecha.  Puede ver tanto los números como las
	  localizaciones en la documentación.

	<p>X dispone de un servicio interno simple para cortar y
	  pegar.  Para seleccionar el texto que quiera copiar, pique y
	  arrastre con el botón izquierdo del ratón.  Esto debería
	  seleccionar el texto que quiere copiar, suponiendo que la
	  aplicación que esté usando soporte el copiar-y-pegar.  Para
	  pegar el texto, pique con el botón central en una aplicación
	  X distinta.  Por ejemplo, si recibe un correo electrónico
	  que contiene una URL, puede seleccionar la URL con el botón
	  izquierdo, luego picar en el apartado "Location" de su
	  navegador con el botón central para pegarla allí.

    <sect1 id="X-basics-clients"> Clientes X

	<p>Los programas que se comunican con el servidor X se
	  denominan clientes X.  La mayor parte de estos programas
	  pedirán al servidor X que muestre ventanas en la pantalla.

	<p>Un cliente X se inicia del mismo modo que cualquier otro
	  programa Debian.  Simplemente escriba el nombre del cliente
	  en la línea de instrucciones.  Escriba <tt>xterm</tt> en una
	  xterm existente, y un nuevo cliente xterm aparecerá en la
	  pantalla.

	<p>Se dará cuenta de que ahora la xterm original es inútil,
	  puesto que la shell está esperando que la segunda xterm se
	  cierre.  Para evitar este problema, puede iniciar el cliente
	  X en segundo plano; añada un <tt>&amp;</tt> tras el nombre
	  de la orden, así: <tt>xterm &</tt>.  Si se le olvida, puede
	  colocar un proceso activo en segundo plano.  Primero
	  suspenda el proceso con <tt>C-z</tt>, y después envíelo al
	  segundo plano con la orden <tt>bg</tt>.

	<p>Si utiliza un programa con frecuencia, su gestor de
	  ventanas ofrecerá generalmente un modo de colocar ese
	  programa en un cómodo menú gráfico.

    <sect1 id="X-basics-trouble"> Resolución de problemas

	<p>En ocasiones, cuando inicie un cliente X desde un menú
	  gráfico, no podrá ver ningún mensaje de error si falla.
	  Puede encontrar cualquier mensaje de error en el archivo
	  <tt>~/.xsession-errors</tt>.

    <sect1 id="X-basics-leaving"> Dejar el entorno X

	<p>Para dejar X, necesitará utilizar un menú.
	  Desafortunadamente para los principiantes, éste será
	  distinto para cada gestor de ventanas, y en muchos gestores
	  de ventanas puede configurarse de muchas maneras.  Si hay un
	  menú aparente, busque una entrad similar a "Salir" o "Cerrar
	  el gestor de ventanas"

	  <footnote>(N. del T.: es conveniente que conozca los
	    mensajes que puede encontrar en gestores no
	    internacionalizados.  Así, "Exit", "Close Window Manager"
	    o "Log out" con expresiones corrientes.)</footnote>.

	  Si no ve un menú, pruebe a picar con cada uno de los botones
	  del ratón en el fondo de la pantalla.  Si falla todo lo
	  demás, puede cerrar el servidor X por la fuerza apretando
	  <tt>C-A-BORR</tt>.  Cerrar el servidor de esta manera
	  destruirá los datos no guardados de las aplicaciones
	  abiertas.

    <sect id="X-startup"> Personalizar el arranque de X

	<p>Cuando arranca X, Debian iniciará algunos guiones de la
	  shell que arrancan el gestor de ventanas y otros clientes X.
	  Por defecto, iniciará para usted un gestor de ventanas, una
	  <tt>consola</tt> y una <tt>xterm</tt>.

	<p>Para personalizar el arranque de X, el fichero
	  <tt>/etc/X11/config</tt> debe contener la línea
	  <tt>allow-user-xsession</tt>.  Si no es así, conviértase en
	  root y añada ahora la línea.  Después ingrese de nuevo como
	  usted mismo y continúe con la práctica

<!-- ARREGLAR : en potato /etc/X11/config ya no es funcional, y sus -->
<!-- entradas se han repartido entre varios ficheros.  En concreto, -->
<!-- ésta s encuentra ahora en /etc/X11/Xsession -->


	  <footnote>Puede ver cómo funciona el arranque de X de Debian
	    en el archivo <tt>/etc/X11/Xsession</tt>.  Fíjese en que
	    el comportamiento de <tt>/etc/X11/Xsession</tt> puede
	    cambiarse modificando el archivo <tt>/etc/X11/config</tt>,
	    que especifica algunas preferencias que afectan a todo el
	    sistema.</footnote>.

	<p>Para iniciar los clientes de su elección cuando arranca X,
	  debe crear un guión ejecutable de la shell llamado
	  <tt>.xsession</tt> en su directorio de usuario.

	<enumlist>

	  <item><tt>touch ~/.xsession</tt> <p> Esto crea el fichero.

	  <item><tt>chmod u+x ~/.xsession</tt> <p> Hace ejecutable al
	    fichero.

	</enumlist>

<!-- ARREGLAR ????????????????????? -->

	<p>Una vez que existe <tt>.xsession</tt>, necesita editarlo
	  con su editor de texto favorito para hacer algo útil.  Puede
	  hacer lo que quiera en este guión.  No obstante, cuando el
	  proceso del script termine, X también terminará.

	<p>En la práctica esto significa que a menudo terminará el
	  guión con una llamada a <tt>exec</tt>.

<!-- FIXME xref que explique exec contra tareas en segundo plano -->
<!-- contra ejecución normal -->

	  Cualquier programa que invoque con <tt>exec</tt> sustituirá
	  al proceso del guión consigo mismo, de manera que se
	  ignorarán las órdenes tras la línea de <tt>exec</tt>.  El
	  programa ejecutado con <tt>exec</tt> se convertirá en el
	  nuevo "propietario" del proceso del guión, lo que quiere
	  decir que X terminará cuando termine el proceso de este
	  nuevo programa.

<!-- FIXME : ¿sustituir las apariciones de fvwm por un WM más moderno?
wmaker, enlightenment o icewm parecen mejores candidatos -->

	<p>Digamos que termina su .xsession con la línea <tt>exec
	  fvwm</tt>.  Esto significa que el gestor de ventanas
	  <tt>fvwm</tt> se iniciará cuando arranca X.  Cuando salga
	  del gestor de ventanas fvwm, su sesión X terminará y se
	  cerrarán todos los clientes restantes.  No tiene por qué
	  usar un gestor de ventanas aquí; podría incluir <tt>exec
	  xterm</tt>, in cuyo caso escribir <tt>exit</tt> es esa xterm
	  específica causaría el final de toda la sesión X.

	<p>Si quiere iniciar otros clientes antes de hacer su
	  <tt>exec</tt>, necesitará iniciarlos en segundo plano.  De
	  otro modo, <tt>.xsession</tt> se detendrá hasta que termine
	  cada cliente, y después pasará a la línea siguiente.  Vea la
	  sección anterior sobre ejecutar trabajos en segundo plano

<!-- FIXME xref -->

	  (básicamente habrá de poner una <tt>&</tt> al final, por
	  ejemplo, <tt>xterm &amp;</tt>.

	<p>Puede sacar provecho de este comportamiento, no obstante.
	  Si quiere ejecutar órdenes al terminar su sesión X, puede
	  hacer que su <tt>.xsession</tt> inicie un gestor de ventanas
	  o similar y esperar que termine.  Esto es, no utilice el
	  <tt>exec</tt> y el <tt>&amp;</tt>, simplemente escriba
	  <tt>fvwm</tt> sin más.  Entonces ponga las instrucciones que
	  quiera después de <tt>fvwm</tt>.

	<p>Probablemente le ayudaría ver algunos ficheros
	  <tt>.xsession</tt> de ejemplo.  En todos ellos, sustituya
	  <tt>fvwm</tt> con el gestor de ventanas que prefiera.

	<p>El <tt>.xsession</tt> más sencillo se limita a iniciar un
	  gestor de ventanas:

<example>
exec fvwm
</example>

	  Esto ejecutará fvwm, y la sesión X terminará cuando fvwm se
	  cierre.  Si lo hace sin <tt>exec</tt>, todo parecerá
	  comportarse igual, pero tras las bambalinas,
	  <tt>.xsession</tt> se colgará esperando a fvwm, y
	  <tt>.xsession</tt> se cerrará después de que fvwm lo haga.
	  Usar <tt>exec</tt> es ligeramente mejor porque fvwm
	  sustituye a <tt>.xsession</tt> en lugar de dejarlo
	  esperando.  Puede utilizar las órdenes <tt>ps</tt> o
	  <tt>top</tt> para comprobarlo.

	<p>Un <tt>.xsession</tt> más útil ejecuta algunos clientes
	  antes de iniciar el gestor de ventanas.  Por ejemplo, usted
	  puede querer algunas xterms y un reloj x

	  <footnote>(N. del T.: reloj x, "xclock".)</footnote> siempre
	  que inicie X.  Sin problemas:

<example>
xterm &
xterm &
xclock &
exec fvwm
</example>

	  Dos xterms y un reloj de X arrancan en segundo plano, y
	  después se inicia el gestor de ventanas.  Cuando abandone el
	  gestor de ventanas, también saldrá de X.

	<p>Puede intentarlo sin utilizar el segundo plano sólo para
	  ver qué sucede.  Haga esto:

<example>
xterm
xclock
exec fvwm
</example>

	  la xterm se iniciará, y esperará a que usted la cierre.
	  Entonces se iniciará xclock; tendrá que salir de xclock
	  antes de que pueda comenzar fvwm.  Las órdenes se ejecutan
	  una tras otra, puesto que el guión espera a que cada una
	  termine.

	<p>Puede sacar provecho de la ejecución sucesiva.  Tal vez
	  quiera mantener un registro de cuándo deja de trabajar cada
	  día:

<example>
xterm &
xclock &
fvwm
date &gt&gt ~/hora-de-terminar
</example>

	  Esto se dividirá en un doble proceso con una xterm y un
	  xclock, después iniciará fvwm y esperará a que éste termine.
	  Cuando abandone fvwm, se moverá hasta la última línea, la
	  cual añade la fecha y hora actuales al archivo
	  <tt>~/hora-de-terminar</tt>.

	<p>Por último, puede hacer que un programa distinto del gestor
	  de las X determine cuándo se abandona X:

<example>
xclock &
fvwm &
exec xterm
</example>
		      
	  Este guión ejecutará xclock y fvwm en segundo plano, y
	  después se sustituye por una xterm.  Cuando abandona la
	  xterm, su sesión X terminará.

	<p>La mejor manera de aprender a usar <tt>.xsession</tt> es
	  intentar algunas de estas cosas.  De nuevo, asegúrese de que
	  utiliza <tt>chmod</tt> para hacerlo ejecutable; éste es un
	  error común.
		      
<!-- FIXME : Necesita completarse

<sect id="X-custom"> Personalizar X
<p>Cómo personalizar el mapa del teclado, el concepto de los recursos
X.
<p>Qué hay en /etc/X11/config (o puede que sólo una referencia a
/usr/doc en este tema.

-->
		      
<!-- ARREGLAR : igual que antes, /etc/X11/config ha quedado sin efecto -->

<!--

<sect id="X-wm"> Personalizar el gestor de ventanas
<p>Una pequeña introducción.  Pero hay que escoger uno en concreto
para explicar esta sección.

-->
		      
    <chapt id="text_tools"> <heading> Herramientas de texto </heading>

	<p>head, tail, grep, wc, tr, sed, perl y demás

     <sect id="text_tools-regexps"> Expresiones regulares

	<p>Una expresión regular es una descripción de un conjunto de
	  caracteres.  Esta descripción puede utilizarse para buscar a
	  través de un fichero buscando texto que <em>equivalga</em> a
	  la expresión regular.  Las expresiones regulares son
	  análogas a los comodines de la shell (vea <ref
	  id="shell-wildcards">), pero son tanto más complicadas como
	  más potentes.

	<p>Una expresión regular se compone de texto y
	  <em>metacaracteres</em>.  Un metacarácter es simplemente un
	  carácter con un significado especial.  Los metacaracteres
	  incluyen: <tt> . * [] - \ ^ &dollar;</tt>.

	<p>Si una expresión regular contiene sólo texto (sin
	  metacaracteres), entonces equivale a ese texto.  Por
	  ejemplo, la expresión regular '<tt>mi expresión
	  regular</tt>' equivale al texto '<tt>mi expresión
	  regular</tt>, y nada más.  Las expresiones regulares tienen
	  generalmente en cuenta las letras mayúsculas.

	<p>Puede utilizar la instrucción <tt>egrep</tt> para mostrar
	  todas las líneas de un fichero que contienen una expresión
	  regular.  Su sintaxis es:

	<p><tt>egrep '<var>regexp</var>' <var>nombredefichero1</var>
	  ... </tt>

	  <footnote>Las comillas no se necesitan siempre, pero no
	    hacen daño.</footnote>

	<p>Por ejemplo, para encontrar todas las líneas de la GPL que
	  contienen la palabra GNU, escriba:

<example>
egrep 'GNU' /usr/doc/copyright/GPL
</example>

	<p><tt>egrep</tt> imprimirá las líneas en la salida estándar.

	<p>Si quiere todas las líneas que contienen <tt>freedom</tt>

	  <footnote>(N. del T.: "freedom", libertad.)</footnote>,

	  seguida de cualquier otro texto, seguido de <tt>GNU</tt>,
	  puede hacer:

<example>
egrep 'freedom.*GNU' /usr/doc/copyright/GPL
</example>

	<p>El <tt>.</tt> significa "cualquier carácter"; el <tt>*</tt>
	  significa "cero o más de la cosa precedente", en este caso,
	  "cero o más de cualquier carácter".  De modo que <tt>.*</tt>
	  equivale a cualquier texto, sin limitaciones.
	  <tt>egrep</tt> sólo busca equivalencias por líneas, por lo
	  que <tt>freedom</tt> y <tt>GNU</tt> tienen que estar en la
	  misma línea.

	<p>Aquí hay un resumen de los metacaracteres de expresiones
	  regulares:

	<p>

	<taglist>

	  <tag><tt>.</tt><item> Equivale a cualquier carácter
	    individual excepto fin de línea.

	  <tag><tt>*</tt><item> Equivale a cero o más apariciones de
	    la cosa precedente.  Así que la expresión <tt>a*</tt>
	    equivale a 0 o más <tt>aes</tt> minúsculas, y <tt>.*</tt>
	    equivale a cero o más caracteres.

	  <tag><tt>[<var>caracteres</var>]</tt><item>Los corchetes
	    deben contener uno o más caracteres; la expresión entre
	    corchetes en su totalidad equivale exactamente a un
	    carácter del conjunto.  Así que <tt>[abc]</tt> equivale a
	    una <tt>a</tt>, una <tt>b</tt>, o una <tt>c</tt>; no
	    equivale a 0 caracteres, y no equivale a un carácter
	    distinto de esos tres.

	  <tag><tt>^</tt><item>Restringe su búsqueda al principio de
	    la línea.  La expresión <tt>^El</tt> equivale a
	    <tt>El</tt> sólo al principio de la línea; no puede haber
	    espacios u otro texto antes de <tt>El</tt>.  Si quiere
	    permitir espacios, puede permitir 0 o más caracteres de
	    espacio así: <tt>^ *El</tt>.

	  <tag><tt>$</tt><item>Restringe la búsqueda al final de la
	    línea. <tt>final$</tt> exige que el texto <tt>final</tt>
	    se encuentre al final de la línea, sin espacios en blanco
	    o texto.

	  <tag><tt>[^<var>carácter</var>]</tt><item><tt>^</tt>
	    invierte el sentido de una lista de caracteres entre
	    corchetes.  Así que <tt>[^abc]</tt> equivale a cualquier
	    carácter individual, <em>excepto</em> a, b, o c.

	  <tag><tt>[<var>carácter</var>-<var>carácter</var>]</tt><item>
	    Puede incluir intervalos en una lista entre corchetes.
	    Para incluir cualquier letra minúscula, utilice
	    <tt>[a-z]</tt>.  Puede tener más de un intervalo; de modo
	    que para equivaler a las primeras tres o las últimas tres
	    letras del alfabeto, pruebe <tt>[a-cx-z]</tt>.  Para
	    obtener cualquier letra, sin importar si es mayúscula o
	    minúscula, use <tt>[a-zA-Z]</tt>.  Puede mezclar los
	    intervalos con caracteres individuales y con el
	    metacarácter <tt>^</tt>; por ejemplo, <tt>[^a-zBZ]</tt>,
	    siginifica "cualquier cosa excepto una letra minúscula, la
	    B mayúscula, o la Z mayúscula".

	  <tag><tt>()</tt><item>Puede utilizar paréntesis para agrupar
	    partes de la expresión regular, tal como se hace en una
	    expresión matemática.

	  <tag><tt>|</tt><item><tt>|</tt> quiere decir "o"; puede
	    utilizarlo para proporcionar una serie alternativa de
	    expresiones.  Normalmente querrá poner las alternativas
	    entre paréntesis, así: <tt>c(asa|ala|ama)</tt> equivale a
	    <tt>casa</tt> o <tt>cala</tt> o <tt>cama</tt>.  En caso de
	    faltar los paréntesis, equivaldría a <tt>casa</tt> o
	    <tt>ala</tt> o <tt>ama</tt>.

	  <tag><tt>\</tt><item>Sirve para poder incluir cualquier
	    carácter especial; si quisie entontrar un <tt>*</tt>,
	    escriba <tt>\*</tt>.  La barra invertida significa que se
	    debe ignorar el significado especial de <tt>*</tt>.

	</taglist>

	<p>Aquí hay algunos ejemplos más, para ayudarle a cogerle el
	  tranquillo:

	<taglist>

	  <tag><tt>c.sa</tt> equivale <tt>casa</tt>, <tt>cesa</tt>,
	    <tt>cosa</tt>

	  <tag><tt>c\.</tt><item>equivale a <tt>c.sa</tt>,
	    <tt>c.ma </tt>

	  <tag><tt>ci*dad</tt><item>equivale a <tt>cdad</tt>,
	    <tt>cidad</tt>, <tt>ciidad</tt>

	  <tag><tt>car.*n</tt><item>equivale a <tt>carton</tt>,
	    <tt>carrion</tt>, <tt>carmen</tt>

	  <tag><tt>xyz.*</tt><item>equivale a <tt>xyz</tt> y cualquier
	    cosa tras ello; algunas herramientas, como <tt>egrep</tt>,
	    sólo buscan equivalencias sólo hasta el final de la línea

	  <tag><tt>^El</tt><item>equivale a <tt>El</tt> al principio
	    de la línea

	  <tag><tt>palabra$</tt><item>equivale a <tt>palabra</tt> al
	    final de la línea

	  <tag><tt>^Solo$</tt><item>equivale a una línea que consiste
	    solamente en la palabra <tt>Solo</tt>: sin espacios, sin
	    otros caracteres, nada.  Solamente se permite
	    <tt>Solo</tt>

	  <tag><tt>m[eiu]sa</tt><item>equivale a <tt>mesa</tt>,
	    <tt>misa</tt>, <tt>musa</tt>

	  <tag><tt>Ver[D-F]</tt><item>equivale a <tt>VerD</tt>,
	    <tt>VerE</tt>, <tt>VerF</tt>

	  <tag><tt>Ver[^0-9]</tt><item>equivale a <tt>Ver</tt> seguido
	    por cualquier carácter que no sea un número

	  <tag><tt>libr[oa][sr]</tt><item>equivale a <tt>libros</tt>,
	    <tt>libror</tt>, <tt>libras</tt>, <tt>librar</tt>

	  <tag><tt>[A-Za-z][A-Za-z]*</tt><item>equivale a cualquier
	    palabra que consista solamente en letras, y al menos una
	    letra.  No equivaldrá a números o espacios

	</taglist>

<!-- FIXME : ¿Dar algunos otros ejemplos de expresiones regulares -->
<!-- además de egrep? -->

   <chapt id="file_tools"> <heading> Herramientas de ficheros
     </heading>

    <sect id="file_tools-backup"> Herramientas de copia de seguridad

<!-- <p> FIXME esta sección está claramente incompleta:

	<p>tar, cpio, dump; también la copia a gran escala, cp -a etc.

	<p>(Quizás algo sobre cómo hacer copias de respaldo solamente
	  de /home y /etc si se tiene sólo una disquetera, puesto que
	  muchos usuarios no tienen cinta).

	<p>Cómo utilizar tar para copiar muchos archivos, o hacer
	  copias de seguridad de sus ficheros.  Tarballs.  Pienso que
	  esta debería ser una sección breve dirigida a los sistemas
	  de usuario único, con una explicación más profunda para
	  administradores del sistema en un manual diferente.

-->

	<p>Los comandos de copia de seguridad (aportados por Oliver
	  Elphick, una sección que tiene que ser aclarada y
	  elaborada):

	<p>dump: vuelca un sistema de ficheros cada vez; sus opciones
	  presumen que se utiliza una cinta de media pulgada (máximo
	  de 45 Mb por cartucho) de modo que es un tanto desagradable
	  cuando se utiliza DAT(2 Gb o más).  Probablemente lo mejor
	  para copias de seguridad periódicas.  No se puede usar en
	  sistemas de ficheros montados con NFS.

	<p>cpio: `find [directorios] -print | cpio -ovH newc -B >
	  /dev/st0'

	<p>tar: `tar cvf /dev/st0 [directorios]'

	<p>afio: como cpio; proporciona precompresión de los ficheros
	  antes de archivarlos.

	<p>tob: frontal para afio.

   <sect id="file_tools-compression"> Compresión de ficheros con
     <tt>gzip</tt>

	<p>Con frecuencia estaría bien poder reducir el tamaño de un
	  archivo: bien para descargarlo más aprisa, o para que ocupe
	  menos espacio en su disco.  El programa que hace esto se
	  llama <tt>gzip</tt> (GNU zip).

	<enumlist>

<!-- FIXME : utilizar gzip con mi /etc/profile sólo lo reduce en 17 -->
<!-- bytes (de 178 a 161).  Considerar utilizar otro ejemplo (¿la -->
<!-- GPL?) -->

	<item><tt>cd; cp /etc/profile ./fichejemplo</tt> <p>Regrese a
	  su directorio de usuario, copie un fichero elegido al azar
	  (<tt>/etc/profile</tt>) en su directorio de trabajo,
	  cambiándole el nombre en el proceso a <tt>fichejemplo</tt>.
	  Esto nos da un fichero con el que jugar con <tt>gzip</tt>.

	<item><tt>ls -l</tt> <p>Liste los contenidos del directorio de
	  trabajo.  Fíjese en el tamaño de <tt>fichejemplo</tt>.

	<item><tt>gzip fichejemplo</tt> <p>Comprima
	  <tt>fichejemplo</tt>.

	<item><tt>ls -l</tt> <p>Observe los resultados:
	  <tt>fichejemplo</tt> se llama ahora <tt>fichejemplo.gz</tt>.
	  También es bastante más pequeño.

	<item><tt>gunzip fichejemplo.gz; ls -l </tt> <p>Descomprima.
	  Observe que <tt>fichejemplo</tt> ha regresado a su estado
	  original.  Dése cuenta de que par descomprimir se utiliza
	  <tt>gunzip</tt>, no <tt>gzip</tt>.

	<item><tt>rm fichejemplo</tt> <p>Borre el fichero, puesto que
	  era nada más para practicar.

	</enumlist>

    <sect id="file_tools-split"> Dividir archivos en trozos más
      pequeños

	<p>A veces un fichero es demasiado grande para caber en un
	  disco, o usted no quiere enviar un archivo enorme a través
	  de la red en una sola pieza.  Puede dividir el fichero
	  utilizando la utilidad <tt>split</tt>, y móntelo de nuevo
	  con la utilidad <tt>cat</tt> (con<em>cat</em>enar).

	<enumlist>

	  <item><tt>cd; cp /bin/bash mifichero; ls -l mifichero</tt>
	    <p>Copie el ejecutable <tt>bash</tt> en un fichero en su
	    directorio de usuario llamado <tt>mifichero</tt>.  Observe
	    que <tt>mifichero</tt> ocupa un poco más de 400.000
	    bytes, o alrededor de 400 kilobytes.

<!-- ARREGLAR : bash 2.1 tiene 364.336 bytes -->

	  <item><tt>split -b100k mifichero miprefijo</tt> <p>Divide el
	    archivo en secciones de 100 kilobytes, y llama a las
	    secciones <tt>miprefijoaa</tt>, <tt>miprefijob</tt>, etc.
	    Escriba <tt>ls -l</tt> para ver los resultados.

	  <item>Puede especificar cualquier número tras <tt>-b</tt>:
	    elija uno que tenga sentido.  Si quita la <tt>k</tt>, se
	    entenderá que son bytes en lugar de kilobytes.  Si utiliza
	    <tt>m</tt> en lugar de <tt>k</tt>, se entenderá que son
	    megabytes.

	  <item><tt>cat miprefijo* &gt mifichero2</tt> <p>Una todos
	    los ficheros y escríbalos en
	    <tt>mifichero2</tt>. (<tt>*</tt> y <tt>&gt</tt> son trucos
	    que aprenderá en otro capítulo

<!-- ARREGLAR : atención pregunta: ¿no debería ser &gt;&gt -->


<!-- FIXME xref -->.)

	  <item> <tt>rm mifichero miprefijo* mifichero2</tt>
	  <p>Bórrelo todo.

	</enumlist>

    <sect id="file_tools-find"> Buscar ficheros

	<p>Hay dos utilidades diferentes para buscar ficheros:
	  <tt>find</tt> y <tt>locate</tt>

	  <footnote>(N. del T.: "find", encontrar; "locate",
	    localizar.)</footnote>.

	  <tt>find</tt> busca los ficheros en su estado presente.
	  <tt>locate</tt> busca en un índice generado diariamente por
	  el sistema

<!-- ARREGLAR : el original dice encontrar en el título -->

<!-- ARREGLAR : el original dice que lo genera el sistema a las 6:42 de -->
<!-- la mañana.  Evidentemente es un trabajo cron, no un trabajo -->
<!-- anacron, de modo que no es válido para todos los usuarios -->

	  (se trata de un trabajo <tt>cron</tt>, explicado en otro
	  lugar de este manual

<!-- FIXME xref -->

	  ). <tt>locate</tt> no encontrará ningún fichero creado
	  después de la generación del índice.  Sin embargo, puesto
	  que <tt>locate</tt> busca en un índice, es mucho más rápido:
	  como utilizar el índice de un libro en lugar de buscar en
	  cada página.

	<p>Para comparar las dos formas de buscar ficheros, imagine
	  que no puede recordar dónde reside el fichero de
	  configuración de X <tt>XF86Config</tt>.

	<enumlist>

	  <item><tt>locate XF86Config</tt> <p> Esto debería ser
	    bastante rápido.  Obtendrá una lista de nombres de fichero
	    que <em>contienen</em> XF86Config, algo como esto:

<example>
/etc/X11/XF86Config 
/usr/X11R6/lib/X11/XF86Config
/usr/X11R6/lib/X11/XF86Config.eg
/usr/X11R6/man/man5/XF86Config.5x.gz
</example>

	  <item><tt>find / -name XF86Config</tt>

	<p>Escuchará un montón de actividad en el disco, y llevará
	  mucho más tiempo.  Los resultados se asemejarán a:

<example>
/etc/X11/XF86Config 
/usr/X11R6/lib/X11/XF86Config 
find: /var/spool/cron/atjobs: Permiso denegado 
find: /var/spool/cron/atspool: Permiso denegado
find: /var/lib/xdm/authdir: Permiso denegado
</example>

	<p>Fíjese en que <tt>find</tt> sólo encuentra ficheros que se
	  llaman <em>exactamente</em> <tt>XF86Config</tt>, en lugar de
	  ficheros que contienen esa secuencia de letras.  Además,
	  <tt>find</tt> intentó mirar en cada directorio del sistema,
	  incluidos algunos para los que usted no tenía permiso de
	  lectura.  De ahí los mensajes de "Permiso denegado".

	<p>La sintaxis también es diferente.  Tiene que especificar en
	  qué directorio buscar --- <tt>/</tt> --- mientras que
	  <tt>locate</tt> automáticamente escoge el directorio raíz.
	  Y tiene que especificar que la búsqueda es por nombre,
	  utilizando la opción <tt>-name</tt>.  También podría haber
	  buscado ficheros utilizando otros muchos otros criterios,
	  como la fecha de modificación o el propietario.  Para que
	  <prgn>find</prgn> busque ficheros cuyo nombre equivalga a
	  XF86Config, tiene que usar una expresión regular

<!-- FIXME xref -->

	: <tt>find / -name '*XF86Config*'</tt>

<!-- ARREGLAR : esto se parece sospechosamente a la utilización de -->
<!-- comodines más que a una expresión regular.  La forma correcta -->
<!-- (probablemente: comprobar sintaxis find) sería '.*XF86Config.*' -->
<!-- -->

	  Como muchas de las herramientas que se utilizan desde la
	  línea de instrucciones, <prgn>find</prgn> acepta expresiones
	  regulares como argumento.

	</enumlist>

	<p>En general, <tt>find</tt> es una utilidad más potente, y
	  <tt>locate</tt> es más rápido para las búsquedas cotidianas.
	  Explicar la lista completa de las posibles búsquedas
	  llevaría mucho tiempo; para más detalles escriba <tt>info
	  find</tt>, lo que le traerá las exhaustivas páginas info
	  sobre <tt>find</tt> y <tt>locate</tt>.

   <sect id="file_tools-file"> Determinar el contenido de un fichero

	<p>Debian viene con una utilidad que puede adivinar el
	  contenido de un archivo para usted.  No siempre acierta.
	  Sin embargo, es razonablemente exacta, y puede usarla para
	  explorar su sistema.

	<enumlist>

	  <item><tt>file /bin/cp</tt> <p> Debería ver algo parecido a
	    esto:

<example>
/bin/cp: ELF 32-bit LSB executable, Intel 80386, version 1, dynamically linked (uses shared libs), stripped
</example>

	    Saltándonos las partes técnicas, se trata de un archivo ejecutable
	    para máquinas Intel.

	  <item><tt>file /etc/init.d/reboot</tt><p>

<example>
/etc/init.d/reboot: Bourne shell script text
</example>

<!-- ARREGLAR : en el original, el ejemplo hace referencia a -->
<!-- /etc/init.d/boot, pero resulta que ese script no existe (al menos -->
<!-- en potato, o mi ordenador no debería arrancar en condiciones :) -->

	    Lo que quiere decir que se trata de un archivo de texto
	    que contiene un guión para la shell Bourne.

	</enumlist>

   <chapt id="disks"> <heading> Utilizar discos </heading>

     <sect id="disks-concepts"> Conceptos

	<p>Probablemente es buena idea explicar un poco de teoría
	  antes de entrar la mecánica de la utilización de los discos.
	  En particular, el concepto de <em>sistema de archivos</em>

<!-- ARREGLAR : en el original hay una nota sobre si en inglés se trata -->
<!-- de una sola palabra o de dos; "filesystem" vs. "file system".  En -->
<!-- español no tiene sentido -->

	  .  Es confuso, porque tiene varios significados.

	<list>

	  <item><em>El</em> sistema de ficheros se refiere a todo el
	    árbol de directorios, empezando con el directorio raíz
	    <tt>/</tt> como se ha descrito antes.

	  <item>Un "sistema de archivos" en general, significa
	    cualquier organización de archivos y directorios en un
	    dispositivo físico concreto.  "Organización" quiere decir
	    la estructura jerárquica de directorios, y cualquier otra
	    información sobre ficheros de la que se quiera estar al
	    tanto: su tamaño, quién tiene permiso para modificarlos,
	    etc.  De modo que usted puede tener un sistema de archivos
	    en su disco duro, y otro en cada disquete.

	  <item>"Sistema de archivos" también se utiliza para designar
	    una <em>clase</em> de sistema de ficheros.  Por ejemplo,
	    MS-DOS y Windows 3.1 organizan los archivos de un modo
	    concreto, con reglas particulares: los nombres de ficheros
	    sólo pueden tener 8 caracteres, por ejemplo, y no se
	    almacena información sobre permisos.  Linux le llama a
	    esto el sistema de archivos <tt>msdos</tt>.  Linux tiene
	    también su propio sistema de archivos, denominado sistema
	    de ficheros <tt>ext2</tt> (versión dos del sistema de
	    ficheros <tt>ext</tt>).  Usted utilizará el sistema de
	    archivos <tt>ext2</tt> prácticamente todo el tiempo, a
	    menos que esté accediendo a archivos procedentes de otros
	    sistemas operativos o que tenga otras necesidades
	    especiales.

	</list>

	<p>Cualquier dispositivo físico que desee utilizar para
	  almacenar ficheros debe tener al menos un sistema de
	  archivos en él.  Esto se refiere al segundo significado de
	  sistema de archivos: una jerarquía de ficheros y
	  directorios, junto con información sobre ellos.  Por
	  supuesto, cualquier sistema de archivos pertenece a una
	  clase, así que el tercer sentido también entra en escena.
	  Si tiene más de un sistema de archivos en un solo
	  dispositivo, cada sistema de archivos puede pertenecer a una
	  clase distinta; por ejemplo, puede tener una partición DOS
	  junto con una partición Linux en su disco duro.

	<p>Es importante distinguir el sistema de archivos del formato
	  de bajo nivel del disco.  En los mundos de DOS y Macintosh,
	  el sistema de archivos recibe el nombre de formato de alto
	  nivel.  Cuando formatea un disco utilizando uno de esos
	  sistemas operativos, generalmente da formato de bajo nivel y
	  también crea un sistema de archivos (formato de alto nivel).
	  En los sistemas GNU y Unix, se dice generalmente nada más
	  "formato" para referirse al formato de bajo nivel y "hacer
	  un sistema de archivos" para el formato de alto nivel.

	<p>Formatear tiene que ver con los pormenores del dispositivo
	  físico, tales como la exacta localización física de los
	  datos en un disquete (al borde o cerca del centro del disco,
	  por ejemplo).  El sistema de archivos es el nivel de
	  organización del que usted tiene que ocuparse: los nombres
	  de directorios y ficheros, sus tamaños, etc.

   </sect>

   <sect id="disks-mount"> <tt>mount</tt> y <tt>/etc/fstab</tt>

	<p>Esta sección describe cómo montar un disquete o un disco
	  Zip, el directorio <tt>/dev</tt>, y la distribución del
	  árbol de directorios sobre varias particiones o dispositivos
	  físicos.

   <sect1 id="disks-mount-mounting"> Montar un sistema de archivos

	<p>En un sistema GNU/Linux no existe una correspondencia
	  necesaria entre los directorios y los dispositivos físicos,
	  como sucede en Windows, donde cada unidad de almacenamiento
	  tiene su propio árbol de directorios que comienza con una
	  letra (como <tt>C:\</tt>).

	<p>En vez de eso, cada dispositivo físico, como un disco duro
	  o un disquete, tiene uno o más sistemas de ficheros en él.
	  Para hacer accesible un sistema de archivos concreto, se le
	  asigna un directorio particular en otro sistema de ficheros.
	  Para evitar círculos viciosos, el sistema raíz de archivos
	  (que contiene el directorio root, <tt>/</tt>) no se
	  encuentra en el interior de ningún otro sistema de archivos;
	  se accede a él automáticamente al arrancar Debian.

	<p>Un directorio en un sistema de archivos que contiene otro
	  sistema de archivos se conoce como <em>punto de
	  montaje</em>.  Un punto de montaje es un directorio en un
	  primer sistema de archivos en un dispositivo (como el disco
	  duro) que "contiene" un segundo sistema de archivos, quizá
	  en otro dispositivo (como un disquete).  Para acceder a un
	  sistema de archivos, es preciso montarlo en algún punto de
	  montaje.

	<p>Así que, por ejemplo, usted puede montar un CD en el punto
	  de montaje <tt>/cdrom</tt>.  Esto significa que si mira en
	  el directorio <tt>/cdrom</tt>, verá el contenido del CD.  El
	  directorio <tt>/cdrom</tt> en sí mismo se encuentra en
	  realidad en su disco duro.  A todos los efectos prácticos el
	  contenido del CD pasa a formar parte del sistema raíz de
	  archivos, y al escribir órdenes y utilizar programas la
	  localización física real de los ficheros no supone
	  diferencia alguna.  Podría haber creado un directorio en su
	  disco duro llamado <tt>/cdrom</tt>, y haber puesto algunos
	  ficheros en él, y todo se comportaría exactamente de la
	  misma manera.  Una vez que monta un sistema de archivos, no
	  hay necesidad de prestar atención a los dispositivos
	  físicos.

	<p>No obstante, antes de montar un sistema de ficheros, o de
	  crear de verdad un sistema de ficheros en un disco que aún
	  no tiene uno, es necesario referirse a los dispositivos
	  mismos.  Todos los dispositivos tienen nombres, y se
	  encuentran situados en el directorio <tt>/dev</tt>.  Si
	  ahora escribe <tt>ls /dev</tt>, verá una lista bastante
	  larga de cada posible dispositivo que podría tener en su
	  sistema Debian.

	   <footnote>(N. del T.: "device", dispositivo.)</footnote>

	<p>Los dispositivos posibles incluyen:

	  <footnote>Esta no es una lista exhaustiva.  Generalmente, la
	    documentación de un dispositivo o programa concretos le
	    dirán que nombre de dispositivo ha de utilizar.  Hay
	    cientos de nombres de dispositivo distintos.  Una lista
	    bastante completa (aunque no muy detallada) debería
	    hallarse en su sistema en el archivo
	    <tt>/usr/src/linux/Documentation/devices.txt</tt>.</footnote>

	<list>

	  <item><tt>/dev/hda</tt> es la unidad IDE A.  En general,
	    será un disco duro.  IDE hace referencia al tipo de
	    unidad; si no sabe lo que significa, probablemente tiene
	    esta clase de disco, porque es el más corriente.  Su
	    partición DOS/Windows <tt>C:\</tt> es probable que esté
	    aquí.

	  <item><tt>/dev/hdb</tt> es la unidad IDE B, como puede
	    suponer.  Podría ser un segundo disco duro, o puede que un
	    lector de CD-ROM.  Las unidades A y B son las unidades
	    primera y segunda (maestro y esclavo) del controlador
	    primario IDE.  Las unidades C y D son la unidad primera y
	    segunda del controlador secundario.

	  <item><tt>/dev/hda1</tt> es la primera partición de la
	    unidad IDE A, normalmente denominada <tt>C:\</tt> en los
	    sistemas DOS o Windows.  Fíjese en que las diferentes
	    unidades se designan mediante letras, mientras que las
	    particiones concretas de esas unidades además se numeran.

	  <item><tt>/dev/sda</tt> es el disco SCSI A.  SCSI es como
	    IDE, sólo que si no sabe lo que es, probablemente
	    <em>no</em> tiene una de estas unidades.  No son muy
	    comunes en los PC de Intel de particulares, aunque con
	    frecuencia se usan en servidores y Macintosh.

	    <footnote>Los dispositios SCSI tienen un sistema de
	      denominaciones más complejo que los dispositivos IDE,
	      principalmente debido a que SCSI tiene se utiliza de más
	      formas.  Las particiones de un disco SCSI tienen la
	      forma <tt>/dev/sda[1-9a-f]</tt>, esto es,
	      <tt>/dev/sda</tt> (o <tt>sdb</tt> o <tt>sdc</tt>, etc.)
	      seguido de un número o una letra de <tt>1--9</tt> o
	      <tt>a--f</tt>. <tt>/dev/scd0</tt> es el primer
	      dispositivo cd CDROM SCSI; los dispositivos generales
	      como los escáner, pueden aparecer como
	      <tt>/dev/sg0</tt>; <tt>/dev/st0</tt> es una unidad de
	      cinta SCSI.</footnote>

	  <item><tt>/dev/fd0</tt> es la primera disquetera,
	    generalmente <tt>A:\</tt> en DOS.  Puesto que los
	    disquetes no tienen particiones, sólo tienen números, en
	    lugar de la combinación letras--números empleada en los
	    discos duros.  Sin embargo, en las disqueteras los números
	    se refieren a la unidad, y en los discos duros los números
	    se refieren a las particiones.

	  <item><tt>/de/ttyS0</tt> es el primero de sus puertos de
	    serie (<tt>COM1:</tt> en DOS).  <tt>/dev</tt> contiene los
	    nombres de muchos dispositivos, no solamente unidades de
	    disco.

	</list>

	<p>Para montar un sistema de archivos, le tenemos que decir a
	  Linux que asocie cualquier sistema de archivos que encuentre
	  en un dispositivo concreto con un punto de montaje concreto.
	  En el proceso, puede que tengamos que informarle de qué
	  clase de sistema de archivos buscar.

   </sect1>

   <sect1 id="disks-mount-cdromexample"> Ejemplo: montar un CD-ROM

	<p>A modo de ejemplo básico, montaremos un CD-ROM, tal como el
	  que puede que haya usado para instalar Debian.  Precisará
	  ser root para hacer esto, así que tenga cuidado; siempre que
	  se es root se tiene el poder para estropear el sistema
	  entero, y no sólo los propios ficheros.  Además, estas
	  órdenes presumen que hay un CD en la unidad; debería poner
	  uno ahora.

	<enumlist>

	  <item><tt>su</tt><p>Si no lo ha hecho aún, necesita ingresar
	    como root u obtener privilegios de root con la instrucción
	    <tt>su</tt>

<!-- ARREGLAR : el original incluye entre paréntesis la expresión "super -->
<!-- user".  Creo que esto puede resultar malo para los novatos, -->
<!-- porque van a acostumbrarse a no utilizar su más que para root, y -->
<!-- van a desperdiciar formas de usar la imaginación: por ejemplo, -->
<!-- alguien que quiera tener cuentas de correo totalmente separadas -->
<!-- para correo personal y del trabajo -->
<!-- puede crear un usuario correo_xx e intercambiar con su.  Por -->
<!-- otro lado, tanto como "super user", su podría valer como "suid -->
<!-- user", mencionado por el propio autor, o mejor todavía, como -->
<!-- "substitute user", como aparece en el título de man e info. -->

	    .  Si utiliza <tt>su</tt>, introduzca la contraseña de
	    root cuando se le solicite.

	  <item><tt>ls /cdrom</tt> <p>Vea lo que hay en el directorio
	    <tt>/cdrom</tt> antes de comenzar.  Si no tiene un
	    directorio <tt>/cdrom</tt> puede crear uno con <tt>mkdir
	    /cdrom</tt>.

	  <item><tt>mount</tt> <p>Escribir <tt>mount/</tt> sin
	    argumentos lista los sistemas de archivos montados en este
	    momento.

	  <item><tt>mount -t iso9660 <var>dispositivo de CD</var>
	    /cdrom</tt> <p>En esta instrucción deberá sustituir la
	    expresión <tt><var>dispositivo de CD</var></tt> por el
	    nombre de su dispositivo de CD-ROM.  Si no está seguro
	    <tt>/dev/cdrom</tt> puede funcionar, puesto que el proceso
	    de instalación debería haber creado en el sistema este
	    enlace simbólico.  Si esto falla, pruebe los distintos
	    dispositivos IDE: <tt>/dev/hdb</tt>, <tt>/dev/hdc</tt>,
	    etc.  Debería ver un mensaje como éste:

<!-- ARREGLAR : el original dice sólo /dev/hdc.  Por razones obvias, -->
<!-- mejor incluir ambos. -->

<example>
mount: block device /dev/hdc is write-protected, mounting read-only
</example>

	<p>La opción <tt>-t</tt> especifica la clase de sistema de
	  archivos, en este caso <tt>iso9660</tt>.  La mayoría de los
	  CD son <tt>iso9660</tt>.  El siguiente argumento es el
	  nombre del dispositivo que se monta, y el último argumento
	  es el punto de montaje.  Hay muchos otros argumentos para
	  <tt>mount</tt>; vea la página de manual para más detalles.

	<p>Una vez que el CD está montado, descubrirá que la bandeja
	  de la unidad no se abre. Debe desmontar el CD antes de
	  retirarlo.

	<item><tt>ls /cdrom</tt> <p>Confirme que <tt>/cdrom</tt> ahora
	  contiene lo que sea que haya en el CD en la unidad.

	<item><tt>mount</tt> <p>Mire otra vez la lista de sistemas de
	  archivos, fijándose en que ahora la unidad de CD está
	  montada.

	<item> <tt>umount /cdrom</tt> <p>Esto desmonta el lector de
	  CD.  Ahora es seguro retirar el CD de la unidad.  Dése
	  cuenta de que la instrucción es <tt>umount</tt>, sin "n".

<!-- ARREGLAR: he suprimido un juego de palabras entre "umount" y -->
<!-- "unmount", imposible en español. -->

	<item><tt>exit</tt> <p>No permanezca como root en el sistema.
	  Abandónelo inmediatamente, sólo para estar seguro.

	</enumlist>

    </sect1>

    <sect1 id="disks-mount-fstab"> <tt>/etc/fstab</tt>: automatizar el
      proceso de montaje

	<p>El archivo <tt>/etc/fstab</tt> (procede de "file system
	  table"

	  <footnote>(N. del T.: tabla del sistema de
	    archivos.)</footnote>)

	  contiene las descripciones de los sistemas de archivos que
	  se montan con frecuencia.  Estos sistemas de ficheros pueden
	  montarse también con una orden más breve, como <tt>mount
	  /cdrom</tt>.  También puede configurar los sistemas de
	  archivos para que se monten automáticamente al arrancar el
	  sistema.  Probablemente querrá montar todos los sistemas de
	  archivos del disco duro al arrancar.

	<p>Mire ahora este fichero, escribiendo <tt>more
	  /etc/fstab</tt>.  Tendrá dos o más entradas que se
	  configuraron automáticamente al instalar el sistema.
	  Probablemente se parece a esto:

<example>
# /etc/fstab: static file system information.
#
# &lt;file system&gt     &lt;mount point&gt   &lt;type&gt  &lt;options&gt   &lt;dump &gt  &lt;pass&gt

/dev/hda1            /               ext2    defaults    0       1
/dev/hda3            none            swap    sw          0       0
proc                 /proc           proc    defaults    0       0

/dev/hda5            /tmp            ext2    defaults    0       2
/dev/hda6            /home           ext2    defaults    0       2
/dev/hda7            /usr            ext2    defaults    0       2

/dev/hdc             /cdrom          iso9660 ro,noauto   0       0
/dev/fd0             /floppy         auto    noauto,sync 0       0
</example>


	<p>La primera columna lista el dispositivo en el que reside el
	  sistema de archivos.  La segundas, el punto de montaje, la
	  tercera la clase de sistema de archivos.  La línea que
	  comienza con <tt>proc</tt> es un sistema de archivos
	  especial

<!-- explicado en FIXME xref -->

	  .  Fíjese en que la partición de intercambio
	  (<tt>/dev/hda3</tt> en el ejemplo) no tiene punto de
	  montaje, de modo que la columna de punto de montaje contiene
	  <tt>none</tt>

	  <footnote>(N. del T.: ninguno.)</footnote>.

	<p>Las últimas tres columnas requieren alguna explicación.

	<p>La quinta columna la usa la utilidad <tt>dump</tt> para
	  decidir cuándo hacer una copia de seguridad del sistema de
	  ficheros.  En la mayoría de los casos puede poner <tt>0</tt>
	  ahí.

<!-- FIXME xref dump/backup -->

	<p>La sexta columna la utiliza <tt>fsck</tt> para decidir en
	  qué orden comprueba los sistemas de ficheros al arrancar el
	  sistema.  El sistema raíz de archivos debería tener un
	  <tt>1</tt> en este campo, los sistemas de ficheros que no
	  necesitan ser comprobados (como la partición de intercambio)
	  deberían tener un <tt>0</tt>, y el resto de los sistemas de
	  archivos deberían tener un <tt>2</tt>.

<!-- FIXME referencia a <tt>fsck</tt> -->

	  Vale la pena darse cuenta de que la partición de intercambio
	  no es exactamente un sistema de archivos en el sentido de
	  que no contiene archivos ni directorios, sino que el kernel
	  Linux la utiliza como memoria secundaria.  No obstante,
	  debido a razones históricas, las particiones de intercambio
	  aún aparecen listadas en el mismo fichero que los sistemas
	  de archivos.

	<p>La cuarta columna contiene una o más opciones utilizadas
	  cuando se monta el sistema de archivos.  Aquí está un breve
	  resumen (algunas de ellas no tendrán aún mucho sentido para
	  usted; están aquí para futura referencia):
			    
	<taglist>

	  <tag> <tt>async</tt> y <tt>sync</tt> <item> Entrada y salida
	    (E/S) síncronas y asíncronas.  La E/S síncrona graba
	    inmediatamente los cambios en los archivos, mientras que
	    la E/S asíncrona puede mantener datos en espacios de
	    almacenamiento temporal y grabarlos después, por razones
	    de rendimiento.
				  
<!-- FIXME : referencia a la sección de sync para una explicación -->
<!-- completa.  Además, debería recomendar cuándo utilizar una o la -->
<!-- otra. -->
				  
	  <tag><tt>ro</tt> y <tt>rw</tt> <item> Monta el sistema de
	    archivos como de sólo lectura o de lectura y escritura.
	    Si no necesita modificar un sistema de archivos, es buena
	    idea montarlo como de sólo lectura, de modo que no pueda
	    estropear algo por accidente.  Además, los dispositivos de
	    sólo lectura (como los lectores de CD-ROM y disquetes con
	    pestañas de protección contra escritura) deberían montarse
	    como de sólo lectura.
				  
	    <footnote>(N. del T.: "ro" procede de "read only", sólo
	      lectura; "rw" de "read-write", lectura y
	      escritura.)</footnote>
				  
	  <tag><tt>auto</tt> y <tt>noauto</tt> <item>Al arrancar el
	    sistema, o al dar la orden <tt>mount -a</tt>,
	    <tt>mount</tt> intenta montar todos los sistemas de
	    ficheros que aparecen en la lista de <tt>/etc/fstab</tt>.
	    Si no quiere que monte automáticamente un sistema de
	    ficheros, deberá utilizar la opción <tt>noauto</tt>.
	    Probablemente, es buena idea usar <tt>noauto</tt> con los
	    dispositivos extraíbles, como los disquetes, porque puede
	    o puede no haber un disco en la unidad.  Esos dispositivos
	    se montan manualmente después de introducir el disco.
				  
	  <tag><tt>dev</tt> y <tt>nodev</tt> <item>Utilizar o ignorar
	    dispositivos de ficheros en este sistema de ficheros.
	    Puede usar <tt>nodev</tt> si monta el directorio raíz de
	    otro sistema en su sistema: no querrá que su sistema
	    intente usar los dispositivos de la otra máquina.
				  
	  <tag><tt>user</tt> y <tt>nouser</tt> <item>Permite o prohíbe
	    a los usuarios corrientes montar el sistema de archivos.
	    <tt>nouser</tt> significa que sólo el root puede montar el
	    sistema de ficheros.  Este es el sistema normal.  Puede
	    usar la opción <tt>user</tt> para acceder a la disquetera
	    sin necesidad de ser root.
				  
	  <tag><tt>exec</tt> y <tt>noexec</tt> <item>Permitir o no
	    permitir la ejecución de ficheros en este sistema de
	    archivos.  Probablemente no precisará estas opciones.
				  
	  <tag><tt>suid</tt> y <tt>nosuid</tt> <item>Permitir o no
	    permitir que funcione el bit suid.  Probablemente no
	    precisará estas opciones.
				  
	  <tag><tt>defaults</tt> <item>Equivale a: <tt>rw</tt>,
	    <tt>dev</tt>, <tt>suid</tt>, <tt>exec</tt>, <tt>auto</tt>,
	    <tt>nouser</tt>, <tt>async</tt>.  Puede especificar
	    <tt>defaults</tt> seguida de otras opciones que
	    invalidarán aspectos concretos de <tt>defaults</tt>.
				  
	</taglist>

    </sect1>

    <sect1 id="disks-mount-removable"> Discos extraíbles (disquetes,
      discos Zip, etc.)

	<p>Añad las líneas siguientes a su archivo
	  <tt>/etc/fstab</tt>:
			    
<example>
/dev/sda1  /mnt/zip  ext2    noauto,user     0 0
/dev/sda4  /mnt/dos  msdos   noauto,user     0 0
</example>

	  De ahora en adelante podrá montar discos Zip formateados
	  para DOS con la orden <tt>mount /mnt/dos</tt>, y discos Zip
	  formateados para Linux con la orden <tt>mount /mnt/zip</tt>.
			    
	  <footnote>Si tiene discos duros SCSI en el sistema, tendrá
	    que sustituir <tt>sda</tt> por <tt>sdb</tt> o
	    <tt>sdc</tt>, etc... en el ejemplo anterior.</footnote>

    </sect1>
			
<!-- FIXME : hay que escribir -->
<!-- <sect id="disks-preparing"> Preparar los discos para usar: -->
<!-- formatear y -->
<!-- crear un sistema de archivos -->
<!-- <p> -->
<!-- </sect> -->
			
<!-- <sect id="disks-lilo"> LILO -->
<!-- <p>Cómo configurarlo, nada más lo esencial -->

<!-- <chapt id="printers"> <heading> Utilizar impresoras </heading> -->
<!-- <sect id="printers-commands"> lpr y compañía -->
<!-- <p>lprm, lpc -->
<!-- ARREGLAR : yo añadiría cancel y lpq -->
<!-- <sect id="printers-setup"> Configurar impresoras -->

<!-- <chapt id="network"> <heading> Configurar la red </heading> -->
<!-- <p>(usuario individual con conexión telefónica o usuario -->
<!-- individual -->
<!-- con máquina de oficina. ¿Deberíamos cubrir alguna otra opción?) -->
<!-- <sect id="network-config"> Ficheros relevantes en /etc -->
<!-- <sect id="network-ethernet"> ethernet -->

    <sect id="network-ppp"><heading>PPP</heading>

    <sect1 id="network-ppp-introduction"> <heading> Introducción
     </heading>

     <p>Si se conecta a internet a través de una línea telefónica,
       tendrá que utilizar PPP (Point-To-Point Protocol)

       <footnote>(N. del T.: Protocolo Punto a Punto.)</footnote>.

       Este es el método estándar de conexión que ofrecen los PSI
       (Proveedores de Servicios de Internet)

       <footnote>(N. del T.: ISP, Internet Service
         Providers.)</footnote>.

       Además de usar PPP para telefonear a su PSI, puede hacer que su
       computadora escuche conexiones entrantes: esto le permite
       telefonear a su ordenador desde una localización remota

       <footnote>(N. del T.: remota se utiliza aquí en un sentido
         especial.  Si dos ordenadores se encuentran conectados,
         aunque sea en la misma habitación, el que se conecta al otro
         será la máquina "remota".)</footnote>

     <p>Esta sección es una guía rápida y sin florituras para
       configurar PPP en Debian.  Si necesitara más detalle, vea el
       excelente <url
       id="http://metalab.unc.edu/LDP/HOWTO/PPP-HOWTO.html" name="PPP
       CÓMO"> del Proyecto de Documentación de Linux.  El CÓMO entra
       en mucho más detalle, si está interesado o tiene necesidades
       específicas.

   <sect1 id="network-ppp-preparation"><heading>Preparativos</heading>

     <p>Configurar PPP en GNU/Linux es muy simple una vez que dispone
       de toda la información que necesita.  Debian hace incluso más
       fáciles las cosas con sus sencillas herramientas de
       configuración.

     <p>Antes de comenzar, asegúrese de tener toda la información
       facilitada por su PSI.  Esto incluirá:

       <list>

         <item>Nombre de usuario o ingreso

         <item>Contraseña

         <item>Su IP (Internet Protocol) estática, si la tiene (son
           semejantes a <tt>209.81.8.242</tt>)

         <item>Su máscara (será algo parecido a
           <tt>255.255.255.248</tt>)

           <footnote>(N. del T.: no se preocupe si nunca ha oído
             hablar de las dos anteriores.  Si se conecta vía
             telefónica, lo normal es que tenga IP dinámica, con lo
             que no necesitará estas especificaciones.)</footnote>

         <item>Las direcciones IP de los servidores de nombres del
           PSI

           <footnote>(N. del T.: los servidores de nombres suelen
             abreviarse en DNS, de "Domain Name Server", o Servidores
             de Nombres de Dominio.  Su función es convertir los
             nombres de dominio, como por ejemplo www.altavista.com,
             en su IP, KKKK.  Es probable que disponga de dos, que su
             PSI le indicará como DNS primario y DNS secundario.
             Anote cuál es cada uno.)</footnote>.

         <item>Cualquier procedimiento especial de ingreso requerido
           por el PSI.

       </list>

       <p>Después, deberá investigar la configuración de su equipo
         físico: si su módem funciona con GNU/Linux, y a qué puerto de
         serie está conectado.

       <p>Hay una regla muy simple para determinar si su módem
         funcionará.  Si es un "WinModem" o un "módem basado en
         sistema anfitrión"

         <footnote>(N. del T.: "host-based modem".)</footnote>,

         no funcionará.  Estos módems son baratos porque son muy
         limitados, y necesitan que la computadora supla sus
         deficiencias.  Desafortunadamente, esto significa que son
         complicados de programar, y los fabricantes no hacen públicas
         sus especificaciones para los desarrolladores.

       <p>Si tiene un módem con su propia circuitería integrada, no
         debería tener ningún problema.

       <p>En los sistemas GNU/Linux, los puertos de serie se denominan
         <tt>/dev/ttyS0</tt>, <tt>/dev/ttyS1</tt>, y así en adelante.
         Su módem está casi con seguridad conectado o al puerto 0 o al
         puerto 1, equivalentes a <tt>COM1:</tt> y <tt>COM2</tt> en
         Windows.  Si no sabe a cuál está conectado su módem,
         <tt>wvdialconf</tt> puede intentar detectarlo (vea más
         abajo); si no, simplemente pruebe ambos y vea cuál funciona

          <footnote>(N. del T.: en todo caso, si su módem no está
            conectado a uno de esos puertos no se preocupe.  Como todo
            depende del técnico que le haya instalado la máquina, es
            perfectamente posible encontrar el módem en <tt>COM4</tt>,
            esto es, <tt>/dev/ttyS03</tt>, por ejemplo.</footnote>.

	<p>Si quiere comunicarse con el módem o conectarse con su PSI
	  sin utilizar PPP, puede usar el programa <tt>minicom</tt>.
	  Necesitará instalar el paquete minicom para que este
	  programa esté disponible.

<!-- ARREGLAR : en toda esta sección no se menciona la necesidad de -->
<!-- que el kernel soporte PPP.  Considerando que viene (¿viene o -->
<!-- venía? comprobar) sin ese soporte, debería al menos comentarse -->
<!-- -->

    <sect1 id="network-ppp-wvdial"> <heading>El Camino Fácil:
     <tt>wvdial</tt> </heading>

	<p>La forma más sencilla de hacer funcionar PPP es utilizar el
	  programa <tt>wvdial</tt>.  Hace algunas conjeturas
	  razonables e intenta configurarle las cosas.  Si funciona,
	  ha tenido usted suerte.  Si se equivoca en sus suposiciones,
	  tendrá que hacer las cosas a mano.

	<p>Asegúrese de tener instalados los siguientes paquetes:

	<list>

	  <item><tt>ppp</tt>

	  <item><tt>ppp-pam</tt>

	  <item><tt>wvdial</tt>

	</list>

	<p>Al instalar el paquete <tt>wvdial</tt> se le dará la
	  oportunidad de configurarlo.  En caso de que no lo haya
	  hecho así, para configurar <tt>wvdial</tt> siga estas
	  sencillas instrucciones:

	<p>

	<enumlist>
			    
	  <item>Ingrese como root, utilizando <tt>su</tt>, como se
	    describe en un capítulo anterior.

	  <item><tt>touch /etc/wvdial.conf</tt><p><tt>touch</tt>
	    creará un archivo vacío si éste no existe; el programa de
	    configuración requiere que ese archivo exista.

	  <item><tt>wvdialconf /etc/wvdial.conf</tt><p>Esto quiere
	    decir que está usted creando un archivo de configuración,
	    <tt>/etc/wvdial.donf</tt>.

	  <item>Responda a todas las preguntas que aparezcan en la
	    pantalla. <tt>wvdialconf</tt> también examinará el sistema
	    en busca de su módem y le dirá en qué puerto serie se
	    encuentra; tome nota de él para futura referencia.

	  <item><tt>/etc/wvdial.conf</tt> ahora debería parecerse a
	    esto:

	  <p>

<example>
[Dialer Defaults]
Modem = /dev/ttyS1
Baud = 115200
Init1 = ATZ
Init2 = ATQ0 V1 E1 S0=0 S11=55 +FCLASS=0
; Phone = [El teléfono al que se conecta]
; Username = [Su nombre de usuario]
; Password = [Su contraseña]
</example>

	  <p>Simplemente sustituya la información entre corchetes con
	    los datos adecuados y borre los signos de punto y coma del
	    principio de esas líneas ¡y habrá terminado!  Un archivo completo
	    <tt>wvdial.conf</tt> debería parecerse a esto:

                <p>
<example>
[Dialer Defaults]
Modem = /dev/ttyS1
Baud = 115200
Init1 = ATZ
Init2 = ATQ0 V1 E1 S0=0 S11=55 +FCLASS=0        
Phone = 5551212
Username = beavis
Password = password
</example>

	</enumlist>

	<p>Ahora que <tt>wvdial.conf</tt> está configurado, para
	  conectarse a su PSI nada más escriba <tt>wvdial</tt>.  Si no
	  funciona, probablemente tendrá que proceder a configurar PPP
	  a mano.

    <sect1 id="network-ppp-pppd"><heading>Hacerlo
      manualmente</heading>

	<p>Esto tampoco es en absoluto difícil, aunque es ligeramente
	  más complicado que con <tt>wvdial</tt>.  El resumen rápido:
	  escriba <tt>pppconfig</tt> como root, responda a las
	  preguntas, después escriba <tt>pon</tt> para ingresar y
	  <tt>poff</tt> para cerrar la sesión.  No obstante,
	  profundizaremos un poco más.

<!-- FIXME <p> terminar de insertar todo lo de Iván -->

   <chapt id="dpkg"> <heading> Instalar y desinstalar software
     </heading>

   <sect id="dpkg-dpkg"> La utilidad de paquetes <prgn>dpkg</prgn>

<!-- FIXME ¿decir algo sobre ello? -->

   <sect id="dpkg-what"> Lo que hace una utilidad de mantenimiento de
     paquetes

	<p>Una aplicación o utilidad implica normalmente a unos
	  cuantos archivos.  Puede involucrar bibliotecas, archivos de
	  datos, como escenarios de juegos o iconos, archivos de
	  configuración, páginas de manual y documentación.  Al
	  instalar el programa, deberá asegurarse de tener todos
	  los archivos que precisa en el lugar correcto.

	<p>También querrá poder desinstalar el programa.  Al
	  desinstalar, se asegurará de que se borran todos los
	  archivos asociados.  Sin embargo, si un programa que aún
	  tiene en el sistema los necesita, querrá estar seguro de
	  conservarlos.

	<p>Por último, le gustaría ser capaz de actualizar un
	  programa.  Al actualizar, querrá borrar archivos obsoletos y
	  añadir otros nuevos, sin estropear nada en el sistema.

	<p>El sistema de paquetes de Debian resuelve estos problemas.
	  Le permite instalar, desinstalar y actualizar
	  <em>paquetes</em> de software, que son como pequeñas piezas
	  bien ajustadas que contienen los archivos de programas e
	  información que ayuda a la computadora a manejarlos
	  adecuadamente.  Los paquetes Debian tienen nombres que
	  terminan en <tt>.deb</tt>, y están disponibles en el sitio
	  ftp o en el CD-ROM oficial Debian.

<!-- FIXME: Hay que escribir...
<sect id="dpkt-ftp"> Conseguir los archivos
<p>Organización del sitio ftp, CD
<p>Mencionar los paquetes de non-US
<p>Describir las distribuciones estable e inestable
-->

   <sect id="dpkg-apt"> Apt

   <sect1 id="apt-config"> Configurar Apt

	<p>Debian proporciona ahora una herramienta llamada Apt (de "A
	  Package Tool")

	  <footnote>(N. del T.: Una Herramienta de
	    Paquetes.)</footnote>

	  para ayudar a los administradores a añadir o quitar software
	  más fácilmente.  Su primera tarea será personalizar el
	  archivo de configuración <tt>/etc/apt/sources.list</tt>.
	  Esta lista de fuentes de paquetes se utiliza para localizar
	  archivos del sistema de distribución de paquetes que se
	  utilizan en el sistema.  La lista de fuentes está diseñada
	  para admitir cualquier número de fuentes activas, y fuentes
	  de distinta naturaleza.  El archivo lista una fuente por
	  línea, en orden de preferencia.  El formato de una entrada
	  de <tt>sources.list</tt> es:

<example>deb uri distribution [component1] [component2] [...]</example>

	  La URI

	    <footnote>(N. del T.: URI procede de "Uniform Resource
	      Identifier", "Identificador Uniforme de
	      Recursos".)</footnote>


	  de la clase <tt>deb</tt> ha de especificar la base de la
	  distribución Debian, a partir de la cual APT encontrará la
	  información que necesita.  <tt>distribution</tt> puede
	  especificar un camino exacto, en cuyo caso han de omitirse
	  los componentes y la <tt>distribution</tt> debe terminar con
	  una barra (/).  Esto es útil cuando sólo interesa una
	  subsección concreta del archivo designado por la URI.  Si
	  <tt>distribution</tt> no señala un camino exacto, debe
	  aparecer al menos un componente.

	<p>Los tipos de URI reconocidos a día de hoy son cdrom, file,
	  http, y ftp.

	<taglist>

	  <tag><tt>file</tt><item> La clase <tt>file</tt>
	    permite que un directorio arbitrario del sistema de
	    ficheros se considere un archivo.  Es útil para sistemas
	    montados mediante NFS y espejos locales de archivos.

	    <footnote>(N. del T.: en éste y los párrafos siguientes,
	      se utiliza la palabra archivo en el sentido de fichero,
	      al igual que en el resto de esta Iniciación, pero sobre
	      todo, como repositorio unitario de paquetes
	      Debian.)</footnote>

	  <tag><tt>cdrom</tt><item>La clase <tt>cdrom</tt>
	    permite a APT utilizar una unidad local de CD-ROM con
	    varios CDs.  Utilice el programa apt-cdrom para crear las
	    entradas del CD-ROM en la lista de fuentes.

<!-- ARREGLAR : en el original hay una errata: "entires" por "entries" -->
<!-- -->

	  <tag><tt>http</tt><item>La clase http especifica un servidor
	    http como archivo.  Si la variable de entorno $http_proxy
	    está definida con el formato http://servidor:puerto/, se
	    utilizará el servidor proxy especificado en $http_proxy.
	    Los usuarios de proxys HTTP/1.1 con autenticación pueden
	    usar una cadena del formato
	    http://usuario:contraseña@servidor:puerto/.  Dése cuenta
	    de que éste es un método inseguro de autenticación.

	  <tag><tt>ftp</tt><item>La clase ftp designa un servidor FTP
	    para el archivo.  La conducta FTP de APT es muy
	    configurable; para más información vea la página de manual
	    de apt.conf(5).

	  <tag><tt>copy</tt><item>La clase copy es idéntica a la de
	    file excepto en que los paquetes se copian en el
	    directorio de caché en lugar de utilizarse directamente
	    donde se encuentran.  Es útil para quienes usan un disco
	    Zip para copiar archivos con APT.

	</taglist>

	<p>Algunos ejemplos:

<example>deb http://www.debian.org/archive stable main contrib</example>

	  Utiliza HTTP para acceder al archivo en www.debian.org, y
	  usa las áreas stable/main y stable/contrib.

<example>deb ftp://ftp.debian.org/debian unstable main contrib non-free</example>

	  Utiliza FTP para acceder al archivo en ftp.debian.org, en el
	  directorio /debian, y usa las áreas unstable/main,
	  unstable/contrib y unstable/non-free.

<example>deb ftp://ftp.debian.org/debian stable main</example>

	  Utiliza FTP para acceder al archivo en ftp.debian.org, en el
	  directorio /debian, y usa el área stable/main.

	<p>Si esta línea aparece junto con la del ejemplo anterior en
	  <tt>sources.list</tt>, se utilizará una sola sesión FTP para
	  ambas líneas.

<example>deb file:/home/vincent/debian stable main contrib
				non-free</example>

	  Utiliza el archivo localmente almacenado (o montado con NFS)
	  en /home/vincent/debian en stable/main, stable/contrib, y
	  stable/non-free.

<!-- FIXME : añadir un ejemplo con el método de acceso del CDROM -->

   <sect1 id="apt-usage"> Usar apt-get

	<p><tt>apt-get</tt> es la herramienta de la línea de
	  instrucciones para manejar paquetes, y puede considerarse
	  como la interfaz de usuario de apt. <tt>apt-get</tt> es
	  sencillísimo de usar.

	<p>

<example>
apt-get [opciones] [orden] [paquete ...]
</example>

	Donde <em>orden</em> es una de las siguientes:

	<taglist>

	<tag><tt>update</tt>

	  <footnote>(N. del T.: actualizar.)</footnote>

	<item>update se usa para poner al día los archivos que guardan
	  la información general de los paquetes usando sus fuentes
	  como referencia.  La información general de los paquetes
	  disponibles se va a buscar a la(s) localizaciones(s)
	  señaladas en <tt>/etc/apt/sources.list</tt>.  Por ejemplo,
	  al utilizar un archivo Debian, esta orden recupera y examina
	  los archivos Packages.gz, de modo que pone a su disposición
	  la información sobre paquetes nuevos y actualizados.
	  Siempre debería actualizarse con update antes de un
	  <tt>upgrade dist-upgrade</tt>.

	<tag><tt>upgrade</tt><item>upgrade se utiliza para instalar
	  las versiones más recientes de todos los paquetes
	  actualmente instalados en el sistema, tomándolas de las
	  fuentes enumeradas en <tt>/etc/apt/sources.list</tt>.  Se
	  recuperan y actualizan los paquetes instalados con nuevas
	  versiones disponibles; en ningún caso se desinstalan
	  paquetes instalados, ni se recuperan e instalan paquetes no
	  instalados.  Las paquetes actualmente instalados de los que
	  han aparecido nuevas versiones que no pueden ser
	  actualizadas sin cambiar el estado de instalación de otro
	  paquete se dejarán en su versión actual.  Debe
	  realizarse un <tt>apt-get update</tt> previo, para que
	  apt-get sepa qué nuevas versiones de los paquetes hay
	  disponibles.

	<tag><tt>dist-upgrade</tt><item><em>dist-upgrade</em>, además
	  de realizar la función de <em>upgrade</em>, se ocupa también
	  de cambiar las dependencias respecto de las nuevas versiones
	  de los paquetes; apt-get dispone de un sistema "inteligente"
	  de resolución de conflictos, e intentará actualizar los
	  paquetes más importantes a costa de los menos importantes si
	  fuera necesario.  El archivo <tt>/etc/apt/sources.list</tt>
	  contiene una lista de localizaciones desde el que recuperar
	  los paquetes deseados.

	<tag><tt>install</tt><item>A <em>install</em> le sigue el
	  nombre de uno o más paquetes cuya instalación desea.  Cada
	  paquete se designa con el nombre del paquete, no con el
	  nombre de fichero completo (por ejemplo, en un sistema
	  Debian GNU/Linux, el argumento sería <em>lsdo</em>, no
	  <em>ldso_1.9.6-2.deb</em>).  También se recuperarán e
	  instalarán todos los paquetes requeridos por los paquetes
	  especificados para su instalación.  Para localizar los
	  paquetes deseados se usa <tt>/etc/apt/sources.list</tt>.  Si
	  se añade un guión al nombre del paquete (sin espacio
	  intermedio), se desinstalará el paquete así identificado (si
	  está instalado).  Esta última característica puede
	  utilizarse para anular decisiones adoptadas por el sistema
	  de resolución de conflictos de <em>apt-get</em>.

	<tag><tt>remove</tt><item><em>remove</em> es idéntico a
	  <em>install</em>, excepto que desinstala los paquetes en
	  lugar de instalarlos.  Si se añade un signo más al nombre
	  del paquete (sin espacio intermedio), se instalará el
	  paquete así identificado.

	<tag><tt>clean</tt><item><em>clean</em> vacía el repositorio
	  local de paquetes recuperados.  Lo borra todo excepto el
	  fichero de cerrojo de <tt>/var/cache/apt/archives/</tt> y
	  <tt>/var/cache/apt/archives/partial/</tt>.

	</taglist>

	<p>Las opciones más útiles son:

	<taglist>

	  <tag><tt>-m</tt><item>Ignora los paquetes que falten, si hay
	    alguno.

	  <tag><tt>-d</tt><item>Descarga solamente paquetes
	    necesarios, pero no los instala.

	  <tag><tt>-f</tt><item>Arregla las dependencias rotas;
	    ejecute <tt>apt-get -f install</tt> para reparar
	    automágicamente los problemas de dependencias de su
	    sistema.

	</taglist>

<!-- ARREGLAR : aquí se ha perdido algo.

    <sect id="dpkg-dselect"> Utilizar dselect

-->

    <sect id="dpkg-commandline"> Utilizar dpkg manualmente

	<p>La forma más simple de instalar un solo paquete que haya
	  descargado es utilizar la orden <tt>dpkg -i</tt> (forma
	  breve de <tt>dpkg --install</tt>

	  <footnote>(N. del T.: instalar.)</footnote>

	  ).  Supongamos que ha descargado el paquete
	  <tt>icewm_0.8.12-1.deb</tt> y quiere instalarlo.  Primero
	  ingrese como root, después escriba:

<example>
dpkg -i icewm_0.8.12-1.deb
</example>

	  y se instalará la versión 0.8.12 de icewm.  Si ya tiene una
	  versión más antigua, dpkg la actualizará en lugar de
	  instalar ambas versiones simultáneamente.

	<p>Si quiere desinstalar un paquete, tiene dos opciones.  La
	  primera es más intuitiva:

<example>
dpkg -r icewm
</example>

	  Esto desinstalará el paquete icewm (<tt>-r</tt> es la forma
	  breve de <tt>--remove</tt>

	  <footnote>(N. del T.: quitar.)</footnote>).

	  Fíjese en que sólo se da "icewm" para <tt>--remove</tt>,
	  mientras que <tt>--install</tt> requiere el nombre completo
	  <tt>.deb</tt>.

	<p><tt>--remove</tt> dejará los archivos de configuración del
	  paquete en su sistema.  "Archivo de configuración" se define
	  como cualquier archivo que usted pueda haber editado para
	  personalizar el programa para su sistema o sus preferencias.
	  De este modo, si más tarde reinstala el paquete, no tendrá
	  que configurarlo todo por segunda vez.

	<p>No obstante, puede querer borrar también los archivos de
	  configuración, de modo que dpkg dispone de una opción
	  <tt>--purge</tt>

	  <footnote>(N. del T.: purgar.)</footnote>.
			    
	  <tt>dpkg --purge icewm</tt> borrará de forma permanente
	  hasta el último fichero asociado con el paquete icewm.

<!-- FIXME : Hay que escribir -->
<!-- <sect id="dpkg-compiling"> Compilar software por uno mismo -->
<!-- <p>Tiene que tener los paquetes -dev instalados. -->
<!-- <p>Ponga en un directorio en /usr/local, o en su directorio de -->

			    
<!-- usuario. -->
<!-- ARREGLAR : el original dice literalmente, en /usr/local o en -->
<!-- /opt; eliminado porque en Debian no hay /opt -->
			    
<!-- <p> El configure \-\-prefix; make; rutina make install. -->
			    
<!-- FIXME : Hay que escribir -->
<!-- <sect id="dpkg-proprietary"> Software licenciado no disponible en -->
<!-- formato .deb -->
<!-- <p>Qué hacer con este asunto tan desagradable (paquetes de -->
<!-- instalación, /usr/local) -->

   <chapt id="troubleshooting"> Resolución de problemas

   <sect id="troubleshooting-frozen"> ¡Debian se congela o falla!

	<p>Si su sistema Debian se congela, se debe posiblemente a un
	  error y el sistema ha fallado.  Sin embargo, es justo decir
	  que esto no sucede con mucha frecuencia; para mucha gente
	  funciona durante meses o incluso años sin un fallo, incluso
	  en uso intensivo.  GNU/Linux es extremadamente seguro.  Si
	  tiene problemas con cierta frecuencia, probablemente algo
	  marcha mal; pida ayuda (vea <ref id="docs-support">).

	    <footnote>(N. del T.: cuando el sistema se congela, todo
	    parece normal, sin embargo, ninguna de nuestras acciones
	    surte efecto.  Que el sistema se congele no es igual a que
	    el sistema se cuelgue; para saber por qué, siga
	    leyendo.)</footnote>

	<p>No obstante, es mucho más corriente que se congele la
	  pantalla debido a un fallo en el servidor X, en especial al
	  cambiar a y desde la consola virtual.  Es más probable que
	  esto lo hagan los servidores X más recientes, o que
	  simplemente fallen; es difícil para el proyecto XFree86
	  mantenerse al tanto de las últimas características de cada
	  tarjeta de vídeo disponible.

	<p>Si la pantalla se congela, <em>el sistema normalmente aún
	  permanecerá activo</em>, lo que sucede es que no se puede
	  interactuar con él desde la consola.  Si está en una red,
	  puede ingresar en él desde otra estación de trabajo.  Una
	  vez ingresado puede reiniciar de la forma correcta (por
	  ejemplo, escriba <tt>reboot</tt>).  Si no está en una red,
	  apretar <tt>C-A-Supr</tt> funcionará en la mayor parte de
	  las ocasiones.  Si ninguno de estos sistemas funciona,
	  tendrá que apagar el sistema y dejar que <tt>fsck</tt>
	  repare el disco en el próximo arranque.

    <sect id="troubleshooting-termgarbage"> Mi terminal no se comporta
      adecuadamente

	<p>A veces su terminal se atascará en el modo inverso de
	  vídeo, rehusará desplazarse a una nueva línea cuando aprieta
	  Intro, imprimirá caracteres extraños, o de algún otro modo
	  no funcionará como debe.  Casi siempre, este es el resultado
	  de intentar ver un archivo binario con <tt>cat</tt> o
	  <tt>more</tt> (a veces también lo causa un error en un
	  programa).  Puede intentar recuperarse introduciendo la
	  orden <tt>reset</tt>.  Si no hace nada, intente escribir
	  <tt>echo C-vESCc</tt> (esto es: apriete C-v, luego ESC,
	  luego 'c').  Si todo falla, abandone el sistema e ingrese de
	  nuevo.

	<p>El problema consiste en que las terminales se controlan con
	  unas <em>secuencias de control</em> especiales, que le dicen
	  que entre en modo inverso de vídeo, le dan la posición del
	  cursor, etc.  Si envía un archivo binario a la terminal, el
	  archivo puede que contenga estas secuencias de control.  Por
	  eso la terminal puede comportarse indebidamente.

    <sect id="troubleshooting-vi"> El ordenador pita cuando aprieto
      una tecla, y la pantalla muestra un archivo de texto y un montón
      de símbolos <tt>~</tt>.

	<p>Sin darse cuenta, se ha quedado atascado en <tt>vi</tt>.
	  Vea <ref id="editor-vi">.

   <chapt id="advanced"> <heading> Materias avanzadas

<!-- FIXME : Pregunta: -->
<!-- ¿Debería haber aquí temas avanzados?  Creo que estaría bien tener -->
<!-- algunos, sólo para explicar a la gente las posibilidades y darles -->
<!-- una explicación conceptual que no van a encontrar en un manual de -->
<!-- referencia.  Además, se disfruta llegar a un capítulo llamado -->
<!-- "Materias avanzadas".  La autoestima del novato da un subidón :) -->
<!-- -->
			      
<!-- FIXME : Hay que escribir -->
<!-- <sect id="advanced-scripting"> Introducción a los guiones de la -->
<!-- shell -->
<!-- <sect1 id="advanced-scripting-why"> Qué y por qué -->
<!-- <p>Automatizar tareas simples -->
<!-- <sect1 id="advanced-scripting-example"> Un ejemplo sencillo -->
<!-- <p>¿Ideas? -->

<!-- ARREGLAR : yo sugeriría hablar al menos del cuaderno de bitácora -->
<!-- del sistema y algunos aspectos prácticos de administración, como -->
<!-- el mantenimiento de un /usr/local, los paquetes -dev y la -->
<!-- compilación (general y del kernel), y un poco de las herramientas -->
<!-- de gestión de bibliotecas -->

    <sect id="advanced-files"> Gestión avanzada de ficheros

    <sect1 id="advanced-files-hardlinks"> La naturaleza real de los
      archivos: enlaces duros e ínodos

	<p>Cada archivo en el sistema está representado por un
	<em>ínodo</em>

	  <footnote>(N. del T.: en inglés "inode", de "Information
	    NODE", nodo de información.)</footnote>:

<!-- ARREGLAR : eliminada la referencia a la pronunciación, sin -->
<!-- sentido en español -->

	<p>Un ínodo contiene toda la información sobre el fichero.  No
	  obstante, el ínodo no se ve directamente.  En su lugar, cada
	  ínodo está enlazado al sistema de archivos por uno o más
	  <em>enlaces duros</em>.  Los enlaces duros contienen el
	  nombre del fichero, y el número del ínodo.  El ínodo
	  contiene al mismo archivo, esto es, la localización de la
	  información almacenada en el disco, sus permisos de acceso,
	  la clase de fichero y demás.  El sistema puede encontrar
	  cualquier ínodo puesto que tiene su número.

	<p>Un fichero individual puede tener más de un enlace duro.
	  Lo que esto quiere decir es que distintos nombres de archivo
	  se refieren al mismo archivo (es decir, están asociados al
	  mismo número de ínodo).  No obstante, no pueden establecerse
	  enlaces duros entre distintos sistemas de archivos: todas
	  las referencias duras a un archivo concreto (ínodo) deben
	  hallarse en el mismo sistema de archivos.  El motivo es que
	  cada sistema de ficheros tiene su propio conjunto de ínodos,
	  y puede haber números de ínodo duplicados entre sistemas de
	  archivos.

	<p>Puesto que todos los enlaces duros a un ínodo dado se
	  refieren <em>al mismo fichero</em>, se puede modificar el
	  fichero, refiriéndose a él por un nombre, y después ver esos
	  cambios refiriéndose a él por otro diferente.  Pruébelo:

	<enumlist>

	  <item> <tt>cd; echo "hola" &gt enlace1</tt>
	    <p> Vaya a su directorio de usuario y cree un fichero
	      llamado <tt>enlace1</tt> que contenga la palabra "hola".
	      Lo que ha hecho en realidad es redirigir la salida de
	      <tt>echo</tt> (<tt>echo</tt> simplemente devuelve lo que
	      se le da), colocando el resultado en
	      <tt>enlace1</tt>.  Vea el capítulo sobre las shells para
	      una explicación completa.

<!-- FIXME xref -->

	  <item> <tt>cat enlace1</tt>
	    <p> Compruebe el contenido de <tt>enlace1</tt>.

	  <item> <tt>ln enlace1 enlace2</tt> <p> Cree un enlace duro:
	    <tt>enlace2</tt> ahora apunta al mismo inodo que
	    <tt>enlace1</tt>.

	  <item> <tt>cat enlace2</tt>
	    <p> Compruebe que <tt>enlace2</tt> es el mismo que
	    <tt>enlace1</tt>.

	  <item> <tt>ls -l</tt>
	    <p> Fíjese en que el número de enlaces duros listados para
	    <tt>enlace1</tt> y <tt>enlace2</tt> es 2.

	  <item> <tt>echo "cambiar" &gt&gt enlace2</tt>
	    <p> Éste es otro truco de redirección de la shell; no se
	    preocupe por los detalles.  Hemos añadido la palabra
	    "cambiar" a <tt>enlace2</tt>.  Compruébelo con <tt>cat
	    enlace2</tt>.

	  <item> <tt>cat enlace1</tt>
	    <p> ¡También se ha añadido la palabra "cambiar" a
	    <tt>enlace1</tt>!  Esto se debe a que <tt>enlace1</tt> y
	    <tt>enlace2</tt> se refieren <em>al mismo fichero</em>.
	    No importa a cuál de ellos llame para modificarlo.

	  <item> <tt>chmod a+rwx enlace1</tt>
	    <p>Modifique los permisos de <tt>enlace1</tt>.  Escriba
	    <tt>ls -l</tt> para comprobar que los permisos de
	    <tt>enlace2</tt> también han cambiado.  Esto significa que
	    la información sobre los permisos se almacena en el ínodo,
	    no en los enlaces.

	  <item> <tt>rm enlace1</tt> <p>Borre este enlace.  Esta es
	    una sutileza de <tt>rm</tt>: en realidad borra enlaces, no
	    archivos.  Ahora escriba <tt>ls -l</tt> y fíjese en que
	    <tt>enlace2</tt> aún está ahí.  Dése cuenta también de que
	    el número de enlaces duros de <tt>enlace2</tt> se ha
	    reducido a uno.

	  <item> <tt>rm enlace2</tt>
	    <p>Borre el otro enlace.  Cuando no hay más enlaces a un
	    fichero, Linux borra el fichero mismo, esto es, su ínodo.

	</enumlist>

	<p>Todos los archivos funcionan así, incluso los especiales,
	  como los dispositivos (por ejemplo, <tt>/dev/hda</tt>).

	<p>Un directorio es simplemente una lista de nombres de
	  ficheros y números de ínodo, esto es, una lista de enlaces
	  duros.  Al crear un enlace duro, usted añade un par
	  nombre-número a un directorio.  Al borrar un fichero, está
	  borrando un enlace duro de un directorio.

    <sect1 id="advanced-files-types"> Clases de archivos

	<p>Una cuestión que hemos estado callando hasta ahora es que
	  el kernel Linux lo considera casi todo como un fichero.  Eso
	  incluye directorios y dispositivos: se trata simplemente de
	  clases especiales de ficheros.

	<p>Como recordará, el primer carácter de la información de
	  <tt>ls -l</tt> representa la clase del fichero.  Para un
	  archivo ordinario, será simplemente <tt>-</tt>.  Otras
	  posibilidades son:

	<list>

	  <item> <tt>d</tt> (directorio)

	  <item> <tt>l</tt> (enlace simbólico)

	  <item> <tt>b</tt> (dispositivo de bloque)

	  <item> <tt>c</tt> (dispositivo de carácter)

	  <item> <tt>p</tt> (tubería con nombre)

	  <item  <tt>s</tt> (socket)

	</list>

    <sect2 id="advanced-files-types-symlinks"> Enlaces simbólicos

	<p> Los enlaces simbólicos

	  <footnote>(N. del T.: "soft links", o también "symlinks".)</footnote>
	  
	  constituyen otra clase de enlace además de los enlaces
	  duros.  Un enlace simbólico es un archivo especial que
	  "apunta a" un enlace duro en cualquier sistema de archivos
	  montado.  Cuando intenta leer el contenido de un enlace
	  simbólico, éste le da el contenido del fichero al que apunta
	  en lugar del contenido del enlace simbólico en sí.  Puesto
	  que los directorios, dispositivos, y otros enlaces
	  simbólicos son tipos de archivos, un enlace simbólico puede
	  apuntar a cualquiera de ellos.

	<p>Por tanto, un enlace duro es un nombre de fichero y un
	  número de ínodo.  Un fichero es en realidad un ínodo: una
	  posición en el disco, clase de fichero, modo de permisos,
	  etc.  Un enlace simbólico es un ínodo que contiene el nombre
	  de un enlace duro.  Un enlace simbólico empareja un nombre
	  de fichero con un segundo nombre de fichero, mientras que un
	  enlace duro empareja un nombre de fichero con un número de
	  ínodo.

	<p>Todos los enlaces duros al mismo fichero tienen igual
	  estatus.  Esto es, uno es tan bueno como el otro; si lleva a
	  cabo cualquier operación en uno es exactamente igual que si
	  hubiera realizado esa operación en cualquiera de los otros.
	  Esto se debe a que los enlaces duros se refieren todos al
	  mismo ínodo.  Las operaciones sobre los enlaces simbólicos,
	  por otro lado, a veces afectan al propio ínodo del enlace
	  (el que contiene el nombre de un enlace duro) y a veces
	  afectan al enlace duro al que apuntan.

	<p>Hay algunas diferencias importantes entre los enlaces
	  simbólicos y los enlaces duros:

	<list>

	  <item>Los enlaces simbólicos pueden atravesar sistemas de
	    archivos.  Esto se debe a que contienen nombres de fichero
	    completos, que comienzan en el directorio raíz, y todos
	    los nombres completos de fichero son únicos.  Puesto que
	    los enlaces duros apuntan a números de ínodo, y los
	    números de ínodo sólo son únicos dentro de un sistema de
	    archivos individual, serían ambiguos si no se conociese el
	    sistema de archivos.

	  <item>Se pueden crear enlaces simbólicos a directorios, pero
	    no enlaces duros.  Cada directorio tiene enlaces duros ---
	    su listado en el directorio padre, su entrada <tt>.</tt>,
	    y la entrada <tt>..</tt> en cada uno de sus subdirectorios
	    ---, pero para establecer un orden en el sistema de
	    ficheros, no se permiten otros enlaces duros a los
	    directorios.  En consecuencia, el número de ficheros en un
	    directorio es igual al número de enlaces duros a ese
	    directorio menos dos (hay que quitar el nombre del
	    directorio y en enlace <tt>.</tt>).

	  <item>Sólo puede crearse un enlace duro a un fichero que
	    existe, porque ha de haber un número de ínodo al que
	    referirse.  Sin embargo, puede crearse un enlace simbólico
	    a cualquier nombre de fichero, exista o no en realidad tal
	    nombre de fichero.

	  <item>Borrar un enlace simbólico borra sólo en enlace.  No
	    tiene efecto en el archivo al que se enlaza.  Borrar el
	    único enlace duro a un fichero borra el fichero.

	</list>

	<p>Practique:

	<enumlist>

	  <item> <tt>cd; ln -s /tmp/yo MiTmp</tt> <p> <tt>cd</tt> a su
	    directorio de usuario. <tt>ln -s</tt>, con la opción
	    <tt>-s</tt>, crea un enlace simbólico; en este caso, uno
	    llamado <tt>MiTmp</tt>, que apunta al nombre de fichero
	    <tt>/tmp/yo</tt>.

	  <item> <tt>ls -l MiTmp</tt>
	     <p> El resultado debería parecerse a:

<example>
lrwxrwxrwx   1 havoc    havoc           7 Dec  6 12:50 MyTmp -> /tmp/yo
</example>

	    La fecha y los nombres de usuario y grupo serán
	    diferentes, por supuesto.  Fíjese en que la clase de
	    fichero es <tt>l</tt>, lo que indica que ese es un enlace
	    simbólico.  Fíjese también en los permisos: los enlaces
	    simbólicos siempre tienen esos permisos.  Si intenta hacer
	    <tt>chmod</tt> con un enlace simbólico, afectará en
	    realidad a los permisos del fichero al que apunta el
	    enlace.

	  <item> <tt>chmod 700 MiTmp</tt>
	    <p>Obtendrá un error: "chmod: MiTmp: No existe el fichero
	    o el directorio", porque el fichero <tt>/tmp/yo</tt> no
	    existe.  Fíjese en que, en cualquier caso, puede crear un
	    enlace simbólico que apunte a él.

	  <item> <tt>mkdir /tmp/yo</tt>
	    <p>Cree el directorio <tt>/tmp/yo</tt>.

	  <item> <tt>chmod 700 MiTmp</tt>
	    <p>Ahora debería funcionar.

	  <item> <tt>touch MiTmp/mifichero</tt>
	    <p>Cree un fichero en <tt>MiTmp</tt>.

	  <item> <tt>ls /tmp/yo</tt>
	    <p>En fichero se ha creado en realidad en
	    <tt>/tmp/yo</tt>.

	  <item> <tt>rm MiTmp</tt>
	    <p>Borre el enlace simbólico.  Fíjese en que esto borra el
	    enlace, no a lo que éste apunta.  Por tanto, utilice
	    <tt>rm</tt>, no <tt>rmdir</tt>.

	  <item> <tt>rm /tmp/yo/mifichero; rmdir /tmp/yo</tt>
	    <p>Dejemos las cosas en orden.

	</enumlist>

   </sect2>

   <sect2 id="files-misc-types-devices"> Archivos de dispositivo

	<p>Los archivos de dispositivo designan dispositivos físicos o
	  virtuales en su sistema, tales como el disco duro, la
	  tarjeta de vídeo, la pantalla, o el teclado.  Un ejemplo de
	  dispositivo virtual es la consola, representada por
	  <tt>/dev/console</tt>.

	<p>Hay dos clases de dispositivos: a los <em>dispositivos de
	  carácter</em> puede acceder un carácter por vez, esto es, la
	  unidad más pequeña de información que se puede escribir o
	  leer en o del dispositivo es un carácter (byte).

	<p>A los <em>dispositivos de bloque</em> se debe acceder en
	  unidades mayores denominadas bloques, que contienen un
	  cierto número de caracteres.  El disco duro es un
	  dispositivo de bloque.

	<p>Usted puede leer y escribir en los archivos de dispositivo
	  igual que puede hacerlo en las otras clases de archivos,
	  aunque el fichero bien puede contener un extraño galimatías
	  incomprensible para las personas.  Escribir datos al azar en
	  esos ficheros es probablemente una Mala Idea.  A veces
	  resulta útil, sin embargo: por ejemplo, puede volcar un
	  archivo postscript en el dispositivo de la impresora
	  <tt>/dev/lp0</tt>, o enviar órdenes de módem al archivo de
	  dispositivo del puerto de serie apropiado.

<!-- FIXME : Hay que escribir -->
<!-- <sect3 id="advanced-files-types-devices-creating"> Cómo crear -->
<!-- archivos de dispositivo. <p><tt>MAKEDEV</tt> -->
<!-- </sect3> -->

   <sect3 id="advanced-files-types-devices-null"> <tt>/dev/null</tt>

	<p> <tt>/dev/null</tt> es un archivo de dispositivo especial
	  que desecha cualquier cosa que se escriba en él.  Si no
	  quiere algo, arrójelo a <tt>/dev/null</tt>.  En esencia, es
	  un pozo sin fondo.  Si lee <tt>/dev/null</tt>, obtendrá
	  inmediatamente un carácter de fin de fichero (EOF)

	  <footnote>(N. del T.: End Of File.)</footnote>.

	<tt>/dev/zero</tt> es similar, sólo que si lo lee obtendrá el
	  carácter <tt>\0</tt> (que no es lo mismo que el número
	  cero).

    <sect2 id="advanced-files-types-pipes"> Tuberías con nombre

	<p>Una tubería con nombre es un archivo que actúa como una
	  tubería.  Se pone algo en el archivo, y sale por el otro
	  lado.  Por eso se le llama FIFO

	  <footnote>(N. del T.: First In First Out, un término común
	    también en economía, que puede traducir como Primera
	    Entrada Primera Salida, abreviado en PEPS.  Sin embargo,
	    se aceptan internacionalmente las iniciales
	    inglesas.)</footnote>,

	  lo primero que se pone en la tubería es lo primero que sale
	  por el otro lado.

	<p>Si se escribe algo en una tubería con nombre, el proceso
	  que espera a la tubería no terminará hasta que la
	  información que se escribe sea leída desde la tubería.  Si
	  lee una tubería con nombre, el proceso de lectura esperará
	  hasta que haya algo que leer antes de terminar.  El tamaño
	  del fichero es siempre cero: no almacena datos, se limita a
	  unir dos procesos igual que el <tt>|</tt> de la shell. Sin
	  embargo, dado que esta tubería tiene un nombre, los dos
	  procesos no tienen por qué estar en la misma línea de
	  instrucciones o incluso ser ejecutados por el mismo usuario.

	<p>Puede ensayarlo haciendo lo siguiente:

	<enumlist>

	  <item> <tt>cd; mkfifo mituberia</tt> <p>Cree la tubería.

	  <item> <tt>echo "hola" > mituberia &</tt> <p>Ponga un
	    proceso en segundo plano que intente escribir "hola" en la
	    tubería.  Fíjese en que el proceso no sale del segundo
	    plano; está esperando a que alguien lea la tubería.

	  <item> <tt>cat mituberia</tt> <p>En este punto el proceso
	    <tt>echo</tt> debería volver, puesto que <tt>cat</tt> ha
	    leído la tubería, y el proceso <tt>cat</tt> imprimirá
	    <tt>hola</tt>.

	  <item> <tt>rm mituberia</tt> <p>Puede borrar las tuberías
	    exactamente igual que cualquier otro fichero.

	</enumlist>

   </sect2>

   <sect2 id="advanced-files-types-sockets">  Sockets

	<p> Los sockets son semejantes a las tuberías, sólo que funcionan
	  sobre la red.  Así es como su computadora se conecta a las
	  redes: puede que haya oído hablar de "WinSock", que son sockets
	  para Windows.

	<p>No vamos a profundizar más en ellos, porque probablemente
	  no tendrá ocasión de utilizarlos a no ser que programe.  No
	  obstante, si ve un fichero del tipo <tt>s</tt> en su
	  ordenador, sabrá qué es.

   </sect2>

   </sect1>

   <sect1 id="advanced-files-proc"> El sistema de archivos
     <tt>proc</tt>

	<p>El kernel Linux pone a nuestra disposición un sistema de
	  archivos especial, montado en <tt>/proc</tt> en los
	  sistemas Debian.  Es un "pseudo sistema de archivos": en
	  realidad no existe en ninguno de los dispositivos físicos.

	<p>El sistema de archivos <tt>/proc</tt> contiene información
	  sobre el sistema y los procesos en ejecución.  Algunos de
	  los "ficheros" de <tt>/proc</tt> son razonablemente
	  comprensibles para las personas (escriba <tt>cat
	  /proc/meminfo</tt> o <tt>cat /proc/cpuinfo</tt>) mientras
	  que algunos otros son arcanas colecciones de números.  Con
	  frecuencia, las utilidades del sistema los emplean para
	  obtener información y presentársela en forma más
	  comprensible.

	<p>La gente se asusta con frecuencia al descubrir un archivo
	  en concreto --- <tt>/proc/kcore</tt> ---, que es por lo
	  general enorme.  Es (más o menos) una copia del contenido de
	  la memoria de su ordenador.  Se utiliza para depurar el
	  kernel.  En realidad no existe en ninguna parte, así que no
	  se preocupe por su tamaño.

	<p>Si quiere saber acerca de todo lo que hay en
	  <tt>/proc</tt>, escriba <tt> man 5 proc</tt>.

   </sect1>

   <sect1 id="advanced-files-permissions"> Aspectos avanzados de los
     permisos de ficheros

   <sect2 id="advanced-files-permissions-absolute"> Utilizar
     argumentos numéricos con <tt>chmod</tt>

	<p>Previamente en este capítulo, mencionamos brevemente que se
	  podían establecer los permisos de fichero usando números.
	  La notación numérica se denomina modo absoluto, como opuesta
	  a la notación simbólica (por ejemplo, <tt>u+rx</tt>), que se
	  denomina con frecuencia modo relativo.  Esto se debe a que
	  el número especifica el modo exacto que debe establecerse, y
	  el símbolo solamente señala el cambio que debe introducirse
	  (por ejemplo, "añadir permisos de lectura y ejecución para
	  el usuario").

	<p>El modo numérico consiste en un número octal de cuatro
	  dígitos o binario de veinte dígitos.  Cada número octal
	  (base ocho) representa tres dígitos binarios: un dígito
	  octal y tres binarios son dos formas de representar los
	  dígitos decimales de 0 a 7.

	<p>Designar un modo concreto es bastante sencillo.
	  Simplemente se añaden los modos que se quieren combinar, o
	  se sustraen los que no se quieren.  Por ejemplo, los
	  permisos del usuario, con sólo el permiso de lectura
	  activado, serían <tt>100</tt> en binario.  Los permisos del
	  usuario con escritura solamente sería el binario
	  <tt>010</tt>.  Los permisos del usuario con ambas lectura y
	  escritura activadas serían <tt>100 + 10 = 110</tt>.
	  Alternativamente, puede escribirlo en octal: <tt>4 + 2 =
	  6</tt>.

	<p>Para el modo completo, simplemente añada los dígitos de
	  esta tabla:

<example>
0001        otros, ejecución
0002        otros, escritura
0004        otros, lectura
0010        grupo, ejecución
0020        grupo, escritura
0040        grupo, lectura
0100        usuario, ejecución
0200        usuario, escritura
0400        usuario, lectura
1000        sticky bit
2000        establecer la ID del grupo (SETGID)
4000        establecer la ID del usuario (SETUID)
</example>

	<p>Para utilizar la tabla, decida primero qué permisos quiere
	  establecer.  Después sume los números para esos permisos.
	  El total es su modo.  Por ejemplo, para obtener el modo
	  <tt>0755</tt>:

<example>
  0001   o=x
  0004   o=r
  0010   g=x 
  0040   g=r
  0100   u=x
  0200   u=w
+ 0400   u=r
-------
  0755  u=rwx go=rw
</example>

	<p>En realidad, este modo se llama simplemente <tt>755</tt>,
	  sin el <tt>0</tt> inicial, porque <tt>chmod</tt> añade
	  automáticamente ceros al principio del modo: <tt>7</tt>
	  significa el modo <tt>0007</tt>.

	<p>Para establecer los permisos <tt>755</tt> para un fichero,
	  escriba <tt>chmod 755 mifichero</tt>.

	<p>El modo <tt>755</tt> es muy común para los directorios,
	  puesto que permite a cualquiera utilizar el directorio, pero
	  sólo al propietario crear y borrar ficheros en
	  él. <tt>644</tt> es el modo análogo para los archivos, y es
	  también muy común.  Permite a cualquiera utilizar el
	  archivo, pero sólo el propietario puede modificarlo.  Para
	  los ejecutables, <tt>755</tt> es un modo habitual; es
	  solamente <tt>644</tt> junto con los permisos de ejecución
	  (<tt>644 + 111 = 755</tt>).

    </sect2>

<!-- FIXME : Hay que escribir -->
<!-- <sect2 id="advanced-files-permission-suid"> Ficheros SUID y SGID  -->
<!-- <p> -->
<!-- </sect2> -->

<!-- <sect2 id="advanced-files-permissiones-sticky"> Establecer el -->
<!-- sticky bit -->
<!-- <p> -->
<!-- </sect2> -->

   </sect1>

   <sect1 id="advanced-files-chattr"> chattr

<!-- FIXME : Hay que escribirlo
	<p>¿Algún consejo útil?

   <sect1 id="advanced-files-copying"> Copiar a gran escala

	<p>cp -a y variantes sobre el tema.

	<p>Cómo copiar un viejo sistema en uno nuevo.
	
	<p>FIXME vaya, también he listado este tema en Herramientas de
	  Backup.  Necesito decidir.

-->

<!-- FIXME :

   <sect1 id="advanced-files-undocumented"> Otros conceptos que aún no
     están cubiertos, pero deberían estarlo

	<p>fsck, dd, fdisk, etc.

	<p>¿En qué paquete se encuentra un archivo?

	<p>Archivos de texto de MSDOS contra Mac contra Unix.

  </sect1>

-->

   <sect id="advanced-kernel">Compilar el kernel
	<p>Cómo, qué y por qué.

   <sect id="advanced-security"> Algunas palabras sobre la seguridad

	<p>Lo esencial de la seguridad desde el punto de vista del
	  usuario.  Mantener la propia privacidad.  Lo que otros
	  usuarios pueden ver de su cuenta.

   <sect id="advanced-programming"> Programar en Linux

	<p>Algo sobre el entorno de programación de Linux.  Dirigido a
	  gente, digamos, que esté siguiendo el CS101.  Nada sobre
	  <em>cómo</em> programar, solamente Emacs, gcc, gdb, ddd,
	  etc. como herramientas de programación.

<!-- ARREGLAR : ¿qué es el CS101? -->

	<p>Probablemente basado en debug.tex.

   <chapt id="next"> <heading> ¿Desde aquí, adónde? </heading>

   <sect id="next-manuals"> Otros manuales Debian

   <sect id="next-resources"> Otros recursos

	<p>Algunas buenas URL, direcciones a meta-documentos.

   <chapt id="helping"> <heading> Contribuir a Debian: ¿Cómo puedo
     ayudar? </heading>

   <sect id="helping-bugs"> Enviar informes sobre fallos

	<p>Cómo hacerlo con el paquete "bug".

   <sect id="helping-other"> Otras cosas

	<p>Lo que sea que queramos decir aquí.

   <appendix id="apps_appendix"> <heading> Un breve examen de
     aplicaciones disponibles </heading>

	<p>(¿Será esto útil? ¿O hace dselect realmente el trabajo?
	  Parece que hay un número significativo de usuarios de Debian
	  que preguntas en grupos de noticias del tipo "Estoy buscando
	  una aplicación que haga X".  Podríamos limitarnos a listar
	  lo que existe, más o menos, puede que recomendar una opción
	  sobre otra cuando se trata de una elección obvia.)

   <sect id="A_apps-whatever"> (Los encabezamientos podrían copiar la
    estructura del sistema de menúes)

   </appendix>

   <appendix id="components_appendix"> <heading> Resumen de los
     componentes del sistema GNU/Linux </heading>
<p>
<example>

 Gestor de ventanas - Programas/Bibliotecas Gnome (en desarrollo)
 |   |	    ----------/                     \
 |   |     /                                 ---------\
 | Clientes X       Progrmas/Aplicaciones ---- Bibliotecas compartidas
 |   |   \                    |                 /
  \  |    ---------------\    |     /-----------       
 Servidor X ------------- Kernel Linux 
      |                   /    |
      |   /---------------     |
 Tarjeta de Vídeo --- Otro equipo físico (memoria, disco, etc.)

</example>

	<p>Fíjese en que el servidor X y los clientes X <em>son</em>
	  aplicaciones, pero son aplicaciones que interactúan de un
	  modo especial con el hardware de vídeo y otras
	  aplicaciones.

	<p>El gestor de ventanas es un cliente X especial, y por tanto
	  también una aplicación.  Todos los programas X utilizan las
	  bibliotecas compartidas, pero ninguna línea aparece en el
	  diagrama.

	<p>Cuando se complete el proyecto GNOME (GNU Network Object
	  Model Environment), ayudará a unificar el entorno X con un
	  conjunto especial de programas y bibliotecas, interactuando
	  con el gestor de ventanas y otros clientes X.

	<p>Las utilidades GNU son programas pequeños que realizan
	  tareas sencillas: <tt>mv</tt>, <tt>cp</tt>, <tt>tar</tt>,
	  por ejemplo.

<!-- ARREGLAR : no sé si esto acaba de cuadrar aquí... -->

   </appendix>

   <appendix id="booting_appendix"> <heading>Appendix C: Arrancar el
     sistema </heading>

	<p>

<!-- FIXME esta sección requiere de verdad averiguar exactamente qué -->
<!-- opciones ofrecen los discos de instalación, y cómo los discos de -->
<!-- instalación formulan las cosas: "Arranque desde el disco duro", -->
<!-- "cree un disquete", etc. -->

<!-- FIXME la verdad es que ya han descubierto cómo arrancar, puesto -->
<!-- que es parte de la instalación, así que quizá quitar esta sección -->
<!-- por entero; en cualquier caso es demasiado larga -->

	<p>Este apéndice describe lo que sucede durante el proceso de
	  arranque de GNU/Linux.

	<p>Cómo arranca usted su sistema depende de cómo configuró las
	  cosas cuando instaló Debian.  Lo más probable es que
	  simplemente encienda el ordenador.  Pero puede que tenga que
	  insertar un disquete primero.

	<p>A Linux lo carga un programa llamado LILO o LInux LOader

	  <footnote>(N. del T.: cargador de Linux.)</footnote>.

	  LILO también puede cargar otros sistemas operativos, y le
	  pregunta qué sistema le gustaría cargar.

	<p>Lo primero que sucede cuando enciende un PC de Intel es que
	  se ejecuta la BIOS.  BIOS procede de Basic Input Output
	  System

	  <footnote>(N. del T.: Sistema Básico de
	    Entrada/Salida.)</footnote>.

	  Se trata de un programa almacenado de forma permanente en la
	  computadora en chips de sólo lectura.  Realiza unas
	  comprobaciones mínimas, y después busca un disquete en la
	  primera unidad de disco.  Si lo encuentra, busca un "sector
	  de arranque" en el disco, y comienza a ejecutar su código,
	  si lo hay.  Si hay un disco, pero sin sector de arranque, la
	  BIOS imprimirá un mensaje parecido a éste:

<!-- ARREGLAR : esto no es totalmente cierto.  Las BIOS suelen poder -->
<!-- configurarse para cambiar el orden de la unidad de arranque -->

<example>
Non-system disk or disk error
</example>

	  Quitar el disco y apretar una tecla hará que el proceso de
	  arranque continúe.

	<p>Si no hay disquete en la unidad, la BIOS busca un registro
	  maestro de arranque

	  <footnote>(N. del T.: "master boot record", MBR.)</footnote>

	  en el disco duro.  Comenzará a ejecutar el código encontrado
	  ahí, que carga el sistema operativo.  En los sistemas
	  GNU/Linux, LILO, el cargador de Linux, puede ocupar el MBR,
	  y cargará GNU/Linux.

	<p>Por lo tanto, si eligió instalar LILO en su disco duro,
	  debería ver la palabra LILO al arrancar su computadora.  En
	  este punto puede apretar la tecla <tt>Mays</tt> izquierda
	  para seleccionar el sistema operativo que cargar; apriete
	  <tt>TAB</tt> para ver una lista de opciones.  Escriba una de
	  esas opciones y apriete Intro.  LILO arrancará el sistema
	  operativo solicitado.

	<p>Si no aprieta la tecla <tt>Mays</tt>, LILO cargará
	  automáticamente el sistema operativo por defecto después de
	  unos 5 segundos.  Si quiere, puede cambiar qué sistema
	  operativo LILO carga automáticamente, qué sistemas sabe cómo
	  cargar, y cuánto espera antes de cargar uno automáticamente.

<!-- vea FIXME referencia -->.

	<p>Si no ha instalado LILO en su disco duro, probablemente ha
	  creado un <em>disco de arranque</em>.  El disco de arranque
	  tendrá LILO en él.  Todo lo que tiene que hacer es insertar
	  el disco antes de encender el ordenador, y la BIOS lo
	  encontrará antes de comprobar el MBR del disco duro.  Para
	  voler a un sistema operativo distinto de Linux, saque el
	  disco de arranque y reinicie el ordenador (desde Linux,
	  asegúrese de seguir el procedimiento apropiado para
	  reiniciar: vea <ref id="start-shutdown"> para más detalles.)

	<p>LILO carga el kernel Linux del disco, y después deja que el
	  kernel tome el control.  (El kernel es el programa central
	  del sistema operativo, que controla a todos los demás
	  programas.)  El kernel descarta la BIOS y LILO.

	<p>En plataformas distintas de Intel, las cosas funcionan de
	  modo un poco distinto.  Pero una vez que inicia, todo será
	  más o menos lo mismo.

	<p>Linux examina el tipo de equipo físico en el que se está
	  ejecutando.  Quiere saber qué tipo de discos duros tiene
	  usted, si tiene o no un ratón con el protocolo BusMouse, si
	  está o no en una red, y otras trivialidades semejantes.
	  Linux no puede recordar las cosas entre arranques, de modo
	  que tiene que hacer estas preguntas cada vez que se inicia.
	  Afortunadamente, estas preguntas no se las hace a
	  <em>usted</em>; ¡le pregunta al equipo físico!  Mientras
	  arranca, el kernel Linux imprimirá mensajes en la pantalla
	  que describen lo que está haciendo.

	<p>El proceso de información puede ocasionar problemas con su
	  sistema, pero si fuera a hacerlo, lo habría hecho cuando
	  instaló GNU/Linux por primera vez.  Si está teniendo
	  problemas, consulte las instrucciones de instalación, o
	  pregunte en una lista de correo.

	<p>El kernel simplemente maneja otros programas, de modo que
	  una vez que decide que todo está bien y está satisfecho,
	  debe iniciar otro programa para hacer algo útil.  El
	  programa que inicia el kernel se llama <prgn>init</prgn>.
	  Después de que el kernel inicia <prgn>init</prgn>, nunca
	  inicia otro programa.  El kernel se convierte en gestor y
	  proveedor de servicios.

	<p>Una vez que se inicia <prgn>init</prgn>, ejecuta un cierto
	  número de guiones (ficheros que contienen instrucciones),
	  que preparan el sistema para su uso: llevan a cabo ciertas
	  rutinas de mantenimiento y arrancan un montón de programas
	  que hacen cosas como mostrar un prompt de ingreso, esperar
	  conexiones de red, y mantener un registro de la actividad de
	  la computadora.

<!-- FIXME describir aquí los guiones de arranque -->

   </appendix>

   <appendix id="misc_appendix"> <heading> Miscelánea </heading>

	<p>Este capítulo contiene información interesante que no
	  encajaba en el resto del manual, como apuntes históricos.
	  Puede ser incluida en otro manual en el futuro, o rehecha
	  para formar un capítulo coherente.

   <sect id="unix-history"> Historia de Unix

	<p>En 1969, los Laboratorios de Telefonía Bell (Bell Labs, una
	  división de AT&amp T) estaban trabajando con la General
	  Electric y el Proyecto MAC del MIT para escribir un sistema
	  operativo llamado Multics.  Para abreviar un poco una larga
	  historia, los Laboratorios Bell decidieron que el proyecto
	  no estaba yendo a ninguna parte y se separaron del grupo.
	  Esto dejó a los Laboratorios Bell sin un buen sistema
	  operativo.

	<p>Ken Thompson y Dennis Ritchie decidieron bosquejar un
	  sistema operativo que satisficiera sus necesidades.  Los
	  Laboratorios Bell tenían una computadora PDP-7 que no se
	  utilizaba, y que Thompson quería poner en funcionamiento, de
	  modo que implementó el sistema que había diseñado en aquella
	  máquina.  Como juego de palabras con Multics, Brian
	  Kerninghan, otro investigador de los Laboratorios Bell, dio
	  al sistema el nombre de Unix.  El grupo consiguió fondos
	  para comprar una computadora mejor, una PDP-11, proponiendo
	  un plan para escribir un sistema de proceso de textos.  En
	  lugar de escribir el procesador de textos desde el
	  principio, hicieron una aplicación que se ejecutaba en Unix,
	  al que portaron al PDP-11.

	<p>Más tarde, Dennis Ritchie inventó el lenguaje de
	  programación "C".  En 1973, se reescribió Unix en C en lugar
	  del lenguaje ensamblador original.

	  <footnote>"Lenguaje Ensamblador" es un lenguaje informático
	    muy básico que está ligado a un tipo determinado de
	    computador.  Normalmente se considera un desafío programar
	    en él.</footnote>

	  En 1977, Unix se trasladó a una nueva máquina mediante un
	  proceso de adaptación

	    <footnote>(N. del T.: "porting".)</footnote>

	  , fuera de las máquinas PDP en las se había ejecutado
	  previamente.  Facilitó el hecho el que Unix estuviera
	  escrito en C, puesto que buena parte del código pudo
	  simplemente ser recompilado y no hubo que reescribirlo.

	<p>A finales de los 70, a AT&amp T se le prohibió competir en
	  la industria informática, así que concedió licencias de Unix
	  a varias facultades y universidades a muy bajo precio.
	  Tardó en extenderse fuera de las instituciones académicas,
	  pero se hizo finalmente también popular entre las empresas.
	  El Unix de hoy es diferente del Unix de 1970.  Tiene dos
	  variantes principales: System V, de los Unix System
	  Laboratories (USL), una filial de SCO

	  <footnote>Previamente, USL perteneció a AT&amp T y más tarde
	    a Novell</footnote>,

	  y la Berkeley Software Distribution (BSD).  La versión de USL
	  marcha ahora por la cuarta entrega, o SVR4

	  <footnote>Un modo críptico de decir "System Five, Release
	    Four".

	    <footnote>(N. del T.: "Sistema V, Cuarta
	      Entrega".)</footnote>

	  </footnote>, mientras que la última versión de BSD es la
4.4.  Sin embargo, hay muchas versiones diferentes de Unix además de
esas dos.  La mayoría de las versiones registradas de Unix que se usan
en la realidad incorporan normalmente características de ambas
variantes.

	<p>Las versiones registradas actuales de Unix para los PC de
	  Intel cuestan entre 500 y 2.000 dólares, con la excepción de
	  Solaris x86, que ha sido machacada por los clones gratuitos
	  de Unix y obligada a reducir los precios.

   <sect>Historia de GNU/Linux

	<p>Debian hunde sus raíces en la fundación del Proyecto GNU en
	  1984 por Richard M. Stallman.  GNU (GNU's Not Unix)

	  <footnote>(N. del T.: GNU No Es Unix.)</footnote>

	  es un proyecto de la Fundación para el Software Libre; su
	  objetivo era y es sustituir el sistema operativo Unix con
	  software libre.  Había escrito un sistema operativo casi
	  entero a principios de los 90, pero faltaba el kernel.
	  Afortunadamente, Linux apareció para llenar este vacío.

	<p>El autor principal del kernel Linux es Linus Thorvalds.
	  Desde su versión original, ha sido mejorado por un
	  incontable número de personas de todo el mundo.  Es un clon,
	  escrito enteramente desde cero, del sistema operativo Unix.
	  Ni USL, ni la Universidad de California, Berkeley,
	  estuvieron implicados en la escritura de Linux.  Uno de los
	  hechos más interesantes sobre Linux es que su desarrollo se
	  produce simultáneamente en todo el mundo.  Gente desde
	  Australia a Finlandia ha contribuido a Linux, y es de
	  esperar que lo siga haciendo.

	<p>Linux comenzó con un proyecto para explorar el chip 386.
	  Uno de los proyectos más tempranos de Linus era un programa
	  que cambiaría entre imprimir <tt>AAAA</tt> y <tt>BBBB</tt>.
	  Esto evolucionaría más tarde hasta convertirse en Linux.

	<p>Linux ha sido registrado bajo los términos de la Licencia
	  General Pública de GNU (GPL).  Esta es una licencia escrita
	  por la Fundación para el Software Libre que está diseñada
	  para mantener libre el software.  Brevemente, dice que
	  aunque puede cobrar tanto como quiera por una copia, no
	  puede impedir que la persona a la que se lo ha vendido lo
	  venda a su vez, regalándolo o modificándolo.  También
	  significa que el código fuente

	  <footnote>El <em>código fuente</em> de un programa es lo que
	    el programador humano lee y escribe.  Después se traduce a
	    código máquina que la computadora interpreta.</footnote>

	  ha de estar igualmente disponible.  Esto es útil para los
	  programadores.  Cualquiera puede modificar Linux e incluso
	  distribuir sus modificaciones, siempre que mantengan el
	  código bajo la misma licencia: la LPG.

	<p>Debian se llama GNU/Linux porque es producto de dos
	  esfuerzos masivos, el kernel Linux y el proyecto GNU.  Sin
	  embargo, enfocarse en sólo esas dos aportaciones deja fuera
	  a decenas de miles de colaboradores.  Es imposible seguir el
	  rastro de todos los que han convertido Debian en lo que es
	  hoy.

	<p>Las siguientes dos listas, de líderes e hitos en las
	  entregas, están registradas por el Software para el Interés
	  Público y pueden redistribuirse, pero no modificarse.

	<p>Debian ha tenido varios líderes desde sus principios en
	  1993.

	<list>

	  <item>Ian Murdock fundó Debian en agosto de 1993 y la
	    dirigió hasta marzo de 1996.  Este esfuerzo fue
	    patrocinado por el proyecto GNU de la Fundación para el
	    Software Libre durante un año (desde noviembre de 1994 a
	    noviembre de 1995).

	  <item>Bruce Perens dirigió Debian desde abril de 1996 hasta
	    diciembre de 1997.

	  <item>Ian Jackson dirigió Debian desde enero de 1998 hasta
	    febrero de 1999.

	  <item>Wichert Akkerman es el actual líder de Debian desde
	    febrero de 1999.

	</list>

	<p>Aquí están algunos de los hitos principales de las entregas
	  de Debian:

	<list>

	  <item>0.01-0.90 apareció entre agosto de 1883 y diciembre de
	    1993

	  <item>0.91 apareció en enero de 1994 (alrededor de 30
	    desarrolladores, gestor de paquetes primitivo)

	  <item>0.93R5 apareció en marzo de 1995 (dpkg hace su primera
	    aparición)

	  <item>0.96R6 apareció en noviembre de 1995 (alrededor de 60
	    desarrolladores, a.aout, primer dselect)

	  <item>1.0 nunca llegó a aparecer.  Se convirtió más tarde en
	    la versión 1.1

	  <item>1.1 'Buzz' apareció en junio de 1996 (474 paquetes,
	    kernel 2.0, soporte ELF completo, dpkg)

	  <item>1.2 'Rex' apareció en diciembre de 1996 (848 paquetes,
	    120 desarrolladores)

	  <item>1.3 'Bo' apareció en julio de 1997 (974 paquetes, 200
	    desarrolladores)

	  <item>2.0 'Hamm' apareció en Julio de 1998 (más de 1500
	    paquetes, más de 400 desarrolladores, glibc2)

	  <item>2.1 'Slink' tiene su aparición programada para
	    principios de marzo de 1999

	</list>

   <sect>La numeración de versiones del kernel Linux

	<p>El primer número en el número de versión de Linux indica
	  revisiones realmente profundas.  Estos cambios son muy
	  lentos: ahora mismo la versión 2 es la última.  El segundo
	  número indica revisiones de importancia algo menor.  Un
	  segundo número par indica mayor estabilidad, versiones
	  fiables de Linux, mientras que los números impares son
	  versiones para desarrolladores, que son más propensas a los
	  errores.  El último número de la versión es el número menor
	  de la entrega: cada vez que aparece una nueva versión que
	  simplemente fija pequeños problemas o añade
	  características menores, ese número se aumenta en uno.
	  Ahora mismo el kernel estable es 2.0, y el kernel de
	  desarrollo es el 2.1.  Cuando el 2.1 esté preparado, se
	  convertirá en el kernel estable 2.2.  La última versión del
	  kernel estable es ahora la 2.0.35, aunque puede haber
	  cambiado cuando usted lea esto.  Se espera pronto la
	  aparición del kernel estable 2.2.

   </appendix>

  </book>

</debiandoc>
