
ABOUT THIS FILE: I put all of the LDP User's Manual in this file, 
and then started going through it. If a section repeats something
already written, or is outdated, I delete it. If it looks like it'd be
a good section to have in the Tutorial, I cut it out of here and paste
it into there. So eventually this file should disappear. If anyone
wants to help it along, feel free.

It's a little boring to do the cut and paste work, but there's useful
stuff in here, I like the colorful history factoids and
rationalizations of cryptic command names. There are also good
explanations. Obviously anything that's pasted will have to have the
LaTeX removed and the DebianDoc added. 




The prompt is displayed by a special program called the
\concept{shell}.  Shells accept commands, and run those commands. They
can also be programmed in their own language, and programs written in
that language are called "shell
scripts".\index{shell!programming}\index{shell!script}

There are two major types of shells in \unix: Bourne shells and C
shells.  Bourne shells are named after their inventor, Steven
Bourne.\index{Bourne, Steve R.} Steven Bourne wrote the original
Unix shell {\tt sh}\ttindex{sh}, and most shells since then end in
the letters {\tt sh} to indicate they are extentions on the original
idea.  There are many implementations of his shell, and all those
specific shell programs are called Bourne shells. Another class of
shells, C shells (originally implemented by Bill Joy\index{Joy,
  Bill}), are also common. Traditionally, Bourne shells have been used
for shell scripts and compatibility with the original {\tt sh} while C
shells have been used for interactive use.  (C shells have had the
advantages of having better interactive features but somewhat harder
programming features.)

GNU/Linux comes with a Bourne shell called {\tt bash}\ttindex{bash},
written by the Free Software Foundation.\index{Free Software Foundation} 
{\tt bash} stands for {\bf B}ourne {\bf A}gain {\bf Sh}ell, one of the
many bad puns in \unix.  It is an "advanced" Bourne shell:  it
contains the standard programming features found in all Bourne shells
with many interactive features commonly found in C shells.  {\tt bash}
is the default shell to use running GNU/Linux.

When you first login, the prompt is displayed by {\tt bash}, and you
are running your first Unix program, the {\tt bash} shell.  As long
as you are logged in, the {\tt bash} shell will constantly be running.


\begin{command}
{\tt cp} [-i] {\sl source} {\sl destination}\\
{\tt cp} [-i] {\sl file1 file2 \ldots fileN} {\sl
  destination-directory}<footnote>{\tt cp} has two lines in its
  template because the meaning of the second parameter can be
  different depending on the number of parameters.}
\end{command}

{\tt cp} is a very useful utility under \unix, and extremely powerful.  It
enables one person to copy more information in a second than a fourteenth
century monk could do in a year.

\cautionpar Be careful with {\tt cp} if you don't have a lot of disk
space.  No one wants to see a "Disk full" message when working on
important files. {\tt cp} can also overwrite existing files without
warning---I'll talk more about that danger later.

We'll first talk about the first line in the command template.  The
first parameter to {\tt cp} is the file to copy---the second is where to
copy it.  You can copy to either a different filename, or a different
directory. Let's try some examples:

\begin{screen}\begin{verbatim}
/home/larry# ls -F /etc/passwd
/etc/passwd
/home/larry# cp /etc/passwd .
/home/larry# ls -F
passwd
/home/larry# cp passwd frog
/home/larry# ls -F
frog  passwd
/home/larry#
\end{verbatim}
\end{screen}

The first {\tt cp} command I ran took the file {\tt
  /etc/passwd}\ttindex{/etc/passwd}, which contains the names of all
the users on the Unix system and their (encrypted) passwords, and
copied it to my home directory.  {\tt cp} doesn't delete the source
file, so I didn't do anything that could harm the system.  So two
copies of {\tt /etc/passwd} exist on my system now, both named {\tt
  passwd}, but one is in the directory {\tt /etc} and one is in {\tt
  /home/larry}.

Then I created a {\em third\/} copy of {\tt
  /etc/passwd}\ttindex{/etc/passwd} when I typed {\tt cp passwd
  frog}---the three copies are now: {\tt /etc/passwd}, {\tt
  /home/larry/passwd} and {\tt /home/larry/frog}. The contents of
these three files are the same, even if the names aren't.

{\tt cp} can copy files between directories if the first parameter is a
file and the second parameter is a directory.  In this case, the short
name of the file stays the same.

It can copy a file and change it's name if both parameters are file
names. Here is one danger of {\tt cp}. If I typed {\tt cp /etc/passwd
/etc/group}, {\tt cp} would normally create a new file with the contents
identical to {\tt passwd} and name it {\tt group}.  However, if {\tt
/etc/group} already existed, {\tt cp} would destroy the old file without
giving you a chance to save it!  (It won't even print out a message
reminding you that you're destroying a file by copying over it.)

Let's look at another example of {\tt cp}:
\begin{screen}\begin{verbatim}
/home/larry# ls -F
frog  passwd
/home/larry# mkdir passwd_version
/home/larry# cp frog passwd passwd_version
/home/larry# ls -F
frog         passwd        passwd_version/
/home/larry# ls -F passwd_version
frog  passwd
/home/larry#
\end{verbatim}
\end{screen}

How did I just use {\tt cp}? Evidentally, {\tt cp} can take {\em
  more\/} than two parameters.  (This is the second line in the
command template.)  What the above command did is copied all the files
listed ({\tt frog} and {\tt passwd}) and placed them in the {\tt
  passwd\_version} directory. In fact, {\tt cp} can take any number of
parameters, and interprets the first $n-1$ parameters to be files to
copy, and the $n^{\rm th}$ parameter as what directory to copy them
too.

\cautionpar You cannot rename files when you copy more than one at a
time---they always keep their short name. This leads to an interesting
question. What if I type {\tt cp frog passwd toad}, where {\tt frog} and {\tt
passwd} exist and {\tt toad} isn't a directory? Try it and see.

\ettindex{cp}

\subsection{Pruning Back with {\tt rm}}\bttindex{rm}

\begin{command}
{\tt rm} [-i] {\sl file1 file2 \ldots fileN}
\end{command}

Now that we've learned how to create millions of files with {\tt
cp}\ttindex{cp} (and believe me, you'll find new ways to create more files
soon), it may be useful to learn how to delete them. Actually, it's very
simple: the command you're looking for is {\tt rm}, and it works just like
you'd expect: any file that's a parameter to {\tt rm} gets deleted.

For example:
\begin{screen}\begin{verbatim}
/home/larry# ls -F
frog         passwd        passwd_version/
/home/larry# rm frog toad passwd
rm: toad: No such file or directory
/home/larry# ls -F
passwd_version/
/home/larry#
\end{verbatim}\end{screen}

As you can see, {\tt rm} is extremely unfriendly.  Not only does it not ask
you for confirmation, but it will also delete things even if the whole
command line wasn't correct. This could actually be dangerous. Consider
the difference between these two commands:
\begin{screen}\begin{verbatim}
/home/larry# ls -F
toad  frog/
/home/larry# ls -F frog
toad
/home/larry# rm frog/toad
/home/larry#
\end{verbatim}\end{screen}
and this
\begin{screen}\begin{verbatim}
/home/larry# rm frog toad
rm: frog is a directory
/home/larry# ls -F
frog/
/home/larry#
\end{verbatim}\end{screen}

\cautionpar As you can see, the difference of {\em one\/} character made
a world of difference in the outcome of the command. It is vital that you
check your command lines before hitting \ret!

\ettindex{rm}

\subsection{A Forklift Can Be Very Handy}\bttindex{mv}

\begin{command}
{\tt mv} [-i] {\sl old-name} {\sl new-name}\\
{\tt mv} [-i] {\sl file1 file2 \ldots fileN} {\sl new-directory}
\end{command}

Finally, the other file command you should be aware of is {\tt mv}. {\tt
mv} looks a lot like {\tt cp}, except that it deletes the original file
after copying it.  It's a lot like using {\tt cp} and {\tt rm}
together. Let's take a look at what we can do:

\begin{screen}\begin{verbatim}
/home/larry# cp /etc/passwd .
/home/larry# ls -F
passwd
/home/larry# mv passwd frog
/home/larry# ls -F
frog
/home/larry# mkdir report
/home/larry# mv frog report
/home/larry# ls -F
report/
/home/larry# ls -F report
frog
/home/larry#
\end{verbatim}\end{screen}

As you can see, {\tt mv} will rename a file if the second parameter is a
file. If the second parameter is a directory, {\tt mv} will move the file
to the new directory, keeping it's shortname the same.

\cautionpar You should be very careful with {\tt mv}---it doesn't check 
to see if the file already exists, and will remove any old file in its way.
For instance, if I had a file named {\tt frog} already in my directory {\tt
report}, the command {\tt mv frog report} would delete the file {\tt
\verb+~+/report/frog} and replace it with {\tt \verb+~+/frog}.

In fact, there is one way to make {\tt rm}, {\tt cp} and {\tt mv} ask
you before deleting files.  All three of these commands accept the
{\tt -i} option, which makes them query the user before removing any
file. If you use an {\bf alias}, you can make the shell do {\tt rm -i}
automatically when you type {\tt rm}.  You'll learn more about this
later in Section~\ref{aliasing-section} on
page~\pageref{aliasing-section}.

\ettindex{mv}

% Local Variables: 
% mode: latex
% TeX-master: "guide"
% End: 


% this teaches about the X Window System, for those people who
% encountered it when they logged on
\include{x11}

\chapter{The X Window System}\label{x-chapter}

\begin{fortune}
The nice thing about standards is that there are so many of them to
choose from.\\
\raggedleft Andrew S.~Tanenbaum
\end{fortune}

\bindex{X Window System}

\xwarn This chapter only applies to those using the X Window
System.  If you encounter a screen with multiply windows, colors, or a
cursor that is only movable with your mouse, you are using X. (If
your screen consists of white characters on a black background, you
are not currently using X.  If you want to start it up, take a look at

\section{What is The X Window System?}

The X Window System is a distributed, graphical method of working
developed primarily at the Massachusetts Institute of
Technology\index{Massachusetts Institute of Technology}. It has since
been passed to a consortium of vendors (aptly named "The X
Consortium") and is being maintained by them.

The X Window System (hereafter abbreviated as "X"<footnote>There are
  several acceptable ways to refer to The X Window System.  A common
  though incorrect way of referring to X is "X Windows".}) has new
versions every few years, called releases. As of this writing, the
latest revision is X11R6, or release six. The eleven in X11 is
officially the version number but there hasn't been a new version in
many years, and one is not currently planned.

There are two terms when dealing with X that you should be familiar.
The \concept{client} is a X program. For instance, {\tt xterm} is the
client that displays your shell when you log on.  The \concept{server}
is a program that provides services to the client program. For
instance, the server draws the window for {\tt xterm} and communicates
with the user.

Since the client and the server are two separate programs, it is
possible to run the client and the server {\em on two physically
  separate machines\/}.  In addition to supplying a standard method of
doing graphics, you can run a program on a remote machine (across the
country, if you like!) and have it display on the workstation right in
front of you.

A third term you should be familiar with is the
\concept{window manager}. The window manager is a special client that
tells the server where to position various windows and provides a way
for the user to move these windows around. The server, by itself, does
nothing for the user. It is merely there to provide a buffer between
the user and the client.

\section{What's This on my Screen?}

When you first start X, several programs are started. First, the
server is started. Then, several clients are usually
started. Unfortunately, this is not standardized across various
distributions. It is likely that among these clients are a window
manager, either {\tt fvwm} or {\tt twm}, a prompt, {\tt xterm}, and a
clock, {\tt xclock}.

\begin{figure}[tbf]\label{full-x-screen}
\centering
\epsfig{file=ps-files/screen-shot-5.ps, width=\linewidth}
\caption{An annotated example of a standard X screen.  In this
 example, the user is running {\tt twm}.  The standard clock has been
  replaced by a transparent clock called {\tt oclock}.}
\end{figure}

\subsection{XClock}

\begin{command}
{\tt xclock} [-digital] [-analog] [-update {\sl seconds}] [-hands {\sl
  color}]
\end{command}

I'll explain the simpliest one first: {\tt xclock}\ttindex{xclock}
functions exactly as you'd expect it would.  It ticks off the seconds,
minutes and hours in a small window.

No amounts of clicking or typing in {\tt xclock}'s window will affect
it---that's {\em all\/} it does. Or is it? In fact, there are various
different options you can give to the program to have it act in
different ways. For instance, {\tt xclock -digital} will create a
digital clock. {\tt xclock -update 1} will create a second hand that
moves every second, while {\tt -update 5} will create a second hand
that moves every 5 seconds.

For more information on {\tt xclock}'s options, consult its
manpage---{\tt man xclock}. If you're going to try running a few of
your own {\tt xclock}s, you should probably read
Section~\ref{section-multitasking} (Multitasking) to learn how to run
them in addition to your current programs.  (If you run an {\tt
  xclock} in the foreground---the usual way of running a program---and
want to get out of it, type \key{ctrl-c}.)

\subsection{XTerm} % better section name?

The window with a prompt in it (something that probably looks like
{\tt /home/larry\#}) is being controlled by a program called {\tt
  xterm}\impttindex{xterm}.  {\tt xterm} is a deceptively complicated
program.  At first glance, it doesn't seem to do much, but it actually
has to do a lot of work.  {\tt xterm} emulates a terminal so that
regular text-mode Unix applications work correctly.  It also
maintains a buffer of information so that you can refer back to old
commands.  (To see how to use this, look at
Section~\ref{x-scroll-bar}.)

For much of this book, we're going to be learning about the Unix 
command-line, and you'll find that inside your {\tt xterm} window.
In order to type into {\tt xterm}, you {\em usually\/} have to move
your mouse cursor (possibly shaped like an "X" or an arrow) into the
{\tt xterm} window.  However, this behavior is dependent on the window
manager.

One way of starting more programs under X is through an {\tt xterm}.
Since X programs are standard Unix programs, they can be run from
normal command prompts such as {\tt xterm}s.  Since running a long
term program from a {\tt xterm} would tie up the {\tt xterm} as long
as the program was running, people normally start X programs in the
background.  For more information about this, see
Section~\ref{section-multitasking}.

\section{Window Managers}

On GNU/Linux, there are two different window managers that are commonly
used.  One of them, called {\tt twm}\ttindex{twm} is short for "Tab
Window Manager". % this is from the manpage. is it correct?
It is larger than the other window manager usually used, {\tt fvwm}.
({\tt fvwm} stands for "F(?) Virtual Window Manager"---the author
neglected to tie down exactly what the f stood for.)  Both {\tt twm}
and {\tt fvwm} are highly configurable, which means I can't tell you
exactly what keys do what in your particular setup.

To learn about {\tt twm}'s configuration, look at
Section~\ref{twm-config-section}. {\tt fvwm}'s configuration is
covered in Section~\ref{fvwm-config-section}.

\subsection{When New Windows are Created}

There are three possible things a window manager will do when a new
window is created.  It is possible to configure a window manager so
that an outline of the new window is shown, and you are allowed to
position it on your screen. That is called \concept{manual placement}.
If you are presented with the outline of a window, simply use the
mouse to place it where you wish it to appear and click the left mouse
button.

It is also possible that the window manager will place the new window
somewhere on the screen by itself.  This is known as 
\concept{random placement}.

Finally, sometimes an application will ask for a specific spot on the
screen, or the window manager will be configured to display certain
applications on the same place of the screen all the time. (For
instance, I specify that I want {\tt xclock} to always appear in
the upper right hand corner of the screen.)

\subsection{Focus}

The window manager controls some important things. The first thing
you'll be interested in is \concept{focus}.  The focus of the server is
which window will get what you type into the keyboard. Usually in X
the focus is determined by the position of the mouse cursor.  If the
mouse cursor is in one {\tt xterm}'s window<footnote>You can have more
  then one copy of {\tt xterm} running at the same time!}, that {\tt
  xterm} will get your keypresses.  This is different from many other
windowing systems, such as Microsoft Windows, OS/2, or the Macintosh,
where you must click the mouse in a window before that window gets
focus.  Usually under X, if your mouse cursor wanders from a
window, focus will be lost and you'll no longer be able to type there.

Note, however, that it is possible to configure both {\tt
  twm}\ttindex{twm} and {\tt fvwm}\ttindex{fvwm} so that you must
click on or in a window to gain focus, and click somewhere else to
lose it, identical to the behavior of Microsoft Windows.  Either
discover how your window manager is configured by trial and error, or
consult local documentation.

\subsection{Moving Windows}

Another very configurable thing in X is how to move windows around.
In my personal configuration of {\tt twm}, there are three different
ways of moving windows around.  The most obvious method is to move the
mouse cursor onto the \concept{title bar} and drag the window around
the screen. Unfortunately, this may be done with any of the left,
right, or middle buttons<footnote>Many PCs have only two button mice.
  If this is the case for you, you should be able to emulate a middle
  button by using the left and right buttons simultaneously.}. (To
drag, move the cursor above the title bar, and hold down on the button
while moving the mouse.)  Most likely, your configuration is
set to move windows using the \emph{left} mouse buttons.

Another way of moving windows may be holding down a key while dragging
the mouse. For instance, in {\em my\/} configuration, if I hold down
the \key{Alt} key, move the cursor above a window, I can drag the
window around using the left mouse button.

Again, you may be able to understand how the window manager is
configured by trial and error, or by seeing local
documentation. Alternatively, if you want to try to interpret the
window manager's configuration file, see
Section~\ref{twm-config-section} for {\tt twm}\ttindex{twm} or
Section~\ref{fvwm-config-section} for {\tt fvwm}\ttindex{fvwm}.

\subsection{Depth}

Since windows are allowed to overlap in X, there is a concept of
\concept{depth}.  Even though the windows and the screen are both two
dimensional, one window can be in front of another, partially or
completely obscuring the rear window.

There are several operations that deal with depth:
\begin{itemize}
\item {\bf Raising} the window, or bringing a window to the front.
  This is usually accomplished by clicking on a window's title bar
  with one of the buttons.  Depending on how the window manager is
  configured, it could be any one of the buttons. (It is also possible
  that more then one button will do the job.)

\item {\bf Lowering} the window, or pushing the window to the back.
  This can generally be accomplished by a different click in the title
  bar. It is also possible to configure some window managers so that
  one click will bring the window foward if there is anything over it,
  while that same click will lower it when it is in the front.

\item {\bf Cycling} through windows is another operation many window
  managers allow. This brings each window to the front in an orderly
  cycle.  
\end{itemize}

\subsection{Iconization}

There are several other operations that can obscure windows or hide
them completely. First is the idea of "iconization". Depending on
the window manager, this can be done in many different ways. In {\tt
  twm}, many people configure an {\bf icon manager}\index{icon
  manager}. This is a special window that contains a list of all the
other windows on the screen.  If you click on a name (depending on the
setup, it could be with any of the buttons!) the window
disappears---it is iconified.  The window is still active, but you
can't see it.  Another click in the icon manager restores the window
to the screen.

This is quite useful.  For instance, you could have remote {\tt
  xterm}s to many different computers that you occasionally use.
However, since you rarely use all of them at a given time, you can
keep most of the {\tt xterm} windows iconified while you work with a
small subset. The only problem with this is it becomes easy to
"lose" windows. This causes you to create new windows that duplicate
the functionality of iconified windows.

Other window managers might create actual icons across the bottom of
the screen, or might just leave icons on the root
window.\glossary{root window}

\subsection{Resizing}

There are several different methods to resize windows under X.  Again,
it is dependent on your window manager and exactly how your window
manager is configured.  The method many Microsoft Windows users are
familiar with is to click on and drag the border of a window.  If your
window manager creates large borders that change how the mouse cursor
looks when it is moved over them, that is probably the method used to
resize windows.

Another method used is to create a "resizing" button on the
titlebar.  In Figure~\ref{full-x-screen}, a small button is visible on
the right of each titlebar.  To resize windows, the mouse is moved
onto the resize button and the left mouse button is held down.  You
can then move the mouse outside the borders of the window to resize
it.  The button is released when the desired size has been reached.

\subsection{Maximization}

Most window managers support maximization.  In {\tt twm}, for
instance, you can maximize the height, the width, or both dimensions
of a window. This is called "zooming" in {\tt twm}'s language
although I prefer the term maximization.  Different applications
respond differently to changes in their window size. (For instance,
{\tt xterm} won't make the font bigger but will give you a larger
workspace.)

Unfortunately, it is extremely non-standard on how to maximize windows.

\subsection{Menus}\label{x-menus}

Another purpose for window managers is for them to provide menus for
the user to quickly accomplish tasks that are done over and over.  For
instance, I might make a menu choice that automatically launches Emacs
or an additional {\tt xterm} for me. That way I don't need to type in
an {\tt xterm}---an especially good thing if there aren't any running
{\tt xterm}s that I need to type in to start a new program!

In general, different menus can be accessed by clicking on the root
window, which is an immovable window behind all the other ones. By
default, it is colored gray, but could look like
anything.<footnote>One fun program to try is called {\tt
    xfishtank}\ttindex{xfishtank}.  It places a small aquarium in the
  background for you.} To try to see a menu, click and hold down a
button on the desktop. A menu should pop up. To make a selection, move
(without releasing the mouse button) the cursor over one of the items
any then release the mouse button.

\section{X Attributes}

There are many programs that take advantage of X. Some programs, like
{\tt emacs}\ttindex{emacs}, can be run either as a text-mode program
{\em or\/} as a program that creates its own X window. However, most X
programs can only be run under X.

\subsection{Geometry}\index{X Window System!geometry}

There are a few things common to all programs running under X.  In X, the
concept of {\bf geometry} is where and how large a window is.  A
window's geometry has four components:
\begin{itemize}
\item The horizontal size, usually measured in pixels. (A pixel is the
  smallest unit that can be colored. Many X setups on Intel PCs have
  1024 pixels horizontally and 768 pixels vertically.) Some
  applications, like {\tt xterm} and {\tt emacs}, measure their size in
  terms of number of characters they can fit in the window. (For
  instance, eighty characters across.)
\item The vertical size, also usually measured in pixels. It's
  possible for it to be measured in characters.
\item The horizontal distance from one of the sides of the screen. For
  instance, {\tt +35} would mean make the left edge of the window
  thirty-five pixels from the left edge of the screen. On the other
  hand, {\tt -50} would mean make the right edge of the window fifty
  pixels from the right edge of the screen.  It's generally impossible to start
  the window off the screen, although a window can be moved off the
  screen.  (The main exception is when the window is very large.)
\item The vertical distance from either the top or the bottom. A
  positive vertical distance is measured from the top of the screen; a
  negative vertical distance is measured from the bottom of the
  screen.
\end{itemize}

All four components get put together into a geometry string that looks
like: {\tt 503x73-78+0}. (That translates into a window 503 pixels
long, 73 pixels high, put near the top right hand corner of the
screen.)  Another way of stating it is {\sl hsize\/}{\tt x}{\sl
  vsize\/}$\pm${\sl hplace\/}$\pm${\sl vplace\/}.

\subsection{Display}

Every X application has a display that it is associated with.  The
display is the name of the screen that the X server controls.  A
display consists of three components:

\begin{itemize}
\item The machine name that the server is running on.  At stand-alone
  GNU/Linux installations the server is always running on the same
  system as the clients. In such cases, the machine name can be
  omitted.
\item The number of the server running on that machine. Since any one
  machine could have multiple X servers running on it (unlikely for
  most GNU/Linux machines, but possible) each must have a unique number.
\item The screen number.  X supports a particular server controlling
  more than one screen at a time. You can imagine that someone wants a
  lot of screen space, so they have two monitors sitting next to each
  other. Since they don't want two X servers running on one machine
  for performance reasons, they let one X server control both screens.
\end{itemize}

These three things are put together like so: {\sl machine\/}:{\sl
  server-number\/}.{\sl screen-number\/}.

For instance, on {\tt mousehouse}, all my applications have the
display set to {\tt :0.0}, which means the first screen of the first
server on the local display. However, if I am using a remote computer,
the display might be set to {\tt mousehouse:0.0}.

By default, the display is taken from the environment variable (see
Section~\ref{section-env-variables}) named {\tt DISPLAY}, and can be
overridden with a command-line option (see
Figure~\ref{x-standard-options}). To see how {\tt DISPLAY} is set, try
the command {\tt echo \$DISPLAY}.

\begin{figure}
\begin{center}
\begin{tabular}{|l|p{.4\linewidth}|p{.4\linewidth}|}\hline
  Name & Followed by & Example\\ \hline
{\tt -geometry} & geometry of the window & {\tt xterm
  -geometry 80x24+0+90}\\ \hline
{\tt -display}  & display you want the program to appear &
                  {\tt xterm -display lionsden:0.0}\\ \hline
{\tt -fg} & the primary foreground color & {\tt xterm -fg
  yellow}\\ \hline
{\tt -bg} & the primary background color & {\tt xterm -bg blue}\\ \hline
\end{tabular}
\end{center}
\caption{Standard options for X programs.}\label{x-standard-options}
\end{figure}

\section{Common Features}

While X is a graphical user interface, it is a very uneven graphical
user interface.  It's impossible to say how any component of the
system is going to work, because every component can easily be
reconfigured, changed, and even replaced. This means it's hard to say
exactly how to use various parts of the interface.  We've already
encountered one cause of this: the different window managers and how
configurable each window manager is.

Another cause of this uneven interface is the fact that X applications
are built using things called "widget sets".  Included with the
standard X distribution are "Athena widgets" developed at MIT.
These are commonly used in free applications.  They have the
disadvantage that they are not particularly good-looking and are
somewhat harder to use than other widgets.\index{X Window
  System!Athena Widget Set}

The other popular widget set is called 
"Motif".\index{X Window System!Motif Widget Set} Motif is a
commercial widget set similar to the user interface used in Microsoft
Windows.  Many commercial applications use Motif widgets, as well as
some free applications.  The popular World Wide Web Browser {\tt
  netscape}\ttindex{netscape} uses Motif.

Let's try to go through some of the more usually things you'll
encounter.

\subsection{Buttons}

Buttons are generally the easiest thing to use.  A button is invoked
by positioning the mouse cursor over it and clicking (pressing and
immediately releasing the mouse button) the left button.  Athena and
Motif buttons are functionally the same although they have cosmetic
differences.

\subsection{Menu Bars}

A menu bar is a collection of commands accessible using the mouse.
For instance, {\tt emacs}'s menu bar is shown in
Figure~\ref{x11-menu-bar}.  Each word is a category heading of
commands.  {\sf File} deals with commands that bring up new files and
save files.  By convention, this is also the category that contains
the command to exit the program.

To access a command, move the mouse cursor over a particular category
(such as {\sf File}) and press and hold down the left mouse button.
This will display a variety of commands.  To select one of the
commands, move the mouse cursor over that command and release the left
mouse button.  Some menu bars let you click on a category---if this is
the case, clicking on the category will display the menu until you
click on either a command, another menu, or outside the menu bar
(indicating that you are not interested in running a particular
command).

\begin{figure}[tb]
\begin{center}
\epsfig{file=ps-files/screen-shot-2.ps, width=\textwidth}
\end{center}
\caption{{\tt emacs} will change its menu bar depending on the type of
  file you're working on.  Here is one possible menu
  bar.}\label{x11-menu-bar}
\end{figure}

\subsection{Scroll Bars}\label{x-scroll-bar}

A {\bf scroll bar} is a method to allow people to display only part of
a document, while the rest is off the screen.  For instance, the {\tt
  xterm} window is currently displaying the bottom third of the text
available in Figure~\ref{x11-scrollbar}.  It's easy to see what part
of the available text is current being displayed: the darkened part of
the scroll bar is relative to both the position and the amount of
displayed text.  If the text displayed is all there is, the entire
scroll bar is dark.  If the middle half of the text is displayed, the
middle half of the scroll bar is darkened.\index{X Window System!scrollbar}

A vertical scroll bar may be to the left or right of the text and a
horizontal one may be above or below, depending the application.

\begin{figure}[tb]
\begin{center}
\epsfig{file=ps-files/screen-shot-3.ps, height=3in} \hspace{0.7in}
\epsfig{file=ps-files/screen-shot-4.ps, height=3in}
\end{center}
\caption{An Athena-type scroll bar is visible on the left of this {\tt
    xterm} window.  Next to it, a Motif-type scroll bar is visible on
  the {\tt netscape} window.}\label{x11-scrollbar}
\end{figure}


\subsubsection{Athena scroll bars}

Athena scroll bars operate differently from scroll bars in other
windowing systems.  Each of the three buttons of the mouse operate
differently.  To scroll upwards (that is, display material above what
is currently visible) you can click the rightmost mouse button
anywhere in the scroll bar.  To scroll downwards, click the left mouse
button anywhere in the scroll bar.

You can also jump to a particular location in the displayed material
by clicking the middle mouse button anywhere in the scroll bar.  This
causes the window to display material starting at that point in the
document.

\subsubsection{Motif scroll bars}

A Motif scroll bar acts much more like a Microsoft Windows or
Macintosh scroll bar.  An example of one is on the right in
Figure~\ref{x11-scrollbar}.  Notice that in addition to the bar, it
has arrows above and below it.  These are used for fine-tuning:
clicking either the left or middle buttons on them will scroll a small
amount such as one line; the right button does nothing.

The behavior of clicking inside the scroll bar is widely different for
Motif scroll bars than Athena scroll bars.  The right button has no
effect.  Clicking the left button above the current position scrolls
upward.  Similarly, clicking below the current position scrolls
downward.  Clicking and holding the left button \emph{on} the current
position allows one to move the bar at will.  Releasing the left
button positions the window.

Clicking the middle button anywhere on the bar will immediately jump
to that location, similar to the behavior of the Athena middle
button.  However, instead of starting to display the data at the
position clicked, that position is taken to be the \emph{midpoint} of
the data to be displayed.

\eindex{X Window System}
% Local Variables: 
% mode: latex
% TeX-master: "guide"
% End: 


% more advance shell stuff: piping, redirection, filters, more
% commands
\include{shell2}

\chapter{Working with \unix}\label{shell2-chapter}


\begin{fortune}
\begin{verse}
A UNIX saleslady, Lenore,\\
Enjoys work, but she likes the beach more.\\
\hspace{0.5in}She found a good way\\
\hspace{0.5in}To combine work and play:\\
She sells C shells by the seashore.
\end{verse}
\end{fortune}
\glossary{C shell}\glossary{Bourne shell}
\glossary{file}\glossary{input}\glossary{output}


Unix is a powerful system for those who know how to harness its
power.  In this chapter, I'll try to describe various ways to use
\unix's shell, {\tt bash}\ttindex{bash}, more efficently.

\section{Wildcards}\bindex{shell!wildcards}
\index{shell!globbing|see{shell, wildcards}}
\index{wildcards|see{shell, wildcards}}

In the previous chapter, you learned about the file maintence commands {\tt
cp}, {\tt mv}, and {\tt rm}.  Occasionally, you want to deal with more than
one file at once---in fact, you might want to deal with many files at once.
For instance, you might want to copy all the files beginning with {\tt
data} into a directory called {\tt \verb+~+/backup}.  You could do this by either
running many {\tt cp} commands, or you could list every file on one command
line. Both of these methods would take a long time, however, and you have a
large chance of making an error.

A better way of doing that task is to type:
\begin{screen}\begin{verbatim}
/home/larry/report# ls -F
1993-1          1994-1          data1           data5
1993-2          data-new        data2
/home/larry/report# mkdir ~/backup
/home/larry/report# cp data* ~/backup
/home/larry/report# ls -F ~/backup
data-new        data1           data2           data5
/home/larry/report#
\end{verbatim}\end{screen}

As you can see, the asterix told {\tt cp} to take all of the files
beginning with {\tt data} and copy them to {\tt \verb+~+/backup}. Can you guess
what {\tt cp d*w \verb+~+/backup} would have done?

\subsection{What {\em Really\/} Happens?}

Good question. Actually, there are a couple of special characters
intercepted by the shell, {\tt bash}\ttindex{bash}. The character
"{\tt *}", an asterix, says "replace this word with all the files
that will fit this specification". So, the command {\tt cp data*
  \verb+~+/backup}, like the one above, gets changed to {\tt cp
  data-new data1 data2 data5 \verb+~+/backup} before it gets run.

To illustrate this, let me introduce a new command, {\tt
  echo}\impttindex{echo}. {\tt echo} is an extremely simple command;
it echoes back, or prints out, any parameters. Thus:

\begin{screen}\begin{verbatim}
/home/larry# echo Hello!
Hello!
/home/larry# echo How are you?
How are you?
/home/larry# cd report
/home/larry/report# ls -F
1993-1          1994-1          data1           data5
1993-2          data-new        data2
/home/larry/report# echo 199*
1993-1 1993-2 1994-1
/home/larry/report# echo *4*
1994-1
/home/larry/report# echo *2*
1993-2 data2
/home/larry/report#
\end{verbatim}
\end{screen}

As you can see, the shell expands the wildcard and passes all of the
files to the program you tell it to run. This raises an interesting
question: what happens if there are {\em no\/} files that meet the
wildcard specification? Try {\tt echo /rc/fr*og} and {\tt
  bash}\ttindex{bash} passes the wildcard specification verbatim to
the program.

Other shells, like {\tt tcsh}\ttindex{tcsh}, will, instead of just
passing the wildcard verbatim, will reply {\tt No match.} Here's the
same command run under {\tt tcsh}:

\begin{screen}\begin{verbatim}
mousehouse>echo /rc/fr*og
echo: No match.
mousehouse>
\end{verbatim}\end{screen}

The last question you might want to know is what if I wanted to have
{\tt data*} echoed back at me, instead of the list of file names?
Well, under both {\tt bash} and {\tt tcsh}, just include the string in
quotes:

\begin{minipage}{2.6in}\begin{screen}
\begin{verbatim}
/home/larry/report# echo "data*"
data*
/home/larry/report#
\end{verbatim}\end{screen}\end{minipage}\ {\large OR}\ 
\begin{minipage}{2.6in}\begin{screen}
\begin{verbatim}
mousehouse>echo "data*"
data*
mousehouse>
\end{verbatim}\end{screen}\end{minipage}

\subsection{The Question Mark}

In addition to the asterix, the shell also interprets a question mark
as a special character.  A question mark will match one, and only one
character. For instance, {\tt ls /etc/??} will display all two letter
files in the the {\tt /etc} directory.

\eindex{shell!wildcards}

\section{Time Saving with {\tt bash}}
\index{command line editing|see{shell, editing}}

\subsection{Command-Line Editing}\bindex{shell!editing}

Occasionally, you've typed a long command to {\tt bash}\ttindex{bash} and,
before you hit return, notice that there was a spelling mistake early in
the line.  You could just delete all the way back and retype everything you
need to, but that takes much too much effort! Instead, you can use the
arrow keys to move back there, delete the bad character or two, and type
the correct information.

There are many special keys to help you edit your command line, most of
them similar to the commands used in GNU Emacs\index{GNU Emacs}. For
instance, \key{C-t} flips two adjacent characters.<footnote>\key{C-t} means
hold down the key labeled "Ctrl", then press the "t" key. Then release
the "Ctrl" key.} You'll be able to find most of the commands in the
chapter on Emacs, Chapter~\ref{emacs-chapter}.

\eindex{shell!editing}

\subsection{Command and File Completion}\bindex{shell!completion}

Another feature of {\tt bash}\ttindex{bash} is automatic completion of
your command lines.  For instance, let's look at the following example
of a typical {\tt cp} command:

\begin{screen}\begin{verbatim}
/home/larry# ls -F
this-is-a-long-file
/home/larry# cp this-is-a-long-file shorter
/home/larry# ls -F
shorter              this-is-a-long-file
/home/larry# 
\end{verbatim}\end{screen}

It's a big pain to have to type every letter of {\tt
  this-is-a-long-file} whenever you try to access it.  So, create {\tt
  this-is-a-long-file} by copying {\tt /etc/passwd} to it<footnote>\tt cp
  /etc/passwd this-is-a-long-file}. Now, we're going to do the above {\tt
  cp} command very quickly and with a smaller chance of mistyping.

Instead of typing the whole filename, type {\tt cp th} and press and
release the \key{Tab}. Like magic, the rest of the filename shows up
on the command line, and you can type in {\tt shorter}. Unfortunately,
{\tt bash}\ttindex{bash} cannot read your thoughts, and you'll have to
type all of {\tt shorter}.

When you type \key{Tab}, {\tt bash} looks at what you've typed and
looks for a file that starts like that. For instance, if I type {\tt
  /usr/bin/ema} and then hit \key{Tab}, {\tt bash} will find {\tt
  /usr/bin/emacs} since that's the only file that begins {\tt
  /usr/bin/ema} on my system. However, if I type {\tt /usr/bin/ld} and
hit \key{Tab}, {\tt bash} beeps at me. That's because three files,
{\tt /usr/bin/ld}, {\tt /usr/bin/ldd}, and {\tt /usr/bin/ld86} all
start with {\tt /usr/bin/ld} on my system.

If you try a completion and {\tt bash} beeps, you can immediately hit
\key{Tab} again to get a list of all the files your start matches so
far. That way, if you aren't sure of the exact spelling of your file,
you can start it and scan a much smaller list of files.

\eindex{shell!completion}

\section{The Standard Input and The Standard Output}

% it might be nice to get some illustrations around here, with
% pointers showing where all the output is going

Let's try to tackle a simple problem: getting a listing of the {\tt
  /usr/bin} directory. If all we do is {\tt ls /usr/bin}, some of the
files scroll off the top of the screen. How can we see all of the
files?

\subsection{Unix Concepts}

The Unix operating system makes it very easy for programs to use the
terminal.  When a program writes something to your screen, it is using
something called \concept{standard output}.  Standard output,
abbreviated as stdout, is how the program writes things to a user. The
name for what you tell a program is \concept{standard input} (stdin).
It's possible for a program to communicate with the user without using
standard input or output, but most of the commands I cover in this
book use stdin and stdout.

For example, the {\tt ls}\ttindex{ls} command prints the list of the
directories to standard output, which is normally "connected" to
your terminal.  An interactive command, such as your shell, {\tt
  bash}\ttindex{bash}, reads your commands from standard input.

It is also possible for a program to write to 
\concept{standard error}, since it is very easy to make standard
output point somewhere besides your terminal. Standard error (stderr)
is almost always connected to a terminal so an actual human will read
the message.

In this section, we're going to examine three ways of fiddling with
the standard input and output: input redirection, output redirection,
and pipes.

\subsection{Output Redirection}\bindex{output redirection}

A very important feature of Unix is the ability to {\bf redirect}
output. This allows you, instead of viewing the results of a command,
to save it in a file or send it directly to a printer. For instance,
to redirect the output of the command {\tt ls /usr/bin}, we place a
{\tt >} sign at the end of the line, and say what file we want the
output to be put in:

\begin{screen}\begin{verbatim}
/home/larry# ls
/home/larry# ls -F /usr/bin > listing
/home/larry# ls
listing
/home/larry#
\end{verbatim}\end{screen}

As you can see, instead of writing the names of all the files, the
command created a totally new file in your home directory. Let's try
to take a look at this file using the command {\tt cat}. If you think
back, you'll remember {\tt cat} was a fairly useless command that
copied what you typed (the standard input) to the terminal (the
standard output). {\tt cat} can also print a file to the standard
output if you list the file as a parameter to {\tt cat}:

\begin{screen}\begin{verbatim}
/home/larry# cat listing
...
/home/larry#
\end{verbatim}\end{screen}

The exact output of the command {\tt ls /usr/bin} appeared in the
contents of {\tt listing}. All well and good, although it didn't solve
the original problem.<footnote>For impatient readers, the command you
  might want to try is {\tt more}. However, there's still a bit more
  to talk about before we get there.}

However, {\tt cat} does do some interesting things when it's output is
redirected. What does the command {\tt cat listing > newfile} do?
Normally, the {\tt > newfile} says "take all the output of the
command and put it in {\tt newfile}." The output of the command {\tt
  cat listing} is the file {\tt listing}. So we've invented a new (and
not so efficient) method of copying files.

How about the command {\tt cat > fox}? {\tt cat} by itself reads in
each line typed at the terminal (standard input) and prints it right
back out (standard output) until it reads \key{Ctrl-d}. In this case,
standard output has been redirected into the file {\tt fox}. Now {\tt
  cat} is serving as a rudimentary editor:

\begin{quote}{\tt 
/home/larry\# cat > fox\\
The quick brown fox jumps over the lazy dog.\\
{\em press Ctrl-d}
}\end{quote}

We've now created the file {\tt fox} that contains the sentence "The
quick brown fox jumps over the lazy dog." One last use of the
versitile {\tt cat} command is to con{\bf cat}enate files together.
{\tt cat} will print out every file it was given as a parameter, one
after another. So the command {\tt cat listing fox} will print out the
directory listing of {\tt /usr/bin}, and then it will print out our
silly sentence. Thus, the command {\tt cat listing fox > listandfox}
will create a new file containing the contents of both {\tt listing}
and {\tt fox}.

\eindex{output redirection}

\subsection{Input Redirection}\bindex{input redirection}

Like redirecting standard output\index{standard output}, it is also
possible to redirect standard input\index{standard input}. Instead of
a program reading from your keyboard, it will read from a file.  Since
input redirection is related to output redirection, it seems natural
to make the special character for input redirection be {\tt <}. It
too, is used after the command you wish to run.

This is generally useful if you have a data file and a command that
expects input from standard input.  Most commands also let you specify
a file to operate on, so {\tt <} isn't used as much in day-to-day
operations as other techniques.

\eindex{input redirection}

\subsection{The Pipe}\bindex{pipes}

Many Unix commands produce a large amount of information. For instance,
it is not uncommon for a command like {\tt ls /usr/bin} to produce more
output than you can see on your screen. In order for you to be able to see
all of the information that a command like {\tt ls /usr/bin}, it's
necessary to use another Unix command, called {\tt
more}\ttindex{more}.<footnote>{\tt more}\ttindex{more} is named because
that's the prompt it originally displayed: {\tt --more--}. In many versions
of GNU/Linux the {\tt more} command is identical to a more advanced command
that does all that {\tt more} can do and more. Proving that computer
programmers make bad comedians, they named this new program {\tt
less}\ttindex{less}.} {\tt more} will pause once every screenful
of information. For instance, {\tt more < /etc/rc} will display the file
{\tt /etc/rc} just like {\tt cat /etc/rc} would, except that {\tt more}
will let you read it.  {\tt more} also allows the command {\tt more
/etc/rc}, and that's the normal way of invoking it.

However, that doesn't help the problem that {\tt ls /usr/bin} displays more
information than you can see. {\tt more < ls /usr/bin} won't work---input
redirection only works with files, not commands! You {\em could\/} do this:

\begin{screen}\begin{verbatim}
/home/larry# ls /usr/bin > temp-ls
/home/larry# more temp-ls
...
/home/larry# rm temp-ls
\end{verbatim}\end{screen}

However, Unix supplies a much cleaner way of doing that. You can just use
the command {\tt ls /usr/bin | more}. The character "{\tt |}" indicates a
{\bf pipe}. Like a water pipe, a Unix pipe controls flow. Instead of
water, we're controlling the flow of information!

A useful tool with pipes are programs called {\bf
  filters}\index{filters}.  A filter is a program that reads the
standard input, changes it in some way, and outputs to standard
output. {\tt more} is a filter---it reads the data that it gets from
standard input and displays it to standard output one screen at a
time, letting you read the file.  {\tt more} isn't a great filter
because its output isn't suitable for sending to another program.

Other filters include the programs {\tt cat}\ttindex{cat}, {\tt
sort}\ttindex{sort}, {\tt head}\ttindex{head}, and {\tt
tail}\ttindex{tail}. For instance, if you wanted to read only the first ten
lines of the output from {\tt ls}, you could use {\tt ls /usr/bin | head}.

\eindex{pipes}

\section{Multitasking}\label{section-multitasking}

\subsection{Using Job Control}
\index{job control|see{shell, job control}} 

{\bf Job control}\index{shell!job control} refers to the ability to
put processes (another word for programs, essentially) in the
\concept{background} and bring them to the \concept{foreground} again.
That is to say, you want to be able to make something run while you go
and do other things, but have it be there again when you want to tell
it something or stop it.  In Unix, the main tool for job control is
the shell---it will keep track of jobs for you, if you learn how to
speak its language.

        The two most important words in that language are {\tt
fg}\ttindex{fg}, for foreground, and {\tt bg}\ttindex{bg}, for
background.  To find out how they work, use the command \ttindex{yes}
{\tt yes} at a prompt.

\begin{screen}\begin{verbatim}
/home/larry# yes
\end{verbatim}
\end{screen}

This will have the startling effect of running a long column of {\tt
  y}'s down the left hand side of your screen, faster than you can
follow.<footnote>There are good reasons for this strange command to
  exist.  Occasional commands ask for confirmation---a "yes" answer
  to a question.  The {\tt yes} command allows a programmer to
  automate the response to these questions.} To get them to stop,
you'd normally type \key{ctrl-c} to kill it, but instead you should
type \key{ctrl-z} this time.  It appears to have stopped, but there
will be a message before your prompt, looking more or less like this:

\begin{screen}\begin{verbatim}
[1]+   Stopped                  yes
\end{verbatim}
\end{screen}

It means that the process {\tt yes} has been \concept{suspended} in
the background.  You can get it running again by typing \ttindex{fg}
\index{foreground} {\tt fg} at the prompt, which will put it into the
foreground again.  If you wish, you can do other things first, while
it's suspended.  Try a few {\tt ls}'s or something before you put it
back in the foreground.

        Once it's returned to the foreground, the {\tt y}'s will start
coming again, as fast as before.  You do not need to worry that while
you had it suspended it was "storing up" more {\tt y}'s to send to the
screen: when a program is suspended the whole program doesn't run
until you bring it back to life.  (Now type \key{ctrl-c} to
kill it for good, once you've seen enough).

        Let's pick apart that message we got from the shell:

\begin{screen}\begin{verbatim}
[1]+   Stopped                yes
\end{verbatim}\end{screen}

        The number in brackets is the \index{shell!job number} {\bf job
number} of this job, and will be used when we need to refer to it
specifically.  (Naturally, since job control is all about running
multiple processes, we need some way to tell one from another).  The
{\tt +} following it tells us that this is the "current job" ---
that is, the one most recently moved from the foreground to the
background.  If you were to type {\tt fg}, you would put the job with
the {\tt +} in the foreground again.  (More on that later, when we discuss
% kff: changed "get into" to "discuss running"
running multiple jobs at once).  The word {\tt Stopped} means that the
job is "stopped".  The job isn't dead, but it isn't running right
now.  GNU/Linux has saved it in a special suspended state, ready to jump
back into the action should anyone request it.  Finally, the {\tt yes}
is the name of the process that has been stopped.

        Before we go on, let's kill this job and start it again in a
different way.  The command is named \ttindex{kill} {\tt kill} and
can be used in the following way:

\begin{screen}\begin{verbatim}
/home/larry# kill %1
[1]+  Stopped                 yes
/home/larry#
\end{verbatim}\end{screen}
\index{jobs|see{shell, jobs}}

        That message about it being "stopped" again is misleading.
To find out whether it's still alive (that is, either running or
frozen in a suspended state), type \index{shell!jobs} {\tt jobs}:

\begin{screen}\begin{verbatim}
/home/larry# jobs
[1]+  Terminated                 yes
/home/larry#
\end{verbatim}\end{screen}
        
        There you have it---the job has been \index{termination}
terminated!  (It's possible that the {\tt jobs} command showed nothing
at all, which just means that there are no jobs running in the
background.  If you just killed a job, and typing {\tt jobs} shows
nothing, then you know the kill was successful.  Usually it will tell
you the job was "terminated".)

        Now, start {\tt yes} running again, like this:

\begin{screen}\begin{verbatim}
/home/larry# yes > /dev/null
\end{verbatim}\end{screen}

        If you read the section about input and output redirection,
you know that this is sending the output of {\tt yes} into the special
file {\tt /dev/null}.  {\tt /dev/null} is a black hole that eats any
output sent to it (you can imagine that stream of {\tt y}'s coming out
the back of your computer and drilling a hole in the wall, if that
makes you happy).
        
        After typing this, you will not get your prompt back, but you
will not see that column of {\tt y}'s either.  Although output is
being sent into {\tt /dev/null}, the job is still running in the
foreground.  As usual, you can suspend it by hitting \key{ctrl-z}.  Do that
now to get the prompt back.

\begin{screen}\begin{verbatim}
/home/larry# yes > /dev/null
["yes" is running, and we just typed ctrl-z]
[1]+  Stopped                 yes >/dev/null 

/home/larry# 
\end{verbatim}
\end{screen}

Hmm\ldots is there any way to get it to actually {\em run\/} in the
background, while still leaving us the prompt for interactive work?
The command to do that is \ttindex{bg}\index{background}{\tt bg}:

\begin{screen}\begin{verbatim}
/home/larry# bg
[1]+ yes >/dev/null  &
/home/larry# 
\end{verbatim}
\end{screen}

Now, you'll have to trust me on this one: after you typed {\tt bg},
{\tt yes > /dev/null} began to run again, but this time in the
background.  In fact, if you do things at the prompt, like {\tt ls}
and stuff, you might notice that your machine has been slowed down a
little bit (endlessly generating and discarding a steady stream of y's
does take some work, after all!)  Other than that, however, there are
no effects.  You can do anything you want at the prompt, and {\tt yes}
will happily continue to sending its output into the black hole.

        There are now two different ways you can kill it: with the
{\tt kill} command you just learned, or by putting the job in the
foreground again and hitting it with an interrupt, \key{ctrl-c}.  Let's try
the second way, just to understand the relationship between {\tt fg}
and {\tt bg} a little better;

\begin{screen}\begin{verbatim}
/home/larry# fg
yes >/dev/null 

[now it's in the foreground again.  Imagine that I hit ctrl-c to terminate it]

/home/larry#
\end{verbatim}\end{screen}

        There, it's gone.  Now, start up a few jobs running in
simultaneously, like this:

% lg: rephrase the above paragraph, maybe. It's a little awkward and
% lg: too much a meta-paragraph: a paragraph about the document
% kff: done, (good point).

\begin{screen}\begin{verbatim}
/home/larry# yes  > /dev/null &
[1] 1024
/home/larry# yes | sort > /dev/null &
[2] 1026
/home/larry# yes | uniq > /dev/null 
[and here, type ctrl-z to suspend it, please]

[3]+  Stopped                 yes | uniq >/dev/null
/home/larry#
\end{verbatim}\end{screen}

The first thing you might notice about those commands is the trailing
{\tt &amp} at the end of the first two.  \index{&amp} Putting an {\tt &amp}
after a command tells the shell to start in running in the background
right from the very beginning.  (It's just a way to avoid having to
start the program, type \key{ctrl-z}, and then type {\tt bg}.)  So, we
started those two commands running in the background.  The third is
suspended and inactive at the moment.  You may notice that the machine
has become slower now, as the two running ones
require some amount of CPU time.

Each one told you it's job number.  The first two also showed you
their \concept{process identification numbers}, or PID's, \index{PID}
immediately following the job number.  The PID's are normally not
something you need to know, but occasionally come in handy.

        Let's kill the second one, since I think it's making your
machine slow.  You could just type {\tt kill \%2}, but that would be
too easy.  Instead, do this:

\begin{screen}\begin{verbatim}
/home/larry# fg %2
yes | sort >/dev/null
[type ctrl-c to kill it]

/home/larry#
\end{verbatim}\end{screen}

        As this demonstrates, {\tt fg} takes parameters beginning with
{\tt \%} as well.  In fact, you could just have typed this:

\begin{screen}\begin{verbatim}
/home/larry# %2
yes | sort >/dev/null
[type ctrl-c to kill it]

/home/larry#
\end{verbatim}\end{screen}

        This works because the shell automatically interprets a job
number as a request to put that job in the foreground.  It can tell
job numbers from other numbers by the preceding \index{\%} {\tt \%}.
Now type {\tt jobs} to see which jobs are left running:

\begin{screen}\begin{verbatim}
/home/larry# jobs
[1]-  Running                 yes >/dev/null  &
[3]+  Stopped                 yes | uniq >/dev/null
/home/larry#
\end{verbatim}
\end{screen}
        
The "{\tt -}" means that job number 1 is
second in line to be put in the foreground, if you just type {\tt fg}
without giving it any parameters.  The "{\tt +}" means the specified job
is first in line---a {\tt fg} without parameters will bring job number
3 to the foreground.  However, you can get to it by
naming it, if you wish:

\begin{screen}\begin{verbatim}
/home/larry# fg %1
yes >/dev/null 
[now type ctrl-z to suspend it]

[1]+  Stopped                 yes >/dev/null
/home/larry#
\end{verbatim}
\end{screen}

Having changed to job number 1 and then suspending it has also changed
the priorities of all your jobs.  You can see this with the {\tt jobs}
command:

\begin{screen}\begin{verbatim}
/home/larry# jobs
[1]+  Stopped                 yes >/dev/null
[3]-  Stopped                 yes | uniq >/dev/null
/home/larry#
\end{verbatim}
\end{screen}
        
Now they are both stopped (because both were suspended with
\key{ctrl-z}), and number 1 is next in line to come to the foreground
by default.  This is because you put it in the foreground manually,
and then suspended it.  The "{\tt +}" always refers to the most
recent job that was suspended from the foreground.  You can start it
running again:

\begin{screen}\begin{verbatim}
/home/larry# bg
[1]+ yes >/dev/null  &
/home/larry# jobs
[1]-  Running                 yes >/dev/null  
[3]+  Stopped                 yes | uniq >/dev/null
/home/larry#
\end{verbatim}
\end{screen}
        
Notice that now it is running, and the other job has moved back up in
line and has the {\tt +}.  Now let's kill them all so your system
isn't permanently slowed by processes doing nothing.

\begin{screen}\begin{verbatim}
/home/larry# kill %1 %3
[3]   Terminated              yes | uniq >/dev/null 
/home/larry# jobs
[1]+  Terminated              yes >/dev/null 
/home/larry#
\end{verbatim}
\end{screen}

You should see various messages about termination of jobs---nothing
dies quietly, it seems.  Figure~\vref{job-control} shows a quick
summary of what you should know for job control.

\begin{figure}[tb]
\index{shell!job control!summary}
\begin{dispitems}
\item [{\tt fg} {\sl \%job}] This is a shell command that returns a
  job to the foreground.  To find out which one this is by default,
  type {\tt jobs} and look for the one with the {\tt +}.\\ Parameters:
  Optional job number.  The default is the process identified
  with {\tt +}.

\item [{\tt &amp}] When an {\tt &amp} is added to the end of the command
  line, it tells the command to run in the background automatically.
  This process is then subject to all the usual methods of job control
  detailed here.

\item [{\tt bg} {\sl \%job}] This is a shell command that causes a
  suspended job to run in the background.  To find out which one this
  is by default, type {\tt jobs} and look for the one with the {\tt
    +}.\\ Parameters: Optional job number.  The default is
  the process identified with {\tt +}.

\item [{\tt kill} {\sl \%job} {\sl PID}] This is a shell
  command that causes a background job, either suspended or running,
  to terminate.  You should always specify the job number or PID, and
  if you are using job numbers, remember to precede them with a {\tt
    \%}.\\ Parameters: Either the job number (preceded by {\tt \%}) or
  PID (no {\tt \%} is necessary).  More than one process or job can be
  specified on one line.

\item [{\tt jobs}] This shell command just lists information about the
  jobs currently running or suspending.  Sometimes it also tells you
  about ones that have just exited or been terminated.

\item [\key{ctrl-c}]
        This is the generic interrupt character.  Usually, if you type
it while a program is running in the foreground, it will kill the
program (sometimes it takes a few tries).  However, not all programs
will respond to this method of termination.

\item [\key{ctrl-z}] This key combination usually causes a program to
  suspend, although a few programs ignore it.  Once suspended, the job
  can be run in the background or killed.
\end{dispitems}
\caption{A summary of commands and keys used in job control.}
\label{job-control}
\end{figure}

\subsection{The Theory of Job Control}
\index{shell!job control!concepts}

        It is important to understand that job control is done by the
shell.  There is no program on the system called {\tt fg}; rather,
{\tt fg}, {\tt bg}, {\tt &amp}, {\tt jobs}, and {\tt kill} are all
shell-builtins (actually, sometimes {\tt kill} is an independent
program, but the {\tt bash} shell used by Linux has it built in).
This is a logical way to do it: since each user wants their own job
control space, and each user already has their own shell, it is
% lg: why the quotes?
% kff: good question :-)... computer techies tend
% to use the word "space" in a way unfamiliar to many people, but I
% think readers can grok it from context, now that you bring it up, so
% I have killed the quotes.
easiest to just have the shell keep track of the user's jobs.
Therefore, each user's job numbers are meaningful only to that user:
my job number [1] and your job number [1] are probably two totally
different processes.  In fact, if you are logged in more than once,
each of your shells will have unique job control data, so you as a
user might have two different jobs with the same number running in two
different shells.

        The way to tell for sure is to use the Process ID numbers
({\tt PID}'s).  These are system-wide --- each process has its own
unique {\tt PID} number.  Two different users can refer to a process
by its {\tt PID} and know that they are talking about the same process
(assuming that they are logged into the same machine!)

Let's take a look at one more command to understand what {\tt PID}s
are. The {\tt ps} command will list all running processes, including
your shell. Try it out. It also has a few options, the most important
of which (to many people) are {\tt a}, {\tt u}, and {\tt x}.  The {\tt
  a} option will list processes belonging to any user, not just your
own. The {\tt x} switch will list processes that don't have a terminal
associated with them.<footnote>This only makes sense for certain
  system programs that don't have to talk to users through a
  keyboard.</footnote> Finally, the {\tt u} switch will give additionally
information about the process that is frequently useful.

To really get an idea of what your system is doing, put them all
together: {\tt ps -aux}. You can then see the process that uses the
more memory by looking at the {\tt \%MEM} column, and the most CPU
by looking at the {\tt \%CPU} column. (The {\tt TIME} column lists the
{\em total\/} amount of CPU time used.)\glossary{CPU time} 

Another quick note about PIDs.  {\tt kill}, in addition to taking
options of the form \%{\sl job\#}, will take options of raw PIDs. So,
put a {\tt yes > /dev/null} in the background, run {\tt ps}, and look
for {\tt yes}. Then type {\tt kill PID}.<footnote>In general, it's
  easier to just kill the job number instead of using PIDs.</footnote>

        If you start to program in C on your Linux system, you will
soon learn that the shell's job control is just an interactive version
of the function calls {\tt fork} and {\tt execl}.  This is too complex
to go into here, but may be helpful to remember later on when you are
programming and want to run multiple processes from a single program.

\chapter{Powerful Little Programs}\label{commands-chapter}

\begin{screen}\begin{verbatim}
better !pout !cry
better watchout
lpr why
santa claus <north pole >town

cat /etc/passwd >list
ncheck list 
ncheck list
cat list | grep naughty >nogiftlist
cat list | grep nice >giftlist
santa claus <north pole > town

who | grep sleeping
who | grep awake
who | egrep 'bad|good'
for (goodness sake) {
        be good
}
\end{verbatim}\end{screen}

% I need a neato quote-type thing here.
% by the way, if anyone can figure out a better way to format this so
% that the command titles stand out better (and maybe have a short
% description next to them) I'd appreciate it

\section{The Power of \unix}

The power of Unix is hidden in small commands that don't seem too
useful when used alone, but when combined with other commands (either
directly or indirectly) produce a system that's much more powerful and
flexible than most other operating systems.  The commands I'm
going to talk about in this chapter include {\tt sort}, {\tt grep},
{\tt more}, {\tt cat}, {\tt wc}, {\tt spell}, {\tt diff}, {\tt head},
and {\tt tail}. Unfortunately, it isn't totally intuitive what these
names mean right now.  

Let's cover what each of these utilities do separately and then I'll
give some examples of how to use them together.<footnote>Please note
  that the short summaries on commands in this chapter are not
  comprehensive. Please consult the command's manpage if you want to
  know every option.}

\section{Operating on Files}

In addition to the commands like {\tt cd}, {\tt mv}, and {\tt rm} you
learned in Chapter~\ref{shell-chapter}, there are other commands that
just operate on files but not the data in them. These include {\tt
  touch}, {\tt chmod}, {\tt du}, and {\tt df}. All of these files
don't care what is {\em in\/} the file---the merely change some of the
things Unix remembers about the file.

Some of the things these commands manipulate:
\begin{itemize}
\item The time stamp\glossary{time stamp}. Each file has three dates
  associated with it.<footnote>Older filesystems in GNU/Linux only
    stored one date, since they were derived from Minix. If you have
    one of these filesystems, some of the information will merely be
    unavailable---operation will be mostly unchanged.} The three dates
  are the creation time (when the file was created), the last
  modification time (when the file was last changed), and the last
  access time (when the file was last read).
\item The owner. Every file in Unix is owned by one user or the
  other.
\item The group.  Every file also has a group of users it is
  associated with. The most common group for user files is called {\tt
    users}, which is usually shared by all the user account on the
  system.
\item The permissions\index{permissions}. Every file has permissions
  (sometimes called "privileges") associated with it
  which tell Unix who can access what file, or change it, or, in the
  case of programs, execute it. Each of these permissions can be
  toggled separately for the owner, the group, and all other users.
\end{itemize}

\begin{command}
  {\tt touch}\impttindex{touch} {\sl file1 file2 \ldots fileN}
\end{command}

{\tt touch} will update the time stamps of the files listed on the
command line to the current time. If a file doesn't exist, {\tt touch}
will create it.  It is also possible to specify the time that {\tt
  touch} will set files to---consult the the manpage for {\tt touch}.

\begin{command}
{\tt chmod}\impttindex{chmod} [-Rfv] {\sl mode} {\sl file1 file2 \ldots fileN}
\end{command}

\bindex{file!permissions} The command used to change the permissions
on a file is called {\tt chmod}, short for {\bf ch}ange {\bf mod}e.
Before I go into how to use the command, let's discuss what
permissions are in \unix. Each file has a group of permissions
associated with it.  These permissions tell Unix whether or not the
file can be read from, written to, or executed as a program. (In the
next few paragraphs, I'll talk about users doing these things.  Any
programs a user runs are allowed to do the same things a user is. This
can be a security problem if you don't know what a particular program
does.)

Unix recognizes three different types of people: first, the owner of
the file (and the person allowed to use {\tt chmod} on that file).
Second, the "group".  The group of most of your files might be
"users", meaning the normal users of the system. (To find out the
group of a particular file, use {\tt ls -l {\sl file}}.) Then, there's
everybody else who isn't the owner and isn't a member of the group,
appropriately called "other".

So, a file could have read and write permissions for the owner, read
permissions for the group, and no permissions for all others.  Or, for
some reason, a file could have read/write permissions for the group
and others, but {\em no\/} permissions for the owner!

Let's try using {\tt chmod} to change a few permissions. First, create
a new file using {\tt cat}, {\tt emacs}, or any other program. By
default, you'll be able to read and write this file. (The permissions
given other people will vary depending on how the system and your
account is setup.) Make sure you can read the file using {\tt
  cat}. Now, let's take away your read privilege by using {\tt chmod
  u-r {\sl filename}}. (The parameter {\tt u-r} decodes to "user
minus read".) Now if you try to read the file, you get a {\tt
  Permission denied} error! Add read privileges back by using {\tt
  chmod u+r {\sl filename}}.
\eindex{file!permissions} 
\index{file!privileges|see{file, permissions}}
\index{security|see{file, permissions}}

Directory permissions\index{directory!permissions} use the same three
ideas: read, write, and execute, but act slightly differently. The
read privilege allows the user (or group or others) to read the
directory---list the names of the files.  The write permission allows
the user (or group or others) to add or remove files. The execute
permission allows the user to access files in the directory or any
subdirectories. (If a user doesn't have execute permissions for a
directory, they can't even {\tt cd} to it!)

To use {\tt chmod}, replace the {\sl mode} with what to operate on,
either {\bf u}ser, {\bf g}roup, {\bf o}ther, or {\bf a}ll, and what to
do with them. (That is, use a plus sign to indicate adding a privilege
or a minus sign to indicate taking one away. Or, an equals sign will
specify the exact permissions.) The possible permissions to add are
{\bf r}ead, {\bf w}rite, and e{\bf x}ecute.

{\tt chmod}'s {\tt R} flag will change a directory's permissions, and
all files in that directory, and all subdirecties, all the way down
the line. (The `R' stands for recursive.)  The {\tt f} flag forces
{\tt chmod} to attempt to change permissions, even if the user isn't
the owner of the file. (If {\tt chmod} is given the {\tt f} flag, it
won't print an error message when it fails to change a file's
permissions.)  The {\tt v} flag makes {\tt chmod} verbose---it will
report on what it's done.

\section{System Statistics}

Commands in this section will display statistics about the operating
system, or a part of the operating system.

\begin{command}
  {\tt du}\impttindex{du} [-abs] [{\sl path1 path2 \ldots pathN}]
\end{command}

{\tt du} stands for {\bf d}isk {\bf u}sage. It will count the amount
of disk space a given directory {\em and all its subdirectories} take
up on the disk. {\tt du} by itself will return a list of how much
space every subdirectory of the current directory consumes, and, at
the very bottom, how much space the current directory (plus all the
previously counted subdirectories) use. If you give it a parameter or
two, it will count the amount of space used by those files or
directories instead of the current one.

The {\tt a} flag will display a count for files, as well as
directories. An option of {\tt b} will display, instead of kilobytes
(1024 characters), the total in bytes. One byte is the equivalent of
one letter in a text document. And the {\tt s} flag will just display
the directories mentioned on the command-line and {\em not\/} their
subdirectories.

\begin{command}
  {\tt df}\impttindex{df}
\end{command}

{\tt df} is short for "disk filling": it summarizes the amount of
disk space in use. For each filesystem (remember, different
filesystems are either on different drives or partitions) it shows the
total amount of disk space, the amount used, the amount available, and
the total capacity of the filesystem that's used.

One odd thing you might encounter is that it's possible for the
capacity to go over 100\%, or the used plus the available not to equal
the total. This is because Unix reserves some space on each
filesystem for {\tt root}. That way if a user accidentally fills the
disk, the system will still have a little room to keep on operating.

For most people, {\tt df} doesn't have any useful options.

\begin{command}
  {\tt uptime}\impttindex{uptime}
\end{command}

The {\tt uptime} program does exactly what one would suspect. It
prints the amount of time the system has been "up"---the amount of
time from the last Unix boot. 

{\tt uptime} also gives the current time and the load
average.\index{load average} The load average is the average number of
jobs waiting to run in a certain time period. {\tt uptime} displays
the load average for the last minute, five minutes, and ten minutes.
A load average near zero indicates the system has been relatively
idle. A load average near one indicates that the system has been
almost fully utilized but nowhere near overtaxed. High load averages
are the result of several programs being run simultaneously.

Amazingly, {\tt uptime} is one of the few Unix programs that have
{\em no\/} options!

\begin{command}
  {\tt who}\impttindex{who}
\end{command}

{\tt who} displays the current users of the system and when they
logged in. If given the parameters {\tt am i} (as in: {\tt who am i}),
it displays the current user.

\begin{command}
  {\tt w}\impttindex{w} [-f] [{\sl username}]
\end{command}

The {\tt w} program displays the current users of the system and what
they're doing. (It basically combines the functionality of {\tt
  uptime}\ttindex{uptime} and {\tt who}. The header of
{\tt w} is exactly the same as {\tt uptime}, and each line shows a
user, when the logged on (and how long they've been idle). {\tt JCPU}
is the total amount of CPU time used by that user, while {\tt PCPU}
the the total amount of CPU time used by their present task.

If {\tt w} is given the option {\tt f}, it shows the remote system
they logged in from, if any. The optional parameter restricts {\tt w}
to showing only the named user.

\section{What's in the File?}

There are two major commands used in Unix for listing files, {\tt
  cat} and {\tt more}. I've talked about both of them in
Chapter~\ref{shell2-chapter}.

\begin{command}
{\tt cat}\impttindex{cat} [-nA] [{\sl file1 file2 \ldots fileN}]
\end{command}

{\tt cat} is not a user friendly command---it doesn't wait for you to
read the file, and is mostly used in conjuction with pipes. However,
{\tt cat} does have some useful command-line options. For instance,
{\tt n} will number all the lines in the file, and {\tt A} will show
control characters as normal characters instead of (possibly) doing
strange things to your screen. (Remember, to see some of the stranger
and perhaps "less useful" options, use the {\tt man} command: {\tt
  man cat}.) {\tt cat} will accept input from stdin if no files
are specified on the command-line.

\begin{command}
{\tt more}\impttindex{more} [-l] [+{\sl linenumber}] [{\sl file1 file2 \ldots fileN}]
\end{command}

{\tt more} is much more useful, and is the command that you'll want to
use when browsing ASCII text files.  The only interesting option is
{\tt l}, which will tell {\tt more} that you aren't interested in
treating the character \key{Ctrl-L} as a "new page" character. {\tt
  more} will start on a specified linenumber.

Since {\tt more} is an interactive command, I've summarized the major
interactive commands below:
\begin{description}
\item [\key{Spacebar}] Moves to the next screen of text.
\item [\key{d}] This will scroll the screen by 11 lines, or about half
  a normal, 25-line, screen.
\item [\key{/}] Searches for a regular expression. While a regular
  expression can be quite complicated, you can just type in a text
  string to search for. For example, {\tt /toad}\ret\ would search for
  the next occurence of "toad" in your current file. A slash
  followed by a return will search for the next occurence of what you
  last searched for.
\item [\key{n}] This will also search for the next occurence of your
  regular expression.
\item [\key{:}\key{n}] If you specified more than one file on the
  command line, this will move to the next file.
\item [\key{:}\key{p}] This will move the the previous file.
\item [\key{q}] Exits from {\tt more}.
\end{description}

\pagebreak
\begin{command}
  {\tt head}\impttindex{head} [-{\sl lines}] [{\sl file1 file2 \ldots fileN}]
\end{command}

{\tt head} will display the first ten lines in the listed files, or
the first ten lines of stdin if no files are specified on the
command line. Any numeric option will be taken as the number of lines
to print, so {\tt head -15 frog} will print the first fifteen lines of
the file {\tt frog}.

\begin{command}
  {\tt tail}\impttindex{tail} [-{\sl lines}] [{\sl file1 file2 \ldots fileN}]
\end{command}

Like {\tt head}, {\tt tail} will display only a fraction of the file.
Naturally, {\tt tail} will display the end of the file, or the last
ten lines that come through stdin. {\tt tail} also accepts a
option specifying the number of lines.

\begin{command}
  {\tt file} [{\sl file1 file2 \ldots fileN}]
\end{command}

The {\tt file} command attempts to identify what format a particular
file is written in. Since not all files have extentions or other easy
to identify marks, the {\tt file} command performs some rudimentary
checks to try and figure out exactly what it contains.

Be careful, though, because it is quite possible for {\tt file} to
make a wrong identification.

\section{Information Commands}

This section discusses the commands that will alter a file, perform a
certain operation on the file, or display statistics on the file.

%\begin{quote}
%  {\tt sort}\impttindex{sort} [
%\end{quote}
% should sort be discussed here, or is it complicated enough to merit
% its own section in another chapter?

\begin{command}
  {\tt grep}\impttindex{grep} [-nvwx] [-{\sl number\/}] {\sl
    expression} [{\sl file1 file2 \ldots fileN\/}]
\end{command}

One of the most useful commands in Unix is {\tt grep}, the
{\bf g}eneralized {\bf r}egular {\bf e}xpression {\bf p}arser. This is
a fancy name for a utility which can only search a text file.  The
easiest way to use {\tt grep} is like this:

\begin{screen}\begin{verbatim}
/home/larry# cat animals
Animals are very interesting creatures. One of my favorite animals is
the tiger, a fearsome beast with large teeth.
I also like the lion---it's really neat!
/home/larry# grep iger animals
the tiger, a fearsome beast with large teeth.
/home/larry#
\end{verbatim}\end{screen}

One disadvantage of this is, although it shows you all the lines
containing your word, it doesn't tell you where to look in the
file---no line number. Depending on what you're doing, this might be
fine. For instance, if you're looking for errors from a programs
output, you might try {\tt a.out | grep error}, where {\tt a.out} is
your program's name.

If you're interested in where the match(es) are, use the {\tt n}
switch to {\tt grep} to tell it to print line numbers. Use the {\tt v}
switch if you want to see all the lines that {\em don't\/} match the
specified expression.

Another feature of {\tt grep} is that it matches only parts of a word,
like my example above where {\tt iger} matched {\tt tiger}. To tell
{\tt grep} to only match whole words, use the {\tt w}, and the {\tt x}
switch will tell grep to only match whole lines.

If you don't specify any files, {\tt grep} will examine stdin.

\begin{command}
  {\tt wc}\impttindex{wc} [-clw] [{\sl file1 file2 \ldots fileN\/}]
\end{command}

{\tt wc} stands for {\bf w}ord {\bf c}ount. It simply counts the
number of words, lines, and characters in the file(s). If there aren't
any files specified on the command line, it operates on stdin.

The three parameters, {\tt clw}, stand for {\bf c}haracter, {\bf
  l}ine, and {\bf w}ord respectively, and tell {\tt wc} which of the
three to count. Thus, {\tt wc -cw} will count the number of characters
and words, but not the number of lines. {\tt wc} defaults to counting
everything---words, lines, and characters.

One nice use of {\tt wc} is to find how many files are in the present
directory: {\tt ls | wc -w}. If you wanted to see how many files that
ended with {\tt .c} there are, try {\tt ls *.c | wc -w}.

\begin{command}
  {\tt spell}\impttindex{spell} [{\sl file1 file2 \ldots fileN\/}]
\end{command}

{\tt spell} is a very simple Unix spelling program, usually for
American English.<footnote>While there are versions of this for
  several other European languages, the copy on your GNU/Linux machine
  is most likely for American English.} {\tt spell} is a filter, like
most of the other programs we've talked about, which sucks in an ASCII
text file and outputs all the words it considers misspellings.  {\tt
  spell} operates on the files listed in the command line, or, if
there weren't any there, stdin.

A more sophisticated spelling program, {\tt ispell}\ttindex{ispell} is
probably also available on your machine.  {\tt ispell} will offer
possible correct spellings and a fancy menu interface if a filename is
specified on the command line or will run as a filter-like program if
no files are specified.

While operation of {\tt ispell}\ttindex{ispell} should be fairly
obvious, consult the man page if you need more help.

\begin{command}
  {\tt cmp}\impttindex{cmp} {\sl file1} [{\sl file2\/}]
\end{command}

{\tt cmp} {\bf c}o{\bf mp}ares two files. The first must be listed on
the command line, while the second is either listed as the second
parameter or is read in from standard input. {\tt cmp} is very simple,
and merely tells you where the two files first differ.

\begin{command}
  {\tt diff}\impttindex{diff} {\sl file1 file2}
\end{command}

One of the most complicated standard Unix commands is called {\tt
  diff}. The GNU\index{GNU Project} version of {\tt diff} has over
twenty command line options! It is a much more powerful version of
{\tt cmp} and shows you what the differences are instead of merely
telling you where the first one is.

Since talking about even a good portion of {\tt diff} is beyond the
scope of this book, I'll just talk about the basic operation of {\tt
  diff}.  In short, {\tt diff} takes two parameters and displays the
differences between them on a line-by-line basis. For instance:

\begin{screen}\begin{verbatim}
/home/larry# cat frog
Animals are very interesting creatures. One of my favorite animals is
the tiger, a fearsome beast with large teeth.
I also like the lion---it's really neat!
/home/larry# cp frog toad
/home/larry# diff frog toad
/home/larry# cat dog
Animals are very nteresting creatures. One of my favorite animals is

the tiger, a fearsome beast with large teeth.
I also   like the lion---it's really neat!
/home/larry# diff frog dog
1c1,2
< Animals are very interesting creatures. One of my favorite animals is
---
> Animals are very nteresting creatures. One of my favorite animals is
> 
3c4
< I also like the lion---it's really neat!
---
> I also   like the lion---it's really neat!
/home/larry#
\end{verbatim}\end{screen}

As you can see, {\tt diff} outputs nothing when the two files are
identical.  Then, when I compared two different files, it had a
section header, {\tt 1c1,2} saying it was comparing line 1 of the left
file, {\tt frog}, to lines 1--2 of {\tt dog} and what differences it
noticed. Then it compared line 3 of {\tt frog} to line 4 of {\tt dog}.
While it may seem strange at first to compare different line numbers,
it is much more efficent then listing out every single line if there
is an extra return early in one file.

\begin{command}
  {\tt gzip}\impttindex{gzip} [-v\#] [{\sl file1 file2 \ldots fileN}]\\
  {\tt gunzip}\impttindex{gunzip} [-v] [{\sl file1 file2 \ldots
    fileN}]\\
  {\tt zcat}\impttindex{zcat} [{\sl file1 file2 \ldots fileN}]
\end{command}

These three programs are used to compress\glossary{compress} and
decompress\glossary{decompress} data.  {\tt gzip}, or GNU Zip, is the
program that reads in the original file(s) and outputs files that are
smaller. {\tt gzip} deletes the files specified on the command line
and replaces them with files that have an identical name except that
they have "{\tt .gz}" appended to them.

\begin{command}
  {\tt tr}\impttindex{tt} {\sl string1} {\sl string2}
\end{command}

The "translate characters" command operates on standard input---it
doesn't accept a filename as a parameter.  Instead, it's two
parameters are arbitrary strings.  It replaces all occurences of {\sl
  string1} in the input with {\sl string2}.  In addition to relatively
simple commands such as {\tt tr frog toad}, {\tt tr} can accept more
complicated commands.  For instance, here's a quick way of converting
lowercase characters into uppercase ones:

\begin{screen}\begin{verbatim}
/home/larry# tr [:lower:] [:upper:]
this is a WEIRD sentence.
THIS IS A WEIRD SENTENCE.
\end{verbatim}\end{screen}
  
{\tt tr} is fairly complex and usually used in small shell programs.


\chapter{I Gotta Be Me!}\label{configuration-chapter}

\begin{quote}
  If God had known we'd need foresight, she would have given it to us.
\end{quote}

\section{{\tt bash} Customization}

One of the distinguishing things about the Unix philosophy is that the
system's designers did not attempt to predict every need that users
might have; instead, they tried to make it easy for each individual
user to tailor the environment to their own particular needs.  This is
mainly done through {\bf configuration files}\index{configuration
  files}. These are also known as "init files"\index{init files},
"rc files"\index{rc files} (for "run control"), or even "dot
files", because the filenames often begin with "{\tt .}". If you'll
recall, filenames that start with "{\tt .}" aren't normally
displayed by {\tt ls}.

The most important configuration files are the ones used by the shell.
Linux's default shell is {\tt bash}\ttindex{bash}, and that's the
shell this chapter covers. Before we go into how to customize {\tt
  bash}, we should know what files {\tt bash} looks at.

\subsection{Shell Startup}

There are several different ways {\tt bash} can run. It can run as a
{\bf login shell}\index{login shell}, which is how it runs when you
first login. The login shell should be the first shell you see.

Another way {\tt bash} can run is as an {\bf interactive
  shell}\index{interactive shell}. This is any shell which presents a
prompt to a human and waits for input. A login shell is also an
interactive shell. A way you can get a non-login interactive shell is,
say, a shell inside {\tt xterm}\ttindex{xterm}. Any shell that
was created by some other way besides logging in is a non-login shell.

Finally, there are {\bf non-interactive shells}\index{non-interactive
  shell}. These shells are used for executing a file of commands, much
like MS-DOS\index{MS-DOS}'s batch files---the files that end in {\tt
  .BAT}. These {\bf shell scripts}\index{shell scripts} function like
mini-programs. While they are usually much slower than a regular
compiled program, it is often true that they're easier to write.

Depending on the type of shell, different files will be used at shell
startup:

\begin{center}
\begin{tabular}{|l|l|}\hline
  \multicolumn{1}{|c|}{Type of Shell} &
     \multicolumn{1}{c|}{Action}\\ \hline
  Interactive login & The file {\tt .bash\_profile} is read and
                      executed\\ \hline
  Interactive       & The file {\tt .bashrc} is read and \ttindex{.bashrc}
                      executed\\ \hline
  Non-interactive   & The shell script is read and executed \\ \hline
\end{tabular}
\end{center}

\subsection{Startup Files}

Since most users want to have largely the same environment no matter
what type of interactive shell they wind up with, whether or not it's
a login shell, we'll start our configuration by putting a very simple
command into our {\tt .bash\_profile}: "{\tt source
  \verb+~+/.bashrc}". The {\tt source}\ttindex{source} command tells
the shell to interprete the argument as a shell script. What it means
for us is that everytime {\tt .bash\_profile} is run, {\tt .bashrc} is
{\em also\/} run.

Now, we'll just add commands to our {\tt .bashrc}. If you ever want a
command to only be run when you login, add it to your {\tt
  .bash\_profile}.

\subsection{Aliasing}\label{aliasing-section}

        What are some of the things you might want to customize?
Here's something that I think about 90\% of Bash users have put in
their {\tt .bashrc}:

\begin{screen}\begin{verbatim}
alias ll="ls -l"
\end{verbatim}\end{screen}

That command defined a shell {\bf alias}\impindex{shell!alias} called
{\tt ll} that "expands" to the normal shell command "{\tt ls~-l}"
when invoked by the user.  So, assuming that Bash has read that
command in from your {\tt .bashrc\/}, you can just type {\tt ll} to
get the effect of "{\tt ls~-l}" in only half the keystrokes.  What
happens is that when you type {\tt ll} and hit \key{Return}, Bash
intercepts it, because it's watching for aliases, replaces it with
"{ls~-l}", and runs that instead.  There is no actual program called
{\tt ll} on the system, but the shell automatically translated the
alias into a valid program.

Some sample aliases are in Figure~\ref{sample-aliases}.  You could put
them in your own {\tt .bashrc}. One especially interesting alias is
the first one. With that alias, whenever someone types {\tt ls}, they
automatically have a {\tt -F} flag tacked on. (The alias
doesn't try to expand itself again.) This is a common way of adding
options that you use every time you call a program.

Notice the comments with the {\tt \#} character in
Figure~\ref{sample-aliases}. Whenever a {\tt \#} appears, the shell
ignores the rest of the line.\index{shell!comments}

\begin{figure}\label{sample-aliases}
\begin{screen}\begin{verbatim}
alias ls="ls -F"          # give characters at the end of listing
alias ll="ls -l"          # special ls
alias la="ls -a"
alias ro="rm *~; rm .*~"  # this removes backup files created by Emacs
alias rd="rmdir"          # saves typing!
alias md="mkdir"
alias pu=pushd            # pushd, popd, and dirs weren't covered in this
alias po=popd             # manual---you might want to look them up
alias ds=dirs             # in the bash manpage
# these all are just keyboard shortcuts
alias to="telnet cs.oberlin.edu"
alias ta="telnet altair.mcs.anl.gov"
alias tg="telnet wombat.gnu.ai.mit.edu"
alias tko="tpalk kold@cs.oberlin.edu"
alias tjo="talk jimb@cs.oberlin.edu"
alias mroe="more"         # spelling correction!
alias moer="more"
alias email="emacs -f rmail" # my mail reader
alias ed2="emacs -d floss:0 -fg \"grey95\" -bg \"grey50\""
                          # one way of invoking emacs
\end{verbatim}\end{screen}
\caption{Some sample aliases for {\tt bash}.}
\end{figure}        

You might have noticed a few odd things about them.  First of all, I
leave off the quotes in a few of the aliases---like {\tt pu}.
Strictly speaking, quotes aren't necessary when you only have one word
on the right of the equal sign. 

It never hurts to have quotes either, so don't let me get you
into any bad habits.  You should certainly use them if you're going to
be aliasing a command with options and/or arguments:

\begin{screen}\begin{verbatim}
alias rf="refrobnicate -verbose -prolix -wordy -o foo.out"
\end{verbatim}\end{screen}

Also, the final alias has some funky quoting going on:

\begin{screen}\begin{verbatim}
alias ed2="emacs -d floss:0 -fg \"grey95\" -bg \"grey50\""
\end{verbatim}\end{screen}

As you might have guessed, I wanted to pass double-quotes in the
options themselves, so I had to quote those with a backslash to
prevent {\tt bash} from thinking that they signaled the end of the
alias.

Finally, I have actually aliased two common typing mistakes, "mroe"
and "moer", to the command I meant to type, {\tt more}.  Aliases do
not interfere with your passing arguments to a program. The following
works just fine:

\begin{screen}\begin{verbatim}
/home/larry# mroe hurd.txt
\end{verbatim}\end{screen}

In fact, knowing how to make your own aliases is probably at least
half of all the shell customization you'll ever do.  Experiment a
little, find out what long commands you find yourself typing
frequently, and make aliases for them.  You'll find that it makes
working at a shell prompt a much more pleasant experience.

\subsection{Environment Variables}\label{section-env-variables}

Another major thing one does in a {\tt .bashrc} is set {\bf
  environment variables}\index{environment variables}.  And what are
environment variables?  Let's go at it from the other direction:
suppose you are reading the documentation for the program {\tt
  fruggle}, and you run across these sentences:

\begin{quote}
  Fruggle normally looks for its configuration file, {\tt .frugglerc},
  in the user's home directory.  However, if the environment variable
  {\tt FRUGGLEPATH} is set to a different filename, it will look there
  instead.
\end{quote}

Every program executes in an {\bf environment}\index{environment}, and
that environment is defined by the shell that called the
program<footnote>Now you see why shells are so important.  Imagine if
  you had to pass a whole environment by hand every time you called a
  program!}.  The environment could be said to exist "within" the
shell.  Programmers have a special routine for querying the
environment, and the {\tt fruggle} program makes use of this routine.
It checks the value of the environment variable {\tt FRUGGLEPATH}.  If
that variable turns out to be undefined, then it will just use the
file {\tt .frugglerc} in your home directory.  If it is defined,
however, {\tt fruggle} will use the variable's value (which should
be the name of a file that {\tt fruggle} can use) instead of the
default {\tt .frugglerc}.

Here's how you can change your environment in {\tt bash}\ttindex{bash}:

\begin{screen}\begin{verbatim}
/home/larry# export PGPPATH=/home/larry/secrets/pgp
\end{verbatim}\end{screen}

        You may think of the {\tt export} command as meaning "Please
export this variable out to the environment where I will be calling
programs, so that its value is visible to them."  There are actually
reasons to call it {\tt export}, as you'll see later.

This particular variable is used by Phil Zimmerman\index{Zimmerman,
  Paul}'s infamous public-key encryption program, {\tt
  pgp}\ttindex{pgp}.  By default, {\tt pgp} uses your home directory
as a place to find certain files that it needs (containing encryption
keys), and also as a place to store temporary files that it creates
when it's running.  By setting variable {\tt PGPPATH} to this value, I
have told it to use the directory {\tt /home/larry/secrets/pgp}
instead. I had to read the {\tt pgp} manual to find out the exact name
of the variable and what it does, but it is farily standard to use the
name of the program in capital letters, prepended to the suffix
"PATH".

It is also useful to be able to query the environment:

\begin{screen}\begin{verbatim}
/home/larry# echo $PGPPATH
/home/larry/.pgp
/home/larry#
\end{verbatim}\end{screen}

        Notice the "\$"; you prefix an environment variable with a
dollar sign in order to extract the variable's value.  Had you typed
it without the dollar sign, {\tt echo} would have simply echoed its
argument(s):

\begin{screen}
   \begin{verbatim}
/home/larry# echo PGPPATH
PGPPATH
/home/larry#
   \end{verbatim}
\end{screen}

The "\$" is used to {\em evaluate} environment variables, but it
only does so in the context of the shell---that is, when the shell is
interpreting.  When is the shell interpreting?  Well, when you are
typing commands at the prompt, or when {\tt bash} is reading commands
from a file like {\tt .bashrc}, it can be said to be "interpreting"
the commands.

There's another command that's very useful for querying the
environment: {\tt env}\impttindex{env}. {\tt env} will merely list all
the environment variables. It's possible, especially if you're using
X, that the list will scroll off the screen. If that happens, just
pipe {\tt env} through {\tt more}: {\tt env | more}.

A few of these variables can be fairly useful, so I'll cover
them. Look at Figure~\ref{env-variables}.  Those four variables are
defined automatically when you login: you don't set them in your {\tt
  .bashrc} or {\tt .bash\_login}.

\begin{figure}\label{env-variables}
\begin{center}
\begin{tabular}{|l|l|l|}\hline
  \multicolumn{1}{|c|}{Variable name} &
    \multicolumn{1}{c|}{Contains} &
    \multicolumn{1}{c|}{Example}\\ \hline
  {\tt HOME} & Your home directory & {\tt /home/larry} \\ \hline
  {\tt TERM} & Your terminal type & {\tt xterm}, {\tt vt100}, or {\tt
    console} \\ \hline
  {\tt SHELL} & The path to your shell & {\tt /bin/bash} \\ \hline
  {\tt USER} & Your login name & {\tt larry} \\ \hline
  {\tt PATH} & A list to search for programs &
    {\tt /bin:/usr/bin:/usr/local/bin:/usr/bin/X11}\\ \hline
\end{tabular}
\end{center}
\caption{Some important environment variables.}
\end{figure}

Let's take a closer look at the {\tt TERM} variable.\index{terminals}
To understand that one, let's look back into the history of \unix: The
operating system needs to know certain facts about your console, in
order to perform basic functions like writing a character to the
screen, moving the cursor to the next line, etc.  In the early days of
computing, manufacturers were constantly adding new features to their
terminals: first reverse-video, then maybe European character sets,
eventually even primitive drawing functions (remember, these were the
days before windowing systems and mice).  However, all of these new
functions represented a problem to programmers: how could they know
what a terminal supported and didn't support? And how could they
support new features without making old terminals worthless?

In \unix, the answer to these questions was {\tt
  /etc/termcap}\ttindex{/etc/termcap}. {\tt /etc/termcap} is a list of
all of the terminals that your system knows about, and how they
control the cursor. If a system administrator got a new terminal, all
they'd have to do is add an entry for that terminal into {\tt
  /etc/termcap} instead of rebuilding all of \unix. Sometimes, it's
even simplier. Along the way, Digital Equipment
Corporation\index{Digital Equipment Corporation}'s vt100\index{vt100}
terminal became a pseudo-standard, and many new terminals were built
so that they could emulate it, or behave as if they were a vt100.

Under GNU/Linux, {\tt TERM}'s value is sometimes {\tt console}, which is
a vt100-like terminal with some extra features.

\bindex{shell!search path}
Another variable, {\tt PATH}, is also crucial to the proper functioning of
the shell.  Here's mine:

\begin{screen}\begin{verbatim}
/home/larry# env | grep ^PATH
PATH=/home/larry/bin:/bin:/usr/bin:/usr/local/bin:/usr/bin/X11:/usr/TeX/bin
/home/larry#
\end{verbatim}\end{screen}

Your {\tt PATH} is a colon-separated list of the directories the shell
should search for programs, when you type the name of a program to
run.  When I type {\tt ls} and hit \key{Return}, for example, the Bash
first looks in {\tt /home/larry/bin}, a directory I made for storing
programs that I wrote.  However, I didn't write {\tt ls} (in fact, I
think it might have been written before I was born!).  Failing to find
it in {\tt /home/larry/bin}, Bash looks next in {\tt /bin}---and there
it has a hit!  {\tt /bin/ls} does exist and is executable, so Bash
stops searching for a program named {\tt ls} and runs it.  There might
well have been another {\tt ls} sitting in the directory {\tt
  /usr/bin}, but {\tt bash} would never run it unless I asked for it by
specifying an explicit pathname:

\begin{screen}\begin{verbatim}
/home/larry# /usr/bin/ls
\end{verbatim}\end{screen}

        The {\tt PATH} variable exists so that we don't have to type
in complete pathnames for every command.  When you type a command,
Bash looks for it in the directories named in {\tt PATH}, in order,
and runs it if it finds it.  If it doesn't find it, you get a rude
error:

\begin{screen}\begin{verbatim}
/home/larry# clubly
clubly: command not found
\end{verbatim}\end{screen}

        Notice that my {\tt PATH} does not have the current directory,
"{\tt .}", in it.  If it did, it might look like this:

\begin{screen}\begin{verbatim}
/home/larry# echo $PATH
.:/home/larry/bin:/bin:/usr/bin:/usr/local/bin:/usr/bin/X11:/usr/TeX/bin
/home/larry#
\end{verbatim}\end{screen}

        This is a matter of some debate in Unix-circles (which you are
now a member of, whether you like it or not).  The problem is that
having the current directory in your path can be a security hole.
Suppose that you {\tt cd} into a directory where somebody has left a
"Trojan Horse" program called {\tt ls}, and you do an {\tt ls}, as
would be natural on entering a new directory.  Since the current
directory, "{\tt .}", came first in your {\tt PATH}, the shell would
have found this version of {\tt ls} and executed it.  Whatever
mischief they might have put into that program, you have just gone
ahead and executed (and that could be quite a lot of mischief indeed).
The person did not need root privileges to do this; they only needed
write permission on the directory where the "false" {\tt ls} was
located.  It might even have been their home directory, if they knew
that you would be poking around in there at some point.

        On your own system, it's highly unlikely that people are
leaving traps for each other.  All the users are probably friends or
colleagues of yours.  However, on a large multi-user system (like many
university computers), there could be plenty of unfriendly programmers
whom you've never met.  Whether or not you want to take your chances
by having "{\tt .}" in your path depends on your situation; I'm not
going to be dogmatic about it either way, I just want you to be aware
of the risks involved<footnote>Remember that you can always execute
programs in the current directory by being explicit about it, i.e.:
"{\tt ./foo}"\,.}.  Multi-user systems really are communities, where
people can do things to one another in all sorts of unforseen ways.

        The actual way that I set my {\tt PATH} involves most of what
you've learned so far about environment variables.  Here is what is
actually in my {\tt .bashrc}:

\begin{screen}\begin{verbatim}
export PATH=${PATH}:.:${HOME}/bin:/bin:/usr/bin:/usr/local/bin:/usr/bin/X11:/usr/TeX/bin
\end{verbatim}\end{screen}

\eindex{shell!search path}
        Here, I am taking advantage of the fact that the {\tt HOME}
variable is set before Bash reads my {\tt .bashrc}, by using its value
in setting my {\tt PATH}.  The curly braces ("{\tt \{\ldots\}}") are
a further level of quoting; they delimit the extent of what the "\$"
is to evaluate, so that the shell doesn't get confused by the text
immediately following it ("{\tt /bin}" in this case).  Here is
another example of the effect they have:

\begin{screen}\begin{verbatim}
/home/larry# echo ${HOME}foo
/home/larryfoo
/home/larry#
\end{verbatim}\end{screen}

Without the curly braces, I would get nothing, since there is no
environment variables named {\tt HOMEfoo}.

\begin{screen}\begin{verbatim}
/home/larry# echo $HOMEfoo

/home/larry#
\end{verbatim}\end{screen}

Let me clear one other thing up in that path: the meaning of "{\tt
  \${PATH}}".  What that does is includes the value of any {\tt PATH}
variable {\em previously\/} set in my new {\tt PATH}. Where would the
old variable be set? The file {\tt /etc/profile} serves as a kind of
global {\tt .bash\_profile} that is common to all users.  Having one
centralized file like that makes it easier for the system
administrator to add a new directory to everyone's {\tt PATH} or
something, without them all having to do it individually. If you
include the old path in your new path, you won't lose any directories
that the system already setup for you.

You can also control what your prompt looks like.  This is done by
setting the value of the environment variable {\bf PS1}.  Personally,
I want a prompt that shows me the path to the current working
directory---here's how I do it in my {\tt .bashrc}:

\begin{screen}\begin{verbatim}
export PS1='$PWD# '
\end{verbatim}\end{screen}

\bindex{shell!quoting}
As you can see, there are actually {\em two} variables being
used here.  The one being set is {\tt PS1}, and it is being set to the
value of {\tt PWD}, which can be thought of as either "Print Working
Directory" or "Path to Working Directory".  But the evaluation of
{\tt PWD} takes place inside single quotes.  The single quotes serve
to evaluate the expression inside them, which itself evaluates the
variable {\tt PWD}.  If you just did {\tt export~PS1=\$PWD}, your
prompt would constantly display the path to the current directory {\em
  at the time that\/} {\tt PS1} {\em was set\/}, instead of constantly
updating it as you change directories.  Well, that's sort of
confusing, and not really all that important.  Just keep in mind that
you need the quotes if you want the current directory displayed in
your prompt.

You might prefer {\tt export PS1='\$PWD>'}, or even the name of your
system: {\tt export PS1=`hostname`'>'}. Let me dissect that last
example a little further.

That last example used a {\em new\/} type of quoting, the back
quotes. These don't protect something---in fact, you'll notice that
"hostname" doesn't appear anywhere in the prompt when you run
that. What actually happens is that the command inside the backquotes
gets evaluated, and the output is put in place of the backquotes and
the command name. 

Try {\tt echo `ls`} or {\tt wc `ls`}. As you get more experienced
using the shell, this technique gets more and more powerful.

\eindex{shell!quoting}

There's a lot more to configuring your {\tt .bashrc}, and not enough
room to explain it here.  You can read the {\tt bash} man page for
more, or ask questions of experienced Bash users.  Here is a complete
{\tt .bashrc} for you to study; it's fairly standard, although the
search path is a little long.

\begin{screen}\begin{verbatim}
# some random stuff:
ulimit -c unlimited
export history_control=ignoredups
export PS1='$PWD>'
umask 022

# application-specific paths:
export MANPATH=/usr/local/man:/usr/man
export INFOPATH=/usr/local/info
export PGPPATH=${HOME}/.pgp

# make the main PATH:
homepath=${HOME}:~/bin
stdpath=/bin:/usr/bin:/usr/local/bin:/usr/ucb/:/etc:/usr/etc:/usr/games
pubpath=/usr/public/bin:/usr/gnusoft/bin:/usr/local/contribs/bin
softpath=/usr/bin/X11:/usr/local/bin/X11:/usr/TeX/bin
export PATH=.:${homepath}:${stdpath}:${pubpath}:${softpath}
# Technically, the curly braces were not necessary, because the colons
# were valid delimiters; nevertheless, the curly braces are a good
# habit to get into, and they can't hurt.

# aliases
alias ls="ls -CF"
alias fg1="fg %1"
alias fg2="fg %2"
alias tba="talk sussman@tern.mcs.anl.gov"
alias tko="talk kold@cs.oberlin.edu"
alias tji="talk jimb@totoro.bio.indiana.edu"
alias mroe="more"
alias moer="more"
alias email="emacs -f vm"
alias pu=pushd
alias po=popd
alias b="~/.b"
alias ds=dirs
alias ro="rm *~; rm .*~"
alias rd="rmdir"
alias ll="ls -l"
alias la="ls -a"
alias rr="rm -r"
alias md="mkdir"
alias ed2="emacs -d floss:0 -fg \"grey95\" -bg \"grey50\""

function gco
{
  gcc -o $1 $1.c -g
}
\end{verbatim}\end{screen}

% $ <- to confuse emacs's highlighting

% **** here I am

\section{The X Window System Init Files}

\xwarn Most people prefer to do their work inside a graphical
environment, and for Unix machines, that usually means using X.  If
you're accustomed to the Macintosh\index{Macintosh} or to Microsoft
Windows\index{Microsoft Windows}, the X Window System may take a
little getting used to, especially in how it is customized.

With the Macintosh or Microsoft Windows, you customize the environment
from {\em within} the environment: if you want to change your
background, for example, you do by clicking on the new color in some
special graphical setup program.  In X, system defaults are controlled
by text files, which you edit directly---in other words, you'd type
the actual color name into a file in order to set your background to
that color.

        There is no denying that this method just isn't as slick as
some commercial windowing systems.  I think this tendency to remain
text-based, even in a graphical environment, has to do with the fact
that X was created by a bunch of programmers who simply
weren't trying to write software that their grandparents could use.
This tendency may change in future versions of X (at least I
hope it will), but for now, you just have to learn to deal with more
text files.  It does at least give you very flexible and precise
control over your configuration.

        Here are the most important files for configuring X:

\begin{samepage}
\begin{tabular}{ll}
{\bf {\tt .xinitrc}}    & A script run by X when it starts up. \\
{\bf {\tt .twmrc}}      & Read by an X window manager, {\tt twm}\ttindex{twm}. \\
{\bf {\tt .fvwmrc}}     & Read by an X window manager, {\tt fvwm}\ttindex{fvwm}. \\
\end{tabular}
\end{samepage}
        
        All of these files should be located in your home directory,
if they exist at all.

        The {\tt .xinitrc} is a simple shell script that gets run when
X is invoked.  It can do anything any other shell script can
do, but of course it makes the most sense to use it for starting up
various X programs and setting window system parameters.  The
last command in the {\tt .xinitrc} is usually the name of a window
manager to run, for example {\tt /usr/bin/X11/twm}.

        What sort of thing might you want to put in a {\tt .xinitrc}
file?  Perhaps some calls to the {\tt xsetroot} program, to make your
root (background) window and mouse cursor look the way you want them
to look.  Calls to {\tt xmodmap}, which tells the server<footnote>The
"server" just means the main X process on your machine, the
one with which all other X programs must communicate in order to use
the display.  These other programs are known as "clients", and the
whole deal is called a "client-server" system.} how to interpret the
signals from your keyboard.  Any other programs you want started every
time you run X (for example, {\tt xclock}).

        Here is some of my {\tt .xinitrc}; yours will almost certainly
look different, so this is meant only as an example:

\begin{screen}\begin{verbatim}
#!/bin/sh
# The first line tells the operating system which shell to use in
# interpreting this script.  The script itself ought to be marked as
# executable; you can make it so with "chmod +x ~/.xinitrc". 

# xmodmap is a program for telling the X server how to interpret your
# keyboard's signals.  It is *definitely* worth learning about. You
# can do "man xmodmap", "xmodmap -help", "xmodmap -grammar", and more.
# I don't guarantee that the expressions below will mean anything on
# your system (I don't even guarantee that they mean anything on
# mine):
xmodmap -e 'clear Lock'
xmodmap -e 'keycode 176 = Control_R'
xmodmap -e 'add control = Control_R'
xmodmap -e 'clear Mod2'
xmodmap -e 'add Mod1 = Alt_L Alt_R'

# xset is a program for setting some other parameters of the X server:
xset m 3 2 &       # mouse parameters
xset s 600 5 &     # screen saver prefs  
xset s noblank &   # ditto
xset fp+ /home/larry/x/fonts # for cxterm
# To find out more, do "xset -help".

# Tell the X server to superimpose fish.cursor over fish.mask, and use
# the resulting pattern as my mouse cursor:
xsetroot -cursor /home/lab/larry/x/fish.cursor /home/lab/larry/x/fish.mask &

# a pleasing background pattern and color:
xsetroot -bitmap /home/lab/larry/x/pyramid.xbm -bg tan

# todo: xrdb here?  What about .Xdefaults file?

# You should do "man xsetroot", or "xsetroot -help" for more
# information on the program used above. 

# A client program, the imposing circular color-clock by Jim Blandy:
/usr/local/bin/circles &

# Maybe you'd like to have a clock on your screen at all times?
/usr/bin/X11/xclock -digital &

# Allow client X programs running at occs.cs.oberlin.edu to display
# themselves here, do the same thing for juju.mcs.anl.gov:
xhost occs.cs.oberlin.edu
xhost juju.mcs.anl.gov

# You could simply tell the X server to allow clients running on any
# other host (a host being a remote machine) to display here, but this
# is a security hole -- those clients might be run by someone else,
# and watch your keystrokes as you type your password or something!
# However, if you wanted to do it anyway, you could use a "+" to stand
# for all possible hostnames, instead of a specific hostname, like
# this:
# xhost +

# And finally, run the window manager:
/usr/bin/X11/twm
# Some people prefer other window managers.  I use twm, but fvwm is
# often distributed with Linux too:
# /usr/bin/X11/fvwm
\end{verbatim}\end{screen}

%        [Larry, or someone, does it matter if the window manager is
%started in the background or not?  It seems to work fine either way;
%I'm wondering if there's any point recommending an "&amp" or not.
%-Karl] I believe we want it without an "&" so the server exits
% at the same time as the window manager

        Notice that some commands are run in the background (i.e.:
they are followed with a "&amp"), while others aren't.  The
distinction is that some programs will start when you start X
and keep going until you exit---these get put in the background.
Others execute once and then exit immediately. {\tt xsetroot} is one
such; it just sets the root window or cursor or whatever, and then
exits.

        Once the window manager has started, it will read its own init
file, which controls things like how your menus are set up, which
positions windows are brought up at, icon control, and other
earth-shakingly important issues.  If you use {\tt twm}, then this
file is {\tt .twmrc} in your home directory.  If you use {\tt fvwm},
then it's {\tt .fvwmrc}, etc.  I'll deal with only those two, since
they're the window managers you'll be most likely to encounter with
Linux.

\subsection{Twm Configuration}\label{twm-config-section}

\bttindex{twm}
The {\tt .twmrc} is not a shell script---it's actually written in a
language specially made for {\tt twm}, believe it or
not!<footnote>This is one of the harsh facts about init files: they
  generally each have their own idiosyncratic command language.  This
  means that users get very good at learning command languages
  quickly.  I suppose that it would have been nice if early Unix
  programmers had agreed on some standard init file format, so that we
  wouldn't have to learn new syntaxes all the time, but to be fair
  it's hard to predict what kinds of information programs will need.}
The main thing people like to play with in their {\tt .twmrc} is
window style (colors and such), and making cool menus, so here's an
example {\tt .twmrc} that does that:

\begin{screen}
    \begin{verbatim}
# Set colors for the various parts of windows.  This has a great
# impact on the "feel" of your environment.
Color
{
    BorderColor "OrangeRed"
    BorderTileForeground "Black"
    BorderTileBackground "Black"
    TitleForeground "black"
    TitleBackground "gold"
    MenuForeground "black"
    MenuBackground "LightGrey"
    MenuTitleForeground "LightGrey"
    MenuTitleBackground "LightSlateGrey"
    MenuShadowColor "black"
    IconForeground "DimGray"
    IconBackground "Gold"
    IconBorderColor "OrangeRed"
    IconManagerForeground "black"
    IconManagerBackground "honeydew"
}

# I hope you don't have a monochrome system, but if you do...
Monochrome
{
    BorderColor "black"
    BorderTileForeground "black"
    BorderTileBackground "white"
    TitleForeground "black"
    TitleBackground "white"
}

# I created beifang.bmp with the program "bitmap".  Here I tell twm to
# use it as the default highlight pattern on windows' title bars:
Pixmaps
{
    TitleHighlight "/home/larry/x/beifang.bmp"
}

# Don't worry about this stuff, it's only for power users :-)
BorderWidth     2
TitleFont       "-adobe-new century schoolbook-bold-r-normal--14-140-75-75-p-87-iso8859-1"
MenuFont        "6x13"
IconFont        "lucidasans-italic-14"
ResizeFont      "fixed"
Zoom 50
RandomPlacement

# These programs will not get a window titlebar by default:
NoTitle
{
  "stamp"
  "xload"
  "xclock"
  "xlogo"
  "xbiff"
  "xeyes"
  "oclock"
  "xoid"
}

# "AutoRaise" means that a window is brought to the front whenever the
# mouse pointer enters it.  I find this annoying, so I have it turned
# off.  As you can see, I inherited my .twmrc from people who also did
# not like autoraise.
AutoRaise 
{
  "nothing"     # I don't like auto-raise  # Me either  # nor I
}

# Here is where the mouse button functions are defined.  Notice the
# pattern: a mouse button pressed on the root window, with no modifier
# key being pressed, always brings up a menu.  Other locations usually
# result in window manipulation of some kind, and modifier keys are
# used in conjunction with the mouse buttons to get at the more
# sophisticated window manipulations.
#
# You don't have to follow this pattern in your own .twmrc -- it's
# entirely up to you how you arrange your environment.

# Button = KEYS : CONTEXT : FUNCTION
# ----------------------------------
Button1 =      : root    : f.menu "main"
Button1 =      : title   : f.raise
Button1 =      : frame   : f.raise
Button1 =      : icon    : f.iconify
Button1 = m    : window  : f.iconify

Button2 =      : root    : f.menu "stuff"
Button2 =      : icon    : f.move
Button2 = m    : window  : f.move
Button2 =      : title   : f.move
Button2 =      : frame   : f.move
Button2 = s    : frame   : f.zoom
Button2 = s    : window  : f.zoom

Button3 =      : root    : f.menu "x"
Button3 =      : title   : f.lower
Button3 =      : frame   : f.lower
Button3 =      : icon    : f.raiselower

# You can write your own functions; this one gets used in the menu
# "windowops" near the end of this file:
Function "raise-n-focus"
{
    f.raise
    f.focus
}

# Okay, below are the actual menus referred to in the mouse button
# section).  Note that many of these menu entries themselves call
# sub-menus.  You can have as many levels of menus as you want, but be
# aware that recursive menus don't work.  I've tried it. 

menu "main"
{
"Vanilla"       f.title
"Emacs"         f.menu "emacs"
"Logins"        f.menu "logins"
"Xlock"         f.menu "xlock"
"Misc"          f.menu "misc"
}

# This allows me to invoke emacs on several different machines.  See
# the section on .rhosts files for more information about how this
# works: 
menu "emacs"
{
"Emacs"      f.title
"here"       !"/usr/bin/emacs &"
""           f.nop
"phylo"      !"rsh phylo \"emacs -d floss:0\" &"
"geta"       !"rsh geta \"emacs -d floss:0\" &"
"darwin"     !"rsh darwin \"emacs -d floss:0\" &"
"ninja"      !"rsh ninja \"emacs -d floss:0\" &"
"indy"       !"rsh indy \"emacs -d floss:0\" &"
"oberlin"    !"rsh cs.oberlin.edu \"emacs -d floss.life.uiuc.edu:0\" &"
"gnu"        !"rsh gate-1.gnu.ai.mit.edu \"emacs -d floss.life.uiuc.edu:0\" &"
}

# This allows me to invoke xterms on several different machines.  See
# the section on .rhosts files for more information about how this
# works: 
menu "logins"
{
"Logins"     f.title
"here"       !"/usr/bin/X11/xterm -ls -T `hostname` -n `hostname` &"
"phylo"      !"rsh phylo \"xterm -ls -display floss:0 -T phylo\" &"
"geta"       !"rsh geta \"xterm -ls -display floss:0 -T geta\" &"
"darwin"     !"rsh darwin \"xterm -ls -display floss:0 -T darwin\" &"
"ninja"      !"rsh ninja \"xterm -ls -display floss:0 -T ninja\" &"
"indy"       !"rsh indy \"xterm -ls -display floss:0 -T indy\" &"
}

# The xlock screensaver, called with various options (each of which
# gives a different pretty picture):
menu "xlock"
{
"Hop"   !"xlock -mode hop &"
"Qix"   !"xlock -mode qix &"
"Flame" !"xlock -mode flame &"
"Worm" !"xlock -mode worm &"
"Swarm" !"xlock -mode swarm &"
"Hop NL"   !"xlock -mode hop -nolock &"
"Qix NL"   !"xlock -mode qix -nolock &"
"Flame NL" !"xlock -mode flame -nolock &"
"Worm NL" !"xlock -mode worm -nolock &"
"Swarm NL" !"xlock -mode swarm -nolock &"
}

# Miscellaneous programs I run occasionally:
menu "misc"
{
"Xload"         !"/usr/bin/X11/xload &"
"XV"            !"/usr/bin/X11/xv &"
"Bitmap"        !"/usr/bin/X11/bitmap &"
"Tetris"        !"/usr/bin/X11/xtetris &"
"Hextris"       !"/usr/bin/X11/xhextris &"
"XRoach"        !"/usr/bin/X11/xroach &"
"Analog Clock"  !"/usr/bin/X11/xclock -analog &"
"Digital Clock" !"/usr/bin/X11/xclock -digital &"
}

# This is the one I bound to the middle mouse button:
menu "stuff"
{
"Chores"       f.title
"Sync"         !"/bin/sync"
"Who"          !"who | xmessage -file - -columns 80 -lines 24 &"
"Xhost +"      !"/usr/bin/X11/xhost + &"
"Rootclear"    !"/home/larry/bin/rootclear &"
}

# X functions that are sometimes convenient:
menu "x"
{
"X Stuff"               f.title
"Xhost +"               !"xhost + &"
"Refresh"               f.refresh
"Source .twmrc"         f.twmrc
"(De)Iconify"           f.iconify
"Move Window"           f.move
"Resize Window"         f.resize
"Destroy Window"        f.destroy
"Window Ops"            f.menu "windowops"
""                      f.nop
"Kill twm"              f.quit
}

# This is a submenu from above:
menu "windowops"
{
"Window Ops"            f.title
"Show Icon Mgr"         f.showiconmgr
"Hide Icon Mgr"         f.hideiconmgr
"Refresh"               f.refresh
"Refresh Window"        f.winrefresh
"twm version"           f.version
"Focus on Root"         f.unfocus
"Source .twmrc"         f.twmrc
"Cut File"              f.cutfile
"(De)Iconify"           f.iconify
"DeIconify"             f.deiconify
"Move Window"           f.move
"ForceMove Window"      f.forcemove
"Resize Window"         f.resize
"Raise Window"          f.raise
"Lower Window"          f.lower
"Raise or Lower"        f.raiselower
"Focus on Window"       f.focus
"Raise-n-Focus"         f.function "raise-n-focus"
"Destroy Window"        f.destroy
"Kill twm"              f.quit
}
    \end{verbatim}
\end{screen}

        Whew!  Believe me, that's not even the most involved .twmrc
I've ever seen.  It's quite probable that some decent example {\tt
.twmrc} files came with your X.  Take a look in the directory
{\tt /usr/lib/X11/twm/} or {\tt /usr/X11/lib/X11/twm} and see what's
there.

        One bug to watch out for with {\tt .twmrc} files is forgetting
to put the &amp after a command on a menu.  If you notice that X
just freezes when you run certain commands, chances are that this is
the cause.  Break out of X with
\key{Control}-\key{Alt}-\key{Backspace}, edit your {\tt .twmrc}, and
try again.
\ettindex{twm}

\subsection{Fvwm Configuration}\label{fvwm-config-section}
\bttindex{fvwm}

        If you are using {\tt fvwm}, the directory {\tt
/usr/lib/X11/fvwm/} (or {\tt /usr/X11/lib/X11/fvwm/}) has some good
example config files in it, as well.

        [Folks: I don't know anything about fvwm, although I might be
able to grok something from the example config files.  Then again, so
could the reader :-).  Also, given the decent but small system.twmrc
in the above-mentioned directory, I wonder if it's worth it for me to
provide that lengthy example with my own .twmrc.  It's in for now, but
I don't know whether we want to leave it there or not.  -Karl]
\ettindex{fvwm}

\section{Other Init Files}

        Some other initialization files of note are:

\begin{samepage}
\begin{tabular}{ll}
{\bf {\tt .emacs}}    & Read by the Emacs text editor when it starts up. \\
{\bf {\tt .netrc}}    & Gives default login names and passwords for ftp. \\
{\bf {\tt .rhosts}}   & Makes your account remotely accessible. \\
{\bf {\tt .forward}}  & For automatic mail forwarding. \\
\end{tabular}
\end{samepage}

\subsection{The Emacs Init File}
        If you use {\tt emacs} as your primary editor, then the {\tt
.emacs} file is quite important.  It is dealt with at length in
Chapter~\ref{emacs-chapter}.

\subsection{FTP Defaults}
        Your .netrc file allows you to have certain {\tt ftp} defaults
set before you run {\tt ftp}.  Here is a small sample {\tt .netrc}:

  \begin{screen}
    \begin{verbatim}
machine floss.life.uiuc.edu login larry password fishSticks
machine darwin.life.uiuc.edu login larry password fishSticks
machine geta.life.uiuc.edu login larry password fishSticks
machine phylo.life.uiuc.edu login larry password fishSticks
machine ninja.life.uiuc.edu login larry password fishSticks
machine indy.life.uiuc.edu login larry password fishSticks

machine clone.mcs.anl.gov login fogel password doorm@
machine osprey.mcs.anl.gov login fogel password doorm@
machine tern.mcs.anl.gov login fogel password doorm@
machine altair.mcs.anl.gov login fogel password doorm@
machine dalek.mcs.anl.gov login fogel password doorm@
machine juju.mcs.anl.gov login fogel password doorm@

machine sunsite.unc.edu login anonymous password larry@cs.oberlin.edu
    \end{verbatim}
  \end{screen}

        Each line of your {\tt .netrc} specifies a machine name, a
login name to use by default for that machine, and a password.  This
is a great convenience if you do a lot of {\tt ftp}-ing and are tired
of constantly typing in your username and password at various sites.
The {\tt ftp} program will try to log you in automatically using the
information found in your {\tt .netrc} file, if you {\tt ftp} to one
of the machines listed in the file.

        You can tell {\tt ftp} to ignore your .netrc and not attempt
auto-login by invoking it with the {\tt -n} option: "{\tt ftp~-n}".

        You must make sure that your {\tt .netrc} file is readable
{\em only} by you.  Use the {\tt chmod} program to set the file's read
permissions.  If other people can read it, that means they can find
out your password at various other sites.  This is about as big a
security hole as one can have; to encourage you to be careful, {\tt
ftp} and other programs that look for the {\tt .netrc} file will
actually refuse to work if the read permissions on the file are bad.

        There's more to the {\tt .netrc} file than what I've said;
when you get a chance, do "{\tt man~.netrc}" or "{\tt man~ftp}".

\subsection{Allowing Easy Remote Access to Your Account}

        If you have an {\tt .rhosts} file in your home directory, it
will allow you to run programs on this machine remotely.  That is, you
might be logged in on the machine {\tt cs.oberlin.edu}, but with a
correctly configured {\tt .rhosts} file on {floss.life.uiuc.edu}, you
could run a program on {\tt floss.life.uiuc.edu} and have the output
go to {\tt cs.oberlin.edu}, without ever having to log in or type a
password.

        A {\tt .rhosts} file looks like this:

  \begin{screen}
    \begin{verbatim}
frobnozz.cs.knowledge.edu jsmith
aphrodite.classics.hahvaahd.edu wphilps
frobbo.hoola.com trixie
    \end{verbatim}
  \end{screen}

        The format is fairly straightforward: a machine name, followed
by username.  Suppose that that example is in fact my {\tt .rhosts}
file on {\tt floss.life.uiuc.edu}.  That would mean that I could run
programs on floss, with output going to any of the machines listed, as
long as I were also logged in as the corresponding user given for that
machine when I tried to do it.

        The exact mechanism by which one runs a remote program is
usually the {\tt rsh} program.  It stands for "remote shell", and
what it does is start up a shell on a remote machine and execute a
specified command.  For example:

\begin{screen}\begin{verbatim}
frobbo$ whoami
trixie
frobbo$ rsh floss.life.uiuc.edu "ls ~"
foo.txt    mbox   url.ps    snax.txt
frobbo$ rsh floss.life.uiuc.edu "more ~/snax.txt"
[snax.txt comes paging by here]
\end{verbatim}\end{screen}

        User trixie at floss.life.uiuc.edu, who had the example {\tt
.rhosts} shown previously, explicitly allows trixie at
frobbo.hoola.com to run programs as trixie from floss.

        You don't have to have the same username on all machines to
make a {\tt .rhosts} work right.  Use the "{\tt -l}" option to {\tt
rsh}, to tell the remote machine what username you'd like to use for
logging in.  If that username exists on the remote machine, and has a
{\tt .rhosts} file with your current (i.e.:~local) machine and
username in it, then your {\tt rsh} will succeed.

\begin{screen}\begin{verbatim}
frobbo$ whoami
trixie
frobbo$ rsh -l larry floss.life.uiuc.edu "ls ~"
[Insert a listing of my directory on floss here]
\end{verbatim}\end{screen}

        This will work if user {\tt larry} on {\tt
floss.life.uiuc.edu} has a {\tt .rhosts} file which allows {\tt
trixie} from {\tt frobbo.hoopla.com} to run programs in his account.
Whether or not they are the same person is irrelevant: the only
important things are the usernames, the machine names, and the entry
in larry's {\tt .rhosts} file on floss.  Note that trixie's {\tt
.rhosts} file on frobbo doesn't enter into it, only the one on the
remote machine matters.

        There are other combinations that can go in a {\tt .rhosts}
file---for example, you can leave off the username following a remote
machine name, to allow any user from that machine to run programs as
you on the local machine!  This is, of course, a security risk:
someone could remotely run a program that removes your files, just by
virtue of having an account on a certain machine.  If you're going to
do things like leave off the username, then you ought to make sure
that your {\tt .rhosts} file is readable by you and no one else.

\subsection{Mail Forwarding}
        You can also have a {\tt .forward} file, which is not strictly
speaking an "init file".  If it contains an email address, then all
mail to you will be forwarded to that address instead.  This is useful
when you have accounts on many different systems, but only want to
read mail at one location.

        There is a host of other possible initialization files.  The
exact number will vary from system to system, and is dependent on the
software installed on that system.  One way to learn more is to look
at files in your home directory whose names begin with "{\tt .}".
These files are not all guaranteed to be init files, but it's a good
bet that most of them are.

\section{Seeing Some Examples}

% Heh heh, do you think this is a big mistake?  I'll risk it for
% now...

The ultimate example I can give you is a running Linux system.  So, if
you have Internet access, feel free to telnet to {\tt
  floss.life.uiuc.edu}.  Log in as "guest", password "explorer",
and poke around.  Most of the example files given here can be found in
{\tt /home/kfogel}, but there are other user directories as well.  You
are free to copy anything that you can read.  Please be careful: floss
is not a terribly secure box, and you can almost certainly gain root
access if you try hard enough.  I prefer to rely on trust, rather than
constant vigilance, to maintain security.
% Local Variables: 
% mode: latex
% TeX-master: "guide"
% End: 


% network programs
\include{network}
\chapter{Talking to Others}\label{network-chapter}

% should we cover Mosaic?

\begin{quote}
"One basic notion underlying Usenet is that it is a cooperative."

Having been on Usenet for going on ten years, I disagree with
this. The basic notion underlying Usenet is the flame.\\
\raggedleft Chuq Von Rospach
\end{quote}

Modern Unix operating systems are very good at talking to other
computers, or networking. Two different Unix computers can
exchange information in many, many different ways.  This chapter is
going to try to talk about how you can take advantage of that strong
network ability.

We'll try to cover electronic mail, Usenet news, and several basic
Unix utilities used for communication.

\section{Electronic Mail}

One of the most popular standard features of Unix is electronic
mail. With it, you are spared the usual hassle of finding an envelope,
a piece of paper, a pen, a stamp, and the postal service, and,
instead, given the hassle of negotiating with the computer.

\subsection{Sending Mail}

All you need to do is type {\tt mail {\sl username}}\impttindex{mail}
and type your message.

For instance, suppose I wanted to send mail to a user named {\tt sam}:

\begin{screen}\begin{verbatim}
/home/larry# mail sam
Subject: The user documentation
Just testing out the mail system.
EOT
/home/larry#
\end{verbatim}\end{screen}

The {\tt mail}\ttindex{mail} program is very simple. Like {\tt cat},
it accepts input from standard input, one line at a time, until it
gets the end-of-text character on a line by itself: \eof. So, to send
my message off I had to hit return and then \eof.

{\tt mail} is the quickest way to send mail, and is quite useful when
used with pipes and redirection. For instance, if I wanted to mail
the file {\tt report1} to "Sam", I could {\tt mail sam < report1},
or I could have even run "{\tt sort report1 | mail sam}".

However, the downside of using {\tt mail} to send mail means a very
crude editor. You can't change a line once you've hit return! So, I
recommend you send mail (when not using a pipe or redirection) is with
Emacs's\index{Emacs} mail mode.  It's covered in
Section~\ref{emacs-mail-mode}.

\subsection{Reading Mail}

\begin{command}
  {\tt mail}\impttindex{mail} [{\sl user}]
\end{command}

The {\tt mail} program offers a clumsy way of reading mail. If you
type {\tt mail} without any parameters, you'll see the following:

\begin{screen}\begin{verbatim}
/home/larry# mail
No mail for larry
/home/larry#
\end{verbatim}\end{screen}

I'm going to send myself some mail so I can play around with the
mailreader:

\begin{screen}\begin{verbatim}
/home/larry# mail larry
Subject: Frogs!
and toads!
EOT
/home/larry# echo "snakes" | mail larry
/home/larry# mail
Mail version 5.5 6/1/90.  Type ? for help.
"/usr/spool/mail/larry": 2 messages 2 new
>N  1 larry                 Tue Aug 30 18:11  10/211   "Frogs!"
 N  2 larry                 Tue Aug 30 18:12   9/191  
& 
\end{verbatim}\end{screen}

The prompt inside the mail program is an ampersand ("{\tt &amp}"). It
allows a couple of simple commands, and will give a short help screen
if you type {\tt ?} and then \ret.

The basic commands for {\tt mail} are:

\begin{dispitems}
\item [{\tt t} {\sl message-list}] Show (or {\bf t}ype) the messages
  on the screen.
\item [{\tt d} {\sl message-list}] Delete the messages.
\item [{\tt s} {\sl message-list} {\sl file}] Save the messages into
  {\sl file}.
\item [{\tt r} {\sl message-list}] Reply to the messages---that is,
  start composing a new message to whoever sent you the listed
  messages.
\item [{\tt q}] Quit and save any messages you didn't delete into a
  file called {\tt mbox} in your home directory.
\end{dispitems}

What's a {\sl message-list}? It consists of a list of integers
separated by spaces, or even a range, such as {\tt 2-4} (which is
identical to "{\tt 2 3 4}"). You can also enter the username of the
sender, so the command {\tt t sam} would {\bf t}ype all the mail from
Sam. If a message list is omitted, it is assumed to be the last
message displayed (or typed).

There are several problems with the {\tt mail} program's reading
facilities. First of all, if a message is longer than your screen, the
mail program doesn't stop! You'll have to save it and use {\tt more}
on it later. Second of all, it doesn't have a very good interface for
old mail---if you wanted to save mail and read it later.

Emacs also has a facility for reading mail, called {\tt rmail}, but it
is not covered in this book. Additionally, most Linux systems have
several other mailreaders available, such as {\tt elm}\ttindex{elm} or
{\tt pine}\ttindex{pine}.

% what about the .forward file!!! ****

\section{More than Enough News}

% nn?

\section{Searching for People}

\subsection{The {\tt finger} command}

The {\tt finger} command allows you to get information on other users
on your system and across the world.  Undoubtably the {\tt finger}
command was named based on the AT&ampT\index{AT&ampT} advertisements
exhorting people to "reach out and touch someone".  Since Unix has
its roots in AT&ampT, this was probably amusing to the author.

\begin{command}
  {\tt finger}\impttindex{finger} [-slpm] [{\sl user}][{\sl @machine}]
\end{command}

The optional parameters to {\tt finger} may be a little
confusing. Actually, it isn't that bad. You can ask for information on
a local user ("sam"), information on another machine
("@lionsden"), information on a remote user ("sam@lionsden"), and
just information on the local machine (nothing).

Another nice feature is, if you ask for information about a user and
there isn't an account name that is exactly what you asked for, it
will try and match the real name with what you specified. That would
mean that if I ran {\tt finger Greenfield}, I would be told that the
account {\tt sam} exists for Sam Greenfield.

\begin{screen}\begin{verbatim}
/home/larry# finger sam
Login: sam                              Name: Sam Greenfield
Directory: /home/sam                    Shell: /bin/tcsh
Last login Sun Dec 25 14:47 (EST) on tty2
No Plan.
/home/larry# finger greenfie@gauss.rutgers.edu
[gauss.rutgers.edu]
Login name: greenfie                    In real life: Greenfie
Directory: /gauss/u1/greenfie           Shell: /bin/tcsh
On since Dec 25 15:19:41 on ttyp0 from tiptop-slip-6439
13 minutes Idle Time
No unread mail
Project: You must be joking!
No Plan.
/home/larry# finger
Login    Name                 Tty  Idle  Login Time   Office     Office Phone
larry    Larry Greenfield      1   3:51  Dec 25 12:50
larry    Larry Greenfield      p0        Dec 25 12:51
/home/larry# 
\end{verbatim}\end{screen}

The {\tt -s} option tells {\tt finger} to always display the short
form (what you normally get when you finger a machine), and the {\tt
  -l} option tells it to always use the long form, even when you
finger a machine. The {\tt -p} option tells {\tt finger} that you
don't want to see {\tt .forward}, {\tt .plan}, or {\tt .project}
files, and {\tt -m} tells {\tt finger} that, if you asked for
information about a user, only give information about an account
name---don't try to match the name with a real name.

\subsection{Plans and Projects}

Now, what's a {\tt .plan}\ttindex{.plan} and a {\tt
  .project}\ttindex{.project}, anyway? They're files stored in a
user's home directory that are displayed whenever they're fingered.
You can create your own {\tt .plan} and {\tt .project} files---the
only restriction is that only the first line of a {\tt .project} file
is displayed.

Also, everybody must have execute privileges in your home directory
({\tt chmod a+x \verb+~+/}) and everybody has to be able to read the
{\tt .plan} and {\tt .project} files ({\tt chmod a+r \verb+~+/.plan
  \verb+~+/.project}).

\section{Using Systems by Remote}

% telnet, rlogin

\begin{command}
  {\tt telnet}\impttindex{telnet} {\sl remote-system}
\end{command}

The principal way of using a remote Unix system is through {\tt
  telnet}.  {\tt telnet} is usually a fairly simple program to use:

\begin{screen}\begin{verbatim}
/home/larry# telnet lionsden
Trying 128.2.36.41...
Connected to lionsden
Escape character is '^]'.

lionsden login: 
\end{verbatim}\end{screen}
  
As you can see, after I issue a {\tt telnet} command, I'm presented
with a login prompt for the remote system.  I can enter any username
(as long as I know the password!) and then use that remote system
almost the same as if I was sitting there.

The normal way of exiting {\tt telnet} is to {\tt logout} on the
remote system, but another way is to type the escape character, which
(as in the example above) is usually \key{Ctrl-]}.  This presents me
with a new prompt titled {\tt telnet>}.  I can now type {\tt quit} and
\ret and the connection to the other system will be closed and {\tt
  telnet} will exit.  (If you change your mind, simply hit return and
you'll be returned to the remote system.)

\xwarn If you're using X, let's create a new {\tt xterm} for the other
system we're travelling to. Use the command "{\tt xterm -title
  "lionsden" -e telnet lionsden &amp}"\ttindex{xterm}. This will create
a new {\tt xterm} window that's automatically running {\tt telnet}.
(If you do something like that often, you might want to create an
alias or shell script for it.)

\section{Exchanging Files}

% ftp

\begin{command}
  {\tt ftp}\impttindex{ftp} {\sl remote-system}
\end{command}

The normal way of sending files between Unix systems is {\tt ftp},
for the {\bf file transfer protocol}.  After running the {\tt ftp}
command, you'll be asked to login to the remote system, much like {\tt
  telnet}.  After doing so, you'll get a special prompt: an {\tt ftp}
prompt.

The {\tt cd} command works as normal, but on the remote system: it
changes your directory on the \emph{other} system.  Likewise, the {\tt
  ls} command will list your files on the remote system.

The two most important commands are {\tt get} and {\tt put}.  {\tt
  get} will transfer a file from the remote system locally, and {\tt
  put} will take a file on the local system and put in on the remote
one.  Both commands work on the directory in which you started {\tt
  ftp} locally and your current directory (which you could have
  changed through {\tt cd}) remotely.

One common problem with {\tt ftp} is the distinction between text and
binary files.  {\tt ftp} is a very old protocol, and there use to be
advantages to assuming that files being transferred are text files.
Some versions of {\tt ftp} default to this behavior, which means any
programs that get sent or received will get corrupted.  For safety,
use the {\tt binary} command before using {\tt get} or {\tt put}.

To exit {\tt ftp} use the {\tt bye} command.

\section{Travelling the Web}

World Wide Web, or WWW, is a popular use of the Internet.  It consists
of {\bf pages}, each associated with its own URL---{\bf uniform
  resource locator}.  URLs are the funny sequence of in the form {\tt
  http://www.rutgers.edu/}.  Pages are generally written in HTML ({\bf
  hypertext markup language}).
\index{URL}\glossary{URL}\glossary{uniform resource locator}
\glossary{HTML}\glossary{hypertext markup language}

HTML allows the writer of a document to link certain words or phrases
(or pictures) to other documents anywhere else in the Web.  When a
user is reading one document, she can quickly move to another by
clicking on a key word or a button and been presented with another
document---possibly from thousands of miles away.

\begin{command}
  {\tt netscape} [{\sl url}]
\end{command}

\xwarn The most popular web browser on GNU/Linux is {\tt
  netscape}\ttindex{netscape}, which is a commercial browser sold (and
given away) by Netscape Communications Corporation.  {\tt netscape}
only runs under X.

{\tt netscape} tries to be as easy to use as possible and uses the
Motif widget set to display a very Microsoft Windows-like appearance.
The basic strategy for using {\tt netscape} is that underlined blue
words are links, as are many pictures.  (You can tell which pictures
are links by clicking on them.)  By clicking on these words with your
left mouse button, you'll be presented with a new page.

GNU/Linux supports many other browsers, including the original web
browser {\tt lynx}\ttindex{lynx}.  {\tt lynx} is a text browser---it
won't display any of the pictures that the Web is currently associated
with---but it will work without X.

\begin{command}
  {\tt lynx}\impttindex{lynx} [{\sl url}]
\end{command}

It's somewhat harder to learn how to use {\tt lynx}, but generally
playing with the arrow keys will let you get the hand of it.  The up
and down arrow keys move between links on a given page, which the
right arrow key follows the current (highlighted) link.  The left
arrow key will reload the previous page.  To quit {\tt lynx}, type
\key{q}.  {\tt lynx} has many other key commands---consult the manpage
for more.


% Local Variables: 
% mode: latex
% TeX-master: "guide"
% End: 

% programs to play with
% this can be a variety of things. Currently, it contains some
% oversized commands that have non-standard interfaces. I'd like to
% cover any of the bigger commands that have their own documentation
% briefly. We might want to move these things somewhere else
\include{funny}

% bugs, and what to do about them!
% common error messages, how to solve them
\include{errors}
\chapter{Errors, Mistakes, Bugs, and Other Unpleasantries}\label{error-chapter}

\begin{quote}
Unix was never designed to keep people from doing stupid things,
because that policy would also keep them from doing clever things.\\
\raggedleft Doug Gwyn
\end{quote}

\section{Avoiding Errors}

Many users report frustration with the Unix operating system at one
time or another, frequently because of their own doing.  A feature of
the Unix operating system that many users' love when they're working
well and hate after a late-night session is how very few commands ask
for confirmation.  When a user is awake and functioning, they rarely
think about this, and it is an assest since it let's them work
smoother.

However, there are some disadvantages.  {\tt rm} and {\tt mv} never
ask for confirmation and this frequently leads to problems.  Thus,
let's go through a small list that might help you avoid total
disaster:

\begin{itemize}
\item Keep backups!  This applies especially to the one user
  system---all system adminstrators should make regular backups of
  their system!  Once a week is good enough to salvage many files.
  See the \ldpsa\ for more information.
\item Individual user's should keep there own backups, if possible.
  If you use more than one system regularly, try to keep updated
  copies of all your files on each of the systems.  If you have access
  to a floppy drive, you might want to make backups onto floppies of
  your critical material.  At worst, keep additional copies of your
  most important material lying around your account {\em in a separate
    directory\/}!
\item Think about commands, especially "destructive" ones like {\tt
    mv}, {\tt rm}, and {\tt cp} before you act.  You also have to be
  careful with redirection ({\tt >})---it'll overwrite your files when
  you aren't paying attention. Even the most harmless of commands can
  become sinister:
\begin{screen}\begin{verbatim}
/home/larry/report# cp report-1992 report-1993 backups
\end{verbatim}\end{screen}
can easily become disaster:
\begin{screen}\begin{verbatim}
/home/larry/report# cp report-1992 report-1993
\end{verbatim}\end{screen}
\item The author also recommends, from his personal experience, not to
  do file maintanence late at night.  Does you directory structure
  look a little messy at 1:32am?  Let it stay---a little mess never
  hurt a computer.
\item Keep track of your present directory.  Sometimes, the prompt
  you're using doesn't display what directory you are working in, and
  danger strikes.  It is a sad thing to read a post on {\tt
    comp.unix.admin}<footnote>A international discussion group on
    Usenet, which talks about administring Unix computers.} about a
  {\tt root} user who was in {\tt /} instead of {\tt /tmp}!  For
  example:
  \begin{screen}\begin{verbatim}
mousehouse> pwd
/etc
mousehouse> ls /tmp
passwd
mousehouse> rm passwd
\end{verbatim}\end{screen}

The above series of commands would make the user very unhappy, seeing
how they have just removed the password file for their system. Without
it, people can't login!
\end{itemize}

\section{What to do When Something Goes Wrong}



\section{Not Your Fault}

Unfortunately for the programmers of the world, not all problems are
caused by user-error. Unix and GNU/Linux are complicated systems, and
all known versions have bugs.  Sometimes these bugs are hard to find
and only appear under certain circumstances.  

First of all, what is a bug?  An example of a bug is if you ask the
computer to compute "5+3" and it tells you "7". Although that's a
trivial example of what can go wrong, most bugs in computer programs
involve arithmetic in some extremely strange way. 

\subsection{When Is There a Bug}

If the computer gives a wrong answer (verify that the answer is
wrong!) or crashes, it is a bug. If any one program crashes or gives
an operating system error message, it is a bug.

If a command never finishes running can be a bug, but you must make
sure that you didn't tell it to take a long time doing whatever you
wanted it to do.  Ask for assistance if you didn't know what the
command did.

Some messages will alert you of bugs.  Some messages are not bugs.
Check Section~\ref{kernel-messages} and any other documentation to
make sure they aren't normal informational messages.  For instance,
messages like "disk full" or "lp0 on fire" aren't software
problems, but something wrong with your hardware---not enough disk
space, or a bad printer.

If you can't find anything about a program, it is a bug in the
documentation, and you should contact the author of that program and
offer to write it yourself. If something is incorrect in existing
documentation<footnote>Especially this one!}, it is a bug with that
manual. If something appears incomplete or unclear in the manual, that
is a bug.

If you can't beat {\tt gnuchess}\ttindex{gnuchess} at chess, it is a
flaw with your chess algorithm, but not necessarily a bug with your
brain.

\subsection{Reporting a Bug}\label{error-reporting}

After you are sure you found a bug, it is important to make sure that
your information gets to the right place.  Try to find what program is
causing the bug---if you can't find it, perhaps you could ask for help
in {\tt comp.os.linux.help} or {\tt comp.unix.misc}. Once you find the
program, try to read the manual page to see who wrote it.

The preferred method of sending bug reports in the GNU/Linux world is
via electronic mail. If you don't have access to electronic mail, you
might want to contact whoever you got GNU/Linux from---eventually,
you're bound to encounter someone who either has electronic mail, or
sells GNU/Linux commercially and therefore wants to remove as many bugs
as possible.  Remember, though, that no one is under any obligation to
fix any bugs unless you have a contract!

When you send a bug report in, include all the information you can
think of.  This includes:
\begin{itemize}
\item A description of what you think is incorrect.  For instance,
  "I get 5 when I compute 2+2" or "It says {\tt segmentation
    violation -- core dumped}." It is important to say exactly what
  is happening so the maintainer can fix {\em your\/} bug!
\item Include any relevant environment variables.
\item The version of your kernel (see the file {\tt /proc/version})
  and your system libraries (see the directory {\tt /lib}---if you
  can't decipher it, send a listing of {\tt /lib}).
\item How you ran the program in question, or, if it was a kernel bug,
  what you were doing at the time.
\item {\bf All} peripheral information.  For instance, the command
  {\tt w}\ttindex{w} may not be displaying the current process for
  certain users. Don't just say, "{\tt w} doesn't work when for a
  certain user".  The bug could occur because the user's name is
  eight characters long, or when he is logging in over the network.
  Instead say, "{\tt w} doesn't display the current process for user
  {\tt greenfie} when he logs in over the network."
\item And remember, be polite.  Most people work on free software for
  the fun of it, and because they have big hearts.  Don't ruin it for
  them---the GNU/Linux community has already disillusioned too many
  developers, and it's still early in GNU/Linux's life!
\end{itemize}

% Local Variables: 
% mode: latex
% TeX-master: "guide"
% End: 

