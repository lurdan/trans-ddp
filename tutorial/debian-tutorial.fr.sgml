<!doctype debiandoc system>
<book>
<title>Tutorial Debian
      <author><name>Havoc Pennington</name><email>hp@debian.org</email>
<version>6 mars 1998
<abstract>Ceci est le Tutorial Debian. Vous devriez le lire après avoir
installé Debian et effectué la configuration de base que traite le manuel
d'installation. Ce document couvre toutes les bases pour l'utilisation de votre
nouveau système, et consiste en une introduction sous forme de tutorial.
<copyright>(c)1998 Software in the Public Interest. Ce document est un logiciel
libre sous licence GPL.</>
<toc>
<chapt>Au sujet de ce manuel</chapt>
<p>
Ceci est le Tutorial Debian. Il s'adresse aux lecteurs novices à GNU/Linux et à
Debian. Il ne nécessite aucune connaissance préalable d'Unix et  des systèmes 
similaires à Unix, mais il requiert des connaissances générales de base à
propos des ordinateurs et du matériel informatique (vous devriez  connaître
quelles sont les composants de base d'un ordinateur et comment les utiliser). 
<p>
Ce manuel est fait pour être lu dans l'ordre; chaque chapitre présuppose une
certaine connaissance des chapitres précédents, bien que vous puissiez trouver
utile de naviguer dans ce tutorial. Si vous vous retrouvez bloqué quelque part,
ne vous découragez pas et passez à un autre sujet.
<p>
Un guide de référence Debian est aussi en préparation. Il sera plus
compréhensible, mais moins introductif.
<p>
Ce tutorial présume que vous avez déjà installé et configuré Debian
GNU/Linux en vous référant au manuel d'installation. Cependant, peut-être
désirerez vous y jeter un coup d'oeil avant l'installation afin d'en savoir
plus à propos de Debian.
<p>
En général, ce tutorial essaie de vous apprendre les raisons de ce qui se
produit, et vous aide à comprendre ce qu'il y a derrière le système.
Ainsi, vous serez à même de résoudre des problèmes nouveaux, et vous pourrez
tirer le meilleur de votre ordinateur. Pour cette raison, vous trouverez
beaucoup de théorie, d'histoire et de faits amusants, associés aux aspects
"Comment faire..." ("How To") de ce manuel. 
<p>
 Envoyez vos commentaires au sujet de ce manuel à [FIXME adresse émail]. Nous
aimerions en particulier savoir en quoi il vous a été utile, et comment nous
pourrions l'améliorer. Si vous rencontrez une difficulté à sa lecture, ou
remarquez que nous utilisons un terme sans l'avoir défini au préalable,
envoyez nous un émail. [FIXME or should we ask for bug reports?] 
<p>
 Ne posez PAS aux auteurs de questions techniques au sujet de Debian, dans la
mesure où il existe des forums pour cela. Voyez [FIXME insérer la référence au
chapitre approprié]. Envoyez seulement à l'adresse ci-dessus les messages
concernant le manuel. 
<p>
Pour trouver la dernière version de ce manuel, allez à [FIXME où].  

<chapt>Introduction</chapt> 
<sect id="explication">Qu'est ce que Debian?</sect>
<p>
<em>Debian</em> est un système d'exploitation gratuit pour votre ordinateur.
Un système d'exploitation représente l'ensemble des programmes de base et des
utilitaires qui permettent à votre ordinateur de fonctionner. Au coeur du
système d'exploitation se situe le noyau (kernel). Le noyau est le programme le
plus fondamental de l'ordinateur: il réalise toute la maintenance et vous
permet de démarrer d'autres programmes. Debian utilise le noyau <em>Linux</em>,
un programme entièrement libre commencé par Linus Torvalds et supporté par des
programmeurs dans le monde entier (probablement plus de 1000). Une bonne partie
des outils de base qui composent le système proviennent de <em>GNU</em> et sont
également des logiciels libres. Bien sûr, ce que les gens veulent, ce sont
les logiciels: des outils pour les aider à réaliser ce qu'ils désirent, depuis
l'édition de documents jusqu'au fonctionnement d'une entreprise, en passant
par les jeux et l'écriture de nouveaux programmes. Debian comporte plus de 1000
<em>paquets</em> (des programmes déjà compilés et empaquetés dans un format
pratique pour une installation aisée sur votre machine) - tout cela disponible
gratuitement.
<p> C'est un peu comme une tour. A la base, il y a Linux. Au dessus, tous les
utilitaires de base, la plupart provenant de GNU. Ensuite, tout les logiciels
que vous exécutez sur votre ordinateur: la plupart encore sont dus à GNU. Au
sommet de la tour, il y a Debian - organisant et agençant soigneusement le
tout afin que tous les programmes fonctionnent ensemble sans heurt. 
<sect1>Qu'est-ce qu'un système d'exploitation, et quel sorte de système
d'exploitation est Debian?</sect1>
<p>
<em>Note: cette section détaille le sujet. Peut être préférerez-vous ne pas
la lire en premier lieu.</em>
<p>
Le but principal d'un système d'exploitation est de faire tourner les logiciels
qui accomplissent le travail dont vous avez besoin. Par exemple, vous pouvez
utiliser un éditeur afin d'être en mesure de créer un document. Cet éditeur ne
pourrait pas effectuer cela sans l'aide du système d'exploitation - il en a
besoin pour interagir avec votre terminal (Ndt: le clavier et le moniteur), vos
fichiers et le reste de votre ordinateur.
<p>
Si le système d'exploitation se contente de supporter vos applications,
pourquoi auriez vous besoin d'un livre entier au sujet de celui-ci? Il y 
a de nombreuses activités de maintenance (en plus de celles qui concernent vos
logiciels principaux) que vous pourriez avoir besoin d'effectuer. En ce qui
concerne GNU/Linux, le système d'exploitation contient également beaucoup de
"mini-applications" pour vous aider à faire votre travail plus efficacement.
De plus, vous aurez besoin d'utiliser les facilités qu'offre le système
d'exploitation pour installer et exécuter des applications.
<p>
Debian GNU/Linux est basé sur le système d'exploitation Unix, lequel est défini
par les standards Posix et X/Open. Unix a une longue histoire (FIXME voir
appendice). Debian est presque entièrement conforme avec le standard Posix;
cependant, la demande de certification coûte une somme significative et Debian
n'est pas officiellement certifié.
<p>
Les systèmes d'exploitation peuvent être simples et minimalistes, comme DOS,
ou gros et complexes, comme OS/2 ou VMS. Unix essaie d'être un compromis. Bien
qu'il fournisse plus de ressources et fasse davantage que les premiers
systèmes d'exploitation, il n'essaie pas de faire <em>tout</em>. Unix a
d'abord été conçu comme une simplification d'un système d'exploitation nommé
Multics (notez le calembour: Multics, Unix).
<p>
La philosophie de conception originelle d'Unix était de distribuer les
fonctionnalités en de petits éléments, les programmes. De cette façon, vous
pouvez facilement réaliser de nouvelles fonctionnalités et de nouvelles
caractéristiques en combinant les petits éléments (les programmes) en de
nouvelles façons. Et si de nouveaux utilitaires apparaissent (ce qui est le
cas), vous pouvez les intégrer dans votre ancienne boite à outils. Par
exemple, pour écrire un document comme celui-ci, il faut utiliser activement
de nombreux programmes: <prgn>fvwm</prgn> pour gérer les fenêtres,
<prgn>emacs</prgn> pour éditer le texte, <prgn>LaTeX</prgn> pour le formater,
<prgn>xdvi</prgn> pour le prévisualiser, <prgn>dvips</prgn> afin de le
préparer pour l'impression et <prgn>lpr</prgn> pour l'imprimer. Si un autre
prévisualiseur dvi était disponible, je pourrais l'utiliser à la place de
<prgn>xdvi</prgn> sans changer mes autres programmes. A chaque instant, 
le système exécutera 50 à 60 programmes pour gérer un seul utilisateur. 
Avec des utilisateurs multiples, vous pouvez vous attendre à quelques 
centaines de programmes. Bien sûr, beaucoup de ceux-ci sont démarrés 
automatiquement par le système, donc vous n'avez pas à vous en soucier.
<p>
Quand vous utilisez un système d'exploitation, vous désirez minimiser 
la quantité de travail que vous fournissez pour effectuer une tache donnée. 
Unix fournit de nombreux outils qui peuvent vous y aider, mais seulement 
si vous savez ce que font ces outils. Passer une heure à essayer de faire 
fonctionner quelque chose et finalement abandonner n'est pas très productif. 
Ce manuel vous apprendra quels outils utiliser dans quelles situations, et 
comment utiliser ensemble ces outils variés.
<p>
La partie clé d'un système d'exploitation est appelée le <em>noyau</em>. Le
noyau Linux fournit des fonctions pour exécuter les programmes à utiliser, et
les ordonne pour l'exécution. En simplifiant, il attribue tant de temps au
programme A, tant au programme B, et ainsi de suite. Un noyau est toujours en
exécution: c'est le premier programme à démarrer quand on allume le système,
et le dernier programme à faire quelque chose quand on arrête le système.

<sect1>Autres choses</sect1>
<p>
Un groupe de volontaires, une distribution GNU/Linux, etc.
<p>
Ce qu'est un système d'exploitation (OS).
<p>
Ce que signifie GNU/Linux.
<p>
Le noyau comparé aux logiciels - Debian n'est pas qu'un OS.

<sect>Qu'est-ce que le logiciel libre ("free software")?</sect>
<p>
"Logiciel libre" renvoie à la liberté et non au prix. Debian est libre dans
ce sens: vous êtes libres de le modifier et de le redistribuer, et pour cette
raison vous aurez toujours accès au code source. Les Debian Free Software
Guidelines décrivent plus en détail ce que signifie exactement "libre"
("free"). La fondation pour le logiciel libre (Free Software Foundation, FSF)
est une autre source d'information.
<p>
Peut être vous posez vous cette question: pourquoi des gens consacrent-ils
des heures de leur temps à écrire des logiciels, les assemblent-ils
soigneusement, pour ensuite les donner? Les réponses sont aussi variées que les
gens qui y participent. Certains aiment aider les autres. Beaucoup écrivent
des programmes pour en apprendre plus au sujet des ordinateurs. De plus en
plus de personnes recherchent des moyens d'éviter l'inflation du prix des
logiciels commerciaux. D'autres apportent leur contribution en
remerciement pour tout les superbes logiciels libres qu'ils ont reçus grâce à
d'autres. Dans les universités, on créent souvent des logiciels libres pour
partager les résultats de ses recherches sur une plus échelle. Le
monde commercial soutient la maintenance des logiciels libres afin de
pouvoir avoir un mot à dire dans leur développement - il n'y a pas de moyen
plus rapide d'obtenir une nouvelle caractéristique que de l'implanter
soi-même! Bien sûr, beaucoup d'entre nous trouvons aussi cela très amusant.
(Ndt: Le traducteur de ce document aimerait ajouter une autre raison: la
possibilité de garder un contrôle absolu sur ses formats de documents et sur
les logiciels qui permettent de les utiliser. Si vous trouvez anormal de
devoir dépenser chaque année quelques milliers de francs dans le seul but de
pouvoir accéder au nouveau format de votre traitement de texte ou pour pouvoir
utiliser un logiciel récent, vous comprendrez aisément l'intérêt des logiciels
libres - pour une entreprise comme pour un particulier)
<p>
Debian est tellement lié aux logiciels libres que mous avons trouvé utile de
formaliser cela dans un document. Notre Contrat Social est donc né.
<p>
Bien que Debian croie au logiciel libre, dans certains cas les gens désirent
installer des logiciels commerciaux sur leur machine. Tant que cela est
possible, Debian supportera cela. Il y a même un nombre important de paquets
dont l'unique but est d'installer des logiciels commerciaux sur un système
Debian.

<sect>Pourquoi devrais-je utiliser Debian?</sect>
<p>
Ce pour quoi Debian est utile, et ce en quoi il ne l'est pas (Ndt: pour la
deuxième partie, ce sera difficile).

<sect>Debian est-il facile à utiliser?</sect>
<p>
Il existe une superstition qui prétend que Debian et les autres systèmes
proches d'Unix sont difficiles à utiliser. Peut-être êtes-vous donc, un peu
préoccupé. Ne le soyez pas.
<p>
Evidement, vous devrez taper certaines commandes là où vous auriez utilisé la
souris sur d'autres systèmes (ceci n'est valable que jusqu'à maintenant - le
développement d'un bureau graphique entièrement libre avance à grands pas, cf.
<ftpsite>www.gnome.org</ftpsite> pour plus de détails)
<p>
Ne soyez pas intimidés. Prenez votre temps, faites des essais, lisez la
documentation. Si vous avez des questions, posez-les (cf. <ref id="aide d'une
personne">). Familiarisez-vous avec le système <em>avant</em> cette démarche de
dernier recours, ce qui vous permettra d'apprendre en toute tranquillité, sans
ressentir aucune frustration. Bientôt, vous pourrez faire du réel travail
rapidement et avec facilité.
<p>
Les couplets sur la difficulté des ordinateurs sont surtout le fait de machos,
ou encore le résultat de la politique "PID" de Microsoft (Peur, Incertitude
et Doute). Les ordinateurs s'adressent à tous, sans considérations d'âge,
de sexe ou de savoir technique. Ne les laissez pas vous troubler.

<sect>Comment éviter de lire ce livre</sect>
<p>
Pour presque tous les programmes informatiques, la meilleure façon d'apprendre
est de vous placer devant votre ordinateur. Beaucoup de gens sont d'avis que
lire un livre sans utiliser le logiciel n'est pas profitable. La meilleure
façon d'apprendre à utiliser Unix et GNU/Linux est de vous en servir. Utilisez
GNU/Linux pour tout ce que vous pouvez. Faites des essais. Soyez sans crainte
- il est <em>possible</em> d'occasionner des modifications, mais vous pouvez
toujours réinstaller. Faites des sauvegardes et amusez-vous! <p>Cependant,
Unix n'est pas aussi intuitivement évident que d'autres systèmes
d'exploitation. Pour cette raison, vous voudrez probablement achever de lire
au moins les premiers chapitres de ce manuel.
<p>
La première façon d'éviter de lire ce livre est d'utiliser la documentation en
ligne disponible, avec des commandes comme <prgn>man</prgn> et
<prgn>info</prgn>. Elles sont décrites dans FIXME xref.
<sect>Comment lire ce livre</sect>
<p>
La méthode d'apprentissage recommandée est de lire un peu, puis de s'amuser
un peu avec ce qu'on vient de découvrir. Continuez de vous amuser jusqu'à ce
que vous soyez familiarisés avec les concepts, puis recommencez à feuilleter
ce livre. Vous y trouverez traités une variété de sujets, dont certains  vous
paraîtront intéressants et d'autres ennuyeux. Après un certain temps, vous
vous sentirez assez en confiance pour commencer à utiliser les commandes sans
savoir exactement ce qu'elles font. C'est une bonne chose.

<sect>Le Projet de Documentation Linux (LDP)</sect>
<p>
Ce manuel emprunte beaucoup au Guide de l'Utilisateur Linux du Projet de
Documentation Linux, par Larry Greenfield. Merci Larry! Ce projet dispose
d'excellents manuels, dont beaucoup s'adressent à des utilisateurs plus
expérimentés et aux administrateurs système.

<chapt>Bien débuter</chapt>
<p>
Ainsi, vous venez juste de finir l'installation de Debian! Félicitations.
Plongeons-nous dans le système et apprenons à l'utiliser.

<sect>Démarrer le système</sect>
<p>
[FIXME cette section requiert vraiment la connaissance des options qu'offrent
les disquettes d'installation, et  nécessite de savoir comment les disquettes
d'installation nomment les choses. "Démarrer depuis le disque dur", "Créer une
disquette", etc.]
<p>
[FIXME de plus, selon toute apparence les lecteurs doivent déjà avoir compris
comment démarrer le système, puisque cela fait partie de l'installation, donc
cette section disparaîtra sans doute dans son intégralité - elle est trop
longue de toute façon]
<p>
Comment vous démarrez votre système dépend de la façon dont vous avez fixé les
choses lorsque vous avez installé Debian. Dans la plupart des cas, vous avez
juste à amorcer l'ordinateur. Mais vous devrez peut-être insérer une disquette
au préalable.
<p>
Linux est chargé par un programme appelé LILO, ou LInux LOader ("chargeur de
Linux"). LILO peut aussi charger d'autres systèmes d'exploitations, et vous
demander quel système vous désirez charger.
<p>
La première chose qui se produit quand vous allumez un PC Intel est l'exécution
du BIOS. BIOS signifie "Basic Input Output System", ou système
d'entrée-sortie de base. C'est un programme situé en permanence sur des
composants de l'ordinateur accessibles en lecture seule. Il effectue des tests
minimaux, puis regarde si une disquette se trouve dans le premier lecteur de
disquettes. S'il en trouve une, il cherche son "secteur d'amorçage" ("boot
sector"), et en exécute le code, s'il est présent. S'il y a
une disquette, mais pas de secteur de démarrage, le BIOS affichera un message
comme:
<p>
<example>Non-system disk or disk error</example> 
<p>
ou, si le BIOS est francisé:
<p>
<example>Disque non système ou erreur de disque</example>
<p>
Enlever la disquette et appuyer sur une touche entraînera la poursuite du
processus de démarrage.
<p>
S'il n'y a pas de disquette dans le lecteur, le BIOS recherche sur le disque dur le secteur
maître d'amorçage (master boot record, MBR). Il commencera l'exécution du
code qu'il y aura trouvé, code qui chargera le système d'exploitation. Sur les
systèmes GNU/Linux, LILO, le chargeur Linux, peut occuper le MBR, et il
chargera GNU/Linux. 
<p>
Ainsi, si vous avez choisi d'installer LILO sur votre disque dur, vous devriez
voir le mot LILO au démarrage de votre ordinateur. A ce moment, vous pouvez
appuyer sur la touche <tt>shift</tt> gauche [FIXME or is it Alt?] pour choisir
quel système charger - appuyez sur <tt>Tab</tt> pour voir une liste d'options.
Choisissez une de ces options, puis appuyez sur <tt>Entrée</tt>. LILO amorcera
le système d'exploitation désiré.
<p>
Si vous n'appuyez pas sur la touche <tt>Shift</tt> gauche, LILO chargera
automatiquement le système d'exploitation par défaut après environ 5 secondes.
Si vous le désirez, vous pouvez changez le système d'exploitation que LILO
charge par défaut, quel systèmes il peut charger et combien de temps il attend
avant d'en charger un par défaut - voyez [FIXME crossref].
<p>
Si vous n'avez pas installé LILO sur votre disque dur, vous avez probablement créé une
disquette de démarrage. LILO est sans doute installé sur celle-ci. Tout ce
que vous avez à faire est d'insérer la disquette avant d'amorcer votre ordinateur, et
le BIOS la trouvera avant de vérifier le MBR du disque dur. Pour revenir sous un OS
non Linux, enlevez la disquette de démarrage et relancez l'ordinateur (depuis Linux,
assurez-vous d'avoir suivi la procédure adéquate pour le redémarrage: voyez
<ref id="arrêt du système"> pour plus de détails).
<p>
LILO charge le noyau Linux du disque, et laisse ensuite le noyau prendre les
commandes (le noyau est le programme central du système d'exploitation, qui
contrôle tous les autres programmes). Le noyau désactive le BIOS et LILO.
<p>
Sur les plates-formes non Intel, la procédure est un peu différente. Mais une
fois que vous avez amorcé le système, tout est plus ou moins équivalent.
<p>
Linux recherche le genre de matériel sur lequel il tourne. Il a besoin de
savoir quel type de disque dur vous possédez, si vous avez ou non une souris, si vous
êtes ou non connecté à un réseau, et autres joyeusetés du même ordre. Linux
ne peut se souvenir de ces choses entre chaque amorçage, et il doit donc
reposer ces questions chaque fois qu'il se lance. Heureusement, ce n'est pas à
<em>vous</em> qu'il pose ces questions - il les pose au matériel! Pendant son
démarrage, le noyau Linux affichera à l'écran des messages décrivant ce qu'il
est en train de faire.
<p>
Ce processus d'interrogation peut occasionner quelques problèmes avec votre
système, mais si cela devait arriver, cela se serait probablement produit
quand vous avez installé GNU/Linux pour la première fois. Si vous rencontrez
des problèmes, consultez les instructions pour l'installation, ou posez la
question dans une liste de diffusion. FIXME ajouter une référence à un
chapitre d'aide.
<p>
Pour simplifier, le noyau se contente de gérer d'autres programmes, donc, une
fois qu'il s'est assuré que tout est normal, il doit lancer un autre programme
pour faire quelque chose d'utile. Le programme que lance le noyau est appelé
<tt>init</tt>. Après avoir lancé <tt>init</tt>, il ne démarre aucun autre
programme. Le noyau devient un gestionnaire et un fournisseur de services.
<p>
Une fois lancé, <tt>init</tt> démarre un certain nombre de scripts (des
fichiers contenant des commandes), qui préparent le système pour
l'utilisation: ils effectuent de la maintenance de routine et démarrent de
nombreux programmes qui, par exemple, affichent une invite de connexion,
vérifient s'il n'y a pas de connexions réseau, et tiennent un registre des
activités de l'ordinateur.
<p>
Excusez du peu! De toutes façons, maintenant, Debian est lancé. Beaucoup
d'explications pour quelque chose qui, de toute  façon, ne requiert aucune
intervention de votre part... :)

<sect>Un système d'exploitation multi-utilisateurs et multitâches</sect>
<p>
Comme nous l'avons mentionné plus haut (<ref id="explication">), la conception
de Debian GNU/Linux est issue du système d'exploitation Unix. Contrairement à
d'autres OS de bureau comme DOS, Windows, et MacOS, Unix a d'abord été conçu
pour les gros serveurs et les systèmes multi-utilisateurs. Ceci signifie que
Debian offre des caractéristiques qui font défaut à d'autres OS. Il permet à
beaucoup de personnes d'utiliser le même ordinateur en même temps, dans la
mesure où chaque utilisateur possède son propre terminal
<footnote>***</footnote>. Pour autoriser de nombreux utilisateurs à travailler
en même temps, Debian doit permettre à de nombreux programmes et applications
de tourner simultanément. Cette propriété est appelée le
<em>multitâches</em>.
<p>
Une bonne partie de la complexité (et de la puissance) d'Unix tient à ces deux
caractéristiques. Par exemple, le système doit disposer d'un moyen d'empêcher
les utilisateurs d'effacer les fichiers des autres, et il doit coordonner les
nombreux programmes tournant en même temps, par exemple s'assurer qu'ils
n'utilisent pas tous le disque dur en même temps.
<p>
Si vous gardez présent à l'esprit ce pourquoi Debian a été originellement
conçu, nombre de ses aspects prendront alors un sens pour vous. Vous
apprendrez à tirer avantage de la puissance de ces caractéristiques.

<sect>Se connecter sur le système</sect>
<p>
Pour utiliser Debian, vous devez vous donner votre identification au système.
Ceci afin qu'il sache qui vous êtes, ce que vous avez la permission de faire
et quelles sont vos préférences.
<p>
Dans ce but, vous disposez d'un <em>nom d'utilisateur</em> (le <em>login</em>)
- si vous avez installé Debian vous-même, il vous a sans doute été demandé de
donner un tel nom pendant le processus d'installation. Si vous vous connectez à
un système administré par un autre personne, vous devrez lui demander un nom
d'utilisateur.
<p>
Vous disposez également d'un mot de passe, afin que personne ne puisse usurper
votre identité. Ceci est important, même si vous êtes l'unique utilisateur de
votre ordinateur: dans le cas contraire, n'importe qui pourrait se connecter à
votre ordinateur depuis l'internet, et causer des dégâts (cf. <ref
id="sécurité">). A moins que vous ne désactiviez tous les services réseau de
Debian et conserviez votre machine dans un local fermé à clé, vous devriez
avoir un mot de passe. <p> (Note: la suite sera légèrement différente si vous
utilisez le système X Window. Si vous voyez une invite de connexion dans une
boite au milieu de l'écran, il s'agit de X. Depuis cette invite, appuyez
simultanément sur <tt>Ctrl</tt>, <tt>Alt</tt> et <tt>F1</tt> (la touche de
fonction 1) pour retourner sous une console en mode texte. Vous pouvez
retourner plus tard sous X en tapant <tt>Alt-F1</tt>. Voyez <ref
id="instructionsX"> pour des détails sur X.
<p>
Quand vous démarrez Debian, vous voyez une <em>invite</em>
(ou prompt) <tt>login</tt> <footnote>***</footnote>. Vous devez entrer votre
nom d'utilisateur, puis votre mot de passe quand il vous sera demandé. Vous ne
pourrez pas voir le mot de passe lorsque vous le taperez - ainsi, personne ne
pourra regarder par dessus votre épaule pour le voir. Vous devrez appuyer sur
<tt>Entrée</tt> après le nom d'utilisateur et le mot de passe. Si vous tapez
incorrectement votre nom d'utilisateur ou votre mot de passe vous pourrez
recommencer.
<p>
Si vous faites cela correctement, vous verrez un bref message puis un
<tt>$</tt>. Le <tt>$</tt> est l'<em>invite du shell</em>: c'est là que
vous passez des commandes au système.
<p>
Essayez maintenant de taper la commande <tt>whoami</tt>. Pour entrer une
commande, vous la tapez à l'invite du shell - vous devriez y voir un curseur
(un petit trait ou un rectangle qui indique l'emplacement où vous tapez).
Appuyez toujours sur <tt>Entrée</tt> quand vous avez tapé la commande.
<p>
<tt>whoami</tt> vous renvoie simplement votre nom d'utilisateur. Vous obtenez
ensuite une nouvelle invite du shell.
<p>
Pour le reste du manuel, quand nous dirons d'entrer une commande, vous devrez
la taper à l'invite du shell puis appuyer sur la touche <tt>Entrée</tt>. Notez
que sur certains claviers la touche <tt>Entrée</tt> (en anglais
<tt>Enter</tt>) est peut-être appelée <tt>Retour</tt> ou <tt>Return</tt>.
Mêmes touches, mais des noms différents.
<p>
Quand vous aurez fini de travailler, vous devrez vous déconnecter du système,
afin que personne ne puisse venir derrière vous et utiliser votre compte
utilisateur. Pour quitter le shell, vous devez juste entrer la commande
<tt>exit</tt>. Vous pouvez aussi taper <tt>logout</tt>. [FIXME <tt>logout</tt>
est-il toujours nécessaire?]

<sect>Historique des commandes et édition de la ligne de commande</sect>
<p>
Tout ce que vous tapez à l'invite du shell avant d'appuyer sur <tt>Entrée</tt>
est appelé la <em>ligne de commande</em> - une ligne de texte qui commande à
l'ordinateur de faire quelque chose. Le shell offre plusieurs caractéristiques
pour rendre l'entrée facile de lignes de commandes.
<p>
Vous pouvez revenir aux anciennes commandes pour les exécuter de nouveau, ou le
modifier quelque peu et <em>ensuite</em> les exécuter de nouveau. Essayez ceci:
connectez-vous au système, si ce n'est déjà fait; entrez une commande comme
<tt>whoami</tt>; puis appuyez sur la touche haut (flèche de direction vers le
haut). Vous devriez revoir la commande <tt>whoami</tt>. Vous pouvez appuyer sur
<tt>Entrée</tt> pour exécuter <tt>whoami</tt> une seconde fois.
<p>
Si vous avez entré quelques commandes, vous pouvez appuyer continuellement sur
la touche de direction vers le haut pour revenir à celles-ci. Cette propriété
est utile si vous effectuez la même action plusieurs fois de suite, ou si vous
tapez mal une commande et voulez la corriger. Vous pouvez appuyer sur
la touche de direction vers le bas pour aller dans l'autre sens, vers les
commandes les plus récentes. Si vous arrivez à la fin de la liste, l'ordinateur
émettra un beep.
<p>
Vous pouvez aussi vous déplacer sur la ligne de commande pour opérer des
changements. La façon la plus simple est de le faire à l'aide des touches de
direction droite et gauche - essayez de taper <tt>whooami</tt> à la place de
<tt>whoami</tt>, puis utilisez la touche de direction vers la gauche pour
revenir au <tt>o</tt> supplémentaire. Vous pouvez effacer le <tt>o</tt> à
l'aide des touches <tt>Backspace</tt> ou <tt>Suppression</tt> (<tt>Suppr</tt>).
<p>
Il y a aussi des caractéristiques avancées (cependant, vous n'êtes pas obligés
de vous souvenir de toutes celles-ci maintenant). Essayez d'appuyer sur
<tt>Control</tt> et <tt>a</tt> en même temps (ceci est souvent noté
<tt>C-A</tt>). Cela vous ramène au début de la ligne de commande.
<tt>C-K</tt> (le <tt>k</tt> est mis pour "kill", "tuer" en anglais) efface
le contenu de la ligne de commande jusqu'à sa fin - essayez de le faire au
milieu de la ligne de commande. En utilisant <tt>C-A</tt> suivi de
<tt>C-K</tt>, vous pouvez rapidement effacer entièrement la ligne de commande.
<tt>C-Y</tt> remet la dernière chose que vous avez effacé - <tt>y</tt> est mis
pour "yank", comme dans "yank it back" (en français "***").
<p>
Faites quelques essais pour vous donner une idée de ces outils. Vous ne pouvez
pas créer de problèmes, donc profitez-en pour vous livrer à quelques
expérimentations.

<sect>Se connecter au système en tant que root</sect>
<p>
Comme Debian est un système multi-utilisateurs, il a été conçu pour empêcher
les utilisateurs de causer des dégâts. Les fichiers importants du système sont
verrouillés et ne peuvent être modifiés par de simples utilisateurs. Ceci
signifie que les choses restent en l'état où elles doivent se trouver,
préservées des accidents, des virus, mais aussi des actes malveillants.
Contrairement à d'autres systèmes d'exploitation, Debian est hors d'atteinte de
ces menaces. Vous n'avez besoin d'aucun programme contre les virus.
<p>
Cependant, vous aurez parfois besoin de modifier des fichiers importants - par
exemple, peut-être désirerez-vous installer de nouveaux logiciels, ou
configurer la connexion réseau. Pour ce faire, il vous faudra des droits plus
étendus que ceux d'un simple utilisateur; vous devrez devenir l'utilisateur
<em>root</em> (aussi appelé le <em>super-utilisateur</em>).
<p>
Pour devenir root, connectez vous simplement au système avec le nom
d'utilisateur <tt>root</tt> et le mot de passe du root. Heureusement, vous vous
souvenez encore du mot de passe que vous avez choisi lorsque vous avez installé
le système - sinon, vous êtes en face d'un problème. Voyez FIXME xref.
<p>
L'idée est que seul l'administrateur système possède le mot de passe du root,
et lui seul peut effectuer ce qu'on ne peut accomplir qu'en tant que root. Si
vous utilisez votre propre ordinateur personnel, bien sûr, <em>vous</em> êtes
l'administrateur système. Si vous ne l'êtes pas, ignorez toutes les références
au root de ce manuel - l'administrateur système s'en occupera pour vous.
<p>
Si vous disposez du mot de passe, essayez de vous connecter au système en tant
que root. Entrez la commande <tt>whoami</tt> pour vous vérifier votre identité.
Ensuite, <em>déconnectez-vous immédiatement</em>. Quand vous êtes root, vous
êtes dangereux. Par exemple, vous pourriez taper <tt>rm /*</tt> et effacer
<em>l'intégramité de votre système</em> avec cinq lettres (point n'est besoin
de vous dire de NE PAS taper ceci). Ne faites pas d'expérimentations quand vous
êtes root. En fait, ne faites rien en tant que root, à moins que ce ne soit
absolument nécessaire.
<p>
Vous préférerez peut-être utiliser la commande <tt>su</tt> pour rendre les
choses plus faciles. <tt>su</tt> est mis pour Super Utilisateur. Essayez ceci:
<enumlist>
<item>Connectez-vous au système sous votre nom propre, c.à.d. non en tant que
root.
<item><tt>whoami</tt>
<p>Vérifie le nom sous lequel vous vous êtes connecté, au cas où vous l'auriez
oublié. :)
<item><tt>su</tt>
<p>
Entre la commande <tt>su</tt>. Un mot de passe vous sera demandé; entrez le mot
de passe du root.
<item><tt>whoami</tt>
<p>
Vous devriez maintenant être root.
<item><tt>exit</tt>
<p>
Fin de la connexion en tant que root.
<item><tt>exit</tt>
<p>
Fin de toute la connexion.
</enumlist>
<p>
Quand vous accomplissez des tâches d'administration système, vous devriez dans
la mesure du possible le faire sous votre nom d'utilisateur. Ensuite lancez
<tt>su</tt>, effectuez ce qui nécessite des privilèges de root, puis faites
<tt>exit</tt>.

<sect>Consoles virtuelles</sect>
Linux supporte les <em>consoles virtuelles</em>. C'est un moyen de simuler, à
partir de votre écran et de votre clavier, des terminaux multiples, tous
connectés à un même noyau Linux. Heureusement, utiliser les consoles
virtuelles est un des aspects les plus simples de Linux: des touches de
raccourcis vous permettent de naviguer rapidement entre celles-ci. Pour faire
un essai, connectez-vous à votre système Linux, maintenez enfoncée la touche
<tt>Alt</tt> gauche, et appuyez sur <tt>F2</tt> (la touche de fonction numéro
2).
<p>
Vous devriez vous retrouver devant une autre invite de connexion. Ne vous
affolez pas: vous êtes maintenant sous la console virtuelle (VC) numéro 2!
Connectez-vous puis lancez quelques commandes - d'autres <tt>whoami</tt> par
exemple - pour vérifier qu'il s'agit bien d'une vraie invite du shell. Vous
pouvez ensuite retourner à la console virtuelle (VC) numéro 1, en maintenant
appuyée la touche <tt>Alt</tt> de gauche et en pressant <tt>F1</tt>. Il vous est
aussi possible d'accéder à une <em>troisième</em> VC, de la même façon
(<tt>Alt-F3</tt>).
<p>
Debian est configuré par défaut avec six VC, accessibles avec les touches de
fonction <tt>F1-F6</tt><footnote>***</footnote>.
<p>
Si vous utilisez le système X Window, il commencera généralement sur la
première VC inutilisée - probablement VC 7. Pour naviguer entre les six
premières VC de X, vous devrez ajouter <tt>Ctrl</tt> à la séquence de
touches. Ainsi, ce sera <tt>Ctrl-Alt-F1</tt> pour la VC 1. Mais vous pouvez
passer d'un VC en mode texte à une VC X (en mode graphique) en utilisant
seulement <tt>Alt</tt>. Si vous ne quittez jamais X, vous n'avez pas à vous en
inquiéter; X passe automatiquement à ses VC lors de son démarrage.
<p>
Une fois que vous en aurez pris l'habitude, les VC vous seront certainement un
outil pour réaliser de nombreuses choses à la fois (le système X Window
poursuit le même objectif, en offrant de multiples fenêtres plutôt que de
multiples consoles). Vous pouvez lancer différents programmes sur chaque VC, ou
vous connecter en tant que root sur une VC et comme simple utilisateur sur une
autre. Ou bien chaque membre de votre famille peut utiliser une VC - ce qui est
particulièrement utile si vous utilisez X, dans la mesure où vous pouvez lancer
plusieurs sessions à la fois, sur différentes VC.

<sect id="instructionsX">Instructions spéciales pour l'utilisation de X</sect>
<p>
Note: vous pouvez passer cette section si vous ne prévoyez pas d'utiliser X
tout de suite.
<p>
Si vous utilisez le système X Window, les choses sont un peu différentes (nous
supposons que X est déjà installé et correctement configuré - si ce n'est pas
le cas, ce qui suit ne fonctionnera pas).
<p>
Il y a deux façons de lancer X. La première est de le lancer manuellement
quand vous avez envie de l'utiliser. Pour ce faire, connectez-vous à une des
consoles en mode texte, et tapez <tt>startx</tt>. Cela démarrera X et vous
commutera à une de ses VC.
<p>
La seconde manière (celle que nous vous recommandons) est d'utiliser X en
association avec <prgn>xdm</prgn>, ou X Display Manager (gestionnaire
de lancement pour X). En simplifiant, <prgn>xdm</prgn> vous affiche une belle
invite de connexion (login) graphique sur la VC de X (probablement VC 7), et
par cet intermédiaire vous connectera au système. <prgn>xdm</prgn> lancera
ensuite automatiquement X.
<p>
Par défaut, les deux méthodes lanceront également un <prgn>xterm</prgn>, une
petite fenêtre affichant une invite du shell. A l'invite du shell, vous pouvez
taper n'importe quelle commande de la même façon que vous le feriez sous une
console texte. Vous pouvez donc suivre tous les exemples de ce tutorial avec
<prgn>xterm</prgn>; la seule différence entre <prgn>xterm</prgn> et la console
texte est que vous n'avez pas à vous connecter au système avec
<prgn>xterm</prgn>, dans la mesure ou vous êtes déjà connecté sous X.
<p>
Il y a aussi beaucoup d'autres choses que vous ne pouvez accomplir que sous X,
que couvre <ref id="Le système X Window">.
<p>
Remarque: le <prgn>xterm</prgn> par défaut a une petite police de caractères.
Si vous utilisez un moniteur de petite taille ou de très grandes résolutions,
ou que vous êtes affligé d'une mauvaise vue, vous voudrez sans doute régler ce
détail. Suivez ces étapes:
<enumlist>
<item>Amenez le pointeur de la souris au centre de la fenêtre
<prgn>xterm</prgn>.
<item>Maintenez simultanément la touche <tt>Ctrl</tt> enfoncée et le bouton
<em>droit</em> de la souris. Ceci vous présentera un menu de sélection des
polices.
<item>Indiquez la police que vous désirez et relâchez le bouton de la souris.
Vous éviterez certainement l'option "Unreadable" ("Illisible"), qui porte bien
son nom.
</enumlist>

<chapt>Arrêter le système</chapt>
<p>
<em>Ne vous contentez pas d'éteindre l'ordinateur! Vous risquer de perdre des
données essentielles!</em>
<p>
Si vous vous êtes le seul à utiliser l'ordinateur, vous voudrez sans doute
éteindre l'ordinateur quand vous aurez achevé la procédure
<footnote>***</footnote>.
<p>
Contrairement à la plupart des versions de DOS, c'est un mauvais choix que de
se contenter d'appuyer sur le bouton d'arrêt lorsque vous avez fini d'utiliser
l'ordinateur. Relancer la machine (avec le bouton reset) est tout aussi
contre-indiqué si vous n'avez pas pris les dispositions nécessaires. Pour
augmenter les performances, GNU/Linux utilise un <em>cache disque</em>. Ceci
signifie qu'il conserve temporairement en mémoire vive (RAM) des informations
qui doivent être conservées de façon permanente: dans la mesure ou la mémoire
vive est quelques milliers de fois plus rapide que le disque dur, ceci accélère
considérablement le système. Régulièrement, les informations que GNU/Linux
conserve en mémoire vive sont écrites sur le disque. On appelle cette méthode
le <em>sycing</em> (le ***). Afin de pouvoir éteindre ou relancer l'ordinateur,
vous devez demander à l'ordinateur de vider tout ce qu'il garde en mémoire vive
en le transférant sur un support de sauvegarde permanent.
<p>
Pour éteindre l'ordinateur, vous devez être <tt>root</tt>. En tant que root,
tapez la commande <tt>shutdown -h now</tt>. Ceci entraînera l'intégralité de la
procédure d'arrêt, incluant la commande <tt>sync</tt>, qui vide le cache
disque comme indiqué ci-dessus. Quand vous verrez <tt>System halted</tt>, vous
pouvez éteindre votre ordinateur en toute sécurité. Si votre noyau et
votre BIOS disposent du support pour la gestion avancée de l'énergie (APM, pour
Advanced Power Management), l'ordinateur devrait s'arrêter de lui-même et
vous éviter tout tracas. L'APM est généralement présente sur les
portables, mais aussi sur certaines cartes mères d'ordinateurs de bureau.
<p>
Pour redémarrer, tapez tout simplement <tt>reboot</tt>, ou appuyez sur C-A-Del
- Control, Alt et Delete (Ndt: sur certaines configurations, cette combinaison 
de touches équivaut à un appui sur le bouton <tt>reset</tt> de l'ordinateur -
donc à utiliser avec prudence si votre carte mère n'est pas un modèle récent.
Dans le doute, essayez d'abord sur un autre système d'exploitation...). Ceci
équivaut plus ou moins à <tt>shutdown</tt> - en fait, c'est la même chose que
de taper <tt>shutdown -r now</tt>. Le <tt>-r</tt> est mis pour "redémarrer", le
<tt>-h</tt> pour "halt" ("arrêter")

<chapt>Les bases </chapt>

<sect>La ligne de commande et les pages <tt>man</tt><sect>
<p>
Nous avons déjà abordé la <em>ligne de commande</em>, c'est à dire tout ce
que vous tapez à l'invite du shell avant de d'appuyer sur <tt>Entrée</tt>. Mais
nous n'avons pas mentionné les différentes parties de la ligne de commande.
<p>
Une ligne de commande minimale contient juste le nom d'une commande, comme <tt>whoami</tt>.
Mais d'autres choses sont possibles:
<p>
<tt>man -k Poscript</tt>
<p>
Cette ligne de commande est constituée de trois parties. Elle commence par
le nom de la commande, <tt>man</tt>. Ensuite vient une <em>option</em> ou
<em>switch</em>, <tt>-k</tt>. Les options changent le comportement d'une
commande. Une option modifie la façon de fonctionner du programme, mais pas ce
sur quoi est exécuté.
<p>
Les options sont généralement indiquées par un <tt>-</tt> qui les précède. Les
utilitaires GNU comportent également des "formes longues" pour les options; la
forme longue de <tt>-k</tt> est <tt>--apropos</tt>. Entrez <tt>man -h</tt> ou
<tt>man --help</tt> pour obtenir une liste complète d'options pour la commande
<tt>man</tt>. Chaque commande possède sa propre liste d'options, bien que la
plupart comportent les options <tt>--help</tt> et <tt>--version</tt>. Certaines
commandes sont étranges; <tt>tar</tt>, par exemple, ne requiert pas de
<tt>-</tt> devant ses options, pour des raisons historiques.
<p>
Tout ce qui ne constitue pas une option ni ne fait partie du nom de la commande
est un <em>argument</em>. Dans cet exemple, il s'agit de <tt>Postscript</tt>.
<p>
Certains considèrent que tous les éléments qui n'entrent pas dans le nom de la
commande constituent les <em>paramètres</em> de celle-ci. Selon cette
définition, les options et les arguments sont des <em>paramètres</em>.
<p>
Analysons la ligne de commande <example>man -k Postscript</example>:
<p>
<tt>man</tt>, le nom de la commande, indique que nous désirons regarder les
pages de manuel. Celles-ci fournissent la documentation des commandes. Par
exemple, essayez de taper <example>man whoami</example>: ceci vous affiche la
documentation de la commande <tt>man</tt> (vous pouvez appuyer sur la barre
d'espace pour faire défiler la documentation).
<p>
<tt>-k</tt>, l'option, modifie le comportement de <tt>man</tt>. En règle
générale, <tt>man</tt> attend un nom de commande comme argument, comme
<tt>whoami</tt>, et recherche la documentation de cette commande. Mais avec les
options <tt>-k</tt> et <tt>apropos</tt>, il attend un mot clé pour argument. Il
affiche alors une liste de toutes les pages de manuel contenant ce mot clé dans
leur description. Les options constituées d'une seule lettre peuvent être
groupées; donc, pour utiliser les deux options <tt>-a</tt> et <tt>-u</tt>, vous
pouvez taper <tt>-ua</tt>.
<p>
<tt>Postscript</tt> est l'argument; comme nous avons utilisé l'option
<tt>-k</tt>, il s'agit du mot clé à rechercher.
<p>
Essayez donc de taper <example>man -k Postscript</example>, et vous devriez
voir une liste de toutes les pages de manuel de votre système qui ont un
rapport avec Postscript. Si vous n'avez pas installé beaucoup de logiciels,
peut-être verrez-vous <example>Postscript: nothing appropriate</example> à la
place.
<p>
<sect1>Description de la ligne de commande</sect1>
<p>
Note: Cette section n'est pas indispensable; vous pouvez ne pas la lire si vous le désirez.
<p>
Il y a une façon concise et traditionnelle de décrire la syntaxe d'une
commande <footnote>***</footnote> que vous devriez connaître. Par exemple, si
vous tapez <example>man man</example> pour obtenir la page de manuel de
<tt>man</tt>, vous verrez plusieurs descriptions de syntaxe commençant par le
nom de la commande <tt>man</tt>. L'une d'elles ressemble à ceci:
<p>
<example>man -k [-M path] keyword ...</example>
<p>
Ceci est très simple. Tous ce qui se trouve entre les crochets ([]) est
optionnel. Ainsi, vous n'êtes pas obligés d'utiliser l'option <tt>-M</tt>, mais
si vous le faites, vous devrez utiliser un chemin de fichier en argument. Pour
cette description, vous devez utiliser l'option <tt>-k</tt> et le mot clé en
argument. Les <tt>...</tt> indiquent que vous pouvez avoir plus de ce qui
précède, donc vous pouvez chercher plusieurs mots clé.
<p>
Considérons une des plus complexes descriptions de la page de manuel de man:
<p>
<example>man  [-c|-w|-tZT  device]  [-adhu7V] [-m system[,...]] [-L      
locale] [-p string] [-M path] [-P pager] [-r  prompt]  [-S       list] [-e
extension] [[section] page ...] ...</example>
<p>
Il n'est pas indispensable de rentrer dans le détail de tout ceci (ne vous
inquiétez pas à propos de ce que tout cela peut signifier), mais prêtons
attention à l'organisation de la description.
<p>
En premier, les groupes d'options signifient généralement que vous pouvez
utiliser l'une d'elles ou plus sous différentes combinaisons, donc
<tt>-adhu7V</tt> signifie que vous pouvez aussi utiliser <tt>-h</tt>.
Cependant, vous ne pouvez pas toujours utiliser des combinaisons; cette
description n'éclaircit pas ce point. Par exemple, <tt>-h</tt> est incompatible
avec les autres options, mais vous pouvez faire <tt>man -du</tt>. C'est une
malheureuse lacune de cette description.
<p>
Deuxièmement, le symbole <tt>|</tt>signifie "ou". Vous pouvez donc utiliser
alternativement les options <tt>-c</tt>, <tt>-w</tt> ou <tt>-tZT</tt>, suivies
d'un processus ("device") comme argument.
<p>
En troisième lieu, notez que vous pouvez remplir les crochets, dans la mesure
où ils indiquent un élément optionnel. Donc, si vous avez une section, vous
devez aussi avoir une page, puisque la page n'est pas optionnelle dans
l'élément <tt>[[section] page]</tt>.
<p>
<sect>Les fichiers</sect>
<sect1>Introduction aux fichiers<sect1>
<p>
Les fichiers sont simplement des endroits où le système conserve les
informations, comme les fichiers papier. Ils sont organisés en répertoires, qui
appelés dossiers sur certains autres OS. Regardons un peu certains fichiers
présents sur un système Debian.
<p>
<list>
<item><tt>/</tt>
<p>
Un simple <tt>/</tt> représente le répertoire racine (root directory). Tous
les autres fichiers et répertoires sont contenus dans le répertoire racine.
<p>
<item><tt>/home/janeq</tt>
<p>
Voici le répertoire personnel de l'utilisateur "janeq". En lisant de la
gauche vers la droite, vous débutez dans le répertoire racine, entrez dans le
répertoire home, et enfin dans le répertoire janeq.
<p>
<item>/etc/X11/XF86Config
<p>
Ceci est le fichier de configuration du système X Window. Il se trouve dans le
sous-répertoire <tt>X11</tt> du répertoire <tt>etc</tt>. <tt>etc</tt> est à son
tour un sous-répertoire du répertoire racine <tt>/</tt>.
<p>
</list>
Quelques points à noter:
<p>
Chaque fichier ou répertoire est désigné par un chemin d'accès, ou séquence de
répertoires à parcourir pour l'atteindre. Tous les chemins d'accès commencent
au répertoire racine. Il y a un <tt>/</tt> dans le chemin d'accès entre chaque
répertoire ou fichier.
<p>
On réfère au répertoire racine avec simplement <tt>/</tt>. Ne confondez pas ce
"racine" ("root") avec l'utilisateur root, l'utilisateur de votre système qui
possède des "super pouvoirs".
<p>
Les répertoires sont disposés selon la métaphore d'un arbre. Tous les chemins
d'accès absolus commencent avec le répertoire racine. Le répertoire racine
comporte un certain nombre de branches, comme <tt>/etc</tt> et <tt>/home</tt>.
Ces sous-répertoires se subdivisent à leur tour en d'autres sous-répertoires.
L'ensemble est appelé l'"arborescence des répertoires".
<p>
Vous pouvez vous représenter un chemin d'accès absolu comme un route depuis la
base de l'arbre (/) jusqu'à l'extrémité d'une des branches (un fichier). Vous
entendrez aussi certains parler de l'arborescence des répertoires comme d'un
arbre généalogique: les sous-répertoires ont des "parents", et un chemin montre
l'ascendance complète d'un fichier.
<p>
Il existe aussi des chemins d'accès relatifs qui débutent ailleurs que depuis
le répertoire racine. Nous en reparlerons plus tard.
<p>
Il n'y a aucun répertoire qui corresponde à un périphérique matériel, comme
votre disque dur. Ceci diffère de DOS et de Windows, où tous les chemins
d'accès débutent par un nom de périphérique comme C:\. L'arborescence des
répertoires est conçue pour être une abstraction du matériel!, et vous donc
pouvez l'utiliser sans connaître quel est le matériel (ceci est important si
vous utilisez un système situé dans un autre endroit, géré par l'administrateur
système de votre compagnie).
<p>
Ainsi, vos fichiers peuvent aussi bien se trouver sur un seul disque que sur
vingt. Vous ne pouvez le dire en regardant l'arborescence des répertoires, et
presque toutes les commandes fonctionnent de la même façon quels que soient
le(s) périphérique(s) sur lesquels ils se trouvent en réalité.
<p>
Tous les répertoires sauf <tt>/</tt> ont un nom, qui peut contenir tous les
symboles ou lettres à l'exception de <tt>/</tt>.
<p>
Les noms de fichiers sont "case sensitive" (sensibles à la casse). Ce qui
signifie que <tt>MYFILE</tt> et <tt>MyFile</tt> sont des fichiers différents.
<p>
Ne vous inquiétez pas si tout vous ne semble pas encore clair. De nombreux
exemples vont suivre. 

<sect1>Utiliser les fichiers: un tutorial</sect1>
<p>
Pour utiliser votre système vous devez savoir comment créer, déplacer,
renommer et effacer des fichiers et des répertoires. Vous effectuerez ces
choses au prompt du shell. (Ndt: mais rassurez vous, des gestionnaires de
fichier en mode graphique sont aussi livrés avec Debian, aussi bien sous la
console en mode texte que sous X)
<p>
Le meilleur moyen d'apprendre est d'essayer ce que vous apprenez. Tant que
vous n'êtes pas root (et que vous n'avez pas créé d'importants fichiers), il
n'y a rien que vous puissiez sérieusement abîmer. Vous pouvez donc y aller -
tapez chacune de ces commande au prompt du shell et appuyez sur entrée.
<p>
<enumlist>
<item><tt>pwd</tt>
<p>
<tt>pwd</tt> est mis pour Present Working Directory - répertoire de travail
actuel. Vous devriez voir à l'écran le nom du répertoire dans lequel vous êtes
- probablement <tt>/home/votrenom</tt>.
<p>
<item><tt>ls</tt>
<tt>ls</tt> est mis pour "lister", comme dans "lister les fichiers". Quand
vous tapez <tt>ls</tt>, vous devez voir une liste de tous les fichiers de votre
répertoire de travail actuel. Si vous venez juste d'installer Debian, votre
répertoire personnel est sans doute vide. Si votre répertoire de travail est
vide, <tt>ls</tt> n'affichera rien à l'écran - il vous semblera qu'il ne fait
rien du tout.
<p>
<item><tt>cd /</tt>
<p>
<tt>cd</tt>est mis pour "Change Directory" - changer de répertoire. Dans ce
cas, vous avez demandé de passer au répertoire racine. Tapez <tt>pwd</tt> de
nouveau, et vérifiez que vous travaillez maintenant dans le répertoire racine.
Tapez <tt>ls</tt> et voyez ce qu'il y a dans <tt>/</tt>.
<p>
<item><tt>cd</tt>
<p>
Taper seulement <tt>cd</tt> vous amène à votre répertoire personnel -
<tt>/home/votrenom</tt>. Tapez <tt>pwd</tt> pour le vérifier.
<p>
<item><tt>mkdir entraînement</tt>
<p>
Dans votre répertoire personnel, créons un répertoire appelé
<tt>entraînement</tt>. Nous utiliserons ce répertoire pour essayer d'autres
commandes. Vous pouvez taper <tt>ls</tt> pour vérifier que votre nouveau
répertoire existe bel et bien.
<p>
<item><tt>cd entraînement</tt>
<p>
Change de répertoire pour <tt>entraînement</tt>.
<p>
<item><tt>mkdir monsousrépertoire
<p>
Crée un sous répertoire d'<tt>entraînement</tt>
<p>
<item><tt>cp /etc/profile .</tt>
<p>
Les choses vont devenir un peu plus compliquées! <tt>cp</tt> est une forme
abrégée pour "copy" (copier). <tt>/etc/profile</tt> est juste un fichier
quelconque de votre système, ne vous inquiétez pas à propos de ce qu'il
signifie maintenant. Nous l'avons copié dans <tt>.</tt> - mais qu'est-ce que
<tt>.</tt>? <tt>.</tt> représente simplement "le répertoire dans lequel je me
trouve actuellement", soit le répertoire de travail actuel. Nous avons donc
créé une copie de /etc/profile, et nous l'avons placée dans notre répertoire
<tt>entraînement</tt>. Tapez <tt>ls</tt> pour vérifier qu'il y a bien un
fichier nommé profile dans le répertoire de travail actuel.
<p>
<item><tt>more profile</tt>
<p>
<tt>more</tt> est utilisé pour voir le contenu de fichiers texte, comme
/etc/profile. On l'appelle <tt>more</tt> ("plus") parce qu'il affiche une page
du fichier à la fois, et que vous devez appuyer sur la barre espace pour voir
la suite. <tt>more</tt> se terminera quand vous aurez atteint la fin du
fichier, ou quand vous appuierez sur <tt>q</tt> (quitter). Vous pouvez
également taper <tt>more /etc/profile</tt> pour vérifier que votre copie est
conforme à  l'original.
<p>
<item><tt>mv profile monsousrépertoire</tt>
<p>
Comme vous l'avez peut-être deviné, <tt>mv</tt> est mis pour "move"
(déplacer). Nous avons déplacé le fichier <tt>profile</tt> depuis le répertoire
courant dans le sous-répertoire que nous avons créé précédemment. Vous pouvez
taper <tt>ls</tt> et/ou <tt>ls monsousrépertoire</tt> pour vous assurer que le
déplacement a bien été effectué.
<p>
<item><tt>cd monsousrépertoire</tt>
<p>
Aller au sous-répertoire.
<item><tt>mv profile monprofile </tt>
<p>
On utilise également <prgn>mv</prgn> pour renommer les fichiers - en les
déplaçant vers un autre nom. Ainsi, il n'y a pas de commande séparée pour
renommer. Notez que le second argument de <tt>mv</tt> peut être un répertoire
où déplacer le fichier, ou un nouveau nom de fichier. <tt>cp</tt> fonctionne de
la même façon.
<p>
Comme d'habitude, vous pouvez taper <tt>ls</tt> pour voir le résultat de <tt>mv</tt>.
<p>
<item><tt>mv monprofile ..</tt>
<p>
De la même façon que <tt>.</tt> signifie "le répertoire où je me trouve
maintenant", <tt>..</tt> signifie "le répertoire parent du répertoire courant",
ici le répertoire <tt>entraînement</tt> que nous avons créé précédemment.
Utilisez <tt>ls</tt> pour vérifier que c'est bien là que <tt>monprofile</tt> se
trouve maintenant.
<p>
<item><tt>cd ..</tt>
<p>
Aller au répertoire parent - ici <tt>entraînement</tt>, où vous venez juste de
mettre <tt>monprofile</tt>.
<p>
<item><tt>rm monprofile</tt>
<p>
<tt>rm</tt> est mis pour "remove" (enlever) - ceci efface le fichier
<tt>monprofile</tt>. Soyez prudents! Effacer un fichier sur un système
GNU/Linux est quelque chose de permanent - il n'y a pas de "undelete" (rétablir
un fichier effacé). Si vous l'effacez avec <tt>rm</tt>, il n'existe
définitivement plus.
<p>
<item><tt>rmdir monsousrépertoire</tt>
<p>
<tt>rmdir</tt> est identique à <tt>rm</tt>, excepté qu'il s'utilise sur des
répertoires. Notez que <tt>rmdir</tt> ne fonctionne que sur des répertoires
vides - si ceux-ci contiennent des fichiers, vous devez les effacer au
préalable, ou utiliser <tt>rm -r</tt> à la place.
<p>
<item><tt>rmdir .</tt>
<p>
Oups! Ça n'a pas fonctionné. Vous ne pouvez effacer le répertoire dans
lequel vous êtes en train de travailler. <item><tt>cd ..</tt>
<p>
Sortez donc du répertoire courant, et entrez dans le répertoire parent. Vous
pouvez maintenant taper:
<p>
<item><tt>rmdir entraînement</tt>
<p>
Ceci effacera les dernières traces de votre session d'entraînement.
</enumlist>
<p>
Notez les deux façons différentes d'écrire un chemin d'accès présentes dans
les exemples ci-dessus. Certains commencent par <tt>/</tt>, le répertoire
racine, comme pour <tt>/etc/profile</tt>. On les appelle des chemins d'accès
absolus parce qu'ils réfèrent toujours au même fichier quel que soit votre
répertoire courant.
<p>
Deux noms de répertoires seulement sont utilisés pour les chemins d'accès
relatifs: <tt>.</tt> et <tt>..</tt>. Le répertoire <tt>.</tt> renvoie au
répertoire courant et <tt>..</tt> est le répertoire parent. Ce sont des
"raccourcis" pour les répertoires. Ils sont présents dans chaque répertoire.
Même le répertoire racine possède sont propre répertoire parent - il est son
propre parent!
<p>
Ainsi, les chemins d'accès qui incluent <tt>.</tt> ou <tt>..</tt> sont
relatifs, parce que leur signification dépend du répertoire courant. Si je suis
dans <tt>/usr/bin</tt> et que je tape <tt>../etc</tt>, je me réfère à
<tt>/usr/etc</tt>. Si je suis dans <tt>/var</tt> et que je tape
<tt>../etc</tt>, alors je me réfère à <tt>/etc</tt>. Notez qu'un nom de chemin
d'accès ne débutant pas par le répertoire racine commence implicitement par un
<tt>./</tt>. Vous pouvez donc aussi bien taper <tt>local/bin</tt> que
<tt>./local/bin</tt> - la signification est la même<footnote>***</footnote>.
<p>
Un dernier conseil utile: le tilde <tt>~</tt> est un alias pour votre
répertoire personnel. Taper <tt>cd ~</tt> est donc la même chose que taper
<tt>cd</tt> tout seul. Vous pouvez également taper des commandes comme <tt>cd
~/entraînement/monsousrépertoire</tt>.
<p>
Maintenant vous savez comment créer, copier, déplacer, renommer et effacer des
fichiers et des répertoires. Vous avez aussi appris des raccourcis, comme taper
simplement <tt>cd</tt> pour passer à votre répertoire personnel, et <tt>.</tt>
et <tt>..</tt> pour référer respectivement au répertoire courant et à son
parent. Vous devriez également vous rappeler du concept de répertoire racine,
ou <tt>/</tt>, et de l'alias <tt>~</tt> pour votre répertoire personnel.
<p>

<sect>Les processus</sect>
<p>
(Auparavant je pensais que cela devait venir plus tard, mais maintenant je
trouve que cette section est bien ici.) Il s'agit simplement de l'utilisation
de <tt>ps</tt> pour lister tous les processus du système, de la façon dont
fonctionne le système, en démarrant un processus originel (init) et en en
lançant d'autres après cela, mais aussi que lorsqu'on lance un programme, il
lance un ou plusieurs processus. <tt>top</tt> (un programme très explicatif).
<p>
Les processus = des outils pour le multitâche.

<sect>Ce qu'est le shell<sect>
<p>
Le shell est un programme qui vous permet de lancer, d'interrompre et
d'interagir avec d'autres programmes. C'est une sorte de façon de parler aux
processus. (fixme OK, c'est sans doute une mauvaise manière d'expliquer ce
qu'est un shell. Des idées?)
<p>
Expliquer par un tutorial qui démarre un processus ("man?"), le suspend avec
<tt>Ctrl-Z</tt>, fait quelque chose d'autre, utilise la commande "jobs",
retourne à un processus, le suspend, en lance un en arrière plan, "jobs" de
nouveau, retour aux deux processus et les quitte? Peut-être un "kill" ici?
aussi un retour à <tt>ps</tt> pour montrer les relations entre les jobs du
shell?
<p>
<sect>Gérer votre identité<sect>
<p>
<tt>chfn</tt>, <tt>finger</tt>, <tt>passwd</tt>
<p>

<chapt>Lire la documentation et obtenir de l'aide</chapt>

<sect>Types de documentation</sect>
<p>
Malheureusement, la documentation est un peu désorganisée sur les systèmes dérivés
d'Unix. Sur Debian, vous pouvez trouver de la documentation au moins aux endroits
suivants:
<p>
Les pages de man, accessibles avec la commande <prgn>man</prgn>.
<p>
Les pages info, accessibles avec la commande <prgn>info</prgn>.
<p>
Les répertoires /usr/doc/paquet, où paquet est le nom d'un paquet Debian.
<p>
/usr/doc/HOWTO/ contient les documents HOWTO du Projet de Documentation Linux.
<p>
De nombreuses commandes possèdent une option -h ou --help. Essayez de taper
le nom de la commande suivi de ces options.
<p>
Le Projet de Documentation de Debian a écrit quelques manuels, celui-ci inclus.
<p>
Le site web de Debian, <ftpsite>www.debian.org</ftpsite>, possède une FAQ et
d'autres choses utiles.
<p>
Vous pouvez trouver de nombreux livres, contenant des informations utiles,
dans le commerce. De nombreuses personnes recommandent très fortement les
éditions O'Reilly.
<p>
La diversité est due à de multiples raisons. Par exemple, <tt>info</tt>
était destiné à remplacer <tt>man</tt>, mais <tt>man</tt> n'a pas encore
disparu.
<p>
Où trouver de l'aide? Voici quelques suggestions:
<p>
Utilisez les pages de <tt>man</tt> et l'option <tt>--help</tt> pour obtenir
un bref résummé de la syntaxe de la commande et de ses options. Utilisez
également <tt>man</tt> si le programme ne dispose pas encore d'une page
<tt>info</tt>.
<p>
Utilisez <tt>info</tt> si le programme est doté d'une documentation <tt>info</tt>.
<p>
Si rien de ce qui précède ne suffit, regardez dans /usr/doc/paquet.
<p>
/usr/doc/paquet contient souvent des informations spécifiques à Debian.
<p>
Référez-vous aux HOWTOs pour des instructions sur la manière de configurer un
point particulier, ou pour des informations concernant votre propre matériel.
Par exemple, le HOWTO Ethernet contient quantité d'informations sur les cartes
ethernet, et le HOWTO PPP détaille la manière de configurer PPP.
<p>
Utilisez les manuels du Projet de Documentation de Debian pour des
explications conceptuelles et des informations spécifiques à Debian.
<p>
Si tout cela échoue, demandez à quelqu'un. Voyez <ref id="aide d'une
personne">.
<p>
L'utilisation des pages de man est décrite plus loin dans <ref id="man">.
<tt>info</tt>, les fichiers contenus dans /usr/doc et l'aide
que peut vous apporter une personne font l'objet de ce chapitre.
<p>
<sect>Utiliser <tt>info</tt></sect>
<p>
Un bref résumé/tutorial des touches, mentionnant TkInfo, et un mea-culpa
pour les ridicules touches.

<sect>Lire des fichiers texte avec <prgn>more</prgn> et
<prgn>less<prgn></sect>
<p>
Utilisation de ces commandes pour lire des docs. Mention de <prgn>zless</prgn> et quand l'utiliser.

<sect>Les HOWTO</sect>
<p>
A côté de ses livres, le Projet de Documentation Linux a réalisé une série de brefs documents
décrivant la configuration d'aspect particuliers de GNU/Linux. Par exemple, le
HOWTO SCSI décrit certaines des complications liées à l'utilisation du SCSI
- une procédure standard de communication avec les périphériques - et de
GNU/Linux. En général, les HOWTO comportent des informations plus spécifiques au
sujet d'une configuration matérielle particulière, et seront moins
d'actualité que ce manuel.
<p>
Il existe un paquet Debian pour les HOWTO. Si vous l'avez installé, vous
devriez les trouver dans /usr/doc/HOWTO. Cependant, vous pourrez
certainement en obtenir des versions plus récentes sur le net - essayez
<ftpsite>sunsite.unc.edu</ftpsite>.

<sect>Obtenir l'aide d'une personne</sect>
<p>
Indication de sites web, de canaux IRC, debian-user, newsgroups. Mentionner
qu'il existe aussi des consultants rémunérés.

<sect1>Ce qu'il faut faire et ce qu'il ne faut pas faire quand on pose une
question</sect1>
<p>
En premier lieu, LISEZ la documentation adéquate. Des informations comme les
options des commandes et ce que ces commandes effectuent s'y trouveront.
<p>
REGARDEZ les HOWTO si votre question concerne une configuration quelconque,
comme pour PPP ou Ethernet.
<p>
ASSUREZ-VOUS que la réponse ne se trouve pas dans ce manuel (bien que la
réalisation d'un index soit utile - nous y travaillons!).
<p>
NE vous retenez PAS de poser la question, lorsque vous avez fournit les
efforts minimaux pour chercher la réponse.
<p>
N'ayez pas peur de demander des explications sur des concepts, des conseils
et autres aspects peu présents dans la documentation.
<p>
INCLUEZ toutes les informations qui semblent avoir un rapport. Vous voudrez
presque toujours indiquer la version de Debian que vous utilisez. Sans doute
mentionnerez-vous aussi la version des paquets importants: la commande
<prgn>dpkg</prgn> <example>--status packagename</example> vous l'indiquera.
Il est aussi utile de dire ce que vous avez essayé et ce qui en a résulté.
<p>
NE vous répandez PAS en excuses à cause de votre ignorance ou parce que vous
êtes un débutant. Il n'y a aucune raison pour que tout le monde doive être
un expert de GNU/Linux, tout comme personne n'est supposé posséder un doctorat en
mécanique.
<p>
N'envoyez PAS de mail sous une forme HTML. Certaines versions de Netscape et
d'Internet Explorer postent en HTML au lieu de le faire en format texte.
Beaucoup ne liront même pas ces envois, car ils sont difficiles à lire pour
la plupart des logiciels de courrier électronique. Il devrait y avoir une
option dans les préférences pour désactiver le HTML.
<p>
SOYEZ POLIS. Souvenez-vous que Debian est réalisé grâce aux efforts de tous,
et que quiconque vous aide ne le fait que par gentillesse.
<p>
POSTEZ à nouveau votre question à la liste de diffusion si vous n'avez
toujours pas obtenu de réponse après quelques jours. Peut-être était-elle
surchargée par un grand nombre de messages et le votre n'a pas retenu
l'attention. Ou bien personne ne connaît la réponse - si personne ne répond
la deuxième fois, c'est sans doute cela.
<p>
REPONDEZ vous-même aux questions quand vous connaissez la réponse. Debian
n'est rendu possible que parce que chacun fait son travail - donc, si vous
posez une question et que quelqu'un d'autre demande la même chose, vous
pourrez répondre. Faites-le!

<sect>Obtenir des informations du système</sect>

<p>
Quand vous essayez de résoudre un problème ou que vous demandez de l'aide,
vous aurez besoin d'obtenir de l'information au sujet de votre système.
Voici quelques moyens d'y parvenir.
<p>
<example>/var/log/*</example>, <example>dmesg</example>, <example>uname
-a</example>

<chapt>Plus sur les fichiers</chapt>
<p>
Dans <ref id="fichiers"> nous avons traité le déplacement et le renommement
des fichiers avec <prgn>mv</prgn>, la copie avec <prgn>cp</prgn>, l'effacement 
avec <prgn>rm</prgn> (et l'effacement de répertoires avec <prgn>rmdir</prgn>),
sans oublier la création de répertoires avec <prgn>mkdir</prgn>. Ce chapitre
couvre quelques aspects supplémentaires au sujet des fichiers.

<sect>Les permissions</sect>
<p>
GNU et les systèmes Unix sont conçus pour permettre à de nombreuses
personnes l'utilisation du même ordinateur, tout en gardant privés certains
fichiers, ou en empêchant certaines personnes de modifier certains fichiers.
Ceci vous préserve d'une destruction accidentelle du système, et si
l'ordinateur est accessible au public comme c'est le cas dans une école ou
dans un bureau, il empêche la destruction volontaire du système.
<p>
Maintenant, tapez <example>ls -l /etc/resolv.conf</example>
<p>
Ceci devrait vous présenter une sortie similaire à celle-ci:
<p>
<example>-rw-r--r-- 1 root root 119 Feb 23 1997 /etc/resolv.conf</example>
<p>
L'option -l de ls demande toutes les informations additionnelles. Les
informations de droite sont faciles - la taille du fichier est de 119
octets, la date indique la dernière fois où le fichier a été changé, le 23
février 1997, le nom du fichier est /etc/resolv.conf. Sur la partie gauche
de l'écran, c'est un peu plus compliqué.
<p>
Tout d'abord, une brève explication technique: le -rw-r--r-- représente
les autorisations d'accès du fichier (le "mode" en anglais), le 1 est le
nombre de "hard links" c'est à dire de liens non symboliques sur ce fichier (ou
le nombre de fichiers d'un répertoire), et les deux root sont l'utilisateur et
le groupe auxquels appartient le fichier.
<p>
Après ce début un peu abscons, nous allons revenir plus doucement sur ces
aspects (à part pour les "hard links" - voyez pour cela FIXME xref).
<p>
<sect1>Les groupes</sect1>
<p>
Chaque fichier possède deux propriétaires - un utilisateur et un groupe. Le
cas ci-dessus peut prêter à confusion, dans la mesure où il y a un groupe
appelé root en plus de l'utilisateur root. Les groupes sont juste des
ensembles d'utilisateurs qui ont une autorisation d'accès collective à une
certaine partie du système. Les groupes de jeu en sont un bon exemple.
En effet, vous pouvez configurer votre système pour que seuls les membres d'un
groupe de jeu aient l'autorisation de jouer.
<p>
Un exemple plus pratique: supposons que vous configurez un ordinateur pour
une école. Vous voulez peut-être rendre certains fichiers accessibles aux
enseignants, mais pas aux élèves, donc vous mettez tous les enseignants dans
un seul groupe. Ensuite, vous pouvez dire au système que certains fichiers
appartiennent aux membres du groupe professeurs, et que personne d'autre ne
peut accéder à ces fichiers. Voici certaines choses que vous pouvez essayer
pour vous familiariser avec les groupes sur votre système:
<p>
<enumlist>
<item><tt>groups</tt>
<p>
Taper ceci au prompt du shell vous dira de quels groupes vous êtes membre.
Selon toute probabilité, vous n'êtes membre que d'un seul groupe, qui est
identique à votre nom d'utilisateur (FIXME: trouver quelle est l'explication
de ceci)
<item>
<tt>more /etc/groups</tt>
Ce fichier liste les groupes qui existent sur votre système. Notez le groupe
root (le seul membre de ce groupe est l'utilisateur root), et le groupe qui
correspond à votre nom d'utilisateur. Il y a aussi des groupes comme dialout
(les utilisateurs autorisés à communiquer avec le modem), et floppy (les
utilisateurs qui peuvent utiliser le lecteur de disquettes). Cependant,
votre système n'est probablement pas configuré pour utiliser ces groupes -
il y a de grandes chances pour que seul root puisse utiliser le lecteur de
disquettes ou le modem tout de suite. Pour obtenir des détails sur ce
fichier, essayez de taper <tt>man group</tt>
<p>
<item><tt>ls -l /home</tt>
Vous permet de voir que chaque répertoire d'utilisateur est possédé par cet
utilisateur et par le groupe personnel de celui-ci (si vous venez juste
d'installer Debian, vous devez être le seul utilisateur).
</enumlist>

<sect1>Les autorisations d'accès</sect1>
<p>
En plus d'être possédés par un utilisateur et un groupe, chaque fichier et
répertoire a également des droits d'accès, qui déterminent qui est autorisé
à lire, écrire et exécuter le fichier. Quelques autres choses sont aussi
déterminées par les autorisations d'accès, mais ce sont des sujets avancés que
nous omettrons pour l'instant.
<p>
Les autorisations d'accès se présentent sous cette forme dans la sortie renvoyée par
<tt>ls</tt>: -rw-r--r--. Il y a dix "espaces" ici, mais les autorisations d'accès consistent
en douze bits (considérez les bits comme des interrupteurs qui peuvent être
allumés ou éteints). Nous ne considéreront que neuf de ces bits: ceux qui
contrôlent les permissions de lecture, d'écriture et d'exécution pour
l'utilisateur qui possède le fichier, pour le groupe auquel il appartient et
pour tous les utilisateurs du système (aussi appelés "le reste du monde").
Notez que trois types de permissions (lecture, écriture et exécution) pour
trois sortes de personnes donnent neuf combinaisons.
<p>
Dans les autorisations d'accès, le premier champ donne le type du fichier. Dans cet exemple,
le - indique que c'est un fichier normal. Si ç'avait été un d, nous aurions
eu affaire à un répertoire. Il y a d'autres possibilités trop complexes
pour que nous les abordions maintenant. (voir FIXME).
<p>
Les 9 champs suivants sont utilisés pour afficher les 12 bits qui composent
les autorisations d'accès du fichier. Les 9 bits de base (lecture, écriture et exécution pour
l'utilisateur, le groupe et le reste du monde) sont affichés comme trois
blocs de rwx. Donc, si toutes les permissions sont accordées, les autorisations d'accès
ressembleront à ceci: -rwxrwxrwx (les trois bits restants sont rendus en
changeant le x en s, t, S ou T, mais il s'agit d'un sujet compliqué que nous
réservons pour plus tard).
<p>
Dans ce contexte, "lecture", "écriture" et "exécution" ont les
significations suivantes:
<p>
La permission en écriture, indiquée par r ("read"), autorise l'examen du
contenu d'un fichier. Appliquée à un répertoire, elle autorise à afficher le
contenu du répertoire.
<p>
La permission en écriture, indiquée par w ("write"), donne la permission de
faire des changement à un fichier. Pour les répertoires, elle donne
l'autorisation de créer et d'effacer des fichiers dans le répertoire.
<p>
La permission d'exécution, indiquée par un x, donne la permission d'exécuter
le fichier comme une commande. En clair, la donner ne revêt un sens que si
le fichier est effectivement une commande.
<p>
Dans la mesure où l'on ne peut jamais exécuter un répertoire, le bit
d'exécution revêt un sens différent. Pour les répertoires, la permission
d'exécution représente l'autorisation d'accéder aux fichiers du répertoire.
Notez que cela est lié avec la permission d'écriture (w): la permission
d'exécution doit être toujours donnée lorsqu'on veut autoriser l'accès à un
répertoire car sans celle-ci
l'autorisation en écriture est inutile. La permission d'exécution pour les
répertoires est souvent appelée permission de "recherche" ("search"),
puisqu'elle n'a rien à voir avec l'exécution. Permission d'"accès aux
fichiers" serait sans doute une meilleure dénomination, mais personne ne
l'utilise.
<p>
Les autorisations d'accès pour les répertoires peuvent prêter à confusion,
donc voici quelques exemples des effets de combinaisons variées:
<p>
r--
<p>
L'utilisateur, le groupe ou le reste du monde, lorsque ces permissions
s'appliquent à eux, peuvent afficher le contenu du répertoire mais rien
d'autre. Les fichiers présents dans le répertoire ne peuvent être lus,
modifiés, effacés, ni manipulés en quelque façon. La seule action autorisée
est de lire le contenu du répertoire lui-même, ce qui veut dire voir quels
fichiers il contient.
<p>
rw-
<p>
L'autorisation en écriture n'a pas d'effets en l'absence de la permission
d'exécution, donc le résultat est identique à l'exemple ci-dessus.
<p>
r-x
<p>
Ceci permet de voir les fichiers présents dans le répertoire, et autorise
l'accès à ces fichiers. Cependant, les fichiers ne peuvent être créés ou
effacés. L'accès signifie que vous pouvez afficher, modifier ou exécuter les
fichiers dans la mesure où les propres permissions de ceux-ci l'autorisent.
<p>
--x
<p>
On peut accéder aux fichiers, mais le contenu du répertoire ne peut être
affiché: vous devez donc savoir à l'avance le nom des fichiers que vous
recherchez (à moins d'avoir beaucoup de chance). Les fichiers ne peuvent
être créés ou effacés.
<p>
rwx
<p>
Vous pouvez faire tout ce que vous désirez avec les fichiers de ce
répertoire, tant que cela est autorisé par les propres permissions des fichiers.
<p>
Les permissions d'écriture d'un répertoire déterminent si vous pouvez
effacer les fichiers de ce dernier - un fichier en lecture seule peut être
effacé, si vous avez l'autorisation d'écrire dans le répertoire qui le
contient. Vous ne pouvez effacer de fichier d'un répertoire en lecture
seule, même si vous avez la permission d'effectuer des changements dans le
fichier. Les permissions des fichiers n'ont rien à voir avec l'effacement
des fichiers.
<p>
Ceci signifie aussi que si vous possédez un répertoire, vous pouvez toujours
en effacer des fichiers, même si ces fichiers appartiennent au root (Ndt:
ceci parce que le possesseur d'un répertoire peut toujours modifier ses
propres droits d'accès, et s'accorder une autorisation en écriture).

<p>
Les permissions d'exécution d'un répertoire déterminent si vous avez ou non
accès aux fichiers - et donc si les permissions des fichiers entrent en jeu. Si
vous disposez de la permission d'exécution pour un répertoire, les permissions
des fichiers de ce répertoire deviennent pertinentes. Dans le cas contraire,
les permissions des fichiers ne servent à rien, dans la mesure où vous ne
pouvez de toute façon pas accéder aux fichiers.
<p>
Si vous avez la permission d'exécution pour le répertoire, les permissions de
fichiers déterminent si vous pouvez lire le contenu du fichier, le modifier
et/ou exécuter le fichier comme une commande.
<p>
FIXME: Les deux paragraphes suivants sont-ils corrects?
<p>
Pour conclure, l'autorisation de changer les permissions d'un fichier n'est
pas affectée par les autorisations d'accès de ce fichier ou du répertoire le
contenant. Plus précisément, vous pouvez toujours changer les permissions des
fichiers et des répertoires que vous possédez, mais non celles des fichiers
possédés par d'autres utilisateurs, tant que vous avez l'autorisation d'accéder
à ce fichier. Ainsi, si vous pouvez accéder à un fichier que vous possédez
(c'est à dire si vous avez la permission d'exécution pour le répertoire dans
lequel il se trouve), alors vous pouvez modifier ses permissions.
<p>
Ceci signifie que vous ne pouvez vous enlever vos propres permissions de façon
permanente, parce que vous pouvez toujours vous les redonner. Admettons que
vous enleviez la permission d'écriture d'un fichier qui vous appartient, puis
essayiez de modifier le fichier. Vous ne serez pas autorisé à le faire, mais
vous pouvez toujours vous réattribuer l'autorisation en écriture puis modifier
le fichier. La seule façon de ne plus pouvoir changer les permissions est de
perdre totalement l'accès au fichier.
<sect1>Les permissions en pratique</sect1> <p> FIXME: Ce n'est pas très
approfondi. Cependant, approfondir rendrait cette partie vraiment longue et
impliquerait la création de fichiers en tant que root, afin de montrer les
effets de différents propriétaires, etc. - peut-être que cela n'en vaut pas la
peine.
<p>
Cette section utilise une courte séance d'exemples pour démontrer
comment les permissions sont utilisées. Vous pouvez sauter cette section que
cela vous fasse perdre le fil.
<p>
Pour changer les permissions, nous utiliserons la commande <prgn>chmod</prgn>.
<p>
<enumlist><item><example>cd; touch myfile</example>
<p>
Voici quelques nouveautés. Tout d'abord, vous pouvez utiliser <tt>;</tt> pour
placer deux commandes sur une seule ligne. Vous pouvez taper l'example
ci-dessus de cette façon:
<p>
<example>$ cd $ touch myfile</example>
<p>
ou sous cette forme:
<p>
<example>$ cd; touch myfile</example>
<p>
et le résultat sera le même.
<p>
Souvenez-vous que <tt>cd</tt> tout seul vous ramène à votre propre répertoire
personnel (home directory). <tt>touch</tt> est généralement utilisé pour amener
la date de modification du fichier à l'heure courante, mais il possède une
caractéristique intéressante: si le fichier n'existe pas, <tt>touch</tt> le
crée. Nous l'utilisons donc pour créer un fichier avec lequel nous allons nous
entraîner. Utilisez <example>ls -l</example> pour vous assurer que le fichier a
bien été créé, et notez les autorisations d'accès:
<p>
<example>$ ls -l -rw-r--r-- 1 havoc havoc 0 Nov 18 22:04 myfile
<p>
Bien sûr, l'heure et les noms de l'utilisateur et du groupe seront différent
dans votre cas. La taille du fichier est 0, puisque <tt>touch</tt> crée un
fichier vide. <tt>-rw-r--r--</tt> représente les autorisations d'accès par
défaut sous Debian (vous pouvez changer ceci - cf. FIXME: ajouter une référence
à umask).
<p>
<item><example>chmod u+x myfile</example>
<p>
Cette commande ajoute (+) la permission d'exécution (x) à l'utilisateur (u)
qui possède le fichier. Utilisez <tt>ls -l</tt> pour observer les effets
produits.
<p>
<item><example>chmod go-r myfile</example>
<p>
Nous venons de soustraire l'autorisation en écriture pour le groupe qui
possède le fichier, et pour tous les autres (others, o). Là encore, utilisez
<tt>ls -l</tt> pour en vérifier les effets.
<p>
<item><example>chmod ugo=rx myfile</example>
<p>
Nous avons attribué (=) à l'utilisateur, au groupe et à tous les autres les
autorisations en écriture et en exécution. Ceci configure les permissions
exactement comme vous l'avez spécifié, et enlève les autres permissions. Donc,
toutes les autorisations d'accès en écriture et en exécution seront attribuées,
et tous les w seront absents. Maintenant, personne ne peut écrire dans le
fichier.
<p>
<item><example>chmod a-x myfile</example>
<p>
<tt>a</tt> est un raccourci pour ugo, ou "all" (tous). Toutes les permissions
x devraient être enlevées.
<p>
<item><example>rm myfile</example>
<p>
Nous effaçons le fichier, bien que nous n'ayons pas d'autorisation en
écriture. <tt>rm</tt> nous demandera confirmation:
<p>
<example>rm: remove 'myfile', overriding mode 0444?</example>
<p>
Vous devriez répondre en tapant <tt>y</tt> et en appuyant sur <tt>Entrée</tt>.
Il s'agit d'une caractéristique de <tt>rm</tt>, non un aspect des permissions -
les permissions d'effacer les fichiers proviennent des autorisations d'accès
des répertoires, et vous disposez de l'autorisation en écriture pour ce
répertoire. Cependant, <tt>rm</tt> s'efforce de se rendre utile, et puisque
vous ne vouliez pas modifier le fichier (et que vous aviez retiré
l'autorisation en écriture dans ce but), il considère que vous ne désirez pas
non plus l'effacer - il vous pose donc la question.
<p>
Qu'était-ce que cette affaire de 0444 dans la question de rm? Souvenez-vous
que les autorisations d'accès sont un nombre binaire de 12 chiffres, comme
ceci: 000100100100. 0444 est ce même nombre binaire présenté comme un nombre
octal (en base 8), ce qui est la convention pour l'écriture des autorisations
d'accès. Vous pouvez taper <tt>chmod 444 myfile</tt> au lieu de <tt>chmod ugo=r
myfile</tt>. Voyez <ref id="avanced permissions">.
<p>
</enumlist>

<sect>Quel sont les fichiers présents sur mon système? Où puis-je mettre mes
propres fichiers?</sect>
<p>
Maintenant que vous pouvez vous déplacer dans l'arborescence des répertoires,
effectuons une visite guidée des fichiers et des répertoires que vous avez créé
en installant Debian. Si vous êtes curieux, allez dans chaque répertoire à
l'aide de la commande <tt>cd</tt> puis tapez <tt>ls</tt> pour voir son contenu.
Si la liste présentée ne tient pas dans l'écran, essayez <tt>ls|more</tt> (Ndt:
ou <tt>ls|less</tt>), où <tt>|</tt> est le caractère de "tube" ("pipe"), qui se
situe généralement sur la même touche que le <tt>-</tt> (la touche du 6).
<p>
/
<p>
Comme nous l'avons déjà mentionné, il s'agit du répertoire racine (on
l'appelle aussi parfois le répertoire root, en référence à l'anglais, où "root"
signifie aussi "racine"), qui contient tous les autres répertoires.
<p>
/root
<p>
Mais ne confondez pas / avec /root! /root est le répertoire personnel ("home
directory") de l'utilisateur root, ou super-utilisateur. Le répertoire est
appelé /root, mais ce n'est pas le répertoire root (ou répertoire racine) /.
<p>
/home
<p>
C'est ici que tous les utilisateurs normaux - c'est à dire tous les
utilisateurs sauf root - ont leurs répertoires personnels ("home directories").
Les répertoires personnels sont nommés d'après le nom de l'utilisateur qui les
possède. Si vous utilisez un gros système à l'école ou au travail, votre
administrateur système a peut-être créé des répertoires supplémentaires pour
contenir les répertoires personnels: /home1 et /home2 par exemple.
<p>
C'est dans votre répertoire personnel que vous mettrez tout votre travail
personnel, votre courrier électronique et autres informations, ainsi que votre
propre configuration et vos préférences.
<p>
/bin
<p>
Ce répertoire contient des programmes ("binaries"), des fichiers exécutables
essentiels pour les opérations du système. Par exemple, le shell (bash), et les
commandes que vous venez d'apprendre, comme <tt>cp</tt>
<p>
/sbin
<p>
Ce répertoire contient tous les programmes système, que l'utilisateur root ou
l'administrateur système voudra sans doute utiliser, mais vous ne voudrez
probablement pas utiliser dans vos activités courantes.
<p>
/usr
<p>
/usr contient la plupart des fichiers qui vous intéresseront. Il contient de
nombreux sous-répertoires: /usr/bin et /usr/sbin sont assez similaires à /bin
et à /sbin, si ce n'est que les répertoires d'/usr ne sont pas considérés comme
"essentiels pour les opérations du système".
<p>
Bien que non essentiel pour le fonctionnement de l'ordinateur, /usr contient
les applications que vous utiliserez pour accomplir votre travail. Vous y
trouverez également les répertoires /usr/man, /usr/info et /usr/doc - le
premier contient les pages de manuel, le second les pages info, le troisième le
reste de la documentation. Et n'oubliez pas /usr/games!
<p>
/usr/local
<p>
Le système Debian n'installe rien dans ce répertoire. Vous devriez l'utiliser
si vous voulez installer des logiciels que vous avez compilés vous-même, ou
toute sorte de logiciels qui ne proviennent pas d'un paquet Debian. Vous pouvez
également installer des logiciels dans votre répertoire personnel, si vous
serez le seul à les utiliser.
<p>
/etc
<p>
/etc contient tous les fichiers de configuration du système. Chaque fois que
vous voudrez effectuer un changement qui affecte tous les utilisateurs de votre
ordinateur - comme la façon dont vous vous connectez à internet, ou quelle
sorte de carte vidéo vous avez - vous devrez probablement vous connecter en
tant que root et modifier un fichier de /etc.
<p>
/tmp
<p>
Vous trouverez ici des fichiers temporaires, la plupart créés par le système.
Ce répertoire est généralement effacé de façon régulière, ou chaque fois que
vous redémarrez votre système. Vous pouvez y créer des fichiers si vous le
désirez, mais soyez conscient qu'ils pourraient être effacés automatiquement.
<p>
/var
<p>
/var contient des fichiers de variables, que le système modifie
automatiquement. Par exemple, le courrier électronique y est rangé est à son
arrivée. Le système y garde en mémoire beaucoup d'actions. Il contient de
nombreux autres fichiers générés automatiquement. Vous serez certainement
intéressé par le contenu de /var/log, ou vous pouvez trouver les messages
d'erreur et essayer de comprendre ce qui arrive à votre système si qui quelque
chose ne va pas.
<p>
Il y a de nombreux autres répertoires sur le système, trop pour pouvoir les
décrire tous. Nous le ferons pour certains plus loin dans ce manuel.
<p>
Pour effectuer des changements, vous voudrez généralement vous limiter à votre
répertoire personnel et à /etc. Sur un système Debian, il est très rare d'avoir
d'autres choses à modifier, parce que tout le reste est installé
automatiquement pour vous.
<p>
/etc est utilisé pour configurer la système dans son ensemble. Vous utiliserez
votre répertoire personnel, un sous répertoire de /home, pour configurer vos
propres préférences, et conserver vos données personnelles. L'idée est de vous
limiter à /home/votrenom pour le travail quotidien, et ainsi vous n'aurez
aucune possibilité de casser quelque chose. Vous vous connecterez en tant que
root de manière occasionnelle pour effectuer une modification dans l'un des
répertoires du système, mais seulement quand ce sera absolument nécessaire.
Bien sûr, si vous utilisez Debian à l'école ou au travail te que quelqu'un
d'autre est l'administrateur système, vous n'aurez pas d'accès root et ne
pourrez modifier que votre répertoire personnel.
<p>

<sect>Utiliser un gestionnaire de fichiers</sect>
<p>
Utilisation de Midnight Commander ou d'un programme similaire au lieu de
manipuler les fichiers manuellement.
<p>
Non un tutorial complet, juste une mention de cette possibilité.
<p>

<chapt>Utiliser le shell</chapt>
<sect>Un peu plus sur le contrôle d'un job</sect>
Détails non encore couverts, kill -9.
<p>
<sect>Variables d'environnement</sect>
Ce qu'elles sont, comment elles sont héritées. Les configurer. Peut-être PAGER
comme exemple, ou modifier le prompt.
<p>
<sect>Où résident les commandes</sect>
Les "builtins" (*Ndt: s'agit-il des commandes intégrées à un programme?)
opposés aux noms de programmes, PATH, "type", "whereis".
<sect>Controller les entrées-sorties</sect>
Stdin, stdout, les pipelines, et la redirection.
<p>
<sect>Spécifier comment et quand lancer des commandes</sect>
Des "modificateurs" ("modifiers" en anglais) comme batch, at, nohup, nice.
<p>
<sect>Les expansions de noms de fichiers ("Wildcards")</sect>
<example>? * []</example>
<p>
<sect>Citer (*Ndt: est-ce bien la traduction de "Quoting"?)</sect>
Quand et comment citer.

<chapt>Créer et éditer des fichiers texte</chapt>
<sect>Qu'est-ce qu'un fichier texte?</sect>
Ce qu'est un fichier texte,  ce à quoi ils servent. Mentionner que nous en
avons déjà vu certains en utilisant "less".
<p>
<sect>Éditeurs de texte</sect>
Utilisés pour créer des fichiers texte et y apporter des modifications.
<p>
Il y en a beaucoup.
<p>
Nous en utiliserons [lesquels?] au cours de ce tutorial.
<p>
<sect>Créer et éditer un fichier texte</sect>
Un petit tutorial sur ce sujet
<p>

<chapt>Customiser le shell</chapt>
<sect>alias et fonctions shell</sect>
Comment créer des raccourcis.
<p>
<sect>Fichiers .rc et ls -a</sect>
À quoi ils servent, pourquoi ils sont cachés, etc.
<p>
<sect>Login shell vs. non-login shell</sect>
La différence, quels fichiers éditer pour chaque.
<p>
<sect>Éditer .bash_profile</sect>
Un petit tutorial, peut-être configurer des variables d'environnement
courantes ou des alias utiles.
<p>
Utiliser quelques trucs élégants pour l'édition de texte.
<p>
Décrire <prgn>umask</prgn>
<p>
<sect>Configurer les éléments par défaut de l'ensemble du système</sect>
Comment éditer les fichiers de configuration du shell dans /etc, et la
différence entre ce procédé et l'utilisation de son propre répertoire
personnel.
<p>
<sect>Modifier votre shell</sect>
Juste une mention de la possibilité, et pourquoi on peut vouloir le faire.
<p>

<chapt>Le système X Window</chapt>
Ce chapitre décrit l'interface graphique utilisateur du système X Window. Il
suppose que vous avez déjà configuré X avec succès, comme cela est décrit dans
le Manuel d'Installation [FIXME crossref], et que vous pouvez donc passer sous
l'environnement X en tapant <tt>startx</tt> ou à l'aide d'<prgn>xdm</prgn>,
suivant le choix que vous avez effectué durant la configuration (il y a aussi
une brève mention de cela dans <ref id="instructionsX">).
<p>
<sect>Introduction: ce qu'est X</sect>
Une GUI (Graphical User Interface, ou Interface Graphique Utilisateur) est une
partie des systèmes Mac ou Windows. Il est presque impossible d'écrire pour ces
systèmes une application qui n'utilise pas la GUI, et le système ne peut
vraiment être utilisé depuis la ligne de commande. GNU/Linux est plus
<em>modulaire</em>, c'est à dire qu'il est constitué de petits composants
indépendants qui peuvent être ou non utilisés suivant les besoins et
les préférences de chacun. Le système X Window - ou plus simplement X - est un
de ces composants.
<p>
X lui-même est pour les programmes un moyen de communiquer avec la souris et
la carte vidéo, sans avoir besoin de savoir de quelle sorte de souris ou de
carte vidéo vous disposez. On appelle cela une <em>abstraction</em>  des
composants graphiques du matériel. Les applications utilisatrices (*Ndt:
faut-il traduire "user applications" par "applications clientes"?) parlent à X,
dans le langage de X; X effectue ensuite la traduction dans le langage de
votre matériel particulier. Ceci signifie que les programmes n'ont à être
écrits qu'une seule fois pour tourner sur les ordinateurs de tous.
<p>
Dans le jargon de X, le programme qui s'adresse au matériel est appelé un
<em>serveur X</em>. Les applications utilisateur qui demandent au serveur X
d'afficher une fenêtre ou des graphismes à l'écran sont les <em>clients
X</em>.
<p>
Le serveur X ne fournit aucune des propriétés que l'on pourrait attendre d'une
GUI, comme redimensionner et réarranger les fenêtres. Un client X spécial,
appelé un <em>gestionnaire de fenêtres</em> (en anglais <em>window
manager</em>), dessine les bordures et les barres de titre des fenêtres,
redimensionne et arrange les fenêtres, et fournit des facilités pour lancer
d'autres clients X depuis un menu. Des gestionnaires de fenêtres spécifiques
peuvent avoir des caractéristiques supplémentaires.
<p>
Les gestionnaires de fenêtres disponibles sur un système Debian comprennent
<prgn>fvwm</prgn>, <prgn>fvwm2</prgn>, <prgn>icewm</prgn>,
<prgn>afterstep</prgn>, <prgn>olwm</prgn>, et d'autres. Vous voudrez
probablement les essayer et garder votre gestionnaire de fenêtres favori.
<tt>ls /usr/X11R6/bin/*wm*</tt> est une excellente façon de voir quels
gestionnaires de fenêtres se trouvent sur votre système (vous verrez également
quelques autres fichiers qui comprennent <tt>wm</tt> dans leur nom).
<p>
Ni le serveur X ni le gestionnaire de fenêtres ne fournissent un gestionnaire
de fichiers; c'est à dire qu'il n'y a aucune fenêtre contenant des icônes de
vos fichiers ou de vos répertoires. Vous pouvez lancer un gestionnaire de
fichiers comme une application séparée; beaucoup sont disponibles, bien
qu'actuellement il n'y en ait aucun de bon qui soit basé sur les icônes. Le
projet de bureau Gnome développe cependant un gestionnaire de fenêtres basé
sur les icônes et d'autres facilités d'une GUI. Voyez
<ftpsite>www.gnome.org</ftpsite> pour les dernières nouvelles à ce sujet.
<p>
Une dernière caractéristique de X est la <em>transparence réseau</em>, ce qui
signifie que les clients X n'ont pas à faire la différence entre communiquer
avec un serveur X situé sur la même machine et avec un serveur X quelque part
sur le réseau. De façon pratique, ceci signifie que vous pouvez exécuter un
programme un programme sur une machine éloignée plus puissante, mais l'afficher
sur le serveur X de votre bureau.
<p>
<sect>Opérations X de base</sect>
<sect1>Passer sous l'environnement X et le quitter</sect1>
Pour passer sous X, vous pouvez soit taper <tt>startx</tt>, soit vous connecter
depuis l'écran graphique de connexion de <tt>xdm</tt>.
<p>
Pour quitter X, vous devrez utiliser un menu. Malheureusement, la procédure
est différente pour tous les gestionnaires de fenêtres, et pour de nombreux
gestionnaires de fenêtres cela peut être configuré de nombreuses manières. S'il
existe un menu apparent, cherchez une entrée comme "Exit" (ou "Quitter"), ou
bien "Close Window Manager" ("Fermer le gestionnaire de fenêtres"). Si vous ne
voyez aucun menu, essayez de cliquer sur le fond de l'écran avec chaque bouton
de la souris.
<sect1>Caractéristiques de base de X</sect1>
<sect2>La souris</sect2>
La souris dans X fonctionne à peu près de la même façon que sous les autres
systèmes, si ce n'est qu'elle comporte trois boutons. Si votre souris n'en a
que deux, vous pouvez simuler le troisième bouton (celui du milieu) en cliquant
simultanément sur les deux boutons. C'est un peu délicat et ennuyeux, donc ce
ne serait pas une mauvaise idée que d'investir cent francs dans une souris à
trois boutons. Vous pouvez en trouver dans les grandes surfaces comme chez les
revendeurs informatiques.
<p>
Les boutons sont numérotés de gauche à droite dans le cas d'une souris pour
droitier, donc le bouton un est celui de gauche, le deuxième est au milieu et
le bouton trois est celui de droite. Vous trouverez dans la documentation aussi
bien les numéros des boutons que leur place.
<p>
<sect2>FIXME</sect2>
Cela dépend plus ou moins de votre gestionnaire de fenêtres ("wm", pour "window
manager"), mais il faudrait couvrir les aspects commun comme le copier-coller,
et les caractéristiques communes des gestionnaires de fenêtres comme les
bureaux et l'icônification.
<p>
xdm
<p>
<sect>Ce qui se produit quand vous démarrez X</sect>
We're (*Ndt: le traducteur avoue les limites)
<p>
/etc/X11/Xsession et .xsession.
<p>
Séquence d'événements.
<p>
Customiser .xsession pour changer de gestionnaire de fenêtres.
<p>
ls /usr/bin/X11/*wm donne une liste des gestionnaires de fenêtres disponnibles.
<p>
Mention de .xsession-errors
<sect>Customiser X</sect>
Comment customiser les caractères du clavier (keymap), le concept des
ressources de X
<p>
Ce qu'il y a dans /etc/X11/config (ou peut-être juste une référence au fichier
dans /usr/doc/ qui concerne ce point).
<sect>Customiser le gestionnaire de fenêtres</sect>
Un petit tutorial. Sans doute faudra-t-il en choisir un pour en parler dans
cette section.
<p>

<chapt>Outils pour le texte</chapt>
head, tail, grep, wc et autres.
<p>
(Je pense que ceci devrait inclure les "Expressions Régulières de Base" -
"Basic Regular Expressions" - dans la mesure où il est difficile de les
apprendre depuis un page man.)
<p>
<chapt>Outils pour les fichiers</chapt>
<sect>Outils de sauvegarde</sect>
FIXME il est clair que cette section est incomplète
<p>
tar, cpio, dump; mais aussi la copie à grande échelle, cp -a, etc.
<p>
(Peut-être quelque chose sur la façon de ne sauvegarder que /home 
et /etc si vous ne disposez que d'un lecteur de disquettes, dans 
la mesure où beaucoup d'utilisateurs  normaux n'auront pas de 
lecteur de bandes magnétiques) 
<p>
Comment utiliser tar pour copier beaucoup de fichiers, ou pour 
sauvegarder vos fichiers. Tarballs. Je pense cela devrait être 
une brève section concernant les systèmes mono-utilisateurs , 
avec une partie plus complète sur les administraeurs système 
dans un autre manuel.  
<p>
Les commandes de sauvegarde (contrition de Olivier Elphick, 
section à réarranger):  
<p>
<tt>dump<tt> - sauvegarde un système de fichiers à une heure 
donnée; ses options de commande supposent que vous utilisez 
un bande d'un demi-pouce (*Ndt: je n'ai aucune connaissance 
des lecteurs de bandes) (maximum 45Mb par bobine) ce qui est 
un peu ennuyeux quand on utilise des DAT (2Gb ou plus). 
Probablement le mieux pour les sauvegardes régulières. Ne 
peut être utilisé pour des système de fichiers montés avec NFS.
<p>
<tt>cpio - `find [directories] -print | cpio -ovH newc -B 
>/dev/st0'</tt>
<p>
<tt>tar - `tar cvf /dev/st0 [directories]'</tt>
<p>
<tt>afio</tt> - comme cpio; supporte la compression 
préalable des fichiers avant l'archivage.
<p>
<tt>tob</tt> - interface pour afio
<p>

<sect>Compression de fichiers avec <tt>gzip</tt></sect>
Il serait souvent utile de rendre un fichier plus petit: afin de le transférer
plus vite, ou pour qu'il prenne moins  de place sur votre disque. Le
programme utilisé est appelé  <tt>gzip</tt> (GNU Zip - le Zip de GNU).
<p>
<enumlist>
<item><example>cd; cp /etc/profile ./monfichieressai</example>
<p>
Passe sous votre répertoire personnel, puis copie un fichier choisi
arbitrairement (<tt>/etc/profile</tt>) dans votre  répertoire courant en le
renommant <tt>monfichieressai</tt>. Cela nous donne un fichier pour faire des
essais avec gzip. 
<p>
<item><example>ls -l</example>
<p>
Liste le contenu du répertoire courant. Notez la taille de
<tt>monfichieressai</tt>.
<p>
<item><example>gzip monfichieressai</example>
<p>
Compresse <tt>monfichieressai</tt>.
<p>
<item><example>ls -l</example>
<p>
Observez le résultat: maintenant, <tt>monfichieressai</tt> 
est nommé <tt>monfichieressai.gz</tt>. Il est aussi un peu 
plus petit.
<p>
<item><example>gunzip monfichieressai.gz; ls -l</example>
<p>
Décompresse. Vous pouvez observer que <tt>monfichier essai</tt> a repris son
aspect originel. Notez que pour <em>décompresser</em> on utilise
<tt>gunzip</tt>, non <tt>gzip</tt>.

<p>
<item><example>rm monfichieressai</example>
<p>
Efface le fichier, puisqu'il ne nous servait qu'à faire des essais.
<p>
</enumlist>
