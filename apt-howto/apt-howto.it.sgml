<!doctype debiandoc system><debiandoc>
 <book>
  <titlepag>
   <title>
     APT HOWTO
   </title>
   <author>
     <name>Gustavo Noronha Silva</name><email>kov@debian.org</email>
   </author>
   <translator>
     <name>Traduzione di Luca Monducci</name>
   </translator>
   <version>
     1.8.10 - Novembre 2004
   </version>
   <abstract>
     Questo documento intende fornire una buona base sul funzionamento del 
     sistema per la gestione dei pacchetti fornito da Debian, APT. Il suo 
     scopo è facilitare la vita ai nuovi utenti Debian e aiutarli ad 
     approfondire le loro conoscenze su come si amministrano i 
     pacchetti. Questo HOWTO fa parte del progetto Debian e ha lo scopo di 
     migliorare il supporto disponibile agli utenti di questa distribuzione.
   </abstract>
   <copyright>
    <copyrightsummary>
      Copyright &copy; 2001, 2002, 2003, 2004 Gustavo Noronha Silva
    </copyrightsummary>
    <copyrightsummary>
      Traduzione italiana &copy; 2002 &ndash; 2005 Luca Monducci
    </copyrightsummary>
    <p>
      This manual is free software; you may redistribute it and/or modify it 
      under the terms of the GNU General Public License as published by the 
      Free Software Foundation; either version 2, or (at your option) any 
      later version.
    </p>
    <p>
      This is distributed in the hope that it will be useful, but without 
      any warranty; without even the implied warranty of merchantability or 
      fitness for a particular purpose. See the GNU General Public License 
      for more details.
    </p>
    <p>
      A copy of the GNU General Public License is available as 
      /usr/share/common-licenses/GPL in the Debian GNU/Linux distribution or 
      on the World Wide Web at the GNU General Public Licence. You can also 
      obtain it by writing to the Free Software Foundation, Inc., 59 Temple 
      Place - Suite 330, Boston, MA 02111-1307, USA.
    </p>
    <p>
      <em>L'unica licenza valida è quella originale in lingua inglese. Di
      seguito ne trovate una traduzione abbastanza fedele che però non ha
      alcun valore legale.</em>
    </p>
    <p>
      Questo documento è software libero; è lecito redistribuirlo o
      modificarlo secondo i termini della GNU General Public License come
      è pubblicata dalla Free Software Foundation; o la versione 2 della
      licenza o (a propria scelta) una versione successiva.
    </p>
<!--La distribuzione e l'utilizzo di questo documento sono vincolati dai
termini indicati nella versione 2 (o da qualunque versione successiva) della
GNU General Public License pubblicata dalla Free Software Foundation.-->
    <p>
      Questo documento è distribuito con l'intento di essere utile, ma senza
      alcuna garanzia; senza neppure la garanzia implicita di negoziabilità o
      di applicabilità per un particolare scopo. Vedere la GNU General Public
      License per avere maggiori dettagli.
    </p>
    <p>
      Una copia della GNU General Public License à disponibile come
      /usr/share/common-licenses/GPL nella distribuzione Debian GNU/Linux
      oppure nel World Wide Web alla GNU General Public Licence. La si
      può ottenere anche scrivendo alla Free Software Foundation, Inc.,
      59 Temple Place - Suite 330, Boston, MA 0211-1307, USA.
    </p>
   </copyright>
  </titlepag>
  <toc detail="sect">
 
 <chapt>
  <heading>
    Introduzione
  </heading>
  <p>
    In principio esistevano i .tar.gz. Gli utenti dovevano compilare ogni 
    programma che volevano usare sui loro sistemi GNU/Linux. Quando fu 
    creata Debian, fu ritenuto necessario che il sistema incorporasse un 
    metodo di gestione dei pacchetti installati sulla macchina. A questo 
    sistema fu dato il nome <prgn>dpkg</prgn>. Fu così che nacque il famoso 
    "pacchetto" nel mondo GNU/Linux, poco prima che Red Hat decidesse di 
    creare il proprio "rpm".
  </p>
  <p>
    Rapidamente un nuovo dilemma si fece strada nelle menti degli 
    sviluppatori di GNU/Linux. A loro serviva un modo rapido, pratico ed 
    efficiente per installare i programmi, che gestisse automaticamente le 
    dipendenze e che avesse cura di mantenere i file di configurazione 
    esistenti mentre si effettuavano i vari aggiornamenti. Ancora una volta 
    Debian ha aperto la strada dando vita a APT (Advanced Packaging Tool), 
    che poi è stato adattato da Conectiva per usarlo insieme a rpm e in 
    seguito è stato adottato anche da altre distribuzioni.
  </p>
  <p>
    Questo HOWTO non tratta di apt-rpm, così è chiamato l'adattamento fatto 
    da Conectiva di APT, ma eventuali patch a questo documento saranno ben 
    accolte.
  </p>
  <p>
    Questo manuale è basato sulla prossima release Debian, <tt>Sarge</tt>.
  </p>
 </chapt>
 <chapt id="basico">
  <heading>
    Configurazione di base
  </heading>
  <sect id="sources.list">
   <heading>
     Il file /etc/apt/sources.list
   </heading>
   <p>
     Nello svolgere le sue operazioni, APT usa un file che contiene la lista 
     delle "sorgenti" dalle quali può attingere i pacchetti. Questo file è 
     <tt>/etc/apt/sources.list</tt>.
   </p>
   <p>
     Il contenuto di questo file ha normalmente il seguente formato:
   </p>
   <p>
    <example>deb http://sito.http.org/debian distribuzione sezione1 sezione2 sezione3
deb-src http://sito.http.org/debian distribuzione sezione1 sezione2 sezione3</example>
         </p>
   <p>
     &Egrave; da osservare che l'esempio sopra è fittizio e non dovrebbe 
     essere usato. La prima parola di ogni riga, <tt>deb</tt> o 
     <tt>deb-src</tt>, indica il tipo di archivio: se contiene pacchetti 
     binari (<tt>deb</tt>), che sono i pacchetti già compilati che 
     normalmente usiamo, o se l'archivio contiene i pacchetti sorgente 
     (<tt>deb-src</tt>), che sono il codice originale del programma con 
     l'aggiunta del file di controllo (<tt>.dsc</tt>) e del file 
     <tt>diff.gz</tt> che contiene i cambiamenti necessari per 
     "debianizzare" il programma.
   </p>
   <p>
     Generalmente questo è il contenuto predefinito di sources.list:
   </p>
   <p>
    <example># See sources.list(5) for more information, especially
# Remember that you can only use http, ftp or file URIs
# CDROMs are managed through the apt-cdrom tool.
deb http://http.us.debian.org/debian stable main contrib non-free
deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
deb http://security.debian.org stable/updates main contrib non-free

# Uncomment if you want the apt-get source function to work
#deb-src http://http.us.debian.org/debian stable main contrib non-free
#deb-src http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free</example>
         </p>
   <p>
     Queste righe sono quelle necessarie per un'installazione base. La prima 
     delle righe che iniziano con <tt>deb</tt> punta all'archivio ufficiale, 
     la seconda all'archivio non-US e la terza all'archivio degli 
     aggiornamenti di sicurezza Debian.
   </p>
   <p>
     Le ultime due righe sono commentate (con un "#" all'inizio), così 
     verranno ignorate da apt-get. Queste iniziano con <tt>deb-src</tt> e 
     puntano agli archivi che contengono i pacchetti sorgente. Se si 
     scaricano spesso i sorgenti di un programma per fare dei test o per 
     ricompilarlo, è necessario togliere il "#" all'inizio delle righe.
   </p>
   <p>
     In <tt>/etc/apt/sources.list</tt> si possono specificare diversi tipi 
     di righe. APT sa come trattare i seguenti tipi di archivio 
     <tt>http</tt>, <tt>ftp</tt>, <tt>file</tt> (file locali, per esempio 
     una directory su cui è montato un CD-ROM) e <tt>ssh</tt>.
   </p>
   <p>
     Non scordarsi di lanciare <tt>apt-get update</tt> ogni volta che si 
     modifica il file <tt>/etc/apt/source.list</tt>. Questa operazione forza 
     APT ad aggiornare la lista dei pacchetti che può reperire dalle 
     sorgenti specificate nel file stesso.
   </p>
  </sect>
  <sect id="dpkg-scanpackages">
   <heading>
     Come usare APT localmente
   </heading>
   <p>
     Può capitare di avere dei pacchetti .deb da installare e lo si vuole 
     fare usando APT così che le dipendenze siano risolte automaticamente.
   </p>
   <p>
     Per farlo bisogna creare una directory e metterci dentro i .deb da 
     trattare. Per esempio:
   </p>
   <p>
    <example># mkdir /root/debs</example>
   </p>
   <p>
     &Egrave; possibile modificare le opzioni nel file di controllo dei 
     pacchetti contenuti nell'archivio locale usando il file di 
     <tt>override</tt>. Dentro questo file si possono definire alcune 
     opzioni che hanno precedenza su quelle predefinite nei pacchetti. Il 
     suo formato dovrebbe assomigliare a quello che segue:
   </p>
   <p>
    <example>pacchetto priorità sezione</example>
   </p>
   <p>
     dove "pacchetto" è il nome del pacchetto, "priorità" può essere low, 
     medium o high e "sezione" è la sezione alla quale appartiene. Il nome 
     di questo file non è importante, successivamente dovrà essere passato 
     come argomento a <prgn>dpkg-scanpackages</prgn>. Se non si vuole 
     scrivere o usare un file di <tt>override</tt>, è sufficiente usare 
     <file>/dev/null</file> quando si richiama 
     <prgn>dpkg-scanpackages</prgn>.
   </p>
   <p>
     Rimanendo nella directory <tt>/root</tt> eseguire:
   </p>
   <p>
    <example># dpkg-scanpackages debs <var>file</var> | gzip &gt; debs/Packages.gz</example>
   </p>
   <p>
     Nella riga sopra, dove <var>file</var> è il file di <tt>override</tt>, 
     il comando genera il file <file>Packages.gz</file>, questo contiene 
     delle informazioni sui pacchetti che saranno usate da APT in 
     seguito. Infine, per usare i nostri pacchetti, aggiungere questa riga a 
     <tt>/etc/apt/source.list</tt>:
   </p>
   <p>
    <example>deb file:/root debs/</example>
   </p>
   <p>
     Adesso si può usare APT normalmente. Anche per i pacchetti sorgente si 
     può generare un archivio locale. Per farlo si segue la stessa 
     procedura, ma bisogna ricordarsi di avere i file <tt>.orig.tar.gz</tt>, 
     <tt>.dsc</tt> e <tt>.diff.gz</tt> nella directory di lavoro e bisogna 
     usare <tt>Sources.gz</tt> al posto di <tt>Packages.gz</tt>. Anche il 
     programma da usare è diverso: per questa operazione va utilizzato 
     <tt>dpkg-scansources</tt>. La riga di comando sarà simile a questa:
   </p>
   <p>
    <example># dpkg-scansources debs | gzip &gt; debs/Sources.gz</example>
   </p>
   <p>
     Notare che <tt>dpkg-scansources</tt> non necessita del file di 
     <tt>override</tt>. Infine aggiungere a <tt>/etc/apt/source.list</tt>:
   </p>
   <p>
    <example>deb-src file:/root debs/</example>
   </p>
  </sect>
  <sect id="netselect">
   <heading>
     Scegliere il miglior mirror da inserire in sources.list: netselect, 
     netselect-apt
   </heading>
   <p>
     Un dubbio molto frequente, in particolare per nuovi utenti, è: "quale 
     mirror inserire in <tt>sources.list</tt>?". Ci sono molti modi per 
     deciderlo. Gli utenti esperti probabilmente hanno uno script che misura 
     il tempo di ping verso svariati mirror. Ma c'è un programma che fa 
     questo per noi: <package>netselect</package>.
   </p>
   <p>
     Per installare netselect, generalmente si esegue:
   </p>
   <p>
    <example># apt-get install netselect</example>
   </p>
   <p>
     Eseguendo netselect senza alcun argomento viene mostrato un breve 
     elenco delle opzioni. Eseguendolo con una lista di host separati da uno 
     spazio come argomento visualizzerà un punteggio e il nome di uno degli 
     host. Il punteggio prende in considerazione il tempo di ping e gli hop 
     (numero di nodi della rete che si deve attraversare per raggiungere la 
     destinazione) ed è inversamente proporzionale alla velocità di download 
     stimata (il più basso è il migliore). Il nome mostrato è quello 
     dell'host che ha il punteggio più basso (la lista completa dei punteggi 
     si ottiene usando l'opzione -vv). Osservare questo esempio:
   </p>
   <p>
    <example># netselect ftp.debian.org http.us.debian.org ftp.at.debian.org download.unesp.br ftp.debian.org.br
  365 ftp.debian.org.br
#</example>
   </p>
   <p>
     Significa che, fra i mirror indicati nella riga di comando, 
     <tt>ftp.debian.org.br</tt> era il migliore, con un punteggio di 
     365. (Attenzione!! Questo risultato è stato ottenuto su un certo 
     computer e per un certo tipo d'accesso alla rete, quindi questo valore 
     non è assolutamente di validità generale).
   </p>
   <p>
     Ora è necessario aggiungere il mirror più veloce nel file 
     <tt>/etc/apt/sources.list</tt> (vedere <ref id="sources.list">) e 
     seguire i suggerimenti in <ref id="apt-get">.
   </p>
   <p>
     <strong>Nota:</strong> la lista completa dei mirror Debian si può 
     trovare a questo indirizzo <url 
     id="http://www.debian.org/mirror/mirrors_full" 
     name="http://www.debian.org/mirror/mirrors_full">.
   </p>
   <p>
     Dalla versione 0.3.ds1 il pacchetto sorgente netselect include il 
     pacchetto binario <strong>netselect-apt</strong> che esegue 
     automaticamente il processo descritto sopra. &Egrave; sufficiente 
     passare come parametro il ramo della distribuzione (stable è il valore 
     predefinito) e verrà generato un nuovo <tt>sources.list</tt> con i 
     mirror migliori per main e per non-US nella directory attuale. Il 
     prossimo esempio genera un <tt>sources.list</tt> per la distribuzione 
     stable:
   </p>
   <p>
    <example># ls sources.list
ls: sources.list: File or directory not found
# netselect-apt stable
(...)
# ls -l sources.list
sources.list
#</example>
   </p>
   <p>
     <strong>Da ricordare:</strong> il file <tt>sources.list</tt> è creato 
     nella directory attuale e deve essere spostato nella directory 
     <tt>/etc/apt</tt>.
   </p>
   <p>
     Infine, seguite i suggerimenti in <ref id="apt-get">.
   </p>
  </sect>
  <sect id="cdrom">
   <heading>
     Aggiungere un CD-ROM al file sources.list
   </heading>
   <p>
     Se si vuole usare un CD-ROM per installare i pacchetti o per aggiornare 
     il sistema automaticamente con APT, va inserito nel file 
     <tt>sources.list</tt>. Per farlo si può usare il programma 
     <prgn>apt-cdrom</prgn> in questo modo:
   </p>
   <p>
    <example># apt-cdrom add</example>
         </p>
   <p>
     con un CD-ROM di Debian nel lettore. Questa istruzione eseguirà il 
     mount del CD-ROM e, se il CD è valido, verranno cercate le informazioni 
     sui pacchetti che sono sul disco. Se la configurazione del CD-ROM è un 
     po' inusuale, si possono usare le seguenti opzioni:
   </p>
   <p>
    <example>-h           - Questo aiuto
-d directory - Mount point del CDROM
-r           - Rinomina un CDROM già riconosciuto
-m           - Nessun montaggio
-f           - Modalità veloce, non controlla i file dei pacchetti
-a           - Scansione in modalità accurata</example>
         </p>
   <p>
     Per esempio:
   </p>
   <p>
    <example># apt-cdrom -d /home/kov/mycdrom add</example>
         </p>
   <p>
     Si può controllare l'identità di un CD-ROM, senza inserirlo nella 
     lista:
   </p>
   <p>
    <example># apt-cdrom ident</example>
         </p>
   <p>
     Notare che questo programma funziona solo se il CD-ROM è correttamente 
     configurato in <tt>/etc/fstab</tt>.
   </p>
  </sect>
 </chapt>
 <chapt id="apt-get">
  <heading>
    Gestione dei pacchetti
  </heading>
  <sect id="update">
   <heading>
     Aggiornare la lista dei pacchetti disponibili
   </heading>
   <p>
     Il sistema di gestione dei pacchetti usa un suo database per tenere 
     traccia di quali pacchetti sono installati, quali non lo sono e quali 
     sono disponibili per l'installazione. Il programma <prgn>apt-get</prgn> 
     usa questo database per capire come installare i pacchetti richiesti 
     dall'utente e per scoprire quali ulteriori pacchetti sono necessari per 
     farli funzionare correttamente.
   </p>
   <p>
     Per aggiornare questo elenco, va usato il comando <prgn>apt-get 
     update</prgn>. Questo comando controlla le liste dei pacchetti presenti 
     negli archivi elencati in <tt>/etc/apt/sources.list</tt>; vedere <ref 
     id="sources.list"> ulteriori informazioni su questo file.
   </p>
   <p>
     &Egrave; una buona idea eseguire questo comando regolarmente per avere 
     un sistema informato su possibili aggiornamenti dei pacchetti, in 
     particolare sugli aggiornamenti di sicurezza.
   </p>
  </sect>
  <sect id="install">
   <heading>
     Installazione dei pacchetti
   </heading>
   <p>
     Con il file sources.list pronto e l'elenco dei pacchetti disponibili 
     aggiornato, tutto quello che è necessario fare per installare un 
     pacchetto è eseguire <tt>apt-get</tt>. Per esempio, si può lanciare:
   </p>
   <p>
    <example># apt-get install xchat</example>
         </p>
   <p>
     APT cercherà nel suo database la versione più recente del pacchetto e 
     lo recupererà, come specificato in <tt>sources.list</tt>, dal 
     corrispondente archivio. Nel caso che il pacchetto dipenda da altri, 
     come nel caso dell'esempio, APT controllerà le dipendenze e installerà 
     i pacchetti necessari, come nell'esempio successivo:
   </p>
   <p>
    <example># apt-get install nautilus
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 0 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 17.2MB will be used.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Il pacchetto <package>nautilus</package> dipende dalle librerie citate 
     sopra, quindi per prima cosa APT preleverà queste dall'archivio. Se si 
     era specificato sulla riga di comando di <tt>apt-get</tt> il nome di 
     queste librerie, APT non avrebbe chiesto conferma per continuare, 
     infatti avrebbe installato esattamente ciò che viene chiesto 
     dall'utente.
   </p>
   <p>
     Questo significa che APT chiede la conferma solo quando è necessario 
     installare pacchetti che non sono specificati sulla riga di comando.
   </p>
   <p>
     Le seguenti opzioni di apt-get possono essere utili:
   </p>
   <p>
    <example>-h  Questo aiuto
-d  Solamente download - NON installa o decomprime gli archivi
-f  Tenta di continuare se il controllo di integrità fallisce
-s  Nessuna azione. Simula i passi
-y  Assume sì a tutte le domande e non chiede conferma
-u  Mostra anche una lista dei pacchetti da aggiornare</example>
         </p>
   <p>
     Sulla riga di comando si possono specificare più pacchetti. I file 
     scaricati dalla rete sono riposti nella directory 
     <tt>/var/cache/apt/archives</tt> per la successiva installazione.
   </p>
   <p>
     Sulla medesima riga di comando si possono specificare anche i pacchetti 
     da rimuovere, è sufficiente mettere "-" immediatamente dopo il nome del 
     pacchetto che dev'essere rimosso, come in quest'esempio:
   </p>
   <p>
    <example># apt-get install nautilus gnome-panel-
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Fare riferimento a <ref id="remove"> per altri dettagli sulla rimozione 
     dei pacchetti.
   </p>
   <p>
     Se in qualche modo si danneggia un pacchetto già installato, o 
     semplicemente si vuole che i file di un pacchetto siano rimpiazzati da 
     quelli della versione più recente che è disponibile, si può usare 
     l'opzione <tt>--reinstall</tt>, in questo modo:
   </p>
   <p>
    <example># apt-get --reinstall install gdm
Reading Package Lists... Done
Building Dependency Tree... Done
0 packages upgraded, 0 newly installed, 1 reinstalled, 0 to remove and 1  not upgraded.
Need to get 0B/182kB of archives. After unpacking 0B will be used.
Do you want to continue? [Y/n]</example>
   </p>
  </sect>
  <sect id="remove">
   <heading>
     Rimozione dei pacchetti
   </heading>
   <p>
     Se non si vuole più usare un pacchetto, lo si può rimuovere dal sistema 
     usando APT. Per farlo eseguire: <tt>apt-get remove package</tt>. Per 
     esempio:
   </p>
   <p>
    <example># apt-get remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Come si può vedere nell'esempio sopra, APT si occupa di rimuovere anche 
     i pacchetti che dipendono da quello che si è chiesto di rimuovere. Non 
     c'è modo, usando APT, di rimuovere un pacchetto senza che siano rimossi 
     anche i pacchetti che dipendono da questo.
   </p>
   <p>
     Eseguendo <prgn>apt-get</prgn> come sopra, saranno rimossi i pacchetti 
     ma i loro file di configurazione, se ci sono, rimarranno intatti sul 
     sistema. Per una rimozione completa del pacchetto, eseguire:
   </p>
   <p>
    <example># apt-get --purge remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Notare gli "*" dopo i nomi. Indicano che anche i file di configurazione 
     di questi pacchetti saranno rimossi.
   </p>
   <p>
     Come nel caso del metodo <tt>install</tt>, si può usare un simbolo per 
     invertire il significato del metodo per un particolare pacchetto. Nel 
     caso di <tt>remove</tt> se si aggiunge "+" alla fine del nome del 
     pacchetto, il pacchetto sarà installato anziché essere rimosso.
   </p>
   <p>
    <example># apt-get --purge remove gnome-panel nautilus+
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Notare che <prgn>apt-get</prgn> elenca i pacchetti extra che saranno 
     installati (cioè i pacchetti di cui è necessaria l'installazione per il 
     corretto funzionamento dei pacchetti richiesti), i pacchetti che 
     saranno rimossi e i nuovi pacchetti che saranno installati (compresi, 
     ancora una volta, i pacchetti extra).
   </p>
  </sect>
  <sect id="upgrade">
   <heading>
     Aggiornamento dei pacchetti
   </heading>
   <p>
     Gli aggiornamenti dei pacchetti sono un grande successo di APT. Possono 
     essere realizzati con un singolo comando: <tt>apt-get upgrade</tt>. Si 
     può usare questo comando sia per aggiornare i pacchetti della stessa 
     distribuzione, sia per aggiornare a una nuova distribuzione, benché per 
     questo scopo si consiglia: <tt>apt-get dist-upgrade</tt>; vedere <ref 
     id="dist-upgrade"> per ulteriori dettagli.
   </p>
   <p>
     &Egrave; utile eseguire questo comando con l'opzione 
     <tt>-u</tt>. Questa opzione forza APT a mostrare la lista completa dei 
     pacchetti che saranno aggiornati, senza l'aggiornamento avverrà senza 
     mostrare nulla. APT scaricherà la versione più recente di ogni 
     pacchetto e li installerà nel giusto ordine. &Egrave; importante 
     eseguire sempre <tt>apt-get update</tt> prima di provare 
     l'aggiornamento. A questo proposito consultare <ref 
     id="update">. Osservare questo esempio:
   </p>
   <p>
    <example># apt-get -u upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages have been kept back
  cpp gcc lilo 
The following packages will be upgraded
  adduser ae apt autoconf debhelper dpkg-dev esound esound-common ftp indent
  ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0 libesd0-dev
  libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev liborbit0
  libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit procps psmisc 
29 packages upgraded, 0 newly installed, 0 to remove and 3 not upgraded.
Need to get 5055B/5055kB of archives. After unpacking 1161kB will be used.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Il procedimento è molto semplice. Notare che nelle prime righe, 
     <tt>apt-get</tt> informa che alcuni pacchetti saranno trattenuti 
     (<tt>kept back</tt>). Questo significa che esistono nuove versioni di 
     questi pacchetti ma che non saranno installate per qualche 
     ragione. Motivi possibili sono la presenza di dipendenze che non 
     possono essere soddisfatte (uno dei pacchetti da cui dipende non è 
     disponibile per il download) o nuove dipendenze (il pacchetto ha 
     aggiunto una nuova dipendenza nell'ultima versione).
   </p>
   <p>
     Non c'è una soluzione semplice nel primo caso. Nel secondo caso è 
     sufficiente lanciare <tt>apt-get install</tt> per il pacchetto in 
     questione e le dipendenze saranno risolte. Una soluzione altrettanto 
     valida è usare <tt>dist-upgrade</tt>. Controllare in <ref 
     id="dist-upgrade">.
   </p>
  </sect>
  <sect id="dist-upgrade">
   <heading>
     Aggiornare a una nuova release
   </heading>
   <p>
     Questa caratteristica di APT permette di aggiornare l'intero sistema in 
     una volta sola, sia attraverso internet che attraverso un CD 
     (acquistato o scaricato come immagine ISO).
   </p>
   <p>
     &Egrave; usata anche quando ci sono delle modifiche alle relazioni fra 
     i pacchetti installati. Con <tt>apt-get upgrade</tt>, questi pacchetti 
     saranno lasciati intoccati (<tt>kept back</tt>).
   </p>
   <p>
     Per esempio, supponiamo che si stia usando la release 0 della versione 
     stable di Debian e che abbiamo comprato un CD con la release 3. Si può 
     usare APT per aggiornare il sistema da questo nuovo CD. Si usa 
     <prgn>apt-cdrom</prgn> (guardare <ref id="cdrom">) per aggiungere il CD 
     al file <tt>/etc/apt/sources.list</tt> e poi si esegue <tt>apt-get 
     dist-upgrade</tt>.
   </p>
   <p>
     &Egrave; importante notare che APT cerca sempre la versione più recente 
     dei pacchetti. Quindi, se nel file <tt>/etc/apt/sources.list</tt> è 
     elencato un archivio che contiene una versione di un pacchetto più 
     recente di quella sul CD, APT vorrà scaricare il pacchetto da 
     quell'archivio.
   </p>
   <p>
     Nell'esempio mostrato in <ref id="upgrade">, abbiamo visto che alcuni 
     pacchetti possono essere trattenuti (<tt>kept back</tt>). Adesso questo 
     problema verrà risolto con il metodo <tt>dist-upgrade</tt>:
   </p>
   <p>
    <example># apt-get -u dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following NEW packages will be installed:
  cpp-2.95 cron exim gcc-2.95 libident libopenldap-runtime libopenldap1
  libpcre2 logrotate mailx 
The following packages have been kept back
  lilo 
The following packages will be upgraded
  adduser ae apt autoconf cpp debhelper dpkg-dev esound esound-common ftp gcc
  indent ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0
  libesd0-dev libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev
  liborbit0 libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit
  procps psmisc 
31 packages upgraded, 10 newly installed, 0 to remove and 1 not upgraded.
Need to get 0B/7098kB of archives. After unpacking 3118kB will be used.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Adesso va osservato che alcuni pacchetti saranno aggiornati e altri 
     nuovi saranno installati (le nuove dipendenze dei pacchetti già 
     installati). Notare che <package>lilo</package> continua a essere 
     trattenuto, probabilmente ha qualche altro problema che è più serio di 
     una nuova dipendenza. Lo si può scoprire eseguendo:
   </p>
   <p>
    <example># apt-get -u install lilo
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be REMOVED:
  debconf-tiny 
The following NEW packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be upgraded
  lilo 
1 packages upgraded, 9 newly installed, 1 to remove and 31 not upgraded.
Need to get 225kB/1179kB of archives. After unpacking 2659kB will be used.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Come si può notare sopra, la nuova versione di <package>lilo</package> 
     è in conflitto con <package>debconf-tiny</package>, questo significa 
     che non può essere installato (o aggiornato) senza rimuovere 
     <package>debconf-tiny</package>.
   </p>
   <p>
     Per sapere quali pacchetti saranno rimossi o non-aggiornati si può 
     usare:
   </p>
   <p>
    <example># apt-get -o Debug::pkgProblemResolver=yes dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Starting
Starting 2
Investigating python1.5
Package python1.5 has broken dep on python1.5-base
  Considering python1.5-base 0 as a solution to python1.5 0
  Holding Back python1.5 rather than change python1.5-base
Investigating python1.5-dev
Package python1.5-dev has broken dep on python1.5
  Considering python1.5 0 as a solution to python1.5-dev 0
  Holding Back python1.5-dev rather than change python1.5
 Try to Re-Instate python1.5-dev
Done
Done
The following packages have been kept back
  gs python1.5-dev 
0 packages upgraded, 0 newly installed, 0 to remove and 2  not upgraded.</example>
         </p>
   <p>
     In questo modo è facile vedere che il pacchetto python1.5-dev non può 
     essere installato perché c'è una dipendenza non soddisfatta: python1.5.
   </p>
  </sect>
  <sect id="clean">
   <heading>
     Rimozione dei file dei pacchetti: apt-get clean e autoclean
   </heading>
   <p>
     Quando si installa un pacchetto APT recupera tutti i file necessari 
     delle sorgenti specificate in /etc/apt/sources.list, gli immagazzina in 
     un archivio locale (<file>/var/cache/apt/archives/</file>) e poi 
     procede con l'installazione. Vedere <ref id="install">.
   </p>
   <p>
     Con il tempo l'archivio locale cresce e può occupare molto spazio sul 
     disco. Fortunatamente APT fornisce gli strumenti per la gestione di 
     questo archivio: i metodi <tt>clean</tt> e <tt>autoclean</tt> di 
     <prgn>apt-get</prgn>.
   </p>
   <p>
     <prgn>apt-get clean</prgn> elimina qualunque cosa, tranne i file lock, 
     dalle directory <file>/var/cache/apt/archives/</file> e 
     <file>/var/cache/apt/archives/partial/</file>. Di conseguenza, se si 
     volesse reinstallare un pacchetto APT dovrà nuovamente scaricarlo.
   </p>
   <p>
     <prgn>apt-get autoclean</prgn> cancella solo i file dei pacchetti che 
     non possono più essere scaricati.
   </p>
   <p>
     Il prossimo esempio mostra come lavora apt-get autoclean:
   </p>
   <p>
    <example># ls /var/cache/apt/archives/logrotate* /var/cache/apt/archives/gpm*
logrotate_3.5.9-7_i386.deb
logrotate_3.5.9-8_i386.deb
gpm_1.19.6-11_i386.deb</example>
         </p>
   <p>
     Nella directory /var/cache/apt/archives ci sono due file che forniscono 
     il pacchetto <package>logrotate</package> e uno che fornisce il 
     pacchetto <package>gpm</package>.
   </p>
   <p>
    <example># apt-show-versions -p logrotate
logrotate/stable uptodate 3.5.9-8
# apt-show-versions -p gpm
gpm/stable upgradeable from 1.19.6-11 to 1.19.6-12</example>
         </p>
   <p>
     <prgn>apt-show-versions</prgn> mostra che 
     <file>logrotate_3.5.9-8_i386.deb</file> fornisce la versione aggiornata 
     di <package>logrotate</package>, quindi il file 
     <file>logrotate_3.5.9-7_i386.deb</file> è inutile. Anche il file 
     <file>gpm_1.19.6-11_i386.deb</file> è inutile perché è disponibile una 
     versione più recente.
   </p>
   <p>
    <example># apt-get autoclean
Reading Package Lists... Done
Building Dependency Tree... Done
Del gpm 1.19.6-11 [145kB]
Del logrotate 3.5.9-7 [26.5kB]</example>
         </p>
   <p>
     Infine, <tt>apt-get autoclean</tt>, rimuove solo i file inutili. Vedere 
     <ref id="apt-show-versions"> per ulteriori informazioni su 
     apt-show-versions.
   </p>
  </sect>
  <sect id="dselect-upgrade">
   <heading>
     Usare APT insieme a dselect
   </heading>
   <p>
     <prgn>dselect</prgn> è un programma che aiuta gli utenti a scegliere 
     quali pacchetti installare. &Egrave; ritenuto piuttosto complicato e 
     abbastanza noioso, ma con la pratica si può acquisire familiarità con 
     la sua interfaccia basata su ncurses.
   </p>
   <p>
     Una caratteristica di dselect è che sa usare la capacità che hanno i 
     pacchetti Debian di "raccomandare" e "consigliare" l'installazione di 
     altri pacchetti. Per avviare il programma, usare <tt>dselect</tt> da 
     root, scegliere "apt" come metodo di accesso (non è obbligatorio, ma se 
     non si sta usando un CD-ROM e si vuole scaricare i pacchetti da 
     internet, è il miglior modo d'usare dselect).
   </p>
   <p>
     Per approfondire l'uso di dselect, leggere la documentazione sul sito 
     Debian <url id="http://www.debian.org/doc/ddp" 
     name="http://www.debian.org/doc/ddp">.
   </p>
   <p>
     Dopo aver fatto le scelte con dselect, usare:
   </p>
   <p>
    <example># apt-get -u dselect-upgrade</example>
         </p>
   <p>
     come nell'esempio sotto:
   </p>
   <p>
    <example># apt-get -u dselect-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  lbxproxy 
The following NEW packages will be installed:
  bonobo console-tools-libs cpp-3.0 enscript expat fingerd gcc-3.0
  gcc-3.0-base icepref klogd libdigest-md5-perl libfnlib0 libft-perl
  libgc5-dev libgcc300 libhtml-clean-perl libltdl0-dev libsasl-modules
  libstdc++3.0 metamail nethack proftpd-doc psfontmgr python-newt talk tidy
  util-linux-locales vacation xbill xplanet-images 
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 30 newly installed, 1 to remove and 0  not upgraded.
Need to get 7140kB of archives. After unpacking 16.3MB will be used.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Questo è quello che si ottiene esguendo <tt>apt-get dist-upgrade</tt> 
     sullo stesso sistema:
   </p>
   <p>
    <example># apt-get -u dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 0 newly installed, 0 to remove and 0  not upgraded.
Need to get 421kB of archives. After unpacking 25.6kB will be freed.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Notare che molti dei pacchetti elencati sopra sono installati perché 
     sono "consigliati" o "raccomandati" da altri pacchetti. Altri sono 
     installati o rimossi (nell'esempio lbxproxy) per le scelte che sono 
     state fatte nella lista dei pacchetti con dselect. Dselect può essere 
     uno strumento davvero potente se usato insieme ad APT.
   </p>
  </sect>
  <sect id="default-version">
   <heading>
     Come mantenere un sistema misto
   </heading>
   <p>
     Alcune volte le persone vogliono usare una delle versioni Debian come 
     distribuzione per il sistema principale e uno o più pacchetti di un 
     altro ramo.
   </p>
   <p>
     Per impostare qual è la versione di Debian principale è necessario 
     modificare la seguente riga del file <file>/etc/apt/apt.conf</file>:
   </p>
   <p>
    <example>APT::Default-Release "<var>versione</var>";</example>
   </p>
   <p>
     Dove <var>versione</var> è la versione di Debian che si desidera usare 
     come distribuzione principale. Le versioni che si possono usare sono 
     <tt>stable</tt>, <tt>testing</tt> e <tt>unstable</tt>. Poi, per 
     installare pacchetti di un'altra versione, si dovrà usare APT nel 
     seguente modo:
   </p>
   <p>
    <example># apt-get -t <var>distribuzione</var> install <var>pacchetto</var></example>
   </p>
   <p>
     Per funzionare è necessario specificare nel file 
     <file>/etc/apt/sources.list</file> fra le sorgenti per APT almeno una 
     riga per la distribuzione da cui si vuole prelevare il pacchetto e che 
     il pacchetto sia disponibile tramite quella fonte.
   </p>
   <p>
     &Egrave; anche possibile richiedere l'installazione di una specifica 
     versione di un pacchetto usando la seguente sintassi:
    <example># apt-get install <var>pacchetto</var>=<var>versione</var></example>
     Per esempio, con la prossima riga è possibile installare la versione 
     <tt>2.2.4-1</tt> del pacchetto <package>nautilus</package>:
    <example># apt-get install nautilus=2.2.4-1</example>
         </p>
   <p>
     <em>IMPORTANTE</em>: la versione "unstable" è la versione di Debian che 
     contiene i nuovi pacchetti e i più recenti aggiornamenti. Questa 
     distribuzione segue tutti i cambiamenti dei pacchetti, dai più piccoli 
     ai più drastici che possono influenzare molti altri pacchetti o 
     l'intero sistema. Per questo motivo, questa versione della 
     distribuzione <em>non</em> dovrebbe essere usata da utenti inesperti o 
     da chi necessita di una collaudata stabilità.
   </p>
   <p>
     La distribuzione "testing" non è necessariamente migliore di 
     "unstable", dato che non riceve rapidamente gli aggiornamenti di 
     sicurezza. Per i server e per i sistemi di produzione si dovrebbe usare 
     sempre la distribuzione "stable".
   </p>
  </sect>
  <sect id="apt-show-versions">
   <heading>
     Come aggiornare i pacchetti di una specifica distribuzione Debian
   </heading>
   <p>
     <prgn>apt-show-versions</prgn> fornisce agli utenti delle distribuzioni 
     miste un modo sicuro per aggiornare i loro sistemi senza ottenere poi 
     una distribuzione meno stabile di quella che hanno in mente. Per 
     esempio, è possibile aggiornare solo i pacchetti di unstable eseguendo 
     dopo aver installato il pacchetto <package>apt-show-versions</package>:
   </p>
   <p>
    <example># apt-get install `apt-show-versions -u -b | grep unstable | cut -d ' ' -f 1`</example>
   </p>
  </sect>
  <sect id="pin">
   <heading>
     Come bloccare una specifica versione di un pacchetto installata (i pin)
   </heading>
   <p>
     Può capitare di modificare qualcosa in un pacchetto e che non si abbia 
     voglia o tempo, di apportare questi cambiamenti a una nuova versione 
     del programma. Oppure, per esempio, si vuole aggiornare la 
     distribuzione alla 3.0, ma si vuole continuare a usare alcuni pacchetti 
     nella versione presente nella Debian 2.2. Per far questo si può 
     "fissare" questi pacchetti nella versione installata in modo che non 
     saranno aggiornati.
   </p>
   <p>
     Usare questo mezzo è semplice. Basta solo modificare il file 
     <tt>/etc/apt/preferences</tt>.
   </p>
   <p>
     Il formato è semplice:
   </p>
   <p>
    <example>Package: &lt;pacchetto&gt;
Pin: &lt;definizione del pin&gt;
Pin-Priority: &lt;priorità del pin&gt;</example>
   </p>
   <p>
     Per esempio, per mantenere il pacchetto <package>sylpheed</package> che 
     si è modificato per usare "reply-to-list" nella versione 0.4.99 si 
     aggiunge:
   </p>
   <p>
    <example>Package: sylpheed
Pin: version 0.4.99*</example>
   </p>
   <p>
     Notare che si è usato un <tt>*</tt> (asterisco). Questo è un "carattere 
     jolly"; indica che questo "pin" è valido per tutte le versioni che 
     iniziano con 0.4.99. Questo perché Debian numera i suoi pacchetti 
     usando un "numero di revisione" e non si vuole impedire l'installazione 
     delle revisioni successive. Così, per esempio, le revisioni 0.4.99-1 e 
     0.4.99-10 saranno installate non appena sono disponibili. Notare che se 
     si è modificato il pacchetto non si vuole che questo accada.
   </p>
   <p>
     La priorità del pin determina se un pacchetto che verifica le righe 
     "Packages:" e "Pin:" verrà installato; più è alta la priorità e 
     maggiori sono le possibilità che il pacchetto sia installato. Si può 
     leggere <manref section="7" name="apt_preferences"> per una profonda 
     discussione sulle priorità, ma alcuni esempi possono rendere l'idea. Di 
     seguito sono descritti gli effetti di diversi valori del campo priorità 
     per l'esempio precedente.
   </p>
   <p>
    <taglist>
     <tag>
       1001
     </tag>
     <item>
      <p>
        La versione 0.4.99 di sylpheed non sarà mai sostituita da apt. Se 
        disponibile apt installerà la versione 0.4.99 anche sostituendo una 
        versione successiva del pacchetto già installata. Solo i pacchetti 
        con priorità superiore a 1000 possono far retrocedere un pacchetto 
        già installato.
      </p>
     </item>
     <tag>
       1000
     </tag>
     <item>
      <p>
        L'effetto è lo stesso della priorità con l'eccezione che apt si 
        rifiuta di retrocedere la versione installata alla versione 0.4.99.
      </p>
     </item>
     <tag>
       990
     </tag>
     <item>
      <p>
        La versione 0.4.99 verrà sostituita solo da una versione successiva 
        disponibile per la release impostata come preferita tramite la 
        variabile "APT::Default-Release" (vedere <ref 
        id="default-version">).
      </p>
     </item>
     <tag>
       500
     </tag>
     <item>
      <p>
        Qualsiasi versione successiva alla 0.4.99 di sylpheed disponibile da 
        una qualunque release avrà precedenza sulla versione 0.4.99, ma la 
        0.4.99 ha comunque la precedenza su tutte le versioni precedenti.
      </p>
     </item>
     <tag>
       100
     </tag>
     <item>
      <p>
        Le versioni successive di sylpheed disponibili da qualsiasi release 
        hanno precedenza sulla versione 0.4.99 di conseguenza verrà 
        installata qualsiasi versione successiva di sylpheed, la versione 
        0.4.99 verrà installata solo se non c'è una versine già 
        installata. Questa è la priorità dei pacchetti una volta che sono 
        installati.
      </p>
     </item>
     <tag>
       -1
     </tag>
     <item>
      <p>
        Sono consentiti anche valori negativi per la priorità, impediscono 
        che 0.4.99 sia installato.
      </p>
     </item>
    </taglist>
   </p>
   <p>
     Un pin può specificare la versione (<tt>version</tt>), la release 
     (<tt>release</tt>) o l'origine (<tt>origin</tt>) di un pacchetto.
   </p>
   <p>
     Il pin su <tt>version</tt>, come abbiamo visto, ammette sia cifre che 
     caratteri jolly per specificare più versioni contemporaneamente.
   </p>
   <p>
     L'opzione <tt>release</tt> dipende dal file Release nell'archivio usato 
     da APT o nel CD. Questa opzione non può essere usata se l'archivio che 
     si usa non fornisce questo file. Si può controllare il contenuto dei 
     file Release in <tt>/var/lib/apt/lists/</tt>. I parametri per release 
     sono: <tt>a</tt> (archive), <tt>c</tt> (components), <tt>v</tt> 
     (version), <tt>o</tt> (origin) e <tt>l</tt> (label).
   </p>
   <p>
     Un esempio:
   </p>
   <p>
    <example>Package: *
Pin: release v=2.2*,a=stable,c=main,o=Debian,l=Debian
Pin-Priority: 1001</example>
   </p>
   <p>
     In questo esempio abbiamo scelto la versione 2.2* (che può essere 
     2.2r2, 2.2r3; questi sono i "point release" che tipicamente includono 
     le fix di sicurezza e altri importanti aggiornamenti), la versione 
     <tt>stable</tt>, la sezione <tt>main</tt> (al posto di <tt>contrib</tt> 
     o <tt>non-free</tt>) e come origine e etichetta Debian. Origine (o) 
     definisce il nome della distribuzione: Debian per la Debian e Progeny 
     per Progeny, per esempio. Un esempio del file Release:
   </p>
   <p>
    <example>$ cat /var/lib/apt/lists/ftp.debian.org.br_debian_dists_potato_main_binary-i386_Release
Archive: stable
Version: 2.2r3
Component: main
Origin: Debian
Label: Debian
Architecture: i386</example>
   </p>
  </sect>
 </chapt>
 <chapt id="helpers">
  <heading>
    Aiuti molto utili
  </heading>
  <sect id="equivs">
   <heading>
     Come installare i pacchetti compilati in proprio: equivs
   </heading>
   <p>
     Qualche volta si vuole usare una specifica versione di un programma 
     disponibile solo tramite i sorgenti, senza alcun pacchetto Debian. Ma 
     per il sistema di gestione dei pacchetti questo può essere un 
     problema. Supponiamo che si voglia compilare una nuova versione del 
     server e-mail. Non ci sarebbero problemi, ma molti pacchetti di Debian 
     dipendono da un MTA (Mail Transport Agent) e, quando si installa 
     qualcosa che abbiamo compilato in proprio, il sistema di gestione dei 
     pacchetti non può sapere nulla del nuovo software.
   </p>
   <p>
     Qui entra in scena <package>equivs</package>. Per usarlo installare il 
     pacchetto omonimo. Equivs crea un pacchetto vuoto che è capace di 
     soddisfare qualunque dipendenza, facendo credere al sistema di gestione 
     dei pacchetti che le dipendenze sono soddisfatte.
   </p>
   <p>
     Prima di iniziare è bene ricordare che esistono modi più sicuri per 
     compilare un programma già impacchettato per Debian con opzioni 
     differenti e che non si dovrebbe usare equivs per rimpiazzare le 
     dipendenze se non sa quali possono essere le conseguenze sul 
     sistema. Vedere <ref id="sourcehandling"> per ulteriori informazioni.
   </p>
   <p>
     Continuando con l'esempio del MTA: si è appena installato il 
     neo-compilato <prgn>postfix</prgn> e ora si vuole installare 
     <package>mutt</package>, però <package>mutt</package> richiede di 
     installare un altro MTA. Ma ce ne già uno installato.
   </p>
   <p>
     Cambiare directory (<file>/tmp</file>, per esempio) ed eseguire:
   </p>
   <p>
    <example># equivs-control <var>nome</var></example>
         </p>
   <p>
     Mettere al posto di <var>name</var> il nome del file di controllo da 
     creare. Il file che sarà creato è come quello che segue:
   </p>
   <p>
    <example>Section: misc
Priority: optional
Standards-Version: 3.0.1

Package: &lt;enter package name; defaults to equivs-dummy&gt;
Version: &lt;enter version here; defaults to 1.0&gt;
Maintainer: &lt;your name and email address; defaults to username&gt;
Pre-Depends: &lt;packages&gt;
Depends: &lt;packages&gt;
Recommends: &lt;packages&gt;
Suggests: &lt;package&gt;
Provides: &lt;(virtual)package&gt;
Architecture: all
Copyright: &lt;copyright file; defaults to GPL2&gt;
Changelog: &lt;changelog file; defaults to a generic changelog&gt;
Readme: &lt;README.Debian file; defaults to a generic one&gt;
Extra-Files: &lt;additional files for the doc directory, comma-seperated&gt;
Description: &lt;short description; defaults to some wise words&gt;
 long description and info
 .
 second paragraph</example>
         </p>
   <p>
     Ora è necessario modificarlo in modo che faccia quello che si 
     vuole. Qui verrà mostrato il formato dei soli campi necessari:
   </p>
   <p>
    <example>Section: misc
Priority: optional
Standards-Version: 3.0.1

Package: mta-local
Provides: mail-transport-agent</example>
         </p>
   <p>
     <package>mutt</package> dipende da 
     <package>mail-transport-agent</package>, che è un pacchetto virtuale 
     fornito da tutti i MTA, si potrebbe semplicemente nominare il pacchetto 
     <package>mail-transport-agent</package>, ma è preferibile usare lo 
     schema dei pacchetti virtuali tramite "Provides".
   </p>
   <p>
     Ora serve solo creare il pacchetto:
   </p>
   <p>
    <example># equivs-build <var>name</var>
dh_tstdir
touch build-stamp
dh_testdir
dh_testroot
dh_clean -k
# Add here commands to install the package into debian/tmp.
touch install-stamp
dh_testdir
dh_testroot
dh_installdocs
dh_installchangelogs
dh_compress
dh_fixperms
dh_installdeb
dh_gencontrol
dh_md5sums
dh_builddeb
dpkg-deb: building package `<var>name</var>' in `../<var>name</var>_1.0_all.deb'.

The package has been created.
Attention, the package has been created in the current directory,</example>
         </p>
   <p>
     e installare il <tt>.deb</tt> finale.
   </p>
   <p>
     Come si può vedere ci sono molti usi di <prgn>equivs</prgn>. Per 
     esempio, si può creare un pacchetto <tt>my-fovorites</tt>, che dipende 
     dai programmi che abitualmente si installano, per esempio. Si ha la più 
     completa libertà di scelta, ma si deve valutare attentamente quello che 
     si ha intenzione di fare.
   </p>
   <p>
     Infine notare che ci sono vari esempi di file di controllo in 
     <file>/usr/share/doc/equivs/example</file>.
   </p>
  </sect>
  <sect id="localepurge">
   <heading>
     Rimuovere i file di localizzazione inutilizzati: localepurge
   </heading>
   <p>
     Molti utenti Debian usano una sola impostazione internazionale. Un 
     utente brasiliano, per esempio, generalmente usa <em>locale</em> 
     settato come <tt>pt_BR</tt> tutto il tempo e non gli interessa avere a 
     disposizione anche <tt>es</tt>.
   </p>
   <p>
     <package>localepurge</package> è uno strumento molto utile per questi 
     utenti, infatti possono liberare molto spazio mantenendo solo i file di 
     localizzazione che realmente usano. Per installare localepurge: 
     <tt>apt-get install localepurge</tt>.
   </p>
   <p>
     Questo pacchetto è veramente semplice da configurare dato che debconf 
     guida l'utente passo dopo passo nella sua configurazione. Tuttavia si 
     deve porre attenzione alle risposte delle prime domande, che, se non 
     corrette, potrebbero causare la rimozione di tutti i file di 
     localizzazione, compresi quelli che si indendeva mantenere. In questo 
     caso, l'unico modo per ripristinare questi file è reinstallare i 
     pacchetti che li forniscono.
   </p>
  </sect>
  <sect id="helper-show-versions">
   <heading>
     Come sapere quali pacchetti potrebbero essere aggiornati
   </heading>
   <p>
     <prgn>apt-show-versions</prgn> è un programma che mostra quali 
     pacchetti del sistema potrebbero essere aggiornati e altre utili 
     informazioni. L'opzione <tt>-u</tt> visualizza un elenco dei pacchetti 
     aggiornabili:
   </p>
   <p>
    <example>$ apt-show-versions -u
libeel0/unstable upgradeable from 1.0.2-5 to 1.0.2-7
libeel-data/unstable upgradeable from 1.0.2-5 to 1.0.2-7</example>
   </p>
  </sect>
 </chapt>
 <chapt id="search">
  <heading>
    Ottenere informazioni sui pacchetti
  </heading>
  <p>
    Ci sono vari front-end per APT che rendono più semplice avere la lista 
    dei pacchetti disponibili per l'installazione o di quelli già 
    installati, così come scoprire a quale sezione appartiene un pacchetto, 
    qual è la sua priorità, qual è la sua descrizione, ecc.
  </p>
  <p>
    Ma lo scopo è imparare ad usare APT. Come si può conoscere il nome di un 
    pacchetto che si desidera installare?
  </p>
  <p>
    Sono disponibili alcuni programmi ognuno con il suo specifico 
    compito. Inizieremo con <tt>apt-cache</tt>. Questo programma è usato da 
    APT per gestire il suo database. Faremo un breve riassunto sulle sue 
    applicazioni più comuni.
  </p>
  <sect id="cache">
   <heading>
     Avere informazioni sui nomi dei pacchetti
   </heading>
   <p>
     Per esempio, supponiamo che si voglia ricordare i bei vecchi tempi 
     dell'Atari 2600. Si vuole usare APT per installare un emulatore 
     dell'Atari e per scaricare qualche gioco. Si può fare così:
   </p>
   <p>
    <example># apt-cache search atari
atari-fdisk-cross - Partition editor for Atari (running on non-Atari)
circuslinux - The clowns are trying to pop balloons to score points!
madbomber - A Kaboom! clone
tcs - Character set translator.
atari800 - Atari emulator for svgalib/X/curses
stella - Atari 2600 Emulator for X windows
xmess-x - X binaries for Multi-Emulator Super System</example>
         </p>
   <p>
     Sono presenti parecchi pacchetti che riguardano quello che si stava 
     cercando, e tutti hanno una breve descrizione. Per avere più 
     informazioni su un pacchetto, si può usare:
   </p>
   <p>
    <example># apt-cache show stella
Package: stella
Priority: extra
Section: non-free/otherosfs
Installed-Size: 830
Maintainer: Tom Lear &lt;tom@trap.mtview.ca.us&gt;
Architecture: i386
Version: 1.1-2
Depends: libc6 (&gt;= 2.1), libstdc++2.10, xlib6g (&gt;= 3.3.5-1)
Filename: dists/potato/non-free/binary-i386/otherosfs/stella_1.1-2.deb
Size: 483430
MD5sum: 11b3e86a41a60fa1c4b334dd96c1d4b5
Description: Atari 2600 Emulator for X windows
 Stella is a portable emulator of the old Atari 2600 video-game console
 written in C++.  You can play most Atari 2600 games with it.  The latest
 news, code and binaries for Stella can be found at:
 http://www4.ncsu.edu/~bwmott/2600</example>
         </p>
   <p>
     Questo è l'output con molti più dettagli sul pacchetto che si desidera 
     (o non si desidera) installare. Se il pacchetto è già installato sul 
     sistema e ne esiste una nuova versione saranno mostrate le informazioni 
     su entrambe le versioni. Per esempio:
   </p>
   <p>
    <example># apt-cache show lilo
Package: lilo
Priority: important
Section: base
Installed-Size: 271
Maintainer: Russell Coker &lt;russell@coker.com.au&gt;
Architecture: i386
Version: 1:21.7-3
Depends: libc6 (&gt;= 2.2.1-2), debconf (&gt;=0.2.26), logrotate
Suggests: lilo-doc
Conflicts: manpages (&lt;&lt;1.29-3)
Filename: pool/main/l/lilo/lilo_21.7-3_i386.deb
Size: 143052
MD5sum: 63fe29b5317fe34ed8ec3ae955f8270e
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.

Package: lilo
Status: install ok installed
Priority: important
Section: base
Installed-Size: 190
Maintainer: Vincent Renardias &lt;vincent@debian.org&gt;
Version: 1:21.4.3-2
Depends: libc6 (&gt;= 2.1.2)
Recommends: mbr
Suggests: lilo-doc
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.</example>
         </p>
   <p>
     Notare che il primo pacchetto nella lista dell'esempio precedente è la 
     versione disponibile per l'installazione e il secondo è quello già 
     installato. Per avere delle informazioni generali su un pacchetto si 
     può usare:
   </p>
   <p>
    <example># apt-cache showpkg penguin-command
Package: penguin-command
Versions: 
1.4.5-1(/var/lib/apt/lists/download.sourceforge.net_debian_dists_unstable_main_binary-i386_Packages)(/var/lib/dpkg/status)

Reverse Depends: 
Dependencies: 
1.4.5-1 - libc6 (2 2.2.1-2) libpng2 (0 (null)) libsdl-mixer1.1 (2 1.1.0) libsdl1.1 (0 (null)) zlib1g (2 1:1.1.3) 
Provides: 
1.4.5-1 - 
Reverse Provides:</example>
         </p>
   <p>
     E per sapere solo quali sono le dipendenze:
   </p>
   <p>
    <example># apt-cache depends penguin-command
penguin-command
  Depends: libc6
  Depends: libpng2
  Depends: libsdl-mixer1.1
  Depends: libsdl1.1
  Depends: zlib1g</example>
         </p>
   <p>
     Ricapitolando, abbiamo un'ampia gamma di strumenti che possiamo usare 
     per trovare il nome dei pacchetti che vogliamo.
   </p>
  </sect>
  <sect id="dpkg-search">
   <heading>
     Usare dpkg per avere informazioni sui pacchetti
   </heading>
   <p>
     Un modo per individuare un pacchetto è conoscere il nome di un file che 
     può essere trovato al suo interno. Per esempio, per trovare il 
     pacchetto che fornisce un particolare ".h" necessario per compilare un 
     programma si può eseguire:
   </p>
   <p>
    <example># dpkg -S stdio.h
libc6-dev: /usr/include/stdio.h
libc6-dev: /usr/include/bits/stdio.h
perl: /usr/lib/perl/5.6.0/CORE/nostdio.h</example>
         </p>
   <p>
     oppure:
   </p>
   <p>
    <example># dpkg -S /usr/include/stdio.h
libc6-dev: /usr/include/stdio.h</example>
         </p>
   <p>
     Per avere i nomi dei pacchetti installati nel sistema, utile in 
     previsione di "pulizia" dei dischi, si può lanciare:
   </p>
   <p>
    <example># dpkg -l | grep mozilla
ii  mozilla-browse 0.9.6-7        Mozilla Web Browser</example>
   </p>
   <p>
     Il problema di questo commando è che può "spezzare" il nome del 
     pacchetto. Nell'esempio sopra il nome intero del pacchetto è 
     <tt>mozilla-browser</tt>, per sistemare questo inconveniente si può 
     usare la variabile d'ambiente <tt>COLUMNS</tt> in questo modo:
   </p>
   <p>
    <example>$ COLUMNS=132 dpkg -l | grep mozilla
ii  mozilla-browser             0.9.6-7                     Mozilla Web Browser - core and browser</example>
         </p>
   <p>
     o fare una ricerca sulla descrizione o su parte di essa:
   </p>
   <p>
    <example># apt-cache search "Mozilla Web Browser"
mozilla-browser - Mozilla Web Browser</example>
   </p>
  </sect>
  <sect id="auto-apt">
   <heading>
     Come installare pacchetti "on demand"
   </heading>
   <p>
     Si sta compilando un programma e, a un certo punto, boom! C'è un errore 
     perché è necessario un file <tt>.h</tt> che non è installato. Il 
     programma <prgn>auto-apt</prgn> può essere utile in questa 
     situazione. Questo programma ferma l'esecuzione del processo 
     principale, chiede di installare i pacchetti necessari e, una volta 
     installati, prosegue nell'esecuzione del processo principale.
   </p>
   <p>
     Quello che si deve fare è lanciare:
   </p>
   <p>
    <example># auto-apt run command</example>
         </p>
   <p>
     Dove "command" è il comando che deve essere eseguito a cui potrebbero 
     mancare alcuni file. Per esempio:
   </p>
   <p>
    <example># auto-apt run ./configure</example>
         </p>
   <p>
     Questo chiederà di installare i pacchetti necessari e, se li vogliamo 
     installare, chiama automaticamente apt-get. Gli utenti che usano X 
     possono usare anche un'interfaccia grafica anziché la normale 
     interfaccia testuale.
   </p>
   <p>
     Per funzionare correttamente auto-apt usa un database che deve essere 
     tenuto aggiornato. Questo può essere fatto usando i commandi 
     <tt>auto-apt update</tt>, <tt>auto-apt updatedb</tt> e <tt>auto-apt 
     update-local</tt>.
   </p>
  </sect>
  <sect id="apt-file">
   <heading>
     Come scoprire a quale pacchetto appartiene un file
   </heading>
   <p>
     Se si vuole installare un pacchetto, di cui non si riesce a scoprire il 
     nome usando <prgn>apt-cache</prgn>, ma di cui si conosce il nome del 
     programma o di un file che è contenuto nel pacchetto, si può usare 
     <prgn>apt-file</prgn> per trovare il nome del pacchetto in questo modo:
   </p>
   <p>
    <example>$ apt-file search <var>file</var></example>
         </p>
   <p>
     Funziona come <tt>dpkg -S</tt>, con la differenza che la ricerca è 
     effettuata anche nei pacchetti non installati. Può anche essere usato 
     per scoprire quali pacchetti contengono i file mancanti quando si 
     compilano dei programmi, anche se <prgn>auto-apt</prgn> sia un metodo 
     molto migliore per risolvere questo genere di problemi, vedere <ref 
     id="auto-apt">.
   </p>
   <p>
     &Egrave; anche possibile vedere contenuto di un pacchetto eseguendo:
   </p>
   <p>
    <example>$ apt-file list <var>pacchetto</var></example>
         </p>
   <p>
     <prgn>apt-file</prgn> tiene un database del contenuto di tutti i 
     pacchetti, come fa auto-apt, e questo dev'essere tenuto aggiornato. Lo 
     si fa eseguendo:
   </p>
   <p>
    <example># apt-file update</example>
         </p>
   <p>
     <prgn>apt-file</prgn> usa lo stesso database di <prgn>auto-apt</prgn>, 
     controllare <ref id="auto-apt">.
   </p>
  </sect>
  <sect id="apt-listchanges">
   <heading>
     Come essere informato sui cambiamenti nei pacchetti
   </heading>
   <p>
     Ogni pacchetto installa, nella sua directory dedicata alla 
     documentazione (<tt>/usr/share/doc/pacchetto</tt>), un file chiamato 
     <tt>changelog.Debian.gz</tt> che contiene l'elenco dei cambiamenti 
     fatti al pacchetto sino all'ultima versione. &Egrave; possibile leggere 
     questo file usando, per esempio, <tt>zless</tt> però non è semplice, 
     dopo un aggiornamento completo del sistema, cercare i changelog di ogni 
     pacchetto che è stato aggiornato.
   </p>
   <p>
     C'è un modo per automatizzare questo lavoro tramite l'uso di 
     <prgn>apt-listchanges</prgn>. Per prima cosa si deve installare il 
     pacchetto <package>apt-listchanges</package>. Durante l'installazione, 
     debconf chiederà come lo si vuole configurare, anche se alcune domande, 
     in base al livello di priorità impostato in Debconf, potrebbero non 
     essere visualizzate, si consiglia di ricordare i seguenti suggerimenti 
     mentre si risponde.
   </p>
   <p>
     la prima domanda chiede come apt-listchanges deve essere mostrare le 
     modifiche, è possibile che siano inviate per posta (ideale per gli 
     aggiornamenti automatici) o che siano mostrate in un impaginatore come 
     <prgn>less</prgn> (in modo da consultarli prima di completare 
     l'aggiornamento). Se non si vuole che <prgn>apt-listchanges</prgn> sia 
     eseguito automaticamente durante gli aggiornamenti si può rispondere 
     <tt>nessuno</tt>.
   </p>
   <p>
     Dopo aver installato apt-listchanges, appena i pacchetti sono 
     disponibili per l'installazione (scaricati, presi da un CD, ecc.) apt 
     mostrerà i changelog di questi pacchetti prima di installarli.
   </p>
  </sect>
 </chapt>
 <chapt id="sourcehandling">
  <heading>
    Lavorare con i pacchetti sorgente
  </heading>
  <sect id="source">
   <heading>
     Scaricare i pacchetti sorgente
   </heading>
   <p>
     Spesso nel mondo del software libero si fanno correzioni ai programmi 
     che contengono dei bug. Per fare questo è necessario scaricare il 
     sorgente del programma: APT fornisce un modo semplice per scaricare i 
     sorgenti di un programma, compresi i file necessari per creare il 
     pacchetto .deb.
   </p>
   <p>
     Un altro uso comune dei sorgenti è compilare su una distribuzione 
     stable i pacchetti di testing o di unstable dato che, quelli presenti 
     in quest'ultime, sono più recenti. Infatti, compilando un pacchetto su 
     stable, sarà creato un .deb le cui dipendenze sono automaticamente 
     aggiustate per operare in questa distribuzione.
   </p>
   <p>
     Per poter fare questo dev'essere specificata almeno una riga 
     <tt>deb-src</tt> in <tt>/etc/apt/sources.list</tt> che punti ai 
     pacchetti di testing o di unstable. Vedere <ref id="sources.list">.
   </p>
   <p>
     Per scaricare un pacchetto sorgente, si può usare il seguente comando:
   </p>
   <p>
    <example>$ apt-get source packagename</example>
   </p>
   <p>
     Questo scaricherà tre file: un <tt>.orig.tar.gz</tt>, un <tt>.dsc</tt> 
     e un <tt>.diff.gz</tt>. Se un pacchetto è fatto specificamente per 
     Debian, l'ultimo fra quelli elencati non è scaricato e al primo della 
     lista mancherà <tt>orig</tt> nel nome.
   </p>
   <p>
     Il file <tt>.dsc</tt> è usato da dpkg-source per decomprimere il 
     pacchetto sorgente nella directory 
     <var>nomepacchetto-versione</var>. Dentro tutti i pacchetti sorgente, 
     una volta scompattati, c'è dentro una directory <tt>debian/</tt> che 
     contiene i file necessari per la costruzione del pacchetto .deb.
   </p>
   <p>
     Per automatizzare la costruzione del pacchetto, dopo aver scaricato i 
     sorgenti, è sufficiente aggiungere l'opzione <tt>-b</tt> nella riga di 
     comando:
   </p>
   <p>
    <example>$ apt-get -b source packagename</example>
         </p>
   <p>
     Se invece non si vuole creare il .deb al termine del download, lo si 
     può creare successivamente lanciando:
   </p>
   <p>
    <example>$ dpkg-buildpackage -rfakeroot -uc -b</example>
         </p>
   <p>
     dopo essersi assicurati che nella directory corrente sia quella creata 
     per il pacchetto al termine del download. Per installare il pacchetto 
     creato con i precedenti comandi si deve usare direttamente il gestore 
     di pacchetti in questo modo:
   </p>
   <p>
    <example># dpkg -i <var>file.deb</var></example>
         </p>
   <p>
     C'è una differenza fra il metodo <tt>source</tt> e gli altri messi a 
     disposizione da <prgn>apt-get</prgn>: tale metodo può essere usato da 
     tutti gli utenti senza che questi abbiano i privilegi di root. I file 
     sono scaricati nella directory dalla quale è stato lanciato il comando 
     <tt>apt-get source package</tt>.
   </p>
  </sect>
  <sect id="build-dep">
   <heading>
     Soddisfare le dipendenze per compilare un pacchetto sorgente
   </heading>
   <p>
     Normalmente per compilare un pacchetto sorgente è necessario aver 
     installato header e librerie appropriate. Tutti i pacchetti sorgente 
     hanno nei loro file di controllo un campo chiamato "Build-Depends:" che 
     indica quali pacchetti devono essere installati per poter costruire il 
     pacchetto dai sorgenti.
   </p>
   <p>
     APT possiede un metodo veramente semplice per scaricare questi 
     pacchetti. &Egrave; sufficiente lanciare <tt>apt-get build-dep 
     pacchetto</tt>, dove "pacchetto" è il nome del pacchetto che si vuole 
     compilare. Per esempio:
   </p>
   <p>
    <example># apt-get build-dep gmc
Reading Package Lists... Done
Building Dependency Tree... Done
The following NEW packages will be installed:
  comerr-dev e2fslibs-dev gdk-imlib-dev imlib-progs libgnome-dev libgnorba-dev
  libgpmg1-dev 
0 packages upgraded, 7 newly installed, 0 to remove and 1  not upgraded.
Need to get 1069kB of archives. After unpacking 3514kB will be used.
Do you want to continue? [Y/n]</example>
         </p>
   <p>
     Saranno installati i pacchetti necessari per la corretta compilazione 
     del pacchetto <package>gmc</package>. &Egrave; importante notare che 
     questo comando non recupera i file sorgente del pacchetto che si vuole 
     compilare, per scaricarlo va lanciato prima <tt>apt-get source</tt>.
   </p>
   <p>
     Se invece si è interessati solo a controllare quali pacchetti sono 
     necessari per compilare un certo pacchetto c'è una variante del comando 
     <tt>apt-cache show</tt> (vedere <ref id="search">), che vi mostrerà fra 
     le varie informazioni la riga <tt>Build-Depends</tt> in cui sono 
     elencati questi pacchetti.
   </p>
   <p>
    <example># apt-cache showsrc <var>pacchetto</var></example>
         </p>
  </sect>
 </chapt>
 <chapt id="erros">
  <heading>
    Come trattare gli errori
  </heading>
  <sect id="erros-comuns">
   <heading>
     Errori banali
   </heading>
   <p>
     Gli errori sono sempre accaduti, molti di questi sono causati da utenti 
     che non prestano attenzione. Quella che segue è una breve lista degli 
     errori più frequenti e di come si possono risolvere.
   </p>
   <p>
     Se viene visualizzato un messaggio d'errore che assomiglia a questo 
     quando si sta provando a installare un pacchetto con <tt>apt-get 
     install package</tt>...
   </p>
   <p>
    <example>Reading Package Lists... Done
Building Dependency Tree... Done
W: Couldn't stat source package list 'http://people.debian.org unstable/ Packages' (/var/state/apt/lists/people.debian.org_&percnt;7ekov_debian_unstable_Packages) - stat (2 No such file or directory)
W: You may want to run apt-get update to correct these missing files
E: Couldn't find package penguineyes</example>
         </p>
   <p>
     vuol dire che non si è lanciato <tt>apt-get update</tt> dopo l'ultima 
     modifica al file <tt>/etc/apt/sources.list</tt>.
   </p>
   <p>
     Se l'errore assomiglia a questo:
   </p>
   <p>
    <example>E: Could not open lock file /var/lib/dpkg/lock - open (13 Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?</example>
         </p>
   <p>
     quando si tenta di usare <prgn>apt-get</prgn> con qualunque metodo 
     (tranne <tt>source</tt>), significa che non si hanno i permessi 
     dell'utente root, cioè si sta eseguendo <prgn>apt-get</prgn> come un 
     normale utente.
   </p>
   <p>
     C'è anche un errore simile al precedente che avviene quando si tenta di 
     avviare più di un processo <prgn>apt-get</prgn> o quando 
     <prgn>apt-get</prgn> è lanciato mentre è già attivo un processo 
     <prgn>dpkg</prgn>. L'unico modo possibile per avere più processi 
     <prgn>apt-get</prgn> attivi è usare il metodo <tt>source</tt>.
   </p>
   <p>
     Se un'installazione si blocca e non è più possibile né installare né 
     rimuovere il pacchetto, provare con questi due comandi:
   </p>
   <p>
    <example># apt-get -f install
# dpkg --configure -a</example>
         </p>
   <p>
     E poi tentare di nuovo. Potrebbe essere necessario ripetere più volte i 
     comandi precedenti. Questa è una lezione importante per gli 
     avventurieri che usano "unstable".
   </p>
   <p>
     Se si riceve l'errore "E: Dynamic MMap ran out of room" durante 
     l'esecuzione di <tt>apt-get update</tt>, aggiungete la seguente riga a 
     <file>/etc/apt/apt.conf</file>:
    <example>APT::Cache-Limit 10000000;</example>
         </p>
  </sect>
  <sect id="help">
   <heading>
     Dove posso trovare aiuto?
   </heading>
   <p>
     In caso di dubbi, consultare la vasta documentazione disponibile per il 
     sistema di gestione dei pacchetti Debian. <tt>--help</tt> e le pagine 
     di manuale possono essere d'aiuto, inoltre si può leggere la 
     documentazione contenuta nelle directory <tt>/usr/share/doc</tt> e in 
     particolare <tt>/usr/share/doc/apt</tt>.
   </p>
   <p>
     Se questa documentazione non è sufficiente, si può provare a cercare la 
     risposta nell'archivio delle mailing list. Altre informazioni sulle 
     mailing list si possono trovare sul sito web di Debian: <url 
     id="http://www.debian.org" name="http://www.debian.org">.
   </p>
   <p>
     Tuttavia, queste mailing list dovrebbero essere usate solo dagli utenti 
     Debian; gli utenti di altri sistemi troveranno un miglior supporto 
     dalle communità che si occupano della propria distribuzione.
   </p>
  </sect>
 </chapt>
 <chapt id="distros">
  <heading>
    Quali distribuzioni supportano APT?
  </heading>
  <p>
    Di seguito sono elencati i nomi di alcune distribuzioni che usano APT:
  </p>
  <p>
    Debian GNU/Linux (<url id="http://www.debian.org" 
    name="http://www.debian.org">) - la distribuzione per la quale è stato 
    sviluppato APT
  </p>
  <p>
    Conectiva (<url id="http://www.conectiva.com.br" 
    name="http://www.conectiva.com.br">) - è stata la prima distribuzione a 
    fondere insieme APT con rpm
  </p>
  <p>
    Libranet (<url id="http://www.libranet.com" 
    name="http://www.libranet.com">)
  </p>
  <p>
    Mandrake (<url id="http://www.mandrake.com" 
    name="http://www.mandrake.com">)
  </p>
  <p>
    PLD (<url id="http://www.pld.org.pl" name="http://www.pld.org.pl">)
  </p>
  <p>
    Vine (<url id="http://www.vinelinux.org" 
    name="http://www.vinelinux.org">)
  </p>
  <p>
    APT4RPM (<url id="http://apt4rpm.sf.net" name="http://apt4rpm.sf.net">)
  </p>
  <p>
    Alt Linux (<url id="http://www.altlinux.ru/" 
    name="http://www.altlinux.ru/">)
  </p>
  <p>
    Red Hat (<url id="http://www.redhat.com/" 
    name="http://www.redhat.com/">)
  </p>
  <p>
    Sun Solaris (<url id="http://www.sun.com/" name="http://www.sun.com/">)
  </p>
  <p>
    SuSE (<url id="http://www.suse.de/" name="http://www.suse.de/">)
  </p>
  <p>
    Yellow Dog Linux (<url id="http://www.yellowdoglinux.com/" 
    name="http://www.yellowdoglinux.com/">)
  </p>
 </chapt>
 <chapt id="agradecimentos">
  <heading>
    Ringraziamenti
  </heading>
  <p>
    Un grande grazie va ai miei amici del progetto Debian-BR e a Debian in 
    sé, che sono un aiuto costante per me e che sempre mi danno la forza per 
    continuare a lavorare per il miglioramento dell'umanità, così come mi 
    aiutano nel mio scopo di salvare il mondo. :)
  </p>
  <p>
    Voglio ringraziare il CIPSGA per l'enorme aiuto che ha dato al nostro 
    progetto e a tutti i progetti liberi che nascono da grandi idee.
  </p>
  <p>
    E speciali ringraziamenti vanno a:
  </p>
  <p>
    Yooseong Yang &lt;yooseong@debian.org&gt;
  </p>
  <p>
    Michael Bramer &lt;grisu@debian.org&gt;
  </p>
  <p>
    Bryan Stillwell &lt;bryan@bokeoa.com&gt;
  </p>
  <p>
    Pawel Tecza &lt;pawel.tecza@poczta.fm&gt;
  </p>
  <p>
    Hugo Mora &lt;h.mora@melix.com.mx&gt;
  </p>
  <p>
    Luca Monducci &lt;luca.mo@tiscali.it&gt;
  </p>
  <p>
    Tomohiro KUBOTA &lt;kubota@debian.org&gt;
  </p>
  <p>
    Pablo Lorenzzoni &lt;spectra@debian.org&gt;
  </p>
  <p>
    Steve Langasek &lt;vorlon@netexpress.net&gt;
  </p>
  <p>
    Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;
  </p>
  <p>
    Erik Rossen &lt;rossen@freesurf.ch&gt;
  </p>
  <p>
    Ross Boylan &lt;RossBoylan@stanfordalumni.org&gt;
  </p>
  <p>
    Matt Kraai &lt;kraai@debian.org&gt;
  </p>
  <p>
    Aaron M. Ucko &lt;ucko@debian.org&gt;
  </p>
  <p>
    Jon &Aring;slund &lt;d98-jas@nada.kth.se&gt;
  </p>
 </chapt>
 <chapt id="novas">
  <heading>
    Nuove versioni di questo tutorial
  </heading>
  <p>
    Questo manuale è stato creato dal progetto <url 
    id="http://www.debian-br.org" name="Debian-BR">, con lo scopo di 
    agevolare l'uso quotidiano di Debian.
  </p>
  <p>
    Nuove versioni di questo documento saranno disponibili alla pagina del 
    Progetto di Documentazione Debian <url 
    id="http://www.debian.org/doc/ddp" 
    name="http://www.debian.org/doc/ddp">.
  </p>
  <p>
    Commenti e critiche possono essere inviati per email all'autore 
    <email>kov@debian.org</email>.
  </p>
 </chapt>
</book>
</debiandoc>
