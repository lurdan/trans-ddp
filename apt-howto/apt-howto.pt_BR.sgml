<!doctype debiandoc system>
<debiandoc>

<book>

<title>Como usar o APT</title>

<author>
<name>Gustavo Noronha Silva</name> <email>kov@debian.org</email>
</author>

<version>1.8.3 - Dezembro de 2002</version>

<abstract>
Esse documento pretende levar ao usuário um bom conhecimento
das funções do utilitário de empacotamento do Debian, APT.
É objetivo real deste, facilitar a vida dos novos usuários
de Debian ou ajudar aqueles que desejam se aprofundar no
conhecimento da administração desse sistema. Ele foi criado 
para o projeto Debian-BR para melhorar ainda mais o suporte
à distribuição Debian oferecido ao usuário falante da língua
portuguesa.
</abstract>

<copyright>
<copyrightsummary>
Copyright &copy; 2001, 2002 Gustavo Noronha Silva
</copyrightsummary>
<p>
Esse manual está licenciado nos termos da GNU FDL (Free Documentation
License). Ele é feito na intenção de ser útil à comunidade mas vem sem
nenhuma garantia, use a seu próprio risco.
</copyright>

<toc>

<chapt>Introdução
<p>
No início havia o .tar.gz. Os usuários tinham de penar para compilar
cada programa usado em seu sistema GNU/Linux, ou outro qualquer. Quando
o Debian foi criado, sentiu-se a necessidade de um sistema de gerenciamento
de pacotes instalados no sistema. Deu-se a esse sistema o nome de 
<prgn>dpkg</prgn>. Assim surgiu o famoso `pacote'. Logo após a Red Hat 
resolveu criar seu conhecido sistema rpm.
<p>
Rapidamente outro dilema tomou conta das mentes dos produtores de GNU/Linux.
Uma maneira rápida, prática e eficiente de se instalar pacotes, gerenciando
suas dependências automaticamente e tomando conta de seus arquivos de
configuração ao atualizar. Assim, o Debian, novamente pioneiro, criou o 
APT ou Advanced Packaging Tool, hoje portado pela Conectiva e incorporado
por algumas outras distribuições.
<p>
Este manual não tenta entrar na área do apt-rpm, como ficou conhecido o 
APT portado pela Conectiva, mas "patches" são bem vindos para atingir
esse objetivo.
<p>
Esse manual é baseado na próxima versão do Debian, a <tt>Sarge</tt>.
</chapt>

<chapt id="basico">Configurações Básicas

<sect id="sources.list">O arquivo /etc/apt/sources.list
<p>
Para seu funcionamento, o APT utiliza-se de um arquivo que lista as
`fontes' de onde ele obterá os pacotes. Esse arquivo é o 
<tt>/etc/apt/sources.list</tt>.
<p>
As entradas desse arquivo são normalmente formadas assim:

<p>
<example>
deb http://site.http.org/debian distribuição seção1 seção2 seção3
deb-src http://site.http.org/debian distribuição seção1 seção2 seção3
</example>
<p>

É lógico que essas entradas são fictícias e não devem ser usadas. A primeira
palavra das linhas, <tt>deb</tt> e <tt>deb-src</tt> indicam o tipo de repositório:
se guarda pacotes binários (<tt>deb</tt>), ou seja, os pré-compilados que
normalmente usamos ou se guarda pacotes fonte (<tt>deb-src</tt>), que são o
fonte original do programa mais o arquivo de controle Debian (<tt>.dsc</tt>)
e o <tt>diff.gz</tt> contendo as modificações necessárias para se debianizar
o programa.
<p>
Normalmente encontramos nos sources.list padrões do Debian o seguinte:
<p>
<example>
# See sources.list(5) for more information, especialy
# Remember that you can only use http, ftp or file URIs
# CDROMs are managed through the apt-cdrom tool.
deb http://http.us.debian.org/debian stable main contrib non-free
deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
deb http://security.debian.org stable/updates main contrib non-free

# Uncomment if you want the apt-get source function to work
#deb-src http://http.us.debian.org/debian stable main contrib non-free
#deb-src http://non-us.debian.org/debian-non-US stable non-US
</example>
<p>

Basicamente, isso é o necessário. A primeira linha com <tt>deb</tt>
aponta para o repositório oficial, a segunda para o non-US e a 
terceira para as atualizações de segurança.
<p>
As duas últimas linhas estão comentadas, (têm um `#' no início) o que
faz com que o apt-get as ignore. Elas são do estilo <tt>deb-src</tt>,
ou seja, têm os pacotes fonte do Debian. Se você costuma baixar fontes
de programas para testar ou recompilar, descomente-as.
<p>
O arquivo <tt>/etc/apt/sources.list</tt> pode conter vários tipos de
linhas. O APT sabe lidar com repositórios <tt>http</tt>, <tt>ftp</tt>,
<tt>file</tt> (arquivos locais, por exemplo, um diretório que contenha
uma ISO montada) e <tt>ssh</tt>, até onde eu sei.
<p>
Não se esqueça de rodar <tt>apt-get update</tt> depois de modificar
o arquivo <tt>/etc/apt/sources.list</tt>. Você precisa fazer isso
para que o APT obtenha as listas de pacotes das fontes que você
especificou.
</sect>

<sect id="dpkg-scanpackages">Como usar o APT localmente
<p>
Algumas vezes você tem um monte de pacotes .deb que gostaria de
usar o APT para instalar, para que as dependências fossem automaticamente
resolvidas.
<p>
Para isso crie um diretório e nele coloque os .deb que você quer
ter indexados. Por exemplo:
<p>
<example>
# mkdir /root/debs
</example>
<p>
Você pode modificar as definições do arquivo de controle dos
pacotes diretamente no repositório usando um arquivo 
<tt>override</tt>. Dentro desse arquivo você pode definir 
algumas opções para se sobreporem ao que vem junto do pacote. 
Ele tem a seguinte forma:
<p>
<example>
pacote prioridade seção
</example>
<p>
Pacote é o nome do pacote, prioridade é low, medium ou high e seção
é a seção a qual ele pertence. O nome do arquivo não importa, ele
vai ser passado como argumento para o comando 
<prgn>dpkg-scanpackages</prgn> mais tarde. Se você não quer usar
um arquivo <tt>override</tt> use <file>/dev/null</file>.
<p>
Ainda no diretório /root faça:
<p>
<example>
# dpkg-scanpackages debs <var>arquivo</var> | gzip &gt; debs/Packages.gz
</example>
<p>
Na linha acima, <var>arquivo</var> é o arquivo <tt>override</tt>, o 
comando gera um arquivo <file>Packages.gz</file> que contém informações 
diversas  sobre os pacotes que serão usadas pelo APT. Para usar os 
pacotes, finalmente, adicione:
<p>
<example>
deb file:/root debs/
</example>
<p>
Depois é só usar os comandos do APT normalmente. Você também pode
gerar um repositório de fontes. Para isso use o mesmo procedimento,
mas leve em conta que precisa ter os arquivos <tt>.orig.tar.gz</tt>,
<tt>.dsc</tt> e <tt>.diff.gz</tt> no diretório e use <tt>Sources.gz</tt> 
ao invés de <tt>Packages.gz</tt>. O programa a ser usado também difere. 
É o <prgn>dpkg-scansources</prgn>. Fica assim:
<p>
<example>
# dpkg-scansources debs | gzip &gt; debs/Sources.gz
</example>
<p>
Note que o <prgn>dpkg-scansources</prgn> não precisa de um arquivo
<tt>override</tt>. A linha pro sources.list fica:
<p>
<example>
deb-src file:/root debs/
</example>
<p>
</sect>

<sect id="netselect">Decidindo qual mirror incluir no sources.list: netselect, netselect-apt
<p>
Uma dúvida muito freqüente, principalmente dos usuários mais novos, é
"qual mirror do Debian colocar no <tt>sources.list</tt>". Para decidir qual
o mirror existem várias maneiras. Os mais experientes provavelmente já terão
um script pronto medindo os tempos de ping entre os diversos mirrors. Mas já
existe um programa que faz isso para nós: <strong>netselect</strong>.
<p>
Para instalar o netselect, como sempre:
<p>
<example>
# apt-get install netselect
</example>
<p>
Executando-o sem parâmetros mostra a ajuda. Executando-o com uma lista
separada por espaços de hosts (mirrors), ele retornará um escore e um dos
hosts. Esse escore leva em consideração o tempo estimado de ping e o número
de hops (hosts pelos quais uma requisição de rede deve passar para chegar no
host destino), e é inversamente proporcional à velocidade estimada de download
(ou seja, quanto menor, melhor). O host retornado é o que obteve o menor
escore (a lista dos escores pode ser obtida acrescentanto a opção -vv).
Veja o seguinte exemplo: <p>
<example>
# netselect ftp.debian.org http.us.debian.org ftp.at.debian.org download.unesp.br ftp.debian.org.br
  365 ftp.debian.org.br
#
</example>
<p>
Isso significa que, dos mirrors incluídos como parâmetros do netselect,
<tt>ftp.debian.org.br</tt> foi o melhor, com um escore de 365. (Atenção!!
Como isso foi feito do meu computador e a topografia da rede é extremamente
diferente dependendo do ponto de contato, esse valor não necessariamente
reflete corretamente a velocidade em outros computadores).
<p>
Agora, basta colocar o mirror mais rápido encontrado pelo netselect no
arquivo <tt>/etc/apt/sources.list</tt> (veja <ref id="sources.list">) e
seguir as dicas em <ref id="apt-get">.
<p> <strong>Observação:</strong> uma
lista de mirrors pode sempre ser encontrada no arquivo <url
id="http://www.debian.org/mirror/mirrors_full"
name="http://www.debian.org/mirror/mirrors_full">. 
<p> 
A partir da versão 0.3 o pacote netselect inclui o script 
<strong>netselect-apt</strong>, que automatiza o processo descrito 
acima. Basta usar como parâmetro do script a distribuição (se não for 
mencionada, stable é adotada como padrão) e o arquivo 
<file>/etc/apt/sources.list</file> é gerado com os melhores mirrors 
da seção main e non-US e gravado no diretório atual. O exemplo a 
seguir gera um sources.list da distribuição stable. 
<p>
<example> $ ls sources.list
ls: sources.list: File or directory not found
# netselect-apt stable
(...)
# ls -l sources.list
sources.list
#
</example>
<p>
<strong>Lembre-se:</strong> o arquivo <tt>sources.list</tt> gerado no
diretório atual deve ser movido para o diretório <tt>/etc/apt</tt>.
<p>
Depois basta seguir as dicas em <ref id="apt-get">.
</sect>

<sect id="cdrom">Colocando um CDROM na sources.list
<p>
Se você preferir usar um CDROM para instalar seus pacotes ou
atualizar seu sistema automaticamente com o APT, você pode
colocá-lo na sua <tt>sources.list</tt>. Para fazer isso, rode 
o <prgn>apt-cdrom</prgn> assim:

<p>
<example>
# apt-cdrom add
</example>
<p>

com o CDROM do Debian no drive. Ele irá montar o CDROM, caso
seja o certo e irá buscar as informações de pacote dele.
Caso sua configuração de CDROM esteja um pouco confusa, você
pode usar as seguintes opções:

<p>
<example>
-h           - ajuda do programa
-d diretório - ponto de montagem do CDROM
-r           - renomear um CDROM reconhecido
-m           - não montar
-f           - modo rápido (não atualiza lista de pacotes)
-a           - scan minucioso
</example>
<p>

Por exemplo:

<p>
<example>
# apt-cdrom -d /home/kov/meucdrom add
</example>
<p>

Você ainda pode identificar o CDROM apenas, sem adicioná-lo:

<p>
<example>
# apt-cdrom ident
</example>
<p>

Note que esse programa só funciona caso seu CDROM esteja bem
configurado em seu <tt>/etc/fstab</tt>.
</sect>

</chapt>


<chapt id="apt-get">Gerenciando pacotes
<sect id="update">Atualizando a lista de pacotes disponíveis
<p>
O sistema de empacotamento usa um banco de dados próprio para saber
quais pacotes estão instalados, quais não estão e quais estão disponíveis
para instalação. O apt-get usa esse banco de dados para saber instalar
os pacotes solicitados pelo usuário e para saber quais pacotes são necessários
para que o pacote selecionado rode perfeitamente.
<p>
Para atualizar essa lista, você usa o comando <prgn>apt-get update</prgn>.
Ele procura pelas listas de pacotes nos repositórios indicados no seu
arquivo <tt>/etc/apt/sources.list</tt>, veja <ref id="sources.list"> para
maiores informações sobre esse arquivo.
<p>
É útil executar esse comando regularmente para saber de possíveis 
atualizações nos pacotes, principalmente de segurança.
</sect>

<sect id="install">Instalando pacotes
<p>
Finalmente um dos processos mais esperados! Com sua sources.list preparada
e a lista de pacotes disponíveis, basta rodar o <tt>apt-get</tt> para ter
seu pacote instalado. Por exemplo você pode fazer:

<p>
<example>
# apt-get install xchat
</example>
<p>

O APT vai buscar então em seu banco de dados a versão mais nova desse pacote
e vai baixá-la do repositório correspondente na <tt>sources.list</tt>. Caso
esse pacote dependa de algum outro -- o que é o caso aqui -- o APT irá
conferir as dependências e instalar os pacotes necessários. Veja esse 
exemplo:

<p>
<example>
# apt-get install nautilus
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 0 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 17.2MB will be used.
Do you want to continue? [Y/n] 
</example>
<p>

O pacote <package>nautilus</package> depende das bibliotecas compartilhadas
citadas, portanto, o APT as vai buscar no repositório. Se você tivesse 
especificado os nomes dessas bibliotecas na linha de comando do 
<tt>apt-get</tt>, o APT não teria perguntado se devia continuar ou não,
ele tomaria como certo o seu desejo em instalar todos aqueles pacotes.
<p>
Isso significa que o APT só pede confirmação quando precisar instalar pacotes
além daqueles que foram solicitados para suprir uma dependência.
<p>
As seguintes opções podem ser de utilidade:

<p>
<example>
-h - ajuda
-d - baixar arquivos apenas, não instalar
-f - conserta erros de instalações de pacotes
-s - não agir, apenas simular operação
-y - assume `sim' para todas as perguntas
-u - mostrar pacotes que serão atualizados também
</example>
<p>

Múltiplos pacotes podem ser solicitados em uma única linha de
comando. Os arquivos baixados da rede são colocados no diretório
<tt>/var/cache/apt/archives</tt> para serem instalados depois.
<p>
Você pode especificar pacotes para remoção na mesma linha de comando.
Para isso, basta colocar um '-' logo depois do nome do pacote a ser
removido, assim:

<p>
<example>
# apt-get install nautilus gnome-panel-       
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n] 
</example>
<p>

Veja a seção <ref id="remove"> para maiores detalhes sobre a remoção
de pacotes.
<p>
Caso você de alguma forma danifique a instalação de um pacote, ou simplesmente
deseja que os arquivos do pacote sejam repostos com a versão mais nova que
estiver disponível, você pode usar a opção <tt>--reinstall</tt> assim:

<p>
<example>
# apt-get --reinstall install gdm
Reading Package Lists... Done
Building Dependency Tree... Done
0 packages upgraded, 0 newly installed, 1 reinstalled, 0 to remove and 1  not upgraded.
Need to get 0B/182kB of archives. After unpacking 0B will be used.
Do you want to continue? [Y/n]
</example>
<p>

O APT usado na produção desse manual é a versão 0.5.3, atual
do Debian `unstable' (<tt>sid</tt>). Essa versão conta com uma função 
especial: você pode usar algo do tipo <tt>apt-get install pacote/distribuição</tt>
para instalar o pacote de uma distribuição específica ou 
<tt>apt-get install pacote=versão</tt>. Por exemplo:

<p>
<example>
# apt-get install nautilus/unstable
</example>
<p>

irá instalar o pacote nautilus da distribuição `unstable' mesmo que
você esteja rodando a `stable'. Os nomes aceitos para `distribuição'
são: <tt>stable</tt>, <tt>testing</tt>, <tt>unstable</tt>.
<p>
Note, porém, que o mais correto para selecionar a distribuição é usar
a opção <tt>-t</tt>, que irá buscar as dependências da distribuição
especificada e não só o pacote.
<p>
<em>IMPORTANTE</em>: a versão `unstable' do Debian é a versão na qual
as últimas versões dos pacotes Debian entram. Essa distribuição recebe
todas as mudanças pelas quais os pacotes passam, desde as pequenas até
as drásticas, que afetam muitos pacotes ou todo o sistema. Por essa
razão, essa versão <em>não</em> deve ser usada por usuários inexperientes
ou que precisem de estabilidade à toda prova. 
<p>
A versão `testing' é um pouco melhor que a `unstable' em relação a
estabilidade mas para sistemas de produção deve-se usar a distribuição
estável.
</sect>

<sect id="remove">Removendo pacotes
<p>
Caso você não esteja mais querendo usar um pacote, você pode removê-lo
do seu sistema usando o APT. Para isso basta usar: <tt>apt-get remove
pacote</tt>. Por exemplo:

<p>
<example>
# apt-get remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n] 
</example>
<p>

Como você pode observar no exemplo acima, o APT cuida também de retirar
os pacotes que dependem do pacote sendo removido. Não há como remover
pacotes sem remover os que são dependentes dele.
<p>
Rodando o <prgn>apt-get</prgn> como acima vai levar à remoção dos
pacotes, mas seus arquivos de configuração, caso existam, permanecerão
intactos. Para uma remoção completa, faça:

<p>
<example>
# apt-get --purge remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n] 
</example>
<p>

Note os '*' na frente dos nomes. Eles indicam que os arquivos de
configuração serão removidos.
<p>
Assim como no caso do método <tt>install</tt>, você pode usar um sinal
gráfico para fazer o processo inverso. No caso da remoção, se você
adicionar um sinal <tt>'+'</tt> logo depois do nome do pacote, ao invés
de removido ele será instalado. Exemplo:

<p>
<example>
# apt-get --purge remove gnome-panel nautilus+
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n] 
</example>
<p>

Note que o <prgn>apt-get</prgn> informa os pacotes extras que serão
instalados, ou seja, os pacotes cuja instalação será necessária ao
funcionamento do pacote cuja instalação foi solicitada, os que serão 
removidos e os que serão instalados (incluindo novamente os extras).
</sect>

<sect id="upgrade">Atualizando os pacotes
<p>
A atualização de pacotes é um grande trunfo do sistema APT. Ela é
feita com um simples comando: <tt>apt-get upgrade</tt>. Você pode
atualizar tanto pacotes dentro de uma mesma distribuição quanto
atualizar para uma nova distribuição, mas, para essa última, o comando
<tt>apt-get dist-upgrade</tt> é melhor, consulte a seção <ref id="dist-upgrade">
para maiores detalhes.
<p>
É útil usar sempre a opção <tt>-u</tt> para esse comando. Essa opção
faz com que o APT mostre os pacotes que serão atualizados. Sem ela
você vai fazer uma atualização no escuro. O APT irá baixar as últimas 
versões de cada pacote e as instalará numa ordem coerente. É sempre 
importante rodar o <tt>apt-get update</tt> antes. Veja a seção 
<ref id="update">. Veja esse exemplo:

<p>
<example>
# apt-get -u upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages have been kept back
  cpp gcc lilo 
The following packages will be upgraded
  adduser ae apt autoconf debhelper dpkg-dev esound esound-common ftp indent
  ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0 libesd0-dev
  libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev liborbit0
  libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit procps psmisc 
29 packages upgraded, 0 newly installed, 0 to remove and 3 not upgraded.
Need to get 5055B/5055kB of archives. After unpacking 1161kB will be used.
Do you want to continue? [Y/n] 
</example>
<p>

Esse processo é muito simples. Repare que logo no início, o
<tt>apt-get</tt> diz que alguns pacotes foram <tt>kept back</tt>.
Isso significa que eles têm novas versões que não serão instaladas
por algum motivo. Alguns deles são: dependências quebradas (um pacote
do qual ele depende não tem uma versão disponível para ser baixada),
novas dependências (o pacote passou a depender de novos pacotes desde
a última versão). 
<p>
O primeiro motivo não tem solução limpa, para o segundo basta rodar um 
<tt>apt-get install</tt> específico para o pacote, que baixará suas dependências.
Outra solução, ainda mais limpa, é usar o <tt>dist-upgrade</tt>. Veja
seção <ref id="dist-upgrade">.
</sect>

<sect id="dist-upgrade">Atualizando para uma nova distribuição
<p>
Essa característica do APT serve para atualizar uma distribuição inteira
de uma única tacada, através da internet ou de um novo CD adquirido, ou
uma ISO baixada.
<p>
Ela é usada também quando mudanças são feitas na interrelação de pacotes
já instalados que devem ser atualizados mas são mantidos inalterados
(<tt>kept back</tt>).
<p>
Por exemplo, supondo que você está usando a versão estável do Debian
revisão 0 e compre o CD com a revisão 3, você pode usar o APT para
atualizar seu sistema a partir desse novo CD. Para isso use o
<prgn>apt-cdrom</prgn> (veja seção <ref id="cdrom">) para adicionar
o CD ao seu arquivo <tt>/etc/apt/sources.list</tt> e rode o 
<tt>apt-get dist-upgrade</tt>.
<p>
É importante notar que o APT sempre busca as versões mais novas dos
pacotes. Portanto, se seu arquivo <tt>/etc/apt/sources.list</tt>
estiver listando um repositório que tenha uma versão mais nova de 
determinado pacote que contém o CD, ele tenderá a buscá-lo de lá.
<p>
No exemplo mostrado na seção <ref id="upgrade">, vimos que alguns
pacotes ficaram <tt>"kept back"</tt>, vamos solucionar isso agora,
com o método <tt>dist-upgrade</tt>:

<p>
<example>
# apt-get -u dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following NEW packages will be installed:
  cpp-2.95 cron exim gcc-2.95 libident libopenldap-runtime libopenldap1
  libpcre2 logrotate mailx 
The following packages have been kept back
  lilo 
The following packages will be upgraded
  adduser ae apt autoconf cpp debhelper dpkg-dev esound esound-common ftp gcc
  indent ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0
  libesd0-dev libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev
  liborbit0 libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit
  procps psmisc 
31 packages upgraded, 10 newly installed, 0 to remove and 1 not upgraded.
Need to get 0B/7098kB of archives. After unpacking 3118kB will be used.
Do you want to continue? [Y/n]
</example>
<p>

Note agora que os pacotes serão atualizados, mas novos pacotes serão 
instalados (as novas dependências dos pacotes). E que o lilo continua
<tt>kept back</tt>. Ele provavelmente tem algum problema mais sério, que
não uma nova dependência. Podemos conferir isso rodando:

<p>
<example>
# apt-get -u install lilo
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be REMOVED:
  debconf-tiny 
The following NEW packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be upgraded
  lilo 
1 packages upgraded, 9 newly installed, 1 to remove and 31 not upgraded.
Need to get 225kB/1179kB of archives. After unpacking 2659kB will be used.
Do you want to continue? [Y/n]
</example>
<p>

Como notamos na saída acima, o lilo tinha um novo conflito com o
pacote <package>debconf-tiny</package>, ou seja, não podia ser
instalado (isso também implica na atualização) sem que o debconf-tiny
fosse removido.
<p>
Uma maneira de saber especificamente o que leva um pacote a ser
mantido ou removido é:

<p>
<example>
# apt-get -o Debug::pkgProblemResolver=yes dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Starting
Starting 2
Investigating python1.5
Package python1.5 has broken dep on python1.5-base
  Considering python1.5-base 0 as a solution to python1.5 0
  Holding Back python1.5 rather than change python1.5-base
Investigating python1.5-dev
Package python1.5-dev has broken dep on python1.5
  Considering python1.5 0 as a solution to python1.5-dev 0
  Holding Back python1.5-dev rather than change python1.5
 Try to Re-Instate python1.5-dev
Done
Done
The following packages have been kept back
  gs python1.5-dev 
0 packages upgraded, 0 newly installed, 0 to remove and 2  not upgraded.
</example>
<p>

Assim fica fácil perceber que o pacote python1.5-dev não pode ser
instalado por culpa de uma dependência não satisfeita: python1.5

</sect>

<sect id="clean">Removendo pacotes que não serão mais usados: apt-get clean e autoclean
<p>
Quando você instala um pacote o APT busca das fontes listadas em
/etc/apt/sources.list os arquivos necessários e os guarda em um
repositório local (<file>/var/cache/apt/archives/</file>), e
então faz a instalação, veja <ref id="install">.
<p>
Em algum tempo o repositório local pode crescer e ocupar muito
espaço em disco. Felizmente o APT fornece ferramentas para
lidar com seu repositório local: os métodos <tt>clean</tt>
e <tt>autoclean</tt> do <prgn>apt-get</prgn>.
<p>
O <prgn>apt-get clean</prgn> remove tudo exceto os arquivos de
lock dos diretórios <file>/var/cache/apt/archives/</file> e
<file>/var/cache/apt/archives/partial/</file>. Assim, se
você precisar reinstalar um pacote o APT irá buscá-lo novamente.
<p>
O <prgn>apt-get autoclean</prgn> remove apenas os arquivos de
pacotes que não possam mais ser baixados.
<p>
O exemplo a seguir mostra como o apt-get autoclean funciona:

<p>
<example>
# ls /var/cache/apt/archives/logrotate* /var/cache/apt/archives/gpm*
logrotate_3.5.9-7_i386.deb
logrotate_3.5.9-8_i386.deb
gpm_1.19.6-11_i386.deb
</example>
<p>

Em /var/cache/apt/archives há dois arquivos para o pacote
<package>logrotate</package> e um para o pacote 
<package>gpm</package>.

<p>
<example>
# apt-show-versions -p logrotate
logrotate/stable uptodate 3.5.9-8
# apt-show-versions -p gpm
gpm/stable upgradeable from 1.19.6-11 to 1.19.6-12
</example>
<p>

O <prgn>apt-show-versions</prgn> mostra que o arquivo
<file>logrotate_3.5.9-8_i386.deb</file> é a última versão
disponível do pacote <package>logrotate</package>, então o
<file>logrotate_3.5.9-7_i386.deb</file> é inútil. O arquivo
<file>gpm_1.19.6-11_i386.deb</file> também é inútil, já que
uma versão mais nova do pacote pode ser baixada.

<p>
<example>
# apt-get autoclean
Reading Package Lists... Done
Building Dependency Tree... Done
Del gpm 1.19.6-11 [145kB]
Del logrotate 3.5.9-7 [26.5kB]
</example>
<p>

Finalmente, o <tt>apt-get autoclean</tt> remove apenas os
arquivos velhos. Veja <ref id="apt-show-versions"> para obter
mais informações sobre o apt-show-versions.
</sect>

<sect id="dselect-upgrade">Usando em conjunto com o Dselect
<p>
O <prgn>dselect</prgn> é um programa que ajuda na seleção
de pacotes do Debian. Ele é considerado meio complicado e
chato de se lidar, mas com alguma prática, sua interface 
ncurses, de console, se torna usual.
<p>
Uma de suas qualidades é que ele "sabe" como explorar a capacidade
de os pacotes "recomendarem" e "sugerirem" a instalação de outros
pacotes. Para usá-lo, rode <tt>`dselect'</tt> como root. Selecione
como método de acesso o apt. Isso não é realmente necessário mas,
caso você não esteja usando um CDROM e quiser usar a internet é o 
melhor jeito de usar o dselect.
<p>
Para entender melhor como usar o dselect, leia a documentação do
dselect que se encontra na página do Debian 
<url id="http://www.debian.org/doc/ddp" name="http://www.debian.org/doc/ddp">
ou sua versão em português, encontrada na página do Debian-BR
<url id="http://debian-br.cipsga.org.br/suporte/documentacao.html" 
name="http://debian-br.cipsga.org.br/suporte/documentacao.html">.
<p>
Depois de feitas as seleções adequadas no dselect, use:

<p>
<example>
# apt-get -u dselect-upgrade
</example>
<p>

Veja esse exemplo:

<p>
<example>
# apt-get -u dselect-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  lbxproxy 
The following NEW packages will be installed:
  bonobo console-tools-libs cpp-3.0 enscript expat fingerd gcc-3.0
  gcc-3.0-base icepref klogd libdigest-md5-perl libfnlib0 libft-perl
  libgc5-dev libgcc300 libhtml-clean-perl libltdl0-dev libsasl-modules
  libstdc++3.0 metamail nethack proftpd-doc psfontmgr python-newt talk tidy
  util-linux-locales vacation xbill xplanet-images 
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 30 newly installed, 1 to remove and 0  not upgraded.
Need to get 7140kB of archives. After unpacking 16.3MB will be used.
Do you want to continue? [Y/n]
</example>
<p>

Veja, no mesmo sistema, se eu rodar apt-get dist-upgrade o que eu
tenho:

<p>
<example>
# apt-get -u dist-upgrade   
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 0 newly installed, 0 to remove and 0  not upgraded.
Need to get 421kB of archives. After unpacking 25.6kB will be freed.
Do you want to continue? [Y/n]
</example>
<p>

Note que muitos dos pacotes do de cima estão sendo instalados porque
outros pacotes os "sugerem" ou "recomendam". Outros deles estão sendo
instalados ou removidos (no caso do lbxproxy por exemplo) por escolha
minha, durante minha navegação pela lista de pacotes do dselect. O dselect 
pode ser uma poderosa ferramenta usada em conjunto com o APT.
</sect>

<sect id="default-version">Como manter um sistema misto
<p>
As pessoas têm o interesse, normalmente, de usar o Debian testing,
por ele ser mais estável que o unstable e mais atualizado que o
stable. Mas você pode ter um sistema Testing e usar alguns pacotes
do unstable.
<p>
Para isso, coloque a seguinte linha no <file>/etc/apt/apt.conf</file>:

<p>
<example>
APT::Default-Release "testing";
</example>
<p>

<p>
E quando for instalar um pacote da unstable, basta passar a opção
<tt>-t</tt>:

<p>
<example>
# apt-get -t unstable install <var>nomedopacote</var>
</example>
<p>

<p>
Não se esqueça de que para usar pacotes de uma versão
do Debian é necessário ter uma linha da mesma no
seu <file>/etc/apt/source.list</file>. No caso do
nosso exemplo, além da linha da distribuição 
<tt>testing</tt>, que é a principal, precisamos de
linhas para a distribuição <tt>unstable</tt>.

</sect>

<sect id="apt-show-versions">Como atualizar os pacotes de versões específicas do Debian
<p>
Você usa uma distribuição mixada e agora quer atualizar os
pacotes de uma dela. O <prgn>apt-show-versions</prgn> entra
aqui. Você pode usar uma linha como a seguinte para atingir
esse objetivo:
<p>
<example>
# apt-get install `apt-show-versions -u -b | grep unstable`
</example>
<p>
</sect>

<sect id="pin">Como manter versões específicas de pacotes instaladas (complexo)
<p>
Algumas vezes você fez uma modificação em um programa e não tem tempo
ou vontade de portar aquelas mudanças para um versão nova do programa.
Então você "prega" a versão que você tem instalada para que não seja
feita a atualização. Ou você acaba de atualizar sua distribuição Debian
para a 3.0 mas quer continuar com um certo pacote da 2.2.
<p>
É para esse propósito que serve o "pinning". A utilização desse recurso
é simples. Basta editar o arquivo <tt>/etc/apt/preferences</tt>.
<p>
O formato é simples:
<p>
<example>
Package: &lt;pacote&gt;
Pin: &lt;definição do pin&gt;
Priority: &lt;prioridade do pin&gt;
</example>
<p>
Por exemplo, para manter o pacote <package>sylpheed</package> que eu
modifiquei para aceitar "responder para a lista" na versão 0.4.99, eu adiciono:
<p>
<example>
Package: sylpheed
Pin: version 0.4.99*
</example>
<p>
Note que eu usei um <tt>*</tt> (asterisco). Isso serve para dizer
que quero que esse "pin" sirva para todas as versões que comecem
com 0.4.99. Isso porque o Debian versiona seus pacotes com uma
"revisão Debian" e eu não quero impedir essas revisões de entrar.
Ou seja, as versões 0.4.99-1 e 0.4.99-10 seriam instaladas a partir
do momento em que existissem. Se você modificou uma versão do pacote
você não vai querer que isso aconteça assim, no entanto.
<p>
Note também que eu não dei prioridade ao Pin. A prioridade foi
auto-definida como 989. Vamos entender melhor o que é a prioridade:
<p>
Uma prioridade menor que 0 faz com que o pacote definido para o
Pin nunca seja instalado. As prioridades 0 a 100 definem pacotes
não instalados e que não têm versões disponíveis então não entram
no processo de escolha de versão. A prioridade 100 é a prioridade
que o pacote atualmente instalado tem - isso significa que para
que uma versão diferente seja instalada ela precisa ter mais de
100 na prioridade.
<p>
Prioridades até 1000 são prioridades que permitem que o pacote seja
instalado. No entanto, um pacote com uma versão mais baixa não
será instalado com esta prioridade em cima de uma versão mais nova
que já está instalado. Ou seja: se eu tenho sylpheed 0.5.3 instalado
e defino um Pin para sylpheed 0.4.99 com prioridade 999, o pacote 0.4.99
<em>não</em> será instalado para conformar com o Pin. Para que um
pacote possa se "desatualizar" para cumprir a determinação de um Pin
ele precisa ter prioridade maior que 1000.
<p>
As opções para o pin podem ser: <tt>version</tt>, <tt>release</tt>
ou <tt>origin</tt>.
<p>
A opção <tt>version</tt>, como já vimos, suporta uma versão normal
e uma máscara (como um asterisco, por exemplo) para definir várias
verões de uma vez.
<p>
A opção <tt>release</tt> é mais ampla e depende do arquivo Release
do repositório APT, ou do CD. Esta opção pode deixar a desejar pois
alguns repositórios não o contém. Você pode ver o conteúdo dos 
arquivos Release que você tem em <tt>/var/lib/apt/lists/</tt>. As
sub-opções são: a (archive), c (componente), v (versão), o (origin)
e l (label).
<p>
Um exemplo:
<p>
<example>
Package: *
Pin: release v=2.2*,a=stable,c=main,o=Debian,l=Debian
Priority: 1001
</example>
<p>
Neste exemplo escolhemos versão do Debian 2.2*, que considera as
"revisões" (que vêm com consertos de segurança e bugs sérios), 
repositório <tt>stable</tt>, seção <tt>main</tt>
(poderia ser contrib e non-free, por exemplo) e origem e nome
Debian. Origem (o=) define quem produziu aquele arquivo Release,
o nome (l=) define o nome da distribuição: Debian para o próprio
Debian e Progeny para a mesma, por exemplo. Um exemplo de
arquivo Release:
<p>
<example>
$ cat /var/lib/apt/lists/ftp.debian.org.br_debian_dists_potato_main_binary-i386_Release 
Archive: stable
Version: 2.2r3
Component: main
Origin: Debian
Label: Debian
Architecture: i386
</example>
<p>
</sect>
</chapt>

<chapt id="helpers">Ajudantes muito úteis
<sect id="equivs">Como instalar programas compilados localmente: equivs
<p>
As vezes as pessoas querem usar uma versão específica para um
programa, uma versão mais nova, só disponível em fontes, sem
pacote Debian. Mas o sistema de empacotamento pode atrapalhar
esses planos. Suponha que você quer compilar uma nova versão do
seu servidor de email. Tudo vai bem, mas inúmeros pacotes no
Debian dependem de um MTA (Mail Transport Agent) instalado. 
Como você instalou algo que você mesmo compilou, o sistema de 
pacotes não sabe da presença dele.
<p>
É aí que entra o <package>equivs</package>. Para usá-lo instale
o pacote de mesmo nome. O que ele faz é criar um pacote vazio
que possa cumprir as dependências, fazendo o sistema de gerenciamento
de pacotes achar que as dependências estão cumpridas.
<p>
Antes de continuarmos, é bom lembrar que há maneiras mais seguras
de se compilar um programa que já está debianizado com opções
alteradas, e que não se deve usar o equivs para substituir
dependências se você não souber realmente o que está fazendo.
Veja a seção <ref id="sourcehandling"> para saber mais.
<p>
Vamos continuar com o exemplo do MTA, você acaba de instalar
seu novo <prgn>postfix</prgn> compilado e parte para a instalação do 
<package>mutt</package>. Qual não é sua surpresa quando descobre
que o <package>mutt</package> quer instalar um outro MTA, mas
você já tem o seu.
<p>
Vá para um diretório qualquer (<file>/tmp</file>, por exemplo)
e execute:

<p>
<example>
# equivs-control <var>nome</var>
</example>
<p>

Substitua <var>nome</var> pelo nome do arquivo de controle que você
quer criar. O arquivo vai ser criado da seguinte forma:

<p>
<example>
Section: misc
Priority: optional
Standards-Version: 3.0.1

Package: &lt;enter package name; defaults to equivs-dummy&gt;
Version: &lt;enter version here; defaults to 1.0&gt;
Maintainer: &lt;your name and email address; defaults to username&gt;
Pre-Depends: &lt;packages&gt;
Depends: &lt;packages&gt;
Recommends: &lt;packages&gt;
Suggests: &lt;package&gt;
Provides: &lt;(virtual)package&gt;
Architecture: all
Copyright: &lt;copyright file; defaults to GPL2&gt;
Changelog: &lt;changelog file; defaults to a generic changelog&gt;
Readme: &lt;README.Debian file; defaults to a generic one&gt;
Extra-Files: &lt;additional files for the doc directory, commaseperated&gt;
Description: &lt;short description; defaults to some wise words&gt;
 long description and info
 .
 second paragraph
</example>
<p>

Basta alterar isso agora para que o que queremos seja feito.
Observe bem o formato dos campos e as descrições deles,
não há necessidade aqui de discorrer sobre cada um desses,
vamos ao que é necessário:

<p>
<example>
Section: misc
Priority: optional
Standards-Version: 3.0.1

Package: mta-local
Provides: mail-transport-agent
</example>
<p>

Sim, é só isso. O <package>mutt</package> depende de
<tt>mail-transport-agent</tt>, que é um pacote virtual
fornecido por todos os MTAs, eu poderia simplesmente
chamar o pacote de <tt>mail-transport-agent</tt>, também,
mas preferi usar o esquema do pacote virtual,usando o 
Provides.
<p>
Agora basta construir o pacote:

<p>
<example>
# equivs-build <var>nome</var>
dh_testdir
touch build-stamp
dh_testdir
dh_testroot
dh_clean -k
# Add here commands to install the package into debian/tmp.
touch install-stamp
dh_testdir
dh_testroot
dh_installdocs
dh_installchangelogs
dh_compress
dh_fixperms
dh_installdeb
dh_gencontrol
dh_md5sums
dh_builddeb
dpkg-deb: building package `<var>nome</var>' in `../<var>nome</var>_1.0_all.deb'.

The package has been created.
Attention, the package has been created in the current directory,
</example>
<p>

E instalar o <tt>.deb</tt> resultante.
<p>
Como se pode ver, há inúmeras utilidades para o <prgn>equivs</prgn>.
Inclusive criar um pacote <tt>meus-preferidos</tt>, que dependa dos
programas que você sempre instala, por exemplo. É soltar a imaginação,
mas com cuidado.
<p>
É importante notar que há exemplos de arquivos de controle em
<file>/usr/share/doc/equivs/examples</file>. Confira.
</sect>

<sect id="localepurge">Removendo arquivos de locale não usados: localepurge
<p>
Muitos usuários de Debian usam apenas um locale. Um usuário de
Debian brasileiro, por exemplo, normalmente usa o locale
<tt>pt_BR</tt> o tempo todo e não se importa com o <tt>es</tt>.
<p>
O <package>localepurge</package> é uma ferramenta muito útil
para esses usuários. Você pode liberar muito espaço tendo apenas
os locales que você realmente usa. Basta usar 
<tt>apt-get install localepurge</tt>.
<p>
É muito fácil configurá-lo, perguntas feitas com o debconf guiam
o usuário em uma configuração passo-a-passo. Seja cuidadoso ao
responder a primeira questão; respostas erradas podem remover
todos os arquivos de locale, mesmo aqueles que você usa. A única
maneira de recuperá-los será reinstalar todos os pacotes que
os fornecem.
</sect>

<sect id="helper-show-versions">Como saber quais pacotes podem ser atualizados
<p>
O <prgn>apt-show-versions</prgn> é um programa que mostra quais
pacotes do seu sistema podem ser atualizados e várias outras
informações úteis. Para saber quais pacotes podem ser atualizados
faça:

<p>
<example>
$ apt-show-versions -u    
libeel0/unstable upgradeable from 1.0.2-5 to 1.0.2-7
libeel-data/unstable upgradeable from 1.0.2-5 to 1.0.2-7
</example>
<p>
</sect>

</chapt>

<chapt id="search">Obtendo informações sobre os pacotes.
<p>
Existem alguns programas, conhecidos como <tt>front-ends</tt>
para o sistema APT que facilitam em muito a listagem dos pacotes
disponíveis para instalação, os instalados, em quais seções se
encontram, quais suas prioridades, descrições, etc.
<p>
Mas... nossa intenção aqui é aprender a usar o APT puro. 
Então o que fazer para descobrir o nome do pacote que você
pode querer a vir instalar?
<p>
Para isso temos uma série de recursos. Vamos começar com o 
<tt>apt-cache</tt>. Esse programa é usado pelo sistema
APT para manter seu banco de dados. Nós vamos entrar apenas
nos aspectos práticos dele.

<sect id="cache">Descobrindo nome dos pacotes
<p>
Por exemplo, suponha que você está com vontade de relembrar 
os bons tempos do atari 2600. Você quer usar o APT para instalar
um emulador de atari e depois baixar alguns jogos. Você pode fazer:

<p>
<example>
# apt-cache search atari
atari-fdisk-cross - Partition editor for Atari (running on non-Atari)
circuslinux - The clowns are trying to pop balloons to score points!
madbomber - A Kaboom! clone
tcs - Character set translator.
atari800 - Atari emulator for svgalib/X/curses
stella - Atari 2600 Emulator for X windows
xmess-x - X binaries for Multi-Emulator Super System
</example>
<p>

Achamos então vários pacotes relacionados ao que queremos e breves 
descrições. Para ter mais informações sobre um pacote, posso, então,
usar:

<p>
<example>
# apt-cache show stella  
Package: stella
Priority: extra
Section: non-free/otherosfs
Installed-Size: 830
Maintainer: Tom Lear &lt;tom@trap.mtview.ca.us&gt;
Architecture: i386
Version: 1.1-2
Depends: libc6 (&gt;= 2.1), libstdc++2.10, xlib6g (&gt;= 3.3.5-1)
Filename: dists/potato/non-free/binary-i386/otherosfs/stella_1.1-2.deb
Size: 483430
MD5sum: 11b3e86a41a60fa1c4b334dd96c1d4b5
Description: Atari 2600 Emulator for X windows
 Stella is a portable emulator of the old Atari 2600 video-game console
 written in C++.  You can play most Atari 2600 games with it.  The latest
 news, code and binaries for Stella can be found at:
 http://www4.ncsu.edu/~bwmott/2600
</example>
<p>

Nessa saída você tem inúmeras informações sobre o pacote que
quer instalar (ou não) e a sua descrição completa. No caso de
o pacote já estar instalado em seu sistema e haver uma versão
mais nova, você verá informações sobre ambos. Por exemplo:

<p>
<example>
# apt-cache show lilo
Package: lilo
Priority: important
Section: base
Installed-Size: 271
Maintainer: Russell Coker &lt;russell@coker.com.au&gt;
Architecture: i386
Version: 1:21.7-3
Depends: libc6 (&gt;= 2.2.1-2), debconf (&gt;=0.2.26), logrotate
Suggests: lilo-doc
Conflicts: manpages (&lt;&lt;1.29-3)
Filename: pool/main/l/lilo/lilo_21.7-3_i386.deb
Size: 143052
MD5sum: 63fe29b5317fe34ed8ec3ae955f8270e
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.

Package: lilo
Status: install ok installed
Priority: important
Section: base
Installed-Size: 190
Maintainer: Vincent Renardias &lt;vincent@debian.org&gt;
Version: 1:21.4.3-2
Depends: libc6 (&gt;= 2.1.2)
Recommends: mbr
Suggests: lilo-doc
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.
</example>
<p>

Note, que a primeira a ser listada é a disponível e a segunda, a
que já se encontra instalada. Para uma informação mais geral sobre
o pacote, você usa:

<p>
<example>
# apt-cache showpkg penguin-command
Package: penguin-command
Versions: 
1.4.5-1(/var/lib/apt/lists/download.sourceforge.net_debian_dists_unstable_main_binary-i386_Packages)(/var/lib/dpkg/status)

Reverse Depends: 
Dependencies: 
1.4.5-1 - libc6 (2 2.2.1-2) libpng2 (0 (null)) libsdl-mixer1.1 (2 1.1.0) libsdl1.1 (0 (null)) zlib1g (2 1:1.1.3) 
Provides: 
1.4.5-1 - 
Reverse Provides: 
</example>
<p>

Para saber de quais pacotes ele depende, apenas:

<p>
<example>
# apt-cache depends penguin-command
penguin-command
  Depends: libc6
  Depends: libpng2
  Depends: libsdl-mixer1.1
  Depends: libsdl1.1
  Depends: zlib1g
</example>
<p>

Resumindo, temos um bom arsenal para encontrarmos o nome do pacote que
queremos.
</sect>

<sect id="dpkg-search">Usando o dpkg para achar nomes de pacotes
<p>
Uma das maneiras de localizar o nome de um pacote é saber o nome
de um arquivo importante que está nesse pacote. Por exemplo, para
achar o pacote ao qual pertence um arquivo <tt>".h"</tt> necessário
a uma compilação você pode fazer:

<p>
<example>
# dpkg -S stdio.h
libc6-dev: /usr/include/stdio.h
libc6-dev: /usr/include/bits/stdio.h
perl: /usr/lib/perl/5.6.0/CORE/nostdio.h

ou:

# dpkg -S /usr/include/stdio.h
libc6-dev: /usr/include/stdio.h
</example>
<p>

Para saber o nome de pacotes instalados no seu sistema, para uma
possível limpeza, por exemplo, você pode usar:

<p>
<example>
# dpkg -l | grep mozilla
ii  mozilla-browse 0.9.6-7        Mozilla Web Browser
</example>
<p>

O problema com esse comando é que ele pode "quebrar" o nome do pacote.
No exemplo acima o nome todo do pacote é <tt>mozilla-browser</tt>. Para
dar um jeito nisso, você pode usar a variável de ambiente <tt>COLUMNS</tt>,
assim, por exemplo:

<p>
<example>
$ COLUMNS=132 dpkg -l | grep mozilla
ii  mozilla-browser             0.9.6-7                     Mozilla Web Browser - core and browser
</example>
<p>

ou usar a descrição assim:

<p>
<example>
# apt-cache search "Mozilla Web Browser"
mozilla-browser - Mozilla Web Browser
</example>
<p>
</sect>

<sect id="auto-apt">Como instalar pacotes "on demand"
<p>
Você está compilando um programa e, de repente, boom! Há um erro
porque falta um arquivo <tt>.h</tt> que você não tem. O <prgn>auto-apt</prgn>
pode te salvar de coisas assim. Ele pede para instalar os pacotes caso 
sejam necessários pausando o processo dependente e depois de instalado
o pacote, continuando.
<p>
O que você faz, basicamente, é executar: 

<p>
<example>
# auto-apt run comando
</example>
<p>

Onde `comando' é o comando a ser executado que pode vir a precisar
de um arquivo qualquer. Por exemplo: 

<p>
<example>
# auto-apt run ./configure
</example>
<p>

Ele irá então pedir para instalar os pacotes necessários e irá 
chamar o apt-get automaticamente. Caso você esteja no X, uma
interface gráfica substituirá a interface de texto padrão.
<p>
O auto-apt mantém bancos de dados que devem ser atualizados para
que ele tenha real eficácia, isso é feito chamando os comandos 
<tt>auto-apt update</tt>, <tt>auto-apt updatedb</tt> e 
<tt>auto-apt update-local</tt>.
</sect>

<sect id="apt-file">Como descobrir a qual pacote um arquivo pertence
<p>
Se você quer instalar um pacote e não consegue achar o seu nome
usando o <prgn>apt-cache</prgn> mas sabe o nome do arquivo do programa
ou de algum outro arquivo que pertence ao pacote pode usar o
<prgn>apt-file</prgn> para encontrar o nome do pacote. Isso é feito
assim:

<p>
<example>
$ apt-file search <var>nomedoarquivo</var>
</example>
<p>

Ele funciona do mesmo jeito que o <tt>dpkg -S</tt>, mas também mostra
os pacotes não instalados que contêm o arquivo. Ele poderia também
ser usado para encontrar que pacotes contêm arquivos include necessários
para uma compilação, apesar de o <prgn>auto-apt</prgn> ser um método
muito melhor para resolver tais problemas, veja <ref id="auto-apt">.
<p>
Você pode também listar o conteúdo de um pacote rodando:

<p>
<example>
$ apt-file list <var>nomedopacote</var>
</example>
<p>

O <prgn>apt-file</prgn> mantém uma base de dados de quais arquivos
cada pacote contém, assim como o auto-apt e essa base precisa estar
atualizada. Isso é feito rodando:

<p>
<example>
# apt-file update
</example>
<p>

Por padrão, o <prgn>apt-file</prgn> usa a mesma base de dados que o
<prgn>auto-apt</prgn> está usando, veja <ref id="auto-apt">.

</sect>

<sect id="apt-listchanges">Como manter-se informado das mudanças nos pacotes.
<p>
Todo pacote instala em seu diretório de documentação 
(<tt>/usr/share/doc/nomedopacote</tt>) um arquivo chamado <tt>changelog.Debian.gz</tt>
que contém a lista de mudanças feitas no pacote desde a última versão.
Você pode ler esses arquivos com a ajuda do <tt>zless</tt>, por exemplo,
mas é algo pouco prático acabar de instalar todos os pacotes de uma atualização
completa do sistema e então sair procurando os changelogs deles todos.
<p>
Há um jeito de automatizar essa tarefa por meio da ferramenta chamada
<prgn>apt-listchanges</prgn>. Para começar instala-se o pacote 
<package>apt-listchanges</package>. Durante a instalação do pacote
uma configuração será feita com o Debconf. Responda às perguntas de
acordo com sua vontade.
<p>
A opção "apt-listchanges deve ser chamado automaticamente pelo apt?" é muito
útil pois mostra a lista de mudanças de todos os pacotes que serão instalados
pelo apt durante uma atualização e permite que você as examine antes de 
continuar. A opção "apt-listchanges deve pedir confirmação após mostrar os 
changelogs?" é útil pois pergunta se você deseja continuar com a instalação
depois de ter lido a lista de mudanças. Se você disser que não deseja continuar
o apt-listchanges retorna um erro e o apt aborta a atualização.
<p>
Depois do apt-listchanges instalado, logo depois de ter baixado todos os
arquivos (ou tê-los adquirido de um CD ou disco montado) o apt irá mostrar
as listas de mudanças ocorridas naqueles pacotes antes de iniciar a instalação.
</sect>
</chapt>

<chapt id="sourcehandling">Lidando com pacotes fonte
<sect id="source">Baixando pacotes fonte
<p>
É comum no mundo livre que se estude código fonte ou mesmo que
se faça correções em código fonte com erros. Para isso é
necessário que se baixe o fonte do programa. O sistema APT 
provê uma maneira fácil de se obter os fontes dos vários
programas contidos na distribuição, com, inclusive, os arquivos
necessários para se criar o .deb do programa.
<p>
Outro uso comum dos fontes no Debian é o de adequar uma versão
mais nova de um programa que está na distribuição unstable, 
por exemplo, à estável. Compilar um pacote no stable gera .debs
com dependências ajustadas aos pacotes disponíveis nessa distribuição.
<p>
Para que isso seja feito, a entrada <tt>deb-src</tt> do seu
<tt>/etc/apt/sources.list</tt> deve estar apontando para a 
unstable. E esteja habilitada (descomentada). Veja a seção
<ref id="sources.list">.
<p>
Para baixar um pacote fonte, você usa o seguinte comando:

<p>
<example>
$ apt-get source nomedopacote
</example>
<p>

Ele irá baixar três arquivos. Um <tt>.orig.tar.gz</tt>, um 
<tt>.dsc</tt> e um <tt>.diff.gz</tt>. No caso de pacotes
feitos especificamente para o Debian, o último desses não
é baixado e o primeiro costuma não ter a parte <tt>"orig"</tt>
no nome.
<p>
O arquivo <tt>.dsc</tt> é usado pelo dpkg-source para descompactar
o pacote fonte no diretório <var>nomedopacote-versão</var>. 
Dentro de todo pacote fonte baixado existe o diretorio <tt>debian/</tt>
que contém os arquivos para se criar o pacote .deb.
<p>
Para que o pacote seja auto-construído ao acabar de ser baixado,
basta especificar <tt>-b</tt> na linha de comando, assim:

<p>
<example>
$ apt-get -b source nomedopacote
</example>
<p>

Se você decidir não gerar o .deb logo após o download, você pode
fazê-lo depois rodando: 

<p>
<example>
$ dpkg-buildpackage -rfakeroot -uc -b
</example>

<p>
de dentro do diretório criado para o pacote após o download.
Para instalar um arquivo <tt>.deb</tt> deve-se usar o gerenciador
de pacotes diretamente, da seguinte forma:

<p>
<example>
# dpkg -i <var>arquivo.deb</var>
</example>

<p>
Há uma grande diferença entre o método <tt>source</tt> do 
<prgn>apt-get</prgn> e os outros. Este pode ser usado por usuários
comuns, sem a necessidade de poderes especiais de root. Os 
arquivos são baixados no diretório de onde foi chamado o
comando <tt>apt-get source pacote</tt>.

</sect>

<sect id="build-dep">Pacotes necessários para compilação de um pacote fonte
<p>
Pacotes fontes, normalmente precisam de bibliotecas compartilhadas
e headers específicos para serem compilados. Todo pacote fonte tem
em seus arquivos de controle um campo conhecido como 'Build-Depends:'
que indica quais os pacotes são necessários para se compilar o 
pacote fonte.
<p>
O APT tem uma maneira simples de baixar esses pacotes, basta você 
executar <tt>apt-get build-dep pacote</tt>, onde `pacote' é o nome
do pacote que você vai construir. Por exemplo:

<p>
<example>
# apt-get build-dep gmc
Reading Package Lists... Done
Building Dependency Tree... Done
The following NEW packages will be installed:
  comerr-dev e2fslibs-dev gdk-imlib-dev imlib-progs libgnome-dev libgnorba-dev
  libgpmg1-dev 
0 packages upgraded, 7 newly installed, 0 to remove and 1  not upgraded.
Need to get 1069kB of archives. After unpacking 3514kB will be used.
Do you want to continue? [Y/n]
</example>
<p>

Os pacotes que serão instalados são os pacotes dos quais o programa 
<package>gmc</package> necessita para se construir perfeitamente. 
É importante notar que esse comando não busca o pacote fonte do programa
a ser compilado. Assim, você deve rodar o <tt>apt-get source</tt> separadamente
para obtê-lo.

<p>
Para apenas ver quais pacotes são necessários para a compilação de
determinado pacote existe uma variante do comando 
<tt>apt-cache show</tt> (veja <ref id="search">), que irá mostrar, 
entre outras informações, a linha <tt>Build-Depends</tt> que 
lista esses pacotes:

<p>
<example>
# apt-cache showsrc <var>pacote</var>
</example>

</sect>
</chapt>

<chapt id="erros">Como lidar com erros?
<sect id="erros-comuns">Erros comuns
<p>
Erros sempre acontecem, muitos deles causados por falta de atenção
do usuário. Aqui estou listando alguns dos erros reportados mais
frequentemente e como lidar com eles.
<p>
Caso você receba uma mensagem parecida com a seguinte ao tentar rodar o 
<tt>apt-get install pacote</tt>...

<p>
<example>
Reading Package Lists... Done
Building Dependency Tree... Done
W: Couldn't stat source package list 'http://people.debian.org unstable/ Packages' (/var/state/apt/lists/people.debian.org_%7ekov_debian_unstable_Packages) - stat (2 Arquivo ou diretório não encontrado)
W: You may want to run apt-get update to correct these missing files
E: Couldn't find package penguineyes
</example>
<p>

você se esqueceu de rodar o <tt>apt-get update</tt> depois da sua última
alteração no arquivo <tt>/etc/apt/sources.list</tt>.
<p>
Se o erro for parecido com:

<p>
<example>
E: Could not open lock file /var/lib/dpkg/lock - open (13 Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?
</example>
<p>

ao tentar qualquer dos métods do <prgn>apt-get</prgn> com excessão do
<tt>source</tt>, você não tem permissão root, ou seja, está acessando como
usuário normal.
<p>
Há um erro parecido com o de cima que acontece ao rodar duas instâncias do
<prgn>apt-get</prgn> juntas ou mesmo ao tentar rodar o <prgn>apt-get</prgn>
enquanto há um processo do <prgn>dpkg</prgn> ativo. O único método que pode
rodar simultâneamente com outro é o <tt>source</tt>.
<p>
Caso uma instalação quebre durante o processo e você fique impossibilitado
de instalar e remover pacotes, tente rodar esses dois comandos:

<p>
<example>
# apt-get -f install
# dpkg --configure -a
</example>
<p>

E tente o processo novamente, pode ser preciso rodar o segundo comando 
acima mais vezes. Essa é uma dica importante aos aventureiros que usam
`unstable'.

</sect>

<sect id="help">Onde consigo ajuda?
<p>
Caso alguma dúvida cruel venha à sua cabeça, consulte a extensiva documentação
existente sobre o sistema de empacotamento do Debian. <tt>--help</tt>'s e
manpages podem ser de enorme ajuda para você, assim como a documentação contida
nos diretórios do <tt>/usr/share/doc</tt> como o <tt>apt</tt>. 
<p>
Se mesmo assim a dúvida persistir, consulte as listas do Debian por uma resposta.
Você pode conseguir mais informações sobre a lista específica para usuários
falantes da língua portuguesa em: <url id="http://debian-br.cipsga.org.br"
name="http://debian-br.cipsga.org.br">, o site do projeto Debian-BR.
Outras listas do Debian podem ser encontradas na página do Debian em:
<url id="http://www.debian.org" name="http://www.debian.org">. Uma
boa parte dessa página se encontra traduzida graças ao esforço do Debian-BR.
<p>
Lembre-se de que essas listas e recursos devem ser usados apenas por usuários
do Debian, usuários de outros sistemas devem encontrar um melhor suporte 
junto à suas distribuições.
</sect>
</chapt>

<chapt id="distros">Quais são as distribuições que suportam o APT?
<p>
Aqui estão os nomes de algumas das distribuições que contam com o APT:
<p>
Debian GNU/Linux (<url id="http://www.debian.org" name="http://www.debian.org">) 
- foi para esta distribuição que o APT foi desenvolvido
<p>
Conectiva (<url id="http://www.conectiva.com.br" name="http://www.conectiva.com.br">) 
- essa foi a primeira distribuição a portar esse software para lidar com rpm
<p>
Mandrake (<url id="http://www.mandrake.com" name="http://www.mandrake.com">)
<p>
PLD (<url id="http://www.pld.org.pl" name="http://www.pld.org.pl">)
<p>
Vine (<url id="http://www.vinelinux.org" name="http://www.vinelinux.org">)
<p>
APT4RPM (<url id="http://apt4rpm.sf.net" name="http://apt4rpm.sf.net">)
<p>
Alt Linux (<url id="http://www.altlinux.ru/" name="http://www.altlinux.ru/">)
<p>
Red Hat (<url id="http://www.redhat.com/" name="http://www.redhat.com/">)
<p>
Sun Solaris (<url id="http://www.sun.com/" name="http://www.sun.com/">)
<p>
SuSE (<url id="http://www.suse.de/" name="http://www.suse.de/">)
<p>
Yellow Dog Linux (<url id="http://www.yellowdoglinux.com/"
name="http://www.yellowdoglinux.com/">)
</chapt>

<chapt id="agradecimentos">Agradecimentos
<p>
Agradecimentos vão para meus grandes amigos do projeto Debian-BR e do
Debian que me ajudam sempre e me dão força para continuar trabalhando em
prol da humanidade além de me ajudar sempre no meu objetivo de salvar
o mundo =).
<p>
Agradeço também ao CIPSGA pelo apoio enorme que dá ao nosso projeto e
a todos os projetos livres que brotam de grandes idéias.
<p>
E agradecimentos especiais para:
<p>
Yooseong Yang &lt;yooseong@debian.org&gt;
<p>
Michael Bramer &lt;grisu@debian.org&gt;
<p>
Bryan Stillwell &lt;bryan@bokeoa.com&gt;
<p>
Pawel Tecza &lt;pawel.tecza@poczta.fm&gt;
<p>
Hugo Mora &lt;h.mora@melix.com.mx&gt;
<p>
Luca Monducci &lt;luca.mo@tiscali.it&gt;
<p>
Tomohiro KUBOTA &lt;kubota@debian.org&gt;
<p>
Pablo Lorenzzoni &lt;spectra@debian.org&gt;
<p>
Steve Langasek &lt;vorlon@netexpress.net&gt;
<p>
Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;
<p>
Erik Rossen &lt;rossen@freesurf.ch&gt;
<p>
Ross Boylan &lt;RossBoylan@stanfordalumni.org&gt;
<p>
Matt Kraai &lt;kraai@debian.org&gt;
<p>
Aaron M. Ucko &lt;ucko@debian.org&gt;
<p>
Jon Åslund &lt;d98-jas@nada.kth.se&gt;
</chapt>

<chapt id="novas">Novas versões desse tutorial
<p>
Esse manual foi produzido pelo projeto <url id="http://www.debian-br.org"
name="Debian-BR">, com o intuito de ajudar no uso cotidiano do sistema
Debian.
<p>
Novas versões serão lançadas na página do Projeto, em
<url id="http://www.debian-br.org/suporte/documentacao.php" 
name="http://www.debian-br.org/suporte/documentacao.php">. 
<p>
Sugestões e críticas podem ser enviadas diretamente para mim no email
<email>kov@debian.org</email>.
<p>
Um abraço a toda a comunidade Debian!
</chapt>

</book>
</debiandoc>
