<!doctype debiandoc system>

<book>

<title>APT HOWTO</title>

<author>
<name>Gustavo Noronha Silva</name> <email>kov@debian.org</email>
</author>
<author>
<name>한국어 번역: 양유성</name> <email>yooseong@debian.org</email>
</author>
<version>1.7.3 - 2001년 9월 September 2001</version>

<abstract>
이 문서는 사용자에게 데비안 패키지 관리 유틸리티인 APT의 사용법에 대한
이해를 돕고자 만들어졌다. 목적은 새로운 데비안 사용자들에게 도움을
주고 데비안 시스템 관리의 폭을 좀더 높이기 위한 사람들에게 도움이 될
것이다. 데비안 프로젝트용으로 만들어졌는데 데비안 사용자들에 대한
지원을 향상시키기 위해서이다. 
</abstract>


<copyright>
<copyrightsummary>
Copyright &copy; 2001 Gustavo Noronha Silva
</copyrightsummary>
<p>
이 문서의 라이선스는 GNU FDL(Free Documentation Lincense)를
따른다. 공동체에 도움이 되길 바라지만 보장은 할 수 없다; 사용을 하면서
따르는 위험부담은 여러분의 몫이다. 
</copyright>

<toc>

<chapt>개요 
<p>
데비안이 시작했을 때에는 .tar.gz이었다. 사용자들이 각 포로그램을
GNU/리눅스 시스템에서 사용하고자 컴파일 해서 사용하였고 데비안이
시작되었을 때 머신에 설치되어 있던 패키지들을 관리하는 도구가 필요하게
되었다. 데비안에서는 <prgn>dpkg</prgn>가 사용되었고 유명한 `패키지'가
GNU/리눅스에 들어오게 되었다. 이는 레드햇이 그들 자신의 `rpm' 시스템을
만들고자 결정하기 전이었다. 
<p>
새로운 딜레마가 GNU/리눅스 제작자들 마음을 사로잡았다. 이들을 빠르고
실용적이고 효과적으로 패키지를 설치하는데 자동적으로 의존성을 관리하고
설정파일을 업그레이드중에 다루게 하고 싶었다. 여기서 데비안은 방법을
고안해 냈는데 이것이 APT, Advanced Packaging Tool,인데 이는
Conectiva에 의해서 포팅이 되어 rpm과 함께 사용되고 있고 다른
디스트리뷰션에서 채택되어 사용되었다. 
<p>
이 매뉴얼은 APT의 Conectiva 포팅인 apt-rpm을 말하려는 것이 아니고 이
문서에 대한 ``패치''는 언제든지 환영한다. 
</chapt>

<chapt id="basico">기본 설정

<sect id="sources.list">/etc/apt/sources.list 파일
<p>
작업과정의 일부로서 APT는 어떤 패키지를 가지고 올 `sources'가
필요하다. 이 파일은 <tt>/etc/apt/sources.list</tt>이다. 
<p>
이 파일들의 항목들은 다음과 같은 형태를 취하고 있다:

<example>
deb http://site.http.org/debian distribution section1 section2 section3
deb-src http://site.http.org/debian distribution section1 section2 section3
</example>

위의 항목들은 가상의 것이고 사용하지 말아야한다. 각 라인의 첫번째
단어는 <tt>deb</tt>나 <tt>deb-src</tt>는 아카이브의 형태를 의미하는데:
바이너리 패키지를 포함하는 경우는 <tt>deb</tt>이며 우리가 일반적으로
사용하는 미리 컴파일된 패키지들이고 <tt>deb-src</tt>를 의미하는 소프
패키지는 원본 소스에 데비안 제어파일(<tt>.dsc</tt>)과 프로그램을
데비안화 하여 만드는데 필요한 데비안 changes 파일인 <tt>diff.gz</tt>를
의미한다.  
<p>
대개는 다음의 내용이 sources.list에 기본으로 들어있다:
<example>
# See sources.list(5) for more information, especialy
# Remember that you can only use http, ftp or file URIs
# CDROMs are managed through the apt-cdrom tool.
deb http://http.us.debian.org/debian stable main contrib non-free
deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
deb http://security.debian.org stable/updates main contrib non-free

# Uncomment if you want the apt-get source function to work
#deb-src http://http.us.debian.org/debian stable main contrib non-free
#deb-src http://non-us.debian.org/debian-non-US stable non-US
</example>

기본 데비안 설치에 필요한 내용들이다. 첫번째 <tt>deb</tt>는 공식적인
아카이브를 가리키고 두번째는 non-US 아카이브이고 세번째는 데비안 보안
업데이트를 가리킨다. 
<p>
마지막 두개의 라인은 #으로 주석처리 되어 있는데 apt-get은 이를
무시한다. 이는 <tt>deb-src</tt>인데 데비안 소스 패키지를
포함한다. 테스팅이나 재컴파일을 위해서 프로그램 소스를 다운로드 하려면
주석을 없애주면 된다. 
<p>
<tt>/etc/apt/sources.list</tt> 파일은 몇개 형태의 라인을 포함할 수
있다. APT는 <tt>http</tt>, <tt>ftp</tt>, <tt>file</tt>(로컬 파일로
마운트된 ISO9660 파일시스템을 포함한 디렉토리)와 <tt>ssh</tt>의
아카이브를 인식하고 다룬다. 

</sect>

<sect id="dpkg-scanpackages">로컬에서 APT 사용하기
<p>
때로는 여러분이 APT를 이용해서 설치하려는 수많은 .deb 패키지들이
있고 의존성이 자동으로 해결되어 설치되게 하고 싶은 경우가 있을 것이다.
<p>
디렉토리를 만들고 .deb를 여러분이 원하는 곳에 넣기 위해서는 다음과
같은 디렉토리를 만든다:
<example>
mkdir /root/debs
</example>
/root 디렉토리 내에서 비어있는 파일을 어떤 이름으로든지 하나
만들어준다. 이유는 APT 저장소가 "override"라는 파일이 필요한데 이
팡리은 비어있을 수 있지만 존재해야한다. 다음의 명령을 통해서 이 파일을
만들 수 있다:
<example>
touch file
</example>
이 파일안에는 패키지와 이미 있었던 옵션을 중복하여 덮어쓰는 몇가지
옵션들을 정할 수 있다. 다음과 같다:
<example>
package priority section
</example>
패키지는 패키지 이름이고 우선 순위는 low, medium이나 high이고 섹션은
이 패키지가 속할 섹션이다. 파일을 비어두는 것으로 충분한다.
<p>
/root 디렉토리에서 할일은:
<example>
dpkg-scanpackages debs file | gzip > debs/Packages.gz
</example>
위에서 파일은 "override"이고 명령은 debs/Packages.gz를 만들어서
패키지에 대한 다양한 정보를 포함하고 있어서 APT가 사용하게
해준다. 패키지를 이용하려면 다음과 같이 추가한다:
<example>
deb file:/root debs/
</example>
이렇게 한 후에 APT 명령을 평상시와 같이 한다. 소스 저장소를 만들 수
있고 이를 하기 위해서는 동일한 과정을 하는데 <tt>.orig.tar.gz</tt>와
<tt>.dsc</tt>, <tt>.diff.gz</tt>를 디렉토리에 넣고 Packages.gz대신
Sources.gz를 사용하면 된다. 프로그램도 다르다:
<prgn>dpkg-scansources</prgn>. 명령은 다음과 같다:
<example>
dpkg-scansources debs | gzip > debs/Sources.gz
</example>
<prgn>dpkg-scansources</prgn>는 "overrride" 파일이
필요없다. sources.list는 다음과 같다:
<example>
deb-src file:/root debs/
</example>
</sect>

<sect id="netselect">어떠한 미리라가 sources.list에 가장 좋은 곳인지
선택해주는 것은: netselect, netselect-apt<p>
새로운 사용자들 대부분이 의심하는 것은: "어떠한 데비안 미러를 사용해서
<tt>sources.list</tt>에 포함시킬까"하는 것이다. 어떤 미러를 선택하는
방법은 여러가지가 있다. 전문가들은 스크립트를 이용해서 몇개의 서버로
ping 시간을 측정하는 스크립트를 갖고 있지만 이를 도와주는 프로그램이
있다: <strong>netselect</strong>.
<p>
netselect를 설치하기 위해서는 다음과 같다:
<example>
apt-get install netselect
</example>
파라미터가 없이 실행하면 도움말을 보여준다. 공백으로 분리된
호스트(미러)를 이용해서 실행하면서 점수와 호스트 하나를 보여준다. 이
점수는 측정된 ping 시간이며 hops(네트워크 쿼리가 목적지에 도착하면서
지나가는 호스트)의 개수와 측정된 다운로드 속도(더 낮을수록 더 낫다)에
반비례한다. 돌아오는 호스트는 더 낮은 점수를 갖게 된다(점수의 모든
리스트는 -vv 옵션을 추가하면 찾을 수 있다). 다음의 예제를 보면:<example>
bash$ netselect ftp.debian.org http.us.debian.org ftp.at.debian.org download.unesp.br ftp.debian.org.br
  365 ftp.debian.org.br
bash$
</example>
이 의미는 netselect에 파라메타에 포함된 미러로부터
<tt>ftp.debian.org.br</tt>가 가장 좋다고 나왔고 점수는 365였다. (주의!
이는 필자의 컴퓨터에서 한 것이고 네트워크 상황은 접근 지점에 따라서
매우 다를 수 있으니 이 값은 다른 컴퓨터에서도 항상 같은 것은 아니다.) 
<p>
지금은 <tt>/etc/apt/sources.list</tt>에 netselect에 의해 가장 빠른
미러를 넣고 (<ref id="sources.list"> 참고) <ref id="apt-get">에 있는
팁을 따른다.  
<p> <strong>참고:</strong> 미러의 리스트는 항상<url
id="http://www.debian.org/mirror/mirrors_full"
name="http://www.debian.org/mirror/mirrors_full">에서 확인할 수 있다. <p>
0.3 버젼으로 시작했던 netselect 패키지는
<strong>netselect-apt</strong>를 포함하고 있고 이는 위의 과정을 자동화
시켜준다. 파라메타로 디스트리뷰션 트리를 입력하고(기본은 안정이다)
<tt>sources.list</tt> 파일이 가장 좋은 main과 non-US 미러가 생기고
현재의 디렉토리에 저장될 것이다. 다음의 예제는 안정 디스트리뷰션의
sources.list를 만들어낸다:
<example>
bash$ ls sources.list
ls: sources.list: File or directory not found
bash$ netselect-apt stable
(...)
bash$ ls -l sources.list
sources.list
bash$
</example>
<strong>기억할 것:</strong> <tt>sources.list</tt> 파일은 현재의
디렉토리에 생기고 반드시  <tt>/etc/apt</tt>로 옮겨져야 한다. 
<p>
<ref id="apt-get">에 나와 있는 팁을 따르면 된다.
</sect>

<sect id="cdrom">CD-ROM을 sources.list에 추가하기
<p>
여러분의 CD-ROM을 패키지를 설치하는데 사용하거나 자동적으로 APT를
이용해서 업데이트하려면 다음의 내용을 <tt>sources.list</tt>을 추가할
수 있다. 이렇게 하기 위해서는 <prgn>apt-cdrom</prgn>를 다음과 같이
이용하면 된다:

<example>
apt-cdrom add
</example>

드라이브에 데비안 CD-ROM을 넣고 실행한다. 이는 CD-ROM을 마운트하고
제대로 된 CD-ROM이면 디스크내에 있는 패키지 정보를 찾는다. CD-ROM
설정이 다소 비정상적이면 여러분은 다음의 옵션을 사용할 수 있다:

<example>
-h           - program help
-d directory - CD-ROM mount point
-r           - Rename a recognized CD-ROM
-m           - No mounting
-f           - Fast mode, don't check package files
-a           - Thorough scan mode
</example>

예를 들어:

<example>
apt-cdrom -d /home/kov/mycdrom add
</example>

여러분의 리스트에 추가하지 않고 CD-ROM을 인식할 수 있다:

<example>
apt-cdrom ident
</example>

이 프로그램은 CD-ROM이 제대로 여러분의 시스템의 <tt>/etc/fstab</tt>에
들어 있는 경우에 작동한다. 
</sect>

</chapt>


<chapt id="apt-get">패키지 관리하기
<sect id="update">가용한 패키지 리스트 업데이트하기
<p>
패키징 시스템은 어떤 패키지가 설치되었고 안되었고 설치에 가용한지 추적하는 자체의
데이타베이스를 사용한다. <prgn>apt-get</prgn> 프로그램은 이
데이타베이스를 이용해서 사용자가 원하는 패키지를 설치하는 방법을
인식하고 선택된 패키지가 작동하는데 필요한 추가적인 패키지가 있는지
찾게 된다. 
<p>
이 리스트를 업데이트하기 위해서는 <prgn>apt-get update</prgn>를
이용하면 된다. 이 명령은 <tt>/etc/apt/sources.list</tt>에 있는
아카이브의 패키지 리스트를 찾는다; 이 파일에 대한 더 자세한 정보는 <ref
id="sources.list">를 참조하면 된다. 
<p>
이 명령을 주기적으로 이용해서 여러분 시스템에서 가용한 패키지
업데이트를 하고 있는 것이 좋다. 특히 보안 업데이트는 매우 중요하다. 
</sect>

<sect id="install">패키지 설치하기
<p>
마지막으로 여러분은 기다리기만 한다! 여러분의 sources.list와 업데이트
가능한 리스트를 이용해서 여러분이 할 일은 <tt>apt-get</tt>을 이용해서
여러분이 원하는 패키지를 설치하면 된다. 예를 들어 다음과 같다:

<example>
apt-get install xchat
</example>

APT는 패키지의 가장 최신버젼을 데이타베이스에서 찾고 이를
<tt>sources.list</tt>에 정해져 있는 해당 아카이브에서 받아오게
된다. 이 패키지가 다른 것에 의존하는 경우에는 APT는 의존성을 확인해서
필요한 패키지를 설치해준다. 예를 들면: 

<example>
[root]@[/] # apt-get install nautilus
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 0 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 17.2MB will be used.
Do you want to continue? [Y/n] 
</example>

<package>nautilus</package> 패키지는 공유 라이브러리에 의존하는데
APT는 자동적으로 아카이브에서 이것들을 가져온다. <tt>apt-get</tt>
명령행에서 이러한 라이브러리의 이름을 정했다면 APT는 여러분이 계속
하기를 원한다면 APT는 물어보지 않을 것이다; 여러분이 이런 패키지들을
모두 원한다면 모두 자동적으로 설치될 것입니다. 
<p>
APT가 단지 의존성을 만족시키는 패키지를 제외하고 패키지를 설치할
필요가 있을 때는 확인을 요구하게 된다. 
<p>
다음의 옵션은 apt-get을 이용할 때 유용하다:

<example>
-h  This help text.
-d  Download only - do NOT install or unpack archives
-f  Attempt to continue if the integrity check fails
-s  No-act. Perform ordering simulation
-y  Assume Yes to all queries and do not prompt
-u  Show a list of upgraded packages as well
</example>

여러개의 패키지를 설치하고자 하는 경우에 한줄에 다 넣으면 된다.
네트워크를 통해서 파일을 다운로드하면 설치후에는
<tt>/var/cache/apt/archives</tt>에 위치하게 된다. 
<p>
두번째 명령행에 제거할 패키지를 정할 수 있다. 단지 '-'를 제거할 패키지
뒤에 다음과 같이 넣으면 된다:

<example>
[root]@[/] # apt-get install nautilus gnome-panel-       
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n] 
</example>

패키지 삭제에 관해서는 <ref id="remove">을 참조하라. 
<p>

패키지가 문제가 있다거나 동일 버젼으로 패키지 파일을 설치하고자 한다면
다음과 같이 <tt>--reinstall</tt>를 이용하면 된다. 

<example>
[root]@[/] # apt-get --reinstall install gdm
Reading Package Lists... Done
Building Dependency Tree... Done
0 packages upgraded, 0 newly installed, 1 reinstalled, 0 to remove and 1  not upgraded.
Need to get 0B/182kB of archives. After unpacking 0B will be used.
Do you want to continue? [Y/n]
</example>

이 문서를 만들 당시의 APT의 버젼은 0.5.3이었다. 이는 현재 `불안정'
버젼(<tt>sid</tt>)에서 이용되는 버젼이다. 이 버젼이 설치되었다면
추가적인 기능을 갖게 된다: <tt>apt-get install
package/distribution</tt>의 형태를 이용해서 원하는 디스트리뷰션에서
패키지를 설치할 수 있다 또는 <tt>apt-get install
package=version</tt>을 이용할 수 있다. 예를 들면:

<example>
apt-get install nautilus/unstable
</example>

이러면 여러분이 사용하는 것이 `stable'이라해도 `unstable'에서 노틸러스
패키지를 설치할 수 있다. '디스트리뷰션'에 대한 값들로는
<tt>stable</tt>, <tt>testing</tt>, <tt>unstable</tt>이 있다. 
<p>
<em>중요한점</em>: 데비안의 `unstable' 버젼은 데비안 패키지의 가장
새로운 버젼이 가장 먼저 업로드 되는 곳이다. 이 디스트리뷰션은 패키지가
지나온 모든 변화를 갖고 있는데 작은 패키지에서 부터 많은 패키지에
영향을 주는 패키지나 전체 시스템에 영향을 주는 패키지까지 있다. 이러한
이유로 인해서 디스트리뷰션의 이 버젼은 경험이 없는 사용자나 안정성이
필요한 사람들이 사용해서는 <em>안된다</em>.
<p>
`testing' 디스트리뷰션은 `unstable'보다는 안정성면에서 낫다. 
</sect>

<sect id="remove">패키지 제거하기
<p>
더이상 어떤 패키지를 사용하고자 하지 않으면 이를 여러분의 시스템에서
APT를 이용해서 없앨 수 있다. 이렇게 하기 위해서는 <tt>apt-get remove
package</tt>를 실행하면 된다. 예를 들면:

<example>
[root]@[/] # apt-get remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n] 
</example>

위의 예에서 볼 수 있듯이 APT는 의존성이 걸린 패키지의 제거에
신중하다. 의존하는 패키지들을 제거하는 것 없이 패키지를 제거할 수 있는
방법은 APT에서는 없다. 
<p>
<prgn>apt-get</prgn>를 위에서와 같이 실행하면 패키지를 제거하지만
설정파일이 있다면 없애지는 않고 시스템에 그대로 남겨둔다. 패키지를
확실하게 지우려면 다음을 실해하라:

<example>
[root]@[/] # apt-get --purge remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n] 
</example>

이름 뒤에 나온 '*'를 유의하라. 이는 각 패키지의 설정파일이 모두
삭제된다는 의미가 된다. 
<p>
<tt>install</tt> 방법에서 처럼 여러분은 <tt>remove</tt>을 심볼로 하여
특정한 패키지에 대한 의미를 변경할 수 ㅇLㅆ다. 제거하는 경우에
<tt>'+'</tt>를 패키지 이름 바로 뒤에 붙이면 패키지를 제거하는 대신
패키지를 설치한다. 

<example>
[root]@[/] # apt-get --purge remove gnome-panel nautilus+
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n] 
</example>

<prgn>apt-get</prgn>는 설치될 다른 패키지들도 보여준고(즉 패키지
설치시 패키지가 정상으로 작동하기 위해서 필요한 패키지들) 없앨
패키지들과 추가 패키지들을 포함해서 설치될 패키지들을 보여준다. 
</sect>

<sect id="upgrade">패키지 업그레이드
<p>
패키지 업그레이드는 APT 시스템의 성공작이다. 단 하나의 명령어로 할 수
있다:<tt>apt-get upgrade</tt>. 이 명령을 이용해서 동일
디스트리뷰션내에서 패키지 업그레이드가 가능하고 새로운
디스트리뷰션으로 업그레이드도 되지만 이 경우에는 <tt>apt-get
dist-upgrade</tt>를 권한다; 자세한 내용은  <ref id="dist-upgrade">
섹션을 참고 하기 바란다. 
<p>
이 명령을 이용할 때는 <tt>-u</tt>과 함께 사용한다. 이 옵션은 APT를
이용할 때 업그레이드 되는 패키지 목록을 보여준다. 이 옵션없이 하면
무엇이 업그레이드 되는지 모른다. APT는 각 패키지의 최신버젼을 다운로드
하고 적절한 순서로 설치한다. 이를 실행하기 전에 반드시 <tt>apt-get
update</tt>를 실행해야 하는 것이 중요하다. <ref id="update">를
참조하라. 다음의 예제를 보면:

<example>
[root]@[/] # apt-get -u upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages have been kept back
  cpp gcc lilo 
The following packages will be upgraded
  adduser ae apt autoconf debhelper dpkg-dev esound esound-common ftp indent
  ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0 libesd0-dev
  libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev liborbit0
  libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit procps psmisc 
29 packages upgraded, 0 newly installed, 0 to remove and 3 not upgraded.
Need to get 5055B/5055kB of archives. After unpacking 1161kB will be used.
Do you want to continue? [Y/n] 
</example>

과정은 매우 단순하다. 처음 몇줄에서는 <tt>apt-get</tt>이 몇몇
패키지들이 <tt>kept back</tt>(그대로 있음)으로 있음을 알려주고
있다. 이 의미는 새로운 버젼의 패키지가 몇가지 이유에 의해서 설치가
안된다는 의미가 된다. 가능한 이유로는 의존성이 깨진(그 패키지가
의존하는 패키지가 다운로드 가능한 버젼이 아닌경우)경우이거나 새로운
의존성(그 패키지가 의존하는 패키지가 새로운 패키지에 의존하는 경우)이
있는 경우이다. 
<p>
첫번째 경우에는 정확한 해결법이 없다. 두번째 경우에는 특정패키지를
<tt>apt-get install</tt>를 이용해서 설치하면 충분하다. 결국 이 것이
의존성을 해결해주는 셈이다. 더 깨끗한 방법은 <tt>dist-upgrade</tt>를
이용하는 것인데 <ref id="dist-upgrade">를 참조하라. 
</sect>

<sect id="dist-upgrade">새로운 릴리즈로 업글하기 
<p>
APT의 이 기능은 여러분이 전체 데비안 시스템을 인터넷을 통하건 새로운
CD(구입하건 ISO이미지를 이용하건)를 이용하건 업그레이드가 됩니다. 
<p>
설치된 패키지들간의 관계가 변화가 있을 때 사용된다. <tt>apt-get
upgrade</tt>를 이용해서 패키지들을 그대로 있을 수 있다(<tt>kept
back</tt>). 
<p>
예를 들어 데비안의 안정버젼의 리비젼 0을 사용하고 있고 리비젼 3의
시디를 구입했다고 가정하자. APT를 이용해서 새로운 CD를 이용해서
시스템을 업그레이드 할 수 있다. 이렇게 하기 위해서는
<prgn>apt-cdrom</prgn>를 이용해서(<ref id="cdrom"> 참조) CD를
<tt>/etc/apt/sources.list</tt>에 넣고 <tt>apt-get dist-upgrade</tt>를
실행시켜준다.  
<p>
APT가 항상 가장 새로운 버젼의 패키지를 찾는다. 따라서 CD가 아닌 더욱더
최근의 것을 갖는 리스트를 <tt>/etc/apt/sources.list</tt>이 포함한다면
APT는 패키지를 거기서 다운로드 한다. 
<p>
<ref id="upgrade"> 섹션에서 본 예와같이 몇개의 패키지들은
그대로(<tt>kept back</tt>) 있게 된다. 이 문제를 <tt>dist-upgrade</tt>
방법으로 해결할 수 있다. 

<example>
[root]@[/] # apt-get -u dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following NEW packages will be installed:
  cpp-2.95 cron exim gcc-2.95 libident libopenldap-runtime libopenldap1
  libpcre2 logrotate mailx 
The following packages have been kept back
  lilo 
The following packages will be upgraded
  adduser ae apt autoconf cpp debhelper dpkg-dev esound esound-common ftp gcc
  indent ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0
  libesd0-dev libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev
  liborbit0 libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit
  procps psmisc 
31 packages upgraded, 10 newly installed, 0 to remove and 1 not upgraded.
Need to get 0B/7098kB of archives. After unpacking 3118kB will be used.
Do you want to continue? [Y/n]
</example>

패키지가 업그레이드 되고 새로운 패키지가 설치되는 것이다(패키지의
새로운 의존성). lilo는 그대로(<tt>kept back</tt>) 있게 된다. 새로운
의존성보다 심각한 문제가 있을 수 있다. 다음을 실행함으로써 확인이
가능하다:

<example>
[root]@[/] # apt-get -u install lilo
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be REMOVED:
  debconf-tiny 
The following NEW packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be upgraded
  lilo 
1 packages upgraded, 9 newly installed, 1 to remove and 31 not upgraded.
Need to get 225kB/1179kB of archives. After unpacking 2659kB will be used.
Do you want to continue? [Y/n]
</example>

위에서 언급한 것 처럼 lilo는 debconf-tiny를 없애지 않고 설치될 수 없는
상황이라서 <package>debconf-tiny</package>와 새롭게 충돌이 일어나고
있다. 
</sect>

<sect id="dselect-upgrade">dselect와 함께 APT 사용하기 
<p>
<prgn>dselect</prgn>는 사용자들이 데비안 패키지 설치를 위해서 도움을
주는 프로그램이다. 다소 복잡하고 진부하게 여길 수 있다. 하지만 조금만
연습하면 이 콘솔 기반의 ncurses 인터페이스에 익숙해지고 그리 힘들지
않을 것이다. 
<p>
dselect의 하나의 기능중의 하나는 패키지 설치시 "추천"하고 "제안"하는
데비안 패키지의 기능을 충분히 이용하는 것입니다. 다 필요하지는
않지만 CD ROM을 사용하지 않고 인터넷에서 패키지를 다운로드 하고자
한다면 dselect를 이용하는 것이 가장 좋다. 
<p>
dselect의 사용에 관해 자세히 알고 싶으면 <url
id="http://www.debian.org/doc/ddp"
name="http://www.debian.org/doc/ddp">에 나온 dselect에 관한 문서를
살펴보면 됩니다.  
<p>
dselect를 이용해서 여러분의 원하는 것을 선택한 후에:

<example>
apt-get -u dselect-upgrade
</example>

아래의 예에서 볼 수 있는 것처럼:

<example>
[root]@[/] # apt-get -u dselect-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  lbxproxy 
The following NEW packages will be installed:
  bonobo console-tools-libs cpp-3.0 enscript expat fingerd gcc-3.0
  gcc-3.0-base icepref klogd libdigest-md5-perl libfnlib0 libft-perl
  libgc5-dev libgcc300 libhtml-clean-perl libltdl0-dev libsasl-modules
  libstdc++3.0 metamail nethack proftpd-doc psfontmgr python-newt talk tidy
  util-linux-locales vacation xbill xplanet-images 
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 30 newly installed, 1 to remove and 0  not upgraded.
Need to get 7140kB of archives. After unpacking 16.3MB will be used.
Do you want to continue? [Y/n]
</example>

동일 시스템에서 apt-get dist-upgrade을 실행하는 것과 비교하라:

<example>
[root]@[/] # apt-get -u dist-upgrade   
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 0 newly installed, 0 to remove and 0  not upgraded.
Need to get 421kB of archives. After unpacking 25.6kB will be freed.
Do you want to continue? [Y/n]
</example>

위에서 나온 많은 패키지들이 설치되는데 "제안되거나" "추천된"
패키지들이기 때문이다. 다른 것들은 dselect를 이용해서 선택한
설치되거나 제거(예를 들어 lbxproxy의 경우) 패키지들이다. Dselect는
APT와 함께 사용할 때 막강한 도구가 될 수 있다. 
</sect>

<sect id="pin">설치된 패키지의 특정 버젼 정해주는 방법
<p>
어떠한 경우에는 패키지에서 무엇인가를 변경할 때가 있고 시간은 없고
이러한 변화들을 프로그램의 새버젼으로 옮기고 싶지 않을 때가 있다. 예를
들어, 단지 여러분의 데비안 디스티리뷰션을 3.0으로 올렸지만 어떤
패키지는 그냥 데비안 2.2를 유지하고 싶은 경우가 있다. 여러분이
설치하고자 하는 버젼을 "pin(고정)"시킬 수 있고 업그레이드 하지 않을 수
있다. 
<p>
이 리소스를 이용하는 것은 단순하다. <tt>/etc/apt/preferences</tt>을
편집할 필요가 있다.  
<p>
포맷은 단순하다:
<example>
Package: &lt;package&gt;
Pin: &lt;pin definition&gt;
Pin-Priority: &lt;pin's priority&gt;
</example>
<p>
예를 들어, <package>sylpheed</package>를 그대로 유지해서 버젼을
0.4.99으로 "reply-to-list"를 이용해서 변경이 가능하다. 다음을
추가한다:
<example>
Package: sylpheed
Pin: version 0.4.99*
</example>
여기서는 <tt>*</tt>를 사용했다. 이는 "wildcard"이다; 이 "pin"을
0.4.99로 시작하는 모든 버젼에 대해서 유용하게 사용하고 싶다는 의미가
된다. 이는 데비안이 패키지 버젼을 "데비안 리비젼"을 이용할 수 있기
때문이고 이러한 리비젼의 설치를 피하고 싶지 않기 때문이다. 그래서
0.4.99-1과 0.4.99-10이 가용하다면 모두 설치될 것이다. 만일 패키지를
변형하고자 한다면 이런식으로 하고 싶지는 않을 것이다. 
<p>
<tt>Pin-Priority</tt> 필드는 선택이다; 정하지 않으면 기본으로 989로
정해진다. 
<p>
여기서 잠깐 pin 우선순위가 어떻게 작동하는지 알아보자. 0보다 낮은
순위는 패키지가 결코 설치되지 말아야한다는 의미이다. 우선순위 0부터
100까지는 설치되지 않은 패키지를 의미하고 가용한 버젼이 아니라는
의미이다. 이는 버젼 선택 과정에 나오지 않을 것이다. 우선 순위 100은
설치된 패키지에 우선순위가 할당된 것이다 - 다른 버젼으로 대체될 설치된
패키지의 버젼에 대해서 대체하는 것은 100보다 우선 순위가 높아야한다. 
<p>
100 이상의 우선순위가 의미하는 것은 패키지가 반드시 설치되어야한다는
의미이다. 전형적으로 설치된 패키지의 버젼은 새로운 버젼으로 업그레이드
된다. 100과 1000사이의 우선순위는 이 전형적인 것을 따르게 된다. 이러한
우선순위를 갖는 패키지는 낮은 버젼을 갖는 가용한 버젼으로 다운그레이드
되지 않는다. 예를 들어 sylpheed가 0.5.3이 설치되었고 pin을 0.4.99로
정하고 우선순위를 99로 하면 pin을 만족시키는 버젼인 0.4.99로 되지
<em>않을</em> 것이다. "다운그레이드 가능한" 패키지를 만들려면
1000이상으로 정해줘야한다. 
<p>
이 다운그레이드의 개념은 막강한 어플리케이션을 갖고 있다; 여러분이
<tt>stable</tt> 버젼의 데비안을 <tt>testing</tt>으로 업그레이한다고
가정하고 그 결정을 번복하고 싶은 경우가 있다 - <tt>testing</tt>이
여러분을 충족시켜 줄 정도로 "테스트"되지 않았다. 기본 pin을 정의하여
패키지 이름에 대해서 와일드카드를 이용해서 stable로 돌아갈 수
있다. 예를 들어:
<example>
Package: *
Pin: release a=stable
Pin-Priority: 1001
</example>
<p>
이렇게 한 후에 <tt>apt-get -u dist-upgrade</tt>를 하면 시스템을 안정
버젼으로 다운그레이드가 가능하다.
<p>
pin은 패키지의 <tt>version</tt>, <tt>release</tt>나 <tt>origin</tt>에
대해 정해줄 수 있다. 
<p>
<tt>version</tt>를 정하는 것은 버젼 숫자를 지원하고 동시에 몇개의 특정
버젼을 지원한다. 
<!-- what's available?  standard shell globs?  ?*[]   or more? -->
<p>
<tt>release</tt> 옵션은 APT 저장소나 CD에서 릴리즈 파일에 의존한다. 이
옵션은 이 파일을 제공하지 않는 패키지 저장소를 사용하는 경우에 전혀
쓸모가 없게 된다. <tt>/var/lib/apt/lists/</tt>에 있는 릴리즈 파일의
내용을 볼 수 있다. 릴리즈에 대한 파라메타는 다음과 같다:  
<tt>a</tt> (archive), <tt>c</tt> (components), <tt>v</tt> (version),
<tt>o</tt> (origin) 와<tt>l</tt> (label).
<p>
일 예로:
<example>
Package: *
Pin: release v=2.2*,a=stable,c=main,o=Debian,l=Debian
Priority: 1001
</example>
이 예를 통해서 보면 데비안 2.2* 버젼을 선택했고(2.2r2, 2.2r3이 될 수
있고 -- 이는 보안 수정을 포함하는 "point release"를 포함하고 이는 매우
중요한 업데이트다), <tt>stable</tt> 저장소, <tt>main</tt>
섹션(<tt>contrib</tt>나 <tt>non-free</tt>와는 반대되는)와 origin과
label 데비안을 선택했다. Origin(o=)는 누가 그 릴리즈 파일을 만드는지
정의하고 label(l=)은 디스트리뷰션의 이름을 정의한다: 데비안 자체를
위한 데비안과 프로제니를 위한 프로제니를 예로 들 수 있다. 샘플 릴리즈
파일은 다음과 같다:
<example>
$ cat /var/lib/apt/lists/ftp.debian.org.br_debian_dists_potato_main_binary-i386_Release
Archive: stable
Version: 2.2r3
Component: main
Origin: Debian
Label: Debian
Architecture: i386
</example>
</sect>

</chapt>

<chapt id="search">패키지에 대한 정보 얻기
<p>
설치가 가능하거나 이미 설치되었거나 어떤 패키지가 어느 섹션에
있는지 우선 순위가 어떻게 되는지 패키지에 설명이 무엇인지 등에 관해서
패키지에 대한 내용을 쉽게 얻을 수 있게 도와주는 것이 APT 시스템의
프론트엔드 프로그램 들이다. 
<p>
하지만 우리의 목적은 순수한 APT를 사용하는 방법을 배우는
것이다. 설치하고자 하는 패키지의 이름을 어떻게 찾을 수 있나?
<p>
이러한 작업을 위해서는 수많은 리소스가 있다. <tt>apt-cache</tt>부터
시작하자. 이 프로그램은 APT 시스템에서 이용되는 것으로 APT의 데이타
베이스를 유지하는데 이용된다. 더욱더 유용한 어플리케이션에 대해서 잠시
살펴볼 것이다. 

<sect id="cache">패키지 이름 찾아내기
<p>
예를 들어 Atari 2600를 사용하고 싶은 경우에 Atari 에뮬레이터를
설치하여 사용하고자 하고 몇개의 게임을 다운로드 하고자 한다면. 이렇게
할 수 있다:

<example>
[root]@[/] # apt-cache search atari
atari-fdisk-cross - Partition editor for Atari (running on non-Atari)
circuslinux - The clowns are trying to pop balloons to score points!
madbomber - A Kaboom! clone
tcs - Character set translator.
atari800 - Atari emulator for svgalib/X/curses
stella - Atari 2600 Emulator for X windows
xmess-x - X binaries for Multi-Emulator Super System
</example>

우리가 찾고자 하는 것과 관계된 몇개의 패키지를 간단한 설명과 함께
찾고자 한다. 특정 패키지에 대한 자세한 정보를 얻고자 하려면 이를
이용할 수 있다:

<example>
[root]@[/] # apt-cache show stella  
Package: stella
Priority: extra
Section: non-free/otherosfs
Installed-Size: 830
Maintainer: Tom Lear &lt;tom@trap.mtview.ca.us&gt;
Architecture: i386
Version: 1.1-2
Depends: libc6 (>= 2.1), libstdc++2.10, xlib6g (>= 3.3.5-1)
Filename: dists/potato/non-free/binary-i386/otherosfs/stella_1.1-2.deb
Size: 483430
MD5sum: 11b3e86a41a60fa1c4b334dd96c1d4b5
Description: Atari 2600 Emulator for X windows
 Stella is a portable emulator of the old Atari 2600 video-game console
 written in C++.  You can play most Atari 2600 games with it.  The latest
 news, code and binaries for Stella can be found at:
 http://www4.ncsu.edu/~bwmott/2600
</example>

이 결과에서 보면 우리가 설치하고자 하거나 설치하고자 하지 않는
패키지에 대한 많은 자세한 정보를 패키지의 설명과 함께 자세히
나와있다. 패키지가 이미 여러분의 시스템에 설치되어 있고 새로운
버젼이라면 무든 버젼에 관한 정보도 볼 수 있다. 예를 들면:

<example>
[root]@[/] # apt-cache show lilo
Package: lilo
Priority: important
Section: base
Installed-Size: 271
Maintainer: Russell Coker &lt;russell@coker.com.au&gt;
Architecture: i386
Version: 1:21.7-3
Depends: libc6 (>= 2.2.1-2), debconf (>=0.2.26), logrotate
Suggests: lilo-doc
Conflicts: manpages (<<1.29-3)
Filename: pool/main/l/lilo/lilo_21.7-3_i386.deb
Size: 143052
MD5sum: 63fe29b5317fe34ed8ec3ae955f8270e
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.

Package: lilo
Status: install ok installed
Priority: important
Section: base
Installed-Size: 190
Maintainer: Vincent Renardias &lt;vincent@debian.org&gt;
Version: 1:21.4.3-2
Depends: libc6 (>= 2.1.2)
Recommends: mbr
Suggests: lilo-doc
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.
</example>

리스트의 첫번째 부분은 가용한 패키지를 의미하고 두번째는 설치되어 있는
버젼이다. 패키지에 대한 일반적인 정보를 얻으려면 다음과 같다:

<example>
[root]@[/] # apt-cache showpkg penguin-command
Package: penguin-command
Versions: 
1.4.5-1(/var/lib/apt/lists/download.sourceforge.net_debian_dists_unstable_main_binary-i386_Packages)(/var/lib/dpkg/status)

Reverse Depends: 
Dependencies: 
1.4.5-1 - libc6 (2 2.2.1-2) libpng2 (0 (null)) libsdl-mixer1.1 (2 1.1.0) libsdl1.1 (0 (null)) zlib1g (2 1:1.1.3) 
Provides: 
1.4.5-1 - 
Reverse Provides: 
</example>

패키지가 어떤 패키지에 의존하고 있는지 찾으려면:

<example>
[root]@[/] # apt-cache depends penguin-command
penguin-command
  Depends: libc6
  Depends: libpng2
  Depends: libsdl-mixer1.1
  Depends: libsdl1.1
  Depends: zlib1g
</example>

요약하면 우리가 원하는 패키지 이름을 찾는데 이용하는 범위의 도구를
갖고 있는 셈이다. 
</sect>

<sect id="dpkg-search">Using dpkg to find package names
<p>
패키지 이름을 정하는 방법중의 한가지는 패키지내에서 발견된 중요한
파일들의 이름을 아는 것이다. 예를 들면 컴파일에 필요한 특정한 <tt>".h"</tt> 파일을
제공하는 패키지를 찾기 위해서는 다음을 실행한다: 

<example>
[root]@[/] # dpkg -S stdio.h
libc6-dev: /usr/include/stdio.h
libc6-dev: /usr/include/bits/stdio.h
perl: /usr/lib/perl/5.6.0/CORE/nostdio.h
</example>

or:

<example>
[root]@[/] # dpkg -S /usr/include/stdio.h
libc6-dev: /usr/include/stdio.h
</example>

여러분의 시스템에 설치되어 있는 유용한 패키지의 이름을 찾기 위해서
하드드라이브를 정리할 계획이라면 다음을 실행하라:

<example>
[root]@[/] # dpkg -l | grep mozilla
ii  mozilla-browse 0.8-0.1        Mozilla Web Browser
</example>

이 명령의 문제점은 패키지 이름이 "잘릴 수" 있다는 것이다. 위의 예에서
패키지의 정확한 이름은 <tt>mozilla-browser</tt>이다. 이를 수정하기
위해서는 패키지 설명을 이용하거나 그 일부를 이용해서 정확한 이름을 알
수 있다:

<example>
[root]@[/] # apt-cache search "Mozilla Web Browser"
mozilla-browser - Mozilla Web Browser
</example>
</sect>

<sect id="auto-apt">"on demand" 패키지 설치하는 방법
<p>
프로그램을 컴파일 하고 있는데 멈춰버렸다! 이는 여러분이 필요한
<tt>.h</tt> 파일이 없기 때문이다.  <prgn>auto-apt</prgn>은 그러한
상황을 막아줄 것이다. 필요한 패키지라면 그 패키지를 설치하라고 하고
과정을 멈추고 패키지가 설치된 후에 과정을 계속 진행해 나갈 것이다. 
<p>

여러분이 기본적으로 할 일은 다음을 실행하는 것이다:

<example>
auto-apt run command
</example>

`command'라는 것은 없을지 모를 파일이 필요한 실행명령이다:

<example>
auto-apt run ./configure
</example>

필요한 패키지들을 설치하도록 요구하고 따라서 자동적으로 apt-get을
호출한다. X를 실행하면 그래픽 인터페이스가 기본 텍스트 인터페이스를
대체할 것이다. 
<p>
Auto-apt은 효율적으로 최신으로 데이타베이스를 유지한다. 이는 다음의
명령을 통해서 가능하다:<tt>auto-apt update</tt>, <tt>auto-apt
updatedb</tt>와 <tt>auto-apt update-local</tt>.
</sect>

<sect id="apt-listchanges">패키지의 변화된 정보를 얻기
<p>
모든 패키지는 자신의 문서
디렉토리(<tt>/usr/share/doc/packagename</tt>)에
<tt>changelog.Debian.gz</tt>라는 파일이 있는데 마지막 버젼이후로
패키지의 변화된 내용을 포함하고 있다. <tt>zless</tt>의 도움을 받아
이러한 파일을 읽을 수 있지만 그리 쉽지는 않고 전체 시스템 업그레이드
하자마자 모든 업그레이드 된 changelog를 찾기 시작한다. 
<p>
이러한 작업을 자동화 해주는 방법이 있는데
<prgn>apt-listchanges</prgn>을 이용하면 된다. 우선은
<package>apt-listchanges</package> 패키지를 우선 설치하고 패키지
설치동안 Debconf가 이를 설정해 줄것이다. 여러분이 원하는대로 질문에
답을 하면 된다. 
<p>
"Should apt-listchanges be automatically run by apt?"라는 것은 매우
유용한데 업그레이드 동안 apt에 의해 설치되는 각 패키지의 변화 목록을
보여주게 해주기 때문이다. 그리고 계속 진행하기 전에 이를 분석하게
해준다. "Should apt-listchanges prompt for confirmation after 
displaying changes?"는 여러분이 변화의 내용을 읽은 후에 설치를 계속할
것인지를 묻기 때문이다. 계속 원하지 않는다고 하면 apt-listchanges를
에러를 apt는 설치를 중단하게 된다. 
<p>
apt-listchanges가 설치된 이후애 apt에 의해서 패키지가 다운로드 되거나
CD에서 가지고 오거나 마운트된 디스크에서 가져오자 마자 설치되기 전에
패키지에 변화된 내용의 리스트를 보여주게 된다. 
</sect>
</chapt>

<chapt id="sourcehandling">소스패키지로 작업하기
<sect id="source">소스 패키지 다운로드 하기
<p>
자유 소프트웨어진영에서는 소스코드를 공부하거나 버그가 있는 코드를
수정하는 것이 일상적인 것이다. 이렇게 하기 위해서는 프로그램의 소스를
우선은 다운로드 받는다. APT 시스템이 소스코드를 디스트리뷰션내에
포함된 많은 프로그램들에 소스코드를 가져오게 해주고 .deb를 만들기
위해서 필요한 모든 파일들을 포함해서 가지고 오게 도와준다. 
<p>
데비안 소스의 다른 일반적인 사용은 프로그램의 좀더 최근의 버젼을
불안정 디스트리뷰션에서 가져와서 안정 디스트리뷰션에서 사용하게 하는
것이다. 안정에서 패키지를 안정버젼에서 컴파일하면 디스트리뷰션에 있는
패키지에 알맞는 의존성을 가지고 .deb를 만들어준다. 
<p>
이렇게 하기 위해서는 <tt>deb-src</tt> 항목을
<tt>/etc/apt/sources.list</tt>에 넣어서 불안정 버젼의 파일을 받게
해주면 된다. 주석을 없애고 사용하면된다. <ref id="sources.list">
부분을 참조하라. 
<p>
소스 패키지를 다운로드 하기 위해서는 다음의 명령을 이용한다:

<example>
apt-get source packagename
</example>
이렇게 하면 세가지 파일을 얻게 되는데: <tt>.orig.tar.gz</tt>,
<tt>.dsc</tt>와 <tt>.diff.gz</tt>. 데비안만을 위한 패키지의 경우에
마지막 파일은 다운로드 되지 않고 첫번째는 이름에 <tt>"orig"</tt>이 없게
됩니다. 
<p>
<tt>.dsc</tt> 파일은 소스 패키지를 <var>패키지버젼</var> 디렉토리 안에
풀 때 dpkg-source에 의해 이용되는 것이다. 각 다운로드된 소스패키지에는
<tt>debian/</tt> 디렉토리가 있는데 .deb 패키지를 만들어주는데 필요한
파일들을 포함하고 있다. 
<p>
다운로드를 하면서 자동적으로 패키지를 빌드하고자 하면 <tt>-b</tt>를
다음과 같이 추가하면 된다:

<example>
apt-get -b source packagename
</example>

다운로드 하면서 .deb를 다운로드 하면서 만들고 싶지 않다면 다음과 같이
나중에 실행하면 된다:

<example>
dpkg-buildpackage -rfakeroot -uc -b
</example>

다운로드후에 패키지를 위해 만들어진 디렉토리에서 하면 된다. 
<p>
<prgn>apt-get</prgn>의 <tt>source</tt>와 다른 방법의 차이는
있다. <tt>source</tt> 방법은 루트 권한 없이도 일반 사용자들이 이용할
수 있다. 파일은 <tt>apt-get source package</tt>를 실행한 디렉토리에
다운로드 된다. 
</sect>

<sect id="build-dep">소스패키지를 컴파일 하는데 필요한 패키지들
<p>
일반적으로 특정 헤더와 공유 라이브러리는 소스패키지를 컴파일하기
위해서 있어야한다. 모든 .deb 패키지들은 control 파일에 소스에서
빌드하여 추가 패키지를 만들 때 필요한 부분을 지칭하는 'Build-Depends:'
필드를 포함하고 있다. 
<p>
APT는 이러한 패키지들을 자동으로 다운로드 해주는 단순한 방법을 갖고
있다. 단지 <tt>apt-get build-dep package</tt>를 실행하면 되는데 여기서
'package'는 여러분이 빌드할 패키지 이름이다. 예를 들면:

<example>
[root]@[/] # apt-get build-dep gmc
Reading Package Lists... Done
Building Dependency Tree... Done
The following NEW packages will be installed:
  comerr-dev e2fslibs-dev gdk-imlib-dev imlib-progs libgnome-dev libgnorba-dev
  libgpmg1-dev 
0 packages upgraded, 7 newly installed, 0 to remove and 1  not upgraded.
Need to get 1069kB of archives. After unpacking 3514kB will be used.
Do you want to continue? [Y/n]
</example>

설치될 패키지들은 빌드할 <package>gmc</package>에 필요한
패키지들이다. 이 명령은 컴파일할 프로그램의 소스 패키지를 찾지는
않는다. <tt>apt-get source</tt>을 실행하여 이를 따로 실행할 수 있다. 
</sect>
</chapt>

<chapt id="distros">APT를 지원하는 디스트리뷰션은?
<p>
APT를 이용한 디스트리뷰션의 이름은 다음과 같다:
<p>
데비안 GNU/리눅스 (<url id="http://www.debian.org" name="http://www.debian.org">) 
- 이는 APT가 개발된 디스트리뷰션이다. 
<p>
Conectiva (<url id="http://www.conectiva.com.br" name="http://www.conectiva.com.br">) 
- 이는 rpm을 사용하여 APT를 포팅한 첫번째 디스트리뷰션이다. 
<p>
Mandrake (<url id="http://www.mandrake.com" name="http://www.mandrake.com">)
<p>
PLD (<url id="http://www.pld.org.pl" name="http://pld.org.pl">)
<p>
Vine (<url id="http://www.vinelinux.org" name="http://www.vinelinux.org">)
</chapt>


<chapt id="erros">에러처리하는 방법
<sect id="erros-comuns">일반적인 에러
<p>
에러는 항상 발생하기 마련인데 대부분의 경우은 주의를 기울이지 않은
사용자들에 의해서 발생한다. 다음의 리스트는 자주 보고되는 에러이며
이를 다루는 방법을 나열하였다. 

<p>
<tt>apt-get install package</tt>을 실행할 때 아래와 같은 메세지를 받게
된다면...


<example>
Reading Package Lists... Done
Building Dependency Tree... Done
W: Couldn't stat source package list 'http://people.debian.org unstable/ Packages' (/var/state/apt/lists/people.debian.org_%7ekov_debian_unstable_Packages) - stat (2 No such file or directory)
W: You may want to run apt-get update to correct these missing files
E: Couldn't find package penguineyes
</example>

이런 경우는 <tt>/etc/apt/sources.list</tt>를 마지막으로 변경한 후에
<tt>apt-get update</tt>를 실행하지 않았다는 것이다. 
<p>
에러는 다음과 같이 나오게 된다:

<example>
E: Could not open lock file /var/lib/dpkg/lock - open (13 Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?
</example>

<tt>source</tt>를 제외한 <prgn>apt-get</prgn> 방법을 이용할 때는 루트
퍼미션이 필요가 없고 그냥 일반 사용자도 가능하다. 
<p>
동시에 <prgn>apt-get</prgn>를 두번 실행할 때 위와 비슷한 에러가
나오는데 <prgn>dpkg</prgn>가 실행되는 동안 <prgn>apt-get</prgn>를
실행하는 경우도 그렇다. 다른 것과 동시에 사용할 수 있는 유일한 방법은
<tt>source</tt> 방법을 이용하는 것이다. 
<p>
프로세스 중간에 설치가 멈추고 더이상 패키지를 설치하거나 제가가
힘들다면 다음의 명령을 실행하라:

<example>
# apt-get -f install
# dpkg --configure -a
</example>

다시 시작해라. 한번 이상 위의 명령의 두번째를 실행할 필요가 있다. 이는
`불안정'을 사용하는 사람들에게는 매우 중요한 교훈이다. 

</sect>

<sect id="help">어디서 도움을 얻을 수 있나?
<p>
의심스런 부분이 생기면 데비안 패키징 시스템에 대한 문서를 참조하면
된다. <tt>--help</tt>와 man 페이지는 여러분에게 많은 도움을 줄것이고
<tt>/usr/share/doc</tt> 디렉토리의 여러가지 문서, 예를 들면
<tt>/usr/share/doc/apt</tt>와 같은 것은 상당히 도움을 많이 줄 것이다. 
<p>
만일 문서가 도움이 안되는 경우라면 데비안 메일링 리스트에서 해답을
찾아라. 데비안 웹사이트에서 특정 사용자 리스트에 관한 정보를 얻을 수
있을 것이다: <url id="http://www.debian.org" name="http://www.debian.org">
<p>
이러한 리스트들과 리소스들이 오직 데비안 사용자들 사이에서만
이용되어야 한다는 것을 명심하라; 다른 시스템 사용자들은 그들의
디스트리뷰션 공동체에서 더 많은 도움을 받을 것이다. 
</sect>
</chapt>

<chapt id="agradecimentos">도움준분들
<p>
데비안-BR 프로젝트의 뛰어난 친구들에게 깊은 감사를 드린다. :)
<p>
우리의 프로젝트를 상당히 많이 도와준 CIPSG에게 감사를 드리며 이러한
생각을 하게해준 많은 자유 프로젝트에 깊은 감사를 드린다. 
<p>

특히 감사할 분들은:
<p>
Yooseong Yang &lt;yooseong@debian.org&gt; - 한국어 번역
<p>
Michael Bramer &lt;grisu@debian.org&gt; - 특정 버젼에 대한 섹션을
포함시키라고 제안해줌. 
<p>
Bryan &lt;Stillwell bryan@bokeoa.com&gt; - 패치와 수정을 많이 보내줌.
<p>
Pawel Tecza  &lt;pawel.tecza@poland.com&gt; - 폴란드어 번역과 다양한
수정을 해줌
<p>
Pablo Lorenzzoni &lt;spectra@debian.org&gt; - netselect에 대한 섹션을
쓰게 도와줌.
<p>
Steve Langasek &lt;vorlon@netexpress.net&gt; - 영어로 번역해줌.
<p>
Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt; - 현재 APT를
포함하고 있는 추가적인 배포본(Mandrake, PLD, Vine)의 목록에 기여함.
<p>
Ross Boylan &lt;RossBoylan@stanfordalumni.org&gt; - 패치와 수정을 많이 보내줌.
</chapt>

<chapt id="novas">이 튜토리얼의 새버젼
<p>
<url id="http://debian-br.sourceforge.net" name="Debian-BR">
프로젝트에서 이문서는 만들어졌고 데비안 사용자에게 도움을 주고자
했다. 
<p>
이 문서의 새버젼은 프로젝트의 홈페이지 <url
id="http://debian-br.sourceforge.net/documentacao.html"
name="http://debian-br.sourceforge.net/documentacao.html">에서 구할 수
있다. 
<p>
조언과 수정과 같은 것을 직접 <email>kov@debian.org</email>로 이메일로
보내주기 바란다. 
</chapt>

</book>

