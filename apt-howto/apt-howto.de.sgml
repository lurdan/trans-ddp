<!doctype debiandoc system>
<debiandoc>

<book>

<title>APT HOWTO</title>

<author>
<name>Gustavo Noronha Silva</name> <email>kov@debian.org</email>
</author>
<author>
<name>Deutsche Übersetzung: David Spreen</name> <email>netzwurm@debian.org</email>
</author>

<version>1.8.1 - Oktober 2002</version>

<abstract>
Dieses Dokument soll dem Benutzer ein gutes Verständnis für die
Arbeitsweise des Debian Paket Management Werkzeugs APT liefern.
Ziel ist es das Leben für neue Debian Benutzer zu erleichtern und
denen zu helfen, die ihr Verständnis für die Administration dieses
Systems vertiefen wollen. Es wurde für das Debian Projekt geschaffen,
um den verfügbaren Support für Benutzer dieser Distribution zu erweitern.
</abstract>

<copyright>
<copyrightsummary>
Copyright &copy; 2001, 2002 Gustavo Noronha Silva
</copyrightsummary>
<copyrightsummary>
Copyright &copy; Deutsche Übersetzung 2002 David Spreen
</copyrightsummary>
<p>
Diese Anleitung ist lizenziert durch die Richtlinien der GNU FDL (Free 
Documentation License). Sie wurde geschrieben in der Hoffnung, dass es 
für die Community von Nutzen ist, aber kommt ohne Garantie; die Benutzung
erfolgt auf eigenes Risiko.
</copyright> 

<toc>

<chapt id=trans>Zur Deutschen Übersetzung

<sect id=vorwort>Vorwort
<p>
Der Text dieser Übersetzung hat das Ziel sich möglichst eng an der 
englischen Übersetzung zu orientieren. Leider lassen sich einige Fachbegriffe
schlecht übersetzen. Diese Begriffe habe ich versucht entweder sinnvoll
einzudeutschen oder als englisches Wort zu übernehmen. Alle diese Begriffe 
werden im unten stehenden Glossar kurz erläutert.
</sect>

<sect id=glossar>Glossar
<p>
Die Begriffe sind hier in der Reihenfolge aufgelistet, in der sie 
im Text auftauchen.
<list>
<item><em>Kompilieren</em> (eingedeutscht): Das Übersetzen des 
Programmquelltextes in ein für den Computer ausführbares Programm.

<item><em>Paket</em> (eingedeutscht): Hier Sammlung von Dateien
die meist ein vorkompiliertes und konfiguriertes Programm enthält,
welches sich mit einem Paketverwaltungsprogramm installieren
lässt.

<item><em>Portieren</em> (eingedeutscht): Das verändern eines Programms
um es auf einem anderen System oder einer anderen Architektur benutzen
zu können.

<item><em>Update</em>: Aktualisieren von Informationen oder Software
um sie auf dem neusten Stand zu halten, wobei Paket-Updates bei APT
"Upgrade" heißen. Verwirrenderweise heißen Paketupgrades aufgrund von
Sicherheitslücken bei Debian allerdings "Sicherheits-Updates".

<item><em>Mirror</em>: Eine exakte Kopie eines Web oder FTP-Servers,
die dazu dient, den Originalserver zu entlasten. Die Liste der
Debian Mirrors gibt es auf http://www.debian.org/distrib/ftplist.

<item><em>Upgrade</em>: Sehen Sie Update. Hierbei handelt es sich um
das Aktualisieren von Paketen.

<item><em>Ncurses</em>: Programmbibliothek um auf der Konsole
Fenster, Menüs usw. darzustellen.

<item><em>MTA</em>: Mail Transport Agent - Programm zum transportieren von
Emails, oft auch Mailserver.

<item><em>Manpage</em>: Anleitung für ein Programm, welche auf der 
Kommandozeile per "man Programmname" verfügbar ist.

<item><em>Lock-Datei</em>: Datei deren Existenz anzeigt, dass ein Resource (z.B. die
APT Datenbank) zur Zeit genutzt wird.
</list>
</sect>
</chapt> 

<chapt>Einführung
<p>
Am Anfang war das .tar.gz. Benutzer mussten jedes Programm, welches sie
auf ihren GNU/Linux Systemen benutzen wollten selbst kompilieren. 
Zu Beginn der Entwicklung des Debian Projekts erachtete man es für notwendig,
dass das System eine Methode zum Verwalten der Pakete, die auf dem System 
installiert sind, beinhaltet. Man gab diesem System den Namen <prgn>dpkg</prgn>.
Dadurch war das erste 'Paket' auf GNU/Linux geboren, bevor Red Hat sich 
entschied ihr eigenes `rpm' System zu erschaffen.
<p>
Schnell standen die Macher von GNU/Linux vor einem neuen Problem.
Sie brauchten ein schnelles, praktisches und effizientes Mittel um 
Pakete zu installieren, dass Abhängigkeiten automatisch behandeln und 
ihre Konfigurationsdateien während des Aktualisierens berücksichtigen würde.
Und wieder war es das Debian Projekt, das den Weg machte und APT, das "Advanced 
Packaging Tool", welches seitdem von Connectiva auf RPM portiert und von 
einigen anderen Distributionen übernommen wurde, das 
Licht der Welt erblicken lies. 
<p>
Diese Anleitung versucht nicht apt-rpm (den Connectiva Port von APT) 
zu behandeln, aber Patches für dieses Dokument, welche es tun
sind willkommen.
</chapt>

<chapt id="basico">Basis Konfiguration

<sect id="sources.list">Die /etc/apt/sources.list Datei
<p>
Als Teil seiner Arbeit benutzt APT eine Datei, die die 'Quellen' von 
denen man Pakete beziehen kann auflistet. Diese Datei heißt 
<tt>/etc/apt/sources.list</tt>.
<p>
Die einträge in dieser Datei sind von folgendem Format:

<example>
deb http://site.http.org/debian distribution sektion1 sektion2 sektion3
deb-src http://site.http.org/debian distribution sektion1 sektion2 sektion3
</example>

Natürlich sind obige Einträge erfunden und sollten nicht benutzt werden.
Das erste Wort jeder Zeile, <tt>deb</tt> oder <tt>deb-src</tt> zeigt den
Typen des Archivs: entweder es enthält Binary Pakete (<tt>deb</tt>), das sind
die vorkompilierten Pakete, die wir normalerweise benutzen, oder Quellpakete
(<tt>deb-src</tt>), welche die originalen Programm Quellen und die Debian
Kontrolldatei (<tt>.dsc</tt>) und das <tt>diff.gz</tt> welches die Änderungen
enthält, die für das 'Debianisieren' des Programms von Nöten sind.
<p>
Normalerweise finden wir folgendes in der standard Debian sources.list:
<example>
# See sources.list(5) for more information, especialy
# Remember that you can only use http, ftp or file URIs
# CDROMs are managed through the apt-cdrom tool.
deb http://http.us.debian.org/debian stable main contrib non-free
deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
deb http://security.debian.org stable/updates main contrib non-free

# Uncomment if you want the apt-get source function to work
#deb-src http://http.us.debian.org/debian stable main contrib non-free
#deb-src http://non-us.debian.org/debian-non-US stable non-US
</example>

Dieses sind die Zeilen, die eine Debian Basis Installation benötigt.  
Die erste <tt>deb</tt> Zeile zeigt auf das offizielle Archiv, die 
Zweite auf das non-US Archiv und die Dritte auf das Archiv der Debian
Sicherheits-Updates.
<p>
Die letzten beiden Zeilen sind auskommentiert (mit einem `#' am Anfang). 
Deshalb wird apt-get sie ignorieren. Sie sind <tt>deb-src</tt> Zeilen, das 
bedeutet, sie führen uns zu Debian Quellpaketen. Wenn sie öfters 
Programm-Quellen herunterladen um sie zu testen oder neu zu kompilieren, 
sollten sie die Kommentarzeichen entfernen. 
<p>
Die <tt>/etc/apt/sources.list</tt> Datei kann verschiedene Typen von
Zeilen enthalten. APT kann mit Archiven der Typen <tt>http</tt>, <tt>ftp</tt>,
<tt>file</tt> (lokale Dateien, u.B. ein Verzeichnis, mit einem gemounteten 
ISO9660 Dateisystem) und <tt>ssh</tt>, soweit ich weiß.
<p>
Vergessen Sie nicht <tt>apt-get update</tt> auszuführen, nachdem
die <tt>/etc/apt-/sources.list</tt> editiert wurde. Dies ist notwendig,
damit APT die Paketlisten der spezifizierten Quellen bezieht.
</sect>

<sect id="dpkg-scanpackages">Wie man APT lokal benutzt
<p>
Manchmal haben Sie vielleicht einige .deb, bei denen Sie APT für die 
Installation benutzen wollen, so dass Abhängigkeiten automatisch 
aufgelöst werden.
<p>
Um das zu tun, erstellen Sie ein Verzeichnis und legen die .debs,
die Sie sie indizieren wollen, dort hinein. Zum Beispiel:
<example>
mkdir /root/debs/
</example>
Nun legen Sie innerhalb des Verzeichnisses /root eine leere
Datei mit irgendeinem Namen an. 
Ein Apt Archiv (Repository) braucht eine "override"-Datei, die
leer sein darf, aber existieren muss. Man könnte das folgende
Kommando benutzen um sie zu erstellen:
<example>
touch Datei
</example>
In dieser Datei können Sie einige Optionen definieren, die die 
paketeigenen Optionen Überschreiben. 
Das Format sieht folgender Maßen aus:
<example>
Paket Priorität Sektion
</example>
Paket ist der Name des Pakets, die Priorität ist "low" (niedrig),
"medium" (mittel) oder "high" (hoch) und die Sektion ist die 
Sektion zu der das Paket gehört.
Es reicht aber, diese Datei leer zu lassen.
<p>
Immernoch im /root Verzeichnis führen Sie folgendes aus:
<example>
dpkg-scanpackages debs Datei | gzip > debs/Packages.gz
</example>
In der obenstehenden Zeile ist Datei die "override"-Datei,
das Kommando generiert eine Datei debs/Packages.gz, welche 
verschiedene Informationen über die Pakete enthält, die APT
benötigt. Um die Pakete benutzen zu können, fügen sie folgendes der
<tt>/etc/sources.list</tt> hinzu:
<example>
deb file:/root debs/
</example>
Nachdem Sie das getan haben können sie einfach die gewöhnlichen
APT Kommandos benutzen. Sie können ebenfalls ein Quellarchiv
erstellen. Die Prozedur ist die selbe, aber die Dateien
<tt>.orig.tar.gz</tt>, <tt>.dsc</tt> und <tt>.diff.gz</tt> müssen sich
in dem Verzeichnis befinden und statt Packages.gz heißt es hier 
Sources.gz. Außerdem müssen Sie ein anderes Programm benutzen. Es heißt 
<prgn>dpkg-scansources</prgn>. Das Kommando sieht folgendermaßen aus:
<example>
dpkg-scansources debs | gzip > debs/Sources.gz
</example>
<prgn>dpkg-scansources</prgn> braucht keine "override"-Datei.
Die Zeile in der sources.list lautet:
<example>
deb-src file:/root debs/
</example>
</sect>

<sect id="netselect">Entscheidung - Welcher Mirror ist der beste für die sources.list: netselect, netselect-apt <p>
Eine häufige Frage, meistens der neueren Benutzer ist: "Welchen Debian
Mirror soll ich in die <tt>sources.list</tt> eintragen?". Es gibt
viele Wege sich für einen Mirror zu entscheiden. Die fortgeschritteneren
Benutzer haben
möglicherweise ein Script welches den Ping mehrerer Mirrors vergleicht.
Aber es gibt so ein Programm inzwischen auch für weniger erfahrene Benutzer: 
<strong>netselect</strong>.
<p>
Installieren tut man netselect wie alles:
<example>
apt-get install netselect
</example>
Wenn man es ohne Parameter ausführt zeigt es seine Hilfe. Führt man es
mit einer durch Leerzeichen separierten Liste von Hostnamen (Mirrors)
aus, gibt es uns einen Hostnamen zusammen mit der einer Punktzahl 
zurück. Diese Punktzahl berücksichtigt die erwarteten Pingzeit und 
die Zahl der Hops (Rechner die eine Netzwerkanfrage passiert um ihren
Zielort zu erreichen) und ist antiproportional zur erwarteten 
Downloadgeschwindigkeit (also je niedriger desto besser). 
Angezeigt wird nur der Host mit der niedrigsten Punktzahl (Die ganze Liste der
Mirrors kann mit der Option -vv angesehen werden). Zum Beispiel: <example>
bash$ netselect ftp.debian.org http.us.debian.org ftp.at.debian.org download.unesp.br ftp.debian.org.br
  365 ftp.debian.org.br
bash$
</example>
Das bedeutet, dass von den Mirrors die als Parameter an netselect 
übergeben wurden <tt>ftp.debian.org.br</tt> der beste war mit einer
Punktzahl von 365. (Achtung!! Weil es auf meinem Computer ausgeführt wurde
und die Netzwerktopographie extrem unterschiedlich und abhängig vom 
Standort des Computers ist, ist dieser Wert nicht notwendiger Weise 
die richtige Geschwindigkeit für andere Computer.
<p>
Jetzt tragen Sie einfach den schnellsten Mirror in die 
<tt>/etc/apt/sources.list</tt> ein (sehen Sie <ref id="sources.list">)
und befolgen Sie die Tipps in <ref id="apt-get">.
<p> <strong>Hinweis:</strong> Die Liste der Mirrors ist immer auf
<url id="http://www.debian.org/mirror/mirrors_full"
name="http://www.debian.org/mirror/mirrors_full"> zu finden. <p>
Ab Version 0.3 enthält das netselect-Paket das 
<strong>netselect-apt</strong> Script, das obigen Prozess automatisiert.
Übergeben Sie einfach die Distribution als Parameter (Der Defaultwert ist
stable) und die <tt>sources.list</tt> wird mit den besten main und non-US
Mirrors generiert und im aktuellen Verzeichnis gespeichert. Das folgende 
Beispiel generiert eine sources.list für die stable Distribution:
<example>
bash$ ls sources.list
ls: sources.list: File or directory not found
bash$ netselect-apt stable
(...)
bash$ ls -l sources.list
sources.list
bash$
</example>
<strong>Hinweis:</strong> Die <tt>sources.list</tt> wird im aktuellen
Verzeichnis erzeugt und muss nach <tt>/etc/apt</tt> verschoben werden.
<p>
Danach befolgen Sie die Tipps in <ref id="apt-get">.
</sect>

<sect id="cdrom">Hinzufügen einer CD-ROM in die sources.list
<p>
Wenn Sie lieber eine CD-ROM zum Installieren von Paketen oder Updaten
ihres Systems durch APT verwenden möchten, können Sie sie in ihre
<tt>sources.list</tt> eintragen.
Um dieses zu tun können Sie das Programm <prgn>apt-cdrom</prgn>
wie im Folgenden beschrieben benutzen:

<example>
apt-cdrom add
</example>

Hierfür muss die Debian CD-ROM im Laufwerk liegen. Die CD-ROM wird
gemountet und wenn sie eine gültige Debian CD ist, wird nach 
Paketinformationen gesucht. Wenn Ihre CD-ROM Konfiguration ein
wenig ungewöhnlich ist, können Sie die folgenden Optionen benutzen: 

<example>
-h           - program help
-d directory - CD-ROM mount point
-r           - Rename a recognized CD-ROM
-m           - No mounting
-f           - Fast mode, don't check package files
-a           - Thorough scan mode
</example>

Zum Beispiel:

<example>
apt-cdrom -d /home/kov/mycdrom add
</example>

Eine CD kann auch identifiziert werden ohne sie zur sources.list hinzuzufügen:

<example>
apt-cdrom ident
</example>

Obiges funktioniert nur, wenn das CD-ROM Laufwerk in der
<tt>/etc/fstab</tt> korrekt konfiguriert ist. 
</sect>

</chapt>


<chapt id="apt-get">Paketverwaltung
<sect id="update">Update der Liste der verfügbaren Pakete
<p>
Das Paketsystem benutzt eine private Datenbank mit Informationen
über installierte, nicht installierte und für eine Installation verfügbare
Pakete.
Das Programm <prgn>apt-get</prgn> benutzt diese Datenbank um herauszufinden,
wie es die vom Benutzer angeforderten Pakete installieren soll und
welche zusätzlichen Pakete benötigt werden, damit die ausgewählten
Pakete ordentlich funktionieren.
<p>
Um diese Liste zu updaten benutzt man das Kommando <prgn>apt-get update</prgn>.
<prgn>apt-get</prgn> sucht dann nach den Paketlisten in den Archiven aus der 
<tt>/etc/apt/sources.list</tt>; sehen Sie <ref id="sources.list"> für 
weiter Informationen über diese Datei. 
<p>
Es ist eine gute Idee dieses Kommando regelmäßig auszuführen um sich 
selbst und sein System auf dem neusten Stand über mögliche Paket bzw.
Sicherheitsupdates zu halten.
</sect>

<sect id="install">Installieren von Paketen
<p>
Endlich kommt das worauf Sie alle gewartet haben! Mit der fertigen 
sources.list und der Liste der verfügbaren Pakete auf dem neusten Stand ist
alles was Sie zu tun haben <tt>apt-get</tt> auszuführen um das gewollte 
Paket zu installieren. Zum Beispiel:

<example>
apt-get install xchat
</example>

APT durchsucht seine Datenbank nach der aktuellsten Version dieses Paketes und
holt es aus dem entsprechenden Archiv, welches in der <tt>sources.list</tt>
spezifiziert ist.
Wenn es eintritt, dass das Paket von einem anderen abhängt -- wie es hier
der Fall ist -- überprüft APT die Abhängigkeiten und installiert die benötigten
Pakete. Sehen Sie folgendes Beispiel:

<example>
[root]@[/] # apt-get install nautilus
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 0 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 17.2MB will be used.
Do you want to continue? [Y/n] 
</example>

Das Paket <package>nautilus</package> benötigt die genannten Bibliotheken 
(bonobo libmedusa0 libnautilus0), deshalb holt APT sie aus dem Archiv.
Übergibt man <tt>apt-get</tt> die Namen der Bibliotheken beim Aufruf mit, fragt
es nicht, ob es fortfahren soll, es akzeptiert automatisch, dass die genannten Pakete
installiert werden sollen.
<p>
Das bedeutet, dass APT nur um Bestätigung bittet, wenn es Pakete 
installieren muss, die man nicht auf der Kommandozeile übergeben hat.
<p>
Die folgenden Optionen von apt-get können hilfreich sein:

<example>
-h  Dieser Hilfetext
-d  Nur herunterladen - Nicht installieren oder entpacken
-f  Versuche fortzufahren wenn der integrity check fehlschlägt
-s  Nichts wirklich tun. Simulation durchführen.
-y  Beantworte alle Fragen mit Ja anstatt sie zu stellen.
-u  Zeige eine Liste der Pakete die geupgraded werden.
</example>

Es können mehrere Pakete in einer Zeile zur Installation
ausgewählt werden.
Pakete, die über das Netzwerk oder Internet heruntergeladen
wurden werden im Verzeichnis <tt>/var/cache/apt/archives</tt>
für spätere Installationen gespeichert. 
<p>
Ebenfalls kann man Pakete zum Entfernen auf der gleichen Zeile angeben,
indem man ein '-' direkt hinter den Paketnamen hängt wie im Folgenden:

<example>
[root]@[/] # apt-get install nautilus gnome-panel-       
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n] 
</example>

Sehen Sie die Sektion <ref id="remove"> für weitere Details zum entfernen von Paketen.
<p>
Wenn Sie ein installiertes Paket irgendwie beschädigt haben oder einfach
die Dateien eines Paketes mit der aktuellsten verfügbaren Version neu 
installieren möchten, können Sie die Option <tt>--reinstall</tt> 
wie im Folgenden nutzen: 

<example>
[root]@[/] # apt-get --reinstall install gdm
Reading Package Lists... Done
Building Dependency Tree... Done
0 packages upgraded, 0 newly installed, 1 reinstalled, 0 to remove and 1  not upgraded.
Need to get 0B/182kB of archives. After unpacking 0B will be used.
Do you want to continue? [Y/n]
</example>

Die Version des APT, was zur Erstellung dieser Anleitung benutzt wurde ist
Version 0.5.3, die aktuelle Version in Debian `unstable' (<tt>sid</tt>)
zur Zeit als sie geschrieben wurde.
Wenn diese Version installiert ist, kann APT auf ihren Wunsch noch mehr:
Sie können ein Kommando der Form <tt>apt-get install paket/distribution</tt>
benutzen um ein Paket einer anderen Distribution zu installieren, oder 
<tt>apt-get install package=version</tt>. Zum Beispiel:

<example>
apt-get install nautilus/unstable
</example>

Dies installiert nautilus aus der Distribution unstable auch, wenn
die aktuell laufende Distribution `stable' ist.
Mögliche Werte für 'distribution' sind 
<tt>stable</tt>, <tt>testing</tt>, und <tt>unstable</tt>.
<p>
Meistens ist es besser die Option <tt>-t</tt> zu benutzen, um eine 
Distribution zu wählen, was dazu führt, dass <prgn>apt-get</prgn>
diese Distribution beim auflösen von Abhängigkeiten bevorzugt.
<p>
<em>WICHTIG</em>: Die `unstable' Version von Debian ist die Version,
in welcher neue Versionen von Debian Paketen zuerst erscheinen. Diese
Distribution sieht alle Änderungen, die an Paketen vorgenommen werden,
kleinere und größere, welche mehrere Pakete oder das ganze System 
betreffen können. Aus diesem Grund sollte sie <em>nicht</em> von unerfahrenen 
Benutzern oder solchen, die geprüfte Stabilität brauchen verwendet 
werden. 

<p>
Die `testing' Distribution ist ein wenig besser als `unstable' was Stabilität 
angeht, jedoch sollte für Produktionssysteme die Distribution `stable' 
benutzt werden.
</sect>

<sect id="remove">Pakete entfernen
<p>
Wenn ein Paket nicht mehr gebraucht wird, kann es mit APT 
vom System entfernt werden.
Geben Sie einfach <tt>apt-get remove package</tt> ein.
Zum Beispiel:

<example>
[root]@[/] # apt-get remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n] 
</example>

Wie im obigen Beispiel zu sehen ist, kümmert sich APT ebenfalls um das 
Entfernen der Pakete, die das Paket was Sie entfernen wollen benötigen.
Es gibt keine Möglichkeit Pakete mit APT zu entfernen ohne die Pakete
zu entfernen, die von dem entfernten Paket abhängen.
<p>
Wenn man <prgn>apt-get</prgn> ausführt wie oben angegeben, werden die Pakete
entfernt, aber die Konfigurationsdateien, falls es welche gibt, bleiben auf
dem System.
Für eine komplette Entfernung der Pakete, sehen Sie folgendes Beispiel:

<example>
[root]@[/] # apt-get --purge remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n] 
</example>

Der '*' hinter den Namen der Pakete, die vom zu entfernenden Paket
abhängen bedeutet, dass deren Konfigurationsdateien ebenso 
entfernt werden.
<p>
Genau wie bei der Methode <tt>install</tt> kann man auch bei 
<tt>remove</tt> ein Symbol benutzen um die Wirkung für ein einzelnes
Paket umzukehren. Hier fügt man einem Paket ein <tt>'+'</tt> zu und
das Paket wird installiert anstatt entfernt zu werden. 

<example>
[root]@[/] # apt-get --purge remove gnome-panel nautilus+
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n] 
</example>

<prgn>apt-get</prgn> listet die Pakete die extra installiert werden (die
die gebraucht werden damit das Programm einwandfrei funktionieren kann),
die die entfernt werden und die die installiert werden (hier werden die extra
Pakete noch einmal mit aufgelistet).
</sect>

<sect id="upgrade">Upgrade von Paketen
<p>
Das aktualisieren von Paketen ist eine tolle Sache mit APT.  Es braucht 
dafür nur einen einzigen Befehl: <tt>apt-get upgrade</tt>. Man kann
dieses benutzen um Pakete aus der gleichen Distribution zu aktualisieren,
oder aus einer neuen Distribution, obwohl für letzteres 
<tt>apt-get dist-upgrade</tt> empfehlenswerter ist; sehen Sie Sektion
<ref id="dist-upgrade"> für weitere Einzelheiten.
<p>
Es macht Sinn diesen Befehl mit der Option <tt>-u</tt> auszuführen.
Diese Option lässt APT die komplette Liste der Pakete anzeigen,
die aktualisiert werden sollen. Ohne diese Option aktualisiert man quasi 
blind. APT lädt die aktuellsten Versionen aller Pakete herunter und
installiert Sie in der richtigen Reihenfolge. Es ist wichtig, dass vor
jedem Aktualisieren der Pakete <tt>apt-get update</tt> ausgeführt wird.
Sehen Sie Sektion <ref id="update">. Zum Beispiel:

<example>
[root]@[/] # apt-get -u upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages have been kept back
  cpp gcc lilo 
The following packages will be upgraded
  adduser ae apt autoconf debhelper dpkg-dev esound esound-common ftp indent
  ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0 libesd0-dev
  libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev liborbit0
  libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit procps psmisc 
29 packages upgraded, 0 newly installed, 0 to remove and 3 not upgraded.
Need to get 5055B/5055kB of archives. After unpacking 1161kB will be used.
Do you want to continue? [Y/n] 
</example>

Das ganze ist extrem einfach. Die ersten paar Zeilen sagen, dass einige
Pakete zurückgehalten werden (have been <tt>kept back</tt>). Das Bedeutet, 
dass es neuere Versionen dieser Pakete gibt, die aus irgend einem Grund
nicht installiert werden. Mögliche Gründe sind unerfüllbare Abhängigkeiten
(z.B. wenn ein Paket von dem das neue Paket abhängt nicht im Archiv
verfügbar ist) oder neue Abhängigkeiten (das Paket hängt nun von
neuen Paketen ab). 
<p>
Es gibt keine "saubere" Lösung für das erste Problem. Für den zweiten
Fall kann man <tt>apt-get install</tt> für das spezielle Paket 
ausführen was zurückgehalten wurde, da dann auch die Abhängigkeiten 
aufgelöst werden. Eine noch sauberere Lösung ist es <tt>dist-upgrade</tt>
zu benutzen. Sehen Sie Sektion <ref id="dist-upgrade">.
</sect>

<sect id="dist-upgrade">Upgrade einer Debian Version
<p>
Diese Funktion erlaubt es ein ganzes Debian System entweder über das
Internet oder von einer neuen CD (die Sie kaufen oder aus dem Internet
herunterladen können) auf einmal zu aktualisieren.
<p>
Außerdem macht es Sinn, wenn an den Abhängigkeiten zwischen den Paketen 
Änderungen vorgenommen wurden. Mit <tt>apt-get upgrade</tt> werden solche
Pakete nicht installiert (sie werden auf dem derzeitigen Stand gehalten 
<tt>kept back</tt>).
<p>
Wenn auf ihrem System z.B. Revision 0 der stable Version von Debian läuft
und Sie sich Revision3 auf CD kaufen, können Sie APT benutzen um ein Upgrade
auf die neue Version von CD durchzuführen.
Dafür benutzen Sie <prgn>apt-cdrom</prgn> (sehen Sie Sektion <ref id="cdrom">)
um die CD zu Ihrer <tt>/etc/apt/sources.list</tt> hinzuzufügen und führen
Sie <tt>apt-get dist-upgrade</tt> aus.
<p>
Es ist wichtig zu wissen, dass APT immer nach der aktuellsten Version 
eines Pakets sucht. Wenn also ihre <tt>/etc/apt/sources.list</tt> auf ein
Archiv zeigt, dass eine neuere Version eines Pakets enthält als sich
auf der CD befindet, lädt APT das Paket aus diesem herunter.
<p>
In dem Beispiel aus Sektion <ref id="upgrade"> sehen wir, dass manche Pakete 
nicht aktualisiert wurden (<tt>kept back</tt>). Wir werden dieses Problem nun 
mit der Funktion <tt>dist-upgrade</tt> lösen:

<example>
[root]@[/] # apt-get -u dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following NEW packages will be installed:
  cpp-2.95 cron exim gcc-2.95 libident libopenldap-runtime libopenldap1
  libpcre2 logrotate mailx 
The following packages have been kept back
  lilo 
The following packages will be upgraded
  adduser ae apt autoconf cpp debhelper dpkg-dev esound esound-common ftp gcc
  indent ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0
  libesd0-dev libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev
  liborbit0 libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit
  procps psmisc 
31 packages upgraded, 10 newly installed, 0 to remove and 1 not upgraded.
Need to get 0B/7098kB of archives. After unpacking 3118kB will be used.
Do you want to continue? [Y/n]
</example>

Hier ist zu bemerken, dass die Pakete aktualisiert werden, aber neue Pakete
(neue Abhängigkeiten der aktualisierten Pakete) zusätzlich installiert werden.
Weiterhin wird lilo immernoch nicht aktualisiert, es gibt möglicherweise 
schwerwiegendere Probleme mit diesem Paket. Wir können das Prüfen, in dem wir
folgendes ausführen:

<example>
[root]@[/] # apt-get -u install lilo
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be REMOVED:
  debconf-tiny 
The following NEW packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be upgraded
  lilo 
1 packages upgraded, 9 newly installed, 1 to remove and 31 not upgraded.
Need to get 225kB/1179kB of archives. After unpacking 2659kB will be used.
Do you want to continue? [Y/n]
</example>

Hier erfahren wir, dass das neue lilo einen Konflikt mit dem Paket 
<package>debconf-tiny</package> hat, was bedeutet, dass wir es nicht
installieren (oder aktualisieren) können, ohne debconf-tiny zu
entfernen.
<p>
Um herauszufinden, wovon ein Paket zurückgehalten oder entfernt wird, 
können Sie folgendes tun:

<example>
# apt-get -o Debug::pkgProblemResolver=yes dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Starting
Starting 2
Investigating python1.5
Package python1.5 has broken dep on python1.5-base
  Considering python1.5-base 0 as a solution to python1.5 0
  Holding Back python1.5 rather than change python1.5-base
Investigating python1.5-dev
Package python1.5-dev has broken dep on python1.5
  Considering python1.5 0 as a solution to python1.5-dev 0
  Holding Back python1.5-dev rather than change python1.5
 Try to Re-Instate python1.5-dev
Done
Done
The following packages have been kept back
  gs python1.5-dev 
0 packages upgraded, 0 newly installed, 0 to remove and 2  not upgraded.
</example>

Auf diesem Wege ist es einfach festzustellen, dass das python1.5-dev Paket 
wegen einer ungelösten Abhängigkeit zu python1.5 nicht installiert werden 
kann.

</sect>

<sect id="clean">Ungenutzte Pakete entfernen: apt-get clean and autoclean    
<p>   
Wenn ein Paket installiert werden soll, bezieht APT von den Quellen,
die in der /etc/apt/sources.list aufgelistet sind die nötigen Dateien,
legt sie in ein lokales Archiv (<file>/var/cache/apt/archives/</file>) und
fährt mit der Installation fort. (sehen Sie <ref id="install">).
<p>
Nach und nach kann dieses lokale Archiv immer größer werden und eine Menge
Platz auf der Festplatte belegen. Auch für diesen Fall bietet APT Werkzeuge
um sein lokales Archiv zu warten:
<prgn>apt-get</prgn>s <tt>clean</tt> und <tt>autoclean</tt> Methoden.
<p>
<prgn>apt-get clean</prgn> entfernt alles bis auf Lock-Dateien (sehen Sie <ref id="glossar">)
aus <file>/var/cache/apt/archives/</file> und <file>/var/cache/apt/archives/partial/</file>.
In der Folge muss APT ein Paket das Sie erneut installieren wollen auch erneut herunterladen.
<p>
<prgn>apt-get autoclean</prgn> entfernt nur Pakete, die nicht mehr heruntergeladen
werden können.
<p>
Das folgende Beispiel sollte zeigen, wie apt-get autoclean arbeitet:
T
<example>
# ls /var/cache/apt/archives/logrotate* /var/cache/apt/archives/gpm*
logrotate_3.5.9-7_i386.deb
logrotate_3.5.9-8_i386.deb
gpm_1.19.6-11_i386.deb
</example>

In /var/cache/apt/archives liegen zwei Versionen des Pakets
<package>logrotate</package> und eine Version des Pakets 
<package>gpm</package>.

<example>
# apt-show-versions -p logrotate
logrotate/stable uptodate 3.5.9-8
# apt-show-versions -p gpm
gpm/stable upgradeable from 1.19.6-11 to 1.19.6-12
</example>
<prgn>apt-show-versions</prgn> shows that
<file>logrotate_3.5.9-8_i386.deb</file> provides the up to date version
of <package>logrotate</package>, so
<file>logrotate_3.5.9-7_i386.deb</file> is useless. Also
<file>gpm_1.19.6-11_i386.deb</file> is useless because a more recent
version of the package can be retrieved.

<example>
# apt-get autoclean
Reading Package Lists... Done
Building Dependency Tree... Done
Del gpm 1.19.6-11 [145kB]
Del logrotate 3.5.9-7 [26.5kB]
</example>

<tt>apt-get autoclean</tt> entfernt also nur die alten Pakete.
Für weitere Informationen über apt-show-versions sehen Sie 
<ref id="apt-show-versions">.
</sect>

<sect id="dselect-upgrade">APT unter dselect verwenden...
<p>
<prgn>dselect</prgn> ist ein Programm, dass Debianbenutzern hilft zu installierende
Pakete auszuwählen. Viele halten es für zu kompliziert und vielmehr langweilig, aber
mit ein wenig Übung kann man durchaus gefallen an seiner Konsolen-basierten 
ncurses-Oberfläche finden.
<p>
Eine Stärke von dselect ist es, dass es mit den Möglichkeiten umgehen kann,
die Debian Pakete haben um andere Pakete zu empfehlen ("suggesting") oder 
vorzustellen ("recommending").
Um es zu benutzen rufen Sie <tt>`dselect'</tt> als root auf.
Wählen Sie 'apt' als Zugriffsmethode. Das ist zwar nicht dringen
notwendig, aber wenn Sie keine CD-ROM benutzen und Pakete aus dem
Internet herunterladen möchten, ist es der beste Weg.
<p>
Um ein besseres Verständnis über die Benutzung von dselect zu erhalten
lesen Sie die Dokumentation auf der Debian Homepage
<url id="http://www.debian.org/doc/ddp" name="http://www.debian.org/doc/ddp">.
<p>
Nachdem Sie ihre Auswahl mit deselect getroffen haben benutzen Sie folgendes
Kommando

<example>
apt-get -u dselect-upgrade
</example>

wie im folgenden Beispiel:

<example>
[root]@[/] # apt-get -u dselect-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  lbxproxy 
The following NEW packages will be installed:
  bonobo console-tools-libs cpp-3.0 enscript expat fingerd gcc-3.0
  gcc-3.0-base icepref klogd libdigest-md5-perl libfnlib0 libft-perl
  libgc5-dev libgcc300 libhtml-clean-perl libltdl0-dev libsasl-modules
  libstdc++3.0 metamail nethack proftpd-doc psfontmgr python-newt talk tidy
  util-linux-locales vacation xbill xplanet-images 
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 30 newly installed, 1 to remove and 0  not upgraded.
Need to get 7140kB of archives. After unpacking 16.3MB will be used.
Do you want to continue? [Y/n]
</example>

Im Vergleich: apt-get dist-upgrade auf dem selben System:

<example>
[root]@[/] # apt-get -u dist-upgrade   
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 0 newly installed, 0 to remove and 0  not upgraded.
Need to get 421kB of archives. After unpacking 25.6kB will be freed.
Do you want to continue? [Y/n]
</example>

Viele der Pakete im oberen Beispiel werden installiert weil andere Pakete
sie "empfehlen ("suggest" or "recommend"). Andere werden aufgrund unserer 
Auswahl, die wir beim Navigieren durch die Paketlisten von dselect
getroffen haben, installiert oder entfernt (Im Falle von lbxproxy z.B.).
Dselect kann in Verbindung mit APT ein nützliches Werkzeug sein. 
</sect>

<sect id="default-version">Wartung eines "gemischten" Systems
<p>
Viele benutzen die "testing" Distribution, da sie stabiler ist als
"unstable" und aktueller als "stable ist. Benutzer, die
aktuelle Versionen von Paketen wollen, sich aber nicht trauen ihr ganzes
System auf "unstable" umzustellen haben die Möglichkeit 
"testing" und "unstable" zu mischen. Auf der anderen Seite möchten 
konservativere
Benutzer vielleicht "stable" und "testing" mischen.
<p>
Für diesen Zweck muss die folgende Zeile in die <file>/etc/apt/apt.conf</file>
eingefügt werden:

<example>
APT::Default-Release "testing";
</example>

<p>
Um nun Pakete aus unstable zu installieren muss die 
<tt>-t</tt> Option benutzt werden:

<example>
# apt-get -t unstable install <var>Paketname</var>
</example>

<p>
Vergessen Sie aber nicht, dass Sie, um ein Paket aus einer
anderen Debian Version zu installieren, eine Quellzeile
in die <file>/etc/apt/sources.list</file> einfügen 
müssen. In unserem Beispiel brauchen wir Quellzeilen
für die "unstable" Distribution neben denen für "testing".

</sect>

<sect id="apt-show-versions">Upgrade von Paketen spezieller Debian-Versionen
<p>
<prgn>apt-show-versions</prgn> bietet einen sicheren Weg für Benutzer 
gemischter Systeme um ihre Systeme zu aktualisieren ohne mehr aus der 
weniger stabilen Distribution zu installieren als sie im Sinn haben.
Zum Beispiel ist es möglich nur die "unstable" Pakete zu aktualisieren in 
dem man folgendes ausführt:
<example>
# apt-get install `apt-show-versions -u -b | grep unstable`
</example>
</sect>

<sect id="pin">Wie man bestimmte Versionen eines Paketes behält (komplex)
<p>
Manchmal gibt es Gründe etwas in einem Paket zu verändern und es fehlt
die Zeit oder die Lust diese Dinge auf neue Versionen des Paketes 
zu übertragen. Vielleicht haben Sie auch gerade ihre Debian Version auf
3.0 aktualisiert, aber möchten trotzdem ein Paket aus Version 2.2 behalten.
Es ist möglich die installierte Version zu markieren (pin), so dass sie
nicht aktualisiert wird.
<p>
Diese Möglichkeit einzusetzen ist einfach. Editieren Sie einfach die Datei
<tt>/etc/apt/preferences</tt>.
<p>
Das Format ist trivial::
<example>
Package: &lt;Paket&gt;
Pin: &lt;Pin-Definition&gt;
Priority: &lt;Priorität des Pins&gt;
</example>
<p>
Um zum Beispiel das Paket <package>sylpheed</package>, welches 
ich dazu gebracht habe "reply-to-list" in Version 0.4.99 zu benutzen,
füge ich folgendes hinzu:
<example>
Package: sylpheed
Pin: version 0.4.99*
</example>
Bemerken Sie das <tt>*</tt> (Sternchen/Asterisk). Es funktioniert als 
Platzhalter; das bedeutet, dass dieser "Pin" für alle Versionen die mit
0.4.99 beginnen gültig sein soll. Das ist nötig, da Pakete in Debian
eine Nummer für die "Debian-Revision" enthalten und ich nicht verhindern
möchte, dass diese Revisionen installiert werden. Folglich werden 
die Versionen 0.4.99-1 und 0.4.99-10 installiert sobald sie verfügbar
sind. Bemerken Sie, dass Sie das vermutlich nicht möchten, wenn Sie
das Paket modifiziert haben, da diese Änderungen dann verloren gehen.
<p>
Das <tt>Priority</tt> Feld ist optional; wenn nicht anders spezifiziert
hat der "Pin" die Priorität 989.
<p>
Lassen Sie uns einen Blick darauf werfen wie die Pin-Priorität funktioniert.
Eine niedrigere Priorität als Null bewirkt, dass das Paket nie installiert 
wird. Prioritäten von 0 bis 100 bezeichnen Pakete, die nicht installiert sind
und keine Verfügbare Version haben. Solche Pakete werden in der Auswahl 
Verfügbarer Versionen nicht berücksichtigt. Die Priorität 100 bezeichnet
ein installiertes Paket. Damit eine installierte Version von einer 
anderen ersetzt wird, muss die Priorität über 100 liegen.
<p>
Prioritäten über 100 sagen aus, dass ein Paket installiert werden soll.
Normalerweise wird ein installiertes Paket nur durch neuere Versionen
übersetzt. Alle Prioritäten zwischen 100 und 1000 (inklusive) führen
zu diesem Normalverhalten. Ein Paket mit solcher Priorität wird nicht
durch eine niedrigere Version ersetzt. Wenn ich also zum Beispiel 
sylpheed 0.5.3 installiert habe und einen Pin auf sylpheed 0.4.99
mit der Priorität 999 definiert habe, wird Version 0.4.99 <em>nicht</em>
installiert werden um den Pin zu erfüllen. Um Pakete deaktualisieren
zu können um einen Pin zu erfüllen braucht der Pin eine Priorität von 
über 1000. 
<p>
Ein Pin kann für die <tt>version</tt>, das <tt>release</tt> oder die
Herkunft (<tt>origin</tt>) definiert werden. 
<p>
Für einen Pin auf die <tt>version</tt>, wie oben beschrieben,
kann man sowohl Versionsnummern als auch Platzhalter (Sternchen)
verwenden. Letzteres spezifiziert mehrere Versionen in einem Pin.
<!-- what's available?  standard shell globs?  ?*[]   or more? -->
<p>
Die Option <tt>release</tt> benutzt die Release-Datei aus den
APT-Archiven oder von den CDs. Die Brauchbarkeit dieser Version
verfällt wenn Sie APT-Archive benutzen, die diese Datei nicht
zur Verfügung stellen. Sie können den Inhalt der Release-Dateien 
die Sie haben in <tt>/var/lib/apt/lists/</tt> nachlesen.
Die Parameter für ein Release sind:
<tt>a</tt> (Archiv(Archive)), <tt>c</tt> (Sektion(Component)), <tt>v</tt> (Version(Version)),
<tt>o</tt> (Herkunft(Origin)) und <tt>l</tt> (Label(Label)).
<p>
Beispiel:
<example>
Package: *
Pin: release v=2.2*,a=stable,c=main,o=Debian,l=Debian
Priority: 1001
</example>
In diesem Beispiel wählen wir die Debian-Version 2.2* (was 2.2r2,
2.2r3 sein kann -- r* bezeichnet so genannte "point releases", welche
normalerweise Sicherheitsupdates und andere extrem wichtige Updates 
enthalten), das <tt>stable</tt> Archiv, die Sektion <tt>main</tt> (im
Gegensatz zu <tt>contrib</tt> oder <tt>non-free</tt>) und Herkunft und
Label Debian. Herkunft (o=) bezeichnet, wer die Release-Datei erstellt hat,
das Label (l=) definiert den Namen des Debian-Distribution: Debian für
Debian selbst und Progeny für Progeny Linux zum Beispiel. Eine Beispiel
Release-Datei:
<example>
$ cat /var/lib/apt/lists/ftp.debian.org.br_debian_dists_potato_main_binary-i386_Release
Archive: stable
Version: 2.2r3
Component: main
Origin: Debian
Label: Debian
Architecture: i386
</example>
</sect>
</chapt>

<chapt id="helpers">Sehr nützliche Helfer
<sect id="equivs">Installieren selbstkompilierter Pakete: equivs
<p>
Manchmal will man spezielle Versionen eines Programms benutzen,
die nur als Quellcode verfügbar sind und nicht als Debian Paket.
Hier kann es allerdings Probleme mit dem Paket-System geben.
Angenommen Sie wollen eine neue Version ihres Mailservers 
kompilieren und alle klappt, aber viele Pakete in Debian
hängen von einem MTA (Mail Transfer Agent) ab. 
Da etwas installiert wurde, was 
Sie selbst kompiliert haben, weiß das Paketsystem darüber
nicht Bescheid.
<p>
Hier kommt das <package>equivs</package> ins Spiel. Um es zu
benutzen installieren Sie das Paket mit diesem Namen. Es 
erstellt ein leeres Paket, was die Abhängigkeiten erfüllt und
so dem Paketsystem erzählt, dass es keine Probleme mit 
Abhängigkeiten gibt.
<p>
Bevor wir näher darauf eingehen ist es wichtig Sie darauf hinzuweisen
dass es sicherere Möglichkeiten gibt Programme, für die in Debian
schon Pakete existieren, mit anderen Optionen zu kompilieren und
man equivs nicht benutzen sollte um Abhängigkeiten zu entfernen,
ohne genau zu wissen was man tut. 
Sehen Sie Sektion <ref id="sourcehandling"> für nähere Informationen.
<p>
Lassen Sie uns mit dem MTA Beispiel fortfahren. Sie haben also
gerade ihren frisch kompilierten <prgn>postfix</prgn> installiert
und wollen nun <package>mutt</package> (ein Mailprogramm) installieren.
Plötzlich stellen Sie fest, dass <package>mutt</package> einen anderen
MTA installieren möchte, obwohl Sie schon ihren selbstkompilierten
laufen haben.
<p>
Wechseln Sie in irgendein Verzeichnis (z.B. <file>/tmp</file>) und führen
Sie folgendes aus:

<example>
# equivs-control <var>name</var>
</example>

Ersetzen Sie  <var>name</var> mit dem Namen der Kontrolldatei, die Sie 
erstellen wollen. Die Datei wird wie folgt erstellt:

<example>
Section: misc
Priority: optional
Standards-Version: 3.0.1

Package: &lt;Paketname; wenn nicht angegeben: equivs-dummy&gt;
Version: &lt;Versionsnummer; wenn nicht angegeben: 1.0&gt;
Maintainer: &lt;Ihr Name mit Emailadresse; wenn nicht angegeben: Benutzername &gt;
Pre-Depends: &lt;Pakete&gt;
Depends: &lt;Pakete&gt;
Recommends: &lt;Pakete&gt;
Suggests: &lt;Pakete&gt;
Provides: &lt;(virtuelles) Paket&gt;
Architecture: all
Copyright: &lt;copyright Datei; normalerweise GPL2&gt;
Changelog: &lt;changelog file; normalerweise ein generisches Changelog&gt;
Readme: &lt;README.Debian file; wenn nicht angegeben, ebenfalls ein generisches&gt;
Extra-Files: &lt;Zusätzliche Dateien für das doc-Verzeichnis, kommasepariert&gt;
Description: &lt;kurze Beschreibung; Standard ist "some wise words"&gt;
 Lange Beschreibung und Info
 .
 Zweiter Paragraph
</example>

Nun muss das so angepasst werden, dass es tut was wir wollen. Gucken
Sie sich die Felder und ihre Beschreibungen an, es ist nicht nötig
jedes einzelne hier zu erklären, lassen Sie uns das nötigste tun: 

<example>
Section: misc
Priority: optional
Standards-Version: 3.0.1

Package: mta-local
Provides: mail-transport-agent
</example>

Das war es schon. <package>mutt</package> hängt von
<package>mail-transport-agent</package> ab, was ein
virtuelles Paket ist, was alle MTAs liefern. Ich 
hätte das Paket einfach <package>mail-transport-agent</package>
nennen können, aber ich bevorzugte das Schema für virtuelle
Pakete, welches das Feld "Provides" benutzt.
<p>
Nun muss das Paket nur noch gebaut werden:

<example>
# equivs-build <var>name</var>
dh_testdir
touch build-stamp
dh_testdir
dh_testroot
dh_clean -k
# Add here commands to install the package into debian/tmp.
touch install-stamp
dh_testdir
dh_testroot
dh_installdocs
dh_installchangelogs
dh_compress
dh_fixperms
dh_installdeb
dh_gencontrol
dh_md5sums
dh_builddeb
dpkg-deb: building package `<var>name</var>' in `../<var>name</var>_1.0_all.deb'.

The package has been created.
Attention, the package has been created in the current directory,
</example>

Und das resultierende <tt>.deb</tt> muss installiert werden.
<p>
Wie man unschwer erkennen kann, gibt es verschiedene Anwendungen für
<prgn>equivs</prgn>. Man könnte sogar ein <tt>Favoriten</tt>-Paket 
erstellen, was von den Paketen abhängt die Sie normalerweise installieren.
Lassen Sie ihren Vorstellungen einfach freien Lauf, aber seien Sie vorsichtig.
<p>
Es ist wichtig zu erwähnen, dass es in 
<file>/usr/share/doc/equivs/examples</file> einige Beispiel-Kontrolldateien
gibt. Werfen Sie da mal einen Blick drauf.
</sect>

<sect id="localepurge">Entfernen von unbenutzten locale Dateien: localepurge
<p>
Viele Debian Benutzer verwenden nur ein locale (Spracheinstellung). 
Ein brasilianischer
Debian Benutzer benutzt z.B. vermutlich immer das brasilianische 
<tt>pt_BR</tt>-locale
und interessiert sich nicht für das spanische <tt>es</tt>-locale. 
<p>
<package>localepurge</package> ist ein sehr nützliches Werkzeug für diese
Art von Benutzern. Sie können eine Menge Festplattenplatz sparen, wenn
Sie nur die locales installiert haben, die Sie auch wirklich brauchen.
Installieren Sie einfach <tt>apt-get install localepurge</tt>.
<p>
Es ist wirklich einfach zu konfigurieren, Debconf Fragen führen den
Benutzer Schritt für Schritt durch die Konfiguration. Seien Sie vorsichtig
beim Beantworten der ersten Frage, da falsche Antworten alle locales
entfernen können - selbst die, die Sie benutzen. Die einzige
Möglichkeit sie wiederherzustellen ist es, alle Pakete neu zu
installieren, die sie enthalten.
</sect>

<sect id="helper-show-versions">Erfahren, welche Pakete aktualisiert werden können
<p>
<prgn>apt-show-versions</prgn> ist ein Programm, das zeigt welche Pakete im 
System aktualisiert werden können und andere hilfreiche Informationen 
bietet.
Die Option <tt>-u</tt> zeigt eine Liste der Pakete die aktualisiert werden 
können:

<example>
$ apt-show-versions -u    
libeel0/unstable upgradeable from 1.0.2-5 to 1.0.2-7
libeel-data/unstable upgradeable from 1.0.2-5 to 1.0.2-7
</example>
</sect>

</chapt>

<chapt id="search">Informationen über Pakete
<p>
Es gibt einige Oberflächen für das APT System, die es 
signifikant einfacher machen Listen über Verfügbare Pakete oder 
schon installierte Pakete zu bekommen oder auch herauszufinden, zu welcher 
Sektion ein Paket gehört, welche Priorität es hat, wie seine Beschreibung 
lautet, etc.
<p>
Unser Ziel ist es hier aber APT selbst benutzen zu lernen. Wie können wir
also den Namen eines Paketes herausfinden, welches wir installieren 
wollen?
<p>
Es gibt eine Reihe von Möglichkeiten für eine solche Aufgabe. Fangen
wir mit <tt>apt-cache</tt> an. Dieses Programm wird vom APT System zum 
warten seiner Datenbank benutzt. Werfen wir nur einen kleinen Blick auf
einige seiner praktischeren Anwendungen.

<sect id="cache">Paketnamen entdecken
<p>
Angenommen Sie wollen die alten Zeiten des Atari 2600 wieder aufleben 
lassen. Sie möchten APT benutzen um einen Atari Emulator zu installieren und
dann Spiele herunterladen. Sie haben folgende Möglichkeit: 

<example>
[root]@[/] # apt-cache search atari
atari-fdisk-cross - Partition editor for Atari (running on non-Atari)
circuslinux - The clowns are trying to pop balloons to score points!
madbomber - A Kaboom! clone
tcs - Character set translator.
atari800 - Atari emulator for svgalib/X/curses
stella - Atari 2600 Emulator for X windows
xmess-x - X binaries for Multi-Emulator Super System
</example>

Wir finden verschiedene Pakete mit kurzen Beschreibungen. Um weitere 
Informationen über ein bestimmtes Paket zu erhalten können wir folgendes 
machen:

<example>
[root]@[/] # apt-cache show stella  
Package: stella
Priority: extra
Section: non-free/otherosfs
Installed-Size: 830
Maintainer: Tom Lear &lt;tom@trap.mtview.ca.us&gt;
Architecture: i386
Version: 1.1-2
Depends: libc6 (>= 2.1), libstdc++2.10, xlib6g (>= 3.3.5-1)
Filename: dists/potato/non-free/binary-i386/otherosfs/stella_1.1-2.deb
Size: 483430
MD5sum: 11b3e86a41a60fa1c4b334dd96c1d4b5
Description: Atari 2600 Emulator for X windows
 Stella is a portable emulator of the old Atari 2600 video-game console
 written in C++.  You can play most Atari 2600 games with it.  The latest
 news, code and binaries for Stella can be found at:
 http://www4.ncsu.edu/~bwmott/2600
</example>

Mit diesem Output erhalten Sie eine Menge Details über das Paket, dass Sie
installieren wollen (oder nicht wollen) inklusive der vollständigen
Beschreibung des Pakets. Wenn das Paket schon installiert ist und es 
eine neuere Version gibt, bekommen Sie Informationen über beide Versionen.
Beispiel:

<example>
[root]@[/] # apt-cache show lilo
Package: lilo
Priority: important
Section: base
Installed-Size: 271
Maintainer: Russell Coker &lt;russell@coker.com.au&gt;
Architecture: i386
Version: 1:21.7-3
Depends: libc6 (>= 2.2.1-2), debconf (>=0.2.26), logrotate
Suggests: lilo-doc
Conflicts: manpages (<<1.29-3)
Filename: pool/main/l/lilo/lilo_21.7-3_i386.deb
Size: 143052
MD5sum: 63fe29b5317fe34ed8ec3ae955f8270e
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.

Package: lilo
Status: install ok installed
Priority: important
Section: base
Installed-Size: 190
Maintainer: Vincent Renardias &lt;vincent@debian.org&gt;
Version: 1:21.4.3-2
Depends: libc6 (>= 2.1.2)
Recommends: mbr
Suggests: lilo-doc
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.
</example>

Das erste in der Liste ist die neu verfügbare Version und das zweite die 
installierte Version. Für generellere Informationen über ein Paket können
Sie folgendes benutzen:

<example>
[root]@[/] # apt-cache showpkg penguin-command
Package: penguin-command
Versions: 
1.4.5-1(/var/lib/apt/lists/download.sourceforge.net_debian_dists_unstable_main_binary-i386_Packages)(/var/lib/dpkg/status)

Reverse Depends: 
Dependencies: 
1.4.5-1 - libc6 (2 2.2.1-2) libpng2 (0 (null)) libsdl-mixer1.1 (2 1.1.0) libsdl1.1 (0 (null)) zlib1g (2 1:1.1.3) 
Provides: 
1.4.5-1 - 
Reverse Provides: 
</example>

Und um nur herauszufinden von welchen Paketen es abhängt:

<example>
[root]@[/] # apt-cache depends penguin-command
penguin-command
  Depends: libc6
  Depends: libpng2
  Depends: libsdl-mixer1.1
  Depends: libsdl1.1
  Depends: zlib1g
</example>

Zusammengefasst haben wir eine Hand voll Waffen, die wir benutzen können um
den Namen des Paketes herauszufinden, dass wir installieren wollen.
</sect>

<sect id="dpkg-search">Paketnamen mit dpkg finden
<p>
Ein Weg den Namen eines Pakets zu finden ist es, den Namen einer wichtigen 
Datei zu kennen, die sich in dem Paket befindet. Um zum Beispiel das
Paket zu finden, welches eine bestimmte <tt>".h"</tt> Datei enthält, dass
für das Kompilieren eines Programms benötigt wird ist folgendes auszuführen: 

<example>
[root]@[/] # dpkg -S stdio.h
libc6-dev: /usr/include/stdio.h
libc6-dev: /usr/include/bits/stdio.h
perl: /usr/lib/perl/5.6.0/CORE/nostdio.h
</example>

oder:

<example>
[root]@[/] # dpkg -S /usr/include/stdio.h
libc6-dev: /usr/include/stdio.h
</example>

Um den Namen installierter Pakete herauszufinden, was zum Beispiel zum
aufräumen der Festplatte nützlich sein kann benutzen Sie:

<example>
[root]@[/] # dpkg -l | grep mozilla
ii  mozilla-browse 0.9.6-7        Mozilla Web Browser
</example>

Das Problem mit diesem Befehl ist, dass er Paketnamen "brechen" kann. Im
obigen Beispiel ist der ganze Name des Pakets <tt>mozilla-browser</tt>.
Um das Problem zu beheben können Sie die Umgebungsvariable 
<tt>COLUMNS</tt> folgendermaßen benutzen: 

<example>
[kov]@[couve] $ COLUMNS=132 dpkg -l | grep mozilla
ii  mozilla-browser             0.9.6-7                     Mozilla Web Browser - core and browser
</example>

oder die Beschreibung bzw. einen Teil dieser wie im Folgenden:

<example>
[root]@[/] # apt-cache search "Mozilla Web Browser"
mozilla-browser - Mozilla Web Browser
</example>
</sect>

<sect id="auto-apt">Pakete nach Bedarf installieren
<p>
Sie kompilieren gerade ein Programm und wie aus heiterem Himmel - Boom!
Es gibt einen Fehler, da eine <tt>.h</tt> Datei gebraucht wird, die Sie
nicht haben. Das Programm <prgn>auto-apt</prgn> kann Sie for solchen 
Szenarios bewahren. Es fragt, ob es die benötigten Pakete installieren soll
nachdem es den betroffenden Prozess gestoppt hat und führt ihn fort, wenn
die relevanten Pakete installiert sind. 
<p>
Der Befehl sieht folgendermaßen aus:

<example>
auto-apt run Kommando
</example>

Wobei `Kommando' das Kommando ist, was ausgeführt werden soll und evtl.
nicht vorhandene Dateien benötigt. Beispiel:

<example>
auto-apt run ./configure
</example>

Es wird fragen, ob die benötigten Pakete installiert werden sollen
und apt-get automatisch aufrufen. Wenn X läuft ersetzt eine grafische
Oberfläche die übliche Text-Oberfläche.
<p>
Auto-apt funktioniert mit einer Datenbank welche up-to-date gehalten werden
muss um effektiv zu funktionieren. Das erreicht man mit den Kommandos
<tt>auto-apt update</tt>, <tt>auto-apt updatedb</tt> und
<tt>auto-apt update-local</tt>.
</sect>

<sect id="apt-file">Herausfinden zu welchem Paket eine Datei gehört
<p>
Wenn ein Paket installiert werden soll und Sie nicht herausfinden können,
wie es heißt indem Sie mit <prgn>apt-cache</prgn> suchen, aber den Dateinamen
des Programms oder einer Datei, die zu dem Paket gehört kennen, können
Sie <prgn>apt-file</prgn> benutzen um den Dateinamen zu finden. Das wird
folgendermaßen gemacht:

<example>
$ apt-file search <var>Dateinamen</var>
</example>

Es funktioniert genau wie <tt>dpkg -S</tt>, es zeigt ihnen aber auch 
nicht installierte Pakete, die die Datei enthalten. Man kann es auch dazu 
benutzen benötigte include-Dateien, die beim Kompilieren von Programmen
fehlen zu installieren, allerdings ist <prgn>auto-apt</prgn> eine
wesentlich bessere Methode solche Fälle zu lösen, sehen Sie 
<ref id="auto-apt">.
<p>
Man kann auch den Inhalt von Paketen auflisten:

<example>
$ apt-file list <var>Paketname</var>
</example>

<prgn>apt-file</prgn> hat genau wie auto-apt eine Datenbank über die 
Dateien aller Pakete und diese muss up-to-date gehalten werden:

<example>
# apt-file update
</example>

Normalerweise benutzt <prgn>apt-file</prgn> die gleiche Datenbank
wie <prgn>auto-apt</prgn>, sehen Sie <ref id="auto-apt">.

</sect>

<sect id="apt-listchanges">Über Änderungen in Paketen informiert bleiben
<p>
Jedes Paket installiert in sein Dokumentationsverzeichnis (<tt>/usr/share/doc/Paketname</tt>) eine Datei mit Namen <tt>changelog.Debian.gz</tt>, welche die 
Liste der Änderungen gegenüber der letzten Version enthält. Sie können diese
Dateien z.B. mit Hilfe von <tt>zless</tt> lesen, aber es ist nicht wirklich
leicht, nach einem System-Upgrade nach dem changelog jedes aktualisierten
Paketes zu suchen.  
<p>
Es gibt aber eine Möglichkeit diese Aufgabe zu automatisieren mit
Hilfe eines Werkzeugs mit Namen <prgn>apt-listchanges</prgn>.
Hierfür muss das Paket <package>apt-listchanges</package> erst einmal
installiert werden. Während der Installation übernimmt Debconf die
Installation. Beantworten Sie die Fragen nach ihren Bedürfnissen.
<p>
Die Option "Soll apt-listchanges nach dem Anzeigen der Changelogs um 
eine Bestätigung bitten?" ist sehr nützlich, da es eine Liste der Änderungen
jedes Paketes, dass während eines Upgrades installiert wird, anzeigt und
Ihnen die Möglichkeit bietet, diese vor dem Fortfahren einzusehen.
Wenn Sie hier sagen, dass Sie nicht fortfahren möchten, gibt apt-listchanges
einen Fehlercode zurück und APT bricht die Installation ab.
<p>
Nachdem apt-listchanges installiert wurde, zeigt es die Liste der Änderungen
installierter Pakete an, wenn Pakete aus dem Netz (oder von
einer CD oder gemounteten Partition) heruntergeladen werden, bevor Sie 
installiert werden.
</sect>
</chapt>

<chapt id="sourcehandling">Das Arbeiten mit Quellpaketen
<sect id="source">Herunterladen von Quellpaketen
<p>
In der Welt der freien Software ist es üblich, den Quellcode zu studieren
oder auch Korrekturen an fehlerhaftem Code vorzunehmen. Um dieses zu tun
muss der Quellcode des Programms heruntergeladen werden. Das APT System
bietet eine einfache Möglichkeit den Quellcode der vielen Programme
der Distribution, einschl. all der für das Erstellen eines .deb des 
Programms nötigen Dateien, zu beziehen.
<p>
Eine andere übliche Anwendung für Debian Quellen ist es eine aktuellere
Version eines Programms aus der Distribution unstable zum Beispiel 
in stable zu benutzen. Das Paket "gegen" stable zu kompilieren erzeugt
ein Paket mit Abhängigkeiten, die auf die Pakete aus stable ausgerichtet
sind.
<p>
Hierfür sollte der <tt>deb-src</tt> Eintrag in Ihrer 
<tt>/etc/apt/sources.list</tt> auf unstable zeigen. Es sollte außerdem
aktiviert sein, d.h. eventuelle Kommentarzeichen vor der Zeile müssen
entfernt werden (sehen Sie  Sektion <ref id="sources.list">).
<p>
Um ein Quellpaket herunterzuladen benutzen Sie folgendes Kommando:

<example>
apt-get source Paketname
</example>
Drei Dateien werden daraufhin heruntergeladen: ein <tt>.orig.tar.gz</tt>,
ein <tt>.dsc</tt> und ein <tt>.diff.gz</tt>. Im Falle von Paketen die
speziell für Debian erzeugt wurden fällt das Letzte weg und das Erste
hat kein <tt>"orig"</tt> im Namen.
<p>
Die Datei <tt>.dsc</tt> wird von dpkg-source benutzt um das Quellpaket
in das Verzeichnis <var>Paketname-Version</var> zu entpacken. In jedem
heruntergeladenen Quellpaket befindet sich ein Verzeichnis <tt>debian/</tt>,
welches die für das Bauen des .deb Paketes nötigen Dateien enthält.
<p>
Um das Paket beim herunterladen automatisch zu erzeugen, fügen Sie einfach
<tt>-b</tt> zur Kommandozeile hinzu:

<example>
apt-get -b source Paketname
</example>

Wenn Sie sich dazu entscheiden, das Paket noch nicht beim Herunterladen
zu erzeugen können Sie dieses später mit

<example>
dpkg-buildpackage -rfakeroot -uc -b
</example>

aus dem Verzeichnis, welches für das Paket nach dem Herunterladen erstellt 
wurde, tun.
<p>
Es besteht ein Unterschied zwischen der <prgn>apt-get</prgn> <tt>source</tt>
Methode und den anderen Methoden von <prgn>apt-get</prgn>. Die <tt>source</tt>
Methode kann von normalen Benutzern ohne Root-Rechten benutzt werden.
Die Dateien werden in das Verzeichnis heruntergeladen, aus dem das 
<tt>apt-get source Paket</tt> aufgerufen wurde.
</sect>

<sect id="build-dep">Für das kompilieren eines Quellpaketes nötige Pakete
<p>
Normalerweise müssen sich spezielle Bibliotheken auf dem System befinden
um ein Quellpaket zu kompilieren. Alle .deb Pakete haben ein Feld mit 
Namen "Build-Depends" in ihrer Kontrolldatei, welches die Namen der
zusätzlichen Pakete enthält, die für das Erzeugen des Paketes aus
dem Quellcode nötig sind. 
<p>
APT bietet eine einfache Möglichkeit diese Pakete herunterzuladen.
Führen Sie einfach <tt>apt-get build-dep Paket</tt> aus, wobei 
`Paket' für den Namen des Pakets welches Sie erzeugen wollen steht.
Beispiel:

<example>
[root]@[/] # apt-get build-dep gmc
Reading Package Lists... Done
Building Dependency Tree... Done
The following NEW packages will be installed:
  comerr-dev e2fslibs-dev gdk-imlib-dev imlib-progs libgnome-dev libgnorba-dev
  libgpmg1-dev 
0 packages upgraded, 7 newly installed, 0 to remove and 1  not upgraded.
Need to get 1069kB of archives. After unpacking 3514kB will be used.
Do you want to continue? [Y/n]
</example>

Die Pakete, die hier installiert werden, werden gebraucht um 
<package>gmc</package> korrekt zu erzeugen. Bemerken Sie jedoch, dass
dieses Kommando sich nicht um das Quellpaket selbst kümmert, welches
Sie bauen möchten. Sie müssen hierfür zusätzlich <tt>apt-get source</tt>
ausführen.
</chapt>

<chapt id="erros">Der Umgang mit Fehlern
<sect id="erros-comuns">Häufige Fehler
<p>
Fehler wird es immer geben. Viele werden durch unachtsame Benutzer verursacht.
Im folgenden finden Sie eine Liste mit häufig gemeldeten Fehlern und wie
Sie mit ihnen umgehen sollten.
<p>
Wenn Sie eine Nachricht erhalten die aussieht wie die im unteren Beispiel,
bei dem Versuch <tt>apt-get install Paket</tt> auszuführen...

<example>
Reading Package Lists... Done
Building Dependency Tree... Done
W: Couldn't stat source package list 'http://people.debian.org unstable/ Packages' (/var/state/apt/lists/people.debian.org_%7ekov_debian_unstable_Packages) - stat (2 No such file or directory)
W: You may want to run apt-get update to correct these missing files
E: Couldn't find package penguineyes
</example>

haben Sie vergessen <tt>apt-get update</tt> nach ihrer letzten Änderung in der
<tt>/etc/apt/sources.list</tt> auszuführen.
<p>
Wenn folgender Fehler auftritt...

<example>
E: Could not open lock file /var/lib/dpkg/lock - open (13 Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?
</example>

nach dem Versuch irgendeine andere <prgn>apt-get</prgn> Methode auszuführen,
als <tt>source</tt>, haben Sie keine Root-Rechte, d.h. Sie haben sie als
normaler Benutzer ausgeführt.
<p>
Der gleiche Fehler wie oben tritt auf, wenn versucht wird zwei mal 
<prgn>apt-get</prgn> gleichzeitig auszuführen oder auch, wenn versucht
wird <prgn>apt-get</prgn> auszuführen während ein <prgn>dpkg</prgn>
Prozess läuft. Die einzige Methode, die simultan zu Anderen ausgeführt
werden darf ist die <tt>source</tt> Methode.
<p>
Wenn eine Installation mitten im Prozess abbricht und Sie merken,
dass es nicht länger möglich ist Pakete zu installieren oder zu entfernen,
versuchen Sie diese zwei befehle auszuführen:

<example>
# apt-get -f install
# dpkg --configure -a
</example>

Danach versuchen Sie es erneut. Es kann nötig sein, den zweiten der beiden
Befehle mehr als einmal auszuführen. Dies ist eine wichtige Information für 
die Abenteurer, die `unstable' benutzen.
</sect>

<sect id="help">Wo gibt es Hilfe?
<p>
Wenn Sie sich von Zweifeln geplagt fühlen, ziehen Sie die umfangreiche
Dokumentation des Debian Paket Systems zu Rate. <tt>--help</tt>'s und 
Manpages können eine enorme Hilfe sein, genau wie die Dokumentation
in den <tt>/usr/share/doc</tt> Verzeichnissen ebenso wie in 
<tt>/usr/share/doc/apt</tt>.
<p>
Wenn diese Dokumentation nicht ausreicht, um ihre Probleme zu beseitigen,
versuchen Sie es auf den Debian Mailinglisten. Mehr Informationen
über die speziellen Benutzer-Listen gibt es auf der Debian-Webseite:
<url id="http://www.debian.org" name="http://www.debian.org">.
<p>
Natürlich sind diese Listen und Hilfen nur für Debian Benutzer; Benutzer
anderer Systeme werden von der Gemeinschaft ihrer Distribution bessere
Hilfe erlangen.
</sect>
</chapt>

<chapt id="distros">Welche Distributionen unterstützen APT?
<p>
Hier finden Sie die Namen einiger Distributionen, die APT unterstützen:
<p>
Debian GNU/Linux (<url id="http://www.debian.org" name="http://www.debian.org">) 
- Für diese Distribution wurde APT entwickelt
<p>
Conectiva (<url id="http://www.conectiva.com.br" name="http://www.conectiva.com.br">) 
- Die erste Distribution, die APT mit RPM benutzt
<p>
Mandrake (<url id="http://www.mandrake.com" name="http://www.mandrake.com">)
<p>
PLD (<url id="http://www.pld.org.pl" name="http://www.pld.org.pl">)
<p>
Vine (<url id="http://www.vinelinux.org" name="http://www.vinelinux.org">)
<p>
APT4RPM (<url id="http://apt4rpm.sf.net" name="http://apt4rpm.sf.net">)
<p>
Alt Linux (<url id="http://www.altlinux.ru/" name="http://www.altlinux.ru/">)
<p>
Red Hat (<url id="http://www.redhat.com/" name="http://www.redhat.com/">)
<p>
Sun Solaris (<url id="http://www.sun.com/" name="http://www.sun.com/">)
<p>
SuSE (<url id="http://www.suse.de/" name="http://www.suse.de/">)
<p>
Yellow Dog Linux (<url id="http://www.yellowdoglinux.com/"
name="http://www.yellowdoglinux.com/">)

</chapt>

<chapt id="agradecimentos">Credits
<p>
Ein großes Danke geht an meine Freunde aus dem Debian-BR Projekt und
Debian selbst, die eine ständige Hilfe für mich sind und mir immer
die Kraft geben für das Wohl der Menschheit zu arbeiten genauso wie
Sie mir bei meinem Ziel helfen die Welt zu retten. :)
<p>
Außerdem möchte ich CIPSGA für die enorme Hilfe danken, die es für
unser Projekt und alle freien Projekte die aus großen Ideen entstehen
bedeutet.
<p>

Und spezieller Dank geht an:
<p>
Yooseong Yang &lt;yooseong@debian.org&gt;
<p>
Michael Bramer &lt;grisu@debian.org&gt;
<p>
Bryan Stillwell &lt;bryan@bokeoa.com&gt;
<p>
Pawel Tecza  &lt;pawel.tecza@poczta.fm&gt;
<p>
Hugo Mora &lt;h.mora@melix.com.mx&gt;
<p>
Luca Monducci &lt;luca.mo@tiscali.it&gt;
<p>
Tomohiro KUBOTA &lt;kubota@debian.org&gt;
<p>
Pablo Lorenzzoni &lt;spectra@debian.org&gt;
<p>
Steve Langasek &lt;vorlon@netexpress.net&gt;
<p>
Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;
<p>
Erik Rossen &lt;rossen@freesurf.ch&gt;
<p>
Ross Boylan &lt;RossBoylan@stanfordalumni.org&gt;
<p>
Matt Kraai &lt;kraai@debian.org&gt;
<p>
Aaron M. Ucko &lt;ucko@debian.org&gt;
<p>
Jon Åslund &lt;d98-jas@nada.kth.se&gt;
</chapt>

<chapt id="novas">Neue Versionen dieses Dokuments
<p>
Diese Anleitung wurde vom <url id="http://www.debian-br.org/"
name="Debian-BR"> Projekt mit dem Ziel geschrieben, den täglichen
Umgang mit Debian zu erleichtern. 
<p>
Neue Versionen dieses Dokuments werden zur Verfügung gestellt auf der 
Webseite des Debian Dokumentations Projekts
<url id="http://www.debian.org/doc/ddp" 
name="http://www.debian.org/doc/ddp">. 
<p>
Kommentare und Kritik können direkt per Mail an mich gesandt werden
unter der Adresse <email>kov@debian.org</email>.
<p>
Kritik zur deutschen Übersetzung geht an
David Spreen <email>netzwurm@debian.org</email>.
</chapt>

</book>

</debiandoc>