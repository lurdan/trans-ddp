<!doctype debiandoc system>
<debiandoc>

<book>

<title>APT HOWTO</title>

<author>
<name>Gustavo Noronha Silva</name> <email>kov@debian.org</email>
</author>
<author>
<name>Deutsche Übersetzung: David Spreen</name> <email>netzwurm@debian.org</email>
</author>

<version>1.8.4 - April 2003</version>

<abstract>
Dieses Dokument soll dem Benutzer ein gutes Verständnis für die
Arbeitsweise des Debian-Paketmanagement-Werkzeugs APT liefern.
Ziel ist es, das Leben für neue Debian Benutzer zu erleichtern und
denen zu helfen, die ihr Verständnis für die Administration dieses
Systems vertiefen wollen. Es wurde für das Debian-Projekt geschaffen,
um den verfügbaren Support für Benutzer dieser Distribution zu erweitern.
</abstract>

<copyright>
<copyrightsummary>
Copyright &copy; 2001, 2002 Gustavo Noronha Silva
</copyrightsummary>
<copyrightsummary>
Copyright &copy; Deutsche Übersetzung 2002 David Spreen
</copyrightsummary>
<p>
Diese Anleitung ist lizenziert durch die Richtlinien der GNU FDL (Free 
Documentation License). Sie wurde geschrieben in der Hoffnung, daß es 
für die Community von Nutzen ist, aber kommt ohne Garantie; die Benutzung
erfolgt auf eigenes Risiko.
</copyright> 

<toc>

<chapt id=trans>Zur Deutschen Übersetzung

<sect id=vorwort>Vorwort
<p>
Der Text dieser Übersetzung hat das Ziel, sich möglichst eng an der 
englischen Übersetzung zu orientieren. Leider lassen sich einige Fachbegriffe
schlecht übersetzen. Diese Begriffe habe ich versucht, entweder sinnvoll
einzudeutschen oder als englisches Wort zu übernehmen. Alle diese Begriffe 
werden im untenstehenden Glossar kurz erläutert.
</sect>

<sect id=glossar>Glossar
<p>
Die Begriffe sind hier in der Reihenfolge aufgelistet, in der sie 
im Text auftauchen.
<list>
<item><em>Kompilieren</em> (eingedeutscht): Das Übersetzen des 
Programmquelltextes in ein für den Computer ausführbares Programm.

<item><em>Paket</em> (eingedeutscht): Hier Sammlung von Dateien,
die meist ein vorkompiliertes und konfiguriertes Programm enthält,
welches sich mit einem Paketverwaltungsprogramm installieren
lässt.

<item><em>Portieren</em> (eingedeutscht): Das Verändern eines Programms,
um es auf einem anderen System oder einer anderen Architektur benutzen
zu können.

<item><em>Update</em>: Aktualisieren von Informationen oder Software,
um sie auf dem neusten Stand zu halten, wobei Paket-Updates bei APT
"Upgrade" heißen. Verwirrenderweise heißen Paketupgrades aufgrund von
Sicherheitslücken bei Debian allerdings "Sicherheits-Updates".

<item><em>Mirror</em>: Eine exakte Kopie eines Web- oder FTP-Servers,
die dazu dient, den Originalserver zu entlasten. Die Liste der
Debian-Mirrors gibt es auf http://www.debian.org/distrib/ftplist.

<item><em>Upgrade</em>: Sehen Sie Update. Hierbei handelt es sich um
das Aktualisieren von Paketen.

<item><em>Ncurses</em>: Programmbibliothek, um auf der Konsole
Fenster, Menüs usw. darzustellen.

<item><em>MTA</em>: Mail Transport Agent - Programm zum Transportieren von
E-Mails, oft auch Mailserver.

<item><em>Manpage</em>: Anleitung für ein Programm, welche auf der 
Kommandozeile per "man Programmname" verfügbar ist.

<item><em>Lock-Datei</em>: Datei, deren Existenz anzeigt, daß eine Ressource (z.B. die
APT-Datenbank) zur Zeit genutzt wird.
</list>
</sect>
</chapt> 

<chapt>Einführung
<p>
Am Anfang war das .tar.gz. Benutzer mußten jedes Programm, welches sie
auf ihren GNU/Linux-Systemen benutzen wollten, selbst kompilieren. 
Zu Beginn der Entwicklung des Debian-Projekts erachtete man es für notwendig,
daß das System eine Methode zum Verwalten der Pakete, die auf dem System 
installiert sind, enthält. Man gab dieser Methode den Namen <prgn>dpkg</prgn>.
Dadurch war das erste 'Paket' auf GNU/Linux geboren, bevor Red Hat sich 
entschied, ihr eigenes RPM-System zu erschaffen.
<p>
Schnell standen die Macher von GNU/Linux vor einem neuen Problem.
Sie brauchten ein schnelles, praktisches und effizientes Mittel, um 
Pakete zu installieren, das Abhängigkeiten automatisch behandeln und 
ihre Konfigurationsdateien während des Aktualisierens berücksichtigen würde.
Und wieder war es das Debian-Projekt, das den Weg machte und APT, das "Advanced 
Packaging Tool", welches seitdem von Connectiva auf RPM portiert und von 
einigen anderen Distributionen übernommen wurde, das 
Licht der Welt erblicken ließ. 
<p>
Diese Anleitung versucht nicht, apt-rpm (den Connectiva-Port von APT) 
zu behandeln, aber Patches für dieses Dokument, welche es tun,
sind willkommen.
<p>
Diese Dokumentation basiert auf der nächsten Debian-Version: <tt>Sarge</tt>.
</chapt>

<chapt id="basico">Basis-Konfiguration

<sect id="sources.list">Die Datei /etc/apt/sources.list
<p>
Als Teil seiner Arbeit benutzt APT eine Datei, die die 'Quellen', von 
denen man Pakete beziehen kann, auflistet. Diese Datei heißt 
<tt>/etc/apt/sources.list</tt>.
<p>
Die Einträge in dieser Datei sind von folgendem Format:

<p>
<example>
deb http://host/debian distribution sektion1 sektion2 sektion3
deb-src http://host/debian distribution sektion1 sektion2 sektion3
</example>

<p>
Natürlich sind obige Einträge erfunden und sollten nicht benutzt werden.
Das erste Wort jeder Zeile, <tt>deb</tt> oder <tt>deb-src</tt> zeigt den
Typ des Archivs: entweder es enthält Binär-Pakete (<tt>deb</tt>), das sind
die vorkompilierten Pakete, die wir normalerweise benutzen, oder Quellpakete
(<tt>deb-src</tt>), welche die originalen Programmquellen und die
Debian-Kontrolldatei (<tt>.dsc</tt>) und das <tt>diff.gz</tt>, welches die Änderungen
enthält, die für das 'Debianisieren' des Programms von Nöten sind.
<p>
Normalerweise finden wir folgendes in der Standard-Debian-sources.list:
<p>
<example>
# See sources.list(5) for more information, especialy
# Remember that you can only use http, ftp or file URIs
# CDROMs are managed through the apt-cdrom tool.
deb http://http.us.debian.org/debian stable main contrib non-free
deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
deb http://security.debian.org stable/updates main contrib non-free

# Uncomment if you want the apt-get source function to work
#deb-src http://http.us.debian.org/debian stable main contrib non-free
#deb-src http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
</example>

<p>
Dieses sind die Zeilen, die eine Debian-Basis-Installation benötigt.  
Die erste <tt>deb</tt> Zeile zeigt auf das offizielle Archiv, die 
zweite auf das Archiv non-US und die dritte auf das Archiv der Debian
Sicherheits-Updates.
<p>
Die letzten beiden Zeilen sind auskommentiert (mit einem `#' am Anfang). 
Deshalb wird apt-get sie ignorieren. Sie sind <tt>deb-src</tt>-Zeilen, das 
bedeutet, sie führen uns zu Debian-Quellpaketen. Wenn Sie öfters 
Programm-Quellen herunterladen, um sie zu testen oder neu zu kompilieren, 
sollten Sie die Kommentarzeichen entfernen. 
<p>
Die <tt>/etc/apt/sources.list</tt> Datei kann verschiedene Typen von
Zeilen enthalten. APT kann mit Archiven der Typen <tt>http</tt>, <tt>ftp</tt>,
<tt>file</tt> (lokale Dateien, z.B. ein Verzeichnis, mit einem gemounteten 
ISO9660-Dateisystem) und <tt>ssh</tt>, soweit ich weiß.
<p>
Vergessen Sie nicht, <tt>apt-get update</tt> auszuführen, nachdem
die <tt>/etc/apt-/sources.list</tt> editiert wurde. Dies ist notwendig,
damit APT die Paketlisten der spezifizierten Quellen bezieht.
</sect>

<sect id="dpkg-scanpackages">Wie man APT lokal benutzt
<p>
Manchmal haben Sie vielleicht einige .deb, bei denen Sie APT für die 
Installation benutzen wollen, so daß Abhängigkeiten automatisch 
aufgelöst werden.
<p>
Um das zu tun, erstellen Sie ein Verzeichnis und legen die .debs,
die Sie sie indizieren wollen, dort hinein. Zum Beispiel:
<p>
<example>
# mkdir /root/debs/
</example>
<p>
Es ist möglich, die Definitionen der paketeigenen Kontrolldatei (debian/control)
für das Repository mit Hilfe einer <tt>override</tt>-Datei zu übergehen. 
In dieser Datei können Sie einige Optionen definieren, die die 
paketeigenen Optionen überschreiben. 
Das Format sieht folgendermaßen aus:
<p>
<example>
Paket Priorität Sektion
</example>
<p>
Paket ist der Name des Pakets, die Priorität ist "low" (niedrig),
"medium" (mittel) oder "high" (hoch) und die Sektion ist die 
Sektion, zu der das Paket gehört. Der Dateiname spielt keine Rolle,
er muß als Argument an <prgn>dpkg-scanpackages</prgn> übergeben werden.
Wenn keine <tt>override</tt>-Datei gebraucht wird, kann man <prgn>dpkg-scanpackages</prgn>
auch <file>/dev/null</file> übergeben.
<p>
Immer noch im Verzeichnis /root führen Sie folgendes aus:
<p>
<example>
# dpkg-scanpackages debs <var>Datei</var> | gzip &gt; debs/Packages.gz
</example>
<p>
In der obenstehenden Zeile ist <file>Datei</file> die <tt>override</tt>-Datei,
das Kommando generiert eine Datei <file>Packages.gz</file>, welche 
verschiedene Informationen über die Pakete enthält, die APT
benötigt. Um die Pakete benutzen zu können, fügen Sie folgendes der
<tt>/etc/sources.list</tt> hinzu:
<p>
<example>
deb file:/root debs/
</example>
<p>
Nachdem Sie das getan haben, können sie einfach die gewöhnlichen
APT-Kommandos benutzen. Sie können ebenfalls ein Quellarchiv
erstellen. Die Prozedur ist dieselbe, aber die Dateien
<tt>.orig.tar.gz</tt>, <tt>.dsc</tt> und <tt>.diff.gz</tt> müssen sich
in dem Verzeichnis befinden und statt <tt>Packages.gz</tt> heißt es hier 
<tt>Sources.gz</tt>. Außerdem müssen Sie ein anderes Programm benutzen. Es heißt 
<prgn>dpkg-scansources</prgn>. Das Kommando sieht folgendermaßen aus:
<p>
<example>
# dpkg-scansources debs | gzip &gt; debs/Sources.gz
</example>
<p>
<prgn>dpkg-scansources</prgn> braucht keine <tt>override</tt>-Datei.
Die Zeile in der sources.list lautet:
<p>
<example>
deb-src file:/root debs/
</example>
</sect>

<sect id="netselect">Entscheidung - Welcher Mirror ist der beste für die sources.list: netselect, netselect-apt <p>
Eine häufige Frage, der meist neuen Benutzer ist: "Welchen Debian-Mirror
soll ich in die <tt>sources.list</tt> eintragen?". Es gibt
viele Wege, sich für einen Mirror zu entscheiden. Die fortgeschritteneren
Benutzer haben
möglicherweise ein Skript, welches den Ping mehrerer Mirrors vergleicht.
Aber es gibt so ein Programm inzwischen auch für weniger erfahrene Benutzer: 
<strong>netselect</strong>.
<p>
Installieren tut man netselect wie üblich:
<p>
<example>
# apt-get install netselect
</example>
<p>
Wenn man es ohne Parameter ausführt, zeigt es seinen Hilfetext an. Führt man es
mit einer durch Leerzeichen separierten Liste von Hostnamen (Mirrors)
aus, gibt es uns einen Hostnamen zusammen mit der einer Punktzahl 
zurück. Diese Punktzahl berücksichtigt die erwarteten Pingzeit und 
die Zahl der Hops (Rechner, die eine Netzwerkanfrage passiert, um ihren
Zielort zu erreichen) und ist antiproportional zur erwarteten 
Downloadgeschwindigkeit (also je niedriger, desto besser). 
Angezeigt wird nur der Host mit der niedrigsten Punktzahl (Die ganze Liste der
Mirrors kann mit der Option -vv angesehen werden). Zum Beispiel: <example>
# netselect ftp.debian.org http.us.debian.org ftp.at.debian.org download.unesp.br ftp.debian.org.br
  365 ftp.debian.org.br
#
</example>
<p>
Das bedeutet, daß von den Mirrors die als Parameter an netselect 
übergeben wurden, <tt>ftp.debian.org.br</tt> der beste war mit einer
Punktzahl von 365. (Achtung! Weil es auf meinem Computer ausgeführt wurde
und die Netzwerktopographie extrem unterschiedlich und abhängig vom 
Standort des Computers ist, ist dieser Wert nicht notwendigerweise 
die richtige Geschwindigkeit für andere Computer.
<p>
Jetzt tragen Sie einfach den schnellsten Mirror in die 
<tt>/etc/apt/sources.list</tt> ein (sehen Sie <ref id="sources.list">)
und befolgen Sie die Tips in <ref id="apt-get">.
<p> <strong>Hinweis:</strong> Die Liste der Mirrors ist immer auf
<url id="http://www.debian.org/mirror/mirrors_full"
name="http://www.debian.org/mirror/mirrors_full"> zu finden. <p>
Ab Version 0.3 enthält das netselect-Paket das 
<strong>netselect-apt</strong>-Script, das obigen Prozeß automatisiert.
Übergeben Sie einfach die Distribution als Parameter (Der Defaultwert ist
stable) und die <tt>sources.list</tt> wird mit den besten "main"- und
"non-US"-Mirrors generiert und im aktuellen Verzeichnis gespeichert. Das folgende 
Beispiel generiert eine sources.list für die stabile Distribution:
<p>
<example>
# ls sources.list
ls: sources.list: File or directory not found
# netselect-apt stable
(...)
# ls -l sources.list
sources.list
#
</example>
<p>
<strong>Hinweis:</strong> Die <tt>sources.list</tt> wird im aktuellen
Verzeichnis erzeugt und muß nach <tt>/etc/apt</tt> verschoben werden.
<p>
Danach befolgen Sie die Tips in <ref id="apt-get">.
</sect>

<sect id="cdrom">Hinzufügen einer CD-ROM in die sources.list
<p>
Wenn Sie lieber eine CD-ROM zum Installieren von Paketen oder Updaten
Ihres Systems durch APT verwenden möchten, können Sie sie in Ihre
<tt>sources.list</tt> eintragen.
Um dieses zu tun, können Sie das Programm <prgn>apt-cdrom</prgn>,
wie im folgenden beschrieben, benutzen:

<p>
<example>
# apt-cdrom add
</example>

<p>
Hierfür muß die Debian CD-ROM im Laufwerk liegen. Die CD-ROM wird
gemountet, und wenn sie eine gültige Debian-CD ist, wird nach 
Paketinformationen gesucht. Wenn Ihre CD-ROM-Konfiguration ein
wenig ungewöhnlich ist, können Sie die folgenden Optionen benutzen: 

<p>
<example>
-h           - program help
-d directory - CD-ROM mount point
-r           - Rename a recognized CD-ROM
-m           - No mounting
-f           - Fast mode, don't check package files
-a           - Thorough scan mode
</example>

<p>
Zum Beispiel:

<p>
<example>
# apt-cdrom -d /home/kov/mycdrom add
</example>

<p>
Eine CD kann auch identifiziert werden ohne sie zur sources.list hinzuzufügen:

<p>
<example>
# apt-cdrom ident
</example>

<p>
Obiges funktioniert nur, wenn das CD-ROM Laufwerk in der
<tt>/etc/fstab</tt> korrekt konfiguriert ist. 
</sect>

</chapt>


<chapt id="apt-get">Paketverwaltung
<sect id="update">Update der Liste der verfügbaren Pakete
<p>
Das Paketsystem benutzt eine private Datenbank mit Informationen
über installierte, nicht installierte und für eine Installation verfügbare
Pakete.
Das Programm <prgn>apt-get</prgn> benutzt diese Datenbank, um herauszufinden,
wie es die vom Benutzer angeforderten Pakete installieren soll und
welche zusätzlichen Pakete benötigt werden, damit die ausgewählten
Pakete ordentlich funktionieren.
<p>
Um diese Liste zu updaten, benutzt man das Kommando <prgn>apt-get update</prgn>.
<prgn>apt-get</prgn> sucht dann nach den Paketlisten in den Archiven aus der 
<tt>/etc/apt/sources.list</tt>; In <ref id="sources.list"> finden Sie 
weitere Information über diese Datei. 
<p>
Es ist eine gute Idee, dieses Kommando regelmäßig auszuführen, um sich 
selbst und sein System auf dem neusten Stand über mögliche Paket- bzw.
Sicherheitsupdates zu halten.
</sect>

<sect id="install">Installieren von Paketen
<p>
Endlich kommt das, worauf Sie alle gewartet haben! Mit der fertigen 
sources.list und der Liste der verfügbaren Pakete auf dem neusten Stand ist
alles, was Sie zu tun haben <tt>apt-get</tt> auszuführen, um das
gewünschte Paket zu installieren. Zum Beispiel:

<p>
<example>
# apt-get install xchat
</example>

<p>
APT durchsucht seine Datenbank nach der aktuellsten Version dieses Paketes und
holt es aus dem entsprechenden Archiv, welches in der <tt>sources.list</tt>
spezifiziert ist.
Wenn es eintritt, daß das Paket von einem anderen abhängt -- wie es hier
der Fall ist -- überprüft APT die Abhängigkeiten und installiert die benötigten
Pakete. Sehen Sie folgendes Beispiel:

<example>
# apt-get install nautilus
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 0 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 17.2MB will be used.
Do you want to continue? [Y/n] 
</example>

<p>
Das Paket <package>nautilus</package> benötigt die genannten Bibliotheken 
(bonobo libmedusa0 libnautilus0), deshalb holt APT sie aus dem Archiv.
Übergibt man <tt>apt-get</tt> die Namen der Bibliotheken beim Aufruf mit, fragt
es nicht, ob es fortfahren soll, es akzeptiert automatisch, daß die genannten Pakete
installiert werden sollen.
<p>
Das bedeutet, daß APT nur um Bestätigung bittet, wenn es Pakete 
installieren muß, die man nicht auf der Kommandozeile übergeben hat.
<p>
Die folgenden Optionen von apt-get können hilfreich sein:

<p>
<example>
-h  Dieser Hilfetext
-d  Nur herunterladen - Nicht installieren oder entpacken
-f  Versuche fortzufahren wenn der integrity check fehlschlägt
-s  Nichts wirklich tun. Simulation durchführen.
-y  Beantworte alle Fragen mit Ja anstatt sie zu stellen.
-u  Zeige eine Liste der Pakete die geupgraded werden.
</example>

<p>
Es können mehrere Pakete in einer Zeile zur Installation
ausgewählt werden.
Pakete, die über das Netzwerk oder Internet heruntergeladen
wurden, werden im Verzeichnis <tt>/var/cache/apt/archives</tt>
für spätere Installationen gespeichert. 
<p>
Ebenfalls kann man Pakete zum Entfernen auf derselben Zeile angeben,
indem man ein '-' direkt hinter den Paketnamen hängt wie im folgenden:

<p>
<example>
# apt-get install nautilus gnome-panel-       
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n] 
</example>

<p>
Im Abschnitt <ref id="remove"> finden Sie weitere Details zum Entfernen von Paketen.
<p>
Wenn Sie ein installiertes Paket irgendwie beschädigt haben oder einfach
die Dateien eines Paketes mit der aktuellsten verfügbaren Version neu 
installieren möchten, können Sie die Option <tt>--reinstall</tt> 
wie im folgenden nutzen: 

<p>
<example>
# apt-get --reinstall install gdm
Reading Package Lists... Done
Building Dependency Tree... Done
0 packages upgraded, 0 newly installed, 1 reinstalled, 0 to remove and 1  not upgraded.
Need to get 0B/182kB of archives. After unpacking 0B will be used.
Do you want to continue? [Y/n]
</example>

<p>
Die Version des APT, die zur Erstellung dieser Anleitung benutzt wurde, ist
Version 0.5.3, die aktuelle Version in Debian `unstable' (<tt>sid</tt>)
zur Zeit als sie geschrieben wurde.
Wenn diese Version installiert ist, kann APT auf Ihren Wunsch noch mehr:
Sie können ein Kommando der Form <tt>apt-get install paket/distribution</tt>
benutzen, um ein Paket einer anderen Distribution zu installieren, oder 
<tt>apt-get install package=version</tt>. Zum Beispiel:

<p>
<example>
# apt-get install nautilus/unstable
</example>

<p>
Dies installiert nautilus aus der Distribution `unstable', auch wenn
die aktuell laufende Distribution `stable' ist.
Mögliche Werte für 'distribution' sind 
<tt>stable</tt>, <tt>testing</tt>, und <tt>unstable</tt>.
<p>
Meistens ist es besser, die Option <tt>-t</tt> zu benutzen, um eine 
Distribution zu wählen, was dazu führt, daß <prgn>apt-get</prgn>
diese Distribution beim Auflösen von Abhängigkeiten bevorzugt.
<p>
<em>WICHTIG</em>: Die `unstable'-Version von Debian ist die Version,
in welcher neue Versionen von Debian-Paketen zuerst erscheinen. Diese
Distribution sieht alle Änderungen, die an Paketen vorgenommen werden,
kleinere und größere, welche mehrere Pakete oder das ganze System 
betreffen können. Aus diesem Grund sollte sie <em>nicht</em> von unerfahrenen 
Benutzern oder solchen, die geprüfte Stabilität brauchen, verwendet 
werden. 

<p>
Die `testing'-Distribution ist ein wenig besser als `unstable' was Stabilität 
angeht, jedoch sollte für Produktionssysteme die Distribution `stable' 
benutzt werden.
</sect>

<sect id="remove">Pakete entfernen
<p>
Wenn ein Paket nicht mehr gebraucht wird, kann es mit APT 
vom System entfernt werden.
Geben Sie einfach <tt>apt-get remove package</tt> ein.
Zum Beispiel:

<p>
<example>
# apt-get remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets gnome-panel gnome-panel-data gnome-session 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n] 
</example>

<p>
Wie im obigen Beispiel zu sehen ist, kümmert sich APT ebenfalls um das 
Entfernen der Pakete, die das Paket, das Sie entfernen wollen, benötigen.
Es gibt keine Möglichkeit, Pakete mit APT zu entfernen, ohne
gleichzeitig die Pakete zu entfernen, die von dem entfernten Paket abhängen.
<p>
Wenn man <prgn>apt-get</prgn> ausführt wie oben angegeben, werden die Pakete
entfernt, aber die Konfigurationsdateien, falls es welche gibt, bleiben auf
dem System.
Für eine komplette Entfernung der Pakete, sehen Sie folgendes Beispiel:

<p>
<example>
# apt-get --purge remove gnome-panel
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
0 packages upgraded, 0 newly installed, 4 to remove and 1  not upgraded.
Need to get 0B of archives. After unpacking 14.6MB will be freed.
Do you want to continue? [Y/n] 
</example>

<p>
Der '*' hinter den Namen der Pakete, die vom zu entfernenden Paket
abhängen, bedeutet, daß deren Konfigurationsdateien ebenso 
entfernt werden.
<p>
Genau wie bei der Methode <tt>install</tt> kann man auch bei 
<tt>remove</tt> ein Symbol benutzen, um die Wirkung für ein einzelnes
Paket umzukehren. Hier fügt man einem Paket ein <tt>'+'</tt> zu und
das Paket wird installiert, anstatt entfernt zu werden. 

<p>
<example>
# apt-get --purge remove gnome-panel nautilus+
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
The following packages will be REMOVED:
  gnome-applets* gnome-panel* gnome-panel-data* gnome-session* 
The following NEW packages will be installed:
  bonobo libmedusa0 libnautilus0 nautilus 
0 packages upgraded, 4 newly installed, 4 to remove and 1  not upgraded.
Need to get 8329kB of archives. After unpacking 2594kB will be used.
Do you want to continue? [Y/n] 
</example>

<p>
<prgn>apt-get</prgn> listet die Pakete auf, die extra installiert werden
(die gebraucht werden, damit das Programm einwandfrei funktionieren kann),
die entfernt werden und die installiert werden (hier werden die extra-Pakete
noch einmal mit aufgelistet).
</sect>

<sect id="upgrade">Upgrade von Paketen
<p>
Das Aktualisieren von Paketen ist eine tolle Sache mit APT.  Es braucht 
dafür nur einen einzigen Befehl: <tt>apt-get upgrade</tt>. Man kann
dieses benutzen, um Pakete aus der gleichen Distribution zu aktualisieren,
oder aus einer neuen Distribution, obwohl für letzteres 
<tt>apt-get dist-upgrade</tt> empfehlenswerter ist; Siehe
<ref id="dist-upgrade"> für weitere Einzelheiten.
<p>
Es ist sinnvoll, diesen Befehl mit der Option <tt>-u</tt> auszuführen.
Diese Option läßt APT die komplette Liste der Pakete anzeigen,
die aktualisiert werden sollen. Ohne diese Option aktualisiert man quasi 
blind. APT lädt die aktuellsten Versionen aller Pakete herunter und
installiert sie in der richtigen Reihenfolge. Es ist wichtig, daß vor
jedem Aktualisieren der Pakete <tt>apt-get update</tt> ausgeführt wird.
Siehe Abschnitt <ref id="update">. Zum Beispiel:

<p>
<example>
# apt-get -u upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages have been kept back
  cpp gcc lilo 
The following packages will be upgraded
  adduser ae apt autoconf debhelper dpkg-dev esound esound-common ftp indent
  ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0 libesd0-dev
  libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev liborbit0
  libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit procps psmisc 
29 packages upgraded, 0 newly installed, 0 to remove and 3 not upgraded.
Need to get 5055B/5055kB of archives. After unpacking 1161kB will be used.
Do you want to continue? [Y/n] 
</example>

<p>
Das ganze ist extrem einfach. Die ersten paar Zeilen sagen, daß einige
Pakete zurückgehalten werden (have been <tt>kept back</tt>). Das bedeutet, 
daß es neuere Versionen dieser Pakete gibt, die aus irgendeinem Grund
nicht installiert werden. Mögliche Gründe sind unerfüllbare Abhängigkeiten
(z.B. wenn ein Paket, von dem das neue Paket abhängt, nicht im Archiv
verfügbar ist) oder neue Abhängigkeiten (das Paket hängt nun von
neuen Paketen ab). 
<p>
Es gibt keine "saubere" Lösung für das erste Problem. Für den zweiten
Fall kann man <tt>apt-get install</tt> für das spezielle Paket 
ausführen, das zurückgehalten wurde, da dann auch die Abhängigkeiten 
aufgelöst werden. Eine noch sauberere Lösung ist es, <tt>dist-upgrade</tt>
zu benutzen. Siehe Abschnitt <ref id="dist-upgrade">.
</sect>

<sect id="dist-upgrade">Upgrade einer Debian-Version
<p>
Diese Funktion erlaubt es, ein ganzes Debian-System entweder über das
Internet oder von einer neuen CD (die Sie kaufen oder aus dem Internet
herunterladen können) auf einmal zu aktualisieren.
<p>
Außerdem ist es sinnvoll, wenn an den Abhängigkeiten zwischen den Paketen 
Änderungen vorgenommen wurden. Mit <tt>apt-get upgrade</tt> werden solche
Pakete nicht installiert (sie werden auf dem derzeitigen Stand gehalten 
<tt>kept back</tt>).
<p>
Wenn auf Ihrem System z.B. Revision 0 der stabilen Debian-Version läuft
und Sie sich Revision 3 auf CD kaufen, können Sie APT benutzen, um ein Upgrade
auf die neue Version von CD durchzuführen.
Dafür benutzen Sie <prgn>apt-cdrom</prgn> (Siehe Abschnitt <ref id="cdrom">),
um die CD zu Ihrer <tt>/etc/apt/sources.list</tt> hinzuzufügen und führen
Sie <tt>apt-get dist-upgrade</tt> aus.
<p>
Es ist wichtig zu wissen, daß APT immer nach der aktuellsten Version 
eines Pakets sucht. Wenn also Ihre <tt>/etc/apt/sources.list</tt> auf ein
Archiv zeigt, das eine neuere Version eines Pakets enthält als sich
auf der CD befindet, lädt APT das Paket aus diesem herunter.
<p>
In dem Beispiel aus Abschnitt <ref id="upgrade"> sehen wir, daß manche Pakete 
nicht aktualisiert wurden (<tt>kept back</tt>). Wir werden dieses Problem nun 
mit der Funktion <tt>dist-upgrade</tt> lösen:

<p>
<example>
# apt-get -u dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following NEW packages will be installed:
  cpp-2.95 cron exim gcc-2.95 libident libopenldap-runtime libopenldap1
  libpcre2 logrotate mailx 
The following packages have been kept back
  lilo 
The following packages will be upgraded
  adduser ae apt autoconf cpp debhelper dpkg-dev esound esound-common ftp gcc
  indent ipchains isapnptools libaudiofile-dev libaudiofile0 libesd0
  libesd0-dev libgtk1.2 libgtk1.2-dev liblockfile1 libnewt0 liborbit-dev
  liborbit0 libstdc++2.10-glibc2.2 libtiff3g libtiff3g-dev modconf orbit
  procps psmisc 
31 packages upgraded, 10 newly installed, 0 to remove and 1 not upgraded.
Need to get 0B/7098kB of archives. After unpacking 3118kB will be used.
Do you want to continue? [Y/n]
</example>

<p>
Hier ist zu bemerken, daß die Pakete aktualisiert werden, aber neue Pakete
(neue Abhängigkeiten der aktualisierten Pakete) zusätzlich installiert werden.
Weiterhin wird lilo immer noch nicht aktualisiert, es gibt möglicherweise 
schwerwiegendere Probleme mit diesem Paket. Wir können das prüfen, in dem wir
folgendes ausführen:

<p>
<example>
# apt-get -u install lilo
Reading Package Lists... Done
Building Dependency Tree... Done
The following extra packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be REMOVED:
  debconf-tiny 
The following NEW packages will be installed:
  cron debconf exim libident libopenldap-runtime libopenldap1 libpcre2
  logrotate mailx 
The following packages will be upgraded
  lilo 
1 packages upgraded, 9 newly installed, 1 to remove and 31 not upgraded.
Need to get 225kB/1179kB of archives. After unpacking 2659kB will be used.
Do you want to continue? [Y/n]
</example>

<p>
Hier erfahren wir, daß das neue lilo einen Konflikt mit dem Paket 
<package>debconf-tiny</package> hat, was bedeutet, daß wir es nicht
installieren (oder aktualisieren) können, ohne debconf-tiny zu
entfernen.
<p>
Um herauszufinden, wovon ein Paket zurückgehalten oder entfernt wird, 
können Sie folgendes tun:

<p>
<example>
# apt-get -o Debug::pkgProblemResolver=yes dist-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Starting
Starting 2
Investigating python1.5
Package python1.5 has broken dep on python1.5-base
  Considering python1.5-base 0 as a solution to python1.5 0
  Holding Back python1.5 rather than change python1.5-base
Investigating python1.5-dev
Package python1.5-dev has broken dep on python1.5
  Considering python1.5 0 as a solution to python1.5-dev 0
  Holding Back python1.5-dev rather than change python1.5
 Try to Re-Instate python1.5-dev
Done
Done
The following packages have been kept back
  gs python1.5-dev 
0 packages upgraded, 0 newly installed, 0 to remove and 2  not upgraded.
</example>

Auf diesem Wege ist es einfach festzustellen, daß das python1.5-dev Paket 
wegen einer ungelösten Abhängigkeit zu python1.5 nicht installiert werden 
kann.

</sect>

<sect id="clean">Ungenutzte Pakete entfernen: apt-get clean and autoclean    
<p>   
Wenn ein Paket installiert werden soll, bezieht APT von den Quellen,
die in der /etc/apt/sources.list aufgelistet sind, die nötigen Dateien,
legt sie in ein lokales Archiv (<file>/var/cache/apt/archives/</file>) und
fährt mit der Installation fort. (sehen Sie <ref id="install">).
<p>
Nach und nach kann dieses lokale Archiv immer größer werden und eine Menge
Platz auf der Festplatte belegen. Auch für diesen Fall bietet APT Werkzeuge an,
um sein lokales Archiv zu warten:
<prgn>apt-get</prgn>s <tt>clean</tt> und <tt>autoclean</tt> Methoden.
<p>
<prgn>apt-get clean</prgn> entfernt alles bis auf Lock-Dateien (sehen Sie <ref id="glossar">)
aus <file>/var/cache/apt/archives/</file> und <file>/var/cache/apt/archives/partial/</file>.
In der Folge muß APT ein Paket, das Sie erneut installieren wollen auch erneut herunterladen.
<p>
<prgn>apt-get autoclean</prgn> entfernt nur Pakete, die nicht mehr heruntergeladen
werden können.
<p>
Das folgende Beispiel sollte zeigen, wie apt-get autoclean arbeitet:

<p>
<example>
# ls /var/cache/apt/archives/logrotate* /var/cache/apt/archives/gpm*
logrotate_3.5.9-7_i386.deb
logrotate_3.5.9-8_i386.deb
gpm_1.19.6-11_i386.deb
</example>

<p>
In /var/cache/apt/archives liegen zwei Versionen des Pakets
<package>logrotate</package> und eine Version des Pakets 
<package>gpm</package>.

<p>
<example>
# apt-show-versions -p logrotate
logrotate/stable uptodate 3.5.9-8
# apt-show-versions -p gpm
gpm/stable upgradeable from 1.19.6-11 to 1.19.6-12
</example>

<p>
<prgn>apt-show-versions</prgn> shows that
<file>logrotate_3.5.9-8_i386.deb</file> provides the up to date version
of <package>logrotate</package>, so
<file>logrotate_3.5.9-7_i386.deb</file> is useless. Also
<file>gpm_1.19.6-11_i386.deb</file> is useless because a more recent
version of the package can be retrieved.

<p>
<example>
# apt-get autoclean
Reading Package Lists... Done
Building Dependency Tree... Done
Del gpm 1.19.6-11 [145kB]
Del logrotate 3.5.9-7 [26.5kB]
</example>

<p>
<tt>apt-get autoclean</tt> entfernt also nur die alten Pakete.
Für weitere Informationen über apt-show-versions sehen Sie 
<ref id="apt-show-versions">.
</sect>

<sect id="dselect-upgrade">APT unter dselect verwenden...
<p>
<prgn>dselect</prgn> ist ein Programm, daß Debian-Benutzern hilft, zu installierende
Pakete auszuwählen. Viele halten es für zu kompliziert und vielmehr langweilig, aber
mit ein wenig Übung kann man durchaus Gefallen an seiner konsolen-basierten 
ncurses-Oberfläche finden.
<p>
Eine Stärke von dselect ist es, daß es mit den Möglichkeiten umgehen kann,
die Debian-Pakete haben, um andere Pakete zu empfehlen ("suggesting") oder 
vorzustellen ("recommending").
Um es zu benutzen, rufen Sie <tt>`dselect'</tt> als root auf.
Wählen Sie 'apt' als Zugriffsmethode. Das ist zwar nicht dringend
notwendig, aber wenn Sie keine CD-ROM benutzen und Pakete aus dem
Internet herunterladen möchten, ist es der beste Weg.
<p>
Um ein besseres Verständnis über die Benutzung von dselect zu
erhalten, lesen Sie die Dokumentation auf der Debian-Homepage
<url id="http://www.debian.org/doc/ddp" name="http://www.debian.org/doc/ddp">.
<p>
Nachdem Sie Ihre Auswahl mit deselect getroffen haben, benutzen Sie folgendes
Kommando

<p>
<example>
# apt-get -u dselect-upgrade
</example>

<p>
wie im folgenden Beispiel:

<example>
# apt-get -u dselect-upgrade
Reading Package Lists... Done
Building Dependency Tree... Done
The following packages will be REMOVED:
  lbxproxy 
The following NEW packages will be installed:
  bonobo console-tools-libs cpp-3.0 enscript expat fingerd gcc-3.0
  gcc-3.0-base icepref klogd libdigest-md5-perl libfnlib0 libft-perl
  libgc5-dev libgcc300 libhtml-clean-perl libltdl0-dev libsasl-modules
  libstdc++3.0 metamail nethack proftpd-doc psfontmgr python-newt talk tidy
  util-linux-locales vacation xbill xplanet-images 
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 30 newly installed, 1 to remove and 0  not upgraded.
Need to get 7140kB of archives. After unpacking 16.3MB will be used.
Do you want to continue? [Y/n]
</example>

<p>
Im Vergleich: apt-get dist-upgrade auf demselben System:

<p>
<example>
# apt-get -u dist-upgrade   
Reading Package Lists... Done
Building Dependency Tree... Done
Calculating Upgrade... Done
The following packages will be upgraded
  debian-policy 
1 packages upgraded, 0 newly installed, 0 to remove and 0  not upgraded.
Need to get 421kB of archives. After unpacking 25.6kB will be freed.
Do you want to continue? [Y/n]
</example>

<p>
Viele der Pakete im oberen Beispiel werden installiert, weil andere Pakete
sie "empfehlen ("suggest" or "recommend"). Andere werden aufgrund unserer 
Auswahl, die wir beim Navigieren durch die Paketlisten von dselect
getroffen haben, installiert oder entfernt (Im Falle von lbxproxy z.B.).
Dselect kann in Verbindung mit APT ein nützliches Werkzeug sein. 
</sect>

<sect id="default-version">Wartung eines "gemischten" Systems
<p>
Viele benutzen die "testing"-Distribution, da sie stabiler ist als
"unstable" und aktueller als "stable" ist. Benutzer, die
aktuelle Versionen von Paketen wollen, sich aber nicht trauen, ihr ganzes
System auf "unstable" umzustellen haben die Möglichkeit 
"testing" und "unstable" zu mischen. Auf der anderen Seite möchten 
konservativere
Benutzer vielleicht "stable" und "testing" mischen.
<p>
Für diesen Zweck muß die folgende Zeile in die <file>/etc/apt/apt.conf</file>
eingefügt werden:

<p>
<example>
APT::Default-Release "testing";
</example>

<p>
Um nun Pakete aus unstable zu installieren, muß die 
Option <tt>-t</tt> benutzt werden:

<p>
<example>
# apt-get -t unstable install <var>Paketname</var>
</example>

<p>
Vergessen Sie aber nicht, daß Sie, um ein Paket aus einer
anderen Debian Version zu installieren, eine Quellzeile
in die <file>/etc/apt/sources.list</file> einfügen 
müssen. In unserem Beispiel brauchen wir Quellzeilen
für die "unstable"-Distribution neben denen für "testing".

</sect>

<sect id="apt-show-versions">Upgrade von Paketen spezieller Debian-Versionen
<p>
<prgn>apt-show-versions</prgn> bietet einen sicheren Weg für Benutzer 
gemischter Systeme, um ihre Systeme zu aktualisieren, ohne mehr aus der 
weniger stabilen Distribution zu installieren als sie im Sinn haben.
Zum Beispiel ist es möglich, nur die "unstable"-Pakete zu aktualisieren, in 
dem man folgendes ausführt:
<p>
<example>
# apt-get install `apt-show-versions -u -b | grep unstable`
</example>
</sect>

<sect id="pin">Wie man bestimmte Versionen eines Paketes behält (komplex)
<p>
Manchmal gibt es Gründe, etwas in einem Paket zu verändern, und es fehlt
die Zeit oder die Lust, diese Dinge auf neue Versionen des Paketes 
zu übertragen. Vielleicht haben Sie auch gerade Ihre Debian-Version auf
3.0 aktualisiert, aber möchten trotzdem ein Paket aus Version 2.2 behalten.
Es ist möglich, die installierte Version zu markieren (pin), so daß sie
nicht aktualisiert wird.
<p>
Diese Möglichkeit einzusetzen ist einfach. Editieren Sie einfach die Datei
<tt>/etc/apt/preferences</tt>.
<p>
Das Format ist trivial:
<p>
<example>
Package: &lt;Paket&gt;
Pin: &lt;Pin-Definition&gt;
Pin-Priority: &lt;Priorität des Pins&gt;
</example>
<p>
Um zum Beispiel das Paket <package>sylpheed</package> zu behalten, welches 
ich dazu gebracht habe "reply-to-list" in Version 0.4.99 zu benutzen,
füge ich folgendes hinzu:
<p>
<example>
Package: sylpheed
Pin: version 0.4.99*
</example>
<p>
Bemerken Sie das <tt>*</tt> (Sternchen/Asterisk). Es funktioniert als 
Platzhalter; das bedeutet, daß dieser "Pin" für alle Versionen die mit
0.4.99 beginnen gültig sein soll. Das ist nötig, da Pakete in Debian
eine Nummer für die "Debian-Revision" enthalten und ich nicht verhindern
möchte, daß diese Revisionen installiert werden. Folglich werden 
die Versionen 0.4.99-1 und 0.4.99-10 installiert, sobald sie verfügbar
sind. Bemerken Sie, daß Sie das vermutlich nicht möchten, wenn Sie
das Paket modifiziert haben, da diese Änderungen dann verloren gehen.
<p>
Das <tt>Pin-Priority</tt> Feld ist optional; wenn nicht anders spezifiziert
hat der "Pin" die Priorität 989.
<p>
Lassen Sie uns einen Blick darauf werfen, wie die Pin-Priorität funktioniert.
Eine niedrigere Priorität als Null bewirkt, daß das Paket nie installiert 
wird. Prioritäten von 0 bis 100 bezeichnen Pakete, die nicht installiert sind
und keine verfügbare Version haben. Solche Pakete werden in der Auswahl 
verfügbarer Versionen nicht berücksichtigt. Die Priorität 100 bezeichnet
ein installiertes Paket. Damit eine installierte Version von einer 
anderen ersetzt wird, muß die Priorität über 100 liegen.
<p>
Prioritäten über 100 sagen aus, daß ein Paket installiert werden soll.
Normalerweise wird ein installiertes Paket nur durch neuere Versionen
übersetzt. Alle Prioritäten zwischen 100 und 1000 (inklusive) führen
zu diesem Normalverhalten. Ein Paket mit solcher Priorität wird nicht
durch eine niedrigere Version ersetzt. Wenn ich also zum Beispiel 
sylpheed 0.5.3 installiert habe und einen Pin auf sylpheed 0.4.99
mit der Priorität 999 definiert habe, wird Version 0.4.99 <em>nicht</em>
installiert werden, um den Pin zu erfüllen. Um Pakete deaktualisieren
zu können, um einen Pin zu erfüllen, braucht der Pin eine Priorität von 
über 1000. 
<p>
Ein Pin kann für die <tt>version</tt>, das <tt>release</tt> oder die
Herkunft (<tt>origin</tt>) definiert werden. 
<p>
Für einen Pin auf die <tt>version</tt>, wie oben beschrieben,
kann man sowohl Versionsnummern als auch Platzhalter (Sternchen)
verwenden. Letzteres spezifiziert mehrere Versionen in einem Pin.
<!-- what's available?  standard shell globs?  ?*[]   or more? -->
<p>
Die Option <tt>release</tt> benutzt die Release-Datei aus den
APT-Archiven oder von den CDs. Die Brauchbarkeit dieser Version
verfällt, wenn Sie APT-Archive benutzen, die diese Datei nicht
zur Verfügung stellen. Sie können den Inhalt der Release-Dateien, 
die Sie haben in <tt>/var/lib/apt/lists/</tt> nachlesen.
Die Parameter für ein Release sind:
<tt>a</tt> (Archiv(Archive)), <tt>c</tt> (Sektion(Component)), <tt>v</tt> (Version(Version)),
<tt>o</tt> (Herkunft(Origin)) und <tt>l</tt> (Label(Label)).
<p>
Beispiel:
<p>
<example>
Package: *
Pin: release v=2.2*,a=stable,c=main,o=Debian,l=Debian
Pin-Priority: 1001
</example>
<p>
In diesem Beispiel wählen wir die Debian-Version 2.2* (was 2.2r2,
2.2r3 sein kann -- r* bezeichnet so genannte "point releases", welche
normalerweise Sicherheitsupdates und andere extrem wichtige Updates 
enthalten), das <tt>stable</tt> Archiv, die Sektion <tt>main</tt> (im
Gegensatz zu <tt>contrib</tt> oder <tt>non-free</tt>) und Herkunft und
Label Debian. Herkunft (o=) bezeichnet, wer die Release-Datei erstellt hat,
das Label (l=) definiert den Namen des Debian-Distribution: Debian für
Debian selbst und Progeny für Progeny Linux zum Beispiel. Ein Beispiel
einer Release-Datei:
<p>
<example>
$ cat /var/lib/apt/lists/ftp.debian.org.br_debian_dists_potato_main_binary-i386_Release
Archive: stable
Version: 2.2r3
Component: main
Origin: Debian
Label: Debian
Architecture: i386
</example>
</sect>
</chapt>

<chapt id="helpers">Sehr nützliche Helfer
<sect id="equivs">Installieren selbstkompilierter Pakete: equivs
<p>
Manchmal will man spezielle Versionen eines Programms benutzen,
die nur als Quellcode verfügbar sind und nicht als Debian-Paket.
Hier kann es allerdings Probleme mit dem Paket-System geben.
Angenommen Sie wollen eine neue Version Ihres Mailservers 
kompilieren und alles klappt, aber viele Pakete in Debian
hängen von einem MTA (Mail Transfer Agent) ab. 
Da etwas installiert wurde, was 
Sie selbst kompiliert haben, weiß das Paketsystem darüber
nicht Bescheid.
<p>
Hier kommt das <package>equivs</package> ins Spiel. Um es zu
benutzen, installieren Sie das Paket mit diesem Namen. Es 
erstellt ein leeres Paket, das die Abhängigkeiten erfüllt und
dem Paketsystem mitteilt, so daß es keine Probleme mit 
Abhängigkeiten gibt.
<p>
Bevor wir näher darauf eingehen, ist es wichtig, Sie darauf hinzuweisen,
daß es sicherere Möglichkeiten gibt, Programme, für die in Debian
schon Pakete existieren, mit anderen Optionen zu kompilieren und
man equivs nicht benutzen sollte, um Abhängigkeiten zu entfernen,
ohne genau zu wissen, was man tut. 
Siehe <ref id="sourcehandling"> für nähere Informationen.
<p>
Lassen Sie uns mit dem MTA-Beispiel fortfahren. Sie haben also
gerade Ihren frisch kompilierten <prgn>postfix</prgn> installiert
und wollen nun <package>mutt</package> (ein Mailprogramm) installieren.
Plötzlich stellen Sie fest, daß <package>mutt</package> einen anderen
MTA installieren möchte, obwohl Sie schon Ihren selbstkompilierten
laufen haben.
<p>
Wechseln Sie in irgendein Verzeichnis (z.B. <file>/tmp</file>), und führen
Sie folgendes aus:

<p>
<example>
# equivs-control <var>name</var>
</example>

<p>
Ersetzen Sie  <var>name</var> durch den Namen der Kontrolldatei, die Sie 
erstellen wollen. Die Datei wird wie folgt erstellt:

<p>
<example>
Section: misc
Priority: optional
Standards-Version: 3.0.1

Package: &lt;Paketname; wenn nicht angegeben: equivs-dummy&gt;
Version: &lt;Versionsnummer; wenn nicht angegeben: 1.0&gt;
Maintainer: &lt;Ihr Name mit Emailadresse; wenn nicht angegeben: Benutzername &gt;
Pre-Depends: &lt;Pakete&gt;
Depends: &lt;Pakete&gt;
Recommends: &lt;Pakete&gt;
Suggests: &lt;Pakete&gt;
Provides: &lt;(virtuelles) Paket&gt;
Architecture: all
Copyright: &lt;copyright Datei; normalerweise GPL2&gt;
Changelog: &lt;changelog file; normalerweise ein generisches Changelog&gt;
Readme: &lt;README.Debian file; wenn nicht angegeben, ebenfalls ein generisches&gt;
Extra-Files: &lt;Zusätzliche Dateien für das doc-Verzeichnis, kommasepariert&gt;
Description: &lt;kurze Beschreibung; Standard ist "some wise words"&gt;
 Lange Beschreibung und Info
 .
 Zweiter Paragraph
</example>

<p>
Nun muß das so angepaßt werden, daß es tut, was wir wollen. Gucken
Sie sich die Felder und ihre Beschreibungen an, es ist nicht nötig,
jedes einzelne hier zu erklären, lassen Sie uns das Nötigste tun: 

<p>
<example>
Section: misc
Priority: optional
Standards-Version: 3.0.1

Package: mta-local
Provides: mail-transport-agent
</example>

<p>
Das war es schon. <package>mutt</package> hängt von
<package>mail-transport-agent</package> ab, was ein
virtuelles Paket ist, was alle MTAs liefern. Ich 
hätte das Paket einfach <package>mail-transport-agent</package>
nennen können, aber ich bevorzugte das Schema für virtuelle
Pakete, welches das Feld "Provides" benutzt.
<p>
Nun muß das Paket nur noch gebaut werden:

<p>
<example>
# equivs-build <var>name</var>
dh_testdir
touch build-stamp
dh_testdir
dh_testroot
dh_clean -k
# Add here commands to install the package into debian/tmp.
touch install-stamp
dh_testdir
dh_testroot
dh_installdocs
dh_installchangelogs
dh_compress
dh_fixperms
dh_installdeb
dh_gencontrol
dh_md5sums
dh_builddeb
dpkg-deb: building package `<var>name</var>' in `../<var>name</var>_1.0_all.deb'.

The package has been created.
Attention, the package has been created in the current directory,
</example>
<p>
Und installieren Sie das erzeugte <tt>.deb</tt>.
<p>
Wie man unschwer erkennen kann, gibt es verschiedene Anwendungen für
<prgn>equivs</prgn>. Man könnte sogar ein <tt>Favoriten</tt>-Paket 
erstellen, was von den Paketen abhängt, die Sie normalerweise installieren.
Lassen Sie Ihren Vorstellungen einfach freien Lauf, aber seien Sie vorsichtig.
<p>
Es ist wichtig zu erwähnen, daß es in 
<file>/usr/share/doc/equivs/examples</file> einige Beispiel-Kontrolldateien
gibt. Werfen Sie mal einen Blick darauf.
</sect>

<sect id="localepurge">Entfernen von unbenutzten locale-Dateien: localepurge
<p>
Viele Debian-Benutzer verwenden nur ein locale (Spracheinstellung). 
Ein brasilianischer
Debian-Benutzer benutzt z.B. vermutlich immer das brasilianische 
<tt>pt_BR</tt>-locale
und interessiert sich nicht für das spanische <tt>es</tt>-locale. 
<p>
<package>localepurge</package> ist ein sehr nützliches Werkzeug für diese
Art von Benutzern. Sie können eine Menge Festplattenplatz sparen, wenn
Sie nur die locales installiert haben, die Sie auch wirklich brauchen.
Installieren Sie einfach <tt>apt-get install localepurge</tt>.
<p>
Es ist wirklich einfach zu konfigurieren, Debconf-Fragen führen den
Benutzer Schritt für Schritt durch die Konfiguration. Seien Sie vorsichtig
beim Beantworten der ersten Frage, da falsche Antworten alle locales
entfernen können - selbst die, die Sie benutzen. Die einzige
Möglichkeit, sie wiederherzustellen, ist, alle Pakete neu zu
installieren, die sie enthalten.
</sect>

<sect id="helper-show-versions">Erfahren, welche Pakete aktualisiert werden können
<p>
<prgn>apt-show-versions</prgn> ist ein Programm, das zeigt, welche Pakete im 
System aktualisiert werden können und andere hilfreiche Informationen 
bietet.
Die Option <tt>-u</tt> zeigt eine Liste der Pakete, die aktualisiert werden 
können:

<p>
<example>
$ apt-show-versions -u    
libeel0/unstable upgradeable from 1.0.2-5 to 1.0.2-7
libeel-data/unstable upgradeable from 1.0.2-5 to 1.0.2-7
</example>
</sect>

</chapt>

<chapt id="search">Informationen über Pakete
<p>
Es gibt einige Oberflächen für das APT-System, die es 
signifikant einfacher machen, Listen über verfügbare Pakete oder 
schon installierte Pakete zu bekommen oder auch herauszufinden, zu welcher 
Sektion ein Paket gehört, welche Priorität es hat, wie seine Beschreibung 
lautet, etc.
<p>
Unser Ziel aber hier ist, APT selbst benutzen zu lernen. Wie können wir
also den Namen eines Paketes herausfinden, welches wir installieren 
wollen?
<p>
Es gibt eine Reihe von Möglichkeiten für eine solche Aufgabe. Fangen
wir mit <tt>apt-cache</tt> an. Dieses Programm wird vom APT-System zum 
Warten seiner Datenbank benutzt. Werfen wir nur einen kleinen Blick auf
einige seiner praktischeren Anwendungen.

<sect id="cache">Paketnamen entdecken
<p>
Angenommen, Sie wollen die alten Zeiten des Atari 2600 wieder aufleben 
lassen. Sie möchten APT benutzen, um einen Atari-Emulator zu installieren und
dann Spiele herunterladen. Sie haben folgende Möglichkeit: 

<p>
<example>
# apt-cache search atari
atari-fdisk-cross - Partition editor for Atari (running on non-Atari)
circuslinux - The clowns are trying to pop balloons to score points!
madbomber - A Kaboom! clone
tcs - Character set translator.
atari800 - Atari emulator for svgalib/X/curses
stella - Atari 2600 Emulator for X windows
xmess-x - X binaries for Multi-Emulator Super System
</example>

<p>
Wir finden verschiedene Pakete mit kurzen Beschreibungen. Um weitere 
Informationen über ein bestimmtes Paket zu erhalten, können wir folgendes 
machen:

<p>
<example>
# apt-cache show stella  
Package: stella
Priority: extra
Section: non-free/otherosfs
Installed-Size: 830
Maintainer: Tom Lear &lt;tom@trap.mtview.ca.us&gt;
Architecture: i386
Version: 1.1-2
Depends: libc6 (&gt;= 2.1), libstdc++2.10, xlib6g (&gt;= 3.3.5-1)
Filename: dists/potato/non-free/binary-i386/otherosfs/stella_1.1-2.deb
Size: 483430
MD5sum: 11b3e86a41a60fa1c4b334dd96c1d4b5
Description: Atari 2600 Emulator for X windows
 Stella is a portable emulator of the old Atari 2600 video-game console
 written in C++.  You can play most Atari 2600 games with it.  The latest
 news, code and binaries for Stella can be found at:
 http://www4.ncsu.edu/~bwmott/2600
</example>

<p>
Mit dieser Ausgabe erhalten Sie eine Menge Details über das Paket, das Sie
installieren wollen (oder nicht wollen) inklusive der vollständigen
Beschreibung des Pakets. Wenn das Paket schon installiert ist und es 
eine neuere Version gibt, bekommen Sie Informationen über beide Versionen.
Beispiel:

<p>
<example>
# apt-cache show lilo
Package: lilo
Priority: important
Section: base
Installed-Size: 271
Maintainer: Russell Coker &lt;russell@coker.com.au&gt;
Architecture: i386
Version: 1:21.7-3
Depends: libc6 (&gt;= 2.2.1-2), debconf (&gt;=0.2.26), logrotate
Suggests: lilo-doc
Conflicts: manpages (&lt;&lt;1.29-3)
Filename: pool/main/l/lilo/lilo_21.7-3_i386.deb
Size: 143052
MD5sum: 63fe29b5317fe34ed8ec3ae955f8270e
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.

Package: lilo
Status: install ok installed
Priority: important
Section: base
Installed-Size: 190
Maintainer: Vincent Renardias &lt;vincent@debian.org&gt;
Version: 1:21.4.3-2
Depends: libc6 (&gt;= 2.1.2)
Recommends: mbr
Suggests: lilo-doc
Description: LInux LOader - The Classic OS loader can load Linux and others
 This Package contains lilo (the installer) and boot-record-images to
 install Linux, OS/2, DOS and generic Boot Sectors of other OSes.
 .
 You can use Lilo to manage your Master Boot Record (with a simple text screen)
 or call Lilo from other Boot-Loaders to jump-start the Linux kernel.
</example>

<p>
Das erste in der Liste ist die neu verfügbare Version und das zweite die 
installierte Version. Für generellere Informationen über ein Paket können
Sie folgendes benutzen:

<p>
<example>
# apt-cache showpkg penguin-command
Package: penguin-command
Versions: 
1.4.5-1(/var/lib/apt/lists/download.sourceforge.net_debian_dists_unstable_main_binary-i386_Packages)(/var/lib/dpkg/status)

Reverse Depends: 
Dependencies: 
1.4.5-1 - libc6 (2 2.2.1-2) libpng2 (0 (null)) libsdl-mixer1.1 (2 1.1.0) libsdl1.1 (0 (null)) zlib1g (2 1:1.1.3) 
Provides: 
1.4.5-1 - 
Reverse Provides: 
</example>

<p>
Und um nur herauszufinden, von welchen Paketen es abhängt:

<example>
# apt-cache depends penguin-command
penguin-command
  Depends: libc6
  Depends: libpng2
  Depends: libsdl-mixer1.1
  Depends: libsdl1.1
  Depends: zlib1g
</example>

<p>
Zusammengefaßt haben wir eine handvoll Waffen, die wir benutzen können, um
den Namen des Paketes herauszufinden, das wir installieren wollen.
</sect>

<sect id="dpkg-search">Paketnamen mit dpkg finden
<p>
Ein Weg, den Namen eines Pakets zu finden, ist, den Namen einer wichtigen 
Datei zu kennen, die sich in dem Paket befindet. Um zum Beispiel das
Paket zu finden, welches eine bestimmte <tt>".h"</tt> Datei enthält, das
für das Kompilieren eines Programms benötigt wird, ist folgendes auszuführen: 

<p>
<example>
# dpkg -S stdio.h
libc6-dev: /usr/include/stdio.h
libc6-dev: /usr/include/bits/stdio.h
perl: /usr/lib/perl/5.6.0/CORE/nostdio.h
</example>

<p>
oder:

<p>
<example>
# dpkg -S /usr/include/stdio.h
libc6-dev: /usr/include/stdio.h
</example>

<p>
Um den Namen installierter Pakete herauszufinden, was zum Beispiel zum
Aufräumen der Festplatte nützlich sein kann, benutzen Sie:

<p>
<example>
# dpkg -l | grep mozilla
ii  mozilla-browse 0.9.6-7        Mozilla Web Browser
</example>

<p>
Das Problem mit diesem Befehl ist, daß er Paketnamen "brechen" kann. Im
obigen Beispiel ist der ganze Name des Pakets <tt>mozilla-browser</tt>.
Um das Problem zu beheben, können Sie die Umgebungsvariable 
<tt>COLUMNS</tt> folgendermaßen benutzen: 

<p>
<example>
[kov]@[couve] $ COLUMNS=132 dpkg -l | grep mozilla
ii  mozilla-browser             0.9.6-7                     Mozilla Web Browser - core and browser
</example>

<p>
oder die Beschreibung bzw. einen Teil dieser wie im folgenden:

<p>
<example>
# apt-cache search "Mozilla Web Browser"
mozilla-browser - Mozilla Web Browser
</example>
</sect>

<sect id="auto-apt">Pakete nach Bedarf installieren
<p>
Sie kompilieren gerade ein Programm, und wie aus heiterem Himmel - Boom!
Es gibt einen Fehler, da eine <tt>.h</tt> Datei gebraucht wird, die Sie
nicht haben. Das Programm <prgn>auto-apt</prgn> kann Sie for solchen 
Szenarios bewahren. Es fragt, ob es die benötigten Pakete installieren soll,
nachdem es den betroffenden Prozeß gestoppt hat und führt ihn fort, wenn
die relevanten Pakete installiert sind. 
<p>
Der Befehl sieht folgendermaßen aus:

<p>
<example>
# auto-apt run Kommando
</example>

<p>
Wobei `Kommando' das Kommando ist, was ausgeführt werden soll und evtl.
nicht vorhandene Dateien benötigt. Beispiel:

<p>
<example>
# auto-apt run ./configure
</example>

Es wird fragen, ob die benötigten Pakete installiert werden sollen,
und apt-get automatisch aufrufen. Wenn X läuft, ersetzt eine grafische
Oberfläche die übliche Text-Oberfläche.
<p>
Auto-apt funktioniert mit einer Datenbank welche aktuell gehalten werden
muß, um effektiv zu funktionieren. Das erreicht man mit den Kommandos
<tt>auto-apt update</tt>, <tt>auto-apt updatedb</tt> und
<tt>auto-apt update-local</tt>.
</sect>

<sect id="apt-file">Herausfinden, zu welchem Paket eine Datei gehört
<p>
Wenn ein Paket installiert werden soll und Sie nicht herausfinden können,
wie es heißt, indem Sie mit <prgn>apt-cache</prgn> suchen, aber den Dateinamen
des Programms oder einer Datei, die zu dem Paket gehört kennen, können
Sie <prgn>apt-file</prgn> benutzen, um den Dateinamen zu finden. Das wird
folgendermaßen gemacht:

<p>
<example>
$ apt-file search <var>Dateinamen</var>
</example>

<p>
Es funktioniert genau wie <tt>dpkg -S</tt>, es zeigt Ihnen aber auch 
nicht installierte Pakete, die die Datei enthalten. Man kann es auch dazu 
benutzen, benötigte include-Dateien, die beim Kompilieren von Programmen
fehlen, zu installieren, allerdings ist <prgn>auto-apt</prgn> eine
wesentlich bessere Methode solche Fälle zu lösen, siehe 
<ref id="auto-apt">.
<p>
Man kann auch den Inhalt von Paketen auflisten:

<p>
<example>
$ apt-file list <var>Paketname</var>
</example>

<p>
<prgn>apt-file</prgn> hat genau wie auto-apt eine Datenbank über die 
Dateien aller Pakete und diese muß aktuell gehalten werden:

<p>
<example>
# apt-file update
</example>

<p>
Normalerweise benutzt <prgn>apt-file</prgn> die gleiche Datenbank
wie <prgn>auto-apt</prgn>, sehen Sie <ref id="auto-apt">.

</sect>

<sect id="apt-listchanges">Über Änderungen in Paketen informiert bleiben
<p>
Jedes Paket installiert in sein Dokumentationsverzeichnis (<tt>/usr/share/doc/Paketname</tt>) eine Datei mit Namen <tt>changelog.Debian.gz</tt>, welche die 
Liste der Änderungen gegenüber der letzten Version enthält. Sie können diese
Dateien z.B. mit Hilfe von <tt>zless</tt> lesen, aber es ist nicht wirklich
leicht, nach einem System-Upgrade nach dem changelog jedes aktualisierten
Paketes zu suchen.  
<p>
Es gibt aber eine Möglichkeit, diese Aufgabe zu automatisieren mit
Hilfe eines Werkzeugs mit Namen <prgn>apt-listchanges</prgn>.
Hierfür muß das Paket <package>apt-listchanges</package> erst einmal
installiert werden. Während der Installation übernimmt Debconf die
Installation. Beantworten Sie die Fragen nach Ihren Bedürfnissen.
<p>
Die Option "Soll apt-listchanges nach dem Anzeigen der Changelogs um 
eine Bestätigung bitten?" ist sehr nützlich, da es eine Liste der Änderungen
jedes Paketes, das während eines Upgrades installiert wird, anzeigt und
Ihnen die Möglichkeit bietet, diese vor dem Fortfahren einzusehen.
Wenn Sie hier sagen, daß Sie nicht fortfahren möchten, gibt apt-listchanges
einen Fehlercode zurück und APT bricht die Installation ab.
<p>
Nachdem apt-listchanges installiert wurde, zeigt es die Liste der Änderungen
installierter Pakete an, wenn Pakete aus dem Netz (oder von
einer CD oder gemounteten Partition) heruntergeladen werden, bevor Sie 
installiert werden.
</sect>
</chapt>

<chapt id="sourcehandling">Das Arbeiten mit Quellpaketen
<sect id="source">Herunterladen von Quellpaketen
<p>
In der Welt der freien Software ist es üblich, den Quellcode zu studieren
oder auch Korrekturen an fehlerhaftem Code vorzunehmen. Um dieses zu tun,
muß der Quellcode des Programms heruntergeladen werden. Das APT-System
bietet eine einfache Möglichkeit, den Quellcode der vielen Programme
der Distribution einschließlich aller für das Erstellen eines .deb des 
Programms nötigen Dateien zu beziehen.
<p>
Eine andere übliche Anwendung für Debian-Quellen ist es eine aktuellere
Version eines Programms aus der Distribution "unstable" zum Beispiel 
in "stable" zu benutzen. Das Paket "gegen" "stable" zu kompilieren erzeugt
ein Paket mit Abhängigkeiten, die auf die Pakete aus "stable" ausgerichtet
sind.
<p>
Hierfür sollte der <tt>deb-src</tt>-Eintrag in Ihrer 
<tt>/etc/apt/sources.list</tt> auf "unstable" zeigen. Es sollte außerdem
aktiviert sein, d.h. eventuelle Kommentarzeichen vor der Zeile müssen
entfernt werden (Siehe Abschnitt <ref id="sources.list">).
<p>
Um ein Quellpaket herunterzuladen, benutzen Sie folgendes Kommando:

<p>
<example>
$ apt-get source Paketname
</example>
<p>
Drei Dateien werden daraufhin heruntergeladen: ein <tt>.orig.tar.gz</tt>,
ein <tt>.dsc</tt> und ein <tt>.diff.gz</tt>. Im Falle von Paketen, die
speziell für Debian erzeugt wurden, fällt das letzte weg und das erste
hat kein <tt>"orig"</tt> im Namen.
<p>
Die Datei <tt>.dsc</tt> wird von dpkg-source benutzt, um das Quellpaket
in das Verzeichnis <var>Paketname-Version</var> zu entpacken. In jedem
heruntergeladenen Quellpaket befindet sich ein Verzeichnis <tt>debian/</tt>,
welches die für das Bauen des .deb-Paketes nötigen Dateien enthält.
<p>
Um das Paket beim Herunterladen automatisch zu erzeugen, fügen Sie einfach
<tt>-b</tt> zur Kommandozeile hinzu:

<p>
<example>
$ apt-get -b source Paketname
</example>

<p>
Wenn Sie sich dazu entscheiden, das Paket noch nicht beim Herunterladen
zu erzeugen, können Sie dieses später nachholen mittels

<p>
<example>
$ dpkg-buildpackage -rfakeroot -uc -b
</example>

<p>
in dem Verzeichnis, welches für das Paket nach dem Herunterladen erstellt 
wurde. Um das zuvor erzeugte Paket zu installieren, muß man den
Paketmanager direkt einsetzen:

<p>
<example>
# dpkg -i <var>Datei.deb</var>
</example>

<p>
Es besteht ein Unterschied zwischen der Methode "<prgn>apt-get</prgn>
<tt>source</tt>" und den anderen Methoden von <prgn>apt-get</prgn>.
Die <tt>source</tt>- Methode kann von normalen Benutzern ohne
Root-Rechten benutzt werden. Die Dateien werden in das Verzeichnis
heruntergeladen, aus dem das <tt>apt-get source Paket</tt> aufgerufen
wurde.
</sect>

<sect id="build-dep">Für das Kompilieren eines Quellpaketes nötige Pakete
<p>
Normalerweise müssen sich spezielle Bibliotheken auf dem System befinden,
um ein Quellpaket zu kompilieren. Alle Quellpakete haben ein Feld mit 
Namen "Build-Depends" in ihrer Kontrolldatei, welches die Namen der
zusätzlichen Pakete enthält, die für das Erzeugen des Paketes aus
dem Quellcode nötig sind. 
<p>
APT bietet eine einfache Möglichkeit diese Pakete herunterzuladen.
Führen Sie einfach <tt>apt-get build-dep Paket</tt> aus, wobei 
`Paket' für den Namen des Pakets, welches Sie erzeugen wollen steht.
Beispiel:

<p>
<example>
# apt-get build-dep gmc
Reading Package Lists... Done
Building Dependency Tree... Done
The following NEW packages will be installed:
  comerr-dev e2fslibs-dev gdk-imlib-dev imlib-progs libgnome-dev libgnorba-dev
  libgpmg1-dev 
0 packages upgraded, 7 newly installed, 0 to remove and 1  not upgraded.
Need to get 1069kB of archives. After unpacking 3514kB will be used.
Do you want to continue? [Y/n]
</example>

<p>
Die Pakete, die hier installiert werden, werden gebraucht, um 
<package>gmc</package> korrekt zu erzeugen. Beachten Sie jedoch, daß
dieses Kommando sich nicht um das Quellpaket selbst kümmert, welches
Sie bauen möchten. Sie müssen hierfür zusätzlich <tt>apt-get source</tt>
ausführen.

<p>
Falls Sie nur feststellen möchten, welche Pakete zum Bau eines
bestimmten Paketes benötigt werden, ist eine Variante des Kommandos
<tt>apt-cache show</tt> (Siehe <ref id="search"> hilfreich, die neben
anderer Information die Zeile <tt>Build-Depends</tt> aufführt, die
ihrerseits die erforderlichen Pakete auflistet.

<p>
<example>
# apt-cache showscrc <var>Paket</var>
</example>

</sect>
</chapt>

<chapt id="erros">Der Umgang mit Fehlern
<sect id="erros-comuns">Häufige Fehler
<p>
Fehler wird es immer geben. Viele werden durch unachtsame Benutzer verursacht.
Im folgenden finden Sie eine Liste mit häufig gemeldeten Fehlern und wie
Sie mit ihnen umgehen sollten.
<p>
Wenn Sie eine Nachricht erhalten, die aussieht wie die im unteren Beispiel,
bei dem Versuch <tt>apt-get install Paket</tt> auszuführen ...

<p>
<example>
Reading Package Lists... Done
Building Dependency Tree... Done
W: Couldn't stat source package list 'http://people.debian.org unstable/ Packages' (/var/state/apt/lists/people.debian.org_%7ekov_debian_unstable_Packages) - stat (2 No such file or directory)
W: You may want to run apt-get update to correct these missing files
E: Couldn't find package penguineyes
</example>

<p>
haben Sie vergessen <tt>apt-get update</tt> nach Ihrer letzten Änderung in der
<tt>/etc/apt/sources.list</tt> auszuführen.
<p>
Wenn folgender Fehler auftritt ...

<example>
E: Could not open lock file /var/lib/dpkg/lock - open (13 Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?
</example>

<p>
nach dem Versuch, irgend eine andere <prgn>apt-get</prgn>-Methode auszuführen
als <tt>source</tt>, haben Sie keine Root-Rechte, d.h. Sie haben sie als
normaler Benutzer ausgeführt.
<p>
Der gleiche Fehler wie oben tritt auf, wenn versucht wird, zweimal 
<prgn>apt-get</prgn> gleichzeitig auszuführen oder auch, wenn versucht
wird <prgn>apt-get</prgn> auszuführen während ein <prgn>dpkg</prgn>
Prozeß läuft. Die einzige Methode, die simultan zu anderen ausgeführt
werden darf, ist die <tt>source</tt>-Methode.
<p>
Wenn eine Installation mitten im Prozeß abbricht und Sie merken,
daß es nicht länger möglich ist, Pakete zu installieren oder zu entfernen,
versuchen Sie diese zwei Befehle auszuführen:

<p>
<example>
# apt-get -f install
# dpkg --configure -a
</example>

<p>
Danach versuchen Sie es erneut. Es kann nötig sein, den zweiten der beiden
Befehle mehr als einmal auszuführen. Dies ist eine wichtige Information für 
die Abenteurer, die `unstable' benutzen.

<p>
Tritt "E: Dynamic MMap ran out of room" beim Ausführen von
<tt>apt-get update</tt> auf, sollte die folgende Zeile der 
<file>/etc/apt/apt.conf</file> hinzugefügt werden:

<example>
APT::Cache-Limit 10000000;
</example> 

</sect>

<sect id="help">Wo gibt es Hilfe?
<p>
Wenn Sie sich von Zweifeln geplagt fühlen, ziehen Sie die umfangreiche
Dokumentation des Debian-Paketsystems zu Rate. <tt>--help</tt> und 
Manpages können eine enorme Hilfe sein, genau wie die Dokumentation
in den Verzeichnissen in <tt>/usr/share/doc</tt> ebenso wie in 
<tt>/usr/share/doc/apt</tt>.
<p>
Wenn diese Dokumentation nicht ausreicht, um Ihre Probleme zu beseitigen,
versuchen Sie es auf den Debian-Mailinglisten. Mehr Informationen
über die speziellen Benutzer-Listen gibt es auf der Debian-Webseite:
<url id="http://www.debian.org" name="http://www.debian.org">.
<p>
Natürlich sind diese Listen und Hilfen nur für Debian-Benutzer; Benutzer
anderer Systeme werden von der Gemeinschaft Ihrer Distribution bessere
Hilfe erlangen.
</sect>
</chapt>

<chapt id="distros">Welche Distributionen unterstützen APT?
<p>
Hier finden Sie die Namen einiger Distributionen, die APT unterstützen:
<p>
Debian GNU/Linux (<url id="http://www.debian.org" name="http://www.debian.org">) 
- Für diese Distribution wurde APT entwickelt
<p>
Conectiva (<url id="http://www.conectiva.com.br" name="http://www.conectiva.com.br">) 
- Die erste Distribution, die APT mit RPM benutzt
<p>
Mandrake (<url id="http://www.mandrake.com" name="http://www.mandrake.com">)
<p>
PLD (<url id="http://www.pld.org.pl" name="http://www.pld.org.pl">)
<p>
Vine (<url id="http://www.vinelinux.org" name="http://www.vinelinux.org">)
<p>
APT4RPM (<url id="http://apt4rpm.sf.net" name="http://apt4rpm.sf.net">)
<p>
Alt Linux (<url id="http://www.altlinux.ru/" name="http://www.altlinux.ru/">)
<p>
Red Hat (<url id="http://www.redhat.com/" name="http://www.redhat.com/">)
<p>
Sun Solaris (<url id="http://www.sun.com/" name="http://www.sun.com/">)
<p>
SuSE (<url id="http://www.suse.de/" name="http://www.suse.de/">)
<p>
Yellow Dog Linux (<url id="http://www.yellowdoglinux.com/"
name="http://www.yellowdoglinux.com/">)

</chapt>

<chapt id="agradecimentos">Credits
<p>
Ein großes Dankeschön geht an meine Freunde aus dem Debian-BR-Projekt und
Debian selbst, die eine ständige Hilfe für mich sind und mir immer
die Kraft geben, für das Wohl der Menschheit zu arbeiten genauso wie
Sie mir bei meinem Ziel helfen, die Welt zu retten. :)
<p>
Außerdem möchte ich CIPSGA für die enorme Hilfe danken, die es für
unser Projekt und alle freien Projekte die aus großen Ideen entstehen
bedeutet.
<p>

Und spezieller Dank geht an:
<p>
Yooseong Yang &lt;yooseong@debian.org&gt;
<p>
Michael Bramer &lt;grisu@debian.org&gt;
<p>
Bryan Stillwell &lt;bryan@bokeoa.com&gt;
<p>
Pawel Tecza  &lt;pawel.tecza@poczta.fm&gt;
<p>
Hugo Mora &lt;h.mora@melix.com.mx&gt;
<p>
Luca Monducci &lt;luca.mo@tiscali.it&gt;
<p>
Tomohiro Kubota &lt;kubota@debian.org&gt;
<p>
Pablo Lorenzzoni &lt;spectra@debian.org&gt;
<p>
Steve Langasek &lt;vorlon@netexpress.net&gt;
<p>
Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;
<p>
Erik Rossen &lt;rossen@freesurf.ch&gt;
<p>
Ross Boylan &lt;RossBoylan@stanfordalumni.org&gt;
<p>
Matt Kraai &lt;kraai@debian.org&gt;
<p>
Aaron M. Ucko &lt;ucko@debian.org&gt;
<p>
Jon Åslund &lt;d98-jas@nada.kth.se&gt;
</chapt>

<chapt id="novas">Neue Versionen dieses Dokuments
<p>
Diese Anleitung wurde vom <url id="http://www.debian-br.org/"
name="Debian-BR">-Projekt mit dem Ziel geschrieben, den täglichen
Umgang mit Debian zu erleichtern. 
<p>
Neue Versionen dieses Dokuments werden auf der 
Webseite des Debian-Dokumentationsprojekts zur Verfügung gestellt
werden
<url id="http://www.debian.org/doc/ddp" 
name="http://www.debian.org/doc/ddp">. 
<p>
Kommentare und Kritik können direkt per Mail an mich gesandt werden
unter der Adresse <email>kov@debian.org</email>.
<p>
Kritik zur deutschen Übersetzung geht an
David Spreen <email>netzwurm@debian.org</email>.
</chapt>

</book>

</debiandoc>
