<!--
  english version: 1.5
  russian version: $Id: customizing.ru.sgml,v 1.1 2001-05-04 23:31:37 nidd Exp $
  -->

<chapt id="customizing">Пользовательская настройка установленного &debian;

<sect id="papersize">Как мне удостовериться, что все программы используют
  одинаковый формат бумаги?

<p>Файл <tt>/etc/papersize</tt> содержит общее для всей системы название 
формата бумаги (т.е. letter или A4). Это значение может быть перекрыто
переменной окружения <tt>PAPERSIZE</tt>. Подробности в странице руководства
<tt>papersize(5)</tt>.

<sect id="hardwareaccess">Как обеспечить доступ к файлам устройств без нарушения
  защиты системы?

<p>Многие файлы в каталоге <tt>/dev</tt> принадлежат предопределенным группам.
Например, <tt>/dev/fd0</tt> принадлежит группе <tt>floppy</tt>, а 
<tt>/dev/dsp</tt>  - группе <tt>audio</tt>.

<p>Если вы хотите предоставитьконкретному пользователю доступ к устройству, то
включите пользователя в группу, которой принадлежит устройство, т.е. сделайте:
  <example>adduser user group</example>
Это если вы не хотите делать chmod для файла устройств.

<sect id="consolefont">Как по правилам Debian при запуске системы грузить 
    консольный шрифт?

<p>Для этой задачи существуют пакеты <package/kbd/ и <package/console-tools/.
Отредактируйте файлы <tt>/etc/kbd/config</tt> или 
<tt>/etc/console-tools/config</tt>.

<sect id="appdefaults">Как настроить параметры по умолчанию для приложений X11?

<p>В Debian установка X11 предполагает, что файлы в каталоге
<tt>/usr/X11R6/lib/X11/app-defaults/</tt> остаются неизменными. Если вы хотите
глобально изменить настройки приложения X, то внесите ваши настройки в файл
<tt>/etc/X11/Xresources</tt>. Этот файл считается настроечным, так что его
содержимое не будет утрачиваться при обновлениях системы.

<sect id="booting">Кажется, каждый дистрибутив имеет собственный способ 
  загрузки. Расскажите, как это устроено в Debian.

<p>Как и все юниксы, Debian загружается выполнением программы <tt>init</tt>.
Настроечный файл для <tt>init</tt> (который нзывается <tt>/etc/inittab</tt>)
указывает, что первыми должны выполняться сценарии в каталоге
<tt>/etc/init.d/rcS</tt>. Эти сценарии проверяют и монтируют 
файловые системы, загружают модули, запускают сетевые сервисы, устанавливают
часы, производят прочие инициализации и запускают сценарии (исключая те, что
имеют `.' в имени файла) в каталоге <tt>/etc/rc.boot/</tt>. Использование
сценариев в последнем каталоге зарезервировано для администраторских задач, и
не допускается для пакетов.

<p>По окончаниии процесса загрузки, <tt>init</tt> выполняет все запускающие
сценарии в каталоге, указанном уровнем запуска по умолчанию (этот уровень
запуска задается записью <tt>id</tt> в <tt>/etc/inittab</tt>).
Подобно большинству <!-- all? SGK --> юниксов, совместимых с System V, 
Linux имеет 7 уровней запуска:
<list>
  <item>0 (останов системы),
  <item>1 (однопользовательский режим),
  <item>с 2 по 5 (различные многопользовательские режимы), и
  <item>6 (перезагрузка системы).
</list>
Системы Debian имеют id=2, что означает, что по умолчанию уровень запуска будет
'2' (вход в многопользовательский режим), и будут запущены сценарии в каталоге
<tt>/etc/rc2.d/</tt>.

<p>В действительности, сценарии в любом из этих каталогов, <tt>/etc/rcN.d/</tt>,
- это только символические связи на сценарии в <tt>/etc/init.d/</tt>. Однако,
<em>имена</em> файлов в каждом из каталогов <tt>/etc/rcN.d/</tt> выбраны так,
чтобы задавать <em>метод</em> выполнения сценариев в <tt>/etc/init.d/</tt>.
А именно, перед переходом на уровень запуска, запускаются все сценарии,
начинающиеся с 'K'; эти сценарии останавливают сервисы. Затем начинается
выполнение сценариев с именами, начинающимися с буквы 'S'; эти сценарии 
запускают сервисы. Двузначное число после 'K' или 'S' указывает порядок, в
котором запускается сценарий. Первыми выполняются сценарии с меньшими номерами.

<p>Для поддержки этого метода все сценарии в каталоге <tt>/etc/init.d/</tt>
принимают один из параметров - `start', `stop', `reload', `restart' или `force-reload' -
и затем выполняют задачу, определляемую этим параметром. Эти сценарии можно
использовать даже после окончания процесса загрузки, чтобы управлять различными
процессами.

<p>Например, параметр `reload' в команде
  <example>/etc/init.d/sendmail reload</example>
приведет к отправке демону sendmail сигнала перечитать файл настроек.

<sect id="custombootscripts">Похоже, что Debian не использует для настройки
  процесса загрузки <tt>rc.local</tt>; как поддерживается эта функция?

<p>Допустим, системе нужно выполнять сценарий <tt>foo</tt> при загрузке,
или при переключении в какой-либо уровень запуска (System V). В этом случае
действия системного администратора такие:
<list>
  <item>Поместить сценарий <tt>foo</tt> в каталог <tt>/etc/init.d/</tt>.
  <item>Запустить команду Debian <tt>update-rc.d</tt> с состветствующими
  аргументами, чтобы установить связи между каталогами rc?.d и 
  <tt>/etc/init.d/foo</tt>. Здесь '?' - это число от 0 до 6, соответсвующее
  одному из уровней запуска System V.
  <item>Перегрузить систему.
</list>

<p>Команда <tt>update-rc.d</tt> установит связи между каталогами rc?.d и 
<tt>/etc/init.d</tt>. Имя каждой связи начинается с букв 'S' или 'K', далее 
числа и имени сценария. Сценарии, начинающиеся с 'S' в каталоге
<tt>/etc/rcN.d/</tt>, выполняются при входе в уровень запуска <tt>N</tt>.
Сценарии, начинающиеся с 'K', выполняются при выходе с уровня запуска 
<tt>N</tt>.

<p>Например, можно выполнять сценарий <tt>foo</tt> при загрузке, поместив
его в <tt>/etc/init.d/</tt> и установив необходимые связи командой
<tt>update-rc.d foo defaults 19</tt>.  Аргумент 'defaults' относится к уровням
запуска со 2 по 5. Аргумент '19' позволяет запускать сценарий
<tt>foo</tt> до сценариев с номерами 20 и выше.

<sect id="interconffiles">Как система управления пакетами обрабатывает случаи,
  когда пакеты содержат настроечные файлы для других пакетов?

<p>К примеру, некоторые пользователи хотят создать новый сервер, устанавливая
группу пакетов Debian и собственный пакет, состоящий из настроечных файлов.
Вообще, это не очень хорошо, поскольку <prgn/dpkg/ не будет знать о файлах
настроек, если они находятся в другом пакете, и может затереть эти файлы при
обновлении другого пакета.

<p>Вместо этого создайте собственный пакет, который правит настроечные файлы
"группы" пакетов Debian, как вам необходимо. В последствии <prgn/dpkg/ и 
лругие утилиты системы управления пакетов увидят, что файлы были 
отредактированы местным "сисадмином" и не станут трогать настройки
при обновлении этих пакетов.

<!-- check against dpkg-divert description -->
<sect id="divert">Как мне использовать вместо программы, установленной
  каким-либо пакетом, свою собственную?

<p>Предположим, что системный администратор ил пользователь хотят использовать
 программу "login-local" вместо "login" из пакета Debian <package/login/.

<p><strong/НЕ/ надо:
<list>
  <item>Перезаписывать <tt>/bin/login</tt> программой <tt>login-local</tt>.
</list>
Система управления пакетами не будет знать об этих изменениях и при последующих
обновлениях или инсталляциях просто заменит <tt>/bin/login</tt>.

<!-- XXX dpkg-divert: is this correct ? -->
<p>Значит делается так:
<list>
  <item>Выполните:
    <example>dpkg-divert --divert /bin/login.debian /bin/login</example>
  чтобы заставить Debian при последующих обновлениях пакета <package/login/
  записывать <tt>/bin/login</tt> как <tt>/bin/login.debian</tt>.
  <item>Затем выполните:
    <example>cp login-local /bin/login</example>
  чтобы перенести вашу локальную программу на нужное место.
</list>

<p>Подробности в странице руководства <manref name="dpkg-divert" section="8">.

<sect id="localpackages">Как включить свой пакет в список доступных пакетов,
  о которых знает система управления пакетами?

<p>Выполните команду:

<example>
dpkg-scanpackages BIN_DIR OVERRIDE_FILE [PATHPREFIX] > my_Packages
</example>

<p>где:
  <list>
    <item>BIN-DIR - это каталог, где находятся архивы файлов Debian (которые
    обычно имеют расширения ".deb").
    <item>OVERRIDE_FILE - это файл, который редактируется ведущими дистрибутива
    и обычно хранится в FTP-архиве Debian в
    <tt>indices/override.main.gz</tt> для Debian-пакетов в разделе
    "main" дистрибутива. Вы можете его проигнорировать для локальных пакетов.
    <item>PATHPREFIX - <em>необязательная</em> строка, которая может 
    предшествовать в имени файла <tt>my_Packages</tt>.
  </list>

<p>после построения файла <tt>my_Packages</tt>, сообщите системе управления
пакетами о новых пакетах командой:

<example>
dpkg --merge-avail my_Packages
</example>

<sect id="diverse">Некоторым пользователям нравится mawk, другим - gawk; 
  некоторым - vim, другим - elvis; некоторым - trn, другим - tin; 
  как осуществялется поддержка предпочтений в Debian?

<p>Есть несколько случаев, когда два пакета предоставляют две разных версии
программы, которые обеспечивают в общем одинаковую функцию. Пользователи одной
и той же машины могут предпочитать одну из этих программ другой по своему вкусу.

<p>Debian использует систему "виртуальных" пакетов для того, чтобы системные
администраторы (или их пользователи) могли выбирать между несколькими пакетами
с одинаковой функциональностью более-менее независимо от требований других 
пакетов.

<p>Например, в системе может существовать две различные версии читалок новостей.
Пакет сервера новостей может 'рекомендовать', чтобы в системе была установлена
<em>некая</em> читалка новостей, но выбор, какая именно - <tt>tin</tt>
или <tt>trn</tt>, остается за конкретным пользователем. Решается это созданием
виртуального пакета <package/news-reader/, который предоставляется пакетами
<package/tin/ и <package/trn/. <em>Какая</em> из этих программ является читалкой
новостей можно определить с помощью символической связи
<tt>/etc/alternatives/news-reader</tt> на выбранный файл, т.е., скажем это
<tt>/usr/bin/trn</tt>.

<p>Просто создания символической связи недостаточно для полного решения задачи
использования альтернативной программы; также должны выбираться страницы
руководства, возможные программы поддержки. Сценарий Perl 
<tt>update-alternatives</tt> берет на себя все, что необходимо сделать для
создания необходимых связей между ресурсами системы.

<p>Например, чтобы проверить, какие программы реализуют `x-window-manager',
выполните:
  <example>update-alternatives --display x-window-manager</example>
Если вы хотите что-то изменить:
  <example>update-alternatives --config x-window-manager</example>
И следуйте инструкциям на экране (в основном, приходится выбирать номер
желаемой программы в меню).

<p>Если пакет по каким-либо причинам не зарегистрировал себя как оконный
менеджер (ошибки в файле), или если вы используете менеджер из каталога 
/usr/local, тогда на экране вы не увидите предпочитаемой вами программы.
Вы можете обновить связь командой:
  <example>update-alternatives --install /usr/bin/x-window-manager \
  x-window-manager /usr/local/bin/wmaker-cvs 50</example>

<p>Первый аргумент в опции `--install' - это символическая связь, которая
указывает на /etc/alternatives/ИМЯ, где ИМЯ - это второй аргумент. Третий 
аргумент - это программа, на которую должна указывать /etc/alternatives/ИМЯ,
и четвертый аргумент - приоритет (чем больше это значение, тем выше приоритет).

<p>Чтобы удалить добавленный вами вариант, просто выполните:
  <example>update-alternatives --remove x-window-manager /usr/local/bin/wmaker-cvs</example>
