<!-- CVS revision of original english document "1.21" -->
<chapt id="pkg_basics">Основи системи управління пакунками Debian

<sect id="package">Що таке пакунок Debian?

<p>Пакунок зазвичай містить всі файли, що потрібні для реалізації 
певних команд чи можливостей. Є два типи пакунків Debian:
<list>
  <item><em>Двійкові пакунки</em>, що містять виконувані і конфігураційні файли, 
  сторінки довідки info/man, інформацію про авторські права та іншу документацію. 
  Ці пакунки поширюються у специфічному для Debian архівному форматі 
  (див. <ref id="deb-format">); як правило вони вирізняються закінченням „.deb“. 
  Двійкові пакунки можуть бути розпаковані за допомогою спеціального інструменту&nbsp;—
  <tt>dpkg</tt>; деталі описано в його довідці. 
  
  <item><em>Джерельні пакунки</em>, що містять файл <tt>.dsc</tt>, котрий описує 
  пакунок (включаючи назви наступних файлів), файл <tt>.orig.tar.gz</tt>, що містить 
  оригінальний, незмінений джерельний код у форматі tar, стиснутому gzip'ом, 
  та зазвичай <tt>.diff.gz</tt> файл, що містить специфічні для Debian зміни 
  джерельного коду. Утиліта <tt>dpkg-source</tt> запаковує та розпаковує джерельні 
  архіви Debian; деталі описано в її довідці. 
</list>

<p>Встановлення програмного забезпечення за допомогою системи керування 
пакунками використовує „залежності“, які старанно формуються супроводжуючими пакунків. 
Ці залежності описані у файлі <tt>control</tt>, що знаходиться в кожному пакунку. 
Наприклад, пакунок, що містить компілятор GCU C (<package/gcc/) „залежить“ від 
пакунка <package/binutils/, котрий містить зв'язувач (linker) та асемблер. 
Якщо користувач спробує встановити <package/gcc/ не маючи при цьому встановленого 
<package/binutils/, система керування пакунками (dpkg) надрукує повідомлення про 
помилку та перерве встановлення <package/gcc/ (однак, наполегливий користувач може 
скорегувати таку поведінку; див. <manref name="dpkg" section="8">). Щоб дізнатись
більше, перегляньте <ref id="depends"> нижче. 

<p>Пакувальні інструменти Debian можуть вживатись для: 
<list>
  <item>маніпуляцій та керування пакунками чи частинами пакунків,
  <item>допомоги користувачу у разі необхідності розділення пакунків, наприклад 
    для копіювання на дискети,
  <item>допомоги розробникам у формуванні архівів пакунків, та 
  <item>допомоги користувачам у встановленні пакунків, що розташовані на віддаленому ftp-сайті.
</list>

<sect id="deb-format">Який формат двійкових пакунків Debian?

<p>Пакунок, або ж архівний файл Debian містить виконувані файли, бібліотеки 
та документацію, що відносяться до певного набору відповідних програм. 
Зазвичай назва такого файлу закінчується на <tt>.deb</tt>.

<p>Нутрощі формату двійкових пакунків Debian описані у сторінці довідки 
<manref name="deb" section="5">. Внутрішній формат є предметом змін 
(між основними версіями &debian;), тому, будь ласка, завжди використовуйте 
<manref name="dpkg-deb" section="1"> для маніпуляцій з <tt>.deb</tt>-файлами. 

<sect id="pkgname">Чому назви пакунків Debian такі довгі?

<p>Назва двійкового Debian-пакунку формується за наступною домовленістю:
&lt;Дещо&gt;_&lt;НомерВерсії&gt;-&lt;НомерРедакціїВDebian&gt;.deb

<p>Мається на увазі, що <tt>дещо</tt> насправді є назвою пакунка. Для перевірки 
ви можете дізнатись назву пакунка, що пов'язаний файлом архіву Debian одним 
з двох шляхів:
<list>
  <item>перевірити файл Packages в теці, в котрій він розміщувався на ftp-сайті Debian. 
  Цей файл містить опис кожного пакунку; в тому числі й формальна назва пакунка. 
  <item>за допомогою команди <tt>dpkg --info foo_VVV-RRR.deb</tt> (де VVV та RRR&nbsp;— версія 
  та редакція пакунка відповідно). Вона відображає, поміж інших речей, ще й відповідну 
  назву пакунка для даного архіву.
</list>

<p>Компонента <tt>VVV</tt>&nbsp;— це номер версії, що визначається основним розробником. 
Він не підкоряється жодним стандартам і може мати різні формати, 
як „19990513“ так і „1.3.8pre1“. 

<p>Компонента <tt>RRR</tt>&nbsp;— це номер редакції пакунка в Debian, він визначається розробником 
(чи окремим користувачем, якщо він захоче сформувати пакунок самостійно). Цей номер вказує 
на кількість редагувань пакунка; таким чином новий рівень редакції як правило означає зміни 
у Makefile (<tt>debian/rules</tt>), контролюючому файлі (<tt>debian/control)</tt>, 
встановлювальному чи видаляючому сценаріях(<tt>debian/p*</tt>), або ж у конфігураційних 
файлах, що використовується пакунком. 

<!--
<p>The <tt>Arch</tt> component identifies the processor for which
the package was built.  This is commonly <tt>i386</tt>, which refers to
chips compatible to Intel's 386 or later versions.  For other
possibilities see <ref id="dirtree" name="Debian's FTP directory structure">.
-->

<sect id="controlfile">Що то за файл control?

<p>Детальний опис вмісту файлу control можна знайти в 5-му розділі Підручника політики Debian,
див. <ref id="debiandocs">.

<p>Тут ми коротко розглянемо приклад файлу control пакунка hello: 

<example>
Package: hello
Priority: optional
Section: devel
Installed-Size: 45
Maintainer: Adam Heath &lt;doogie@debian.org&gt;
Architecture: i386
Version: 1.3-16
Depends: libc6 (>= 2.1)
Description: The classic greeting, and a good example
 The GNU hello program produces a familiar, friendly greeting.  It
<!-- XXX below 'non-programmers' were better, but this is a verbatim copy -->
 allows nonprogrammers to use a classic computer science tool which
 would otherwise be unavailable to them.
 .
 Seriously, though: this is an example of how to do a Debian package.
 It is the Debian version of the GNU Project's 'hello world' program
 (which is itself an example for the GNU Project).
</example>

<p>У полі Package вказується назва пакунка. Саме за ним пакунком можна 
маніпулювати за допомогою спеціальних інструментів, і вона як правило 
(але не обов'язково) є такою ж, як і перша частина назви архівного 
файлу Debian. 

<p>У полі Version вказується як версія виробника програми, так і рівень 
редакції пакунка Debian, як це описано в <ref id="pkgname">. <!-- XXX missing name -->

<p>Поле Architecture вказує, для якої системи скомпільований двійковий файл.

<p>В полі Depends перелічуються пакунки, котрі повинні бути встановлені для 
успішного встановлення даного пакунку. 

<p>Поле Installed-Size вказує, скільки дискового простору займе встановлений пакунок. 
Передбачається, що його будуть використовувати інші програми для того, щоб визначити,
чи достатньо на розділі місця для встановлення пакунка.

<p>Рядок Section вказує на розділ, в котрому міститься пакунок на ftp-сайтах Debian. 
Це&nbsp;— назва підтеки (в одній з основних тек&nbsp;— див. <ref id="dirtree">), 
де розташовано пакунок.

<p>Priority вказує на те, наскільки даний пакунок важливий при встановленні, 
то ж напівінтелектуальні програми на кшталт dselect чи console-apt можуть
поділити пакунки на категорії, наприклад за ступенем необхідності їх встановлення.
Див. <ref id="priority">.

<p>В полі Maintainer можна знайти електронну адресу людини, котра що на даний момент 
відповідає за супровід пакунка.

<p>В полі Description знаходиться короткий перелік основних можливостей пакунка.

<p>За додатковою інформацією про всі можливі поля, що може мати пакунок, зверніться 
до розділу&nbsp;5 Підручника політики Debian, „Контрольні файли та їх поля“.

<sect id="conffile">Для чого призначені conffile?

<p>У цьому файлі перелічуються конфігураційніфайли (розміщених, як правило, 
в теці <tt>/etc</tt>), котрі система керування пакунками не буде перезаписувати 
при оновленні пакунка. Таким чином досягається захист вмісту конфігураційних файлів, 
що є критичним на працюючій системі. 

<p>Щоб дізнатись точно, які саме файли не будуть затерті при оновленні пакунка, запустіть
  <example>dpkg --status package</example> та перегляньте поле Conffiles.

<sect id="maintscripts">Що роблять сценарії preinst, postinst, prerm, та postrm?

<p>Ці файли&nbsp;— це виконувані сценарії, що автоматично запускаються перед чи після 
встановлення пакунку. Разом з файлом <tt>control</tt> всі ці файли є частиною
„контролюючої“ секції файлу архіву Debian. 

<p>Кожен окремо вони роблять наступне:
<taglist>
<tag/preinst/
  <item>Цей сценарій запускається перед розпаковуванням пакунку з його Debian-архіву 
  („.deb“-файлу). Багато preinst-сценаріїв зупиняють служби для пакунків, що оновлюються, 
  аж доки їх встановлення чи оновлення не завершаться (з наступним успішним виконанням 
  сценарію postinst).

<tag/postinst/
  <item>Цей сценарій, як правило, завершує необхідні конфігурації пакунка <tt>foo</tt> коли 
  його вже було розпаковано з архівного „.deb“-файлу. Часто postinst просить ввести 
  користувача якусь інформацію та/або попереджає його у випадку використання стандартних 
  значень, щоб він не забув повернутись та переконфігурувати пакунок у разі необхідності. 
  Потім багато сценаріїв виконують команди, необхідні для запуску чи перезапуску 
  різноманітних служб, оскільки новий пакунок вже встановлено чи оновлено. 

<tag/prerm/
  <item>Цей сценарій як правило зупиняє всі демони, що мають певне відношення до пакунку. 
  Він виконується перед видаленням файлів, пов'язаних з пакунком.

<tag/postrm/
  <item>Цей сценарій зазвичай змінює відсилачі та інші файли, пов'язані з <tt>foo</tt> 
  та/або видаляє файли, створені пакунком (див. також <ref id="virtual">).
</taglist>

<p>На даний момент всі керуючі файли можна знайти в теці
<tt>/var/lib/dpkg/info</tt>. Файли, що відносяться до пакунка <tt>foo</tt>
починаються з foo і мають розширення відповідно preinst, postinst і т.д.
Файл <tt>foo.list</tt> з вищевказаної теки&nbsp;— це список 
всіх файлів, встановлених з пакунка <tt>foo</tt>.
(Зауважте, що місцезнаходження цих файлів визначається внутрішніми налаштуваннями
dpkg; ви не повинні орієнтуватись саме на цей шлях.)

<sect id="priority">Що це за пакунки&nbsp;— <em/Essential/, <em/Required/, 
<em/Important/, <em/Standard/, <em/Optional/ та <em/Extra/ 
(Невіддільний, Необхідний, Важливий, Типовий, Необов'язковий та Додатковий)?

<p>Кожному пакункові Debian супроводжуючими збірки присвоюється <em>пріоритет</em>, 
щоб допомогти системі керування пакунками. Пріоритети бувають:

<list>
  <item><strong>Required</strong> (Необхідний): пакунки, що необхідні для правильного 
    функціонування системи.
    <p>Сюди входять всі інструменти, необхідні для усунення дефектів системи. 
    Ви не повинні видаляти ці пакунки, інакше ваша система буде повністю виведена 
    з ладу і швидше за все ви навіть не зможете використати dpkg щоб встановити їх назад.
    В системах з набором лише необхідних пакунків, швидше за все, не можна працювати, 
    але вони надають системному адміністратору достатньо функціональності, щоб завантажити 
    систему та встановити додаткове програмне забезпечення. 
  <item><strong>Important</strong> (Важливі) пакунки повинні бути встановлені 
    на будь-якій Unix-системі
    <p>До таких відносяться всі інші пакунки, без яких використання системи буде незручним 
    або маломожливим. Сюди <em>НЕ</em> входять Emacs, X11, TeX чи інші великі додатки; 
    ці пакунки лише формують кістяк. 
<!-- JFS: Review for etch, since some development packages might be removed
     in the near future #301138 -->
  <item><strong>Standard</strong> (Типові) пакунки є стандартом для будь-якої 
    Linux-системи, включаючи але не обмежуючись текстовими системами.
    <p>Сюди входить все те, що встановлюється по замовчуванню, якщо користувачі 
    не вибрали що-небудь ще. Це не стосується багатьох великих додатків, але все ж 
    до таких пакунків відносяться деякі програми для розробників на кшталт 
    компіляторів GNU C та С++ (<tt>gcc</tt>, <tt>g++</tt>), GNU make, а також 
    інтерпретатор мови Python, деяке серверне програмне забезпечення типу OpenSSH, 
    демон друку BSD (<tt>lpr</tt>) і дзеркало портів (portmapper) RPC (<tt>portmap</tt>).
  <item><strong>Optional</strong> (Необов'язкові) пакунки включають в себе все те, 
    що вам є сенс встановити, якщо ви не знаєте, що воно таке, або ж не маєте 
    якихось особливих забаганок. 
    <p>Сюди входять Х11, повна збірка ТеХ та багато інших програм.
  <item><strong>Extra</strong> (Додаткові): пакунки, котрі або конфліктують з іншими, 
    з вищим пріоритетом, або мають сенс до використання, лише якщо ви точно знаєте, 
    що воно таке, або ж мають якісь спеціалізовані вимоги, що не дозволили включити 
    їх до Optional. 
</list>

<p>Якщо ви встановлюєте стандартний Debian, всі пакунки з пріоритетом <strong>Standard</strong> 
та вищим буде встановлено до вашої системи. Якщо ви оберете перед-визначення задач встановлення 
ви отримаєте доступ і до пакунків з нижчим пріоритетом також. 

<p>На додаток, деякі пакунки позначено як <strong>Essential</strong> (Невіддільні), 
оскільки вони абсолютно необхідні для успішного функціонування системи. 
Інструменти системи керування пакунками не зможуть їх видалити. 

<sect id="virtual">Що таке віртуальний пакунок?

<p>Віртуальний пакунок&nbsp;— це загальна назва, що дається пакункові чи групі 
пакунків, кожен з яких пропонує схожу базову функціональність. Наприклад, 
обидві програми <tt>tin</tt> та <tt>trn</tt> призначені для читання новин, 
а отже повинні задовольнити залежність іншої програми, що потребує встановленої 
програми для читання новин у системі. Тому обидві вони забезпечують 
„віртуальний пакунок“, що називається <tt>news-reader</tt>.

<p>Аналогічно, програми <tt>smail</tt> та <tt>sendmail</tt> забезпечують 
функціональність транспортного агента електронної пошти. Тому кажуть, 
що вони обидві забезпечують віртуальний пакунок „mail transport agent“. 
Якщо хоча б одна з них встановлена, будь-яка інша програма, що залежить 
від <tt>mail-transport-agent</tt>, буде задоволена наявністю віртуального
пакунка. 

<p>Debian забезпечує цей механізм таким чином, що якщо в системі встановлено 
більш ніж один пакунок з однаковою базовою функціональністю, то системний 
адміністратор може зробити один із них привілейованим. Для ознайомленням з 
описом можливостей відповідної команди, <tt>update-alternatives</tt>, перегляньте
<ref id="diverse">.

<sect id="depends">Що мається на увазі, коли кажуть, що пакунок залежить, 
рекомендує, пропонує, конфліктує, замінює або забезпечує (<em/Depends/, 
<em/Recommends/, <em/Suggests/, <em/Conflicts/, <em/Replaces/ або <em/Provides/) 
інший пакунок?

<p>Система керуваннями пакунків Debian оперує шкалою залежностей, 
щоб вказати, в який спосіб програма А може реагувати на наявність 
в системі програми В:

<list>
  <item>Пакунок A залежить (<em>depends</em>) від пакунку B, якщо B 
    безумовно повинен бути встановленим у системі щоб запустити програму A. 
    В деяких випадках A залежить не просто від B, але від певної версії B. 
    В такому випадку залежність як правило має нижню межу, в цьому випадку A 
    залежить від будь-якої версії B, що новіша за деяку визначену версію. 
  <item>Пакунок A рекомендує (<em>recommends</em>) пакунок B, якщо супроводжуючий 
    пакунку A вважає, що переважній більшості користувачів не потрібен пакунок A 
    без функціональності, що її забезпечує пакунок B. 
  <item>Пакунок A пропонує (<em>suggests</em>) пакунок B, якщо B містить файли, 
    пов'язані з функціональністю A (та, зазвичай, покращують її).
  <item>Пакунок A конфліктує (<em>conflicts</em>) з пакунком B, 
    якщо A не зможе функціонувати при встановленому у системі B. Значно рідше 
    конфлікт виникає через те, що A містить файли, відмінні від аналогічних 
    у пакунку B. Часто conflicts поєднується з replaces.
  <item>Пакунок A замінює (<em>replaces</em>) пакунок B, коли файли, 
    встановлені B видаляються та (в деяких випадках) перезаписуються файлами з A. 
  <item>Пакунок A забезпечує (<em>provides</em>) пакунок B, коли всі файли та 
    функціональність B включені в A. Цей механізм дає можливість користувачам 
    з обмеженим дисковим простором встановити лише ту частину пакунку A, 
    котра їм справді необхідна.
</list>

<p>Детальніша інформація по кожному з цих термінів знаходиться у підручнику Політики Debian. 

<sect id="pre-depends">Що означає „попередня залежність“?

<p>„Попередня залежність“&nbsp;— це особлива залежність. Для більшості пакунків 
<tt>dpkg</tt> розпакує архівний (<tt>.deb</tt>) файл незалежно від того, 
чи є в системі файли, від котрих він залежить. Це означає, що <tt>dpkg</tt> 
добуде їх з архіву та помістить туди, де вони повинні знаходитись. Якщо ці пакунки 
<em>залежать</em> від наявності інших пакунків у системі, <tt>dpkg</tt> відмовиться 
завершити встановлення (виконуючи дію „configure“), поки інші пакунки не будуть встановлені. 

<p>Проте для деяких пакунків <tt>dpkg</tt> відмовиться проводити розпакування, 
поки всі залежності не будуть задоволені. Цей механізм називається попередньою 
залежністю від присутності у системі інших пакунків. Проект Debian пропонує цей 
механізм для безпечного оновлення системи від формату <tt>a.out</tt> до <tt>ELF</tt>, 
де <em>порядок</em>, у якому розпаковуються пакунки, є критичним. Є й інші випадки 
значних оновлень, у яких цей механізм є доволі зручним, наприклад пакунки з пріоритетом 
„необхідний“ та їхня залежність від LibC.

<p>Як завжди, більш детальну інформацію про це можна знайти в Підручнику політики Debian.

<sect id="pkgstatus">Що мається на увазі, кажучи невідомий, встановлений, видалений, 
очищений чи зафіксований (<em/unknown/, <em/install/, <em/remove/, <em/purge/ та <em/hold/) 
про стан пакунку.

<p>Ці прапорці вказують, що користувач хоче зробити з пакунком 
(як вказано або діями користувача в секції Select програми <tt>dselect</tt>, 
або ж прямими викликами <tt>dpkg</tt>). 

<p>Вони означають наступне: 
<list>
  <item>unknown (невідомий)&nbsp;— користувач ніколи не цікавився цим пакунком.
  <item>install (встановлений)&nbsp;— користувач бажає встановити чи оновити пакунок.
  <item>remove  (видалений)&nbsp;— користувач хоче видалити пакунок, але не хотів 
      видаляти існуючі файли конфігурації.
  <item>purge   (очищений)&nbsp;— користувач хотів би видалити пакунок разом 
      з усіма конфігураційними файлами.
  <item>hold    (зафіксований)&nbsp;— користувач не бажає обробляти цей пакунок, 
      тобто він хоче зберегти його поточну версію з поточним статусом.
</list>

<sect id="puttingonhold">Як мені зафіксувати пакунок?

<p>Є три способи зафіксувати пакунок&nbsp;— за допомогою dpkg, aptitude, або ж dselect.

<p>Для dpkg вам потрібно експортувати список станів пакунків за допомогою команди 
  <example>dpkg --get-selections \* > selections.txt</example>
Далі відредагуйте отриманий файл <file/selections.txt/, змінивши рядки, що містять 
назви пакунків, які ви хочете зафіксувати, як наприклад <package/libc6/ з ось таких
  <example>libc6                                           install</example>
на такі:
  <example>libc6                                           hold</example>
Збережіть файл та завантажте його назад в базу даних dpkg таким чином:
  <example>dpkg --set-selections < selections.txt</example>

<p>У випадку aptitude ви можете зафіксувати пакунок такою командою: 
  <example>aptitude hold назва_пакунка</example>
    та зняти фіксацію командою 
  <example>aptitude unhold назва_пакунка</example>

<p>Для dselect вам потрібно лише перейти до екрану [S]elect, знайти пакунок, 
котрий ви хочете зафіксувати, та натиснути клавішу '=' або 'Н'. Зміни збережуться, 
як тільки ви покинете екран [S]elect. 

<sect id="sourcepkgs">Як мені встановити джерельний пакунок?

<p>Джерельні пакунки Debian насправді не можуть бути встановлені, вони лише 
розпаковуються в ту теку, де ви хочете зібрати двійкові пакунки, котрі вони створюють.

<p>Джерельні пакунки розповсюджуються на більшості тих дзеркал, котрі пропонують 
двійкові пакунки. Якщо ви налаштуєте <manref name="sources.list" section="5"> 
вашого APT таким чином, щоб він включав необхідні рядки „deb-src“, ви зможете 
легко встановлювати будь-які джерельні пакунки командою 

  <example>apt-get source назва_пакунка</example>

<p>Щоб дійсно допомогти вам компонувати джерельні пакунки, Debian пропонує 
так званий механізм компонування залежностей. Мається на увазі, що супроводжуючий 
джерельного пакунку веде список інших пакунків, що потрібні для компонування даного. 
Щоб побачити, як це зручно, запустіть 

  <example>apt-get build-dep назва_пакунка</example>

перед збиранням джерельних кодів.

<sect id="sourcebuild">Як мені скомпонувати двійковий пакунок з джерельного?

<p>Вам потрібні всі файли foo_*.dsc, foo_*.tar.gz та foo_*.diff.gz щоб скомпілювати 
джерельні коди (зауважте, що для деяких пакунків, що є рідними для Debian, немає файлів.diff.gz). 

<p>Після того як ви їх отримали (див. <ref id="sourcepkgs">), якщо у вас встановлено 
пакунок <package/dpkg-dev/, команда 
  <example>dpkg-source -x foo_version-revision.dsc</example>
видобуде пакунок в теку під назвою <tt>foo-version</tt>.

<p>Якщо ви хочете лише скомпілювати пакунок, ви можете перейти 
в цю теку та запустити команду 
  <example>dpkg-buildpackage -rfakeroot -b</example>
щоб скомпонувати пакунок (зауважте, що при цьому у вас повинен бути 
встановлений пакунок <package/fakeroot/), а потім 
  <example>dpkg -i ../foo_version-revision_arch.deb</example>
щоб встановити новозбудований пакунок.

<sect id="creatingdebs">А як мені створити власний пакунок Debian?

<p>Для детального опису прочитайте Довідник нового супроводжуючого,
доступний у пакунку <package/maint-guide/, або за адресою 
<url id="http://www.debian.org/doc/devel-manuals#maint-guide">.
