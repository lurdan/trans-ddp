<!doctype debiandoc system>

<debiandoc>

 <book>

  <titlepag>

   <title>Debian メンテナ入門</title>

   <author>Josip Rodin <email/jrodin@jagor.srce.hr/
   </author>

   <author> 翻訳: 八田真行 <email/mhatta@debian.or.jp/
   </author>

   <version>version 1.0.2, 10 June 2001.</version>

   <copyright>
   <copyrightsummary>Copyright &copy; 1998-2001 Josip Rodin.</copyrightsummary>

   <p>この文書は GNU 一般公有使用許諾書、バージョン 2 かそれ以降が
   規定する条件の下で利用できます。
   
   <p>この文書は以下の二つの文書を参考として書かれました。

   <p>Debian パッケージの作り方(Debmake マニュアル)、
   Copyright &copy; 1997 Jaldhar Vyas <email/jaldhar@debian.org/

   <p>新米メンテナのための Debian パッケージング Howto、
   Copyright &copy; 1997 Will Lowe <email/lowe@debian.org/
  </copyright>

  </titlepag>

  <toc sect>

  <chapt id="start">まずは始めよう

  <p>この文書では、Debian GNU/Linux 用パッケージを作るには
  どうしたらよいか、一般的な Debian ユーザ(と開発者予備軍)を対象に
  解説しようと思います。
  小難しい専門用語はできるだけ避けて、実用的な例を多く用いて説明していく
  つもりです。ことわざにもあるように、<em>百聞は一見にしかず</em>
  ですからね!

  <p>Debian が Linux ディストリビューションの最高峰と呼ばれる
  までになった理由のひとつがそのパッケージ管理システムです。
  すでに膨大な数のソフトウェアが Debian 形式になっていますが、
  まだパッケージ化されていないソフトウェアをインストールしなければ
  ならないこともあるでしょう。
  あるいは、どうやったら自分でパッケージが作れるんだろう、とか
  それはとても難しいことなんじゃないか、などと考えたことがあるかも
  しれません。まあ、もしあなたが本当に駆け出しの Linux ユーザならば
  困難な仕事でしょうが、でもそうだったら今ごろこんな文書
  読んでませんて :-)

  パッケージ作成には、 Unix のプログラミングについて多少の知識が
  必要です。がしかし、神様みたいに精通している必要は全くありません。

  <p>この文書の最新版は常に以下の場所からネットワーク経由で入手できます。
  <url name="http://www.debian.org/doc/maint-guide/" id="http://www.debian.org/doc/maint-guide/">
  また、 「maint-guide」パッケージにも含まれています。

  <sect id="needprogs">開発に必要なプログラム

  <p>何かを始める前に、開発作業に必要となる以下に挙げるような
  パッケージがきちんとインストールされていることを
  まず確かめておかなければいけません。
  以下のリストには「essential」または「required」なパッケージが
  含まれていないことに注意してください。
    - これらのパッケージは既にインストールされていることを前提に
  しています。

  <p>この文書は 2.1 「slink」ディストリビューションが Debian の
  公式安定版リリースで、2.2 「potato」が開発中だった期間に書かれました。
  そのため、ここで名を挙げたパッケージはほとんどが
  「potato」に収録されているものとなっています。

  <p>以下のパッケージは普通に Debian 2.1 をインストールしたならば
  すでに(それらが依存する他のパッケージといっしょに)システムに
  入っているはずです。
  しかし、念のために「dpkg -s &lt;パッケージ名&gt;」で確認して
  おきましょう。

  <list>
  <item><em>binutils</em> - これらのプログラムは、プログラムの
  「素」となるオブジェクトファイルをアセンブル、あるいは
  リンクするために使われます。
  (「info binutils」とすればマニュアルが読めます)

  <item><em>cpp</em> - C プリプロセッサ
  (詳しくは<manref name="cpp" section="1">を参照)

  <item><em>cpio</em> - これは tar や zip と同じアーカイバと呼ばれる種の
  プログラムです(詳しくは <manref name="cpio" section="1">を参照)。

  <item><em>dpkg-dev</em> - このパッケージには Debian ソースパッケージ
  を展開、構築、アップロードするのに必要なツール群が含まれています。
  (詳しくは <manref name="dpkg-source" section="1">を参照)。

  <item><em>file</em> - この便利なプログラムを使うとそのファイルがどういう形式
  のものか判定することができます(詳しくは<manref name="file" section="1">を
  参照)。

  <item><em>gcc</em> - GNU C コンパイラ。ほとんどの Linux プログラムは
  C 言語で書かれていますが、もしあなたのプログラムがその他の
  プログラミング言語、例えば C++、Fortran、Pascal などで書かれて
  いるならば、それぞれ g++、g77、gpc などをインストールしましょう
  (詳しくは <manref name="gcc" section="1">、
  <manref name="g++" section="1">、<manref name="g77" section="1">、
  <manref name="gpc" section="1">)を参照)。

  <item><em>libc6-dev</em> - gcc が、オブジェクトファイルを生成してリンク
  するのに必要な C ライブラリとヘッダファイルはこのパッケージに
  入っています。未だに libc5 の使用を推奨、あるいは現に使っている
  プログラムもありますが、ぜひ新バージョンの libc6 を
  使うようにしてください。(「info libc」でマニュアルが読めます)

  <item><em>make</em> - ふつう、プログラムはいくつかの手順を踏んで
  生成されます。同じコマンドを何度も何度も繰り返し入力する代わりに、
  make プログラムを使えば「Makefile」を書くことで手続きを自動化
  することができます。
  また、ある種のプログラムは imake や xmkmf といった Makefile を
  一揃いのマクロ関数から生成するプログラムを使いますし、より新しい
  プログラムの多くは autoconf や automake といったプログラムを利用して
  configure スクリプトと Makefile をプログラムの生成に使っています
  ので、これらも必要になるかもしれません(詳しくは「info make」、
  <manref name="imake" section="1">、
  <manref name="xmkmf" section="1">、
  <manref name="autoconf" section="1">、
  <manref name="automake" section="1">を参照)。

  <item><em>patch</em> - このとても有用なユーティリティは
  オリジナルとの差異が列挙されたファイル(diff プログラムによって生成)を
  読み込んでオリジナルのファイルに適用し、パッチ済バージョンを作成します。
  (詳しくは <manref name="patch" section="1"> を参照)。

  <item><em>perl5</em> - Perl は今日の Un*x システムにおいてもっとも
  使われているインタープリタ型スクリプト言語のひとつで、その強力さは
  しばしば「Unix のスイス軍用チェーンソー」と形容されるほどです
  (詳しくは <manref name="perl" section="1">を参照)。
  </list>

  <p>以下はおそらくディストリビューションの「devel」セクションから
  自分でインストールする必要のあるものです。

  <list>
  <item><em>dh-make</em> と <em>debhelper</em> - dh-make はあとで説明する
  パッケージのひな型を用意するのに必要となります。dh_make は 
  ひな型を作る過程で debhelper ツールのいくつかを使います。これらを
  使わなくてもパッケージ作成は可能ですが、
  初めてパッケージを作る方には利用を<em>強く</em>お勧めします。
  パッケージを作るのも、以後パッケージを管理するのもずっと簡単になるからです。
  (詳しくは <manref name="dh_make" section="1">、
  <manref name="debhelper" section="1">、/usr/share/doc/debhelper/README を参照)

  <item><em>devscripts</em> - このパッケージは
  メンテナにとって便利であると思われるいくつかの有用で優れたスクリプト
  を含んでいますが、これらもまたパッケージ作成に当たって必要というわけでは
  ありません(詳しくは /usr/share/doc/devscripts/README.gz 参照)。

  <item><em>fakeroot</em> - このユーティリティを使うと、
  パッケージ作成の諸段階のいくつかにおいて必要となる root 権限を
  エミュレートすることができます(詳しくは <manref name="fakeroot" section="1">
  を参照)。

  <item><em>lintian</em> - これは Debian パッケージチェッカで、
  あなたが構築したパッケージを調べて、その中にありがちなミスが
  見つかったらそれを指摘し、その問題について説明してくれます
  (詳しくは <manref name="lintian" section="1">、
  /usr/share/doc/lintian/lintian.html/index.html を参照)。
  </list>

  <p>さて、以下の<em>とても重要</em>なパッケージは
  ディストリビューションの「doc」セクションに収録されています。

  <list>
  <item><em>debian-policy</em> - Debian ポリシーマニュアル。
  アーカイブの構造と内容、OS の設計に関する
  いくつかの問題、あるいは「ファイルシステム体系基準」
  (Filesystem Hierarchy Standard)についてなどいろいろ載っていますが、
  さしあたって重要になってくるのはディストリビューションに含まれるために
  それぞれのパッケージが満たすべき必要条件の説明です
  (詳しくは /usr/share/doc/debian-policy/policy.html/index.html を参照)。

  <item><em>developers-reference</em> - 開発者リファレンス。
  例えばアーカイブの構造、パッケージ名の変更方法、
  パッケージの選び方、メンテナを降りるにはどうしたらよいか、
  どうやって NMU をするか、バグとのつき合い方、
  いつどこにアップロードすればよいかなどなど、特に技術的な事柄以外の
  パッケージ化についてのありとあらゆる情報がここにあります。
  (詳しくは /usr/share/doc/developers-reference/developers-reference.html/index.html を参照)
  </list>

  <p>これらに加え、あなたのパッケージに電子的に<em>署名</em>するために
  暗号化ソフトウェア PGP (pgp-* パッケージ群)または
  GPG (gnupg パッケージ)が必要です。
  これは、もしあなたがご自分のパッケージを他の人に配布したい場合
  (あなたのパッケージを Debian ディストリビューションに含める
  ということは、つまりそういうことなのですが)特に重要になってきます。
  しかし、アメリカ合衆国のへんちくりんな輸出規制法のせいで、単にこれを
  近くの Debian FTP サイトからダウンロードするというわけにはいきません。
  このため、 Debian はこれらのパッケージを物理的にアメリカ合衆国内に
  ないサイトである non-US.debian.org(ftp://non-us.debian.org/debian-non-US/)
  を通して提供しています。あなたの FTP サイトには README.non-us という
  ファイルがあるはずで、それを見ればどうすればサイトのより近いミラーを
  探せるかが分かります。

  <p>上記の簡単な説明は、それぞれのパッケージが何をするのか紹介
  するだけのものです。先に進む前にどうかそれぞれのプログラムに
  付属の文書を徹底的に熟読し、標準的な使い方だけでも理解しておいて
  ください。きついと思われるかも知れませんが、あとになればきっと
  <em>読んでてよかったなあ</em>と思うことでしょう。

  注意: <em>debmake</em>は dh-make と似た働きをするいくつかの
  プログラムを含むパッケージですが、それ特有の使い方は
  この文書の<strong>範囲外</strong>です。詳しくは<url name="Debmake マニュアル"
  id="http://www.debian.org/~jaldhar/">を参照してください。

  <sect id="otherinfo">その他知っておくべきこと

  <p>これから作ろうとするのは 2 種類のパッケージで、それぞれ
  ソースパッケージ、バイナリパッケージと呼ばれています。
  ソースパッケージはコンパイルしてプログラムになるソースコードが
  含まれます。バイナリパッケージにはでき上がったプログラムそのものです。
  紛らわしい言葉ですが、「プログラムのソース」と
  「プログラムのソースパッケージ」を混同しないようにしましょう!
  もし用語についてもっと知りたければ他のマニュアル類を参照してください。
  
  <p>Debian では、「メンテナ(maintainer)」と言う用語はパッケージを
  作る人を示し、「上流作者(upstream author)」とはプログラムそれ自身を
  作った人を指します。そして「上流メンテナ(upstream maintainer)」
  というのは Debian の外部で現在プログラムそのものを管理している人の
  ことです。
  たいていの場合、作者と上流メンテナは同一人物ですが、メンテナすらも
  同じという場合もあり得ます。
  もしあなたが何かのプログラムを書いて、それを Debian に入れたいと
  考えたならば、ぜひあなたのアプリケーションを自分でパッケージ化して
  メンテナになってください。

  <p>もしディストリビューションの次のリリースにあなたのプログラムを
  含めたい(そのプログラムが有用なら、ぜひ!)ならば、パッケージを
  構築したあとに(あるいはしている最中でも構いませんが)
  正式な Debian メンテナになる必要があります。その手続きは
  開発者リファレンスで説明されていますので、そちらを参照してください。

  <chapt id="first">はじめの一歩

  <p><url name="Developer's Corner" id="http://www.debian.org/devel/">
  にある文書には、パッケージ化を始める上でどこからどうやって
  手をつけたらよいのかについてあまり書いてありません。この文書ではどんな
  細かい(最初見た時はほとんど無関係に思えるような)手順も余さず説明し、
  あなたが最初のパッケージを作るお手伝いをします。
  ともかく一つ作ってしまえば、あとは次のリリース、そして他のパッケージへ
  と経験を積んでいけばよいのです。

  <sect id="choose">パッケージ化するプログラムの選定

  <p>パッケージにしたいプログラムについてはすでに各自お考えがあると
  思いますが、未経験者なら以下をチェックしてみてください。

  <list>
  <item>そのパッケージがすでにディストリビューションに収録されていないか
  どうか確かめてください。もしあなたが「安定版」を使っているのなら、
  たぶん
  <url name="パッケージ検索ページ" id="http://www.debian.org/distrib/packages.html">
  に行って調べるのが最上の策です。
  ((訳注: <url name="Debian JP パッケージ" id="http://www.debian.or.jp/Packages.html">
  もついでに見ておくといいかもしれません。))
  もしあなたが<strong>現在の</strong>「開発版」ディストリビューションを使って
  いるのなら、以下のコマンドを使って調べてみてください。

  <example>
  dpkg -s プログラム名
  dpkg -l '*プログラム名*'
  </example>

  <item><url name="WNPP page" id="http://www.debian.org/devel/wnpp/">
  ((訳注:
  <url id="http://www.debian.or.jp/devel/prospective-packages.html"
     name="作業を必要としているパッケージ"> も見ておきましょう))、
  あるいは debian-devel メーリングリストで
  誰か他の人が同じプログラムのパッケージを作っていないかどうか
  確かめてください。もし誰か作っていたら、現在のメンテナに連絡を
  とってご自分の要望を伝えてください。それで満足したならば、まだ誰も
  手をつけていない他の面白いプログラムを探して再チャレンジです。</item>

  <item>プログラムはライセンスを<strong>与えられていなければなりません</strong>。
  それが
  <url name="Debian フリーソフトウェアガイドライン、DFSG" id="http://www.debian.org/social_contract.html#guidelines">
  で示されているようなフリーのものであれば言うことなしです。
  ((訳注: 日本のミラーサイトは
   <url name="Debian フリーソフトウェアガイドライン" id="http://www.jp.debian.org/social_contract#guidelines">
   にあります))

  もしガイドラインにそぐわない点があっても、Debian の「contrib」や
  「non-free」セクションに入れることは可能です。
  もしどのセクションに入れればよいか良く分からなければ、
  <email/debian-legal@list.debian.org/ で聞いてみてください。
  </item>
  
  <item>プログラムは setuid root で動くものであっては<strong>なりません。
  </strong>。
  一番良いのは、setuid とか setgid とかの使用を要求しない
  プログラムです。</item>

  <item>デーモンや何か */sbin に行くようなものは手始めとしてはよろしくない。
  </item>

  <item>プログラムはバイナリ実行形式になるものがよいでしょう。ライブラリ
  は今はやめといたほうがいいですよ。
  </item>

  <item>ちゃんとした説明書きのあること。あるいは少なくとも誰にとっても
  理解可能なプログラムであること。</item>

  <item>プログラムの作者に連絡をとってパッケージ化の承諾をもらいましょう。
  何かプログラムそのものに起因する問題が発生した際に、作者にいろいろ聞けると
  いうことは重要なので、由来のはっきりしないソフトウェアの断片をパッケージ化
  するのはやめておきましょう。
  </item>

  <item>そして最後に、といってもこれが重要なのですが、
  ちゃんと動くかどうか確かめましょう。そして何回か試してみましょう。
  </item>
  </list>

  <p>もちろんこれらのことは安全策というだけのことです。筆者としては、
  何も知らないままにパッケージ化しておまけにミスった
  ある種の setuid デーモンのせいで
  怒り狂ったユーザからあなたに向けて抗議殺到というような事態を
  回避したいのです。
  パッケージ化についてもっと経験を積めば、こうしたパッケージも
  作れるようになるでしょう。しかし、どんなに老練な開発者だって
  何か分からないことがあれば debian-devel メーリングリストで質問するの
  です。そこには喜んで手助けしてくれる人々がいます。

  <p>もっと詳しい話は、開発者リファレンスに載っていますので
     そちらを参照してください。

  <sect id="getit">プログラムを手にいれて、試してみる

  <p>さて、最初にすべきことは、オリジナルのソースを探してダウンロード
  することです。ここでは作者のホームページからすでにソースファイルを入手した
  として話を進めます。
  フリーな Linux 用プログラムのソースはふつう tar/gzip 形式で提供されています。
  拡張子は .tar.gz で、普通は「プログラム名-バージョン」という
  サブディレクトリを含んでいます。そこにすべてのソースが入っているわけです。
  もしあなたのプログラムのソースが他の種類のアーカイブで提供されていたら
  (例えばファイル名が <TT>.Z</TT>とか<TT>.zip</TT>で終わっていたら)、
  適切なツールで展開しましょう。どうやって展開したらよいのか
  良く分からなかったら debian-mentors メーリングリストで聞いてみましょう
  (ヒント: 「file アーカイブファイル名.拡張子」を実行してるとよいかも)。

  <p>さて本稿では、「gentoo」というプログラムを例にとって説明しようと
  思います。これは X11 上で動く GTK+ を使用したファイルマネージャです。
  ちなみにこのプログラムはすでにパッケージ化されており、また、
  この文書が最初に書かれた時点から比べると大幅に改変が加えられていることに
  注意してください。

  <p> 自分のホームディレクトリ以下に 'debian'、'deb'、または何か適当だと
  思われる名前 (今回の場合には ~/gentoo/ とでもすれば良いでしょう) の
  サブディレクトリを作りましょう。
  ダウンロードしたアーカイブをここにコピーし、
  ( tar xzf gentoo-0.9.12.tar.gz を実行して) 展開してください。
  この時エラーが (一見「無関係」に思えるようなものでさえ) 起きなかったか
  どうか、確認しておいてください。
  もしエラーが起きたら、それは他の人々のシステム上で展開する際にもおそらく
  エラーが起きるということです。そしてそこで使われている展開用のツールは
  こういった異常を無視するかも知れませんし、無視してくれないかもしれません。
  
  <p>さて、「gentoo-0.9.12」という別のサブディレクトリができました。
  展開したディレクトリに移って、提供されているドキュメントを
  <strong>徹底的に</strong>読みましょう。
  通常は README*、INSTALL*、*.lsm、*.html などといった名前のファイルが
  あり、
  それらの文書の中に、どうやったら正しくコンパイルできるのか、
  どうインストールすればよいのかといった情報が見つかるはずです。
  (たぶん /usr/local/bin にインストールするものとして説明されていますが、
  そうしてはいけません。これについては <ref id="destdir"> を
  参照してください)。

  <p>プログラムによって構築の手順は代わりますが、最近のプログラムだと
  「configure」スクリプトが付属していることがあります。
  このスクリプトはソースをあなたのシステムに応じて設定し、あなたの
  システムにおいてコンパイルできるかどうか確かめます。
   設定したあと(「./configure」と実行)、プログラムは普通
  「make」でコンパイルされます。「make check」でプログラムに含まれている
  自己診断テストを実行できるものもあります。
  目的のディレクトリへのインストールは一般に「make install」によって
  実行されます。

  <p>さあ、試しにプログラムをコンパイルし、実行してみましょう。
  インストール中や実行中に他の何かを壊してしまうことが無いかどうか、
  またちゃんと動作するかどうか、などを確認してください。

  <p>それから、「make uninstall」を実行するとインストールされたファイルを
  すべて削除できる場合が多いです。また 「make clean」(もっと良いのは
  「make distclean」) を実行するとコンパイル用のディレクトリを
  きれいにしてくれます。

  <sect id="namever">「dh_make」を実行する前にやっておくべきこと

  <p>パッケージ化の作業は完全にクリーンな (オリジナルのままの)
  ソースディレクトリ、簡単に言えば新しく展開したソースから始めるべきです。

  <p>パッケージをきちんと作るためには、(もしまだそうなっていなければ) 
  プログラム名がすべて小文字になるよう、オリジナルの名前から
  変更しておかなければいけません。
  またソースディレクトリ名を &lt;パッケージ名&gt;-&lt;バージョン&gt; に
  変更しておきましょう。
  
  <p>もしプログラムの名前が一語以上で構成されていたら、
  一つの語につなげるか省略形にしましょう。
  例えば、「John's little editor for X」というソフトウェアならば
   johnledx とか jle4x というようにしましょう。あまり長すぎない程度、
  せいぜい 20 文字くらいまでの長さで、適当に決めて下されば結構です。

  <p>プログラムの正確なバージョンもチェックしましょう
  (パッケージのバージョンに含めるために)。
  もしそのソフトウェアが「バージョン X.Y.Z」という形式で番号付けされて
  おらず、ある種の日付で区別されている場合には、バージョン番号として
  "0.0." にその日付を続けたものを使ってもいいでしょう
  (先頭に "0.0." を付けておくのは、上流の開発者たちがある日
  1.0 のような素敵なバージョンをリリースすると決めた場合に備えての
  ことです。) つまり、もしリリースの、あるいはスナップショットの
  日付が 1998 年の 12 月 19 日だったら、0.0.19981219 としておけば
  結構です。
  およそバージョン番号に使えそうな情報がまったくないと言う場合、
  上流メンテナに連絡をとって彼らが何か他のリビジョン管理手段を
  使っているかどうか聞いてみましょう。

  <sect id="dh_make">「dh_make」の実行

  <p>現在プログラムのソースディレクトリにいることを確認し、以下を
  実行してください。

  <p><example>
  dh_make -e your.maintainer@address -f ../gentoo-0.9.12.tar.gz
  </example>
   
  <p>もちろん、"your.maintainer@address" の部分は changelog の
  エントリやその他のファイルに記載するための、あなたの電子メール
  アドレスに置き換えてくさい。またファイル名はオリジナルソース
  アーカイブの名前に置き換えてください。
  詳細は <manref name="dh_make" section="1"> を参照してください。

  <p>画面にはいろいろ表示されて、あなたが作ろうとしているパッケージ
  がどういう種類のものか聞いてきます。gentoo は 単一バイナリパッケージ - 
  すなわちパッケージに含まれるバイナリが一つだけで、一つの .deb ファイル
  のみが作成される - ですので最初の選択肢を選び、「s」キーを押しましょう。
  その後、画面に表示される情報をよく読み、確認したら &lt;enter&gt; を押して
  ください。
  初めてパッケージを作るというときには、マルチバイナリパッケージや
  ライブラリに手を出さない方が無難です。この話は前にもしましたね。
  実際には作業自体はそれほど大変ではないのですが、ちょっとだけ
  より多くの知識が必要になります。そのため、ここではそれについてごちゃごちゃ
  説明することは控えます。

  <p>dh_make の実行は <strong>ただ一度だけ</strong> です。注意して
  ください。既に「デビアン化」された同じディレクトリで再び実行すると、
  正しく動作しないでしょう。これはつまり、将来パッケージの改訂版や
  新バージョンをリリースする時には別の方法を使うことになる、ということでも
  あります。後で説明する <ref id="update"> の部分をしっかり読んでください。

  <chapt id="modify">ソースコードの変更

  <p>ふつう、プログラムは自分自身を /usr/local 以下のディレクトリに
  インストールするようになっています。しかし、Debian システムにおいては、
  /usr/local 以下はシステム管理者(とユーザ)の個人的利用のために
  予約されているので、Debian パッケージはこのディレクトリを使っては
  いけないことになっています。
  このため、Makefile に始まるプログラムを生成するための仕組を調べなければ
  いけません。Makefile というのは <manref name="make" section="1"> が
  このプログラムを自動生成するために利用するスクリプトです。
  Makefile について詳しくは、<ref id="rules">を参照してください。

  <p>もしあなたのプログラムが GNU <manref name="automake" section="1"> や
  <manref name="autoconf" section="1"> を使っているのでしたら、ソースに
  それぞれ Makefile.am や Makefile.in などのファイルが含まれているはずです。
  このような場合には、Makefile ではなく、これらのファイルを変更する必要が
  あります。何故なら、automake を実行すると Makefile.am から生成された
  情報によって Makefile.in が上書きされ、また ./configure を実行すると
  Makefile.in から生成した情報によって Makefile が上書きされるからです。
  Makefile.am の編集には、automake の知識がすこしばかり必要になります。
  これについては info automake で調べることができます。
  一方、Makefile.in の編集は普通の Makefile の編集とほぼ同じです。
  ただちょっと変数に気をつければいいだけです。変数というのは例えば
  @CFLAGS@ や @LN_S@ などのように「@」で囲まれた文字列のことです。
  これらの変数は ./configure を実行した際に実際の内容に置き換えられます。

  <p>修正の具体的なやり方について<em>何から何まで</em>説明するにはとても
  紙面が足りませんが、よくあるパターンとしては大体以下のようなものでしょう。

  <sect id="destdir">サブディレクトリへのインストール

  <p>ほとんどのプログラムは自分自身をシステムの既存のディレクトリ構造に
  インストールするための仕組を備えています。これによってインストールされた
  バイナリがユーザの $PATH に含まれるようになり、また附属文書やマニュアル
  ページをシステムに共通の場所で見ることがでるようになるわけです。
  あなたがパッケージ化するプログラムがこの作業をきちんと実行できることを
  確認しなければいけません。さらに、Debian パッケージを作成するためには、
  プログラムを通常 debian/ ディレクトリの下に作成される
  作業用のサブディレクトリ以下にインストールさせなければなりません。
  この一時的なサブディレクトリには通常 <tt>debian/tmp</tt> という名前が
  付けられていて、ここの中身をメンテナー用ツールがきちんとした
  一つの .deb パッケージにまとめあげてくれます。
  このディレクトリ以下にあるファイルは、パッケージを
  インストールした際にはすべてユーザのシステムへとインストールされます。
  唯一の違いは dpkg がファイルをルートディレクトリ以下にインストールする
  ということだけです。

  <p>基本的に、パッケージを作成するためにはプログラムを debian/tmp に
  インストールすることが必要ですが、一方パッケージをインストールした後は
  ルートディレクトリ以下に置かれるため、その状態で正しく動作できるように
  しなければなりません。GNU autoconf を使用するプログラムの場合は、
  dh_make がこの作業を行なうコマンドを自動的に設定してくれるため、
  このセクションを読み飛ばしてしまってもいいくらい非常に簡単な作業です。
  しかし、その他のプログラムについては、おそらく自分で Makefile を調べて
  編集する必要があるでしょう。

  <p>以下は gentoo の Makefile 中の関連する部分です。

  <p><example>
  # Where to put binary on 'make install'?
  BIN     = /usr/local/bin
  # Where to put icons on 'make install'? Note: if you change this,
  # gentoo will not find the icons as it starts up. You're going to
  # have to alter gentoo's icon path (in the config window, "Paths"
  # tab) to get it work.
  ICONS   = /usr/local/lib/gentoo/
  </example>

  <p>まず始めに、以下のような新しい行を 2 行挿入しましょう。

  <p><example>
  # Edited for Debian GNU/Linux.
  DESTDIR =
  </example>
  これはパッケージ構築の過程で必要になります(後の <ref id="rules"> 
  の項で説明します)。

  <p>次に、 Makefile で最終的に生成されたバイナリがインストールされる
  場所が指定されているところを探し、こんな風に変えます。
  <p><example>
  # Where to put binary on 'make install'?
  BIN     = $(DESTDIR)/usr/X11R6/bin
  </example>

  <p>しかしなぜこのディレクトリなんでしょう。他の所じゃだめでしょうか？
  だめです。
  というのも Debian ではどこにプログラムをインストールするかいくつかの
  ルールが決められているからです。これは「ファイルシステム体系基準」
  (/usr/share/doc/debian-policy/fhs)で指定されています。
  Gentoo は X11 用のプログラムですので、/usr/local/bin ではなく 
  /usr/X11R6/bin にインストールしなければなりません。
   man ページは(大抵のプログラムには付属していますが、無い場合も
  あります。今回は無いのであとでひとつ書くことにします) /usr/local/man/man1 
  ではなく /usr/share/man/man1 にインストールしなければなりません。

  <p>さて次はちょっと厄介な問題です。例えばあなたが次の行を以下のように
  変更したとします。

  <p><example>
  ICONS   = $(DESTDIR)/usr/share/gentoo/
  </example>
  さて、ポリシーに合わせたのは良いのですが、今度は C のソースそのものを
  いじってアイコンを参照しているところすべてを修正しなければなりません。
  でもどこを、そして何を探せばよいのでしょうか？修正すべき個所を探すには
  ( .c と .h という拡張子のファイルを含むすべてのディレクトリで)
  こんな風に実行すればよいでしょう。
  <p><example>
  grep -n usr/local/lib *.[ch]
  </example>
  
   Grep は usr/local/lib という文字列を探して、見つかったファイル名と
   それが何行めであるかを教えてくれるでしょう。そうしたらそれらのファイルを
   編集して usr/local/lib という部分を usr/share に置き換えてやれば
   良いのです。それでおしまい。usr/local/lib をあなたの指定した場所に
   置き換えるだけです。
   他の部分をいじってぐちゃぐちゃにしないよう気をつけましょう。
   もしあなたが C プログラミングについてあまりご存知ないならば :-)

  <p>修正が終ったら、インストールターゲットを探しましょう(「install:」
  で始まる行を探してみてください)。Makefile の先頭で
  直接定義されているものを除いて、ディレクトリへの参照を
  すべて変更してください。
  gentoo の元々のインストールターゲットはこんな感じでした。

  <p><example>
  # ----------------------------------------- Installation

  # You're going to have to be root to do this!
  install:        gentoo
                  install ./gentoo $(BIN)
                  install icons $(ICONS)
                  install gentoorc-example $(HOME)/.gentoorc
  </example>

  <p>修正後はこんな風になります。
  <example>
  # ----------------------------------------- Installation

  # You're going to have to be root to do this!
  install:        gentoo-target
                  install -d $(BIN) $(ICONS) $(DESTDIR)/etc
                  install ./gentoo $(BIN)
                  install -m644 icons/* $(ICONS)
                  install -m644 gentoorc-example $(DESTDIR)/etc/gentoorc
                  install -d $(DESTDIR)/usr/share/doc/gentoo/html
                  cp -a docs/* $(DESTDIR)/usr/share/doc/gentoo/html
  </example>

  <p>鋭い人なら私が「install:」の行の「gentoo」を「gentoo-target」に変えた
  のに気づくでしょう。 こういうのをバグフィックスというのですな。:-)

  <p>今のような、特に Debian パッケージだけに関係しない変更はすべて
  上流メンテナに報告し、プログラムの次のリビジョンに反映してもらうように
  しましょう。注意すべきことは debian/* 以下のファイルを送る必要は無いと
  いうことです。それらを除いたパッチを用意して送りましょう。
  また、あなたの修正を送る前に、Debian や Linux (あるいは Unix でさえも!)
  だけに通用するものでなく、できるだけ広範囲に通用するよう心がけることで、
  上流の開発者にとっての負担を軽減するように努めましょう。

  <sect id="difflibs">使用ライブラリの違い

  <p>よくある問題としてもう一つ、ライブラリの問題があります。
  ライブラリはしばしばプラットフォームごとに異なります。
  例えば、 Makefile は Debian 上には、あるいはもしかしたら Linux 上
  には存在しないライブラリへの参照すら含んでいるかもしれません。
  その場合、その個所を探して、Debian 上に存在する互換のライブラリを
  指すように変更してやらなければなりません。
  一番良いのはそういう行をコメントにしておくことです。
  そうしておけば、他の人が違うプラットフォーム上でコンパイルしようとして
  何か問題が起こったときに、解決のヒントになるかも知れませんから。

  <p>そんなわけで、もしあなたのプログラムの Makefile (または Makefile.in) 
  に以下のような部分があったら(そしてうまくコンパイルできなかったら)、

  <p><example>
  LIBS = -lcurses -lなんとか -lかんとか
  </example>

  <p>こういう風に変えましょう。今度はきっと大丈夫です。

  <p><example>
  LIBS = -lncurses -lなんとか -lかんとか
  #LIBS = -lcurses -lなんとか -lかんとか
  </example>

  <chapt id="dreq"> debian/ ディレクトリ以下に無くてはならないファイル

  <p>プログラムのメインディレクトリ (「gentoo-0.9.12」) の中に、
  「debian」という名前の新しいディレクトリが作られています。
  このディレクトリ内には様々なファイルが納められていますが、
  パッケージの動作をカスタマイズするために、これらのファイルを
  これから編集していきます。
  最も重要なファイルは「control」、「changelog」、「copyright」、
  そして「rules」であり、これらのファイルはすべてのパッケージが
  必ず用意しなければならないものです。

  <sect id="control">「control」ファイル

  <p>このファイルには dpkg と dselect がパッケージを管理するために
  利用する様々な情報が納められています。
  以下は dh_make が作ってくれる control ファイルのひな型です。

  <p><example>
  1  Source: gentoo
  2  Section: unknown
  3  Priority: optional
  4  Maintainer: Josip Rodin &lt;jrodin@jagor.srce.hr&gt;
  5  Standards-Version: 3.0.1
  6
  7  Package: gentoo
  8  Architecture: any
  9  Depends: ${shlibs:Depends}
  10 Description: &lt;insert up to 60 chars description&gt;
  11  &lt;insert long description, indented with spaces&gt;
  </example>
  (行番号は筆者が書き加えました)

  <p>1-5 行目はソースパッケージの管理情報です。1行目はソースパッケージの
  名前です。

  <p>2 行目はディストリビューションにおいてこのパッケージが所属する
  セクションです。
  既にお気づきかも知れませんが、Debian はいくつかのセクションに
  分割されています。セクションには main (完全にフリーなソフトウェア)、
  non-free (実際の所フリーであるとはいえないソフトウェア)、そして
  contrib (それ自身はフリーなソフトウェアであるけれども、non-free な
  ソフトウェアが無ければ使えないもの) があります。
  更に、これらの下にはどんなパッケージが含まれているのか簡単に説明する
  ような名前の付いた、論理的なサブセクションがいくつか
  存在しています。
  つまり、管理者専用のプログラムのために「admin」、基本的なツールの
  ために「base」、プログラマーのためのツールが含まれる「devel」、文書の
  「doc」、ライブラリの「libs」、電子メールを読み書きするための
  リーダやデーモンのための「mail」、ネットワーク関係のアプリケーション
  やデーモンの「net」、X11 用のプログラムのための「x11」など、そして
  さらに多くのものが用意されています。

  <p>ここでは x11 に変更しておきましょう。

  <p>3行目はこのパッケージがこのパッケージをインストールする
  ユーザにとってどれくらい重要なものかを示しています。
  セクション(Section) と優先度 (Priority) は、実際には dselect が
  パッケージをソートするときとデフォルトを選ぶときにしか
  使われません。そしてこれらのフィールドは
  (よくあることですが) 我々の FTP メンテナたちによって上書きされることが
  あります。
  これらのフィールドに何を設定すべきかについては、ポリシーマニュアル
  の説明を読んでください。

  <p>この gentoo は通常の優先度を持つパッケージなので、
  ここでは optional のままにしておきましょう。

  <p>4 行目はメンテナの名前と電子メールアドレスです。

  <p>5 行目はこのパッケージが準拠している Debian ポリシー基準の
  バージョン (インストールされている debian-policy パッケージの
  2 つのメジャーバージョン) です。

  <p>もしパッケージを生成するために標準的でないコンパイラ、または
  その他のツールが必要なら、ここ (5 行目と 6 行目(空行) の間) に
  「Build-Depends」行を追加して、必要なパッケージをそこに記載して
  おきましょう。これについての詳細は、パッケージングマニュアル
  (8.7 節) および「build-essential」パッケージの附属文書を参照して
  ください。

  <p>7 行目はバイナリパッケージの名前です。

  <p>8 行目にはバイナリパッケージをコンパイル可能な CPU アーキテクチャ
  を記述します。
  ここを「any」のままにしておけば、
  <manref name="dpkg-gencontrol" section="1">が、このパッケージを
  コンパイルしたマシンに合わせて適当に埋めてくれます。
  (パッケージのポーティングについては、開発者レファレンスを参照して
  ください。)
  あなたのパッケージが特定のアーキテクチャに依存しないのであれば
  (例えば、シェルや Perl のスクリプトであるとか、あるいは
  文書のパッケージである場合) ここを「all」に変更し、パッケージの
  生成に「binary-arch」ではなく「binary-indep」を使う方法について
  の説明をあとで <ref id="rules"> の項で読んでおいてください。

  <p>9 行目は Debian パッケージ管理システムの最も強力な機能のひとつ
  を示しています。
  それぞれのパッケージは様々な形で相互に関係情報を持つことができます。
  パッケージ間の関係には、Depends: すなわち「依存」の他に、Recommends:、
  Suggests:、Pre-depends:、Conflicts:、Provides:、Replaces: が
  あります。

  <p>dpkg、dselect、APT (そしてそのフロントエンド) などの
  パッケージ管理ツールは、通常これらの関係を処理する場合に、
  同じ動作をします。
  そうでない場合については、追々説明していきます。
  (<manref name="dpkg" section="8">、
   <manref name="dselect" section="8">、
   <manref name="apt" section="8">、
   <manref name="console-apt" section="8">、
   <manref name="gnome-apt" section="8">
  を参照してください)。

  <p>以下にこれらの依存関係が通常持つ意味を説明します。

  <p><list>
  <item>Depends: 「依存」
  <p>パッケージはここで指定したパッケージをインストールしない限り
  インストールされません。
  あなたのプログラムが特定のパッケージに依存していて、そのパッケージが
  存在しない限り全く動作しない (または非常に重大な問題が発生する) 
  場合には、これを使いましょう。</item>

  <item>Recommends: 「推奨」
  <p>dselect はここで指定されたパッケージがインストールされていない限り
  あなたのパッケージをインストールしません。
  dpkg と APT の場合には、無視してインストールすることが可能です。
  厳密に言えばあなたのプログラムの動作に必須ではないけれど、
  一緒に使うことがほぼ前提となっているようなパッケージは
  ここで指定しましょう。</item>

  <item>Suggests: 「提案」
  <p>dselect はあなたのプログラムをインストールする際に、
  ここで指定したパッケージをインストールするかどうかユーザに質問します。
  dpkg と APT はこの指定を無視します。
  必要というわけではないが、あなたのプログラムと一緒に使うと
  便利というパッケージについては、ここで指定しておきましょう。</item>

  <item>Pre-Depends: 「先行依存」
  <p>これは Depends: よりも強い関係を示します。
  ここで指定されたパッケージがあらかじめインストールされ、<em>かつ</em>
  適切に設定されていない限り、あなたのパッケージは
  インストールされません。
  これを使う前に、まずは debian-devel メーリングリストで
  相談しましょう。できるだけ使わないようにしましょう。
  早い話が、使っちゃいけません。:-)</item>

  <item>Conflicts: 「競合」
  <p>ここで指定されたすべてのパッケージが削除されない限り、
  あなたのパッケージはインストールされません。特定のパッケージが
  存在しているとあなたのプログラムが動作しない (または非常に重大な
  問題が起きる) 場合には、これを使います。</item>

  <item>Provides: 「提供」
  <p>ほぼ同じ機能を持つパッケージが複数あって、選択の余地があるような
  場合のために仮想パッケージ名というものが定義されています。
  仮想パッケージ名の一覧は、ファイル
  /usr/share/doc/debian-policy/virtual-package-names-list.text.gz
  にあります。
  あなたのプログラムが既存の仮想パッケージに相当する機能を
  提供する場合には、これを使います。</item>

  <item>Replaces: 「置換」
  <p>あなたのプログラムが他のパッケージに含まれるファイルを
  上書きする場合、または他のパッケージ全体を完全に置き換えて
  しまう場合 (この場合は Conflicts: も一緒に指定してください) には、
  これを使います。
  指定されたパッケージに含まれる (上書き対象の) ファイルは、
  あなたのプログラムをインストールする前に削除されます。
  </item>
  </list>

  <p>これらのフィールドはすべて共通の書式で記述します。
  指定したいパッケージ名をコンマで区切って並べてください。
  もしいくつか選択肢があれば、それらのパッケージ名を
  縦棒 <tt>|</tt> (パイプ記号)で区切って並べてください。
  あるバージョンより上でなければダメ、などというようにパッケージの
  バージョン番号によって制限を加えることも可能です。
  これを指定したい場合にはそれぞれのパッケージ名の後で丸カッコ(パーレン)
  を開き、以下の関係式に続けてバージョン番号を指定してください。
  使用できる関係式は
  <tt>&lt;&lt;</tt>、<tt>&lt;=</tt>、<tt>=</tt>、<tt>&gt;=</tt>、
  <tt>&gt;&gt;</tt>で、それぞれ
  「指定されたものより古いバージョンのみ」、
  「指定されたもの以前か指定のバージョン」、
  「指定のバージョンのみ」
  「指定されたもの以降か指定のバージョン」、
  「指定されたものより新しいバージョンのみ」
  を意味します。
  
  <p>最後に、知っておかなければいけない機能をもうひとつ。
  それは $(shlibs:Depends) で、例えば libc6 や xlib6g のような
  あなたのプログラムが利用している共有ライブラリの名前すべてが
  <manref name="dh_shlibdeps" section="1"> によって自動的に
  調べられ、その結果は
  <manref name="dh_gencontrol" section="1"> によってこの記述と
  置換されます。
  これを使えば、あなた自身が自分で共有ライブラリを調べて記述する
  必要はありません。
  以上の説明から、今回は 9 行目をそのままにしておくことができます。

  <p>ここで 10 行目に gentoo が「提案」するパッケージの一覧を
  追加します。
  gentoo は「file」プログラム/パッケージによって提供される機能をいくつか
  利用することができるので、ここではそれだけを記載しておきましょう。

  <p>11 行目はこのパッケージに関する簡潔な説明です。多くの人々は
  一行半角 80 文字幅のスクリーンでこれを見ますから、
  半角 60 文字以上にしてはいけません。
  今回は「A fully GUI configurable GTK+ file manager」としました。

  <p>12 行目はこのパッケージに関する詳細な説明文です。
  ここでは一つの段落でパッケージについてより詳しく説明するように
  してください。それぞれの行は空白で始めなければいけません。
  また空白行を入れてはいけませんが、先頭の空白の後に . 
  (半角ピリオド) を書くことで、それらしく見せることができます。
  また、説明文の後に空白行があってはいけません。

  <p>以下が修正後の control ファイルです。

  <p><example>
  1  Source: gentoo
  2  Section: x11
  3  Priority: optional
  4  Maintainer: Josip Rodin &lt;jrodin@jagor.srce.hr&gt;
  5  Standards-Version: 3.0.1
  6
  7  Package: gentoo
  8  Architecture: any
  9  Depends: ${shlibs:Depends}
  10 Suggests: file
  11 Description: A fully GUI configurable GTK+ file manager
  12  gentoo is a file manager for Linux written from scratch in pure C. It
  13  uses the GTK+ toolkit for all of its interface needs. gentoo provides
  14  100% GUI configurability; no need to edit config files by hand and re-
  15  start the program. gentoo supports identifying the type of various
  16  files (using extension, regular expressions, or the 'file' command),
  17  and can display files of different types with different colors and icons.
  18  .
  19  gentoo borrows some of its look and feel from the classic Amiga file
  20  manager "Directory OPUS" (written by Jonathan Potter).
  </example>

  <sect id="copyright">「copyright」ファイル

  <p>このファイルにはパッケージの上流 (upstream) に関する
  リソース (URI など)、著作権、およびライセンスなどの情報を記載します。
  このファイルの書式はポリシーに規定されていませんが、内容については
  (6.5 節に) 規定されています。
  dh_make はデフォルトとして以下のようなひな型を作成します。

  <p><example>
  1  This package was debianized by Josip Rodin jrodin@jagor.srce.hr on
  2  Wed, 11 Nov 1998 21:02:14 +0100.
  3
  4  It was downloaded from &lt;fill in ftp site&gt;
  5
  6  Upstream Author(s): &lt;put author(s) name and email here&gt;
  7
  8  Copyright:
  9
  10 &lt;Must follow here&gt;
  </example>
  (行番号は筆者が書き加えました)

  <p>ここでファイルに追加すべき重要なことは、あなたがこのソフトウェアを
  入手した場所と、実際に有効な著作権表示およびライセンスです。
  原則としてライセンスは全文を含めなければなりません。
  ただし、もしプログラムのライセンスが GNU GPL または LGPL、BSD、
  あるいは Artistic などの良く知られたフリーソフトウェアのライセンス
  であって、どの Debian システムにも存在するディレクトリ
   /usr/share/common-licenses/ の中の適切なファイルを参照することで
  ライセンスの内容をすべて示すことができる場合に限って、
  全文をここに引用する必要はありません。
  gentoo は GNU 一般使用許諾 (GPL) に従って配布されていますから、
  こんな風に変更しましょう。

  <p><example>
  1  This package was debianized by Josip Rodin jrodin@jagor.srce.hr on
  2  Wed, 11 Nov 1998 21:02:14 +0100.
  3
  4  It was downloaded from http://www.obsession.se/gentoo/
  5
  6  Upstream Author(s): Emil Brink &lt;emil@obsession.se&gt;
  7
  8  This software is copyright (c) 1998-99 by Emil Brink, Obsession
  9  Development.
  10
  11 You are free to distribute this software under the terms of
  12 the GNU General Public License.
  13 On Debian systems, the complete text of the GNU General Public
  14 License can be found in /usr/share/common-licenses/GPL file.
  </example>
  (行番号は筆者が書き加えました)

  <sect id="changelog">「changelog」ファイル

  <p>これは必須のファイルです。パッケージングマニュアル (3.2.3 節)
  にはこのファイルのための特別な書式が規定されています。
  この書式は dpkg やその他のプログラムによってあなたのプログラムの
  バージョン番号、レビジョン、ディストリビューション、それに緊急度
  (urgency) を識別するために利用されます。

  <p>あなたが行なったすべての変更をきちんと記載しておくことは
  良いことであり、その意味でこのファイルはまた、パッケージメンテナ
  であるあなたにとっても重要なものです。
  あなたのパッケージをダウンロードした人々は、
  このファイルを見ることで、ユーザが最初に知っておくべき
  このパッケージに関する解決されていない問題があるかどうかを
  知ることができます。
  このファイルはバイナリパッケージ中に
  「/usr/share/doc/gentoo/changelog.Debian.gz」として保存されます。

  <p>dh_make がデフォルトとして生成する changelog はこんな感じです。

  <p><example>
  1  gentoo (0.9.12-1) unstable; urgency=low
  2
  3   * Initial Release.
  4
  5  -- Josip Rodin &lt;jrodin@jagor.srce.hr&gt; Wed, 11 Nov 1998 21:02:14 +0100
  6
  7  Local variables:
  8  mode: debian-changelog
  9  End:
  </example>
  (行番号は筆者が書き加えました)

  <p>1 行目はパッケージ名、バージョン、ディストリビューション、
  そして緊急度 (urgency) です。
  ここに書くパッケージ名はソースパッケージの名前と一致していなければ
  なりません。
  またディストリビューションは (今の時点では) 「unstable」または
  「experimental」のどちらかにすべきであり、緊急度は「low」より
  高いものに変更するべきではありません :-)
  
  <p>3-5 行目はログエントリで、ここにこのリビジョンのパッケージで
  行われた変更を記述します (上流プログラムそのものの変更点では
  ありません - その目的のためには、上流作者によって作成され、
  /usr/share/doc/gentoo/changelog.gz としてインストールされる
  専用のファイルが存在しています)。
  新しい行はアスタリスク(「*」)で始まる最初の行の直前に挿入します。
  この操作は
  <manref name="dch" section="1">、や <manref name="emacs" section="1">
  (7-10 行目は Emacs エディタ用のモード情報です) を使うと
  便利ですが、その他の普通のテキストエディタを使って実行しても
  もちろん構いません。
  最終的にこんな風になればよいわけです。

  <p><example>
  1  gentoo (0.9.12-1) unstable; urgency=low
  2
  3   * Initial Release.
  4   * This is my first Debian package.
  5   * Adjusted the Makefile to fix $DESTDIR problems.
  6
  7  -- Josip Rodin &lt;jrodin@jagor.srce.hr&gt; Wed, 11 Nov 1998 21:02:14 +0100
  8
  9  Local variables:
  10  mode: debian-changelog
  11 End:
  </example>
  (行番号は筆者が書き加えました)

  <p>パッケージの新バージョンをリリースする際には、バージョン番号を
  増やさなければいけません。
  これは単に「dch -i」を実行するか、あるいは
  「dch -v &lt;version&gt;-&lt;revision&gt;」によって明示的に
  バージョン番号を指定して、その後で好みのエディタを使って
  必要なコメントを記載していきます。
  ヒント: 規定の書式で日時を入力する簡単な方法。
  「822-date」または「date -R」を使いましょう。

  <p>新バージョンについての情報は changelog ファイルの先頭に追加されます。
  作業後 changelog はこんな風になります。

  <p><example>
  1  gentoo (0.9.12-2) unstable; urgency=low
  2
  3   * Fixed a glitch in the menu file.
  4
  5  -- Josip Rodin &lt;jrodin@jagor.srce.hr&gt; Wed, 11 Nov 1998 22:15:39 +0100
  6
  7  gentoo (0.9.12-1) unstable; urgency=low
  8
  9   * Initial Release.
  10  * This is my first Debian package.
  11  * Adjusted the Makefile to fix $DESTDIR problems.
  12
  13 -- Josip Rodin &lt;jrodin@jagor.srce.hr&gt; Wed, 11 Nov 1998 21:02:14 +0100
  14
  15 Local variables:
  16 mode: debian-changelog
  17 End:
  </example>
  (行番号は筆者が書き加えました)

  <p>あとから <ref id="update"> の中で新しいパッケージの
  バージョンとレビジョンについてもっと詳しく説明します。

  <sect id="rules">「rules」ファイル

  <p>さて、今度は <manref name="dpkg-buildpackage" section="1"> が
  実際にパッケージを作成するために使う「rules」ファイルを
  調べる必要があります。
  このファイルは「make -f」で実行されるため、実はもう一つの
  Makefile といったものですが、上流ソースに含まれる Makefile とは
  違います。

  <p>すべての「rules」ファイルは、他の Makefile と同じく、ソースから
  プログラムを構築する方法を記述したいくつかのルールによって
  構成されています。
  それぞれのルールはいくつかのターゲット、ファイル名、
  あるいは実行されるべき動作の名前(つまり「build:」や「install:」)
  によって構成されます。
  実行したいルールは、コマンドライン引数として指定します
  (例えば「./debian/rules build」または「make -f rules install」と
  いうように)。ターゲット名の後には、依存関係、そのルールが
  依存しているプログラムやファイルの名前を指定できます。
  この後には、いくらでもコマンドを記述できます
  (各行を &lt;タブ&gt;で始めてください!)
  空行があると、そこで一つのルールが終り、次のルールが
  始まります。複数の空行、および「#」 (ハッシュ) で始まる行は
  行の終りまでコメントと見なされ、無視されます。

  <p>以上を読んでもわけが分からないかもしれませんが、dh_make が
  デフォルトとして作成する「rules」ファイルを実際に読んでみると、
  理解できるようになるでしょう。
  また、info コマンドの「make」エントリーに、より詳細な説明が
  あるので、読んでおくと良いでしょう。

  <p>dh_make によって作成された rules ファイルについて知っておくべき
  最も重要なことは、これが単なる提案であり、サンプルに過ぎない、と
  いうことです。
  単純なパッケージに対してはこのままでも使えるでしょうけれど、
  もっと複雑なパッケージの場合には、必要に応じて追加したり
  省略したりすることをためらってはいけません。
  あなたが変えてはいけないのはたった一つ、rules ファイル内に
  記述された各ルールの名前だけです。
  すべてのツールがパッケージングマニュアルに規定されたように
  これらの名前を参照するので、ルールの名前を変更してしまうと
  うまくパッケージを生成できなくなってしまいます。

  <p><example>
  1  #!/usr/bin/make -f
  2  # Made with the aid of dh_make, by Craig Small
  3  # Sample debian/rules that uses debhelper. GNU copyright 1997 by Joey Hess.
  4  # Some lines taken from debmake, by Christoph Lameter.
  5
  6  # Uncomment this to turn on verbose mode.
  7  #export DH_VERBOSE=1
  8
  9  # This is the debhelper compatability version to use.
  10 export DH_COMPAT=1
  11
  12 build: build-stamp
  13 build-stamp:
  14	dh_testdir
  15
  16	# Add here commands to compile the package.
  17	$(MAKE)
  18
  19	touch build-stamp
  20
  21 clean:
  22	dh_testdir
  23	dh_testroot
  24	rm -f build-stamp
  25
  26	# Add here commands to clean up after the build process.
  27	-$(MAKE) clean
  28
  29	dh_clean
  30
  31 install: build-stamp
  32	dh_testdir
  33	dh_testroot
  34	dh_clean -k
  35	dh_installdirs
  36
  37	# Add here commands to install the package into debian/tmp.
  38	$(MAKE) install DESTDIR=`pwd`/debian/tmp
  39
  40 # Build architecture-independent files here.
  41 binary-indep: build install
  42 # We have nothing to do by default.
  43
  44 # Build architecture-dependent files here.
  45 binary-arch: build install
  46 #	dh_testversion
  47	dh_testdir
  48	dh_testroot
  49 #	dh_installdebconf
  50	dh_installdocs
  51	dh_installexamples
  52	dh_installmenu
  53 #	dh_installemacsen
  54 #	dh_installpam
  55 #	dh_installinit
  56	dh_installcron
  57	dh_installmanpages
  58	dh_installinfo
  59 #	dh_undocumented
  60	dh_installchangelogs
  61	dh_link
  62	dh_strip
  63	dh_compress
  64	dh_fixperms
  65	# You may want to make some executables suid here.
  66	dh_suidregister
  67 #	dh_makeshlibs
  68	dh_installdeb
  69 #	dh_perl
  70	dh_shlibdeps
  71	dh_gencontrol
  72	dh_md5sums
  73	dh_builddeb
  74
  75 binary: binary-indep binary-arch
  76 .PHONY: build clean binary-indep binary-arch binary install
  </example>
  (行番号は筆者が書き加えました)

  <p>1 行目は、シェルや Perl のスクリプトでおなじみの表現でしょう。
  これは、このファイルが /usr/bin/make によって処理されることを
  オペレーティングシステムに指示しています。

  <p>12 行目から 19 行目までは「build」 (およびその子供である
  「build-stamp」) ルールを記述しており、その中でプログラムを
  コンパイルするためにアプリケーション自身の Makefile を実行
  しています。

  <p>21 行目から 29 行目までに記述されている「clean」ルールは、
  パッケージの生成過程によって自動生成されたバイナリその他の
  不要なファイルをすべて削除します。
  このルールはどんな時でも (たとえソースツリーが <em/削除/ 
  されてしまっている状態でも!) きちんと動作しなければいけません。
  このため、強制オプションを使うか (たとえば rm なら「-f」)、
  返り値を無視する (コマンド名の前に「-」を追加) などの措置を
  講じてください。
  
  <p>インストール方法を記述する「install」ルールは 31行目から
  始まります。このルールは基本的にプログラム自身の Makefile に
  記述されている「install」ルールを実行しますが、
  インストール先は `pwd`/debian/tmp ディレクトリです - 
  このために gentoo の Makefile の中で $(DESTDIR) を
  ルートインストールディレクトリとして指定しておいたのです。
  
  <p>コメントにもあるように、41 行目の「binary-indep」ルールは
  アーキテクチャに依存しないパッケージを生成するために使われます。
  今回の例はそのようなパッケージではないため、ここでするべきことは
  何もありません。
  もしあなたのパッケージが「Architecture: all」なら、パッケージを
  生成するために必要なコマンドをすべてこのルールの中で指定し、
  その代りに次のルール (「binary-arch」) を空にしておかなければ
  いけません。
  
  <p>さあ、次のルール - 「binary-arch」の番です。45 行目から 73 行目に
  かけて記述されたこのルールでは、あなたのパッケージが Debian ポリシー
  に適合するよう、debhelper パッケージに収録されているいくつかの小さな
  ユーティリティを実行して、これから生成するパッケージ中のファイルに
  対してさまざまな操作を行ないます。
  
  <p>これらのユーティリティの名前は dh_ で始まり、残りの部分は
  そのユーティリティが実際に行なう内容に関する説明となっています。
  これらはほとんど読めばすぐわかるような簡単なものですが、
  以下に説明を追加しておきます。

  <list>
  <item><manref name="dh_testdir" section="1"> はあなたが正しい
  ディレクトリ (つまり、ソースディレクトリのトップレベル) に
  いるかどうかをチェックします
  <item><manref name="dh_testroot" section="1"> は binary* ターゲット
  と clean ルールの実行に必要なルート権限をあなたが持っているかどうか
  チェックします。
  <item><manref name="dh_installmanpages" section="1"> は
  ソースツリーの中に見つかったすべての man ページをパッケージに
  コピーします。(注意: これは DWIM、つまり書いたとおりの意味です。)
  ((訳注: DWIM の意味については jargon を参照のこと))
  <item><manref name="dh_strip" section="1"> はデバッグ用ヘッダを
  実行形式ファイルおよびライブラリから取り除き、それらのサイズを
  小さくします。
  <item><manref name="dh_compress" section="1"> は man ページと
  サイズが 4 kB より大きな附属文書を gzip で圧縮します。
  ((訳注: 附属文書のうち圧縮形式の画像ファイルと HTML ファイルは
  サイズに関わらず圧縮されません。既に圧縮済みのファイルも、
  二重に圧縮されることはありません。))
  <item><manref name="dh_installdeb" section="1"> はパッケージに
  関連するファイル (例えばメンテナースクリプトなど) を
   debian/tmp/DEBIAN ディレクトリにコピーします。
  <item><manref name="dh_shlibdeps" section="1"> はライブラリや
  実行形式ファイルが依存している共有ライブラリを判定します。
  <item><manref name="dh_gencontrol" section="1"> は
  control ファイルに必要な情報を追加し、インストールします。
  <item><manref name="dh_md5sums" section="1"> はパッケージ中の
  すべてのファイルに対して MD5 チェックサムを計算します。
  </list>

  <p>これらすべての dh_* スクリプトが実際にはそれぞれ何をするのか、
  また他にはどんなオプションが使えるのか、などのさらに詳しい情報に
  ついては、それぞれの man ページを参照してください。
  また、ここでは取り上げませんでしたが、非常に便利だと思われる
  dh_* スクリプトが他にもいくつか用意されています。
  これらに関しては、必要に応じて debhelper の説明書を読んでみて
  ください。

  <p>binary-arch セクションの中にある、不要な処理を実行している行は
  すべてどんどんコメントにしてしまうべきです。gentoo の場合には、
  testversion、emacsen、pam、init、cron、manpages、info、undocumented、
  suidregister, makeshlibs、そして perl に関する行を、単に gentoo が
  これらの処理を必要としていないという理由によってコメントにします。
  また、今回の場合、60 行目に「FIXES」を追加する必要があります。
  上流開発者 (upstream) の changelog (変更履歴) ファイルの名前が
  FIXES だからです。  

  <p>最後の 2 行は (説明しなかった他の行と同様に) 多少なりとも
  必要なものです。これらについては make のマニュアルや
  パッケージングマニュアルの中に説明があります。
  今のところは、必ず知っておかなくてはいけないような重要な項目
  というわけではありません。

  <chapt id="dother">debian/ の中にあるその他のファイル

  <p>debian/ サブディレクトリには他にもいくつかのファイルが
  あるはずです。それらのほとんどには「.ex」サフィックスが
  付いており、そのファイルがサンプルであることを示しています。
  もしこれらの機能のどれかを使いたいと思ったり、また使う必要が
  生じたりした場合には、そのファイル自身と関連する文書
   (ヒント: ポリシーマニュアル) を調べ、
  「.ex」というサフィックスを取り除くように名前を変更し、
  そのファイルの内容と rules ファイルとを必要に応じて編集して
  ください。
  これらのファイルのうち、特によく利用されるものについては、
  以下のセクションに説明があります。

  <sect id="readme">README.Debian

  <p>パッケージに関して何か特別にユーザに知らせる必要がある情報や、
  オリジナルのソフトウェアとあなたが Debian パッケージにした
  バージョンとの相違点は、ここに記述しておくべきです。
  以下はデフォルトとして dh_make が生成するものです。

  <example>
  gentoo for Debian
  ----------------------

  &lt;possible notes regarding this package - if none, delete this file&gt;

  Josip Rodin &lt;jrodin@jagor.srce.hr&gt;, Wed, 11 Nov 1998 21:02:14 +0100
  </example>

  <p>今回は特に何も書き込む必要はありません - つまりこのファイルを
  削除してもいいということです。
  

  <sect id="conffiles">conffiles

  <p>ソフトウェアに関して最もうんざりさせられることのひとつに、
  大変な量の時間と労力を費してプログラムをカスタマイズした後で
  そのための設定変更が一回のアップグレードによってすべて上書き
  されてしまった場合が挙げられるでしょう。
  Debian はこの問題を、設定ファイルを記録しておいて、パッケージを
  アップグレードする際に古い設定をそのまま使いたいかどうか質問する
  という方法で解決しました。
  この機能を使うには、パッケージのプログラムが使う各設定ファイル
  (たいてい /etc にあります) のフルパス名を 1 行にひとつずつ、
  この conffiles という名前のファイルに記載します。

  <p>gentoo には設定ファイルがひとつあり、それは /etc/gentoorc と
  いう名前です。これを「conffiles」ファイルに記載します。
  もしプログラムに設定ファイルがまったく存在しない場合には、
  この「conffiles」というファイルは実のところ不要です。

  <sect id="dirs">dirs

  <p>このファイルには、我々のパッケージが必要としているが、
  通常のインストール手順 (make install) では作成されない
  ディレクトリを指定します。

  デフォルトでは、こんな風になっています:
  <p><example>
  1 usr/bin
  2 usr/sbin
  </example>

  <p>一番最初のスラッシュが含まれない事に注意してください。
  ここではこんな風に変えましょう:
  <p><example>
  1 usr/X11R6/bin
  2 usr/X11R6/man/man1
  </example>
  
  とはいえ、これらのディレクトリは既に Makefile の中の処理によって
  既に作成されているはずなので、このファイルは必要ではなく、
  今回の場合には削除してしまうことができます。

  <sect id="manpage">manpage.1.ex

  <p>*.ex で終るファイルは、どうやってパッケージにその種のサポートを
  加えるかという例です。
  これらの機能を使うには、ファイルを適宜編集して拡張子 .ex を
  取り除きます。もし使いたくなければ、そのまま削除してください。

  <p>すべてのプログラムは man ページを持つべきです。
  もし無かったら、このひな型を利用して、必要な情報を追加すれば
  自分で作成しましょう。
  <manref name="man" section="7"> の man ページには、
  man ページの作成方法についての簡潔な説明があります。
  このファイルの名前をプログラムの名前に変更し、
  また拡張子をそれが属すべきマニュアル分類に従って付けることを
  忘れないように。以下がマニュアル分類の要点をまとめたリストです。

  <p><example>
  セクション |     説明     |     メモ
     1     ユーザコマンド         実行可能なコマンドやスクリプト
     2     システムコール         カーネルの提供する機能
     3     ライブラリコール       システムライブラリに含まれる機能
     4     特別ファイル           たいていは /dev 内にあるもの
     5     ファイルの書式         例えば /etc/passwd の書式
     6     ゲーム                 またはその他のどうでもいいプログラム
     7     マクロパッケージ       man マクロのようなもの
     8     システム管理           実行するのに root 権限が必要なものなど
     9     カーネルルーチン       非標準的コールや内部仕様
  </example>
  
  <p>そんなわけで gentoo のman ページは gentoo.1, あるいは
  gentoo.1x と呼ばれることになります。1x というのは、gentoo が
  X11 用のプログラムだからです。
  元のソースには gentoo.1 という man ページが含まれていなかったので、
  筆者がサンプルと、上流開発者が提供している文書からの情報をもとに
  書きました。

  <sect id="menu">menu.ex

  <p>X Window System のユーザはたいていプログラムを起動するための
  設定可能なメニューの機能をもつウィンドウマネージャを使っています。
  もしユーザが Debian の「menu」パッケージをインストールしていれば
  システムにあるすべてのプログラム用のメニューのセットが作成され、
  menu に対応したウィンドウマネージャから利用できます。
  Debian ポリシーでは必要とまではされていない機能ですが、
  ユーザはきっと喜ぶでしょう。
  このファイルを編集することで、gentoo をメニューに
  追加することができます。
  以下が dh_make によって生成されたデフォルトです:
  
  <p><example>
  ?package(gentoo):needs=X11|text|vc|wm section=Apps/see-menu-manual\
    title="gentoo" command="/usr/bin/gentoo"
  </example>

  <p>最初のフィールドはプログラムがどういう種類のインターフェースを
  必要とするのか指定します (例えばテキスト、X11 など)。
  次はプログラムのエントリーが表示されるメニューやサブメニューの
  指定です。現在のセクション一覧は 
  /usr/share/doc/debian-policy/menu-policy.html/ch2.html#s2.1 に
  記載されています。
  第 3 のフィールドはプログラムの名称です。
  第 4 のフィールドはそのプログラムのアイコンの定義ですが、
  もしアイコンがなかったら空白のままにしておきましょう。
  第 5 のフィールドはメニューに実際に表示されるタイトルです。
  第 6 のフィールドはプログラムを実行するコマンドです。

  <p>さて、今回はこんな風に menu エントリを変えましょう。
  <p><example>
  ?package(gentoo):needs=X11 section=Apps/Misc \
    title="Gentoo" command="/usr/X11R6/bin/gentoo"
  </example>

  <p>より詳細な説明は
  <manref name="menufile" section="5">、
  <manref name="update-menus" section="1">、
  および /usr/share/doc/debian-policy/menu-policy.html/ を
  参照してください。

  <sect id="watch">watch.ex

  <p>このファイルを
  <manref name="uscan" section="1"> および
  <manref name="uupdate" section="1"> プログラム
  (これらは devscripts パッケージにあります) と合わせて
  使うことによって、オリジナルソースを入手したサイトの
  更新をチェックすることができます。
  今回は以下のようにしました。

  <p><example>
  # watch control file for uscan
  # Site		Directory	Pattern			Version	Script
  ftp.obsession.se	/gentoo		gentoo-(.*)\.tar\.gz	debian	uupdate
  </example>

  <p>ヒント:このファイルを作成したら、インターネットに接続し、ソースを
  展開したディレクトリの中から「uscan」を試しに実行してみるとよいでしょう。
  それから、マニュアルページも読んでみてください。

  <sect id="doc-base">ex.doc-base

  <p>もしあなたのパッケージが HTML やその他の形式の附属文書を
  (マニュアルページと info 形式の文書以外に) 含んでいるのなら、
  「doc-base」ファイルを使ってそれを登録し、
  ユーザがそれらの附属文書を、例えば
  <manref name="dhelp" section="1"> や
  <manref name="dwww" section="1"> などのコマンドによって
  見つけられるようにするべきです。

  <p>以下に gentoo の doc-base ファイルの例を示します。

  <p><example>
  Document: gentoo
  Title: Gentoo Manual
  Author: Emil Brink
  Abstract: This manual describes what Gentoo is, and how it can be used.
  Section: Apps/Tools

  Format: HTML
  Index: /usr/share/doc/gentoo/html/index.html
  Files: /usr/share/doc/gentoo/html/*.html
  </example>

  <p>このファイルの書式については
  <manref name="install-docs" section="8"> および
  /usr/doc/doc-base/doc-base.html/index.html にある doc-base の
  マニュアルを参照してください。

  <sect id="maintscripts">postinst.ex、preinst.ex、postrm.ex、prerm.ex

  <p>これらのファイルはメンテナスクリプトと呼ばれるもので、
  パッケージの制御パートに収録され、
  あなたのパッケージがインストール、アップグレード、あるいは
  削除されるときに dpkg によって実行されます。
  
  <p>今のところは、メンテナスクリプトを手でいじるのは、
  できるだけ避けるようにするべきでしょう。
  というのも、これらはどんどん複雑になっていってしまう傾向が
  あるからです。
  詳しくはパッケージングマニュアルの第 6 節と
  dh_make によって用意されたこれらのサンプルファイルを
  注意して読んでください。
  

  <p>これでパッケージを構築する準備が整いました。

  <chapt id="final">最終段階

  <sect id="build">パッケージの構築

  <p>プログラムのメインディレクトリに移動して
  以下のコマンドを実行してください:

  <p><example>
  dpkg-buildpackage -rfakeroot
  </example>

  <p>途中で PGP の秘密鍵を 2 回入力する必要がありますが、
  それを除けばこのプログラムにすべてお任せで大丈夫です。
  一連の作業が終わった後、上記のディレクトリ (~/debian/) には
  新しいファイルが 4 つ作成されているはずです。

  <p><list>
  <item><em>gentoo_0.9.12-1_i386.deb</em>
  <p>これは作成されたバイナリパッケージです。他のすべてのパッケージと
  同じく、dpkg や dselect を使ってインストールしたり削除したりできます。

  <item><em>gentoo_0.9.12.orig.tar.gz</em>
  <p>元のソースコードをまとめてアーカイブにしたもので、
  誰か他の人がソースからパッケージを再構築したいという場合に
  使ってもらうことができます。
  また、現在 Debian パッケージ管理システムを使っていないが、
  そのプログラムのソースを自分の手でダウンロードし、
  コンパイルしたいという場合にも役に立ちます。

  <item><em>gentoo_0.9.12-1.dsc</em>
  <p>これはソースコードの内容の概要です。このファイルは
  gentoo-0.9.12/debian/control ファイルから生成され、ソースを
  <manref name="dpkg-source" section="1"> によって展開する時に
  使われます。
  このファイルは PGP で署名されているので、本当にあなた自身が
  作成したものかどうかを利用者が検証できます。

  <item><em>gentoo_0.9.12-1.diff.gz</em>
  <p>この圧縮されたファイルにはあなたがオリジナルのソースコードに
  行なったすべての変更や追加などの情報が「unified diff」の形式で
  含まれています。これは <manref name="dpkg-source" section="1"> 
  によって生成され、また利用されます。

  <item><em>gentoo_0.9.12-1_i386.changes</em>
  <p>このファイルは現在のレビジョンのパッケージにおける変更点を
  すべて記載したもので、Debian FTP アーカイブ管理プログラムに
  よってバイナリおよびソースパッケージを FTP アーカイブに
  インストールするために利用されます。
  これは gentoo-0.9.12/debian/changelog ファイルと .dsc ファイル
  とを元にして生成されます。

  <p>パッケージの保守管理を続けていくと、プログラムの動作が
  変更されたり新機能が追加されたりすることがあります。
  あなたのパッケージをダウンロードする人は、このファイルを見れば
  何が変わったのか一目で分かります。
  長い数字の羅列は各ファイルの MD5 チェックサムで、パッケージを
  ダウンロードした人は <manref name="md5sum" section="1"> を使って
  整合性をテストすることができます。もし数字が一致しない場合には、
  ファイルが壊れているか、あるいは何者かによって改ざんされている
  と分かるわけです。
  このファイルは PGP で署名されているので、
  パッケージの利用者はこのファイルが本当にあなた自身が作成した
  ものかどうかをちゃんと判断できます。
  </list>

  <p>大規模なパッケージの場合には、debian/rules をちょっといじるたびに
  毎回最初からパッケージの再構築をやりなおしたくはないでしょう。
  テスト目的の場合、以下のようにすれば上流 (upstream) ソースの再構築を
  しないで .deb ファイルを生成できます。

  <p><example>
  fakeroot debian/rules binary
  </example>

  <p>`dh_clean -k` が確実に毎回実行されるように、「install」ルールが
  「install-stamp」という子供 (これは最近のデフォルトです) を *持たない*
  ことだけは確認してください。それから、最終的にきちんとテストが
  完了したら、ちゃんと upload できるようにするため、正しい手順に
  従ってパッケージを再構築することを忘れないようにしてください。

  <sect id="checkit">できたパッケージの誤りを調べる

  <p><manref name="lintian" section="1">をあなたの .changes ファイルに
  かけてみましょう。このプログラムはパッケージ化におけるよくある間違いを
  チェックしてくれます。実行するコマンドは:
  
  <p><example>
  lintian -i gentoo_0.9.12-1_i386.changes
  </example>
  
  <p>もちろん、ファイル名はあなたのパッケージのために生成された
  changes ファイルの名前に置き換えてください。
  もしエラー (E: で始まる行) が表示されたなら、説明 (N: の行) を
  読んで誤りを訂正し、<ref id="build"> に記述されているように
  再構築してください。
  W: で始まる行は単なる警告ですので、もし大丈夫だという確信があれば
  無視してしまっても結構です (しかし多くの場合には、
  修正すべき点が何かしら存在しているようです)。

  <p>dpkg-buildpackage によるパッケージの生成と、lintian の実行を
  すべてひとつのコマンド <manref name="debuild" section="1"> で
  行なってしまうこともできます。

  <p><manref name="mc" section="1"> などのファイルマネージャを
  使ってパッケージの中を見たり、<manref name="dpkg-deb" section="1">
  を使ってパッケージの中身を一時的な場所へ取り出したりしてみましょう。
  なにかがうまく行かなくて、妙なものが削除されないままに残されて
  しまった場合に備えて、バイナリおよびソースパッケージの両方について
  不要なファイルが余分に含まれたりしていないかどうか、
  しっかり検査してください。
  ヒント: `zgrep ^+++ ../gentoo_0.9.12-1.diff.gz` を実行すると、
  ソースファイルに対してあなたが行なった変更や追加のリストを
  得ることができ、また `dpkg-deb -c gentoo_0.9.12-1_i386.deb` を
  実行するとパッケージ中のファイルのリストを得ることができます。

<p>自分でパッケージをインストールして試してみましょう。
   例えば、<manref name="debi" section="1"> コマンドを root で
   実行してみましょう。
   自分の環境以外のマシンでも試してみて、インストール時や実行時に
   警告やエラーが発生しないか注意深く観察してみてください。
   
  <p>また、後日プログラムの新版を元にしたバージョンを構築する際には、 
  パッケージが基本的にアップグレード可能であることを検証するために、
  以下を実行してください。

  <list>
  <item>旧バージョンからアップグレードする (Debian ディストリビューションの
  旧版に納められているバージョンからのアップグレードもやってみてください)
  <item>またダウングレードする。
  <item>新パッケージとしてインストールする(前のバージョンがインストール
  されていない状態からインストール)
  <item>削除して、またインストールして、さらに完全削除してみる。
  </list>

  <sect id="upload">パッケージをアップロードする

  <p>徹底的に新パッケージをテストしたら、次にこれらのファイルを
  <manref name="dupload" section="1"> を使って master.debian.org に
  アップロードする必要があります。
  まず dupload の設定ファイル  ~/.dupload.conf を編集しましょう
  以下はこのファイルの例です。

  <example>
  package config;
  $default_host = "master";
  
  $cfg{"master"}{"method"} = "scpb";
  $cfg{"master"}{"login"} = "joy";
  $cfg{"master"}{"visibleuser"} = "jrodin";
  $cfg{"master"}{"visiblename"} = "jagor.srce.hr";
  $cfg{"master"}{"fullname"} = "Josip Rodin";
  
  $cfg{"non-us"}{"method"} = "scpb";
  $cfg{"non-us"}{"login"} = "joy";
  $cfg{"non-us"}{"visibleuser"} = "jrodin";
  $cfg{"non-us"}{"visiblename"} = "jagor.srce.hr";
  $cfg{"non-us"}{"fullname"} = "Josip Rodin";
  
  1;
  </example>

  <p>もちろん、私の個人的な設定の部分はあなたの設定に従って
  変更してください。またそれぞれのオプションが持つ意味を理解する
  ために <manref name="dupload.conf" section="5"> マニュアルページ
  を読んでください。

  <p>インターネットプロバイダに接続し、以下のコマンドを
     実行してください:
  
  <p><example>
  dupload --to master gentoo_0.9.12-1_i386.changes
  </example>

  <p>dupload は各ファイルの md5 チェックサムを計算し、
  .changes ファイルの中の情報と照合します。もし一致しない時は
  正しく upload できるように <ref id="build"> の説明に従って
  再構築するよう、警告してきます。
  
  <p>dupload は master.debian.org 上でのあなたのパスワードを
  質問し、パッケージを upload し、今回のあなたの upload に
  ついての短いアナウンスを必要に応じて
  <email/debian-devel-changes@lists.debian.org/ に流します。

  <p>もしあなたがヨーロッパに住んでいるなら、master の代わりに
  他のいくつかの upload queue を利用することが可能です。
  詳細については <manref name="dupload" section="1">、
  <manref name="dupload.conf" section="5">、
  および開発者レファレンスを参照してください。

  <sect id="update">パッケージの更新

  <p>例えば仮に、#54321 という番号のバグレポートがあなたのパッケージ
  に対してファイルされ、解決するべき問題が記述されていたとしましょう。
  パッケージの新しい Debian レビジョンを作成するには、以下を実行する
  必要があります。

  <list>
  <item>もちろん、パッケージソース中の問題を修正します。

  <item>`dch -i` を使って Debian changelog ファイルに新しいレビジョンを
  追加します。そしてそこにバグとその解決策についての簡単な説明を記載し、
  「Closes: #54321」と続けておきます。
  これによってあなたのパッケージが Debian アーカイブ中に受け入れられた時、
  アーカイブ管理ソフトウェアによってバグレポートが自動的に閉じられます。

  <item><ref id="build">、<ref id="checkit">、<ref id="upload"> の中で
  実行してきたことを再度繰り返します。今回のような場合には、オリジナル
  ソースアーカイブは変更されておらず、既に Debian アーカイブ中に
  存在しているため、upload するファイルにはこのファイルが含まれない
  という点が前回と異なる点です。
  </list>

  <p>さて、ではまた別の、もうすこし複雑な状況を考えてみましょう - 
  新しい上流のバージョン (new upstream version) がリリースされ、
  もちろんあなたはそれをパッケージ化したい、という状況です。
  この場合、以下を実行する必要があります。

  <list>
  <item>新しいソースをダウンロードして (例えば「gentoo-0.9.13.tar.gz」
  という名前で) tarball にまとめ、古いソースツリーの上のディレクトリ
  (例えば ~/debian/) にそれを置きます。

  <item>古いソースディレクトリに移動し、以下を実行:

  <example>
  uupdate -u gentoo-0.9.13.tar.gz
  </example>

  もちろん、このファイル名はあなたのプログラムのソースアーカイブ名で
  置き換えてください。<manref name="uupdate" section="1"> は tarball
  の名前を適切に変更し、以前の .diff.gz ファイルにある変更をすべて
  適用して新しい debian/changelog ファイルの内容を更新します。
  
  <item>ディレクトリを新しいパッケージソースツリーである
  「../gentoo-0.9.13」に変更し、<ref id="build">、
  <ref id="checkit">、<ref id="upload"> の中で
  実行してきたことを再度繰り返します。
  </list>

  <p>もし 「debian/watch」ファイルを <ref id="watch"> で
  説明したように設定していれば、
  <manref name="uscan" section="1">
  を実行して、改訂されたソースを探して、ダウンロードし、
  uupdate を実行、という手順を自動的に行なわせることができます。

  <sect id="helpme">相談するには

  <p>公共の場で質問する前に、まずはマニュアルを読みましょう。
  ここでいうマニュアルには、例えば /usr/share/doc/dpkg、
  /usr/share/doc/debian、/usr/share/doc/package/* といった
  ディレクトリに含まれる文書や、この文書で言及されたプログラムに
  関する man/info ページなどが含まれます。
  もしあなたがバグレポート (そう、ホンモノのバグレポートです!)
  を受け取ったら、それはあなたが
  <url name="Debian バグ追跡システム" id="http://www.debian.org/Bugs/">
  をじっくり調べて、そこにある文書を読み、バグレポートに効率よく
  対処する方法を知る時が来たということです。

  <p>Debian Mentors メーリングリスト
     <email/debian-mentors@lists.debian.org/ 
     に参加すれば、あなたの質問に答えてくれる経験豊富な Debian 開発者に
     相談することができます。このリストに参加するには、
     サブジェクト (件名) に「subscribe」という単語を書いたメールを
     <email/debian-mentors-request@lists.debian.org/ 宛に送ってください。

  <p>それでもまだ質問があるのなら、Debian Developers メーリングリスト
     <email/debian-devel@lists.debian.org/ で尋ねてみるとよいでしょう。
     このリストに参加するには、
     サブジェクト (件名) に「subscribe」という単語を書いたメールを
     <email/debian-devel-request@lists.debian.org/ 宛に送ってください。
     もしあなたが Debian 開発者だったら、どっちにしてもこのリストに
     参加するべきです。

  <p>((訳注: 日本では、Debian JP Project が主催する Debian JP 開発者
  メーリングリスト <email/debian-devel@debian.or.jp/に参加して質問して
  みても良いでしょう。
  このリストに加入するにはメール本文に
  「subscribe あなたのお名前 (ローマ字で)」を書いて
  <email/debian-devel-ctl@debian.or.jp/ に送り、あとは管理サーバの
  指示にしたがってください。
  Debian JP Project では他にもいくつかのメーリングリストを用意しています。
  詳しくは 
  <url name="メーリングリスト" id="http://www.debian.or.jp/MailingList.html">
  を参照してください。))

  <p>万事うまく行ったとしても、神様にお祈りを忘れずに。
  なんでかって？考えても見てください、ほんの数時間の内に (あるいは
  数日かかるかも知れませんが) 世界中のユーザがあなたのパッケージを
  使うようになるのです。
  そしてもしあなたがとんでもないヘマをしでかしていたら、きっと数知れぬ
  怒れる Debian ユーザからメール爆撃を食らうはめになるでしょう…
  まあ冗談ですけど :-)

  <p>楽に構えて、バグ報告に対応する準備をしましょう。
  それに、Debian ポリシーに完全に沿うようにするまでには
  まだまだやるべきことがいっぱい残っています。
  (もう一度言いますが、<em>ちゃんとした文書</em> を読んで勉強しましょう)。
  好運を祈ります!
 </book>

</debiandoc>
