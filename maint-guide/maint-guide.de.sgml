<!DOCTYPE debiandoc PUBLIC "-//DebianDoc//DTD DebianDoc//EN" [

<!-- textual data entities -->
<!-- first definition wins in SGML -->
<!ENTITY % default  SYSTEM "default.ent">  %default;

]>
<!-- CVS revision of this document "$Revision: 1.25 $"  -->
<!-- CVS revision of original english document "1.97"  -->


<debiandoc>

 <book>

  <titlepag>

   <title>Anleitung für zukünftige Debian-Maintainer</title>

   <author>Josip Rodin <email/joy-mg@debian.org/
   </author>

   <author>Übersetzer: Erik Schanze <email/mail@erikschanze.de/
   </author>

   <author>Übersetzer: Eduard Bloch <email/blade@debian.org/
   </author>

   <version>Version 1.2.3, 18. Januar 2005.</version>

   <copyright>
   <copyrightsummary>Copyright &copy; 1998-2002 Josip Rodin.</copyrightsummary>

   <p>Dieses Dokument darf gemäß der GNU General Public License
   (Version 2 oder höher) verwendet werden.
   <p>Diesem Dokument liegen die Beispiele der folgenden zwei Dokumente zugrunde:

   <p>Making a Debian Package (AKA the Debmake-Manual), copyright &copy;
   1997 Jaldhar Vyas.

   <p>The New-Maintainer's Debian Packaging Howto, copyright &copy; 1997
   Will Lowe.
   </copyright>
  </titlepag>

   <toc sect>

   <chapt id=trans>Zu dieser Übersetzung

   <sect id="Vorwort">Vorwort
   <p>Anmerkung des Übersetzers:
   Diese Übersetzung baut auf Eduard Blochs Übersetzung der
   Version 1.0.2 auf.
   Ich habe bei dieser Übersetzung versucht, mich so eng wie möglich an
   das englischsprachige Original zu halten. Dennoch musste ich an
   vielen Stellen Änderungen vornehmen, damit Zusammenhänge verständlich
   bleiben; es kann deswegen sinnvoll sein, bei Unklarheiten das
   Original oder die genannten Referenzdokumente zu lesen. Meine
   eigenen Ergänzungen und Kommentare sind mit "A.d.Ü." gekennzeichnet.
   Leider können viele englische Begriffe nicht sinnvoll übersetzt
   werden; in solchen Fällen habe ich versucht, sie so gut wie möglich
   einzudeutschen. Im Anhang finden Sie ein Glossar, das die
   Bedeutung der einzelnen Begriffe näher erläutert. Weiterhin
   übernehme ich keine Verantwortung für Fehler und dadurch verursachte
   Schäden. Verbesserungen sind jederzeit willkommen.

  <sect id="gloss">Mini-Glossar
  <p>

  <list>
  <item><em>Feature</em>: Eigenschaft, eine spezielle Funktion.
  <item><em>RTFM</em>:  "read the fucking manual" - "lies das verdammte Handbuch",
  eine Aufforderung, die zugehörige Dokumentation zu lesen.
  <item><em>Maintainer</em>: der zuständige Entwickler eines Softwarepakets. Er
  "wartet" seine Pakete, korrigiert Fehler usw.
  <item><em>Policy</em>, auch <em>"Policy-Manual"</em>: eine Sammlung der Vorschriften, an
  die sich alle Debian-Entwickler halten müssen. Siehe <ref id="needprogs">.
  <item><em>Bug</em>: Ein Software-Fehler, meist ein Programmierfehler.
  <item><em>FTBFS</em>: "Failed to build from source" - das Paket kann aus den Paket-Quellen
  nicht erstellt werden, meist sind Abhängigkeiten nicht erfüllt.
  <item><em>Bug Tracking System (BTS)</em>: Debians System zum Melden und
  Verwalten von Fehlern.
  <item><em>Bugfix</em>: Beheben eines Bugs, meist durch ein berichtigendes
  Codefragment, sog. Patch.
  <item><em>Manpage</em> oder <em>Man-Seite</em> bzw.
  <em>Manual-Seite</em>: "Bedienungsanleitung" eines Programms,
  gespeichert in einer gleichnamigen Datei (plus Erweiterung nach
  Kategorie). Siehe Handbuch, man(1) und die Verweise dort.
  <item><em>Upstream, Upstream-Autor</em>: der eigentliche Autor der
  Software, meist außerhalb der Debian-Distribution.
  </list>

  <chapt id="start">Einstieg, aber richtig!

  <p>Dieses Dokument versucht, einem typischen Debian-Benutzer und
  zukünftigen Entwickler in einer verständlichen Sprache die
  Technik der Paketerstellung für Debian beizubringen,
  begleitet von funktionierenden Beispielen.
  Ein alter Römer hat einmal gesagt:
  <em>Longum iter est per preaecepta, breve et efficax per exempla!</em>
  (Es ist ein langer Weg mit Regeln, aber ein kurzer und effizienter mit
  Beispielen!).

  <p>Eines der Dinge, die Debian zu einer hervorragenden Distribution
  machen, ist das Paket-System. Auch wenn inzwischen massenhaft
  Linux-Software im Debian-Format vorhanden ist, muss man manchmal auch
  Software installieren, die es eben nicht als ".deb"-Paket gibt. Sie fragen
  sich vermutlich, wie man eigene Pakete erstellt und vielleicht
  meinen Sie, es sei eine komplizierte Aufgabe. Nun, wenn sie ein
  blutiger Linux-Neuling sind, dann ist es wirklich hart, aber als
  Anfänger würden Sie dieses Dokument jetzt nicht lesen. :-)
  Sie sollten schon ein wenig Kenntnisse über die Unix-Programmierung
  mitbringen, aber Sie brauchen ganz sicher kein Guru zu sein.

  <p>Eines ist wohl sicher, um Debian-Pakete richtig zu bauen und zu
  warten, braucht es Zeit. Um keine Fehler zu machen und damit unser
  System läuft, muss der Maintainer technisch kompetent sein und
  fleißig und sorgfältig arbeiten.

  <p>Dieses Dokument wird jeden kleinen (möglicherweise auch irrelevanten)
  Schritt erklären, um Ihnen bei der Erstellung des ersten Pakets zu
  helfen, und Ihnen etwas Erfahrung zu geben im Erstellen neuer Releases
  dieses, oder vielleicht später anderer Pakete.

  <p>Aktuelle Versionen dieses Dokuments sollten immer über
  <url name="http://www.debian.org/doc/maint-guide/"
  id="http://www.debian.org/doc/maint-guide/">  oder in dem
  Paket <package/maint-guide-de/ zu finden sein.

  <sect id="needprogs">Benötigte Programme

  <p>Bevor Sie loslegen können, müssen Sie sicherstellen,
  dass einige zusätzliche Pakete richtig installiert sind, die
  für die Entwicklung benötigt werden. Beachten Sie, dass die
  Liste keine Pakete enthält, die als `essential' oder `required'
  markiert sind - denn man kann davon ausgehen, dass Sie diese Pakete
  schon installiert sind.

  <p>Dieses Dokument wurde überarbeitet für die Pakete in Debian
  2.2 (`potato') und 3.0 (`woody').

  <p>Die folgenden Pakete sind in der Standard-Installation von
  Debian enthalten, also werden Sie sie vermutlich schon haben (und
  zusätzliche Pakete, von denen sie abhängen). Sie können
  es dennoch überprüfen, z.B. mit `dpkg -s &lt;package&gt;`.

  <list>
    <item><package/dpkg-dev/ - dieses Paket enthält die Tools, die zum
    Entpacken, Erstellen und Hochladen der Quell-Pakete benötigt
    werden. (siehe <manref name="dpkg-source" section="1">)

    <item><package/file/ - dieses handliche Programm kann den Typ einer
    Datei feststellen. (siehe <manref name="file" section="1">)

    <item><package/gcc/ - der GNU-C-Compiler ist nötig, wenn Ihr Programm,
    wie viele andere auch, in der Programmiersprache C geschrieben wurde.
    (siehe <manref name="gcc" section="1">)
    Dieses Paket wird einige andere Pakete in Ihr System ziehen, wie
    <package/binutils/, das Programme zum Assemblieren und Linken der
    Objekt-Dateien enthält (siehe `info binutils` im Paket <package/binutils-doc/)
    und <package/cpp/, den C-Präprozessor. (siehe <manref name="cpp"
    section="1">)

    <item><package/g++/ - der GNU-C++-Compiler wird benötigt, wenn Ihr
    Programm in C++ geschrieben wurde.
    (siehe <manref name="g++" section="1">)

    <item><package/libc6-dev/ - die C-Bibliotheken und Header-Dateien, die
    gcc zum Linken und Erstellen von Objekt-Dateien benötigt.
    (siehe `info libc` im <package/glibc-doc/ Paket)

    <item><package/make/ - normalerweise wird ein Programm in mehreren
    Schritten erstellt. Statt wieder und wieder die selben Befehle zu
    tippen, können Sie das Ganze mit Hilfe dieses Programms und der
    sog. `Makefile's automatisieren. (siehe `info make`)

    <item><package/patch/ - ein sehr nützliches Programm, das eine
    sog. diff-Datei, eine Auflistung der Unterschiede im Dateiinhalt
    (produziert mit dem Programm <prgn/diff/), auf die ursprüngliche Datei
    anwendet und daraus die neue Version erzeugt.
    (siehe <manref name="patch" section="1">)

    <item><package/perl5/ - Perl ist eine der am meisten gebrauchten
    Skript-Sprachen auf heutigen Unix-ähnlichen Systemen, oft betrachtet
    als "Unix' Schweizer Offizierskettensäge".
    (siehe <manref name="perl" section="1">)
  </list>

  <p>Sie sollten vielleicht auch folgende Pakete installieren:

  <list>
    <item><package/autoconf/ und <package/automake/ - Viele neue Programme
    benutzen auch configure-Skripte und Makefile-Vorlagen mit Hilfe dieser
    Programme, also benötigen Sie diese wahrscheinlich auch.
    (siehe `info autoconf`, `info automake`)

    <item><package/dh-make/ und <package/debhelper/ - dh-make wird
    benötigt, um eine Vorlage des Beispiel-Pakets zu erstellen, und
    es benötigt einige debhelper-Tools für die Paketerstellung.
    Sie sind nicht zwingend erforderlich, aber für neue Maintainer
    <strong>sehr</strong> empfohlen. Es vereinfacht den ersten Einstieg
    sehr, ebenso die spätere Kontrolle.  (siehe <manref name="dh_make"
    section="1">, <manref name="debhelper" section="1">,
    <file>/usr/share/doc/debhelper/README</file>)

    <item><package/devscripts/ - dieses Paket enthält einige
    nützliche Skripte, die für die Maintainer oft sehr hilfreich sein
    können, aber nicht unbedingt zum Bauen der Pakete benötigt
    werden. (siehe <file>/usr/share/doc/devscripts/README.gz</file>)

    <item><package/fakeroot/ - dieses Werkzeug ermöglicht Ihnen, die
    Identität des "root"s vorzutäuschen, was für einige
    Teile des Build-Prozesses benötigt wird. (siehe <manref
    name="fakeroot" section="1">)

    <item><package/gnupg/ - ein Programm, mit dem Sie Pakete digital
    <em>signieren</em> können. Dies ist besonders wichtig, wenn Sie das
    Paket an andere Leute verteilen wollen und das werden Sie sicher, wenn
    Ihre Arbeit in die Debian-Distribution aufgenommen wird.
    (siehe <manref name="gpg" section="1">)

    <item><package/g77/ - der GNU-Fortran77-Compiler wird benötigt, wenn Ihr
    Programm in Fortran geschrieben wurde.

    <item><package/gpc/ - der GNU-Pascal-Compiler wird benötigt, wenn Ihr
    Programm in Pascal geschrieben wurde. Man sollte an dieser Stelle auch
    <package/fp-compiler/, den `Free Pascal Compiler` erwähnen, der sich
    dafür ebenfalls gut eignet.
    (siehe <manref name="gpc" section="1">, <manref name="ppc386" section="1">)

    <item><package/xutils/ - Programme, die üblicherweise
    für X11 erstellt wurden, sie dienen zur Generierung von Makefiles aus einem
    Satz von Makro-Funktionen. (siehe <manref name="imake" section="1">,
    <manref name="xmkmf" section="1">)

    <item><package/lintian/ - das ist Debians Paket-Prüfer, der Sie
    über die üblichen Fehler nach der Paketerstellung informiert
    und die gefundenen Fehler erklärt.  (siehe <manref name="lintian"
    section="1">, <file>/usr/share/doc/lintian/lintian.html/index.html</file>)

    <item><package/linda/ - das ist ein alternativer Debian-Paket-Prüfer.
    (siehe <manref name="linda" section="1">)

    <item><package/pbuilder/ - dieses Paket enthält Programme, um eine
    Chroot-Umgebung aufzubauen und zu betreuen. Beim Bauen eines Debian-Pakets in
    dieser Chroot-Umgebung wird geprüft, ob die Build-Abhängigkeiten stimmen
    und das verhindert FTBFS-Fehler.
    (siehe <manref name="pbuilder" section="8"> und
    <manref name="pdebuild" section="1">)
  </list>

  <p>Es folgen noch <em>sehr wichtige</em> Dokumentationen, die Sie neben
  diesem Dokument auch lesen sollten:

  <list>
    <item><package/debian-policy/ - die Policy beinhaltet die Beschreibung
    der Struktur und des Inhalts eines Archivs, Texte über das Systemdesign,
    den Filesystem Hierarchy Standard (der beschreibt, wo jede Datei und
    jedes Verzeichnis ein sollte) etc.
    Das Wichtigste für Sie ist, sie beschreibt die Anforderungen, die ein
    Paket erfüllen muss, um in die Distribution aufgenommen zu werden.
    (siehe &debian-policy;)

    <item><package/developers-reference/ - für alle Fragen, die nicht
    ausschließlich technischer Natur der Paketerstellung sind, z.B. über
    die Struktur des Archivs, wie man Pakete umbenennt, aufgibt,
    übernimmt, NMUs durchführt, Fehler verwaltet,
    Hinweise zum guten Paketieren, wie und wo ins Archiv hochlädt etc.
    (siehe &developers-reference;)
  </list>

  <p>Die kurzen Erklärungen oben dienen nur der
  Einführung. Bevor Sie weitermachen, sollten Sie die Dokumentation
  jedes Programms durchlesen, das Sie verwenden werden, zumindest
  den normalen Umgang. Das mag Ihnen am Anfang überflüssig vorkommen, aber
  schon bald werden Sie <em>froh</em> darüber sein, sich schon vorher
  informiert zu haben.

  <p>Anmerkung: Das Paket <package/debmake/ enthält einige Programme, die
  dh-make in der Funktionalität sehr ähneln. Die Benutzung von debmake
  wird hier <strong>nicht</strong> beschrieben, weil es nicht mehr benutzt
  werden sollte (<em>deprecated</em>). Informationen zu debmake
  finden Sie im <url name="Debmake-Manual"
  id="http://www.debian.org/~jaldhar/">.

  <sect id="otherinfo">Andere Informationen

  <p>Sie können zwei Arten von Paketen erstellen: Binär- und
  Quell-Pakete. Ein Quell-Paket enthält den Code, aus dem man ein
  Programm kompilieren kann. Ein Binär-Paket enthält das
  fertige Programm. Bringen Sie die Begriffe Quellcode und Quell-Paket
  des Programms nicht durcheinander! Lesen Sie andere Anleitungen, falls
  die Terminologie nicht klar ist.

  <p>In Debian bezeichnet der Ausdruck `Maintainer' eine Person, die
  Pakete baut, `Upstream-Autor' die Person, die das Programm erstellt
  hat und `Upstream-Maintainer' die Person außerhalb von Debian, die
  zurzeit das Programm pflegt. Üblicherweise sind `Upstream
  Autor' und `Upstream-Maintainer' die selbe Person, und manchmal ist
  es sogar der Maintainer selbst. Wenn Sie also ein Programm erstellen
  und in Debian integriert sehen möchten, dann können Sie sich
  ruhig als Maintainer bewerben.

  <p>Nachdem Sie ein eigenes Paket erstellt haben (oder während Sie
  gerade dabei sind), möchten Sie vermutlich ein offizieller
  Debian-Maintainer werden, damit Ihr Paket den Weg in die nächste
  Distribution findet (wenn das Programm wirklich nützlich ist, warum
  nicht?). Dieser Prozess ist in der "Developer's Reference"
  beschrieben; bitte lesen Sie das.

  <chapt id="first">Erste Schritte

  <sect id="choose">Ein Programm wählen

  <p>Sie haben sich wahrscheinlich schon ein Paket ausgesucht, das
  Sie bauen wollen. Zuerst sollte man am besten überprüfen, ob das Paket nicht
  bereits in der Distribution existiert. Wenn Sie eine `stable'-Distribution
  verwenden, sollten Sie am besten über <url name="Paket-Such-Seite"
  id="http://www.debian.org/distrib/packages.html"> nach dem Paket
  suchen.  [A.d.Ü.: Oder von der `unstable'-Distribution die
  Contents-Datei ziehen und nach bekannten Dateinamen durch'grep'en.]

  Benutzen Sie die <strong>aktuelle</strong> `unstable'-Distribution,
  versuchen Sie es mit diesen Kommandos:
  <example>
dpkg -s Programm
dpkg -l '*Programm*'
  </example>

  <p>Wenn es das Paket schon gibt, dann installieren Sie es! :-) Wenn
  es aufgegeben wurde, d.h. wenn als Maintainer "Debian QA Group"
  eingesetzt ist, dann können Sie es übernehmen. Schauen Sie auf der
  <url name="Liste der abgegebenen Pakete"
  id="http://www.debian.org/devel/wnpp/orphaned"> und der <url name="Liste
  der zu adoptierenden Pakete"
  id="http://www.debian.org/devel/wnpp/rfa_bypackage">
  nach, welche Pakete dafür zur Verfügung stehen.

  <p>Wenn Sie ein Paket übernehmen möchten, laden Sie sich das Quell-Paket
  herunter (z.B. mit `apt-get source <var>Paketname</var>`) und nehmen Sie
  es unter die Lupe. Leider enthält dieses Dokument keine umfassende
  Anleitung zum Übernehmen von Paketen. Der Vorteil ist, dass schon
  jemand das Paket für Sie vorbereitet hat und Sie keine Schwierigkeiten
  haben sollten, herauszufinden, wie das Paket funktioniert. Doch lesen
  Sie weiter, denn viele der folgenden Ratschläge werden auch für Sie
  nützlich sein.

  <p>Wenn das Paket neu ist und Sie es gern in Debian integrieren
  möchten, gehen Sie wie folgt vor:

  <list>
  <item>Überprüfen Sie auf der <url name="Liste der Pakete in Arbeit"
  id="http://www.de.debian.org/devel/wnpp/being_packaged">, dass
  niemand bereits an diesem Paket arbeitet. Wenn schon jemand an dem Paket
  arbeitet, nehmen Sie mit ihm Verbindung auf, wenn es nötig ist.
  Andernfalls finden Sie bestimmt ein anderes interessantes Paket, das von
  niemandem betreut wird.
  </item>

  <item>Das Programm <strong>muss</strong> eine Lizenz haben, die
  möglichst `frei' nach den Richtlinien der <url name="Debian Free
  Software Guidelines"
  id="http://www.debian.org/social_contract#guidelines">. Wenn sie
  diesen Richtlinien nicht entspricht, aber trotzdem verteilt werden
  darf, kann das Paket oft noch in die Sektionen `contrib' oder
  `non-free' aufgenommen werden. Sind Sie sich über die Lizenzfragen nicht
  sicher, schicken Sie den Lizenz-Text an
  <email/debian-legal@lists.debian.org/ und bitten um Rat.
  </item>

  <item>Das Programm sollte sicherlich <strong>nicht</strong> als
  "setuid root" laufen, oder noch besser, es sollte für die Ausführung
  überhaupt keine setuid- oder setgid-Rechte brauchen.</item>

  <item>Das Programm sollte kein Dienst sein, oder in die
  Verzeichnisse `*/sbin/' installiert werden und auch keinen
  Port als root öffnen.</item>

  <item>Das Programm sollte in einer binären ausführbaren Form erstellt
  werden, Bibliotheken sind viel schwieriger.</item>

  <item>Es sollte gut dokumentiert sein, oder/und der Quellcode sollte
  verständlich sein.</item>

  <item>Sie sollten den Autor des Programms kontaktieren und
  sicherstellen, dass er mit ihrer Aktion einverstanden ist. Es ist
  wichtig, dass man den Autor auch später über
  programmspezifische Probleme fragen kann, versuchen Sie also nicht,
  ungepflegte/aufgegebene Programme zu packen.

  <item>And last but not the least, müssen Sie wissen, wie es
  funktioniert und damit schon einige Zeit arbeiten.</item>
  </list>

  <p>Natürlich sind die aufgeführten Punkte eher Sicherheitsmaßnahmen
  und sollten Sie vor tobenden Benutzern schützen, falls ihr
  setuid-Dienst irgendetwas Schlimmes anstellt. Wenn Sie mehr
  Erfahrungen im Paket-Erstellen gesammelt haben, können Sie sich
  auch an solchen Paketen versuchen, aber selbst erfahrene Debian-Entwickler
  fragen schon mal in der debian-mentors-Mailingliste, wenn sie irgendwo
  Zweifel haben. Und die Leute dort helfen gern.

  <p>Für weitere Fragen konsultieren Sie die "Developer's Reference".

  <sect id="getit">Programm holen und ausprobieren

  <p>Als Erstes müssen Sie das Original-Paket des Programms finden und
  herunterladen. Ich nehme an, dass Sie bereits die Quellcode-Dateien von
  der Homepage des Autors bezogen haben. Quellen der freien
  Linux-Programme kommen i.d.R. im tar/gzip-Format, mit der
  Erweiterung
  .tar.gz, und enthalten üblicherweise ein Unterverzeichnis, genannt
  nach dem PROGRAMM-VERSION-Schema, das alle Quellcode-Dateien enthält.
  Kommt der Quellcode in einem anderen Archivtyp daher (z.B. wenn der
  Dateiname auf ".Z" oder ".zip" endet), entpacken Sie es mit den
  entsprechenden Tools oder fragen Sie in der debian-mentors
  Mailingliste, wie man es richtig entpackt
  (Tipp: `file archive.extension` versuchen.)

  <p>Als Beispiel dient hier das Programm namens `gentoo', ein
  X GTK+-Dateimanager. Das Programm ist bereits verpackt, und wurde
  wesentlich verändert seit dieser Text geschrieben wurde.

  <p>Erstellen Sie ein Verzeichnis in Ihrem Home-Verzeichnis, z.B.
  'debian' oder 'deb' oder irgendwas anderes, was für Sie geeignet
  erscheint, etwa <file>~/gentoo/</file> in diesem Fall. Kopieren Sie das
  heruntergeladene Archiv dorthin, und entpacken Sie es, z.B. mit
  `tar zxvf gentoo-0.9.12.tar.gz`. Vergewissern Sie sich, dass es keine
  Fehler beim Entpacken gab, nicht mal sog. `irrelevante' Fehler, weil
  es auf anderen Systemen Probleme geben kann, wenn andere Entpacker
  bestimmte Anomalien nicht ignorieren.

  <p>Jetzt haben Sie ein neues Unterverzeichnis, 'gentoo-0.9.12'.
  Wechseln Sie dorthin und lesen Sie die mitgelieferte Dokumentation
  <strong>komplett durch</strong>. Meist sind die Dateien mit Namen
  nach dem Schema `README*', `INSTALL*', `*.lsm' oder `*.html' benannt.
  Sie müssen eine Anleitung finden, wie man das Programm richtig übersetzt
  und installiert (meistens wird von einer Installation in
  <file>/usr/local/bin/</file> ausgegangen, aber das wollen Sie nicht.
  Mehr dazu später in <ref id="destdir">).

  <p>Der Prozess ist von Programm zu Programm unterschiedlich, aber
  viele moderne Programme kommen mit einem `configure'-Skript, das den
  Quellcode an die Systemumgebung anpasst. Nach dem erfolgreichen
  Konfigurieren mit `./configure` können die Programme mit `make`
  kompiliert werden. Einige unterstützen auch `make check`, das
  zusätzliche Selbsttests durchführt. Die Installation in die
  Zielverzeichnisse geschieht dann mit `make install`.

  <p>Versuchen Sie nun, das Programm zu kompilieren und stellen Sie
  sicher, dass es einwandfrei funktioniert und nichts anderes während
  der Installation oder der Ausführung kaputt macht.

  <p>Ebenfalls kann man `make clean` (oder besser `make dist-clean`)
  ausführen, um im aktuellen Arbeitsverzeichnis aufzuräumen.
  Manchmal gibt es sogar ein `make uninstall`, womit man alle
  installierten Dateien löschen kann.

  <sect id="namever">Name und Version des Pakets

  <p>Sie sollten mit einem aufgeräumten oder besser frisch
  ausgepackten Quellcode-Verzeichnis anfangen.

  <p>Damit alles richtig funktioniert, sollten Sie den ursprünglichen
  Namen in Kleinbuchstaben umwandeln. Ebenfalls sollten Sie den Namen zu
  &lt;Paketname&gt;-&lt;Version&gt; verändern.

  <p>Wenn der Programmname aus mehr als einem Wort besteht, sollten Sie
  stattdessen ein Wort oder eine Abkürzung verwenden. Zum Beispiel
  könnte man "John's little editor for X" in johnledx, oder jle4x
  umbenennen, oder wie auch immer, solange die Länge in einem vernünftigen
  Rahmen von etwa 20 Zeichen bleibt.

  <p>Überprüfen Sie auch die exakte Versionsnummer des Programms, die
  als Versionsnummer des Pakets verwendet wird. Wenn dieses Stück
  Software keine Nummerierung nach dem Schema X.Y.Z, sondern nach dem
  Datum verwendet, können Sie dieses Datum mit davor stehenden "0.0"
  verwenden ("0.0" für den Fall, das sich der `Upstream-Autor' dazu
  entschließt, eine zukünftige Version mit 1.0 zu nummerieren). In diesem
  Fall bekommt ein Abzug vom 19. Dezember 1998 eine Versionsnummer wie
  0.0.19981219.

  <p>Einige Programme haben gar keine Versionsnummerierung,
  in diesem Fall sollten Sie den `Upstream-Maintainer' kontaktieren und
  eine eindeutige Methode ausarbeiten.

  <sect id="dh_make">Die erste "Debianisierung"

  <p>Wechseln Sie in das Quell-Verzeichnis des Programms und führen Sie
  Folgendes aus:

  <p><example>
dh_make -e ihre.maintainer@adresse -f ../gentoo-0.9.12.tar.gz
  </example>

  <p>Natürlich ersetzen Sie "ihre.maintainer@adresse" durch ihre
  eigene E-Mail-Adresse für den Eintrag im `changelog' sowie anderen
  Dateien, ebenfalls verwenden Sie den Dateinamen ihres Quellcode-Archivs.
  (Weitere Details in <manref name="dh_make" section="1">).

  <p>Es werden einige Informationen angezeigt und Sie werden gefragt,
  welcher Art das Paket sein wird. Gentoo ist ein "single binary
  package" - es wird eine Binär-Datei und ein .deb-Paket erstellt,
  also wählen Sie die erste Option mit der `s'-Taste,
  überprüfen nochmal die Informationen und bestätigen mit
  &lt;enter&gt;.

  <p>Nach diesem Aufruf von <prgn>dh_make</prgn> wird eine Kopie des
  Upstream-Tarballs mit dem Namen <file>gentoo_0.9.12.orig.tar.gz</file> im
  übergeordneten Verzeichnis angelegt, um ein nicht-natives Debian-Quell-Paket
  mit der Datei <file>*.diff.gz</file> erstellen zu können.
  Beachten Sie zwei wichtige Stellen in dem Dateinamen:
  <list compact>
  <item>Paketname und Version sind durch das Zeichen "<tt>_</tt>" getrennt.
  <item>Es steht "<tt>orig.</tt>" vor "<tt>tar.gz</tt>".
  </list>

  <p>Um es noch einmal deutlich zu machen, einem beginnenden
  Maintainer wird davon abgeraten, komplizierte Pakete zu bauen, z.B.:
  <list compact>
  <item>mit mehreren Binär-Paketen (`multiple binary packages'),
  <item>Bibliotheken (`libraries'),
  <item>wenn die Quellen nicht als <tt>tar.gz.</tt> oder <tt>tar.bz2</tt>
  vorliegen oder
  <item>wenn der Quell-Tarball nicht verteilbaren Inhalt hat.
  </list>

  <p>Es ist nicht zu schwer, erfordert aber etwas mehr Wissen. Deswegen wird
  hier nicht näher darauf eingegangen.

  <p>Beachten Sie, dass <prgn/dh_make/ nur <strong>ein Mal</strong> ausgeführt
  wird und bei späteren Aufrufen nicht sauber funktioniert, wenn Sie
  es im "debianisierten" Verzeichnis ausführen. Das bedeutet
  auch, dass Sie bei späteren Updates mit neueren Programm-Versionen
  anders vorgehen müssen, mehr dazu später in <ref id="update">.

  <chapt id="modify">Quellcode modifizieren

  <p>Normalerweise installieren sich die Programme in Verzeichnissen
  unterhalb von <file>/usr/local/</file>. Da bei Debian-Paketen dieses Verzeichnis
  nicht verwendet werden darf und ausschließlich zur Verfügung des
  lokalen Administrators (oder der User) steht, müssen Sie einen Blick
  auf den Erstellungsprozess werfen, normalerweise beginnend mit dem
  Makefile. Das ist das Skript, mit dem <manref name="make" section="1">
  die Arbeit automatisiert. Weitere Details über Makefiles in <ref
  id="rules">.

  <p>Beachten Sie, dass wenn ihr Programm GNU <manref
  name="automake" section="1"> und/oder <manref name="autoconf"
  section="1"> verwendet, werden Sie die Änderungen in der Datei
  `Makefile.am' bzw. `Makefile.in' machen müssen, weil jeder Aufruf von
  automake die Datei `Makefile.in' mit Informationen aus `Makefile.am' neu
  erzeugt (und die vorhandene Datei `Makefile.in' überschreibt!),
  genau wie jeder Aufruf von ./configure mit den Daten aus `Makefile.in'
  das fertige Makefile erzeugt. Änderungen in Dateien `Makefile.am'
  erfordern einige Kenntnisse über die Funktionsweise von <prgn/automake/;
  mehr darüber finden Sie in der Hilfe `info automake`.
  Das Bearbeiten von Dateien `Makefile.in' ist dagegen fast genauso einfach
  wie das Bearbeiten von Makefiles, man muss lediglich bei der
  Verwendung der Variablen aufpassen, d.h. Strings, die mit `@'
  umgeben sind, z.B. <var>@CFLAGS@</var> oder <var>@LN_S@</var>; in diese
  werden beim Aufruf `./configure` die entsprechenden Werte eingesetzt.
  Bitte lesen Sie <file>&autotools-dev;</file>, bevor Sie weitermachen.

  <p>Wir können an dieser Stelle nicht auf <em>alle</em> Feinheiten
  eingehen, denn es würde den Rahmen dieser Anleitung sprengen, aber
  an dieser Stelle treten auch die wenigsten Probleme auf.

  <sect id="destdir">Installation in ein Unterverzeichnis

  <p>Die meisten Programme installieren sich in die vorhandene
  Verzeichnisstruktur, so dass die ausführbaren Binär-Dateien
  irgendwo in ihrem <var>$PATH</var> landen und die Dokumentation an einer
  der üblichen Positionen. Wenn Sie so vorgehen, wird das Programm aber
  in Ihr System integriert. Die Paket-Erstellungs-Tools werden es
  dadurch schwer haben, herauszufinden, welche Dateien zu Ihrem Paket
  gehören und welche nicht.

  <p>Deshalb sollten Sie anders verfahren:
  Installieren Sie das Programm in ein angelegtes Unterverzeichnis
  von dem aus die Paket-Erstellungs-Tools ein funktionierendes
  .deb-Paket erzeugen werden.
  Alles, was dieses Unterverzeichnis enthält, wird
  später auf das System der Benutzer installiert, mit dem einzigen
  Unterschied, dass dpkg den Inhalt im Stamm-Verzeichnis auspackt.

  <p>Dieses Unterverzeichnis wird üblicherweise unterhalb des Verzeichnisses
  <file>debian/</file> im ausgepackten Quellverzeichnis angelegt. Man nennt
  es <file>debian/tmp</file> oder <file>debian/paketname</file>.

  <p>Denken Sie daran, auch wenn Sie das Programm in
  <file>debian/paketname</file> installieren, muss es korrekt funktionieren
  wenn es in das root-Dateisystem übernommen wird, z.B. wenn es
  aus einem .deb-Paket installiert wird. Sie müssen dafür sorgen,
  dass beim Erstellen des Pakets keine fest einprogrammierten Werte
  in den Dateien auftreten wie
  <file>/home/me/deb/gentoo-0.9.12/usr/share/gentoo</file>.

  <p>Mit Programmen, die GNU <prgn/autoconf/ benutzen wird es ein
  leichtes Spiel sein. Die meisten dieser Programme nutzen Makefiles,
  die es standardmäßig erlauben, das Programm in irgendein
  Unterverzeichnis zu installieren, ohne zu vergessen, dass
  /usr der vorschriftsmäßige Präfix ist.
  <prgn/dh_make/ wählt die richtigen Kommandos, wenn es feststellt,
  dass Ihr Programm <prgn/autoconf/ benutzt, also
  können Sie diesen Abschnitt vermutlich überspringen. Bei
  anderen Programmen müssen Sie die entsprechenden Makefiles
  untersuchen und ggf. anpassen. (A.d.Ü.: Bei einigen Programmen
  kommt man auch um das Anpassen des Quellcodes nicht herum, wenn z.B.
  die Pfade zu best. Konfigurationsdateien fest einkompiliert werden).

  <p>Hier ist der relevante Abschnitt des Makefiles von gentoo:

  <p><example>
# Where to put binary on 'make install'?
BIN     = /usr/local/bin
# Where to put icons on 'make install'?
ICONS   = /usr/local/lib/gentoo/
  </example>

  <p>Sie sehen, die Dateien sollen unter <file>/usr/local</file>
  installiert werden, dies ändern Sie zu:

  <p><example>
# Where to put binary on 'make install'?
BIN     = $(DESTDIR)/usr/bin
# Where to put icons on 'make install'?
ICONS   = $(DESTDIR)/usr/share/gentoo
  </example>

  <p>Sie fragen sich vielleicht, warum in dieses Verzeichnis und
  nicht in irgendein anderes? Weil Debian-Pakete niemals Dateien
  unter <file>/usr/local</file> ablegen -- dieses Verzeichnis ist für den
  Systemadministrator reserviert. Debian nutzt stattdessen <file>/usr</file>.

  <p>Eine genauere Beschreibung der Installationsverzeichnisse für
  Binär-Dateien, Icons und Dokumentationen finden Sie im Filesystem
  Hierarchy Standard (siehe <file>/usr/share/doc/debian-policy/fhs/</file>).
  Schauen Sie es sich an und lesen Sie die Passagen, die Ihr Paket betreffen
  könnten.

  <p>Sie sollten also die Binär-Dateien in
  <file>/usr/bin/</file> anstatt <file>/usr/local/bin/</file>,
  die Manpages in
  <file>/usr/share/man/man1/</file> anstatt <file>/usr/local/man/man1/</file>
  installieren. Beachten Sie, dass gentoo's Makefile nicht die
  Installation einer Manpage vorsieht, doch die Debian Policy verlangt,
  dass jedes Programm eine hat. Sie schreiben später eine und installieren
  sie nach <file>/usr/share/man/man1/</file>.

  <p>Manche Programmierer nutzen leider das Makefile nicht, um die Pfade
  o.ä. variabel zu gestalten. Das bedeutet, dass Sie wahrscheinlich die
  C-Quelltexte direkt bearbeiten müssen.
  (A.d.Ü.: Warum?
  Ganz einfach, weil dieser Pfad beim Kompilieren nirgendwo verwendet wird,
  müssen Sie davon ausgehen, dass der Autor die Pfadangaben direkt
  einkodiert hat).
  Aber wie und wo soll man suchen? Man kann z.B. mit
  <p><example>
grep -rn usr/local/lib *.[ch]
  </example>
  das Quellen-Verzeichnis rekursiv durch'grep'en, das Dateien *.c und *.h enthält.
  Grep wird die Stellen aufzeigen, an den der Pfadname verwendet wurde.
  (A.d.Ü.: Meine Idee wäre eher:
  <example>
find -regex ".*\.h$\|.*\.c$"|xargs grep -n usr/local/lib | less
  </example>
  oder ähnliches). Nun müssen Sie die entsprechenden Dateien
  bearbeiten und "/usr/local/" durch "/usr/" ersetzen und dabei
  aufpassen, dass Sie den restlichen Code nicht beschädigen. :-)

  <p>Wenn alles erledigt ist, sollten Sie das Install-Target im Makefile
  lokalisieren (Es sollte normalerweise helfen, wenn Sie nach
  der Zeile, die mit `install:' beginnt, suchen.)
  und die Verweise auf die Verzeichnisse gegen die Variablen
  austauschen, die Sie am Anfang definiert haben. Vorher hat das
  Install-Target so ausgesehen:

  <p><example>
install:   gentoo
           install ./gentoo $(BIN)
           install icons/* $(ICONS)
           install gentoorc-example $(HOME)/.gentoorc
  </example>

  <p>Nach unseren Änderungen sieht es so aus:
  <example>
install:    gentoo-target
            install -d $(BIN) $(ICONS) $(DESTDIR)/etc
            install ./gentoo $(BIN)
            install -m644 icons/* $(ICONS)
            install -m644 gentoorc-example $(DESTDIR)/etc/gentoorc
  </example>

  <p>Sie haben sicherlich bemerkt, dass es jetzt ein Kommando
  <tt>install -d</tt> vor allen anderen in der Rule gibt. Das
  Original-Programm hatte das nicht, weil normalerweise die
  ursprünglichen Verzeichnisse <file>/usr/local/bin/</file> u.a. schon auf
  dem System existieren, wenn `make install` aufgerufen wird. Weil Sie
  aber in Ihr eigenes, leeres (oder sogar nicht vorhandenes) Verzeichnis
  installieren, müssen Sie jedes Verzeichnis vorher anlegen.

  <p>Sie können noch Weiteres am Ende der Rule anfügen, wie z.B. die
  Installation einer Dokumentation, die der Upstream-Autor manchmal
  weglässt.

  <p><example>
           install -d $(DESTDIR)/usr/share/doc/gentoo/html
           cp -a docs/* $(DESTDIR)/usr/share/doc/gentoo/html
  </example>

  <p>Einem aufmerksamen Leser wird auffallen, dass gentoo zu
  gentoo-target geändert wurde. Das nennt man auch unverlangten Bugfix. ;-)

  <p>Wo auch immer Sie Änderungen machen, die nicht ausschließlich
  auf Debian bezogen sind, sollten Sie diese dem Upstream-Maintainer
  zukommen lassen, damit er diese in zukünftigen Programm-Versionen
  verwenden kann und sie für alle Anderen nützlich sein können.
  Und versuchen Sie, dem Upstream entgegen zu kommen, indem Sie keine
  Debian- oder Linux- (oder eben Unix-) spezifischen Patches senden,
  sondern gestalten Sie diese portabel.
  Dadurch kann er Ihre Bugfixes besser übernehmen.

  <p>Beachten Sie außerdem, dass Sie dem Upstream nicht das ganze
  Verzeichnis <file>debian/</file> schicken müssen.

  <p>(A.d.Ü.: Speziell hier könnte man dem Upstream mit
  wenigen C-Kenntnissen helfen, indem man die Pfade variabel macht.
  D.h. man verändert im Makefile die gcc-Parameter so, dass die
  Variable <var>ICONS</var> an den C-Präprozessor übergeben wird. In
  dem Programm verwendet man dann <var>ICONS</var> statt den festgelegten
  Pfaden.)

  <sect id="difflibs">Unterschiedliche Programmbibliotheken

  <p>Das ist ein alltägliches Problem: Bibliotheken sind von
  Plattform zu Plattform verschieden. Z.B. kann ein Makefile einen Verweis
  auf eine Bibliothek enthalten, die es für Debian nicht
  gibt. In diesem Fall müssen Sie das Makefile so verändern, dass
  eine Bibliothek verwendet wird, die es
  in Debian gibt und den selben Zweck erfüllt.

  <p>Wenn also im Makefile (bzw. in Makefile.in) eine Zeile wie die
  folgende vorkommt, und Ihr Programm sich nicht kompiliert lässt:

  <p><example>
LIBS = -lcurses -lsomething -lsomethingelse
  </example>

  <p>ändern Sie sie zum Folgenden und es könnte funktionieren:
  <p><example>
LIBS = -lncurses -lsomething -lsomethingelse
  </example>

  <p>Der Autor ist sich bewusst, dass dies nicht das beste Beispiel ist, weil
  das Paket <package/libncurses/ einen Symlink <file>libcurses.so</file>
  mitbringt, aber er konnte sich kein besseres ausdenken. Vorschläge sind sehr
  erwünscht :-)

  <chapt id="dreq">Benötigte Dinge in debian/

  <p>Es gibt nun ein neues Unterverzeichnis 'debian' im
  Hauptverzeichnis des Quellcode-Pakets, in dem
  bereits einige Dateien liegen. Wir werden diese ändern, um die
  Eigenschaften des Pakets anzupassen. Die wichtigsten Dateien sind `control',
  `changelog', `copyright' und 'rules', die für die Erstellung
  jedes Pakets benötigt werden.

  <sect id="control">Die Datei `control'

  <p>Diese Datei enthält verschiedene Werte, die <prgn/dpkg/,
  <prgn/dselect/ und andere Paketverwaltungs-Tools
  für die Paketverwaltung benötigen.

  <p>Das ist die Datei `control', die <prgn/dh_make/ für uns erstellt hat:

  <p><example>
1  Source: gentoo
2  Section: unknown
3  Priority: optional
4  Maintainer: Josip Rodin &lt;joy-mg@debian.org&gt;
5  Build-Depends: debhelper (>> 3.0.0)
6  Standards-Version: 3.5.2
7
8  Package: gentoo
9  Architecture: any
10 Depends: ${shlibs:Depends}
11 Description: &lt;insert up to 60 chars description&gt;
12  &lt;insert long description, indented with spaces&gt;
  </example>
  (Zeilennummerierung habe ich für dieses Beispiel hinzugefügt.)

  <p>Zeilen 1-6 sind Steuer-Informationen für das Quellcode-Paket.

  <p>Zeile 1 ist die Bezeichnung des Quellcode-Pakets.

  <p>Zeile 2 bestimmt die Sektion der Distribution, in die das
  Quellcode-Paket gehört.

  <p>Sie haben bestimmt schon gemerkt, dass Debian in
  Sektionen aufgeteilt ist: main (die freie Software), non-free (nicht
  wirklich freie Software) und contrib (freie Software, die von
  non-free-Sachen abhängt). Unterhalb dieser Sektionen existieren
  logische Untersektionen, die eine minimale Beschreibung des Pakets
  geben. D.h. die Sektion `admin' enthält Programme für
  Administration, `base' die grundlegenden Pakete, `devel' die
  Pakete für die Programmierer, `doc' die Dokumentation, `libs' die
  Programmbibliotheken, `mail' die E-Mail-Leseprogramme und -Dienste, `net'
  die Netzwerk-Anwendungen und Dienste, die `x11'-Sektion die
  X11-Programme, die nirgendwo anders unterkommen, usw.

  <p>Verändern Sie Sektion also zu x11. (Der Präfix "main/"
  wird angenommen, wenn Sie nichts angeben, also lassen Sie
  ihn weg.)

  <p>Zeile 3 beschreibt, wie wichtig es für den
  durchschnittlichen Benutzer wäre, das Paket zu installieren.
  Lesen Sie das "Policy-Manual" als Anleitung, was Sie in das
  Feld schreiben. Die Priorität "optional" passt eigentlich bei
  allen neuen Paketen.

  <p>Sektion und Priorität werden zurzeit nur von Programmen wie
  <prgn/dselect/ benutzt, um Pakete zu sortieren und Standardparameter
  auszuwählen.
  Wenn Sie das Paket zu Debian hochladen, können (und werden es
  wahrscheinlich auch) die FTP-Maintainer diesen Wert überschreiben.
  Sie erhalten dann eine Nachricht darüber per E-Mail.

  <p>Da es sich um ein normales Paket handelt und nichts anderes
  stört, lassen Sie es bei optional.

  <p>Zeile 4 ist der Name und die E-Mail-Adresse des Maintainers.
  Beachten Sie, dass dieses Feld einen gültigen "To:"-Header Eintrag
  für eine E-Mail enthält, weil nach einem Hochladen zu Debian das
  Bug Tracking System diesen Eintrag nutzt, um die Bug-E-Mails an
  Sie zu zustellen. Benutzen Sie keine Kommas, UND-Zeichen und Klammern.

  <p>Zeile 5 enthält eine Liste der Pakete, die zum Bauen des Pakets
  benötigt werden. Einige Pakete wie <package/gcc/ und <package/make/ brauchen
  nicht aufgeführt werden, siehe <package/build-essential/ Paket für Details.
  Falls ein unüblicher Compiler oder andere Tools zum Bauen des Pakets
  benötigt werden, dann sollten Sie diese Pakete zu der Zeile
  `Build-Depends' hinzufügen. Mehrere Einträge werden durch Komma
  getrennt; mehr über die Syntax dieses Feldes finden Sie in den
  Erläuterungen der `binary dependencies'.

  <p>An dieser Stelle können weitere Felder wie `Build-Depends-Indep',
  `Build-Conflicts' u.a. auftreten. Diese werden von der automatischen
  Paket-Erstellungs-Software in Debian genutzt, um Binär-Pakete für
  andere Plattformen zu bauen. Lesen Sie im Policy-Manual über
  Abhängigkeiten beim Paketbauen (build-dependencies) und in der
  Entwickler-Referenz über andere Plattformen bzw. wie man Software
  dahin portiert.

  <p>Mit diesem Beispiel können Sie herausfinden, welche anderen Pakete
  Ihr Paket zum Bauen braucht:
  <example>
strace -f -o /tmp/log ./configure
# or make instead of ./configure, if the package doesn't use autoconf
for x in `dpkg -S $(grep open /tmp/log|\
                    perl -pe 's!.* open\(\"([^\"]*).*!$1!' |\
                    grep "^/"| sort | uniq|\
                    grep -v "^\(/tmp\|/dev\|/proc\)" ) 2>/dev/null|\
                    cut -f1 -d":"| sort | uniq`; \
  do \
    echo -n "$x (>=" `dpkg -s $x|grep ^Version|cut -f2 -d":"` "), "; \
  done
  </example>

  <p>Um die genauen Build-Abhängigkeiten für
  <prgn><var>/usr/bin/foo</var></prgn> herauszufinden, führen Sie
  <example>
objdump -p <var>/usr/bin/foo</var> | grep NEEDED
  </example>
  und für jede aufgelistete Bibliothek, z.B. <prgn>libfoo.so.6</prgn>
  <example>
dpkg -S libfoo.so.6
  </example>
  aus.
  Dann nehmen Sie die Entwickler-Versionen (*-dev) jedes Pakets als einen
  `Build-deps'-Eintrag. Wenn Sie dafür <prgn>ldd</prgn> benutzen, werden
  auch indirekt abhängende Bibliotheken aufgelistet und überflüssige
  Build-Abhängigkeiten geliefert.

  <p>Gentoo benötigt noch <package/xlibs-dev/, <package/libgtk1.2-dev/
  und <package/libglib1.2-dev/ um gebaut werden zu können, deshalb
  hängen Sie diese an "debhelper" an.

  <p>Zeile 6 enthält die Version des Debian-Policy-Standards, dem
  dieses Paket entspricht, also die Version, die Sie gelesen haben,
  während Sie das Paket erstellten.

  <p>Zeile 8 enthält die Bezeichnung des Binär-Pakets. Üblicherweise
  ist sie gleich dem Namen des Quell-Pakets, aber das muss nicht immer
  so sein.

  <p>Zeile 9 beschreibt die CPU-Architektur für die das
  Binär-Paket kompiliert wird. Wir können das bei "any"
  belassen, weil es dann von  <manref name="dpkg-gencontrol"
  section="1"> mit dem richtigen Inhalt ersetzt wird, der für den
  Rechner gilt, auf dem das Paket gebaut wird.

  <p>Wenn ihr Paket unabhängig von der Architektur funktioniert (z.B.
  ein Shell- oder Perl-Skript, oder Dokumentation), ändern Sie dies
  zu "all", und lesen Sie später unter <ref id="rules"> über
  die Benutzung der Rule `binary-indep' statt `binary-arch'.

  <p>Zeile 10 zeigt eine der mächtigsten Eigenschaften des
  Paketsystems von Debian. Über spezielle Attribute kann das Verhalten
  des Paketmanagers in Bezug auf andere Pakete verändert werden. Neben
  Depends: (Abhängigkeit) gibt es noch weitere Attribute:
  Recommends: (Empfehlung), Suggests: (Vorschlag), Pre-Depends:
  (Voraussetzung), Conflicts: (Konflikt), Provides: (Enthält) und
  Replaces: (Ersetzt).

  <p>Die verschiedenen Paketverwaltungs-Programme verhalten sich
  sehr ähnlich bei der Behandlung dieser Beziehungen
  (Abweichungen werden weiter unten erklärt).  (siehe <manref name="dpkg"
  section="8">, <manref name="dselect" section="8">, <manref name="apt"
  section="8">, <manref name="aptitude" section="1">, usw.)

  <p>Und das bedeuten die Abhängigkeiten:

  <p><list>
  <item>Depends:
  <p>Das Paket wird erst installiert, wenn die hier aufgelisteten Pakete
  ebenfalls installiert sind. Benutzen Sie dies, wenn ihr Programm ohne
  diese Pakete überhaupt nicht (oder nicht vernünftig) laufen kann.</item>

  <item>Recommends:
  <p>Frontends wie <prgn/dselect/ und <prgn/aptitude/ fordern Sie auf, empfohlene Pakete
  zusammen mit Ihrem Paket zu installieren; <prgn/dselect/ besteht sogar darauf;
  <prgn/dpkg/ und <prgn/apt-get/ werden dieses Feld jedoch ignorieren. Benutzen Sie dieses Feld, wenn die Pakete
  nicht zwingend erforderlich sind, aber normalerweise mitinstalliert
  werden.</item>

  <item>Suggests:
  <p>Wenn der Benutzer ihr Programm installiert, werden alle Frontends Sie
  auffordern, die vorgeschlagenen Pakete zu installieren. <prgn/dpkg/ und <prgn/apt-get/
  kümmern sich nicht darum. Benutzen Sie dies für Pakete, die mit
  ihrem Programm gut zusammenarbeiten, aber eigentlich nicht benötigt
  werden.</item>

  <item>Pre-Depends:
  <p>Dies "wirkt" stärker als Depends:. Das Paket wird nicht
  installiert, bevor die hier aufgelisteten Pakete fertig installiert
  <em>und richtig konfiguriert</em> sind. Benutzen Sie dies <strong>sehr</strong> sparsam
  und erst, wenn auf der debian-devel-Mailingliste darüber diskutiert
  wurde. Lies: Verwenden Sie es überhaupt nicht. :-)</item>

  <item>Conflicts:
  <p>Das Paket wird nicht installiert, bevor alle aufgelisteten Pakete
  deinstalliert sind. Benutzen Sie dies, wenn ihr Programm überhaupt
  nicht oder nicht vernünftig laufen kann, solange eines dieser Pakete
  installiert ist.</item>

  <item>Provides:
  <p>Für einige Paketarten mit mehreren Alternativen wurden sog.
  "virtual names" eingeführt. Die vollständige Liste dieser virtuellen
  Pakete finden Sie in der Datei
  <file>/usr/share/doc/debian-policy/virtual-package-names-list.txt.gz</file>.
  Benutzen Sie dies, wenn Ihr Paket die Funktionalität eines
  existierenden virtuellen Pakets bietet.
  </item>

  <item>Replaces:
  <p>Benutzen Sie dies, wenn Ihr Paket die Dateien eines anderen Pakets
  überschreibt oder dieses Paket vollständig ersetzt (benutzt zusammen
  mit Conflicts:). Die Dateien des genannten Pakets werden mit den
  Dateien aus Ihrem Paket überschrieben.

  </item>
  </list>

  <p>All diese Felder haben eine einheitliche Syntax. Dies ist eine
  Liste der Paketnamen, getrennt durch Kommas. Ein Paketname kann auch
  aus einer Liste der alternativen Paketnamen bestehen, die durch
  senkrechte Striche <tt>|</tt> ("pipe"-Zeichen) getrennt werden.

  <p>Die Angabe des Pakets kann auch auf ganz bestimmte Paketversionen
  beschränkt werden. Diese Versionen werden in Klammern nach jedem
  einzelnen Paketnamen aufgeführt und werden durch spezielle Symbole
  festgelegt, gefolgt von einer Versionsnummer. Folgende Symbole sind
  erlaubt: <tt>&lt;&lt;</tt>, <tt>&lt;=</tt>, <tt>=</tt>, <tt>&gt;=</tt>
  und <tt>&gt;&gt;</tt> für niedriger, niedriger oder gleich, gleich,
  höher oder gleich und höher. Zum Beispiel:

  <p><example>
Depends: foo (&gt;= 1.2), libbar1 (= 1.3.4)
Conflicts: baz
Recommends: libbaz4 (&gt;&gt; 4.0.7)
Suggests: quux
Replaces: quux (&lt;&lt; 5), quux-foo (&lt;= 7.6)
  </example>

  <p>Das letzte Feature, das erwähnt werden sollte, ist die Variable
  <var>${shlibs:Depends}</var>. Nachdem Ihr Paket gebaut und in das
  Unterverzeichnis (A.d.Ü.: debian/tmp) installiert wurde, wird es von
  <manref name="dh_shlibdeps" section="1"> nach Binär-Dateien und Bibliotheken
  durchsucht, um Abhängigkeiten zu `shared libraries' festzustellen und
  herauszufinden, in welchen Paketen diese stecken, wie z.B. libc6 oder
  xlib6g. Die Liste wird an <manref name="dh_gencontrol" section="1">
  weiter gegeben um sie an die richtige Stelle zu setzen. Darum brauchen
  Sie sich nicht zu kümmern.

  <p>Wie schon gesagt, Sie lassen die Depends: Zeile wie sie ist und
  fügen darunter eine neue Zeile <tt>Suggests: file</tt>, weil gentoo
  für einige Funktionen dieses Programm/Paket braucht.

  <p>Zeile 11 enthält eine Kurzbeschreibung. Bei den meisten Leuten sind
  die Terminalzeilen 80 Zeichen breit, also sollte die Kurzbeschreibung
  nicht länger als 60 Zeichen sein. Sie ändern es in "fully GUI
  configurable X file manager using GTK+".

  <p>In die Zeile 12 kommt eine ausführliche Beschreibung des Pakets.
  Sie sollte aus einem kleinen Text bestehen, der mehr über das Paket
  verrät. Die erste Spalte der Zeilen sollte immer leer sein. Es dürfen
  keine leeren Zeilen vorkommen, Sie können aber welche simulieren, indem
  Sie einen einzelnen . (Punkt) in die Zeile einsetzen. Es darf nach der
  ausführlichen Beschreibung auch nicht mehr als eine Leerzeile
  vorkommen.

  <p>Und so sieht die angepasste Datei `control' aus:

  <p><example>
1  Source: gentoo
2  Section: x11
3  Priority: optional
4  Maintainer: Josip Rodin &lt;joy-mg@debian.org&gt;
5  Build-Depends: debhelper(>> 3.0.0),xlibs-dev,libgtk1.2-dev,libglib1.2-dev
6  Standards-Version: 3.6.1
7
8  Package: gentoo
9  Architecture: any
10 Depends: ${shlibs:Depends}
11 Suggests: file
12 Description: fully GUI configurable X file manager using GTK+
13  gentoo is a file manager for Linux written from scratch in pure C. It
14  uses the GTK+ toolkit for all of its interface needs. gentoo provides
15  100% GUI configurability; no need to edit config files by hand and re-
16  start the program. gentoo supports identifying the type of various
17  files (using extension, regular expressions, or the 'file' command),
18  and can display files of different types with different colors and icons.
19  .
20  gentoo borrows some of its look and feel from the classic Amiga file
21  manager "Directory OPUS" (written by Jonathan Potter).
  </example>
  (Die Zeilennummerierung habe ich für dieses Beispiel hinzugefügt.)

  <sect id="copyright">Die Datei `copyright'

  <p>In dieser Datei stehen Informationen über die Herkunft des Pakets
  (bzw. der Quellen), über die Lizenz und das Urheberrecht (Copyright).
  Die Policy schreibt keine bestimmte Form vor, aber den benötigten
  Inhalt (siehe Abschnitt 13.6 "Copyright information").

  <p><prgn/dh_make/ erstellt uns eine Standardvorlage, die etwa so aussieht:

  <p><example>
1  This package was debianized by Josip Rodin &lt;joy-mg@debian.org&gt; on
2  Wed, 11 Nov 1998 21:02:14 +0100.
3
4  It was downloaded from &lt;fill in ftp site&gt;
5
6  Upstream Author(s): &lt;put author(s) name and email here&gt;
7
8  Copyright:
9
10 &lt;Must follow here&gt;
  </example>
   (Die Zeilennummerierung habe ich für dieses Beispiel hinzugefügt.)

  <p>Die wichtigsten Dinge, die Sie hier einzutragen haben, sind die
  Quelle, von der Sie das Paket bezogen haben, die geltenden
  Copyright-Vermerke und die Lizenz. Sie müssen die komplette Lizenz
  einfügen, sofern es sich nicht um eine der gängigen freien
  Softwarelizenzen handelt, z.B. die GNU GPL oder LGPL, die BSD- oder
  die Artistic-License; in diesem Fall reicht ein Verweis auf die
  entsprechende Datei im Verzeichnis <file>/usr/share/common-licenses/</file>,
  das auf jedem Debian-System existieren sollte.

  <p>Gentoo's Datei `copyright' sollte also so aussehen:

  <p><example>
1  This package was debianized by Josip Rodin &lt;joy-mg@debian.org&gt; on
2  Wed, 11 Nov 1998 21:02:14 +0100.
3
4  It was downloaded from: ftp://ftp.obsession.se/gentoo/
5
6  Upstream author: Emil Brink &lt;emil@obsession.se&gt;
7
8  This software is copyright (c) 1998-99 by Emil Brink, Obsession
9  Development.
10
11 You are free to distribute this software under the terms of
12 the GNU General Public License.
13 On Debian systems, the complete text of the GNU General Public
14 License can be found in the file `/usr/share/common-licenses/GPL'.
  </example>
   (Die Zeilennummerierung habe ich für dieses Beispiel hinzugefügt.)

  <sect id="changelog">Die Datei `changelog'

  <p>Dies ist eine zwingend vorgeschriebene Datei, deren Format in
  der Policy Sektion 4.4 "debian/changelog" beschrieben wird. Dieses Format
  benötigen <prgn/dpkg/ und andere Programme um Dinge wie Versionsnummer,
  Revision, Distribution und die Wichtigkeit ihres Pakets zu bestimmen.

  <p>Für Sie ist die Datei ebenfalls wichtig, weil man hier die gemachten
  Änderungen dokumentieren kann. Damit können Leute, die Ihr Paket
  herunterladen, einfacher herausfinden, ob es Probleme
  mit dem Paket gibt, die sie kennen sollten. Diese Datei wird im
  Binär-Paket als <file>/usr/share/doc/gentoo/changelog.Debian.gz</file>
  gespeichert.

  <p><prgn/dh_make/ erstellt eine Standardvorlage, die etwa so aussieht:

  <p><example>
1  gentoo (0.9.12-1) unstable; urgency=low
2
3   * Initial Release.
4
5  -- Josip Rodin &lt;joy-mg@debian.org&gt; Wed, 11 Nov 1998 21:02:14 +0100
6
  </example>
  (Die Zeilennummerierung habe ich für dieses Beispiel hinzugefügt.)

  <p>In der Zeile 1 stehen der Paketname, die Version, die Distribution
  und die Wichtigkeit.  Der Name muss mit dem Namen des
  Quell-Pakets übereinstimmen, Distribution sollte vorerst `unstable' (oder
  sogar `experimental') sein und die Priorität nicht höher als `low'. :-)

  <p>Zeilen 3-5 sind Log-Einträge, in den Sie die in dieser Revision
  gemachten Änderungen dokumentieren können. (Hierher kommt nichts über
  die Änderungen des Upstream-Maintainers, für diese Zwecke gibt es eine
  separate Datei, die Sie später als
  <file>/usr/share/doc/gentoo/changelog.gz</file>
  speichern werden.) Neue Zeilen werden direkt über die oberste Zeile,
  die mit einem Stern (`*') beginnt, eingefügt. Sie können das mit
  <manref name="dch" section="1">, oder per Hand mit einem Texteditor
  erledigen.

  <p>Schließlich kommen Sie zu einer Datei wie dieser hier:

  <p><example>
1  gentoo (0.9.12-1) unstable; urgency=low
2
3   * Initial Release.
4   * This is my first Debian package.
5   * Adjusted the Makefile to fix $DESTDIR problems.
6
7  -- Josip Rodin &lt;joy-mg@debian.org&gt; Wed, 11 Nov 1998 21:02:14 +0100
8
  </example>
    (Die Zeilennummerierung habe ich für dieses Beispiel hinzugefügt.)

  <p>Mehr über Änderungen in der Datei `changelog' können Sie später in
  <ref id="update"> lesen.

  <sect id="rules">Die Datei `rules'

  <p>Nun müssen Sie einen Blick auf die eigentlichen Befehlssequenzen,
  sog. Rules, werfen, mit denen <manref name="dpkg-buildpackage"
  section="1"> das Paket schließlich erstellt. Die Datei `rules' ist
  im Prinzip ein weiteres Makefile, unterscheidet sich aber von denen
  des Upstream-Autors. Im Gegensatz zu anderen Dateien in debian/ ist
  diese Datei ausführbar.

  <p>Wie jedes andere Makefile besteht die Datei `rules' aus mehreren
  Rules, die bestimmen, wie mit dem Quellcode verfahren wird. Jede Rule
  besteht wiederum aus weiteren Targets, Dateinamen oder Namen der
  Aktionen, die durchgeführt werden (z.B. `build:' oder `install:').
  Rules, die Sie ausführen möchten, werden beim Aufruf als
  Programmparameter angegeben (z.B., `./debian/rules build` oder `make
  -f rules install`). Nach dem Targetnamen  (A.d.Ü.: nach der
  Bezeichnung unserer Rule) können Sie Programme oder Dateinamen
  angeben, von der die Ausführung der Rule abhängt. Danach folgt eine
  beliebige Anzahl von Kommandos, eingerückt mit
  &lt;tab&gt;. Eine neue Rule beginnt mit der Deklaration eines Targets
  in der ersten Spalte. Leerzeilen und mit einem `#'
  (hash) beginnende Zeilen werden als Kommentare betrachtet und
  ignoriert.

  <p>Sie sind vielleicht etwas verwirrt, aber es wird alles verständlich
  nach der genaueren Betrachtung der Datei `rules', die uns <prgn/dh_make/
  erstellt hat. Sie sollten evtl. die Info-Seiten von <prgn/make/ lesen, um
  mehr über die Funktionsweise zu erfahren.

  <p>Wichtig zu wissen ist noch, dass <prgn/dh_make/ nur ein Muster der
  Datei `rules' erzeugt, also einen Vorschlag, wie sie ungefähr
  auszusehen hat. Diese Datei wird für einfache Pakete wahrscheinlich
  funktionieren, aber bei komplizierteren sollten Sie die Datei nach
  Bedarf anpassen und erweitern. Sie dürfen nur die Namen der Rules
  nicht ändern, weil diese in der Policy vorgeschrieben sind und
  von allen Programmen (für die Paketerstellung) so erwartet werden.

  <p><example>
1  #!/usr/bin/make -f
2  # Sample debian/rules that uses debhelper.
3  # GNU copyright 1997 to 1999 by Joey Hess.
4
5  # Uncomment this to turn on verbose mode.
6  #export DH_VERBOSE=1
7
8  # This is the debhelper compatibility version to use.
9  export DH_COMPAT=4
10
11 CFLAGS = -g
12 ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
13 CFLAGS += -O0
14 else
15 CFLAGS += -O2
16 endif
17
18 build: build-stamp
19 build-stamp:
20        dh_testdir
21
22        # Add here commands to compile the package.
23        $(MAKE)
24        #docbook-to-man debian/gentoo.sgml > gentoo.1
25
26        touch build-stamp
27
28 clean:
29        dh_testdir
30        dh_testroot
31        rm -f build-stamp
32
33        # Add here commands to clean up after the build process.
34        -$(MAKE) clean
35
36        dh_clean
37
38 install: build
39        dh_testdir
40        dh_testroot
41        dh_clean -k
42        dh_installdirs
43
44        # Add here commands to install the package into debian/gentoo.
45        $(MAKE) install DESTDIR=$(CURDIR)/debian/gentoo
46
47 # Build architecture-independent files here.
48 binary-indep: build install
49 # We have nothing to do by default.
50
51 # Build architecture-dependent files here.
52 binary-arch: build install
53        dh_testdir
54        dh_testroot
55 #      dh_installdebconf
56        dh_installdocs
57        dh_installexamples
58        dh_installmenu
59 #      dh_installlogrotate
60 #      dh_installemacsen
61 #      dh_installpam
62 #      dh_installmime
63 #      dh_installinit
64        dh_installcron
65        dh_installman
66        dh_installinfo
67 #      dh_undocumented
68        dh_installchangelogs ChangeLog
69        dh_link
70        dh_strip
71        dh_compress
72        dh_fixperms
73 #      dh_makeshlibs
74        dh_installdeb
75 #      dh_perl
76        dh_shlibdeps
77        dh_gencontrol
78        dh_md5sums
79        dh_builddeb
80
81 binary: binary-indep binary-arch
82 .PHONY: build clean binary-indep binary-arch binary install
  </example>
  (Zeilennummerierung habe ich für dieses Beispiel hinzugefügt. In der
  richtigen Datei <file>debian/rules</file> sind die führenden Leerzeichen
  ein TAB.)

  <p>Die Funktion der ersten Zeile kennen Sie vielleicht von Perl-
  oder Shell-Skripten. Sie teilt dem Betriebssystem mit, dass das Skript
  mit <file>/usr/bin/make</file> interpretiert wird.

  <p>Die Zeilen 6 bis 9 enthalten Variablen <var>DH_*</var>, deren Bedeutung
  durch die Kurzbeschreibung klar werden sollte. Mehr Informationen über
  <var>DH_COMPAT</var> finden Sie in dem Kapitel "Debhelper compatibility
  levels" in der Manpage <manref name="debhelper" section="1">.

  <p>Die Zeilen 11 bis 16 beinhalten ein Grundgerüst für die Auswertung
  der Parameter in <var>DEB_BUILD_OPTIONS</var>, die in der Policy, Kapitel
  11.1 "Binaries" beschrieben sind. Im Grunde steuern Sie hier, ob die
  Binär-Dateien mit Debugging-Informationen gebaut werden und ob diese
  während der Installation wieder entfernt werden sollen. Nochmal, es ist
  ein Grundgerüst, ein  Hinweis, dass Sie so vorgehen können. Sie müssen
  herausfinden, wie das Einfügen und Entfernen von Debugging-Informationen
  im Upstream-Quellcode gehandhabt wird und es selbst einbauen.

  <p>Normalerweise sollten Sie die Variable <var>CFLAGS</var> benutzen,
  um <prgn/gcc/ mit der Option "-g" aufzurufen. Wenn Sie das tun, dann sollten
  Sie die Variable mittels <tt>CFLAGS="$(CFLAGS)"</tt> an den Aufruf
  <var>$(MAKE)</var>
  in der Rule `build' <em>anhängen</em> (siehe unten). Wenn Ihr Paket aber
  ein autoconf-Skript verwendet, können Sie die Variable an `configure'
  übergeben, indem Sie die o. g. Zeichenkette dem Aufruf `./configure`
  in der Rule `build' <em>voranstellen</em>.

  <p>Weil Sie gerade beim "stripping" sind. :-)  Häufig sind Programme
  so konfiguriert, dass sie ungestrippt installiert werden, oft ohne eine
  Möglichkeit, das zu ändern. Zum Glück haben Sie <manref name="dh_strip"
  section="1">, das das Flag <tt>DEB_BUILD_OPTIONS=nostrip</tt> erkennt und still
  endet.

  <p>Zeilen 18 bis 26 enthalten die Rule `build' (und die untergeordnete
  `build-stamp'-Rule), die mit dem Makefile der Anwendung das Programm
  kompiliert. Wenn Ihr Paket die "GNU configure"-Werkzeuge benutzt, sollten
  Sie unbedingt <file>&autotools-dev;</file> gelesen haben.
  Auf die auskommentierte Zeile der docbook-to-man Umwandlung
  wird später in <ref id="manpage"> eingegangen.

  <p>Die Rule `clean' in den Zeilen 28-36 entsorgt alle unnötigen Binär- und
  automatisch generierten Dateien, die nach der Paketerstellung
  zurückbleiben. Diese Rule muss jederzeit funktionsfähig sein, auch
  wenn im Quellcode-Verzeichnis bereits aufgeräumt wurde, also sollten
  Sie evtl. die "Zwang"-Optionen benutzen (z.B. "-f" bei  rm), oder die
  Rückgabewerte (Fehler) mit einem `-' am Anfang des Befehls ignorieren.

  <p>Der Installationsprozess, die Rule `install', beginnt in der Zeile
  38. Es wird einfach die Rule `install' des programmeigenen Makefiles
  ausgeführt, aber in das Verzeichnis <tt>$(CURDIR)/debian/gentoo</tt>
  installiert - aus diesem Grund haben Sie in gentoo's Makefile auch die
  Variable <var>$(DESTDIR)</var> (als Root-Verzeichnis der Installation)
  eingebaut.

  <p>Die Rule `binary-indep' in der Zeile 48, ist, wie der Kommentar
  bereits sagt, für die Erstellung von architekturunabhängigen Paketen
  vorgesehen. Das ist bei Ihrem Paket nicht der Fall, also wird hier
  auch nichts gemacht.

  <p>Auf zur nächsten Rule - `binary-arch' in den Zeilen 52 bis 79, in
  der verschiedene kleine Hilfsprogramme aus dem Paket <package>dephelper</package> gestartet werden,
  die an unseren Dateien verschiedene Operationen durchführen, um das
  Paket an die Policy anzupassen.

  <p>Wenn Ihr Paket `Architecture: all' entspricht, dann müssen
  Sie alle Kommandos zum Bauen des Pakets in der Rule `binary-indep'
  platzieren und die Rule `binary-arch' dafür leer lassen.

  <p>Die Namen der debhelper-Programme beginnen mit <tt>dh_</tt> und der Rest
  erklärt bereits die Aufgabe
  des Tools. Alles ist praktisch selbsterklärend, hier dennoch einige
  zusätzlichen Erläuterungen:

  <list>
  <item><manref name="dh_testdir" section="1"> überprüft, ob Sie im
  richtigen Verzeichnis sind (d.h. im obersten Verzeichnis des
  Quellcode-Verzeichnisbaums).
  <item><manref name="dh_testroot" section="1"> überprüft, ob Sie
  root-Rechte besitzen, die für die Targets `binary-arch', `binary-indep'
  und `clean' benötigt werden.
  <item><manref name="dh_installmanpages" section="1"> kopiert die
  Manpages an die richtige Stelle im Zielverzeichnis, Sie müssen
  nur angeben, wo sie relativ zum obersten Verzeichnis des
  Quellcode-Verzeichnisbaums zu finden sind.
  <item><manref name="dh_strip" section="1"> "strippt" (A.d.Ü.: siehe auch
  <manref name="strip" section="1">) die Debugging-Header aus Bibliotheken und
  ausführbaren Dateien, um die Dateigröße zu reduzieren.
  <item><manref name="dh_compress" section="1"> komprimiert
  Manpages und Doku-Dateien, die größer als 4 kB sind mit
  <manref name="gzip" section="1">.
  <item><manref name="dh_installdeb" section="1"> kopiert sonstige, fürs
  Paket benötigte Dateien (z.B. die Maintainer-Skripte) ins Verzeichnis
  `debian/gentoo/DEBIAN'.
  <item><manref name="dh_shlibdeps" section="1"> berechnet
  Abhängigkeiten von Bibliotheken und anderen Binär-Dateien.
  <item><manref name="dh_gencontrol" section="1"> installiert eine
  angepasste Version der Datei `control' in das Verzeichnis
  <file>debian/gentoo/DEBIAN</file>.
  <item><manref name="dh_md5sums" section="1"> generiert MD5-Prüfsummen
  für alle Dateien im Paket.
  </list>

  <p>Die vollständigen Infos über die Aufgaben und Bedienung all
  dieser dh_*-Skripte finden Sie in den jeweiligen Manpages.  Es gibt
  noch weitere (möglicherweise sehr nützliche) dh_*-Skripte, die hier
  nicht weiter erwähnt werden. Wenn Sie die mal brauchen, lesen Sie die
  Debhelper-Dokumentation.

  <p>Die Sektion "binary-arch" ist eine, in der Sie wirklich alle
  Zeilen, in den nicht benötigte Features installiert werden,
  auskommentieren oder entfernen sollten. Bei Gentoo kommentieren Sie
  Zeilen mit folgenden
  Befehlen aus, weil Gentoo diese nicht braucht:
  examples, cron, init, man und info. In der Zeile 68 werden Sie `ChangeLog'
  durch `FIXES' ersetzen, weil das der Name der Changelog-Datei des
  Upstreams ist.

  <p>Die letzten zwei Zeilen sind (genau wie andere, nicht weiter
  erklärte Zeilen) mehr oder weniger benötigte
  Dinge, über die Sie mehr im <prgn/make/-Manual oder der Policy nachlesen
  können. Im Moment brauchen Sie darüber nichts zu wissen.

  <chapt id="dother">Andere Dateien unter debian/

  <p>Wie Sie sehen gibt es noch verschiedene weitere Dateien im
  "debian/"-Unterverzeichnis, von den die meisten mit dem `ex'-Suffix
  oder Präfix
  versehen sind, was bedeutet, dass es sich um Beispiele handelt. Schauen
  Sie sich alle an. Wenn Sie eines dieser Features unbedingt brauchen oder
  einfach so verwenden möchten:

  <list>
    <item>Lesen Sie die entsprechende Dokumentation (Tipp: Policy-Manual),
    <item>ändern Sie die Dateien, wenn nötig,
    <item>benennen Sie die Datei um, indem Sie `.ex' entfernen, wenn vorhanden,
    <item>benennen Sie die Datei um, indem Sie `ex.' entfernen, wenn vorhanden,
    <item>passen Sie die Datei `rules' an, soweit notwendig.
  </list>

  <p>Einige dieser Dateien, die am
  meisten benutzten,  werden in den folgenden Abschnitten beschrieben.

  <sect id="readme">README.Debian

  <p>Alle zusätzlichen Details und nennenswerte Unterschiede zwischen dem
  Original und ihrer "debianisierten" Version sollten hier dokumentiert
  werden.

  <p><prgn/dh_make/ erstellt eine Standardvorlage, die etwa so aussieht:

  <p><example>
gentoo for Debian
-----------------

&lt;possible notes regarding this package - if none, delete this file&gt;

-- Josip Rodin &lt;joy-mg@debian.org&gt;, Wed, 11 Nov 1998 21:02:14 +0100
  </example>

  <p>Da Sie nichts einzutragen haben, kann die Datei ruhig gelöscht werden.


  <sect id="conffiles">conffiles.ex

  <p>Eine der ärgerlichsten Sachen bei Software ist es, wenn Sie
  richtig viel Zeit und Mühe in die Konfiguration eines Programms
  investieren, und schon das nächste Update ihre Konfigurationsdateien
  platt macht. Debian löst dieses Problem, indem die
  Konfigurationsdateien markiert werden und der Administrator beim
  nächsten Paket-Upgrade gefragt wird, ob er seine Konfiguration behalten
  will oder nicht.

  <p>Zu markierende Konfigurationsdateien können Sie in die Datei
  `conffiles' eintragen, pro Zeile ein Dateiname mit dem vollständigen
  Pfad der Konfigurationsdatei (normalerweise in <file>/etc/</file>).
  Gentoo hat eine Konfigurationsdatei, <file>/etc/gentoorc</file>, also
  werden Sie diesen String in die Datei `conffiles' eintragen.

  <p>Wenn Ihr Programm Konfigurationsdateien nutzt, diese aber selbst
  zurückschreibt, ist es das Beste, diese nicht als conffiles zu kennzeichnen,
  weil sonst <prgn/dpkg/ den Nutzer jedes Mal auffordert Änderungen zu bestätigen.

  <p>Wenn Ihr Programm, das Sie paketieren möchten, verlangt, dass der
  Nutzer die Konfigurationsdateien ändern muss, damit es überhaupt
  funktioniert, sollten Sie diese auch nicht als conffiles kennzeichnen.

  <p>Beispiel-Konfigurationsdateien können Sie durch `maintainer scripts'
  bereitstellen, siehe <ref id="maintscripts">.

  <p> Wenn Ihr Programm keine Konfigurationsdateien braucht, kann die
  Datei `conffiles' aus dem Verzeichnis debian/ natürlich gelöscht werden.

  <sect id="crond">cron.d.ex

  <p>Wenn Ihr Paket immer wiederkehrende Aufgaben erledigen muss, um ordentlich
  zu arbeiten, können Sie diese Datei benutzen um das einzurichten.

  <p>Beachten Sie, dass dies nicht die `log-rotation' einschließt,
  siehe <manref name="dh_installlogrotate" section="1"> und <manref
  name="logrotate" section="8">. (A.d.Ü: Ein Programm, mit dem man das
  unbegrenzte Wachstum der Log-Dateien verhindern kann.)

  <p>Wenn Sie das nicht brauchen, entfernen Sie die Datei.

  <sect id="dirs">dirs

  <p>In dieser Datei werden Verzeichnisse festgelegt, die Sie brauchen,
  aber von der Installationsprozedur (hier: "make install") nicht
  automatisch erstellt werden.

  <p>Die Vorlage sieht so aus:

  <p><example>
usr/bin
usr/sbin
  </example>

  <p>Beachten Sie, dass kein einleitender Schrägstrich dabei ist.
  Normalerweise würden Sie das jetzt in Folgendes ändern:

  <p><example>
usr/bin
usr/man/man1
  </example>

  <p>Allerdings werden diese Verzeichnisse bereits durch das Makefile
  erstellt, also brauchen Sie die Datei `dirs' nicht und werden sie
  löschen.

  <sect id="docs">docs

  <p>Diese Datei enthält die Namen der Dokumentations-Dateien, die
  <prgn/dh_installdocs/ für Sie ins Unterverzeichnis debian/ installieren wird.

  <p>Standardmäßig schließt das alle Dateien im obersten Verzeichnis des
  Quellcode-Verzeichnisbaums ein, die da heißen "BUGS", "README*", "TODO"
  usw.

  <p>Für Gentoo fügen Sie noch Weiteres hinzu:

  <p><example>
BUGS
CONFIG-CHANGES
CREDITS
ONEWS
README
README.gtkrc
TODO
  </example>

  <p>Sie können die Datei auch löschen und stattdessen die Dateinamen
  in die Kommandozeile von <prgn/dh_installdocs/ in der Datei `rules',
  wie hier:
  <p><example>
        dh_installdocs BUGS CONFIG-CHANGES CREDITS ONEWS README \
                       README.gtkrc TODO
  </example>

  <p>Sollten Sie keine dieser Dateien in Ihrem Paket haben, können Sie
  die Datei auch löschen. Aber löschen Sie nicht den Aufruf <prgn/dh_installdocs/
  in der Datei `rules', da dieser auch die Datei `copyright' installiert
  und andere Dinge tut.

  <sect id="emacsen">emacsen-*.ex

  <p>Wenn Ihr Paket Emacs-Dateien mitbringt, die während der Installation des
  Pakets kompiliert werden, sollten Sie diese Datei dafür nutzen.

  <p>Sie werden durch <manref name="dh_installemacsen" section="1">
  im Unterverzeichnis installiert, vergessen Sie also nicht, diese Zeile
  in der Datei `rules' auszukommentieren, wenn Sie das benutzen.

  <p>Wenn Sie das nicht benötigen, löschen Sie die Datei.

  <sect id="initd">init.d.ex

  <p>Wenn Ihr Paket einen Dienst enthält, der beim Hochfahren des Systems
  gestartet werden muss, haben Sie die anfänglichen Empfehlungen offensichtlich
  missachtet, stimmt's? :-)

  <p>Es ist wirklich ein sehr allgemeines Grundgerüst für ein Skript, das
  in <file>/etc/init.d/</file> installiert werden soll, es hat reichlich
  Anpassungsbedarf. Es wird durch <manref name="dh_installinit" section="1">
  in das Unterverzeichnis installiert.

  <p>Wenn Sie das nicht benötigen, löschen Sie die Datei.

  <sect id="manpage">manpage.1.ex, manpage.sgml.ex

  <p>Ihr Programm sollte eine Manpage haben. Hat es keine, dann können
  Sie die erstellte Vorlage umbenennen und mit dem eigenen Text füllen.

  <p>Manual-Seiten werden üblicherweise in <manref name="nroff" section="1">
  geschrieben. Das Beispiel <tt/manpage.1.ex/ ist auch in nroff geschrieben.
  In den Manpages von <manref name="man" section="7"> finden Sie weitere
  Hinweise zur Erstellung von Man-Seiten.

  <p>Wenn Sie es andererseits bevorzugen in SGML anstatt nroff zu schreiben,
  können Sie die Datei `manpage.sgml.ex' benutzen. Dann müssen Sie Folgendes
  tun:

  <list>
    <item>Installieren Sie das Paket <package/docbook-to-man/,
    <item>fügen Sie <tt/docbook-to-man/ der Zeile <tt/Build-Depends/ in der
    Datei `control' hinzu und
    <item>aktivieren Sie den Aufruf docbook-to-man in der Rule `build' der
    Datei `rules'.
  </list>

  <p>Vergessen Sie nicht, die Datei in `gentoo.sgml' umzubenennen!

  <p>Die endgültige Manpage-Datei sollte den Namen des Programms, das
  dokumentiert wird, erhalten. Deshalb ändern Sie den Namen von "manpage" nach
  "gentoo". Die Datei muss auch eine ".1" als erste Endung erhalten, d.h.
  es handelt sich um eine Manpage für ein Nutzer-Kommando.
  Stellen Sie sicher, dass Sie die richtige Kategorie gewählt haben.
  Hier ist eine kurze Liste der Kategorien:

  <p><example>
Sektion |     Beschreibung     |     Anmerkungen
   1     Benutzerkommandos      Ausführbare Programme oder Skripte
   2     Systemaufrufe          Kernelfunktionen
   3     Bibliotheksaufrufe     Funktionen in System-Bibliotheken
   4     Spezielle Dateien      gewöhnlich in /dev
   5     Dateiformate und
         Konventionen           z.B. das Format von /etc/passwd
   6     Spiele                 und ähnliche Programme
   7     Makropakete und
         Konventionen           z.B. man(7), groff(7)
   8     Systemadministrations-
         befehle                in der Regel nur für root
   9     Kernelroutinen         [Nicht Standard]
  </example>

  <p>Also bekommt unsere Manpage den Dateinamen `gentoo.1'. Für
  X Programme können Sie noch ein "x" anhängen, z.B.
  `gentoo.1x'. Im gentoo-Archiv gab es keine
  Manpage `gentoo.1', also hat der Autor eine geschrieben, mit Hilfe der
  Informationen aus dem Beispiel und aus der Dokumentation des Upstreams.

  <sect id="menu">menu.ex

  <p>Benutzer von "X Window System" haben normalerweise einen
  Fenstermanager mit konfigurierbaren Menüs, aus dem die Programme
  gestartet werden. Wenn Sie das Debian-Paket <package/menu/ installiert haben,
  wird eine Reihe Menü-Einträge für die installierten Programme
  automatisch hinzugefügt.

  <p>Standardmäßig erstellt <prgn/dh_make/ die Datei <package/menu/ so:

  <p><example>
?package(gentoo):needs=X11|text|vc|wm section=Apps/see-menu-manual\
    title="gentoo" command="/usr/bin/gentoo"
  </example>

  <p>Das erste Feld nach dem Doppelpunkt ist "needs" und  bestimmt,
  welche Art der Benutzerschnittstelle das
  Programm braucht. Lassen Sie nur die zutreffende Option stehen, z.B.
  "text" oder "X11".

  <p>Das nächste ist "section", in welchem Menü und Untermenü der Eintrag
  später erscheinen soll. Die aktuelle Liste der Sektionen ist in:
  <file>/usr/share/doc/debian-policy/menu-policy.html/ch2.html#s2.1</file>
  zu finden.

  <p>Das Feld "title" enthält den Namen des Programms. Der kann mit
  Großbuchstaben beginnen, sollte aber kurz gehalten werden.

  <p>Zuletzt das Feld "command", das den Kommandoaufruf zum Starten des
  Programms enthält.

  <p>Den Menü-Eintrag verändern Sie also zum folgenden:
  <p><example>
?package(gentoo): needs=X11 section=Apps/Tools title="Gentoo"\
    command="gentoo"
  </example>

  <p>Sie können noch weiter Felder wie "longtitle", "icon", "hints" usw.
  hinzufügen. Siehe <manref name="menufile" section="5">,
  <manref name="update-menus" section="1"> und
  <file>/usr/share/doc/debian-policy/menu-policy.html/</file> für mehr Infos.

  <sect id="watch">watch.ex

  <p>Mit dieser Datei können Sie <manref name="uscan" section="1">- und
  <manref name="uupdate" section="1">-Programme (aus dem Paket <package/devscripts/)
  konfigurieren. Diese sind nützlich, um die Seite zu überwachen, von der Sie
  die Original-Quellen bezogen haben.

  <p>Folgendes könnten Sie da eintragen:

  <p><example>
# watch control file for uscan
# Site             Directory  Pattern               Version  Script
ftp.obsession.se   /gentoo    gentoo-(.*)\.tar\.gz  debian   uupdate
  </example>

  <p>Hinweis: Wechseln Sie, wenn Sie die Datei einmal erstellt haben, mit
  einer bestehenden Internetverbindung in das Arbeitsverzeichnis und
  probieren Sie, "uscan" auszuführen. Und RTFM. :)

  <sect id="doc-base">ex.package.doc-base

  <p>Hat Ihr Programm noch andere Dokumentationen, nicht nur Man- und Info-Seiten,
  so sollten Sie die Datei `<package/doc-base/' benutzen, um diese zu registrieren,
  damit der Benutzer sie mit
  Programmen wie <manref name="dhelp" section="1">,
  <manref name="dwww" section="1"> oder <manref name="doccentral" section="1">
  finden kann.

  <p>Das schließt normalerweise HTML-, PS- und PDF-Dateien ein, die sich in
  <file>/usr/share/doc/packagename/</file> befinden.

  <p>So könnte Gentoo's Datei `gentoo.doc-base' dann aussehen:
  <p><example>
Document: gentoo
Title: Gentoo Manual
Author: Emil Brink
Abstract: This manual describes what Gentoo is, and how it can be used.
Section: Apps/Tools

Format: HTML
Index: /usr/share/doc/gentoo/html/index.html
Files: /usr/share/doc/gentoo/html/*.html
  </example>

  <p>Informationen über das Format dieser Datei finden Sie in
  <manref name="install-docs" section="8">
  und der Anleitung von <package/doc-base/ in
  <file>/usr/share/doc/doc-base/doc-base.html/</file>.

  <sect id="maintscripts">postinst.ex, preinst.ex, postrm.ex, prerm.ex

  <p>Diese Dateien werden Maintainer-Skripte genannt. Das sind Skripte die im
  Kontroll-Bereich des Pakets liegen und von <prgn/dpkg/ ausgeführt werden, und
  zwar, wenn Ihr Paket installiert, aktualisiert oder entfernt wird.

  <p>Vorerst sollten Sie aber von den Maintainer-Skripten die Finger
  lassen, weil die manuelle Bearbeitung schnell kompliziert werden kann.
  Mehr Informationen finden Sie in der Policy, Kapitel 6, und
  werfen Sie einen Blick auf die Beispiele von <prgn/dh_make/.


  <chapt id="build">"Bau" des Pakets

  <p>Nun sollten Sie soweit sein, das Paket zu "bauen".

  <sect id="completebuild">Kompletter Neubau

  <p>Wechseln Sie nun in das Verzeichnis des Programms und führen Sie
  das folgende Kommando aus:

  <p><example>
dpkg-buildpackage -rfakeroot
  </example>

  <p>Das wird alles für Sie erledigen. In Einzelnen:
  <list>
    <item>Aufräumen des Quell-Verzeichnisbaumes (debian/rules clean), mittels
    <prgn/fakeroot/,
    <item>Bauen des Quell-Pakets (dpkg-source -b),
    <item>Bauen des Programms (debian/rules build,)
    <item>Bauen des Binär-Pakets (debian/rules binary), mittels
    <prgn/fakeroot/,
    <item>signieren der Quell-Datei `*.dsc', mittels <prgn/gnupg/,
    <item>erstellen und signieren der Upload-Datei `.changes', mittels
    <prgn/dpkg-genchanges/ und <prgn/gnupg/.
  </list>

  <p>Sie müssen nur zweimal Ihr Passwort für den GPG-Schlüssel eingeben.

  <p>Nachdem das erledigt ist, werden Sie folgende Dateien im darüberliegenden
  Verzeichnis (<file>~/gentoo/</file>) vorfinden:

  <p><list>
    <item><em>gentoo_0.9.12.orig.tar.gz</em>

    <p>Dies ist der ursprüngliche Quellcode-Tarball, lediglich umbenannt,
    um dem Debian-Standard zu genügen.

    <item><em>gentoo_0.9.12-1.dsc</em>

    <p>Dies ist eine Zusammenfassung des Inhalts des Quellcode-Pakets. Sie
    wird aus Ihrer Datei `control' generiert und
    für das Entpacken des Quellcodes mittels <manref name="dpkg-source"
    section="1"> benötigt. Diese Datei ist mit GPG signiert, somit können
    sich die Leute vergewissern, dass sie von ihnen kommt.

    <item><em>gentoo_0.9.12-1.diff.gz</em>

    <p>Diese komprimierte Datei enthält alle Zusätze und Änderungen, die
    Sie mit dem ursprünglichen Quellcode gemacht haben, im Format, das als
    "unified diff" bekannt ist. Die Datei wird erstellt und benutzt von
    <manref name="dpkg-source" section="1">. Wenn Sie den originalen Tarball nicht
    `paketname_version.orig.tar.gz' genannt haben, wird <prgn/dpkg-source/ bei der
    Generierung der Datei `*.diff.gz' scheitern!

    <p>Wenn jemand Ihr Paket von Grund auf neu bauen will, kann er die drei
    o.g. Dateien dazu verwenden. Das Verfahren ist trivial: kopieren Sie
    einfach die drei Dateien in ein Verzeichnis und starten Sie `dpkg-source
    -x gentoo_0.9.12-1.dsc`.

    <item><em>gentoo_0.9.12-1_i386.deb</em>

    <p>Das ist Ihr fertiges Binär-Paket. Sie können es mit <prgn/dpkg/
    installieren und wieder entfernen wie jedes andere Paket auch.

    <item><em>gentoo_0.9.12-1_i386.changes</em>

    <p>Diese Datei beschreibt die Änderungen  in dieser Paket-Revision.
    Die Verwaltungsprogramme für Debians FTP-Archive benötigen diese Datei
    zur Installation der Binär- und Quellcode-Pakete ins FTP-Archiv. Sie
    wird zum Teil aus den Dateien `changelog' und `*.dsc' generiert. Diese Datei
    ist GPG-signiert, so dass man sicher sein kann, dass sie wirklich von Ihnen
    ist.

    <p>Wenn Sie weiter an dem Paket arbeiten, wird sich das Verhalten ändern und
    Sie werden neue Funktionen hinzufügen. Leute, die Ihr Paket herunterladen,
    können sich die Datei ansehen und feststellen, was sich geändert hat. Das
    Debian-Archiv-Verwaltungsprogramm wird den Inhalt dieser Datei auch an die
    debian-devel-changes Mailingliste schicken.
  </list>

  <p>Die langen Zahlenreihen in den Dateien `*.dsc' und `.changes' sind
  MD5-Prüfsummen dieser Dateien.
  Jemand, der Ihr Paket herunterlädt, kann die enthaltenen Dateien mit <manref
  name="md5sum" section="1"> testen und wenn die Zahlen nicht übereinstimmen,
  weiß er, die geprüfte Datei ist beschädigt oder manipuliert.

  <sect id="quickrebuild">Schneller Neubau

  <p>Bei einem großen Paket wollen Sie bestimmt nicht alles nach jeder
  kleiner Änderung in <file>debian/rules</file> neu kompilieren. Für Testzwecke
  können Sie ein .deb erstellen, ohne alle Schritte durchzumachen, z.B.
  so:

  <p><example>
fakeroot debian/rules binary
  </example>

  <p>Wenn Sie mit Ihren Anpassungen fertig, vergessen Sie nicht, nach der
  kompletten Prozedur das Paket endgültig zu bauen. Sie werden Pakete, die auf
  diese Weise gebaut sind, nicht korrekt hochladen können.

  <sect id="debuild">Das Kommando <prgn>debuild</prgn>

  <p>Sie können das Paketbauen in Zukunft mit dem Kommando
  <prgn>debuild</prgn> automatisieren.
  (siehe <manref name="debuild" section="1">)

  <p>Das Kommando <prgn>debuild</prgn> kann in den Dateien
  <file>/etc/devscripts.conf</file> oder <file>~/.devscripts</file>
  benutzerbezogen angepasst werden.
  Die folgenden Einträge sind mindestens empfohlen:

  <p><example>
DEBSIGN_KEYID="Ihre_GPG_Schlüssel_ID"
DEBUILD_DPKG_BUILDPACKAGE_OPTS="-i -ICVS -I.svn"
  </example>
  Damit werden Ihre gebauten Pakete immer mit Ihrem GPG-Schlüssel signiert und
  es werden unerwünschte Dateien und Verzeichnisse im Paket verhindert.
  (Das ist auch für Sponsoren geeignet.)
  Beispielsweise ist das Säubern des Quellverzeichnisses und Neubauen des
  Pakets als Benutzer so einfach, wie:

  <p><example>
debuild clean
debuild
  </example>

  <sect id="dpatch">Das <prgn>dpatch</prgn>-System
  <p>Die einfach zu nutzenden Kommandos <prgn>dh_make</prgn> und
  <prgn>dpkg-buildpackage</prgn> erstellen eine große Datei
  <file>*.diff.gz</file>, die alle Dateien für die Paketbetreuung in
  <file>debian/</file> und Patch-Dateien für den Quellcode enthält.
  So ein Paket ist sehr mühselig zu kontrollieren und jede Änderung
  des Quellcodes ist später schwer zu verstehen. Das ist nicht so schön.
  <footnote>
  Wenn Sie noch kein Debian-Entwickler sind und Ihren Sponsor bitten, Ihr
  Paket nach einer Überprüfung hochzuladen, sollten Sie Ihr Paket so einfach
  wie möglich für ihn überprüfbar machen.
  </footnote>

  <p>Verschiedene Möglichkeiten der Betreuung von Patch-Sets wurden
  vorgeschlagen und werden in Debian verwendet. Das <prgn>dpatch</prgn>-System
  ist eines der einfachsten. Andere sind dbs, cdbs, etc.

  <p>Ein Paket, das ordentlich mit dem <prgn>dpatch</prgn>-System erstellt
  wurde, enthält die Änderungen des Quellcodes klar dokumentiert als
  Patch-Set-Dateien in <file>debian/patches/</file> und der Quellcode außerhalb
  des Verzeichnisses <file>debian/</file> bleibt unberührt. Wenn Sie Ihren
  Sponsor bitten, Ihr Paket hochzuladen, ist diese klare Trennung und
  Dokumentation Ihrer Änderungen für die zügige Überprüfung des Pakets durch
  Ihren Sponsor sehr wichtig. Der Umgang mit <prgn>dpatch</prgn> wird in
  <manref section="1" name="dpatch"> erklärt.

  <p>Wenn Ihnen jemand (einschließlich Ihnen selbst) später einen Patch
  für den Quellcode zur Verfügung stellt, ist die Anpassung des Pakets mit
  <prgn>dpatch</prgn> recht einfach:
  <list compact>
  <item>Patch anpassen, zu einem "-p1"-Patch zum Quellcode machen.
  <item>Kopfzeilen mit dem Kommando <prgn>dpatch patch-template</prgn>
  hinzufügen.
  <item>Im Verzeichnis <file>debian/patches</file> ablegen.
  <item>Den Dateinamen in die <file>debian/patches/00list</file> schreiben.
  </list>

  <p><prgn>dpatch</prgn> bietet auch die Möglichkeit, Patches durch das CPP-Macro
  architekturabhängig zu machen.

  <sect id="option-sa">Einbeziehen von <file>*.orig.tar.gz</file> beim Hochladen

  <p>Wenn Sie das Paket zum ersten Mal in das Archiv hochladen, müssen Sie die
  Original-Quellen <file>*.orig.tar.gz</file> einbeziehen. Wenn die Paketversion
  nicht eine <tt>-0</tt> oder <tt>-1</tt> als Debian-Revisionsnummer hat,
  müssen Sie dem Kommando <prgn>dpkg-buildpackage</prgn> die Option
  "<tt>-sa</tt>" mitgeben. Dem gegenüber erzwingt die Option "<tt>-sd</tt>" den
  Ausschluss der Original-Quellen <file>*.orig.tar.gz</file>.

  <chapt id="checkit">Überprüfung des Pakets auf Fehler

  <p>
  <sect id="lintians">Die Pakete <package>lintian</package> und <package>linda</package>

  <p>Lassen Sie <manref name="lintian" section="1"> und
  <manref name="linda" section="1">auf ihre
  Datei `*.changes' los; diese Programme finden viele Fehler, die beim
  Paketerstellen häufig gemacht werden. Die Aufrufe sind folgende:

  <p><example>
lintian -i gentoo_0.9.12-1_i386.changes
linda   -i gentoo_0.9.12-1_i386.changes
  </example>

  <p>Den Dateinamen ersetzen Sie durch den Namen der Datei `*.changes' Ihres
  Pakets. Erscheinen bei der Überprüfung einige Fehler, (mit E:
  anfangende Zeilen), lesen Sie die Erklärung (die N:-Zeilen),
  korrigieren Sie die Fehler und erstellen Sie das Paket neu, wie in
  <ref id="completebuild"> beschrieben wurde. Erscheinen nur Zeilen mit W: am
  Anfang, dann sind es Warnungen. Sie sollten die Ursachen berichtigen
  oder sich davon überzeugen, dass die Warnungen unbegründet sind (und
  <prgn/lintian/ zwingen, das zu akzeptieren; siehe die Dokumentation für Details).

  <p>Noch ein Tipp: Sie können <prgn/dpkg-buildpackage/ und <prgn/lintian/
  auf einmal
  ausführen, mit dem Befehl <manref name="debuild" section="1">.

  <sect id="mc">Das Programm <prgn>mc</prgn>

  <p>Sie können den Inhalt eines <file>.deb</file>-Pakets mit dem Kommando
  <manref name="dpkg-deb" section="1"> auspacken. Sie können den Inhalt eines
  Debian-Pakets mit dem Kommando <manref name="debc" section="1"> anzeigen.

  <p>Ein Dateimanager wie <manref name="mc" section="1"> kann die Arbeit
  vereinfachen, indem er Ihnen nicht nur den Inhalt eines
  <file>.deb</file>-Pakets anzeigt, sondern auch die Dateien
  <file>*.diff.gz</file> und <file>*.tar.gz</file>.

  <p>Halten Sie im Binär- und Quell-Paket Ausschau nach unnötigen oder leeren
  Dateien. Meistens wurde dieser Müll nicht richtig entfernt; passen Sie die
  Datei <file>rules</file> an, das zu tun.

  <p>Tipps:
  <list compact>
  <item>`<tt>zgrep ^+++ ../gentoo_0.9.12-1.diff.gz</tt>' zeigt Ihnen eine Liste
  Ihre Änderungen/Hinzufügungen zu den Quellcode-Dateien
  <item>`<tt>dpkg-deb -c gentoo_0.9.12-1_i386.deb</tt>' oder `<tt>debc
  gentoo_0.9.12-1_i386.changes</tt>' listet die Dateien des Binär-Pakets auf.
  </list>

  <sect id="debdiff">Das Kommando <prgn>debdiff</prgn>

  <p>Sie können mit dem Kommando <manref name="debdiff" section="1"> die
  Dateilisten in zwei Binär-Paketen vergleichen. Damit können Sie überprüfen,
  dass keine Dateien unabsichtlich verschoben oder gelöscht wurden und keine
  anderen versehentlichen Veränderungen bei der Aktualisierung des Pakets
  eingetreten sind.
  Mit dem Kommando `<tt>debdiff old-package.change new-package.change</tt>'
  können Sie einfach mehrere <file>.deb</file>-Pakete überprüfen.

  <sect id="interdiff">Das Kommando <prgn>interdiff</prgn>

  <p>Sie können mit dem Kommando <manref name="interdiff" section="1"> zwei
  Dateien <file>*.diff.gz</file> vergleichen. Damit können Sie überprüfen,
  dass keine versehentlichen Veränderungen am Quellcode bei der Aktualisierung
  des Pakets durch den Paket-Betreuer eingetreten sind.
  Rufen Sie `<tt>interdiff -z old-package.diff.gz new-package.diff.gz</tt>'
  auf.

  <sect id="debi">Das Kommando <prgn>debi</prgn>

  <p>Installieren Sie das Paket nun selbst, z.B. mit dem Kommando
  <manref name="debi" section="1"> als root. Versuchen Sie jetzt, das
  Paket auf anderen Rechnern zu installieren und das Programm laufen zu
  lassen, achten Sie dabei auf Warnungen und Fehlermeldungen während der
  Installation und Ausführung.

  <sect id="pbuilder">Das Paket <package>pbuilder</package>

  <p>Das Paket <package>pbuilder</package> ist sehr gut geeignet, die
  Build-Abhängigkeiten in einer sauberen Build-Umgebung (chroot) zu überprüfen.
  Das stellt ein problemloses Bauen des Pakets aus den Quellen auf den
  Auto-Buildern für verschiedene Architekturen sicher und verhindert einen
  schwerwiegenden FTBFS-Bug, der immer release-kritisch (RC) ist. Siehe
  <url id="&buildd-home;"> für mehr Informationen über die Debian-Auto-Builder.

  <p>Am einfachsten nutzen Sie das Paket <package>pbuilder</package> durch
  direkten Aufruf des Kommandos <prgn>pbuilder</prgn> als Benutzer root.
  Führen Sie beispielsweise folgende Kommandos in dem Verzeichnis aus, das die
  Dateien <file>*.orig.tar.gz</file>, <file>*.diff.gz</file> und
  <file>*.dsc</file> enthält, um ein Paket zu bauen.
  <example>
root # pbuilder create # if second time, pbuilder update
root # pbuilder build foo.dsc
  </example>
  Das neu gebaute Paket befindet sich unter
  <file>/var/cache/pbuilder/result/</file> und gehört root.

  <p>Das Kommando <prgn>pdebuild</prgn> ermöglicht Ihnen, das Paket
  <package>pbuilder</package> als normaler Benutzer zu nutzen. Im
  Wurzelverzeichnis des Quellcodes, die Datei <file>*.orig.tar.gz</file>
  liegt im übergeordneten Verzeichnis, führen Sie folgende Kommandos aus:
  <example>
$ sudo pbuilder create # if second time, sudo pbuilder update
$ pdebuild
  </example>
  Das neu gebaute Paket befindet sich unter
  <file>/var/cache/pbuilder/result/</file> und gehört nicht root.
  <footnote>
  Sie sollten eventuell Ihr System anpassen, indem Sie das Verzeichnis
  <file>/var/cache/pbuilder/result/</file> für die Benutzer schreibbar machen
  und in der Datei <file>~/.pbuilderrc</file> oder <file>/etc/pbuilderrc</file>
  Folgendes hinzufügen:
  <example>
AUTO_DEBSIGN=yes
  </example>
  Damit können Sie die erzeugten Pakete mit Ihrem geheimen GPG-Schlüssel unter
  <file>~/.gnupg/</file> signieren. Da sich das Paket
  <package>pbuilder</package> in ständiger Entwicklung befindet, sollten Sie
  die aktuellen Einstellmöglichkeiten in der letzten offiziellen Dokumentation
  nachschlagen.
  </footnote>
  <p>Wenn Sie in eine zusätzliche APT-Quelle hinzufügen wollen, die vom Paket
  <package>pbuilder</package> benutzt werden soll, setzen Sie
  <tt>OTHERMIRROR</tt> in der Datei <file>~/.pbuilderrc</file> oder
  <file>/etc/pbuilderrc</file> und starten (für Sarge):
  <example>
$ sudo pbuilder update --distribution sarge --override-config
  </example>
  Die Option <tt>--override-config</tt> muss mitgegeben werden, um die
  APT-Quelle in der chroot-Umgebung zu aktualisieren.

  <p>Siehe <url id="&pbuilder-home;">, <manref section="1" name="pdebuild">,
  <manref section="5" name="pbuilderrc"> und
  <manref section="8" name="pbuilder">.


  <chapt id="upload">Hochladen des Pakets

  <p>Nun, nachdem Sie das Paket ausreichend getestet haben, können Sie
  sich als neuer Debian-Entwickler bewerben, der sog. "Debian new maintainer
  application process", näher beschrieben unter
  <url id="http://www.debian.org/devel/join/newmaint">, beginnt.

  <sect id="upload-debian">Hochladen in das Debian-Archiv

  <p>Wenn Sie dann offizieller Entwickler geworden sind, werden Sie das Paket
  in das Debian-Archiv hochladen wollen. Sie können das per Hand erledigen,
  aber es ist einfacher, das mit den bereitgestellten Werkzeugen wie
  <manref name="dupload" section="1"> oder <manref name="dput"
  section="1"> zu automatisieren.
  Hier wird die Handhabung von <prgn/dupload/ beschrieben.

  <p>Zunächst müssen Sie <prgn/dupload/'s Konfigurationsdatei erstellen.
  Sie können entweder die systemweite Datei
  <file>/etc/dupload.conf</file> verändern oder Sie nehmen in Ihrer
  eigenen Datei `<file>~/.dupload.conf</file>' die wenigen Änderungen,
  die Sie benötigen, vor. Schreiben Sie etwas wie folgendes dort hinein:

  <example>
package config;

$default_host = "anonymous-ftp-master";

$cfg{'anonymous-ftp-master'} = {
      fqdn => "ftp-master.debian.org",
      method => "ftp",
      incoming => "/pub/UploadQueue/",
      # files pass on to dinstall on ftp-master which sends emails itself
      dinstall_runs => 1,
};

1;
  </example>

  <p>Natürlich ersetzen Sie die Angaben durch Ihre eigenen und lesen
  die Manpage für <manref name="dupload.conf" section="5">,
  um die einzelnen Optionen zu verstehen.

  <p>Die schwierigste Option ist <var>$default_host</var> -- sie legt fest,
  welche Warteschlange beim Hochladen normalerweise benutzt wird. Die
  bevorzugte Queue ist "anonymous-ftp-master", aber es ist möglich, dass Sie
  eine andere, schnellere nutzen wollen. Mehr Informationen über die
  "Upload Queues" finden Sie in der Entwickler-Referenz, Sektion
  "Uploading a package", in
  <file>&uploading;</file>

  <p>Bauen Sie eine Verbindung zu Ihrem Internet-Provider auf, und
  führen Sie dieses Kommando aus:

  <example>
dupload gentoo_0.9.12-1_i386.changes
  </example>

  <p><prgn/dupload/ vergleicht die MD5-Prüfsummen mit denen aus der
  Datei `<file>*.changes</file>' und weist Sie ggf. an, das Paket neu zu
  "bauen", wie unter es <ref id="completebuild"> bereits beschrieben wurde.

<!-- (ftp-master wird nicht mehr benutzt)
  <p>Wenn Sie zum "ftp-master" hochladen, fragt <prgn/dupload/ nach ihrem
  Passwort auf den Debian-Rechnern und lädt dann die Pakete hoch.
-->

  <p>Wenn Sie ein Problem beim Hochladen auf <url id="&ftp-uploadqueue;">
  feststellen, können Sie das selbst beheben, indem Sie mit dem Programm
  <prgn>ftp</prgn> eine GPG-signierte Datei <file>*.commands</file> nach
  <url id="&ftp-uploadqueue;"> kopieren.
  <footnote>
  Siehe <url id="&ftp-command;">. Sie können auch das Kommando
  <prgn>dcut</prgn> aus dem Paket <package>dput</package> benutzen.
  </footnote>
  Beispiel <file>hello.commands</file>:
  <example>
-----BEGIN PGP SIGNED MESSAGE-----

Uploader: Roman Hodek &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;
Commands:
 rm hello_1.0-1_i386.deb
 mv hello_1.0-1.dsx hello_1.0-1.dsc

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3ia

iQCVAwUBNFiQSXVhJ0HiWnvJAQG58AP+IDJVeSWmDvzMUphScg1EK0mvChgnuD7h
BRiVQubXkB2DphLJW5UUSRnjw1iuFcYwH/lFpNpl7XP95LkLX3iFza9qItw4k2/q
tvylZkmIA9jxCyv/YB6zZCbHmbvUnL473eLRoxlnYZd3JFaCZMJ86B0Ph4GFNPAf
Z4jxNrgh7Bc=
=pH94
-----END PGP SIGNATURE-----
  </example>

  <sect id="upload-private">Hochladen in ein privates Archiv

  <p>Wenn Sie ein privates Archiv unter
  <tt>URL="http://people.debian.org/~<var>account_name</var>"</tt> erstellen
  wollen, können Sie das als Entwickler durch den einfachen Aufruf von
  <tt>dupload -t <var>target_name</var></tt>. Die sollten der Datei
  <file>/etc/dupload.conf</file> folgende Zeilen hinzufügen:
  <example>
# Entwickler-Zugang
$cfg{'<var>target_name</var>'} = {
    fqdn =&gt; "people.debian.org",
    method =&gt; "scpb",
    incoming =&gt; "/home/<var>account_name</var>/public_html/package/",
    # I do not need to announce
    dinstall_runs =&gt; 1,
};
$cfg{'<var>target_name</var>'}{preupload}{'changes'} = "
    echo 'mkdir -p public_html/package' | ssh people.debian.org \
         2&gt;/dev/null;
    echo 'Package directory created!'";

$cfg{'<var>target_name</var>'}{postupload}{'changes'} = "
    echo 'cd public_html/package ;
    dpkg-scanpackages . /dev/null &gt;Packages || true ;
    dpkg-scansources . /dev/null &gt;Sources || true ;
    gzip -c Packages >Packages.gz ;
    gzip -c Sources &gt;Sources.gz ' | ssh people.debian.org \
         2&gt;/dev/null;
    echo 'Package archive created!'";

  </example>
  Dabei wird das APT-Archiv durch einen entfernten
  "quick-and-dirty"-Shell-Aufruf über SSH realisiert. Die von den Programmen
  <prgn>dpkg-scanpackages</prgn> und <prgn>dpkg-scansources</prgn> benötigten
  Dateien <file>override</file> werden durch <file>/dev/null</file> ersetzt.
  Auf diese Weise können Sie auch ohne Debian-Entwickler zu sein, Ihre Pakete
  auf Ihrer privaten Internetseite bereitstellen. Sie können aber auch
  <prgn>apt-ftparchive</prgn> oder andere Skripte benutzen, um das APT-Archiv
  zu erstellen.

  <chapt id="update">Weiterentwicklung des Pakets

  <sect id="newrevision">Eine neue Debian Revision

  <p>Angenommen, es wurde ein Bug-Report (#54321) erstellt,
  und er beschreibt ein Problem, das Sie lösen können. Um eine neue
  Revision zu erstellen haben Sie folgendes zu tun:

  <list>
  <item>Lösen Sie das Problem im Quellcode (wohl selbstverständlich).

  <item>Machen Sie einen neuen Revisions-Eintrag an oberster Stelle in der
  Datei `changelog', z.B. mit `<tt>dch -i</tt>`, oder explizit mit
  `<tt>dch -v &lt;version&gt;-&lt;revision&gt;</tt>`

  <p>Tipp: Wie bekommen Sie das Datum ins richtige Format?
  Nehmen Sie <prgn/822-date/ oder <prgn/date/ mit der Option "-R".

  <item>Fügen Sie eine kleine Beschreibung des Bugs und der Lösung dem
  Eintrag hinzu, gefolgt von: "Closes: #54321". Auf diese Weise wird der
  Bug-Report von der Verwaltungssoftware "automagisch" geschlossen, sobald
  das Paket ins Debian-Archiv übernommen wurde.

  <item>Wiederholen Sie die Schritte aus <ref id="completebuild">, <ref
  id="checkit">, und <ref id="upload">. Der einzige Unterschied ist
  jetzt nur, dass der Original-Quellcode nicht mehr hochgeladen wird, da
  das Tar-Archiv nicht mehr geändert wurde und die alte Version bereits
  auf dem Server liegt.
  </list>

  <sect id="newupstream">Ein neues Upstream-Release (einfach)

  <p>Dies ist eine andere, etwas kompliziertere Situation -
  eine neue Upstream-Version wurde freigegeben und Sie wollen diese
  natürlich gleich übernehmen. Sie können nun folgendes tun:

  <list>
  <item>Den neuen Quellcode-Tarball herunterladen (z.B. das Archiv
  `<file>gentoo-0.9.13.tar.gz</file>'), in das Verzeichnis über dem alten
  Quellcode-Verzeichnis (z.B. `<file>~/gentoo/</file>') ablegen.

  <item>Das alte Quellcode-Verzeichnis (gentoo-0.9.12) betreten und folgendes
  ausführen:

  <example>
uupdate -u gentoo-0.9.13.tar.gz
  </example>

  <p>Natürlich ersetzen Sie den Dateinamen durch den Namen des neuen
  Source-Tarballs Ihres Programms.
  <manref name="uupdate" section="1"> wird es dann richtig umbenennen und
  versuchen, alle Änderungen aus Ihrer vorherigen Datei
  `<file>*.diff.gz</file>' in die neue Version zu übernehmen. Anschließend
  wird die Datei `<file>debian/changelog</file>' aktualisiert.

  <item>Wechseln Sie in das neue Verzeichnis `<file>../gentoo-0.9.13</file>',
  Ihr neues Quellcode-Arbeitsverzeichnis, und wiederholen Sie die Schritte
  aus <ref id="completebuild">, <ref id="checkit"> und <ref id="upload">.
  </list>

  <p>Übrigens können Sie, vorausgesetzt Sie haben `debian/watch' wie in
  <ref id="watch"> aufgesetzt, durch Ausführung von <manref name="uscan"
  section="1"> "automagisch" nach aktuellem Quellcode suchen,
  ihn herunterladen und <prgn/uupdate/ durchführen.

  <sect id="newupstream-real">Ein neues Upstream-Release (in Wirklichkeit)

  <p>Wenn Sie Pakete für das Debian-Archiv vorbereiten, müssen Sie die
  erstellten Paket eingehend prüfen. Es folgt ein realistischeres Beispiel
  für dieses Vorgehen.

  <p><enumlist compact>

  <item>Überprüfen der Änderungen im Programm-Quellcode

  <list compact>

  <item>Lesen Sie die Dateien <file>changelog</file>, <file>NEWS</file> und
  andere Dokumentationen der neuen Version des Upstream-Autors.

  <item>Führen Sie `<tt>diff -urN</tt>' zwischen dem alten und neuen
  Programm-Quellcode aus, um ein Gefühl für den Umfang der Änderungen zu
  bekommen, woran aktiv gearbeitet wurde (wodurch neue Fehler auftreten könnten)
  und halten Sie Ausschau nach allem, was verdächtig erscheint.

  </list>

  <item>Bringen Sie das alte Debian-Paket auf die neue Version.

  <list compact>

  <item>Packen Sie den Quell-Tarball aus, benennen Sie das Wurzelverzeichnis
  des Quellcodes in <file>&lt;Paketname&gt;-&lt;Upstream_Version&gt;/</file>
  um und wechseln Sie in dieses Verzeichnis.

  <item>Kopieren Sie den Quell-Tarball in das übergeordnete Verzeichnis und
  benennen Sie ihn in
  <file>&lt;Paketname&gt;_&lt;Upstream_Version&gt;.orig.tar.gz</file> um.

  <item>Wenden Sie auf den Quellcode der neuen Version die gleichen Änderungen
  an, wie bei der alten. Möglich ist das durch:
  <list compact>
  <item>das Kommando `<tt>zcat
  <var>/Pfad/zu/</var>&lt;Paketname&gt;_&lt;alte-Version&gt;.diff.gz |
  patch -p1</tt>',
  <item>das Kommando `<prgn>uupdate</prgn>',
  <item>das Kommando `<tt>svn merge</tt>', wenn Sie den Quellcode in einem
  Subversion-Repository verwalten oder
  <item>einfaches Kopieren des Verzeichnisses <file>debian/</file> aus dem
  alten Paketverzeichnis, wenn es mit <package>dpatch</package> erstellt wurde.
  </list>

  <item>Behalten Sie die alten Changelog-Einträge (sollte klar sein, aber es
  kam schon vor ...)

  <item>Die neue Paketversion besteht aus der Upstream-Release-Version,
  erweitert um eine <tt>-1</tt> als Debian-Revisionsnummer, z.B.
  `<tt>0.9.13-1</tt>'.

  <item>Fügen Sie einen Changelog-Eintrag mit "New upstream release" für
  diese neue Version oben in die Datei <file>debian/changelog</file> ein,
  z.B.: mit dem Aufruf `<tt>dch -v 0.9.13-1</tt>'.

  <item>Beschreiben Sie kurz die Änderungen <em>im</em> neuen Upstream-Release,
  die gemeldete Fehler beheben und schließen Sie diese Fehler im Changelog.

  <item>Beschreiben Sie kurz die Änderungen <em>am</em> neuen Upstream-Release,
  die Sie als Betreuer vorgenommen haben und die gemeldete Fehler beheben;
  schließen Sie diese Fehler im Changelog.

  <item>Wenn das Patchen/Zusammenführen nicht problemlos abläuft, untersuchen
  Sie die Fehler, um zu sehen, was schief geht (Hinweise geben die Dateien
  <file>*.rej</file>). Meistens stellt sich heraus, dass ein Patch, den Sie
  auf den Quellcode anwenden wollen, schon durch den Upstream-Autor in den
  Quellcode integriert wurde und der Patch nicht mehr gebraucht wird.

  <item>Die Aktualisierung des Pakets beim Benutzer sollte still und
  unauffällig ablaufen (bestehende Benutzer sollten von der Aktualisierung
  nichts mitbekommen, außer der Feststellung, dass alte Fehler behoben wurden
  oder vielleicht neue Funktionen vorhanden sind).
  <footnote>
  Bitte sorgen Sie dafür, dass Ihr Paket durch wohldurchdachtes
  <prgn>postinst</prgn> etc. die Konfigurationsdateien ordentlich aktualisiert,
  damit <strong>nichts</strong> geschieht, was der Benutzer nicht will! Das
  sind die Verbesserungen, die erklären, <strong>warum</strong> sich Leute
  für Debian entscheiden.

  <p>Wenn es nötig ist, die Aktualisierung auffällig ablaufen zu lassen
  (z.B. Konfigurationsdateien sind in verschiedenen Home-Verzeichnissen mit
  völlig unterschiedlicher Struktur verstreut), sollten Sie als letzte
  Möglichkeit das Paket in einen sicheren Standardmodus bringen (z.B. den Dienst
  abschalten) und eine ordentliche Dokumentation gemäß der Policy
  (<file>README.Debian</file> und <file>NEWS.Debian</file>) bereitstellen.
  Aber nicht den Admin mit einer debconf-Meldung belästigen.
  </footnote>

  <item>Wenn Sie aus irgendeinem Grund gelöschte debhelper-Template-Dateien
  wieder haben wollen, können Sie <prgn>dh_make</prgn> mit der Option
  <tt>-o</tt> nocheinmal im schon "debianisierten" Verzeichnis aufrufen und dann
  entsprechend ändern.

  <item>Vorhandene Änderungen für Debian müssen nochmals überprüft werden;
  entfernen Sie Sachen, die der Upstream-Autor schon eingebaut hat (in welcher
  Form auch immer) und behalten Sie Sachen, die noch nicht eingebaut sind, außer
  es gibt zwingende Gründe dagegen.

  <item>Wenn Sie Änderungen beim Bauen des Pakets vornehmen (hoffentlich haben
  Sie es gleich am Anfang gemerkt und die Dateien <file>debian/rules</file> und
  <file>debian/control</file> für die Build-Abhängigkeiten wenn nötig angepasst.

  </list>

  <item>Bauen Sie das neue Paket, wie in <ref id="debuild"> oder
  <ref id="pbuilder"> beschrieben. Die Nutzung von
  <package>pbuilder</package> ist wünschenswert.

  <item>Überprüfen, dass neue Pakete richtig gebaut werden.

  <list compact>

  <item>Verfahren Sie wie in <ref id="checkit">.

  <item>Weiter mit <ref id="upgrading">.

  <item>Überprüfen Sie erneut, ob Fehler behoben wurden, die im
  <url name="Debian Bug Tracking System (BTS)"
  id="http://www.debian.org/Bugs/"> noch offen sind.

  <item>Überprüfen Sie den Inhalt der Datei <file>*.changes</file>, damit Sie
  zur richtigen Distribution hochladen, die zutreffenden Fehlerbehebungen
  im Feld `Closes:' aufgelistet sind, die Felder `Maintainer:' und `Changed-By:'
  übereinstimmen, die Dateien GPG-signiert sind etc.

  </list>

  <item>Wenn Sie während der Arbeit an dem Paket irgendetwas an der Paketierung
  ändern, gehen Sie zu Punkt 2 bis es passt.

  <item>Wenn Sie einen Sponsor hochladen lassen, weisen Sie auf alle speziellen
  Optionen hin, die beim Bauen des Pakets angegeben werden müssen (z.B.
  '<tt>dpkg-buildpackage -sa -v ...</tt>') hin und informieren Sie Ihren Sponsor
  darüber, damit er oder sie das Paket richtig baut.

  <item>Wenn Sie selbst hochladen, machen Sie mit <ref id="upload"> weiter.
  </enumlist>

  <sect id="orig-tar">Die Datei <file>*.orig.tar.gz</file>

  <p>Wenn Sie versuchen, ein Paket nur aus dem neuen entpackten Quellcode mit
  dem Verzeichnis <file>debian/</file> und ohne die Datei
  <file>*.orig.tar.gz</file> im übergeordneten Verzeichnis zu bauen, werden Sie
  unabsichtlich ein Nativ-Quellpaket erstellen, das keine Datei
  <file>*.diff.gz</file> enthält. Diese Art von Paketen sollte nur für
  Debian-spezifische Pakete verwendet werden, die für andere Distributionen
  nicht nützlich sind.
  <footnote>
  Einige Leute lehnen das sogar für Debian-spezifische Pakete ab und finden es
  besser, den Inhalt des Verzeichnisses <file>debian/</file> in die Datei
  <file>*.diff.gz</file> zu packen, als in die Datei <file>*.orig.tar.gz</file>.
  </footnote>

  <p>Um kein Nativ-Quellpaket zu erstellen, sondern eins, das die Dateien
  <file>*.orig.tar.gz</file> und <file>*.diff.gz</file> enthält, müssen Sie
  den Quellcode-Tarball selbst in das übergeordnete Verzeichnis kopieren und
  seinen Namen in
  <file>&lt;Paketname&gt;_&lt;Upstream_Version&gt;.orig.tar.gz</file> ändern,
  wie es das Kommando <prgn>dh_make</prgn> in <ref id="dh_make"> macht.

  <sect id="cvs-buildpackage">Das Kommando <prgn>cvs-buildpackage</prgn> und
  ähnliche

  <p>Sie sollten überlegen, ein Versionskontrollsystem für die Verwaltung der
  Paketierungsdateien einzusetzen. Es gibt verschiedene Wrapper-Skripte, die
  auf die Verwendung mit den populärsten angepasst sind.
  <p><list compact>
  <item>CVS
  <list compact>
  <item><package>cvs-buildpackage</package>
  </list>
  <item>Subversion
  <list compact>
  <item><package>svn-buildpackage</package>
  </list>
  <item>Arch (tla)
  <list compact>
  <item><package>tla-buildpackage</package>
  <item><package>arch-buildpackage</package>
  </list>
  </list>

  <p>Diese Kommandos automatisieren auch das Paketieren neuer Upstream-Releases.

  <sect id="upgrading">Überprüfen des Upgrades

  <p>Wenn Sie eine neue Version Ihres Pakets gebaut haben, sollten Sie
  folgende Schritte ausführen, um sicher zu stellen, dass Ihr Paket
  problemlos aktualisiert werden kann:
  <list>
    <item>Upgrade von der vorherigen Version
    <item>Downgrade zurück und dann löschen,
    <item>Installation des neuen Pakets (A.d.Ü.: ohne, dass
    eine vorherige  Version installiert ist),
    <item>Deinstallation, erneute Installation,
    <item>dann ein "Purge".
  </list>

  <p>Wenn das Paket nicht triviale pre/post/inst/rm-Skripte enthält, testen Sie
  unbedingt deren Verhalten während einer Aktualisierung.

  <p>Wenn Ihr Paket in einer früheren Version schon in Debian integriert
  ist, vergessen Sie nicht, auch gegen diese Version zu testen, weil viele
  Leute die Version aus dem letzten Debian-Release upgraden werden.

  <chapt id="helpme">Wo bekommt man Hilfe?

  <p>Bevor Sie sich dazu entschließen, Ihre Frage irgendwo zu
  veröffentlichen, versuchen Sie es zuerst mit RTFM.
  Dazu gehören Dokumentationen in <file>/usr/share/doc/dpkg</file>,
  <file>/usr/share/doc/debian</file>, <file>&autotools-dev;</file>, Dateien in
  <file>/usr/share/doc/package/*</file> und die man/info-Seiten für alle
  Programme, die in diesem Artikel erwähnt wurden.
  Siehe auch alle Informationen auf <url id="&nm-home;"> und
  <url id="&mentors-faq;">.

  <p>Wenn Sie Fragen zum Paketieren haben und in der Dokumentation keine
  Antworten finden, können Sie in der Debian Mentors-Mailingliste unter
  <email/debian-mentors@lists.debian.org/ nachfragen. Erfahrenere Entwickler
  werden Ihnen gern helfen, aber Sie sollten sich zumindest die
  Dokumentation durchlesen, bevor Sie fragen!

  <p>Mehr Informationen zu der Mailingliste finden Sie unter:
  <url id="http://lists.debian.org/debian-mentors/">.

  <p>Wenn Sie einen Bug-Report erhalten (ja, richtige Bug-Reports!),
  dann wissen Sie auch, dass es an der Zeit ist, sich näher mit der
  <url name="Fehlerdatenbank" id="http://www.debian.org/Bugs/"> zu
  beschäftigen, d.h. die Doku dort zu lesen, um mit den Reports
  effizient umgehen zu können. Sie sollten unbedingt die "Developers'
  Reference", Kapitel "Handling Bugs", in <file>&bughandling;</file> lesen.

  <p>Wenn Sie dann immer noch Fragen haben, dann stellen Sie diese auf der
  "Debian Developers"-Mailingliste über <email/debian-devel@lists.debian.org/.
  Mehr Informationen erhalten Sie bei
  <url id="http://lists.debian.org/debian-devel/">.

  <p>Auch wenn alles richtig funktioniert hat, ist es jetzt Zeit für ein
  Gebet. Warum? Weil in wenigen Stunden (oder Tagen) die Benutzer aus
  aller Welt ihr Paket benutzen werden - und da Sie irgendwo kritische
  Fehler gemacht haben, werden Sie von Tausenden von verärgerten
  Debian-Benutzern zugemailt ... Nur ein Scherz. :-)

  <p>Entspannen sie Sich und machen Sie sich auf Bug-Meldungen gefasst,
  da i.d.R. noch viel Arbeit zu erledigen ist, bis Ihr Paket
  den "Debian policies" vollständig entspricht (und noch einmal: lesen Sie
  in der <em>richtigen Dokumentation</em> über Details). Viel Glück!

  <appendix id="pkg-eg">Beispiele

  <p>Jetzt paketieren Sie den Quellcode-Tarball <var>gentoo-1.0.2</var>.tar.gz
  und laden alle Pakete nach <tt><var>NM_Ziel</var></tt> hoch.

  <sect id="pkg-simple">Einfaches Beispielpaket

  <p><example>
$ mkdir -p <var>/Pfad/zu</var> # neues leeres Verzeichnis
$ cd <var>/Pfad/zu</var>
$ tar -xvzf <var>/Pfad/von/gentoo-1.0.2</var>.tar.gz # Quellcode auspacken
$ cd <var>gentoo-1.0.2</var>
$ dh_make -e <var>Name@Domain.com</var> -f <var>/Pfad/von/gentoo-1.0.2</var>.tar.gz
... Fragen beantworten
... Quellcode anpassen
... Wenn es ein Skript-Paket ist, in der Datei debian/control
    "Architecture: all" eintragen.
... Die Datei ../<var>gentoo_1.0.2</var>.orig.tar.gz nicht löschen.
$ debuild
... Darauf achten, dass keine Warnungen auftreten.
$ cd ..
$ dupload -t <var>NM_Ziel</var> <var>gentoo_1.0.2-1</var>_i386.changes
  </example>

  <sect id="pkg-dpatch">Beispielpaket mit <package>dpatch</package> und
  <package>pbuilder</package>

  <p><example>
$ mkdir -p <var>/path/to</var> # neues leeres Verzeichnis
$ cd <var>/Pfad/zu</var>
$ tar -xvzf <var>/Pfad/von/gentoo-1.0.2</var>.tar.gz
$ cp -a  <var>gentoo-1.0.2</var> <var>gentoo-1.0.2-orig</var>
$ cd <var>gentoo-1.0.2</var>
$ dh_make -e <var>Name@Domain.com</var> -f /Pfad/von/<var>gentoo-1.0.2</var>.tar.gz
... Fragen beantworten
... Quellcode anpassen
... Erstellen Sie das Paket mit "dpkg-buildpackage -rfakeroot -us -uc"
... Quellcode anpassen bis das Paket richtig baut.
... Die Datei ../<var>gentoo_1.0.2</var>.orig.tar.gz nicht löschen.
$ cd ..
$ cp -a <var>gentoo-1.0.2</var> <var>gentoo-1.0.2-keep</var> # Sicherheitskopie
$ mv <var>gentoo-1.0.2</var>/debian debian
$ diff -Nru  <var>gentoo-1.0.2-orig</var> <var>gentoo-1.0.2</var> \
   &gt; <var>patch-file</var>
... Sie könnten damit das Verzeichnis <var>gentoo-1.0.2</var> überschreiben.
... Behalten Sie unbedingt <var>gentoo-1.0.2</var>-keep zur Sicherheit.
$ mkdir -p debian/patches
$ dpatch patch-template <var>patch-file</var> \
   -p "01_patchname" "patch-file description" \
   &lt; <var>patch-file</var> &gt; debian/patches/01_patchname.dpatch
$ cd debian/patches
$ echo 01_patchname.dpatch >00list
$ cd ../.. # zurück zu <var>/Pfad/zu</var>
$ rm -rf <var>gentoo-1.0.2</var>
$ editor debian/rules
  </example>
  Die Datei <file>debian/rules</file> sieht original so aus:
  <example>
config.status: configure
     ./configure --prefix=/usr --mandir=/usr/share

build: config.status
     ${MAKE}

clean:
     $(testdir)
     $(testroot)
     ${MAKE} distclean
     rm -rf debian/imaginary-package debian/files debian/substvars
  </example>
  Ändern Sie die Datei <file>debian/rules</file> folgendermaßen, um
  <package>dpatch</package> nutzen zu können:
  <example>
config.status: patch configure
     ./configure --prefix=/usr --mandir=/usr/share

build: config.status
     ${MAKE}

clean: clean-patched unpatch

clean-patched:
     $(testdir)
     $(testroot)
     ${MAKE} distclean
     rm -rf debian/imaginary-package debian/files debian/substvars

patch: patch-stamp

patch-stamp:
     dpatch apply-all
     dpatch call-all -a=pkg-info >patch-stamp

unpatch:
     dpatch deapply-all
     rm -rf patch-stamp debian/patched
  </example>
  <p>
  Jetzt sind Sie so weit, den Quellcode mit dem <package>dpatch</package>-System
  neu zu packen.
  <example>
$ tar -xvzf <var>gentoo_1.0.2</var>.orig.tar.gz
$ cp -a debian/ <var>gentoo-1.0.2</var>/debian
$ cd <var>gentoo-1.0.2</var>
$ sudo pbuilder update
$ pdebuild
$ cd /var/cache/pbuilder/result/
$ dupload -t <var>nm_target</var> <var>gentoo_1.0.2-1</var>_i386.changes
  </example>


  </book>

</debiandoc>
