<!DOCTYPE debiandoc PUBLIC "-//DebianDoc//DTD DebianDoc//EN" [
 
         <!-- textual data entities -->
         <!-- first definition wins in SGML -->
 <!ENTITY % default  SYSTEM "default.ent">  %default;
 
 ]>
 <!-- CVS revision of this document "$Revision: 1.7 $"  -->
 <!-- CVS revision of original english document "1.97"  -->
 
 
 <debiandoc>
 
  <book>
 
   <titlepag>
 
    <title>Debian新維護人員手冊</title>
 
    <author>Josip Rodin <email/joy-mg@debian.org/
    </author>
 
    <author>華文版翻譯：李凌 <email/lilingv@gmail.com/
    </author>
    <author>華文版翻譯：鄭原真 <email/ycheng@slat.org/
    </author>
 
    <version>version 1.2.3, 2005年4月3日.</version>
 
    <copyright>
    <copyrightsummary>版權所有 &copy; 1998-2002 Josip Rodin.</copyrightsummary>
 
    <p>本文件可以在GNU通用公眾授權的第2或更新的版本下使用。
 
    <p>This document was made using message these two documents as examples:
 
    <p>Making a Debian Package (AKA the Debmake Manual), copyright &copy;
    1997 Jaldhar Vyas.
 
    <p>The New-Maintainer's Debian Packaging Howto, copyright &copy; 1997
    Will Lowe.
    </copyright>
 
   </titlepag>
 
   <toc sect>
 
   <chapt id="start">從一條正確的路開始
 
   <p>這篇文章為普通的Debian使用者和希望能夠對Debian套件有所了解的開發人員講述
      了製作Debian套件的方法。它使用了非常通用的語言，並且透過一個可以工作的
      例子進行了演示。有一句古老的羅馬諺語說的好：<em>Longum iter est per
      preaecepta, breve et efficax per exempla!</em>(透過理論要講述很久的問題，
      可以很快地用例子說明白。)
 
   <p>Debian能夠成為一個高品質的Linux發行版的重要原因之一就是它的套件系統。
      盡管已經存在相當大量的用Debian格式打包裝檔的軟體，有時你還是需要安裝一些不是
      這一格式的軟體。可能你會為如何製作自己的套件而彷徨，而且也許你會認為這
      是一個非常困難的工作。是的，如果你是一個Linux初學者，那麼這的確很難，不過
      如果你真的是一個新手，現在你也就不會來讀這個文件了。:-) 你的確需要
      對Unix的程式設計有所了解，但你並不需要是這方面的天才。
 
   <p>有一件事情是非常明確的：如果你希望建立並維護一個Debian的套件，那將花費
      你數個小時的時間。作為一個維護人員，為了能夠不犯錯誤，讓我們的系統很好地
      工作，必須有良好的技術基礎且非常勤奮。
 
   <p>這篇文件將會講述每一個細節(開始時也許給人感覺毫不相關)的步驟，並且幫助你
      建立第一個套件，從而讓你學習到可以幫助你製作它的下一個版本或是其它安裝
      包裝檔的經驗。
 
   <p>這個文件的更新版本可以在<url name="http://www.debian.org/doc/maint-guide/"
      id="http://www.debian.org/doc/maint-guide/">和“<package/maint-guide/”安
      裝包裝檔中找到。這個文件的華文翻譯版本也可以在“<package/maint-guide-xy/”安裝
      包裝檔中找到。
 
   <sect id="needprogs">開發時需要的軟體
 
   <p>在開始之前，你需要確認你是否已經正確安裝了一些額外在開發時需要的安裝
      包裝檔。注意這裡列出的軟體都沒有標記為“essential”或是是“required”──我們希望
      你能夠安裝好這些軟體。
 
   <p>這個文件的目前版本已經為Debian 2.2(“potato”)和3.0(“Woody”)更新過了。
 
   <p>下面列出的這些軟體在Debian的標準安裝中已經有了，因此它們在你的機器上應
      當已經安裝好了(也包裝檔括它們依賴的其它套裝軟體)。然而，你還是應該
      用“dpkg -s &lt;package&gt;”來檢查一下。
 
   <list>
   <item>
      <package/dpkg-dev/ - 這個套裝軟體包裝檔括了在解開、製作、上傳Debian來源檔案包裝檔時
      需要用到的工具。(參考<manref name="dpkg-source" section="1">)
 
   <item>
      <package/file/ - 這個小程式可以偵測檔案的類型。(參考 <manref name="file"
      section="1">)
 
   <item>
      <package/gcc/ - GNU C語言編譯器，如果你的程式是和其它很多程式一樣用C語
      言編寫，那麼就需要這個套裝軟體。(參考 <manref name="gcc" section="1">)這
      個套裝軟體還會“pull in”其它幾個套裝軟體，比如包裝檔括匯編(assemble)和鏈
      接(link)目的檔案的程式的套裝軟體<package/binutils/(參
      考<package/binutils-doc/套裝軟體中的“info binutils”)和C預先處理
      器(preprocessor)<package/cpp/(參考<manref name="cpp" section="1">)。
 
   <item>
      <package/g++/ - GNU C++語言編譯器，如果你的程式是用C++語言寫的那就需要
      它。(參考<manref name="g++" section="1">)
 
   <item>
      <package/libc6-dev/ - gcc需要的用於連結和建立目的檔案的C函式庫和頭文
      件。(參考<package/glibc-doc/套裝軟體中的“info libc”)
   
 
   <item>
      <package/make/ - 通常建立一個程式的程序需要經過好幾步，為了能夠不把同樣
      的命令一遍又一遍的輸入，你可以用這個程式透過建立“Makefile”來使這個程序
      自動化。(參考“info make”)
 
   <item>
      <package/patch/ - 這是一個非常有用的工具，它可以把(用diff程式產生的)包裝檔
      含有一個相異列表的檔案套用到原先的檔案上去，從而產生一個補綴版本。(參
      考<manref name="patch" section="1">)
 
   <item>
      <package/perl/ - Perl是在當今的Unix類系統上套用得非常廣泛的解釋型腳本語
      言之一，它通常被稱作“Unix的瑞士軍刀”。(參考 <manref name="perl"
      section="1">)
   </list>
 
   <p>你也很可能會想要安裝下面的套裝軟體：
 
   <list>
   <item>
      <package/autoconf/和<package/automake/ - 很多新的程式在這一類工具的幫助
      下來組態腳本檔案並對Makefiles進行預先處理。(參考“info autoconf”和“info
      automake”)
 
   <item>
      <package/dh-make/和<package/debhelper/ - 在例子中建立我們的套裝軟體時需要
      使用dh-make來建立它的骨架，並且要使用到一些debhelper套裝軟體中的工具。他
      們對於建立套裝軟體不是最基本的，但對於新的維護者則是<strong>強
      烈</strong>推薦使用的。它們使得整個程序的開始變得很容易且使後續的程序容
      易控制。(參考<manref name="dh_make" section="1">、<manref
      name="debhelper" section="1">和/usr/share/doc/debhelper/README)
 
   <item>
      <package/devscripts/ - 這個套裝軟體中包裝檔括了一些非常好的且很有用的腳本程
      序，它們對於維護者是很有用的，但它們對建立套裝軟體也不是必需的。(參
      考/usr/share/doc/devscripts/README.gz)
 
   <item>
      <package/fakeroot/ - 這個工具使你可以模擬變成root使用者，這在建立套裝軟體的
      程序的一些部分是必要的。(參考<manref name="fakeroot" section="1">)
 
   <item>
      <package/gnupg/ - 一個可以讓你對你製作的套裝軟體進行數位<em>簽名</em>的工
      具。如果你希望把它發佈給其它人，這個步驟是非常重要的，並且當你所做的工
      作被加入到Debian發行版中時就必需進行這一步。(參考<manref name="gpg"
      section="1">)
 
   <item>
      <package/g77/ - GNU Fortran 77語言編譯器，如果你的程式是用Fortran語言編
      寫的就需要它了。(參考<manref name="g77" section="1">)
 
   <item>
      <package/gpc/ - GNU Pascal語言編譯器，如果你的程式是用Pascal語言寫的，
      就需要它了。這裡值得一提的是套裝軟體<package/fp-compiler/，自由Pascal編
      譯器(the Free Pascal Compiler)，它也是一個完成這一工作的好選擇。(參
      考<manref name="gpc" section="1">和<manref name="ppc386" section="1">) 
 
   <item>
      <package/xutils/ - 一些程式，通常是為X11編寫的程式，也使用這些程式透過
      一套巨集來產生Makefile檔案。(參考<manref name="imake" section="1">和<manref
      name="xmkmf" section="1">)
 
   <item>
      <package/lintian/ - 這是一個Debian套裝軟體檢查器，它可以在你建立套裝軟體後
      為你找出一些常見的錯誤，並解釋這些錯誤。(參考<manref name="lintian"
      section="1">和/share/doc/lintian/lintian.html/index.html)
 
   <item><package/pbuilder/ - 這個套裝軟體中包裝檔含了用於建立和維護chroot環境的程
      序。在此chroot環境中建立Debian可以檢查建立套裝軟體的依賴關係的正確性並防
      止FTBFS錯誤發生。(參考<manref name="pbuilder" section="8">和<manref
      name="pdebuild" section="1">)
   </list>
 
   <p>下面列出的這些文件都<em>非常重要</em>，你在閱讀本文件時也應當閱讀它們：
 
   <list>
   <item>
      <package/debian-policy/ - 政策(Policy)檔案中包裝檔含了對很多內容的解釋，比
      如Debian檔案的結構及內容、幾個關於作業系統設計的問題、檔案系統層次標
      准(講述了每個檔案和目錄應該存在的地方)等等。對你來說，最重要的是它描述
      了在加入每個套裝軟體到發行版中時，它們必須滿足的要求。(參考&debian-policy;)
 
   <item>
      <package/developers-reference/ - 包裝檔含了全部的參考資料，其內容不只是打包裝檔
      軟體的技術細節，比如文件的結果、如何改名、孤兒、選擇套裝軟體、如何做NMUs、
      如何管理bugs、最佳包裝實務以及在什麼時間將套裝軟體上傳到什麼位置等等。(參
      考&developers-reference;)
   </list>
 
   <p>上面的簡短描述只是對每一個套裝軟體進行了一下簡單的介紹。在繼續後面的工作
      前，請完整的閱讀每一個程式的文件，至少要了解基本的使用方式。現在看來也許是
      很繁重的工作，不過以後你會非常<em>高興</em>的去閱讀它們的。
 
   <p>注意: <package/debmake/套裝軟體中包裝檔含了一些和dh-make作用相似的程式，但它
      的詳細使用方式並<strong>沒有</strong>包裝檔含在這份文件中，因為它已經<em>不推
      薦</em>使用了。要得到更多的資訊，請參考<url name="the Debmake manual"
      id="http://www.debian.org/~jaldhar/">。
 
   <sect id="otherinfo">其它資訊
 
   <p>你可以製作的套裝軟體有兩種，來源檔案版本和可執行版本。來源檔案版本的套裝軟體包裝檔
      含了可以被編譯成程式的來源程式碼。可執行版本的套裝軟體只包裝檔含編譯好的檔案。不
      要把程式來源檔案和程式的來源檔案版本套裝軟體混在一起！如果你需要更詳細的關於
      這些字匯的資料，請參考閱讀其它的手冊。
 
   <p>在Debian中，“維護者(maintainer)”一字指的是製作套裝軟體的人，“上游作
      者(upstream author)”指的是編寫程式的人，而“上游維護
      者(upstream maintainer)”是指在Debian項目之外維護著程式的人。一般情況下
      作者和上游維護者是同一個人──有時維護者甚至也是同一個人。如果你編寫了一
      個程式並且希望它被包裝檔含到Debian中，那麼你可以提交你的程式從而成為一個維
      護者。
 
   <p>在你建立了你的套裝軟體(或則正在做這件事情)，若你希望它能夠被加入到下一個
      發行版中(如果你的程式非常有用，為什麼不呢？)，那麼你必須成為一個正式
      的Debian維護者。這一程序在開發人員參考(Developer's Reference)中解釋了。
      請閱讀它。
 
   <chapt id="first">第一步
 
   <sect id="choose">選擇你的程式
 
   <p>你大概已經選好了你要製作的套裝軟體。首先要做的事情是檢查它是否已經在發行
      版中了。如果你使用的是“穩定”發行版，那麼你最好到<url
      name="套裝軟體查詢頁面" id="http://www.debian.org/distrib/packages">查一
      下。如果你使用的是<strong>目前的</strong>“不穩定”發行版，可以用下面的命
      令來檢查：
   <example>
   dpkg -s program
   dpkg -l '*program*'
   </example>
 
   <p>如果套裝軟體已經存在了，那麼好，安裝它！:-) 如果他碰巧是個孤兒──如果它的
      維護者成為了“Debian QA Group”的成員，你就應該可以重新維護它。查詢<url
      name="孤兒套裝軟體列表" id="http://www.debian.org/devel/wnpp/orphaned">
      和<url name="打算收養的套裝軟體列表"
      id="http://www.debian.org/devel/wnpp/rfa_bypackage">可以確認套裝軟體是否
      真的需要領養。
 
   <p>如果你獲准收養一個套裝軟體，那就獲取它們的來源程式碼(用<tt/apt-get source
      packagename/一類的命令)並檢查它們。很不幸，這份文件中並不包裝檔含關於收養軟
      件包裝檔的詳細資訊。值得慶幸的是，在收養套裝軟體時，你不用花費很多時間在找出
      如何讓其工作，因為已經有人為你做了初始的設定工作。盡管如此，也請繼續讀
      下去，下面的很多建議也會對你所處的情況有用。
 
   <p>如果套裝軟體是新的，並且你已經決定讓它出現在Debian中，請按照下面的步驟來
      做：
 
   <list>
   <item>到<url name="正在製作中的套裝軟體列表"
      id="http://www.de.debian.org/devel/wnpp/being_packaged">檢查是否沒有其
      它人正在為打包裝檔同一個軟體而工作。如果已經有人正在做了，並且你覺得它對你
      很重要，就請和他們取得洽詢。否則──找另一個沒人維護的有趣程式吧。
   </item>
 
   <item>每一個軟體都<strong>必須</strong>有授權，如果有可能最好是像<url
      name="Debian自由軟體指導方針"
      id="http://www.debian.org/social_contract#guidelines">中說的那樣屬於自
      由軟體。如果它並不遵守這些規則但仍然可以以任意形式發佈，它也還可以被加
      入到“contrib”或是“non-free”部分中。如果你不確定它究竟應該被放到哪裡，可
      以把它的授權文字發到
   <email/debian-legal@lists.debian.org/問一下該怎麼做。
   </item>
 
   <item>程式的確<strong>不</strong>應當以setuid root的方式執行，或是最好它應
      該不需要setuid或setgid成為其它任何東西。
   </item>
 
   <item>程式不能是一個背景作業程式，且它不應該放到*/sbin目錄中去，也不該以root身
      份開啟一個連接埠。
   </item>
 
   <item>程式最終應當是二進位可執行的形式，庫處理起來要困難一些。</item>
 
   <item>它應當有很好的文件，最好連來源程式碼也是容易理解的(比如不混亂)。</item>
 
   <item>你應該與程式的作者取得洽詢問一下他是否同意程式被打包裝檔。能夠向作者咨詢
      關於程式的任何問題是非常重要的，不要試著去打包裝檔一個沒有人維護的軟體。
   </item>
 
   <item>最後的但並不是不重要的，你必須知道它確實可以工作並且已經試著使用了一段時間。
   </item>
   </list>
 
   <p>當然，這些問題都是只是為了安全，並試著讓你不至於在比如setuid的守護進程
      等問題上犯錯誤而激怒了使用者。當你有了在打包裝檔軟體方面的更多經驗時，你就可
      以處理那種套裝軟體了，但即便是富有經驗的開發人員在他們疑惑時也會發信件
      到debian-mentors信件列表咨詢。那裡的人們會很樂意提供幫助的。
 
   <p>要獲得關於這些內容的更多幫助，請參考開發者參考手冊。
 
   <sect id="getit">獲得程式，並且試用它
 
   <p>第一件要做的事情就是找到並下載原始的套裝軟體。我假定你已經從作者的首頁上
      找到它的來源檔案了。免費的Unix程式的來源檔案通常是以tar/gzip格式提供的，它
      的檔案副檔名是.tar.gz，並且通常還包裝檔含了以program-version形式命名的子
      目錄，裡面放著全部的來源檔案。如果你的程式來源檔案是以一些其它的形式提供
      的(比如，檔案名稱是以“.Z”或“.zip”結尾的)，那麼就用適當的工具把它解開，或
      者如果你不清楚應當如何正確把它解開，就在debian-mentors信件列表上問一
      下。(提示：可以用命令“file archive.extension”)
 
   <p>作為一個例子，我將會使用程式“gentoo”，它是一個基於X GTK+的檔案管理器。
      需要注意的是，這個程式已經被打包裝檔好了，並且從寫這篇文件之初到現在它已經
      發生了很大的變化。
 
   <p>在你的home目錄中建立一個名為“debian”或是“deb”或是任何你喜歡的名字的目
      錄(比如在這個例子中~/gentoo/就可以了)。把下載的檔案放到這個目錄中，然後
      將其解開(用命令“tar xzf gentoo-0.9.12.tar.gz”)。確認在這個程序中沒有發
      生錯誤，即便是一點“不恰當”的也不行，因為當在別人的系統上解開這些檔案的
      時候，如果它們的工具並不忽略這些反常的現象，那就會有了。
 
   <p>現在又有了一個新的子目錄，名叫“gentoo-0.9.12”。進入這個目錄並且<strong>徹
      底</strong>的讀完其中的文件。一般情況下在目錄裡面會有名
      叫README*、INSTALL*、*.lsm或是*.html的檔案。你必需找到如何正確編譯並安
      裝程式的指導。(最有可能的是它們會假設你希望把程式安裝到/usr/local/bin目
      錄中；你不需要這樣做，但在後面的<ref id="destdir">中需要做很多事情。)
 
   <p>安裝的程序對於不同的軟體是不同的，但很多現代的程式都帶有一個“configure”
      腳本檔案，這個檔案設定你系統上的來源檔案，並確認你的系統已經可以編譯它了。
      在透過“./configure”命令設定之後，通常可以透過“make”來編譯程式。有一些程
      序還會支援透過“make check”命令來進行自我檢查。把程式安裝到目標目錄中的命令
      通常是“make install”。
 
   <p>現在可以試著編譯並執行你的程式了，從而確定它可以很好的工作並且在它安裝
      或工作時不會破壞其它程式的執行。
   
   <p>另外，通常你還可以透過“make clean”(或是更好的“make distclean”)命令來清
      理build目錄。有時還會有一個“make uninstall”命令來刪除所有已經安裝的檔案。
 
   <sect id="namever">套裝軟體名稱和版本
 
   <p>在開始打包裝檔時，來源程式目錄應當是絕對乾淨(原始)的，或是直接從剛剛解開的來源
      代碼目錄開始。
   
   <p>為了讓套裝軟體能夠正確地製作，你必須把程式原有的名字改成小寫(如果它不是
      的話)，並且你應該把來源程式碼目錄的名字改
      成&lt;packagename&gt;-&lt;version&gt;的形式。
   
   <p>如果程式的名字是由多於一個的英文單字組成的，那就把它改成一個單字，或是
      縮寫的形式。例如，程式“John's little editor for X”套裝軟體可以改
      成johnledx或是jle4x，或是隨便什麼你認為合適的，只要它符合一些很合理的
      限制，比如在20個字元以內。
 
   <p>另外要做的一件事情就是檢查一下被包裝檔裝在套裝軟體裡的程式的精確版本號(它將被
      包裝檔含在套裝軟體的版本號中)。如果包裝檔裝的軟體並不是以X.Y.Z的方式來命名它的版
      本的，而是用比如日期一類的方式，那麼就用那個日期來做版本號好了，只要在
      前面加上“0.0.”就可以了(直到上游的人決定發佈一個好的版本比如1.0等時候)。
      因此，如果發行版或是snapshot的日期是1998年12月19日，你就可以使
      用0.0.19981219作為版本號。
 
   <p>有一些程式根本就沒有數位的版本，在這種情況下，你就需要和上游維護者取得
      洽詢，看看他們是不是使用了什麼別的版本追蹤方法。
 
   <sect id="dh_make">首次“Debian化”
 
   <p>確定你在程式原始碼目錄中，然後執行這個命令：
 
   <p><example>
   dh_make -e your.maintainer@address -f ../gentoo-0.9.12.tar.gz
   </example>
 
   <p>當然，要用你的E-mail位址換掉字串“your.maintainer@address”，並用你的來源
      代碼文件的名字取代掉上面的檔案名稱。你的這個E-mail位址將會被包裝檔含在changlog
      項目和其它的檔案中。參考<manref name="dh_make" section="1">獲得詳細的信
      息。
  
   <p>在執行這個命令後，你將會看到一些資訊，它會問你你需要建立那種類型的軟體
      包裝檔。Gentoo是一個單二進位套裝軟體──它只建立一個二進位形式的套裝軟體，也就是
      說只有一個.deb檔案──所以我們按“s”鍵選擇第一個選項，檢查螢幕上的資訊，
      然後按&lt;enter&gt;鍵確認。
 
   <p>在此次執行<prgn>dh_make</prgn>之後，上游的套裝軟體將會被打包裝檔
      為<file>gentoo_0.9.12.orig.tar.gz</file>並放在父目錄中，以便
      用<file>diff.gz</file>建立非Debian原有的來源程式碼包裝檔。請注意檔案名稱中的兩個
      關鍵點：
   <list compact>
   <item>包裝檔名稱和版本是以“<tt>_</tt>”分割的。
   <item>在之前“<tt>tar.gz</tt>”有“<tt>orig.</tt>”。
   </list>
 
   <p>再說一下，作為一個新的維護者，我們不鼓勵你建立複雜的套裝軟體，譬如：
   <list compact>
   <item>產生多個二進位包裝檔的，
   <item>庫套裝軟體，
   <item>來源檔案格式不是<tt>tar.gz</tt>也不是<tt>tar.bz2</tt>，或是
   <item>在來源碼包裝檔中包裝檔含的是不可發佈的內容。
   </list>
   要說清這些問題並不是很難，但你確實需要了解更多一些的知識，因此在這裡講述關
   於它們的全部內容。
 
   <p>請注意你只能執行<strong>一次</strong><prgn>dh_make</prgn>程式，如果你再
      次在同一個已經“Debian化”的目錄中執行它，它將不能正常執行。這也意味著當
      你要發佈你的軟體的下一個版本時，你需要使用一些不同的方法。以後你會在
      <ref id="update">一部分中讀到更多關於這個問題的內容。
 
   <chapt id="modify">修改來源程式碼
 
   <p>一般情況下，程式會把它們自己安裝到/usr/local子目錄中。但是Debian的軟體
      包裝檔絕對不能使用那個目錄，因為它被保留給系統管理員(或是使用者)使用。這就是
      說你必需要仔細看一下你的程式的建構系統(build system)，通常從Makefile開
      始。它是<manref name="make" section="1">將會使用的用於自動建構程式的腳
      本。要了解更多關於Makefiles的內容，請參考<ref id="rules">。
 
   <p>注意如果你的程式使用了GNU的<manref name="automake"
      section="1">和/或<manref name="autoconf" section="1">，也就意味著來源程式碼
      是在Makefile.am和/或Makefile.in檔案中，相對的，你需要修改這些檔案。這是
      因為在每一次automake的執行中，Makefile.in等檔案中的資訊將會通
      過Makefile.am等檔案來重新產生，並且每次執行./configure時，類似的操作會
      執行在Makefile等檔案上，它們會被根據Makefile.in檔案重新產生。修
      改Makefile.am檔案需要一些關於automake的知識，你可以閱讀automake的info項
      目，然而修改Makefile.in檔案和修改Makfile檔案是差不多的，不過要注意一下
      變數，例如，任何被“@”包裝檔圍的字串如@CFLAGS@或@LN_S@將會在每次
      ./configure 執行時用實際的值取代掉。
 
   <p>還需要注意的是，在這裡我們沒有地方討論所有的修改上游來源程式碼的細節，這裡
      我們只有一些人們經常會會遇到的問題。
 
   <sect id="destdir">在一個子目錄中安裝
 
   <p>大多數的程式都能夠以某種方式把自己安裝到系統現有的目錄結構上，所以它們
      的可執行檔案已經存在於你的$PATH中，並且你也可以在一般的位置找到它們的文
      檔和手冊。然而，如果你這樣做，這些程式將會和你系統上的其它程式混合在一
      起。這樣的話，對於打包裝檔工具而言要想把它們同不屬於這個套裝軟體的程式區分開
      就很困難了。
 
   <p>因此，你還必須要做一些其它的事情：把程式安裝到一個臨時的子目錄中，從這
      裡打包裝檔工具可以建立一個可以工作的.deb套裝軟體。在這個目錄中的所有內容都將
      會被安裝到使用者的系統中，當他們安裝你的套裝軟體時，唯一的不同是dpkg將會把
      這些檔案安裝到檔案系統的根目錄上。
 
   <p>這個暫時檔案目錄通常建立在來源程式碼目錄的debian/子目錄中。一般情況下，它的
      名字是<file>debian/packagename</file>。
 
   <p>有一件事情請記住，盡管你要把程式安裝到debian/packagename目錄中，但在安
      裝.deb檔案的時候，它仍應當可以正常地安裝到根目錄中。所以你絕對不能讓軟
      件包裝檔的建構系統把類似
      於<tt>/home/me/deb/gentoo-0.9.12/usr/share/gentoo</tt>的字串寫入到軟
      件包裝檔中。
 
   <p>對於使用GNU autoconf的程式而言，這個工作是非常簡單的。大多數這樣的程式
      的makefile腳本預設狀態下就允許程式被安裝到任何的子目錄中，並以(例如)/usr
      作為它的典型前綴。當偵測到你的程式使用了autoconf時，dh_make發現將會自動
      設定命令完成這一工作，因此你可以略過下面的部分。但對於其它的程式，你極
      有可能不得不檢查並修改Makefile檔案。
 
   <p>這裡是gentoo的Makefile檔案的相應部分：
 
   <p><example>
   # Where to put binary on 'make install'?
   BIN     = /usr/local/bin
 
   # Where to put icons on 'make install'?
   ICONS   = /usr/local/share/gentoo
   </example>
 
   <p>我們發現這個檔案被設定成為安裝到<file>/usr/local</file>目錄下。將這些路
      徑改為：
 
   <p><example>
   # Where to put binary on 'make install'?
   BIN     = $(DESTDIR)/usr/bin
 
   # Where to put icons on 'make install'?
   ICONS   = $(DESTDIR)/usr/share/gentoo
   </example>
 
   <p>但為什麼要在這個目錄中而不是其它的呢？這是因為Debian絕不會把檔案安裝
      到<file>/usr/local</file>目錄中──那個目錄是留給系統管理員用的。這些檔案
      在Debian系統上都會被安裝到<file>/usr</file>目錄下。
 
   <p>在檔案系統層次標準中描述了更多的關於二進位、圖示、文件等檔案放置位置的
      資訊(請參考/usr/share/doc/debian-policy/fhs/)。我建議你瀏覽一下其中可能
      與你的套裝軟體有關的部分。
 
   <p>因此，我們應該把二進位檔案安裝在/usr/bin目錄中而不是/usr/local/bin目錄
      中，把手冊安裝在/usr/share/man/man1目錄中而不是/usr/local/man/man1目錄
      中。也許你注意到在gentoo的makefile中並未涉及到手冊檔案，但Debian政策要
      求每個程式都要有一篇手冊，因此我們稍後會製作一份並把它安裝
      到/usr/share/man/man1中。
 
   <p>有一些程式並不像這樣使用makefile的變數來定義其路徑。這就意味著你不得不
      去修改一些C來源程式來使其能夠在正確的位置找到檔案。但到哪裡去找又改找些什
      麼呢？你可以使用這樣的命令：
 
   <p><example>
   grep -nr -e 'usr/local/lib' --include='*.[c|h]' .
   </example>
 
   <p>grep會遞歸地搜索整個來源程式碼目錄樹，並在找到相對的字串時告訴你它所在文
      件的名字和在檔案中所處行的行號。
 
   <p>修改那些檔案，並用usr/*取代掉原來的/usr/local/*以及所有相關的內容。注意
      不要為了修改這些地方而把代碼的其它部分搞亂。 :-)
 
   <p>之後，你應該找到install目標(尋找以“install:”開始的行)並修改所有對於目錄
      的參照，使其和在Makefile的開始部分定義的一致。最初的時
      候，gentoo的install目標是下面的樣子：
 
   <p><example>
   install:        gentoo
                   install ./gentoo $(BIN)
                   install icons/* $(ICONS)
                   install gentoorc-example $(HOME)/.gentoorc
   </example>
 
   <p>在我們修改以後它變成了這個樣子：
   <example>
   install:        gentoo-target
                   install -d $(BIN) $(ICONS) $(DESTDIR)/etc
                   install ./gentoo $(BIN)
                   install -m644 icons/* $(ICONS)
                   install -m644 gentoorc-example $(DESTDIR)/etc/gentoorc
   </example>
 
   <p>你一定已經注意到在其它命令之前有一個<tt>install -d</tt>命令。原來
      的makefile腳本沒有它是因為一般情況下在運
      行“make install”時，/usr/local/bin和其它的目錄都已經存在於檔案系統上了。
      然而，我們是要把檔案安裝到我們的空的(或是是根本不存在的)目錄中，因此我
      們不得不首先建立每一個目錄。
 
   <p>在rule檔案的結尾，我們還可以加入其它的內容，比如安裝上游作者忽略掉的附
      加文件，如下所示：
   <p><example>
                   install -d $(DESTDIR)/usr/share/doc/gentoo/html
                   cp -a docs/* $(DESTDIR)/usr/share/doc/gentoo/html
   </example>
 
   <p>細心的讀者應該已經注意到我把“install:”一行中的“gentoo”改成
      了“gentoo-target”。這被稱為無關bug修復 :-)
 
   <p>當你做了一些並不特定地與Debian套裝軟體相關的修改時，請一定要把它們發送給 
      上游的維護者，這樣這些修改就可以被包裝檔含在軟體的下一個版本中，這樣會對其
      他人非常有用。還要記住不要使你的修改只是針對Debian或是Linux(甚至
      是Unix！)，在發送它們之前──讓它們具有可移植性。這將會使你的修改更容易
      被接受。
 
   <p>注意，你不需要把debian/*檔案也發送給上游的人。
 
   <sect id="difflibs">不一樣的程式庫名稱
 
   <p>有一個非常普遍的問題：在不同的平台上連結程式庫通常是不一樣的。例
      如，Makefile中包裝檔含了對一個庫的參照，但Debian系統上並沒有這個程式庫。在這種
      情況下，我們需要把它修改成為一個在Debian中確實存在並且完成相同功能的庫。
 
   <p>因此，如果在你的程式的Makefile(或是Makefile.in)中有類似於下面的一行(並
      且使你的程式無法編譯了)：
 
   <p><example>
   LIBS = -lcurses -lsomething -lsomethingelse
   </example>
 
   <p>可以把它改成這樣，一般情況下它都能工作：
   <p><example>
   LIBS = -lncurses -lsomething -lsomethingelse
   </example>
 
   <p>(作者已經注意到這並不是最好的例子，因為我們現在使用的libncurses套裝軟體在
      發佈的時候包裝檔含了一個libcurses.so的符號連結，但他沒能想到更好的。歡迎你
      提些建議 :-) 
 
   <chapt id="dreq">debian/目錄中必需的內容
 
   <p>在程式的來源程式碼目錄中有一個名叫“debian”的新子目錄。在這個子目錄中有很多
      我們需要檔案，透過修改這些檔案可以訂製套裝軟體的行為。其中最為重要的
      是“control”、“changelog”、“copyright”和“rules”，它們對於所有的套裝軟體都
      是必需的。
 
   <sect id="control">“control”檔案
 
   <p>在這個檔案中包裝檔含了很多變數，<prgn/dpkg/、<prgn/dselect/和其它套裝軟體管理
      工具透過它們來管理套裝軟體。
 
   <p>dh_make為我們建立的control檔案如下所示：
 
   <p><example>
   1  Source: gentoo
   2  Section: unknown
   3  Priority: optional
   4  Maintainer: Josip Rodin &lt;joy-mg@debian.org&gt;
   5  Build-Depends: debhelper (>> 3.0.0)
   6  Standards-Version: 3.5.2
   7
   8  Package: gentoo
   9  Architecture: any
   10 Depends: ${shlibs:Depends}
   11 Description: &lt;insert up to 60 chars description&gt;
   12  &lt;insert long description, indented message spaces&gt;
   </example>
   (我為它增加了行號。)
 
   <p>1-6行是來源程式形式套裝軟體的控制資訊。
 
   <p>第1行是來源程式包裝檔的名字。
 
   <p>第2行是來源程式包裝檔在發行版中所屬部分。
 
   <p>你也許已經注意到了，Debian被分成許多不同的部分：包裝檔括main(自由軟
      件)、non-free(非自由軟體)和contrib(基於非自由軟體的自由軟體)。在這些部
      分中，還有子分類，這些子分類以簡短的方式說明了套裝軟體的用途。比
      如“admin”是只有系統管理員才能使用的程式，“base”是基本的工具，“devel”是
      給程式員使用的工具，“doc”是文件，“libs”是函式庫，“mail”是信件閱讀工具
      和背景作業程式，“net”是網路應用程式和背景作業程式，“x11”是不屬於以上各個部分
      的X11程式，還有更多這裡就不一一敘述了。
 
   <p>我們把它改成x11。(“main/”是預設的前綴，因此我們可以忽略它。)
 
   <p>第3行描述了在使用者安裝系統時此套裝軟體的重要程度。參考政策手冊中相對的指導
      可以知道應當把它設定成什麼。“optional”的優先等級對於新套裝軟體通常是合適的。
 
   <p>所屬部分和優先等級對<prgn/dselect/等前端軟體是有用的，它們在排序和選擇缺
      省的套裝軟體時會用到這些變數。當你把套裝軟體上傳到Debian以後，這兩個字串的
      值可以被文件維護員修改，在這種情況下，你會收到一封知會電子信件。
   
   <p>因為這是一個普通層級的套裝軟體，並且它不和其它任何套裝軟體衝突，我們讓它保
      留原來的“optional”。
 
   <p>第四行是維護者的姓名和電子信件位址。一定要保證這個字串包裝檔含有一個合法的
      電子信件“To: ”字串，因為在你把套裝軟體上傳以後，bug追蹤系統將會使用這個
      位址來傳遞知會bug資訊的電子信件給你。不要使用逗號、“&amp;”符號和括號。
 
   <p>第五行包裝檔括了要建立你的套裝軟體需要的套裝軟體列表。包裝檔括gcc和make在內的一些軟
      件包裝檔是不需要列出來的，關於此內容的詳細資訊可以參考軟體
      包裝檔<package/build-essential/。如果在建構你的套裝軟體時需要一些非標準的編譯
      器或是是其它的工具，你就需要把它們加到“Build-Depends”這一行上。多個項目
      之間用逗號隔開；要了解關於這個項目的語法的更多資訊，請閱讀關於二進位文
      件倚賴性的解釋。
 
   <p>你還可以在這裡加入Build-Depends-Indep、Build-Conflicts和其它一些字
      段。Debian的套裝軟體自動建構系統將會使用這些資料為其它的電腦平台建立二
      進制套裝軟體。可以參考政策手冊中關於build-dependencies的部分和程式員參考
      手冊，裡面包裝檔含有關於其它平台(體系結構)以及如何把軟體移植到上面的更多信
      息。
 
   <p>要想知道你的軟體在編譯的時候需要用到哪一個套裝軟體，可以透過下面的方法：
   <example>
   strace -f -o /tmp/log ./configure
   # or make instead of ./configure, if the package doesn't use autoconf
   for x in `dpkg -S $(grep open /tmp/log|\
                       perl -pe 's!.* open\(\"([^\"]*).*!$1!' |\
                       grep "^/"| sort | uniq|\
                       grep -v "^\(/tmp\|/dev\|/proc\)" ) 2>/dev/null|\
                       cut -f1 -d":"| sort | uniq`; \
         do \
           echo -n "$x (>=" `dpkg -s $x|grep ^Version|cut -f2 -d":"` "), "; \
         done
   </example>
   	 
   <p>要準確地找到建立<prgn><var>/usr/bin/foo</var></prgn>所需要的套裝軟體，執行：
   <example>
   objdump -p <var>/usr/bin/foo</var> | grep NEEDED
   </example>
   而要列出每一個庫，如<prgn>libfoo.so.6</prgn>，執行：
   <example>
   dpkg -S libfoo.so.6 
   </example>
   現在你已經安裝了“Build-deps”一項列出的每一個-dev套裝軟體。如果你使
   用<prgn>ldd</prgn>來完成這個工作，它會把並非直接使用的庫也報告出來，導致過
   多的建構依賴。
 
   <p>Gentoo還需要軟體
      包裝檔<package/xlibs-dev/、<package/libgtk1.2-dev/和<package/libglib1.2-dev/才
      能夠建構，因此我們把它們加到<package/debhelper/的後面。
 
   <p>第6行是這個套裝軟體遵循的Debian政策標準的版本，也就是你在製作這個套裝軟體時讀
      的政策手冊的那個版本。
   
   <p>第8行是二進位套裝軟體的名字。它通常和來源檔案套裝軟體有一樣的名字，但實際上並
      不一定得是這樣。
 
   <p>第9行描述了可以使用這個二進位套裝軟體的CPU類型。我們讓它保持原來的“any”值，
      因為<manref name="dpkg-gencontrol" section="1">會在為任何一種機器編譯這
      個套裝軟體時自動為這個字串填寫合適的值。
   
   <p>如果你的套裝軟體是體系結構無關的(比如一個shell或Perl腳本，或是是文件)，就
      把這個字串修改成“all”，另外在稍後還要仔細看一下<ref id="rules">中關於
      用“binary-indep”規則來代替“binary-arch”規則的內容。
 
   <p>第10行顯示了Debian套裝軟體系統的一個強大功能。套裝軟體可以透過多種不同的方
      式和其它的套裝軟體相關連。除了Depends:之外，還有其它的關聯字串，它們
      是Recommends:、Suggests:、Pre-Depends:、Conflicts:、Provides:和Replaces:。
 
   <p>在管理這些套裝軟體的關聯時，所有的套裝軟體管理工具通常的行為都是一樣的；如
      果不是這樣的話，它將會給出解釋。(參考<manref name="dpkg"
      section="8">、<manref name="dselect" section="8">、<manref name="apt"
      section="8">和<manref name="aptitude" section="1">等。)
 
   <p>下面給出每一種套裝軟體依存性的含義：
 
   <p><list>
   <item>Depends:
   <p>除非把此套裝軟體所倚賴的所有其它套裝軟體安裝好，否則套裝軟體將不會被安裝。你
      可以在除非提供了一個其它的套裝軟體，否則你的套裝軟體絕對不能執行(或是會導致
      嚴重的breakage)時使用這種關聯。</item>
 
   <item>Recommends:
   <p>dselect或是是aptitude等前端工具在安裝你的套裝軟體的時候，它們會問你是否將
      與該套裝軟體以推薦的方式相關聯的套裝軟體一起安裝；dselect甚至會堅持這樣做。
      而dpkg和apt-get會忽略這個字串。這個字串可以被用於那些並不是嚴格需要卻經
      常會和你的套裝軟體一起使用的套裝軟體。</item>
 
   <item>Suggests:
   <p>在一個使用者安裝你的軟體時，所有的前端工具都會詢問他是否要安裝被建議的軟
      件包裝檔。dpkg和apt-get不會這樣做。這個字串可以被用於那些可以和你的程式非常
      好地一起工作但並不是必需的套裝軟體。
   </item>
 
   <item>Pre-Depends:
   <p>它的要求比Depends:更強。除非它需要的套裝軟體已經安裝<em>並且正確配
      制</em>好，它才會被安裝。使用這個標籤是<strong>非常</strong>sparingly的，
      要使用它一定要先在debian-devel信件列表上討論完才可以。讀一遍這句話：絕
      對不要使用它。 :-)</item>
 
   <item>Conflicts:
   <p>除非與這個套裝軟體衝突的套裝軟體都已經被刪除了，否則它不會被安裝。如果一個
      套裝軟體存在時你的程式不能被執行或是會出現嚴重的錯誤，就使用這個標籤。
   </item>
 
   <item>Provides:
   <p>當多個套裝軟體提供同一個功能時，可以定義一些虛擬的套裝軟體名稱。你可以
      在/usr/share/doc/debian-policy/virtual-package-names-list.txt.gz檔案中
      找到一個完整的虛擬套裝軟體列表。當你的套裝軟體提供一個已經存在的虛擬套裝軟體
      所需要的功能時，可以使用這個字串。</item>
 
   <item>Replaces:
   <p>當你的套裝軟體會取代一些其它套裝軟體的檔案或是是整個套裝軟體(與Confilicts:聯
      用)時，可以使用這個字串。這裡提到的套裝軟體中的檔案將會被你的套裝軟體中的文
      件覆寫。</item>
   </list>
 
   <p>所有這些字串使用統一的語法格式：用逗號分隔的一系列套裝軟體名稱。這裡的軟
      件包裝檔名稱可以是用豎線符號“<tt>|</tt>”分開的一系列可相互取代(alternative)的
      套裝軟體名稱。
 
   <p>對於每一個套裝軟體的特定版本的要求也可以在這個字串中限制。只要在套裝軟體的
      名稱後寫上括號並在括號中寫明版本列表並在每一個版本號前注明目前套裝軟體和
      它的關係就可以了。這裡提到的關係可以是：<tt>&lt;&lt;</tt>、<tt>&lt;=
      </tt>、<tt>=</tt>、<tt>&gt;=</tt>和<tt>&gt;&gt;</tt>，它們分別表示先
      於、先於或等於、等於、晚於和晚於或等於。例如，
 
   <p><example>
   Depends: foo (>= 1.2), libbar1 (= 1.3.4)
   Conflicts: baz
   Recommends: libbaz4 (>> 4.0.7)
   Suggests: quux
   Replaces: quux (<< 5), quux-foo (<= 7.6)
   </example>
   
   <p>最後一個你需要知道的功能是${shlibs:Depends}。在你的套裝軟體被建立並且安裝
      到臨時目錄中以後，<manref name="dh_shlibdeps" section="1">將會掃瞄其中
      的二進位檔案和程式庫檔案，偵測它們對共享庫的倚賴性，以及這些共享庫所在的軟
      件包裝檔，如libc6、xlib6g等。它將會把結果列表傳遞給<manref
      name="dh_gencontrol" section="1">，後者將會把這些資訊填寫到正確的位置
      上，你就不用為它操心了。
 
   <p>說了這麼多，我們現在可以繼續了，讓Depends:這一行保持原狀，並在它後面插
      入一行，在這一行中些上<tt>Suggests: file</tt>，因為gentoo可以使用這個
      程式/套裝軟體提供的一些功能。
 
   <p>第11行是一個簡短的描述。大多數人的螢幕都是80列寬的，所以描述文字不能超
      過大概60個英文字元長。我把它改成“fully GUI configurable X file manager
      using GTK+”。
 
   <p>第12行是一個比較長的描述。在這裡可以寫關於這個套裝軟體的詳細情況的一段話。
      每行的第1列應該是空白的。兩行之間不能有空白行，如果真的想留一個空白行，
      可以透過寫一個單獨的小數點符號實作。還有，在長描述之後，不能有超過一行
      的空白。
 
   <p>最後，我們給出一個修改好的control檔案：
 
   <p><example>
   1  Source: gentoo
   2  Section: x11
   3  Priority: optional
   4  Maintainer: Josip Rodin &lt;joy-mg@debian.org&gt;
   5  Build-Depends: debhelper (>> 3.0.0), xlibs-dev, libgtk1.2-dev, libglib1.2-dev
   6  Standards-Version: 3.5.2
   7
   8  Package: gentoo
   9  Architecture: any
   10 Depends: ${shlibs:Depends}
   11 Suggests: file
   12 Description: fully GUI configurable X file manager using GTK+
   13  gentoo is a file manager for Linux written from scratch in pure C. It
   14  uses the GTK+ toolkit for all of its interface needs. gentoo provides
   15  100% GUI configurability; no need to edit config files by hand and re-
   16  start the program. gentoo supports identifying the type of various
   17  files (using extension, regular expressions, or the 'file' command),
   18  and can display files of different types message different colors and icons.
   19  .
   20  gentoo borrows some of its look and feel from the classic Amiga file
   21  manager "Directory OPUS" (written by Jonathan Potter).
   </example>
   (我為它增加了行號。)
 
   <sect id="copyright">“copyright”檔案
 
   <p>這個檔案中包裝檔含著關於套裝軟體的來自於上游的資源、版權和授權資訊。它的格式
      在政策中並未規定，關於它的內容是(12.5 “Copyright information”).  
   <p>dh_make將會建立一個預設的，其內容如下：
 
   <p><example>
   1  This package was debianized by Josip Rodin &lt;joy-mg@debian.org&gt; on
   2  Wed, 11 Nov 1998 21:02:14 +0100.
   3
   4  It was downloaded from &lt;fill in ftp site&gt;
   5
   6  Upstream Author(s): &lt;put author(s) name and email here&gt;
   7
   8  Copyright:
   9
   10 &lt;Must follow here&gt;
   </example>
   (我為它增加了行號。)
 
   <p>在這個檔案中需要增加的重要資訊是你獲得套裝軟體的位置以及它原有的版權提示
      和授權條款。如果它的授權條款不是通用的自由軟體授權條款
      如GNU的GPL或LGPL、BSD或是Artistic條款，你就必需把它的條款包裝檔含在這個文
      件中。而當它使用上述自由軟體授權條款時，你可以直接引
      用/usr/share/common-licenses/目錄中的相應檔案，它們已經存在於Debian系統
      中了。
 
   <p>簡而言之，下面是gentoo的copyright檔案：
 
   <p><example>
   1  This package was debianized by Josip Rodin &lt;joy-mg@debian.org&gt; on
   2  Wed, 11 Nov 1998 21:02:14 +0100.
   3
   4  It was downloaded from: ftp://ftp.obsession.se/gentoo/
   5
   6  Upstream author: Emil Brink &lt;emil@obsession.se&gt;
   7
   8  This software is copyright (c) 1998-99 by Emil Brink, Obsession
   9  Development.
   10
   11 You are free to distribute this software under the terms of
   12 the GNU General Public License.
   13 On Debian systems, the complete text of the GNU General Public
   14 License can be found in the file `/usr/share/common-licenses/GPL'.
   </example>
   (我為它增加了行號。)
 
   <sect id="changelog">“changelog”檔案
 
   <p>這是一個必需的檔案，它的格式已經在政策檔案的4.4節“debian/changelog”中說
      明了。dpkg和其它需要獲取你的套裝軟體的版本號、修訂號、發行版和緊急度的程
      序會需要使用這個格式。
 
   <p>對你而言，它也是非常重要的，因為它可以讓你寫下所有你所做的所有變更。這
      可以幫助下載了你的套裝軟體的人們了解套裝軟體中是否有它們應該知道的問題。在
      二進位版本的套裝軟體中，它會被保存
      在“/usr/share/doc/gentoo/changelog.Debian.gz”檔案中。
 
   <p>dh_make建立了一個預設的，如下所示：
 
   <p><example>
   1  gentoo (0.9.12-1) unstable; urgency=low
   2
   3   * Initial Release.
   4
   5  -- Josip Rodin &lt;joy-mg@debian.org&gt;  Wed, 11 Nov 1998 21:02:14 +0100
   6
   </example>
   (我為它增加了行號。)
 
   <p>第1行是套裝軟體的名稱、版本、發行版和緊急度。這裡的名稱必需和來源程式碼包裝檔的名
      稱相同，發行版應當是“unstable”(或是“experimental”)，urgency應當改成任何
      比“low”高一些層級的內容。:-)  
   
   <p>第3到5行是一個很長的項目，在這裡你可以寫下你對這個版本的軟體說做的修
      改(不包裝檔括上游修改──有專門的由作者建立的檔案來記錄它們，稍後你將會把它安
      裝到/usr/share/doc/gentoo/changlog.gz)。新的內容必需插入在最上方的星
      號(“*”)前。你可以用<manref name="dch" section="1">來做或是用一個純文字編
      輯器手動修改。
 
   <p>最後，你的檔案應該是下面的樣子：
 
   <p><example>
   1  gentoo (0.9.12-1) unstable; urgency=low
   2
   3   * Initial Release.
   4   * This is my first Debian package.
   5   * Adjusted the Makefile to fix $DESTDIR problems.
   6
   7  -- Josip Rodin &lt;joy-mg@debian.org&gt; Wed, 11 Nov 1998 21:02:14 +0100
   8
   </example>
   (我為它增加了行號。)
 
   <p>在後面的更新<ref id="update">中你可以找到更多關於更新changelog的內容。
   
   <sect id="rules">“rules”檔案
 
   <p>現在我們需要來看看<manref name="dpkg-buildpackage" section="1">用來建立
      套裝軟體的精確規則了。這個實際上是另一個Makefile腳本，但同上游來源程式碼中的
      那個不同。與debian/目錄中的其它檔案不同的是這個檔案有可執行標記。
 
   <p>就像其它的Makefile一樣，每個“rules”檔案都有一些用來指導如何處理來源程式碼的
      規則。每個規則都由目標、檔案名稱或是是需要執行的操作的名
      稱(如“build:”、“install:”)組成。當你要執行一個規則時可以在命令行參數上
      加入參數(比如“./debian/rules build”或是“make -f rules install”)。在目
      標名稱之後，你可以寫這個規則對程式檔案的倚賴性。之後，可以有任意數目
      的命令，這些命令要用&lt;tab&gt;符號縮排。新的規則以位於第一列上目標宣告
      開始。空白行和以“#”(井字號)開始的行將會被作為註解忽略掉。
 
   <p>現在你可能已經聽糊塗了，但只要看一下dh_make為我們建立的預設的“rules”文
      件你就能明白了。另外你也應該讀一下info中的“make”項目來獲得更多的資訊。
 
   <p>有一個關於dh_make所建立的rules檔案的重要問題是你應該知道的：它只是一個
      建議版本。對於一些簡單的套裝軟體它可以工作，但對於稍為複雜一些的，應當敢
      於增加或是刪減其內容使其符合你的需求。唯一你不能修改的就是規則的名稱，
      因為政策手冊中提到的所有工具都將使用它們。
 
   <p>這裡是dh_make為我們產生的預設的debian/rules檔案：
 
   <p><example>
&makefile;
   </example>
   (我為它增加了行號。在實際的 <file>debian/rules</file> 檔案中，行首的空白是
    定位字元TAB。)
 
   <p>對於第1行你一定很熟悉，因為它和shell及Perl腳本很象。它告訴作業系統這個
      檔案應當交給/usr/bin/make來處理。
 
   <p>第6到9行上提到的DH_*變數應當被簡短明確的說明。要想知道關於DH_COMPAT的更
      多資訊，可以閱讀<manref name="debhelper" section="1">手冊中關於“Debhelper
      compatibility levels”一節。
 
   <p>第11到16行是一個支援DEB_BUILD_OPTIONS的骨架，它的描述可以在政策文件的
      第10.1節“Binaries”中找到。簡單的說，它們控制著在建構二進位檔案的時候是
      否要加入除錯符號，是否要在安裝的時候進行裁減。再重覆一下，這只是一個骨
      架，一個你應當做這件事的提示。你需要找出上游的建立系統是如何處理除錯符
      號和install-strip的，然後自己實作它們。
 
   <p>一般情況下，你可以透過CFLAGS變數來讓gcc在編譯的時候使用“-g”選項──如果這
      是你的套裝軟體的情況，你可以把<tt>CFLAGS="$(CFLAGS)"</tt>附加到$(MAKE)調
      用的<em>後面</em>來propagete這個變數(看下面)。還有另外一種方法，如果你
      的套裝軟體使用了autoconf腳本，你可以把透過給./configure執行加上<em>前
      綴</em>來把它傳遞給建立規則。
 
   <p>關於裁減的問題，一般情況下程式自己的安裝設定都不會進行裁減，而且通常也
      不會包裝檔含一個選項讓 你來做這件事情。幸運的是，你有<manref name="dh_strip"
      section="1">，而且當你設定了DEB_BUILD_OPTIONS=nostrip時，他會安靜地退出。
 
   <p>第18到26行描述了“build”(和“build-stamp”)規則，它們執行應用程式自己
      的Makefile來編譯它。如果你的套裝軟體使用GNU組態工具來建構，請一定要閱
      讀<file>&autotools-dev;</file>。稍後在<ref id="manpage">中我們會討
      論docbook-to-man的例子。
 
   <p>第28到36行的“clean”規則會清除所有不需要的二進位檔案和自動產生的東西，在
      每次建立套裝軟體的時候都會首先執行。這個規則必須在所有的時候都能正常工
      作(即便來源程式碼目錄已經<em>是</em>清理被清理好的)，所以請使用強制選項(比
      如對於rm是“-f”)，或是透過在命令的名字前加上“-”讓make忽略傳回值(失敗)。
 
   <p>“install”規則從第38行開始，它指導了安裝程序。它通常去執行軟體自己
      的Makefile中的“install”規則，但會把套裝軟體安裝
      在<tt>$(CURDIR)/debian/gentoo</tt>目錄中──這就是為什麼我們要
      在gentoo的Makefile中指定$(DESTDIR)作為安裝的跟目錄。
 
   <p>就像註解中說明的那樣，第48行上的“binary-indep”規則是用來建立體系結構無
      關的套裝軟體的。因為這裡我們並沒有這樣的套裝軟體，所以什麼都不用做了。
 
   <p>在52-79行上是下一筆規則“binary-arch”，在這裡我們執行了好幾個debhelper軟
      件包裝檔中的小工具，它們將會在你的套裝軟體上執行不同的操作來使其符合政策。
 
   <p>如果你的套裝軟體是“Architecture: all”的，那麼你需要在“binary-indep”中包裝檔含
      所有的命令，而讓“binary-arch”保持空白。
   
   <p>debhelper程式都是以dh_開始的，剩下的部分描述了這個工具具體的作用。其實
      它們的名字都已經說的很清楚了，但這裡我們還是給出一些額外的解釋：
 
   <list>
   <item>
      <manref name="dh_testdir" section="1">檢查你是不是在正確的目錄中(比如來源程式碼目錄的最上層)；
   <item>
      <manref name="dh_testroot "section="1">檢查你是否擁有在“binary-arch”、“binary-indep”和“clean”時需要用到的root權限；
   <item>
      <manref name="dh_installman" section="1">把手冊頁檔案複製到正確的目標目錄中你不需要告訴它究竟相對於最高層來源程式碼目錄的那個位置是哪裡；
   <item>
      <manref name="dh_strip" section="1">從可執行檔案和程式庫檔案中裁減掉偵錯資訊，使它們更小一些；
   <item>
      <manref name="dh_compress" section="1">用<manref name="gzip" section="1">壓縮所有大於4 kB的手冊頁和文件；
   <item>
      <manref name="dh_installdeb" section="1">把與套裝軟體相關的所有檔案(例如維護腳本)複製到<file>debian/gentoo/DEBIAN</file>目錄中；
   <item>
      <manref name="dh_shlibdeps" section="1">計算程式庫檔案和可執行檔案對共享庫的倚賴性；
   <item>
      <manref name="dh_gencontrol" section="1">在控制檔案插入一個已經格式化(fine-tuned)好的<file>debian/gentoo/DEBIAN</file>檔案;
   <item>
      <manref name="dh_md5sums" section="1">為套裝軟體中的所有檔案產生MD5校驗碼。
   </list>
 
   <p>要想了解更完整的的關於這些dh_*腳本究竟會做什麼的資訊以及它們其它的選項，
      請閱讀它們相對的手冊。還有一些可能是非常有用的dh_*腳本檔案在這裡沒有提
      及。如果你需要使用它們，情閱讀debhelper的文件。
 
   <p>在binary-arch一節中，你必須要註解掉或是刪除掉你不需要的功能執行。對
      於gentoo，我把關於examples、cron、init、man和info的行註解掉了，因
      為gentoo根本不需要它們。而且在第68行上，我把“ChangeLog”換成了“FIXES”，
      因為那是上游的changelog檔案的真實名字。
 
   <p>最後的兩行(和其它這裡未曾解釋的地方)是需要的，在make的手冊和Debian政策
      檔案都是可以找到。現在知道它們的作用並不重要。
 
   <chapt id="dother">debian/中的其它檔案
 
   <p>你會看到在debian/子目錄中還有幾個已經存在的檔案，它們大多數都是以“.ex”結
      尾的，表明它們只是例子。仔細看一下它們。如果你希望使用其中任何一個功
      能，你需要做的事情是：
 
   <list>
     <item>看一下相關的文件(提示：Debian政策手冊)，
     <item>如果需要就修改檔案使其符合你的需求，
     <item>修改檔案名稱如果有“.ex”後綴就去掉它，
     <item>修改檔案名稱如果有“ex.”前綴就去掉它，
     <item>如果需要就修改“rules”檔案。
   </list>
 
   <p>在下面給出了一些經常會被用到的檔案的解釋。
 
   <sect id="readme">README.Debian
 
   <p>所有的在原來的套裝軟體和你的debian版本的套裝軟體之間的細節及差异需要寫在這裡。
 
   <p>dh_make建立了一個預設的，如下所示：
 
   <p><example>
   gentoo for Debian
   -----------------
 
   &lt;possible notes regarding this package - if none, delete this file&gt;
 
    -- Josip Rodin &lt;joy-mg@debian.org&gt;, Wed, 11 Nov 1998 21:02:14 +0100
   </example>
 
   <p>由於我們不需要在這裡寫任何東西，我們就把它刪掉了。
 
   <sect id="conffiles">conffiles.ex
 
   <p>關於軟體，有一件事情是很煩人的，那就是當你花費了很多的時間和精力訂製好
      一個程式，只要一升級，你所有的訂製就都會被丟棄了。Debian解決這個問題的
      方法是標注出設定檔案，這樣當你升級一個套裝軟體時，你將會被詢問是否要保留
      你原來的設定檔案。
 
   <p>如果希望對讓一個套裝軟體可以做到這點，只要把每一個設定檔案(通常在/etc)目
      錄下的完整路徑逐行加入到一個名叫<tt/conffiles/的檔案裡面就可以
      了。Gentoo有一個設定檔案，/etc/gentoorc，我們把他加入到文
      件<tt/conffiles/中。
 
   <p>如果你自己的程式有一個設定檔案並且會自己覆寫它，那麼最好就不要把它標記
      為設定檔案了，因為這樣dpkg就總會會詢問使用者是否要修改它。
 
   <p>如果你的套裝軟體總要求每個使用者修改自己的設定檔案，最好也不要把設定檔案標
      記出來了。
 
   <p>你可以用用“maintainer scripts”來處理例子設定檔案，要了解更多的資訊請參
      考<ref id="maintscripts">。
   
   <p>如果你的程式根本沒有conffiles，對你來說從debian/目錄中刪
      除<tt/conffiles/就是很安全的了。
 
   <sect id="crond">cron.d.ex
 
   <p>如果你的套裝軟體需要排程工作正常執行才能夠正常操作，你可以在這個檔案中設
      置它。
 
   <p>注意這裡並不包裝檔括定期清除日誌的工作；關於它，請參考<manref
      name="dh_installlogrotate" section="1">和<manref name="logrotate"
      section="8">。
 
   <p>如果你不需要，那就把它刪了吧。
 
   <sect id="dirs">dirs
 
   <p>這個檔案裡指出了我們需要的但一般的安裝程序(make install)並不會自動建立
      的目錄。
 
   <p>預設情況下，它的內容如下所示：
 
   <p><example>
   usr/bin
   usr/sbin
   </example>
 
   <p>注意最前面是沒有斜線的。我們通常把它改成下面的樣子：
 
   <p><example>
   usr/bin
   usr/man/man1
   </example>
   
   <p>但這些目錄在Makefile中已經建立了，所以我們不需要這個檔案，並且打算把它
      刪了。
 
   <sect id="docs">docs
 
   <p>在這個檔案中，我們可以指定一些讓dh_installdocs幫我們安裝到臨時目錄中的
      文件的檔案名稱。
 
   <p>預設的情況下，他會包裝檔含所有已經存在於來源程式碼目錄最高層目錄中的名為“BUGS”、
      “README*”、“TODO”等的檔案。
 
   <p>對於gentoo，我們還加入了一些其它的內容：
 
   <p><example>
   BUGS
   CONFIG-CHANGES
   CREDITS
   ONEWS
   README
   README.gtkrc
   TODO
   </example>
   
   <p>我們可以刪掉這個檔案，取而代之的是在<tt/rules/檔案中
      的<tt/dh_installdocs/命令後列出這裡提到的檔案的名字，如下所示：
 
   <p><example>
           dh_installdocs BUGS CONFIG-CHANGES CREDITS ONEWS README \
                        README.gtkrc TODO
   </example>
 
   <p>也許並不像你看到的這樣，你自己的套裝軟體可能根本就沒有這些檔案。在這種情
      況下，對你來說刪掉這個檔案是很安全的。但是不要刪掉<tt/rules/檔案中
      的<tt/dh_installdocs/，因為它還要被用於安裝<tt/copyright/和其它的一些
      東西。
 
   <sect id="emacsen">emacsen-*.ex
 
   <p>如果你的套裝軟體提供了一些可以在安裝時進行位元組編譯的Emacs檔案，你可以使用
      這些檔案來設定它們。
 
   <p>透過命令<manref name="dh_installemacsen" section="1">可以把它們安裝到臨
      時檔案中，所以如果你要使用它不要忘了去掉<tt/rules/檔案中那一行上的註解。
 
   <p>如果你不需要這些，刪掉它們。
 
   <sect id="initd">init.d.ex
 
   <p>如果你的套裝軟體是一個需要在系統啟動時執行的背景作業程式，那麼很顯然你沒有采
      納我在開始時的建議，不是嗎？:-)
 
   <p>這是一個<file>/etc/init.d/</file>腳本的通用骨架，所以你不得不對它進行大
      規模的修改。透過<manref name="dh_installinit" section="1">可以把它安裝
      到臨時目錄中。
 
   <p>如果你不需要這些，刪掉這個檔案。
 
   <sect id="manpage">manpage.1.ex, manpage.sgml.ex
 
   <p>你的程式應該有一個手冊頁。如果它們沒有，這裡的每一個檔案都是一個模板，
      你只要把它填好就可以了。
 
   <p>手冊頁通常用<manref name="nroff" section="1">寫成。<tt/manpage.1.ex/這
      個例子也使用nroff寫的。在<manref name="man" section="7">的手冊頁中可以
      找到一個關於如何編寫這樣一個檔案的簡短說明。
   
   <p>如果你更希望些SGML而不時nroff，那麼你可以使用<tt/manpage.sgml.ex/模板。
      如果是這樣，那麼你就必需做下面這些事情：
   <list>
     <item>安裝套裝軟體<package/docbook-to-man/
     <item>把<tt/docbook-to-man/加到<tt/control/檔案的<tt/Build-Depends/一行。
     <item>刪除<tt/rules/檔案“build”規則中docbook-to-man執行前的註解
   </list>
 
   <p>另外還要記得把檔案名稱改成類似於<tt/gentoo.sgml/的樣子！
 
   <p>最後，手冊頁檔案的名字應該包裝檔含它所描述的程式的名字。所以我們需要把
      “manpage”改成“gentoo”。這個檔案明中還以一個“.1”作為後綴，這表明它是一個
      關於使用者命令的手冊。一定要確保這個節編號是正確的。這裡有一個關於手冊頁
      各個節的簡短列表：
 
   <p><example>
   Section |     Description     |     Notes
      1     User commands          Executable commands or scripts.
      2     System calls           Functions provided by the kernel.
      3     Library calls          Functions messagein system libraries.
      4     Special files          Usually found in /dev
      5     File formats           E.g. /etc/passwd's format
      6     Games                  Or other frivolous programs
      7     Macro packages         Such as man macros.
      8     System administration  Programs typically only run by root.
      9     Kernel routines        Non-standard calls and internals.
   </example>
   
   <p>所以gentoo的手冊頁應該叫做<tt/gentoo.1/。在原來的來源程式中，並沒
      有gentoo.1的手冊頁，所以我利用例子和上游文件給出的資訊寫了一個。
 
   <sect id="menu">menu.ex
 
   <p>X視窗系統的使用者通常都會使用支援功能表的視窗管理器，這些功能表可以被訂製用於
      啟動程式。如果它們安裝了Debian的<package/menu/套裝軟體，那麼系統就會建立
      一套包裝檔含有系統上每一個程式的功能表。 
 
   <p>這裡有一個預設的由dh_make建立的<tt/menu.ex/檔案：
   
   <p><example>
   ?package(gentoo):needs=X11|text|vc|wm section=Apps/see-menu-manual\
     title="gentoo" command="/usr/bin/gentoo"
   </example>
 
   <p>在冒號之後的第一個字串是“needs”，他指明了程式需要什麼樣的界面。可以把這
      個字串改成一個合適的值，比如“text”或是“X11”。
 
   <p>下面是“section”，它指出這個項目應當出現的功能表和子功能表。目前的可選節被列
      在檔案<file>/usr/share/doc/debian-policy/menu-policy.html/ch2.html#s2.1
      </file>中。
 
   <p>“title”字串是程式的名字。如果你喜歡，可以用大寫字母開頭。但一定要使它保
      持簡短。
 
   <p>最後，“command”字串用於執行程式。
 
   <p>現在我們要把功能表項目改成下面的樣子：
 
   <p><example>
   ?package(gentoo): needs=X11 section=Apps/Tools title="Gentoo" command="gentoo"
   </example>
 
   <p>你還可以加入其它的字串，比如“longtitle”、“icon”和“hints”等。參考<manref
      name="menufile" section="5">、<manref name="update-menus"
      section="1">和<file>/usr/share/doc/debian-policy/menu-policy.html/
      </file>可以了解更多資訊。
 
   <sect id="watch">watch.ex
 
   <p>這個檔案用於設定程式<manref name="uscan" section="1">和<manref
      name="uupdate" section="1">(在套裝軟體<package/devscripts/中)。它們可以用
      於監視你下載來源程式碼的站台。
 
   <p>這裡是我的設定：
 
   <p><example>
 # watch control file for uscan
 # Site           Directory  Pattern               Version  Script
 ftp.obsession.se  /gentoo   gentoo-(.*)\.tar\.gz  debian   uupdate
   </example>
 
   <p>提示：在建立了這個檔案後，可以連線到Internet，並且試著在程式目錄中執行
      “uscan”命令。還要讀手冊哦！:)
 
   <sect id="doc-base">ex.package.doc-base
 
   <p>如果你的套裝軟體還有除了手冊頁以外的其它普通文件和info文件，你需要使
      用“<package/doc-base/”檔案來註冊它們，這樣使用者就能夠用如<manref
      name="dhelp" section="1">、<manref name="dwww" section="1">或是<manref
      name="doccentral" section="1">等工具來找到它們。
 
   <p>這通常包裝檔括<file>/usr/share/doc/packagename/</file>中的HTML、PS和PDF檔案。
 
   <p>gentoo的doc-base檔案<tt>gentoo.doc-base</tt>如下所示：
 
   <p><example>
   Document: gentoo
   Title: Gentoo Manual
   Author: Emil Brink
   Abstract: This manual describes what Gentoo is, and how it can be used.
   Section: Apps/Tools
 
   Format: HTML
   Index: /usr/share/doc/gentoo/html/index.html
   Files: /usr/share/doc/gentoo/html/*.html
   </example>
 
   <p>關於安裝的檔案格式，請參考<manref name="install-docs"
      section="8">和<file>/usr/share/doc/doc-base/doc-base.html/</file>中
      的<package/doc-base/手冊。
 
   <sect id="maintscripts">postinst.ex, preinst.ex, postrm.ex, prerm.ex
 
   <p>這些檔案叫做維護者腳本。它們位於套裝軟體的控制欄位中，並且在你安裝、升級
      或刪除套裝軟體時，<prgn/dpkg/會執行他們。
 
   <p>現在，你應該盡可能避免修改任何維護者腳本，因為它們有一些複雜。要了解關
      於它們的更多資訊請參考政策手冊的第6章，而且還應該看看dh_make所提供的例
      子檔案。
 
   <chapt id="build">建立套裝軟體
 
   <p>現在我們已經為建立套裝軟體做好了準備。
 
   <sect id="completebuild">完整的rebuild
 
   <p>進入程式的主目錄然後執行如下命令：
 
   <p><example>
   dpkg-buildpackage -rfakeroot
   </example>
 
   <p>這將為你做好每件事情。它會：
   <list>
     <item>清理來源程式碼目錄樹(debian/rules clean)，需要使用<prgn/fakeroot/
     <item>建立來源程式碼套裝軟體(dpkg-source -b)
     <item>建立程式(debian/rules build)
     <item>建立二進位套裝軟體(debian/rules binary)，需要使用<prgn/fakeroot/
     <item>用檔案<tt/.dsc/給來源程式碼簽名，需要使用<prgn/gnupg/
     <item>建立上傳檔案<tt/.changes/並給它簽名，需要使用
           <prgn/dpkg-genchanges/和<prgn/gnupg/
   </list>
 
   <p>唯一需要你輸入的是你的GPG密鑰的密碼，兩次。
 
   <p>當完成所有這些，你會在上一層目錄(<tt>~/gentoo/</tt>)中看到下面的檔案：
 
   <p><list>
   <item><em>gentoo_0.9.12.orig.tar.gz</em>
 
   <p>這是原來的來源程式的壓縮檔，為了遵守Debian的標準，修改了它的檔案名稱。注意
      它是我們透過在開始時執行帶有“-f”參數的<prgn/dh_make/命令建立的。
 
   <item><em>gentoo_0.9.12-1.dsc</em>
 
   <p>這時對來源程式碼的一個總結。這個程式是利用你的“control”檔案建立的，並且在
      用<manref name="dpkg-source" section="1">命令解開來源程式碼時將會用到。這個
      檔案已經有了GPG簽名，這樣人們就可以確認他是你發佈的。
 
   <item><em>gentoo_0.9.12-1.diff.gz</em>
 
   <p>這個檔案中包裝檔含了每一個你對原始來源程式碼所做的每一個修改，它的格式是“unified
      diff”。他是由<manref name="dpkg-source" section="1">程式建立的，而且這
      個程式還要使用它。警告：如果你沒有把原始的來源程式碼壓縮檔的名字改
      成packagename_version.orig.tar.gz，<prgn/dpkg-source/將不能正確地建立這
      個.diff.gz檔案。
 
   <p>如果其它人希望從頭重新建構你的套裝軟體，它們可以用上面的三個檔案很容易地
      做到。解開的程序很簡單：只要把這三個檔案複製到一個另外的目錄，然後運
      行<tt>dpkg-source -x gentoo_0.9.12-1.dsc</tt>.
 
   <item><em>gentoo_0.9.12-1_i386.deb</em>
 
   <p>這是你的完整的二進位套裝軟體。你可以像對待其它套裝軟體一樣用<prgn/dpkg/命令
      安裝和刪除它。
 
   <item><em>gentoo_0.9.12-1_i386.changes</em>
 
   <p>這個檔案描述了描述了所有對目前版本的修訂版所作的改動，Debian FTP文件維
      護程式在安裝二進位版本套裝軟體和來源程式碼版本的套裝軟體時將會使用到它。它的一
      部分是透過“changelog”檔案和.dsc檔案建立的。這個檔案已經有了GPG簽名，這
      樣人們可以確信它確實是你的。
 
   <p>因為你會繼續花精力在這個套裝軟體上，它的行為可能會改變，還有可能會增加一
      些新的功能。下載了你的套裝軟體的人們可以透過閱讀這個檔案從而快速的了解到
      什麼東西發生了變化。Debian的文件維護程式也會把這個檔案的內容發送
      到debian-devel-changes信件列表上。
   </list>
 
   <p>.dsc和.changes檔案中的長數位字串是上面提到的檔案的MD5校驗碼。下載了你
      的檔案的人可以用<manref name="md5sum" section="1">來檢查這些數位是否相
      同，這樣它們就可以知道檔案是不是損壞了，或是是否被竄改了。
 
   <sect id="quickrebuild">快速rebuild
 
   <p>對於一個很大的套裝軟體，你可能不希望在你調整了<file>debian/rules</file>文
      件的一些細節後都從頭來建立它。為了測試，你可以只製作一個.deb檔案而不重
      新建構上游來源程式碼，具體的作法如下所示：
 
   <p><example>
   fakeroot debian/rules binary
   </example>
 
   <p>一旦你完成了調整，記得要根據上面的內容從頭以正確的順序重新建立套裝軟體。
      如果你想上傳一個以這種方式製作的.deb檔案時可能會遇到錯誤。
 
   <sect id="debuild"><prgn>debuild</prgn>命令
 
   <p>使用<prgn>debuild</prgn>命令你可以讓後面的建構套裝軟體的程序自動完成。
      參考<manref name="debuild" section="1">。
   
   <p>對debuild命令的位址可以透過修改<file>/etc/devscripts.conf</file>或
      者<file>~/.devscripts</file>完成。我建議至少修改以下內容：
 
   <p><example>
   DEBSIGN_KEYID="Your_GPG_keyID"
   DEBUILD_DPKG_BUILDPACKAGE_OPTS="-i -ICVS -I.svn"
   </example>
   使用這個組態，你就可以總是使用你的GPG密鑰來建構套裝軟體並避免不希望的部件。(這
   對於發起人也是很好的。)譬如，使用一個使用者帳號清空來源碼並重新建構套裝軟體會非常
   簡單：
 
   <p><example>
   debuild clean
   debuild
   </example>
 
   <sect id="dpatch"><prgn>dpatch</prgn>系統
   <p>簡單地使用<prgn>dh_make</prgn>和<prgn>dpkg-buildpackage</prgn>命令會創
      建一個大的<file>diff.gz</file>檔案，這個檔案中會包裝檔含<file>debian/
      </file>目錄中的檔案和來源碼補綴。當日後要檢查和理解每一處對來源碼的修改時，
      這樣的包裝檔會難以處理。這樣總不是很好。
 
   <footnote>
      如果你還不是Debian開發者並且希望別人在他檢查了套裝軟體之後能夠上傳你的軟
      件包裝檔，你己應該盡可能讓檢查套裝軟體的工作容易一些。
   </footnote>
 
   <p>目前已經有多種管理多個補綴的方法用於Debian中。<prgn>dpatch</prgn>系統是
      其中最一簡單的一個，此外還有dbs、cdbs等。
 
   <p>一個用<prgn>dpatch</prgn>系統打包裝檔的套裝軟體，其套裝軟體的修改記錄在<file>
      debian/patches/</file>目錄下的一個文件清晰的補綴集中。<file>debian/
      </file>目錄之外的來源碼樹並沒有被修改。如果你需要其它人來幫你上傳套裝軟體，
      透過上述方法將你所做的修改清晰地分離出來並加上文件是非常重要的，它可以
      方便別人檢查。<prgn>dpatch</prgn>程式的使用方式在<manref section="1"
      name="dpatch">中解釋清楚了。
 
   <p>此後如果當某人(包裝檔括你自己)為你提供了一個來源碼補綴，在dpatch下修改來源碼包裝檔
      是非常容易的：
 
   <list compact>
   <item>修改補綴，使其成為對來源碼樹的-p1補綴。
   <item>用<prgn>dpatch patch-template</prgn>命令加入檔案頭。
   <item>將其放入<file>debian/patches</file>目錄
   <item>將此dpatch檔案放入<file>debian/patches/00list</file>檔案中
   </list>
 
   <p>此外<prgn>dpatch</prgn>還可以透過使用CPP巨集讓補綴對體系結構無關。
 
   <sect id="option-sa">在上傳時包裝檔含<file>orig.tar.gz</file>
 
   <p>當你第一次上傳了套裝軟體時，你需要包裝檔含原始的<file>orig.tar.gz</file>來源碼
      包裝檔。如果包裝檔的Debian修正版本號不是<tt>-0</tt>或<tt>-1</tt>，你在使
      用<prgn>dpkg-buildpackage</prgn>命令需要加上“<tt>-sa</tt>”選項。換句話
      說，“<tt>-sd</tt>”選項將會除去<file>orig.tar.gz</file>檔案。
 
   <chapt id="checkit">檢查套裝軟體中的錯誤
 
   <sect id="lintians"><package>lintian</package>套裝軟體
 
   <p>在你的.changes檔案上執行<manref name="lintian" section="1">；它們會檢查出其中很多常見的錯誤。通常使用命令：
   
   <p><example>
   lintian -i gentoo_0.9.12-1_i386.changes
   </example>
   
   <p>當然，要用為你的套裝軟體產生的.changes檔案的檔案名稱取代掉上面的。如果這個
      命令的執行結果顯示在套裝軟體中有錯誤(以E:開始的行)，清仔細閱讀關於錯誤的
      說明(以N:開始的行)，糾正錯誤，然後根據前文<ref id="completebuild">所述
      重新建立套裝軟體。如果在輸入的資訊中有以W:開始的行，它們代表警告，那就要
      調整套裝軟體或是如果你確認這些警告是不是spurious的(讓Lintianoverride它
      們；請參考文件以獲得更多的資訊。)
  
   <p>你可以用<manref name="debuild" section="1">命令，它會首先
      用<prgn/dpkg-buildpackage/建立套裝軟體，接著運
      行<prgn/lintian/。
   
   <sect id="mc"><prgn>mc</prgn>命令
 
   <p>你可以用<manref name="dpkg-deb" section="1">解壓<file>*.deb</file>包裝檔中
      的內容。你也可以用<manref name="debc" section="1">列出產生的Debian包裝檔中
      的內容。
 
   <p>這也可以用如<manref name="mc" section="1">的檔案管理器直接完成，使用它，
      不只有可以瀏覽<file>*.deb</file>檔案的內容，還可以瀏覽<file>*.diff.gz
      </file>和<file>*.tar.gz</file>檔案的內容。
 
   <p>請注意來源碼包裝檔和二進位包裝檔中沒有用處的檔案或零長度的檔案。通常cruft都不能被
      正確地清理；請調整你的rules檔案來修復它們。
 
   <p>技巧：使用“<tt>zgrep ^+++ ../gentoo_0.9.12-1.diff.gz</tt>”命令可以得到
      一系列對來源檔案進行的修改或增加。而“<tt>
      dpkg-deb -c gentoo_0.9.12-1_i386.deb</tt>”或“<tt>
      debc gentoo_0.9.12-1_i386.changes</tt>”會列出二進位包裝檔中的檔案。
 
   <sect id="debdiff"><prgn>debdiff</prgn>命令
 
   <p>你可以用<manref name="debdiff" section="1">命令來比較兩個Debian二進位軟
      件包裝檔中的檔案清單。這對於核對是否有錯誤地放置或刪除了檔案和其它粗心大意
      的修改是很有用的。你可以用“<tt>
      debdiff old-package.change new-package.change</tt>”檢查一組<file>
      *.deb</file>檔案。
 
   <sect id="interdiff"><prgn>interdiff</prgn>命令
 
   <p>你可以用<manref name="interdiff" section="1">命令比較兩個<file>
      diff.gz</file>檔案。這對於核對維護者在更新包裝檔時對於來源碼包裝檔是否有粗心大意
      地修改是很有用的。執行“<tt>
      interdiff -z old-package.diff.gz new-package.diff.gz</tt>”。
 
   <sect id="debi"><prgn>debi</prgn>命令
 
   <p>自己安裝你的套裝軟體，比如用root的身份使用<manref name="debi"
      section="1">命令。嘗試在其它的機器上而不只是你自己的機器上安裝並執行你
      的套裝軟體，並仔細觀察所有的在安裝和執行時系統給出的錯誤資訊。
 
   <sect id="pbuilder"><package>pbuilder</package>包裝檔
   <p>對於淨室(chroot)建構環境而言，要核對編譯環境的依賴關係，<package>
      pbuilder</package>套裝軟體是很有用的。使用它可以確保在auto-builder中為不
      同的體系結構完全從來源碼完成編譯，從而避免了很嚴重的FTBFS(無法從來源碼編
      譯)的bug，而這種bug經常會出現在RC(發佈臨界版)中。要了解Debian軟體
      包裝檔auto-builder的更多資訊，請參考<url id="&buildd-home;">。
 
   <p>最簡單地使用<package>pbuilder</package>包裝檔的方法是直接以root身份使
      用<prgn>pbuilder</prgn>命令。例如，在包裝檔含了<file>.orig.tar.gz
      </file>、<file>.diff.gz</file>和<file>.dsc</file>的目錄下使用下面的命令
      可以建構一個套裝軟體。
 
   <example>
 root # pbuilder create # if second time, pbuilder update
 root # pbuilder build foo.dsc
   </example>
   新建構的套裝軟體可以在<file>/var/cache/pbuilder/result/</file>中找到，而它們
   的所有者都是root使用者。
 
   <p><prgn>pdebuild</prgn>命令讓你可以以普通用戶的身份使用<package>pbuilder
      </package>包裝檔的功能。從來源碼樹的根中，當其父目錄中有<file>orig.tar.gz
      </file>時，你可以輸入下面的命令：
 
   <example>
 $ sudo pbuilder create # if second time, sudo pbuilder update
 $ pdebuild
   </example>
   新建構的套裝軟體會在<file>/var/cache/pbuilder/result/</file>中，而其所有者將
   不再是root使用者。
 <footnote>
 現在我建議你透過將<file>/var/cache/pbuilder/result/</file>目錄設定為使用者可寫
 且設定<file>~/.pbuilderrc</file>和<file>/etc/pbuilderrc</file>以包裝檔含
 <example>
 AUTO_DEBSIGN=yes
 </example>
 
 這允許你用你的GPG密鑰來為新產生的套裝軟體簽名。<file>~/.gnupg/</file>。因
 為<package>pbuilder</package>包裝檔還在改進之中，若要了解實際的組態情況，請查詢
 它最新的官方檔案。</footnote>
 
   <p>如果你希望增加新的apt來源讓<package>pbuilder</package>包裝檔，你可以設定<tt>
      OTHERMIRROR</tt>、<file>~/.pbuilderrc</file>和<file>/etc/pbuilderrc
      </file>且(對srage)可執行
 <example>
 $ sudo pbuilder update --distribution sarge --override-config
 </example>
 使用<tt>--override-config</tt>則需要更新chroot環境中的apt來源。<p>
 參考<url id="&pbuilder-home;">、<manref section="1" name="pdebuild">、<manref
 section="5" name="pbuilderrc">和<manref section="8" name="pbuilder">。
 
   <chapt id="upload">上傳套裝軟體
 
   <p>現在你已經完整地測試過你的新套裝軟體了，你可以開始Debian新維護者申請的過
      程，<url id="http://www.debian.org/devel/join/newmaint">講述了這個程序。  
 
   <sect id="upload-debian">上傳到Debian檔案庫
 
   <p>一旦你成為正式的開發人員，你就可以上傳套裝軟體到Debian文件中了。你可以手
      工做這件事情，但如果使用一些已經提供的自動化工具(比如<manref
      name="dupload" section="1">和<manref name="dput" section="1">)，這個過
      程將會變得更容易。我們將仔細描述如何使用<prgn/dupload/來完成這一工作。
 
   <p>首先你必需設定dupload的設定檔案。你可以修改會影響整個系統的檔案<file>
      /etc/dupload.conf</file>，或是是建立一個屬於你自己的檔案<file>
      ~/.dupload.conf</file>，來覆寫系統檔案中一些你希望修改的部分。把下面的
      內容加入到檔案中去： 
 
   <p><example>
   package config;
 
   $default_host = "anonymous-ftp-master";
 
   $cfg{'anonymous-ftp-master'} = {
         fqdn => "ftp-master.debian.org",
         method => "ftp",
         incoming => "/pub/UploadQueue/",
         # files pass on to dinstall on ftp-master which sends emails itself
         dinstall_runs => 1,
   };
 
   1;
   </example>
 
   <p>當然，要把我的個人設定改成你的，再閱讀一下<manref name="dupload.conf"
      section="5">的手冊，搞懂這裡的每一個選項是什麼意思。
 
   <p>設定$default_host選項是最有竅門的──它會自動檢查預設情況下究竟使用哪一個
      上傳序列。“anonymous-ftp-master”是一個主序列，但很有可能你會希望能夠使
      用另外一個更快的。要了解關於上傳序列(queues)的更多內容，請閱讀位於<file>
      &uploading;</file>的開發人員參考中“Uploading a package”一節。
 
   <p>然後連線到你的Internet服務提供商，並且執行下面的命令：
   
   <p><example>
   dupload gentoo_0.9.12-1_i386.changes
   </example>
 
   <p><prgn/dupload/會檢查檔案的MD5校驗碼是否和.changes檔案中的相同，正因為
      此，它才會像在<ref id="completebuild">中所述警告你重新建立套裝軟體，
      只有這樣它才能正常上傳套裝軟體。
 
   <!-- (不要再使用ftp-master了)
   <p>如果你上傳到伺服器"ftp-master"，<prgn/dupload/會詢問你在那台Debian服務
      器上的密碼，然後自動上傳它。
   -->
 
   <p>如果你在<url id="&ftp-uploadqueue;">上傳時遇到問題，可以透過用<prgn>
   ftp</prgn>程式手動上傳以gnupg簽名的<file>*.commands</file>檔案到<url
   id="&ftp-uploadqueue;">來解決這個問題。
 
   <footnote>
   參考<url id="&ftp-command;">。此外你也可以使用<package>dput</package>中
   的<prgn>dcut</prgn>命令。
   </footnote>
   例如，使用<file>hello.commands</file>:
 <example>
 -----BEGIN PGP SIGNED MESSAGE-----
 
 Uploader: Roman Hodek &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;
 Commands: 
  rm hello_1.0-1_i386.deb
  mv hello_1.0-1.dsx hello_1.0-1.dsc
 
 -----BEGIN PGP SIGNATURE-----
 Version: 2.6.3ia
 
 iQCVAwUBNFiQSXVhJ0HiWnvJAQG58AP+IDJVeSWmDvzMUphScg1EK0mvChgnuD7h
 BRiVQubXkB2DphLJW5UUSRnjw1iuFcYwH/lFpNpl7XP95LkLX3iFza9qItw4k2/q
 tvylZkmIA9jxCyv/YB6zZCbHmbvUnL473eLRoxlnYZd3JFaCZMJ86B0Ph4GFNPAf
 Z4jxNrgh7Bc=
 =pH94
 -----END PGP SIGNATURE-----
 </example>
 
   <sect id="upload-private">上傳到私有的檔案庫
 
   <p>如果你想要建立一個私有的檔案庫，並以開發者的身份簡單使用<tt>dupload
   -t <var>target_name</var></tt>命令將其放在<tt>
   URL="http://people.debian.org/~<var>account_name</var>"</tt>中，
   你需要在<file>/etc/dupload.conf</file>檔案中加入：
 <example>
 # Developer account
 $cfg{'<var>target_name</var>'} = {
         fqdn =&gt; "people.debian.org",
         method =&gt; "scpb",
         incoming =&gt; "/home/<var>account_name</var>/public_html/package/",
         # I do not need to announce
         dinstall_runs =&gt; 1,
 };
 $cfg{'<var>target_name</var>'}{preupload}{'changes'} = "
         echo 'mkdir -p public_html/package' | ssh people.debian.org  2&gt;/dev/null ; 
         echo 'Package directory created!'";
 
 $cfg{'<var>target_name</var>'}{postupload}{'changes'} = "
         echo 'cd public_html/package ;
         dpkg-scanpackages . /dev/null &gt;Packages || true ;
         dpkg-scansources . /dev/null &gt;Sources || true ;
         gzip -c Packages >Packages.gz ;
         gzip -c Sources &gt;Sources.gz ' | ssh people.debian.org  2&gt;/dev/null ;
         echo 'Package archive created!'";
 
 </example>
 這裡，APT檔案庫是使用一個快速但寫的不太好的腳本透過遠端SSH來完成的。<prgn>
 dpkg-scanpackages</prgn>和<prgn>dpkg-scansources</prgn>需要的覆寫檔案都使
 用了<file>/dev/null</file>。非Debian開發者可以使用這一技術在他自己的Web站
 點上放置他自己的包裝檔。你也可以使用<prgn>apt-ftparchive</prgn>或其它腳本來創
 建APT檔案庫。
 
   <chapt id="update">更新套裝軟體
 
   <sect id="newrevision">新的Debian修訂版
 
   <p>現在我們假設有人提交了一個關於你的套裝軟體的bug報告，第#54321號，它描述了
      一個你可以解決的問題。要為你的套裝軟體建立一個新的Debian修訂版，你需要：
 
   <list>
   <item>當然，必需更正套裝軟體的來源程式碼中的問題。
 
   <item>在Debian changelog檔案中增加一個新的修訂版，比如透過命令“<tt>
   dch -i</tt>”或是是“<tt>dch -v &lt;version&gt;-&lt;revision&gt;</tt>”。然後
   用你喜歡的純文字編輯器插入新的關於修改的註解資訊。
 
   <p>小技巧：如何才能方便地以希望的格式得到日期呢？使用“<tt>822-date</tt>”或 
      者是“<tt>date -R</tt>”。
 
   <item>在changelog的項目上包裝檔含一份對bug的簡短描述以及解決方法，並將它附加
   在“Closes: #54321”之後。這樣，當你的套裝軟體被Debian文件庫接受的時候，這
   個bug報告將會被文件維護軟體自動關閉。
   
   <item>重覆你在<ref id="completebuild">、<ref id="checkit">和<ref
   id="upload">中所做的。不同的是這一次，原始的來源程式碼將不會被包裝檔括，因為它們並
   沒有被修改並且已經存在於Debian的文件庫中了。
   </list>
 
   <sect id="newupstream">新的上游版本(基本)
 
   <p>現在我們來考慮另外一種情況，一種稍微複雜一點的情況──一個上游的版本發佈
   了，當然你會希望它能夠被打包裝檔。你需要做下面的事情：
 
   <list>
   <item>下載新版本的來源程式碼，並將它的壓縮檔(比如“gentoo-0.9.13.tar.gz”)放到原
   先的來源程式碼目錄樹的上層目錄中(比如~/gentoo/)。 
 
   <item>進入舊的來源程式碼目錄，並且執行下面的命令：
 
   <example>
   uupdate -u gentoo-0.9.13.tar.gz
   </example>
 
   <p>當然用你的新程式的文件名稱取代掉這裡的檔案名稱。<manref name="uupdate"
      section="1">將會修改這個壓縮檔的名字，還會試著將原先<file>.diff.gz
      </file>檔案中的所有的修改套用到它上面，並且會更新新的<file>
      debian/changelog</file>檔案。
 
   <item>更換到目錄“<file>../gentoo-0.9.13</file>”中，它是新的套裝軟體來源碼目
      錄樹，重覆你在<ref id="completebuild">、<ref id="checkit">和<ref
      id="upload">中所做的。
   </list>
 
   <p>注意如果你已經如<ref id="watch">所述建立了一個“<file>debian/watch
      </file>”檔案，那麼你就可以透過執行<manref name="uscan" section="1">來自
      動偵測新版本的來源程式碼並下載它們，然後執行<prgn/uupdate/。
 
   <sect id="newupstream-real">新的上游版本 (實際的)
 
   <p>當為Debain檔案庫準備套裝軟體時，你必須仔細檢查最終的套裝軟體。下面是一個更加
      實際的程序。
 
 <enumlist compact>
 
 <item>校驗上游修改
 
 <list compact>
 
 <item>閱讀上游的<file>changelog</file>、<file>NEWS</file>及其它可能和新版本
 一起發佈的文件。
 
 <item>用“<tt>diff -urN</tt>”比較新舊上游套裝軟體的差別，從而對修改的範圍有個概
 略性的了解，哪些工作已經完成了(同時因此在哪裡可能會有新的bug)，而且還要留心
 觀察任何值得懷疑的東西。
 
 </list>
 
 <item>把舊Debian套裝軟體升級為新版本。
 
 <list compact>
 
 <item>解壓來源碼包裝檔，並修改來源碼樹的根目錄為<file>
 &lt;packagename&gt;-&lt;upstream_version&gt;/</file>並“<tt>cd</tt>”到此目錄中。
 
 <item>複製父目錄中的來源碼包裝檔並將其更名為<file>
 &lt;packagename&gt;_&lt;upstream_version&gt;.orig.tar.gz</file>。
 
 <item>對新的來源碼樹也進行與舊來源碼樹一樣的修改。可能的方法有：
 <list compact>
 <item>“<tt>zcat <var>/path/to/</var>&lt;packagename&gt;_&lt;old-version&gt;.diff.gz | patch -p1</tt>”命令，
 <item>“<prgn>uupdate</prgn>”命令
 <item>“<tt>svn merge</tt>”命令，如果你使用Subversion倉庫來管理來源碼，或是
 <item>直接將<file>debian/</file>目錄從舊來源碼樹複製到新的來源碼樹中，如果它是
 用<package>dpatch</package>打包裝檔的。
 </list>
 
 <item>保留舊的修改日誌項目(看上去不重要，但其實隨時會有意外...)
 
 <item>新套裝軟體的版本應該由上游版本號加上Debian修訂號<tt>-1</tt>構成，例
 如“<tt>0.9.13-1</tt>”。
 
 <item>在<file>debian/changele</file>檔案的頂部為此新版本加入修改日誌項目
 ──“新的上游版本”。例如“<tt>dch -v 0.9.13-1</tt>”.
 
 <item>簡要地說明新上游版本<em>中</em>修復的已報bug並在修改日誌中關閉這些bug。
 
 <item>簡要地說明維護者為修復已報bug<em>對</em>新上游版本所做的修改並且在修改
 日誌中關閉這些bug。
 
 <item>如果補綴或是合併的程序並不順利，就要仔細地查出哪些地方有錯誤(在<file>
 .rej</file>檔案中會留下線索。)多數情況下是因為你使用的補綴已經整合到上游版本
 中，這樣就不再需要那補綴了。
 
 <item>向新版本的升級應當是安靜地且不會打擾到使用者(除非是發現舊的bug已經被修復
 或是增加了新的功能，已有的使用者應當不會注意到升級。)
 <footnote>
 請讓你的套裝軟體在升級的時候使用設計良好的<prgn>postinst</prgn>等來正確地更新
 組態檔案，從而使它<strong>不至於</strong>做出使用者不希望的事情！這更有助於解
 釋人們<strong>為什麼</strong>選擇Debian。
 <p>
 如果升級必須要造成影響(譬如組態檔案分在在不同的home目錄中且有完全不同的結
 構)，作為最後的選擇，你也許應當考慮將套裝軟體設定為安全的預設狀態(譬如關閉服
 務)並根據政策的要求提供相對的文件(在<file>README.Debian</file>和<file>
 NEWS.Debian</file>)。
 </footnote>
 
 <item>如果你處於某種原因需要已經刪除的模板檔案，你可以在同一個已經“debian化”
 的目錄中再次執行<prgn>dh_make</prgn>，執行時加上<tt>-o</tt>選項。然後就可以
 修改它了。
 
 <item>應當對已經存在的Debian修改進行重新評估；除非有什麼不得已的原因，都應當
 刪除掉上游作者已經合併的(無論何種形式)並繼續保留上游作者並未合併的。
 
 <item>If any changes were made to the build system (hopefully you'd know
 from the step 1 and update the <file>debian/rules</file> and
 <file>debian/control</file> build dependencies if necessary.
 
 </list>
 
 <item>如<ref id="debuild">或<ref id="pbuilder">所述建立新的套裝軟體。最好是使
 用<package>pbuilder</package>。
 
 <item>核對新套裝軟體是否建構正確。
 
 <list compact>
 
 <item>執行 <ref id="checkit">.
 
 <item>執行 <ref id="upgrading">.   
 
 <item>在此檢查是否有已經修復但在<url name="Debian Bug追蹤系統(BTS)"
 id="http://www.debian.org/Bugs/">仍然為開啟狀態的bug。
 
 <item>檢查.changes檔案的內容以確認你把套裝軟體上傳到了正確的發行版中、已經關閉
 的bug已經列出在“Closes:”網域中，而“Maintainer:Check”和“Changed-By:”網域可以匹配，
 以及檔案已經用GPG簽署等等。
 
 </list>
 
 <item>如果為修正任何內容而修改了套裝軟體，請傳回到第2步直到滿意。
 
 <item>如果你需要別人幫助才可以上傳，請一定要注意在建構套裝軟體的時候使用特殊的
 選項(如“<tt>dpkg-buildpackage -sa -v ...</tt>”)，同時請知會幫助你上傳的人以便他/她能夠正確建構套裝軟體。
 
 <item>如果你自己上傳，執行<ref id="upload">.
 </enumlist>
 
   <sect id="orig-tar"><file>orig.tar.gz</file>檔案
   <p>如果你建構軟體時使用的來源碼樹只有<file>debian/</file>目錄而沒有<file>
      orig.tar.gz</file>檔案在其父目錄中，最後你將得到一個Debian專用來源碼包裝檔，
      而沒有<file>diff.gz</file>檔案。這種包裝檔裝方式應當只有對那些Debian專用的軟
      件適用，這些套裝軟體在其它發行版中應當是完全沒有用處的。
   <footnote>
   有些人認為，即便是對Debian專用的套裝軟體，最好還是應當將<file>debian/
   </file>目錄中的內容分離到<file>diff.gz</file>檔案中，而不是放在<file>
   orig.tar.gz</file>檔案中。
   </footnote>
 
   <p>要獲得由<file>orig.tar.gz</file>和<file>diff.gz</file>兩個檔案構成的
      非Debian專用的來源碼包裝檔，你必須手動複製上游套裝軟體到父目錄中，並將其名稱改
      為<file>&lt;packagename&gt;_&lt;upstream_version&gt;.orig.tar.gz
      </file>，如<ref id="dh_make">所述由<prgn>dh_make</prgn>所做的那樣。
 
   <sect id="cvs-buildpackage"><prgn>cvs-buildpackage</prgn>命令和similes
 
   <p>你應當考慮使用一些來源碼關係系統來管理套裝軟體。有幾個腳本已經被訂製用於和
      多數流行的系統一起工作。
 <list compact>
 <item>CVS
 <list compact>
 <item><package>cvs-buildpackage</package>
 </list>
 <item>Subversion
 <list compact>
 <item><package>svn-buildpackage</package>
 </list>
 <item>Arch (tla)
 <list compact>
 <item><package>tla-buildpackage</package>
 <item><package>arch-buildpackage</package>
 </list>
 </list>
   <p>這些命令也可以使對新版上游軟體的打包裝檔自動化。
 
   <sect id="upgrading">校驗套裝軟體的升級
 
   <p>當你建立了一個套裝軟體的新版本，你必需做下面的事情來確認所有的人都可以
   安全的升級：
 
   <list>
     <item>從原先的版本升級，
     <item>降級到原先的版本並刪除它，
     <item>安裝新的套裝軟體，
     <item>刪除它然後重新安裝它一遍，
     <item>徹底清楚它。
   </list>
 
   <p>注意如果你以前的套裝軟體已經被發佈到Debian，人們會通常會更新到Debian最新
      的發佈中的那個版本上，所以要記得測試從那個版本升級的情況。
 
   <chapt id="helpme">在哪裡可以找到幫助
 
   <p>在你決定要在一些公共地方提出你的問題時，請先RTFM。包裝檔括在<file>
      /usr/share/doc/dpkg</file>、<file>/usr/share/doc/debian</file>、<file>
      &autotools-dev;</file>和<file>/usr/share/doc/package/*</file>等目錄中的
      文件和所有在文件中提及的程式的man/info頁面。在<url id="&nm-home;">和<url
      id="&mentors-faq;">可以看到詳細的資訊。
 
   <p>如果你有一些關於軟體打包裝檔的問題，但卻無法從文件中找出答案，你可以在Debian
      Mentors信件列表上提出你的問題，信件列表
      在<email/debian-mentors@lists.debian.org/。一些經驗更豐富的Debian開發人
      員將會很高興地幫助你，但在問問題前你要確定確實至少讀過一些文件！
 
   <p>更多的關於這個信件列表的資訊可以在<url
      id="http://lists.debian.org/debian-mentors/">找到。
 
   <p>當你收到一個bug報告(是的，真正的bug報告！)，就是需要你去<url 
      name="Debian Bug Tracking System" id="http://www.debian.org/Bugs/">看看
      並讀一下那裡的文件的時候了，這樣你才能高效地處理bug。我強烈建議你閱讀一
      下開發人員手冊中“Handling Bugs”一節，它位於<file>&bughandling;</file>。
 
   <p>如果你仍然有問題，可以在Debian開發人員信件列表上把它提出來，這個信件列
      表位於<email/debian-devel@lists.debian.org/。要想了解更多關於這個信件列
      表的資訊，請參考<url id="http://lists.debian.org/debian-devel/">。
 
   <p>即便所有的東西都工作正常，也到了你祈禱的時候了。為什麼？因為在幾小時(或
      者幾天)之後，全球各地的Debian使用者將會開始使用你的套裝軟體，如果你犯了一些
      嚴重的錯誤，那麼你的郵箱就會因受到太多憤怒的使用者的抱怨而爆炸…… 笑笑吧。
      :-)
 
   <p>放鬆一下然後為接受bug報告做準備吧，因為在你的套裝軟體能夠完全符合Debian的
      各種政策之前還有很多工作要做呢(再說一遍，一定要閱讀<em>文件原文</em>來
      了結詳細資訊哦)。祝你好運！
 
 <appendix id="pkg-eg">例子
   <p>現在我們來給上游軟體<var>gentoo-1.0.2</var>.tar.gz打包裝檔，並且上傳所有的
      套裝軟體到<tt><var>nm_target</var></tt>.
 
 <sect id="pkg-simple">簡單打包裝檔例子
 <p>
 <example>
 $ mkdir -p <var>/path/to</var> # new empty directory
 $ cd <var>/path/to</var>
 $ tar -xvzf <var>/path/from/gentoo-1.0.2</var>.tar.gz # get source
 $ cd <var>gentoo-1.0.2</var>
 $ dh_make -e <var>name@domain.dom</var> -f <var>/path/from/gentoo-1.0.2</var>.tar.gz
 ... Answer prompts.
 ... Fix source tree
 ... If it is a script package, set debian/control to "Architecture: all"
 ... Do not erase ../<var>gentoo_1.0.2</var>.orig.tar.gz
 $ debuild
 ... Make sure no warning happens.
 $ cd ..
 $ dupload -t <var>nm_target</var> <var>gentoo_1.0.2-1</var>_i386.changes
 </example>
 
 
 <sect id="pkg-dpatch">用<package>dpatch</package>和<package>pbuilder</package>打包裝檔
 <p>
 <example>
 $ mkdir -p <var>/path/to</var> # new empty directory
 $ cd <var>/path/to</var>
 $ tar -xvzf <var>/path/from/gentoo-1.0.2</var>.tar.gz
 $ cp -a  <var>gentoo-1.0.2</var> <var>gentoo-1.0.2-orig</var>
 $ cd <var>gentoo-1.0.2</var>
 $ dh_make -e <var>name@domain.dom</var> -f /path/from/<var>gentoo-1.0.2</var>.tar.gz
 ... Answer prompts.
 ... Fix source tree by editor
 ... Try building packages message "dpkg-buildpackage -rfakeroot -us -uc"
 ... Edit source to make source buildable.
 ... Do not erase ../<var>gentoo_1.0.2</var>.orig.tar.gz
 $ cd ..
 $ cp -a <var>gentoo-1.0.2</var> <var>gentoo-1.0.2-keep</var> # safety backup
 $ mv <var>gentoo-1.0.2</var>/debian debian
 $ diff -Nru  <var>gentoo-1.0.2-orig</var> <var>gentoo-1.0.2</var> &gt; <var>patch-file</var>
 ... You may overwrite <var>gentoo-1.0.2</var> directory while doing this.
 ... Make sure to keep <var>gentoo-1.0.2</var>-keep for your safety
 $ mkdir -p debian/patches
 $ dpatch patch-template <var>patch-file</var> \
    -p "01_patchname" "patch-file description" \
    &lt; <var>patch-file</var> &gt; debian/patches/01_patchname.dpatch
 $ cd debian/patches
 $ echo 01_patchname.dpatch >00list
 $ cd ../.. # back to <var>/path/to</var>
 $ rm -rf <var>gentoo-1.0.2</var>
 $ editor debian/rules
 </example>
 現在檔案<file>debian/rules</file>的內容是：
 <example>
 config.status: configure
      ./configure --prefix=/usr --mandir=/usr/share
 build: config.status
      ${MAKE}
 clean:
      $(testdir)
      $(testroot)
      ${MAKE} distclean
      rm -rf debian/imaginary-package debian/files debian/substvars
 </example>
 你可以用編輯器修改<file>debian/rules</file>檔案為以下內容使其使用<package>
 dpatch</package>:
 <example>
 config.status: patch configure
      ./configure --prefix=/usr --mandir=/usr/share
 build: config.status
      ${MAKE}
 clean: clean-patched unpatch
 clean-patched:
      $(testdir)
      $(testroot)
      ${MAKE} distclean
      rm -rf debian/imaginary-package debian/files debian/substvars
 patch: patch-stamp
 patch-stamp:
      dpatch apply-all
      dpatch call-all -a=pkg-info >patch-stamp
 
 unpatch:
      dpatch deapply-all
      rm -rf patch-stamp debian/patched
 </example>
 <p>
 現在你可以用<package>dpatch</package>系統重新打包裝檔了。
 <example>
 $ tar -xvzf <var>gentoo_1.0.2</var>.orig.tar.gz
 $ cp -a debian/ <var>gentoo-1.0.2</var>/debian
 $ cd <var>gentoo-1.0.2</var>
 $ sudo pbuilder update
 $ pdebuild
 $ cd /var/cache/pbuilder/result/
 $ dupload -t <var>nm_target</var> <var>gentoo_1.0.2-1</var>_i386.changes
 </example>
 
  </book>
 
 </debiandoc>
