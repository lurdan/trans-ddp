<!-- CVS revision of original english document "1.28" -->

<chapt>Après l'installation

<p>Une fois que le système est installé, vous pouvez encore faire plus pour
sécuriser le système&nbsp;; certaines des étapes décrites ci-dessous peuvent
être effectuées. Bien sûr, cela dépend vraiment de votre configuration, mais
pour prévenir un accès physique, vous devriez lire <ref id="bios-boot">,<ref
id="lilo-passwd">,<ref id="kernel-root-prompt">, <ref id="floppy-boot">, <ref
id="restrict-console-login"> et <ref id="restrict-reboots">.

<p>Avant de vous connecter à tout réseau, particulièrement s'il s'agit d'un
réseau public, vous devez, au minimum, exécuter une mise à jour de sécurité
(voir <ref id="security-update">). Vous pouvez optionnellement prendre un
instantané de votre système (voir <ref id="snapshot">).

<sect id="debian-sec-announce">S'abonner à la liste de diffusion Debian Security Announce

<p>Pour recevoir des informations sur les mises à jour de sécurité disponibles,
vous devriez vous abonner à la liste de diffusion debian-security-announce pour
recevoir les Avis de Sécurité Debian<footnote>
Debian Security Advisories</footnote> (DSAs). Voir <ref id="debian-sec-team">
pour plus d'informations sur la façon dont fonctionne l'équipe de sécurité
Debian. Pour des informations sur l'inscription aux listes de diffusion Debian,
lisez <url id="http://lists.debian.org">.

<p>Les DSAs sont signées par la signature de l'équipe de sécurité Debian qui
peut être récupérée depuis <url id="http://security.debian.org">.

<p>Vous devriez également envisager de vous abonner à la <url
id="http://lists.debian.org/debian-security" name="liste de diffusion
debian-security"> pour des discussions générales sur les problèmes de sécurité
dans le système d'exploitation Debian. Vous pourrez entrer en contact
avec d'autres administrateurs système ainsi qu'avec des développeurs
Debian et des développeurs amont d'outils de sécurité qui pourront
répondre à vos questions et proposer leurs conseils.

<p>FIXME: ajouter la clé ici également&nbsp;?

<sect id="security-update">Se mettre à jour au niveau de la sécurité

<p>
Dès que de nouveaux bogues de sécurité sont décelés dans les paquets, les 
responsables Debian et les auteurs en amont les corrigent dans les journées ou les
heures suivantes. Une fois le bogue résolu, un nouveau paquet est fourni sur <url
name="http://security.debian.org" id="http://security.debian.org">.

<p>Si vous installez une version de Debian, vous devez prendre en compte qu'il a
pu y avoir des mises à jour de sécurité depuis la publication après qu'il a été
déterminé qu'un paquet donné est vulnérable. Ainsi, il a pu y avoir des révisions
mineures (il y en a eu sept dans la version Debian 2.2 <em>Potato</em>) incluant
ces mises à jour de paquets.

<p>Vous devez noter la date à laquelle votre support amovible (si vous en
utilisez un) a été créé et vérifier le site de sécurité pour savoir s'il y a eu
des mises à jour de sécurité. S'il y en a et que vous ne pouvez pas télécharger
les paquets du site de sécurité sur un autre système (vous n'êtes pas encore
connecté à l'Internet, n'est-ce pas&nbsp;?) avant de vous connecter au réseau,
vous devriez évaluer (si vous n'êtes pas protégé par un pare-feu par exemple)
d'ajouter des règles de pare-feu pour que votre système ne puisse se connecter
qu'à security.debian.org et ensuite réaliser la mise à jour. Une configuration
exemple est donnée dans <ref id="fw-security-update">.

<p><em>Remarque&nbsp;:</em>Depuis Debian Woody&nbsp;3.0, après l'installation, il
vous est donné la possibilité d'ajouter les mises à jour de sécurité au système.
Si vous répondez «&nbsp;oui&nbsp;» (yes ?) à cette question, le système d'installation
prendra les étapes nécessaires pour ajouter la source pour les mises à jour de
sécurité aux sources de paquets et votre système, s'il a une connexion Internet,
téléchargera et installera toutes les mises à jour de sécurité qui auront pu
être produites depuis la création de votre support. Si vous mettez à jour depuis
une version précédente de Debian ou si vous demandez au système de ne pas faire
cela, vous devriez suivre les étapes décrites ici.

<p>
Pour mettre à jour manuellement le système, insérez la ligne suivante dans votre
<file>sources.list</file> et vous recevrez les mises à jour de sécurité
automatiquement quand vous mettrez à jour votre système.

<example>
  deb http://security.debian.org/debian-security stable/updates main contrib non-free
</example>

<p>
Une fois ceci fait, vous pouvez utiliser soit <package>apt</package>, soit
<package>dselect</package> pour les mises à jour&nbsp;:

<list>
<item>Si vous voulez utiliser <package>apt</package>, exécutez simplement (en
tant que root)&nbsp;:
<example>
# apt-get update
# apt-get upgrade
</example>
<item>Si vous voulez utiliser <package>dselect</package>, choisissez
tout d'abord [M]ise à jour ([U]pdate), puis [I]nstaller ([I]nstall) et
enfin [C]onfigurer ([C]onfigure) pour mettre à jour et installer les paquets.
</list>

<p>
Si vous voulez, vous pouvez ajouter également les lignes deb-src à
<file>/etc/apt/sources.list</file>. Voir <manref name="apt" section="8"> pour
plus de détails.

<p>Remarque&nbsp;: vous n'avez <em>pas</em> besoin d'ajouter la ligne suivante&nbsp;:

<example>
  deb http://security.debian.org/debian-non-US stable/non-US main contrib non-free
</example>

<p>
car security.debian.org est hébergé à un emplacement hors des États-Unis et n'a
donc pas d'archive non-US séparée.


<!-- <p>
Vous devriez procéder à des mises à jour fréquemment, la plupart des piratages 
est le résultat de vulnérabilités connues mais qui n'ont pas été raccommodées à 
temps, tel que le décrit le <url id="http://www.cs.umd.edu/~waa/vulnerability.html"
 name="texte de Bill Arbaugh"> (présenté au Symposium IEEE 2001 sur la Sécurité et 
 la Vie Privé).

<p>FIXME&nbsp;: Ajouter des informations sur comment est réalisé la signature des paquets, ce qui peut
être réalisé automatiquement par un cron job (Gros avertissement: DNS spoofing).
 -->

<sect1 id="lib-security-update">Mise à jour de sécurité des bibliothèques

<p>Une fois que vous avez exécuté une mise à jour de sécurité, il se
peut que vous deviez redémarrer certains des services système. Si vous
ne faites pas cela, certains services pourraient encore être vulnérables
après une mise à jour de sécurité. La raison pour cela est que les
démons qui fonctionnent avec une mise à jour peuvent encore utiliser les
anciennes bibliothèques après la mise à jour<footnote>Bien que les
bibliothèques aient été supprimées du système de
fichiers, les i-noeuds ne seront pas nettoyés tant qu'un programme a
encore un descripteur de fichier pointant dessus</footnote>. Pour détecter
quels démons peuvent devoir être redémarrés, vous pouvez utiliser le
programme <prgn>checkrestart</prgn> (disponible dans le paquet
<package>debian-goodies</package>) ou utiliser cet ligne de commande (en
tant que root)&nbsp;:

<example>
# lsof | grep dpkg- | awk '{print $1, $8}' | sort +0
</example>

<P>Certains paquets (comme <package>libc6</package>) feront cette
vérification dans la phase de post-installation pour un nombre limité de
services en particulier car une mise à jour de bibliothèques
essentielles peut casser certaines applications (avant leur
redémarrage)<footnote>Ceci s'est produit, par exemple, dans la mise à
jour de la libc6 2.2.x à la 2.3.x à cause de problèmes
d'authentification NSS, voir <url
id="http://lists.debian.org/debian-glibc/2003/debian-glibc-200303/msg00276.html">.</footnote>.

<P>Faire passer le système en niveau d'exécution&nbsp;1 (utilisateur
seul), puis ensuite au niveau d'exécution&nbsp;3 (multi-utilisateurs)
devrait entraîner le redémarrage de la plupart (si ce n'est tous) des
services système. Mais cela n'est pas une possibilité si vous exécutez
la mise à jour de sécurité depuis une connexion distante (comme ssh) car
celle-ci serait alors interrompue.

<p>Apportez le plus grand soin lors des mises à jour de sécurité si vous
les réalisez depuis une connexion à distance comme ssh. Une procédure
suggérée pour une mise à jour de sécurité qui implique un redémarrage de
service est de redémarrer le démon SSH, puis immédiatement de tenter une
nouvelle connexion ssh sans interrompre la précédente. Si la connexion
échoue, annulez la mise à jour et analysez le problème. 

</sect1>
<sect1 id="kernel-security-update">Mise à jour de sécurité du noyau

<P>Assurez-vous tout d'abord que votre noyau est géré par le système de
gestion des paquets. Si vous l'avez installé en utilisant le système
d'installation de Debian&nbsp;3.0 ou de versions précédentes, votre
noyau <em>n'est pas</em> intégré dans le système de gestion des paquets
et pourrait être obsolète. Vous pouvez facilement confirmer cela en
exécutant&nbsp;:

<example>
$ dpkg -S `readlink -f /vmlinuz`
kernel-image-2.4.27-2-686: /boot/vmlinuz-2.4.27-2-686
</example>

<p>Si votre noyau n'est pas géré par ce système, vous verrez un message
indiquant que le gestionnaire de paquets n'a pas trouvé le fichier
associé à un paquet au lieu du message ci-dessus qui veut dire que
le fichier associé au noyau actuellement en fonctionnement est fourni
par le paquet <package>kernel-image-2.4.27-2-686</package>. Dans le
premier cas, vous devrez installer manuellement un paquet d'image de
noyau. L'image de noyau exact que vous devez installer dépend de votre
architecture et de votre version de noyau préférée. Une fois ceci fait,
vous pourrez gérer les mises à jour de sécurité du noyau comme pour tout
autre paquet. Dans tous les cas, notez que les mises à jour de noyau ne
seront faites <em>que</em> pour la même version de noyau que celui que vous
utilisez, c'est-à-dire que <prgn>apt</prgn> ne va pas mettre à jour
automatiquement votre noyau de la version&nbsp;2.4 à la version&nbsp;2.6
(ou de la version&nbsp;2.4.26 à la version&nbsp;2.4.27<footnote>Sauf si
vous avez installé un méta-paquet de noyau comme
<package>kernel-image-2.4-686</package> qui va toujours tirer la
dernière révision mineure de noyau pour une version de noyau et une
architecture donnée</footnote>).

<p>Le système d'installation de la version&nbsp;3.1 de Debian gérera le
noyau sélectionné (soit 2.4 ou 2.6) comme partie du système de gestion
des paquets. Vous pouvez vérifier quels noyaux sont installés en exécutant&nbsp;:

<example>
$ COLUMNS=150 dpkg -l 'kernel-image*' | awk '$1 ~ /ii/ { print $0 }'
</example>

<p>Pour voir si votre noyau doit être mis à jour, exécutez&nbsp;:

<example>
$ kernfile=`readlink -f /vmlinuz`
$ kernel=`dpkg -S $kernfile | awk -F : '{print $1}'`
$ apt-cache policy $kernel
kernel-image-2.4.27-2-686:
  Installed: 2.4.27-9
  Candidate: 2.4.27-9
  Version Table:
 *** 2.4.27-9 0
(...)
</example>


<P>Si vous effectuez une mise à jour de sécurité incluant l'image du
noyau, vous <em>devez</em> redémarrer le système pour que la mise à jour
de sécurité soit utile. Sinon, vous utiliserez encore l'ancienne image
de noyau (vulnérable).

<!-- FIXME: Faire un script pour vérifier cela, peut-être en utilisant ps -p 1 -o etime | tail -1
et obtenir la date de création `readlink -f /vmlinuz` -->

<p>Si vous devez effectuer un redémarrage du système (à cause d'une mise
à jour du noyau), vous devriez vous assurer que le noyau démarrera
correctement et que la connectivité réseau sera restaurée,
particulièrement si la mise à jour de sécurité est réalisée depuis une
connexion à distance comme ssh. Pour le premier point, vous pouvez
configurer le chargeur d'amorçage pour redémarrer l'ancien noyau en cas
d'échec (pour des informations plus détaillées, veuillez lire (en anglais)
<url id="http://www.debian-administration.org/?article=70"
name="Remotely rebooting Debian GNU/Linux machines">). Pour le second
point, vous devez introduire un script de test de connectivité réseau
qui vérifiera si le noyau a lancé le sous-système réseau correctement
et qui redémarrera le système si ce n'est pas le cas<footnote>Un exemple de
tel script appelé
<url id="http://www.debian-administration.org/articles/70/testnet" name="testnet">
est disponible dans l'article <url id="http://www.debian-administration.org/?article=70" 
name="Remotely rebooting Debian GNU/Linux machines">. Un script de test
de connectivité réseau plus élaboré est disponible dans l'article
<url id="http://www.debian-administration.org/?article=128" 
name="Testing network connectivity">.</footnote>. Ceci devrait prévenir
des surprises désagréables comme une mise à jour du noyau en réalisant
après un redémarrage qu'il n'a pas détecté ou configuré le matériel
réseau correctement et que vous devez parcourir une longue distance pour
relancer à nouveau le système. Bien sûr, avoir la console
série<footnote>Configurer une console série est en dehors du cadre de ce
document, pour plus d'informations, veuillez lire le
<url id="http://www.tldp.org/HOWTO/Serial-HOWTO.html" name="Serial HOWTO">
et le <url id="http://www.tldp.org/HOWTO/Remote-Serial-Console-HOWTO/index.html"
name="Remote Serial Console HOWTO">.</footnote> du système connectée à
une console ou un serveur de terminal devrait également aider à déboguer
à distance les problèmes de redémarrage.
</p>

</sect1>

<sect id="bios-boot">Changer le BIOS (à nouveau)

<p>Vous vous souvenez de <ref id="bios-passwd">&nbsp;? Et bien, vous devriez
maintenant, une fois que vous n'avez plus besoin de démarrer à partir d'un
support amovible, changer la configuration par défaut du BIOS pour qu'il ne
puisse démarrer <em>que</em> depuis le disque dur. Assurez-vous de ne pas perdre
le mot de passe BIOS, sinon, en cas de défaillance du disque dur, vous ne
pourrez pas retourner dans le BIOS et modifier la configuration pour le
récupérer en utilisant, par exemple, un cédérom.

<p>Un autre moyen moins sécurisé, mais plus pratique est de changer la
configuration pour que le système s'amorce depuis le disque dur et, si cela
échoue, d'essayer un support amovible. À propos, c'est ainsi fait parce que la
plupart des personnes n'utilisent pas le mot de passe BIOS très souvent&nbsp;;
il est facilement oublié.

<sect id="lilo-passwd">Attribuer un mot de passe à LILO ou GRUB 
<p>
N'importe qui peut obtenir facilement un shell root et changer 
vos mots de passe en entrant au prompt de boot <tt>&lt;nom-de-votre-image-de-boot&gt; 
init=/bin/sh</tt>. Après le changement du mot de passe et le redémarrage du
système, la personne a un accès root illimité et peut faire tout ce qu'elle
veut sur le système. Après ceci, vous n'aurez plus d'accès root sur votre machine,
étant donné que vous ne connaîtrez pas le mot de passe.
<p>
Pour être sûr que cela ne puisse pas se produire, vous devriez attribuer un
mot de passe au démarrage. Vous avez le choix entre un mot de passe global et un 
mot de passe pour une image donnée.

<p>
Pour LILO, vous avez besoin d'éditer le fichier <file>/etc/lilo.conf</file> et ajouter les lignes
<tt>password</tt> ainsi que <tt>restricted</tt> comme dans l'exemple suivant.

<example>
  image=/boot/2.2.14-vmlinuz
     label=Linux
     read-only
     password=piratemoi
     restricted
</example>

<p>
Une fois terminé, relancez lilo. Omettre la ligne <tt>restricted</tt> entraîne une attente 
de mot de passe, en dépit des paramètres passés à LILO.
Les permissions par défaut pour le fichier <file>/etc/lilo.conf</file> accordent à root les 
droits de lecture et d'écriture et permettent un accès en lecture seule pour le groupe
de configuration de <file>lilo.conf</file>, à savoir root.

<p>
Si vous utilisez GRUB plutôt que LILO, éditez <file>/boot/grub/menu.lst</file>
et ajoutez les deux lignes suivantes en début (en remplaçant, bien sûr, <tt>piratemoi</tt> par
le mot de passe désiré). Ceci empêche les utilisateurs d'éditer les options de démarrage.
<tt>timeout 3</tt> indique un délai de 3 secondes avant que <prgn>grub</prgn> démarre l'option par défaut.

<example>
  timeout 3
  password piratemoi
</example>

<p>
Pour aller plus loin dans le durcissement de l'intégrité du mot de passe, vous 
pourriez entreposer le mot de passe sous une forme cryptée. L'utilitaire <prgn>grub-md5-crypt</prgn>
génère un hachage de mot de passe qui est compatible avec l'algorithme du mot de passe 
grub (md5). Pour spécifier à <prgn>grub</prgn> qu'un mot de passe sous le format md5 va être 
utilisé, utilisez la directive suivante&nbsp;: 

<example>
  timeout 3
  password --md5 $1$bw0ez$tljnxxKLfMzmnDVaQWgjP0
</example>

Le paramètre --md5 a été ajouté pour informer <prgn>grub</prgn> d'effectuer la 
procédure d'authentification md5. Le mot de passe fourni est la version 
md5 cryptée de piratemoi. L'utilisation de la méthode md5 pour le mot de passe 
est préférable à la méthode précédente dont le mot de passe est en clair.
Plus d'information concernant les mots de passe <prgn>grub</prgn> se trouvent 
dans le paquet <package>grub-doc</package>.

<sect id="kernel-root-prompt">Enlever le prompt root du noyau

<p>Note&nbsp;: Cela ne s'applique pas aux noyaux fournis par Debian&nbsp;3.1.

<p>Les noyaux Linux 2.4 fournissent un moyen d'accéder à un shell root lors de
l'amorçage et qui sera présenté juste après le chargement du système de fichiers
cramfs. Un message apparaîtra pour permettre à l'administrateur d'entrer un
shell exécutable avec des permissions root, ce shell peut être utilisé pour
charger manuellement des modules quand la détection automatique échoue. Ce
comportement est celui par défaut pour <file>linuxrc</file> de
l'<prgn>initrd</prgn>. Le message suivant apparaîtra&nbsp;:
<example>
  Press ENTER to obtain a shell (waits 5 seconds)
</example>

<p>Pour supprimer ce comportement, vous devez changer
<file>/etc/mkinitrd/mkinitrd.conf</file> et positionner&nbsp;:
<example>
  # DELAY  Le nombre de secondes que le script linuxrc doit attendre
  # pour permettre à l'utilisateur de l'interrompre avant que le
  # système soit lancé
  DELAY=0
</example>
<p>Puis, régénérez votre image de ramdisk. Vous pouvez faire cela ainsi, par
exemple&nbsp;:
<example>
  # cd /boot
  # mkinitrd -o initrd.img-2.4.18-k7 /lib/modules/2.4.18-k7
</example>
<p>ou (de préférence)&nbsp;:
<example>
  # dpkg-reconfigure -plow kernel-image-2.4.x-yz
</example>

<p>Notez que Debian&nbsp;3.0 <em>Woody</em> permet aux utilisateurs d'installer des
noyaux&nbsp;2.4 (en sélectionnant des <em>saveurs</em>), <em>cependant</em> le noyau
par défaut est un&nbsp;2.2 (excepté pour certaines architectures pour lesquelles le
noyau&nbsp;2.2 n'a pas été porté). Si vous pensez que cela est un bogue, veuillez
consulter le <url id="http://bugs.debian.org/145244" name="bogue n°&nbsp;145244"> avant
d'envoyer un rapport de bogue.

<sect id="floppy-boot">Interdire le démarrage sur disquette
<p>
Le MBR par défaut dans Debian avant la version 2.2 ne fonctionnait pas 
comme le master boot record habituel et laissait un moyen facile de 
pénétrer un système&nbsp;:

<list>
<item>Appuyez sur shift lors du démarrage et le prompt du MBR apparaît

<item>Ensuite appuyez sur F, et votre système démarrera à partir d'une 
disquette de démarrage. Ceci peut être utilisé pour obtenir un accès root
au système.
</list>

<p>Ce comportement peut être modifié en entrant&nbsp;:

<example>
  lilo -b /dev/hda
</example>

<p>Maintenant LILO est mis dans le MBR. Ceci peut être fait également
en ajoutant <tt>boot=/dev/hda</tt> au fichier <file>lilo.conf</file>. Il y a encore une 
autre solution qui désactivera complètement le prompt MBR&nbsp;:

<example>
  install-mbr -i n /dev/hda
</example>

<p>
D'un autre côté, cette «&nbsp;porte dérobée&nbsp;», dont de nombreuses personnes ne 
sont pas au courant, peut aussi bien vous sauver la peau si vous rencontrez 
de gros problèmes, quelque soient les raisons, avec votre installation.

<p>FIXME vérifier si cela touche réellement la 2.2 ou seulement la 2.1?
INFO: Les disques de démarrage de la 2.2 n'installe pas le mbr, mais seulement LILO.


<sect id="restrict-console-login">Restreindre les accès aux consoles 

<p>Certaines règles de sécurité peuvent forcer les administrateurs à 
se connecter au système via une console avec leur identifiant/mot de passe 
puis devenir super utilisateur (avec <prgn>su</prgn> ou <prgn>sudo</prgn>). 
Cette règle est appliquée sous Debian en éditant les fichiers
<file>/etc/login.defs</file> ou <file>/etc/securetty</file> lors de 
l'utilisation de PAM. Dans&nbsp;:

<list>

<item><file>login.defs</file>, éditez la variable CONSOLE qui définit un 
fichier ou une liste de terminaux sur lesquels la connexion de root est 
autorisée&nbsp;;

<item><file>securetty</file><footnote>
Le fichier <file>/etc/securetty</file> est un fichier de configuration
qui appartient au paquet <package>login</package>.</footnote>
en ajoutant/supprimant les terminaux depuis lesquels les accès root seront autorisés.
Si vous voulez n'autoriser que les accès locaux en console, vous avez alors
besoin de <em>console</em>, <em>ttyX</em><footnote>
Ou <em>ttyvX</em> pour GNU/FreeBSD et <em>ttyE0</em> pour GNU/KNetBSD.
</footnote>
et <em>vc/X</em> (si vous utilisez des périphériques <em>devfs</em>), vous
pouvez vouloir ajouter également <em>ttySX</em><footnote>
Ou <em>comX</em> pour GNU/Hurd, <em>cuaaX</em> pour GNU/FreeBSD et
<em>ttyXX</em> pour GNU/KNetBSD.
</footnote>
si vous utilisez une console série pour l'accès local (où X est un nombre
entier, vous pouvez vouloir avoir plusieurs instances<footnote>
La configuration par défaut dans <em>Woody</em> inclut 12&nbsp;consoles locales
tty et vc, ainsi que le périphérique <em>console</em>, mais ne permet pas les
connexions distantes. Dans <em>Sarge</em>, la configuration par défaut fournit
64&nbsp;consoles pour les consoles tty et vc. Vous pouvez les supprimer en
toute sécurité si vous n'en utilisez pas tant.
</footnote>
selon le nombre de consoles virtuelles que vous avez activées dans
<file>/etc/inittab</file><footnote>Recherchez les appels
<em>getty</em>.</footnote>). Pour plus d'informations sur les périphériques de
terminal, veuillez consulter le
<url id="http://tldp.org/HOWTO/Text-Terminal-HOWTO-6.html"
name="HOWTO Terminal Texte pour Linux"> (ou la <url
id="http://www.traduc.org/docs/HOWTO/vf/Text-Terminal-HOWTO.html" name="version
française">).

</list>

<p>
En cas d'utilisation de PAM d'autres changements au processus de login,
qui peuvent inclure des restrictions aux utilisateurs et groupes à certains
moments, peuvent être configurés dans <file>/etc/pam.d/login</file>.
Une fonctionnalité intéressante qui peut être désactivée est la possibilité
de se connecter avec des mots de passe nuls (vides). Cette fonctionnalité
peut être limitée en enlevant <em>nullok</em> de la ligne&nbsp;:

<example>
  auth       required   pam_unix.so nullok
</example>

<sect id="restrict-reboots">Restreindre les redémarrages système depuis la console

<p>Si votre système dispose d'un clavier attaché, n'importe qui (oui, vraiment
<em>n'importe qui</em>) peut redémarrer le système avec celui-ci sans se
connecter au système. Cela peut en conformité ou non avec vos règles de
sécurité. Si vous désirez restreindre cela, vous devez vérifier le fichier
<file>/etc/inittab</file> pour que la ligne incluant <tt>ctrlaltdel</tt> appelle
<prgn>shutdown</prgn> avec le paramètre <tt>-a</tt> (rappelez-vous d'exécuter
<tt>init q</tt> après avoir fait un changement à ce fichierà. La valeur par
défaut dans Debian inclut ce paramètre&nbsp;:

<example>
  ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
</example>

<p>Puis, pour permettre à <em>certains</em> utilisateurs d'arrêter le système,
comme décrit dans la page de manuel <manref section="8" name="shutdown">, vous
devez créer le fichier <file>/etc/shutdown.allow</file> et inclure le nom des
utilisateurs qui peuvent amorcer (?) le système. Quand le <em>salut à trois
doigts</em> (ou <em>ctrl+alt+del</em>) est exécuté, le programme va vérifier
si l'un des utilisateurs de ce fichier est connecté. Si aucun d'entre eux ne
l'est, <prgn>shutdown</prgn> ne va <em>pas</em> redémarrer le système.
 
</sect>

<sect>Monter correctement les partitions
<p>
Lorsque vous montez une partition ext2, vous avez différentes options 
additionnelles pour l'appel mount ou pour le fichier <file>/etc/fstab</file>. 
Par exemple, ceci est mon entrée pour la partition /tmp&nbsp;:

<example>
/dev/hda7    /tmp    ext2    defaults,nosuid,noexec,nodev    0    2
</example>

<p>
Vous voyez la différence dans la section des options. L'option 
<tt>nosuid</tt> ignore complètement les bits setuid et setgid, tandis que
<tt>noexec</tt> interdit l'exécution de tout programme sur ce point de 
montage et <tt>nodev</tt> ignore les périphériques. Ceci semble bon mais cela 
<list>
<item>ne s'applique uniquement qu'au système de fichiers ext2,
<item>peut être contourné facilement.
</list>

<p>L'option <tt>noexec</tt> évite aux binaires d'être exécutés directement mais
cela est facilement contournable&nbsp;:

<example>
  alex@joker:/tmp# mount | grep tmp
  /dev/hda7 on /tmp type ext2 (rw,noexec,nosuid,nodev)
  alex@joker:/tmp# ./date
  bash: ./date: Permission denied
  alex@joker:/tmp# /lib/ld-linux.so.2 ./date
  Sun Dec  3 17:49:23 CET 2000
</example>

<p>
Toutefois, de nombreux script kiddies utilisent des exploits qui essayent
de créer et d'exécuter des fichiers dans <file>/tmp</file>. S'ils ne sont pas futés<!-- n'ont pas d'indice -->,
ils tomberont sur un pépin. En d'autres termes, un utilisateur ne peut être 
abusé en exécutant un binaire compromis (genre cheval de troie) dans /tmp 
lorsqu'il a accidentellement ajouté <file>/tmp</file> dans son PATH.

<p>
Soyez aussi vigilant, certains scripts peuvent dépendre du fait que 
<file>/tmp</file> devienne exécutable. Notamment Debconf qui a (avait&nbsp;?) quelques problèmes
concernant cela, pour plus d'information voir le bogue <url
id="http://bugs.debian.org/116448" name="116448">.

<p>
Ce qui suit est un exemple un plus peu poussé. Prenez note que, bien que
<file>/var</file> peut être mis à noexec, certains logiciels<footnote>Cela
inclut le gestionnaire de paquet <package>dpkg</package> car les scripts
d'installation (pre et pos) et de suppression (pre et post) sont à
<file>/var/lib/dpkg/</file> et aussi Smartlit</footnote> conservent leurs
programmes dans /var. Les mêmes conditions peuvent être appliquées à l'option
nosuid.

<example>
/dev/sda6   /usr          ext2    defaults,ro,nodev       0       2
/dev/sda12  /usr/share    ext2    defaults,ro,nodev,nosuid        0       2
/dev/sda7   /var          ext2    defaults,nodev,usrquota,grpquota0       2
/dev/sda8   /tmp          ext2    defaults,nodev,nosuid,noexec,usrquota,grpquota    0       2
/dev/sda9   /var/tmp      ext2    defaults,nodev,nosuid,noexec,usrquota,grpquota    0       2
/dev/sda10  /var/log      ext2    defaults,nodev,nosuid,noexec    0       2
/dev/sda11  /var/account  ext2    defaults,nodev,nosuid,noexec    0       2
/dev/sda13  /home         ext2    rw,nosuid,nodev,exec,auto,nouser,async,usrquota,grpquota                0       2
/dev/fd0    /mnt/fd0      ext2    defaults,users,nodev,nosuid,noexec      0       0
/dev/fd0    /mnt/floppy   vfat    defaults,users,nodev,nosuid,noexec      0       0
/dev/hda    /mnt/cdrom    iso9660 ro,users,nodev,nosuid,noexec            0       0
</example>


<sect1>Paramétrer <file>/tmp</file> en noexec
<p>
Soyez vigilant si vous mettez <file>/tmp</file> en noexec et que vous voulez installer de 
nouveaux logiciels étant donné que certains peuvent l'utiliser pendant l'installation.
<package>Apt</package> est un programme de ce genre (voir <url id="http://bugs.debian.org/116448">) si
<tt>APT::ExtractTemplates::TempDir</tt> n'est pas configuré correctement (voir <manref name="apt-extracttemplates" section="1">). 
Vous pouvez paramétrer cette variable dans le fichier <file>/etc/apt/apt.conf</file> vers 
un autre répertoire que <file>/tmp</file> et qui aura les privilèges exec.

<p>
Concernant noexec, prenez conscience qu'il peut ne pas offrir le niveau de sécurité désiré.
Observons ceci&nbsp;:
<example>
  $ cp /bin/date /tmp
  $ /tmp/date
  (n'est pas exécuté pas à cause de noexec)
  $/lib/ld-linux.so.2 /tmp/date
  (fonctionne correctement car date n'est pas exécuté directement)
</example>


<sect1>Paramétrer /usr en lecture seule
<p>
Si vous mettez <file>/usr</file> en lecture seule, vous serez dans l'incapacité
d'installer de nouveaux paquets sur votre système Debian GNU/Linux. Vous devrez, 
avant tout la remonter en lecture-écriture, puis installer les nouveaux paquets 
et enfin la remonter en lecture seule. La dernière version d'<package>apt</package> (dans Debian 
3.0 «&nbsp;Woody&nbsp;») peut être configurée pour lancer des commandes avant et après 
l'installation de paquets, ainsi vous pouvez avoir envie de le configurer correctement.


<p>
Pour réaliser ceci, modifiez le fichier <file>/etc/apt/apt.conf</file> et ajoutez&nbsp;:
<example>
  DPkg
  {
      Pre-Invoke  { "mount /usr -o remount,rw" };
      Post-Invoke { "mount /usr -o remount,ro" };
  };
</example>

<p>
Notez que le Post-invoke peut échouer avec un message d'erreur "/usr busy".
Ceci survient principalement lorsque vous utilisez des fichiers lors de la 
mise à jour et que ces fichiers sont justement mis à jour. Vous pouvez trouver
ces programmes en exécutant
<example>
# lsof +L1
</example>

<p>Arrêtez ou relancez ces programmes et exécutez la commande de Post-Invoke
manuellement. <em>Attention&nbsp;!</em> Cela veut dire que vous devrez
probablement redémarrez votre session X (si vous en faites fonctionner une) à
chaque fois que vous faites une mise à jour majeure de votre système. Vous
pouvez vouloir reconsidérer  si un <file>/usr</file> en lecture seule est
convenable pour votre système. Voir également cette <url
id="http://lists.debian.org/debian-devel/2001/11/threads.html#00212"
name="discussion sur debian-devel à propos de /usr en lecture seule">.

<sect>Fournir des accès sécurisés aux utilisateurs

<sect1 id="auth-pam">Authentification utilisateur&nbsp;: PAM

<p>PAM (Pluggable Authentication Modules) permet aux administrateurs systèmes de 
choisir comment les applications authentifient les utilisateurs. Il est à noter 
que PAM ne peut rien faire tant qu'une application n'a pas été compilée avec le 
support pour PAM. La plupart des applications livrées dans la Debian 2.2 ont 
ce support d'inclus. Par ailleurs, Debian n'avait pas le support de PAM avant 
la 2.2. La configuration actuelle par défaut pour tout service activé avec PAM
est d'émuler l'authentification UNIX (lisez
<file>/usr/share/doc/libpam0g/Debian-PAM-MiniPolicy.gz</file> pour plus
d'informations sur la façon dont les services <em>devraient</em> fonctionner dans Debian).

<p>
Chaque application avec le support PAM fournit un fichier de configuration 
dans <file>/etc/pam.d</file> qui peut être utilisé pour modifier son
comportement&nbsp:

<list>
<item>quelle fonction de base est utilisée pour l'authentification&nbsp;;
<item>quelle fonction de base est utilisée pour les sessions&nbsp;;
<item>comment les vérifications de mots de passe se comportent.
</list>

<p>
La description qui suit est loin d'être complète, pour plus d'informations vous 
pouvez regarder le 
<url id="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam.html" 
name="The Linux-PAM System Administrator's Guide"> (sur le
<url id="http://www.kernel.org/pub/linux/libs/pam/"
name="site primaire de distribution de PAM">). Ce document est également fourni
dans le paquet Debian <package>libpam-doc</package>.

<p>
PAM vous offre la possibilité de passer en revue plusieurs étapes d'authentification 
en une seule fois, à l'insu de l'utilisateur. Vous pouvez vous authentifier à une base 
de données Berkeley et à un fichier <file>passwd</file> normal, ainsi l'utilisateur pourra se 
connecter seulement si l'authentification est correcte des deux côtés.
Vous pouvez restreindre beaucoup de choses avec PAM comme vous pouvez laisser libre 
accès à votre système. Donc soyez prudent. Une ligne de configuration typique a un 
champ de contrôle comme deuxième élément.
<!-- Second in mine (old Debian v2.0 though), check this! (FIXME) (era) -->
Généralement, il devrait être paramétrer sur <tt>requisite</tt> qui retourne un échec de
connexion si un module échoue.
<!-- Lots of fields in mine are "required", please elaborate? (FIXME) (era) -->

<p>
La première chose que j'aime faire est d'ajouter le support MD5 aux applications 
PAM, étant donné que ceci protège le système contre les tentatives d'attaques par dictionnaire 
(les mots de passes peuvent être plus long en utilisant MD5). Les deux lignes suivantes
devraient être ajoutées à toutes les lignes dans <file>/etc/pam.d/</file> qui alloue l'accès à la 
machine, tel <tt>login</tt> et <tt>ssh</tt>.

<example>
  # Vérifier que libpam-cracklib soit installé avant sinon vous ne
  # pourrez pas vous connecter.
  password   required     pam_cracklib.so retry=3 minlen=12 difok=3
  password   required     pam_unix.so use_authtok nullok md5
</example>

<p>
Que fait cette formule magique&nbsp;? La première ligne charge le module PAM
cracklib qui fournit la vérification de la longueur des mots de passe, attend un
nouveau mot de passe avec au minimum 12 caractères, une différence d'au-moins 3
caractères par rapport à l'ancien et autorise 3 essais. Cracklib dépend d'une liste de mots (comme
<package>wenglish</package>, <package>wspanish</package>,
<package>wbritish</package>, etc.), assurez-vous donc d'en avoir installé une adaptée
à votre langue, sinon, cela peut ne pas vous être du tout utile.
<footnote>
Cependant, cette dépendance n'est pas fixe. Veuillez lire le <url
id="http://bugs.debian.org/112965" name="Bogue 112965">.
</footnote>
La seconde ligne
introduit le module d'authentification standard avec MD5 et autorise un mot de
passe nul. La directive <tt>use_authok</tt> est nécessaire pour passer le mot de
passe du module précédent.

<p>
Afin d'être sûr que l'utilisateur root peut se connecter uniquement à 
partir des terminaux locaux, la ligne suivante doit être activée dans 
<file>/etc/pam.d/login</file>&nbsp;:

<example>
  auth     requisite  pam_securetty.so
</example>

<p>
<p>Puis, vous devez modifier la liste des terminaux sur lesquels la connexion de
root est autorisée dans le fichier <file>/etc/securetty</file>. Vous pouvez
sinon activer le module <tt>pam_access</tt> et modifier
<file>/etc/security/access.conf</file> qui permet un contrôle plus général et
affiné, mais à qui il manque (malheureusement) des messages de journalisation
décents (la journalisation dans PAM n'est pas standard et est un problème
particulièrement peu gratifiant à traiter). Nous reviendrons au fichier
<file>access.conf</file> un peu plus tard.

<p>
Enfin, mais pas le moindre, la ligne suivante devrait être activée dans
<file>/etc/pam.d/login</file> pour mettre en place des limites de ressource
utilisateur.

<example>
  session  required   pam_limits.so
</example>

<p>
Ceci restreint les ressources du système auxquelles les utilisateurs sont
autorisées (voir ci-dessous <ref id="user-limits">).  Par exemple, vous pouvez 
restreindre le nombre de connexions (d'un groupe d'utilisateurs donné ou 
tout le système), le nombre de processus, la taille de la mémoire, 
etc.

<p>
Maintenant, éditez <file>/etc/pam.d/passwd</file> et changez la première ligne.
Vous devriez ajouter l'option «&nbsp;md5&nbsp;» pour utiliser les mots de passe MD5, modifiez 
la longueur minimale du mot de passe de 4 à 6 (ou plus) et fixez une longueur maximale si 
vous le désirez. La ligne devrait ressembler à quelque chose comme ceci&nbsp;:
<!-- J'ai change les verbes a l'infinitif par un imperatif qui me semble plus adequat, non? jpg -->

<example>
  password   required   pam_unix.so nullok obscure min=6 max=11 md5
</example>

<p>
Si vous voulez protéger su, pour que seuls quelques personnes puissent
l'utiliser pour devenir root sur votre système, vous avez besoin de 
créer un nouveau groupe «&nbsp;wheel&nbsp;» (c'est la meilleure façon, étant donné 
qu'aucun fichier n'a ces permissions d'attribuées). Ajoutez root et les 
autres utilisateurs, qui auront la possibilité d'utiliser <prgn>su</prgn> pour
devenir root, à ce groupe. Ensuite, ajoutez la ligne suivante dans 
<file>/etc/pam.d/su</file>&nbsp;:

<example>
  auth        requisite   pam_wheel.so group=wheel debug
</example>

<p>
Ceci permet d'être sûr qu'uniquement les personnes du groupe «&nbsp;wheel&nbsp;» pourront 
utiliser <prgn>su</prgn> pour devenir root. Les autres utilisateurs ne 
seront pas capable de le devenir. En fait, ils recevront un message de refus
s'ils essayent de devenir root.

<p>
Si vous désirez que seulement certains utilisateurs s'authentifient à un 
service PAM, il suffit de faire cela en utilisant les fichiers où sont stockés les utilisateurs autorisés (ou pas) à se 
connecter. Imaginons que vous ne vouliez autoriser que l'utilisateur «&nbsp;ref&nbsp;» 
à se connecter via <prgn>ssh</prgn>. Vous le mettez dans <file>/etc/sshusers-allowed</file>
et écrivez ce qui suit dans <file>/etc/pam.d/ssh</file>:

<example>
  auth        required    pam_listfile.so item=user sense=allow file=/etc/sshusers-allowed onerr=fail
</example>

<p>
La dernière étape, mais pas la moindre, est de créer le fichier <file>/etc/pam.d/other</file> et 
d'ajouter les lignes suivantes&nbsp;:

<example>
  auth     required       pam_securetty.so
  auth     required       pam_unix_auth.so
  auth     required       pam_warn.so
  auth     required       pam_deny.so
  account  required       pam_unix_acct.so
  account  required       pam_warn.so
  account  required       pam_deny.so
  password required       pam_unix_passwd.so
  password required       pam_warn.so
  password required       pam_deny.so
  session  required       pam_unix_session.so
  session  required       pam_warn.so
  session  required       pam_deny.so
</example>

<p>
Ces lignes vont fournir une bonne configuration par défaut pour toutes
les applications qui supportent PAM (accès refusé par défaut).


<sect1 id="user-limits">Restreindre l'utilisation des ressources&nbsp;: le fichier <file>limits.conf</file>

<p>
Vous devriez vraiment jeter un sérieux &oelig;il à ce fichier. Vous pouvez
définir dans celui-ci les limites des ressources par utilisateur. Dans
d'anciennes versions, ce fichier de configuration était
<file>/etc/limits.conf</file>, mais dans les nouvelles versions (avec
PAM), le fichier de configuration à utiliser devrait être
<file>/etc/security/limits.conf</file>.

<p>Si vous ne désirez pas restreindre l'utilisation des ressources,
<em>n'importe quel</em> utilisateur ayant un shell valide sur votre système (ou
même un intrus qui aurait compromis le système par un service ou un
démon devenu fou) pourra utiliser
autant de CPU, de mémoire, de pile, etc. que le système pourra fournir. Ce
problème d'<em>épuisement de ressources</em> peut être réglé par
l'utilisation de PAM.

<p>Il existe un moyen d'ajouter des limites
de ressources pour certains shells (par exemple, <prgn>bash</prgn> a
<prgn>ulimit</prgn>, voir <manref section="1" name="bash">), mais comme ils ne
fournissent pas tous les mêmes limites et comme l'utilisateur peut changer de
shell (voir <manref section="1" name="chsh">), il est préférable de placer ces
limites dans les modules PAM ainsi elles s'appliqueront quel que soit le
shell utilisé et également aux modules PAM qui ne sont pas orientés shell.

<p>Les limites de ressources sont imposées par le noyau, mais elles
doivent être configurées par le fichier <file>limits.conf</file> et la
configuration PAM des différents services doit charger le module PAM
approprié. Vous pouvez vérifier quels services imposent des limites en
exécutant&nbsp;:

<example>
$ find /etc/pam.d/ \! -name "*.dpkg*" | xargs -- grep limits |grep -v ":#"
</example>

<P>Habituellement, <file>login</file>, <file>ssh</file> et les
gestionnaires de session graphique (<file>gdm</file>, <file>kdm</file>
ou <file>xdm</file>) devraient imposer des limites aux utilisateurs,
mais vous pouvez vouloir faire cela dans d'autres fichiers de
configuration de PAM, comme <file>cron</file>, pour empêcher les démons
système d'accaparer toutes les ressources système..

<p>Les paramètres de limites spécifiques que vous pouvez vouloir imposer
dépend des ressources de votre système, c'est l'une des principales
raisons pour lesquelles aucune limite n'est imposée dans l'installation
par défaut.</p>

<p>Par exemple, l'exemple de configuration ci-desous impose une limite
de 100&nbsp;processus pour chaque utilisateur (pour empêcher les
<em>bombe de fork</em>) ainsi qu'une limite de 10&nbsp;Mo de mémoire par
processus et une limite de 10&nbsp;connexions simultanées. Les
utilisateurs du groupe <tt>adm</tt> ont des limites supérieures et
peuvent créer des fichiers core s'ils le désirent (c'est simplement une
limite <em>douce</em> (soft)).

<p>
<example>
*              soft    core            0
*              hard    core            0
*              hard    rss             1000
*              hard    memlock         1000
*              hard    nproc           100
*              -       maxlogins       1
*              hard    data            102400
*              hard    fsize           2048
@adm           hard    core            100000
@adm           hard    rss             100000
@adm           soft    nproc           2000
@adm           hard    nproc           3000
@adm           hard    fsize           100000
@adm           -       maxlogins       10
</example>

<p>Voici les limites qu'un utilisateur standard (y compris les démons
système) aurait&nbsp;:

<example>
$ ulimit -a
core file size        (blocks, -c) 0
data seg size         (kbytes, -d) 102400
file size             (blocks, -f) 2048
max locked memory     (kbytes, -l) 10000
max memory size       (kbytes, -m) 10000
open files                    (-n) 1024
pipe size          (512 bytes, -p) 8
stack size            (kbytes, -s) 8192
cpu time             (seconds, -t) unlimited
max user processes            (-u) 100
virtual memory        (kbytes, -v) unlimited
</example>

<p>Et voici les limites d'un utilisateur administratif&nbsp;:

<example>
$ ulimit -a
core file size        (blocks, -c) 0
data seg size         (kbytes, -d) 102400
file size             (blocks, -f) 100000
max locked memory     (kbytes, -l) 100000
max memory size       (kbytes, -m) 100000
open files                    (-n) 1024
pipe size          (512 bytes, -p) 8
stack size            (kbytes, -s) 8192
cpu time             (seconds, -t) unlimited
max user processes            (-u) 2000
virtual memory        (kbytes, -v) unlimited
</example>


<p>
Pour plus d'informations, lisez&nbsp;:
<list>

<item>le <url
id="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html"
name="guide de référence PAM pour les modules disponibles">,

<item>l'<url
id="http://www.samag.com/documents/s=1161/sam0009a/0009a.htm"
name="article de configuration de PAM">,

<item>l'article <url
id="http://seifried.org/security/os/linux/20020324-securing-linux-step-by-step.html"
name="Seifried's Securing Linux Step by Step"> pour la section <em>Limiting
users overview</em>,

<item>le <url id="http://seifried.org/lasg/users/" name="LASG"> pour la section 
<em>Limiting and monitoring users</em>.

</list>

<sect1>Actions de connexion de l'utilisateur&nbsp;: éditer <file>/etc/login.defs</file>

<p>
La prochaine étape est d'éditer la configuration et action de base sur
la connexion de l'utilisateur. Notez que ce fichier ne fait pas parti de la
configuration PAM, c'est un fichier de configuration qui est pris en compte par
les programmes <tt>login</tt> et <tt>su</tt>, il n'est pas logique de l'adapter
aux cas pour lesquels ni l'un, ni l'autre des programme n'est appelé au moins
indirectement (le programme <prgn>getty</prgn> qui gère les console et offre le
prompt de connexion initial appelle <em>bien</em> <prgn>login</prgn>).

<example>
  FAIL_DELAY          10
</example>

<p>
Cette variable devrait être fixée à une valeur suffisamment grande de façon 
à rendre plus difficile les tentatives de connexion en utilisant la 
manière forte. Si un mauvais mot de passe est fourni, le pirate potentiel 
(ou le simple utilisateur&nbsp;!) doit attendre 10 secondes avant d'obtenir un 
nouveau prompt de connexion, ce qui prend pas mal de temps quand vous
testez des mots de passe. Veuillez noter que ce paramètre est inopérant
si vous utilisez un programme autre que <prgn>getty</prgn>, comme par
exemple <prgn>mingetty</prgn>.

<example>
  FAILLOG_ENAB        yes
</example>

Si vous activez cette variable, les connexions échouées seront enregistrées dans
un journal. Il est important d'en garder une trace pour quelqu'un qui tente une
attaque par la manière forte.

<example>
  LOG_UNKFAIL_ENAB    yes
</example>

<p>
Si vous mettez la variable <var>FAILLOG_ENAB</var> à yes, alors il faudra mettre 
cette variable également à yes. Ceci sauvegardera les noms d'utilisateurs 
inconnus si la connexion échoue. Si vous faites cela, assurez-vous que les 
journaux de connexion ont les bonnes permissions (640 par exemple avec un groupe adéquat 
comme adm), car souvent les utilisateurs entrent accidentellement leur mot de 
passe au lieu du nom d'utilisateur et vous ne voulez pas permettre aux 
autres utilisateurs de le voir.

<example>
  SYSLOG_SU_ENAB      yes
</example>

<p>Ceci va activer l'écriture dans les journaux de <file>syslog</file> des tentatives de 
<prgn>su</prgn>. Plutôt important sur des machines sérieuses, mais notez que 
ceci peut aussi bien être à la base de problèmes de respect de la vie privée.

<example>
  SYSLOG_SG_ENAB      yes
</example>

<p>
La même chose que SYSLOG_SU_ENAB, mais s'applique au programme <prgn>sg</prgn>.

<example>
  MD5_CRYPT_ENAB      yes
</example>

<p>
Comme mentionné ci-dessus, les mots de passe MD5 réduit considérablement le
problème des attaques par dictionnaire étant donné que vous pouvez utiliser des
mots de passe plus longs. Si vous utilisez slink, lisez les documentations avant
d'activer le MD5. Sinon, cela est paramétré dans PAM.

<example>
  PASS_MAX_LEN        50
</example>

<p>
Si les mots de passe MD5 sont activés dans votre configuration PAM, 
alors cette variable devrait avoir la même valeur que dans celle-ci.

<sect1>Restreindre le ftp&nbsp;: éditer <file>/etc/ftpusers</file>

<p>
Ce fichier contient une liste d'utilisateurs qui ne sont pas autorisés 
à se connecter à l'hôte en utilisant ftp. Utilisez uniquement ce fichier 
si vous voulez réellement autoriser le ftp (qui n'est, en général, pas 
recommandé car il utilise des mots de passe en clair). Si votre démon 
supporte PAM, celui-ci peut être utilisé pour permettre ou refuser 
certains services aux utilisateurs.

<p>FIXME (BUG): Est-ce un bogue que le fichier par défaut <file>ftpusers</file>
dans Debian ne contient <em>pas</em> tous les utilisateurs d'administration
(dans <package>base-passwd</package>).

<sect1>Utilisation de su

<p>
Si vous avez réellement besoin que des utilisateurs deviennent super 
utilisateur sur votre système, par exemple pour installer des paquets 
ou ajouter des utilisateurs, vous pouvez utiliser la commande
<prgn>su</prgn> pour changer d'identité. Vous devriez essayer d'éviter 
toute connexion en tant que root et d'utiliser à la place <prgn>su</prgn>. 
En réalité, la meilleure solution est de supprimer <prgn>su</prgn> et de changer pour 
le mécanisme <prgn>sudo</prgn> qui a une logique plus large et plus de fonctionnalités que
<prgn>su</prgn>. Cependant, <prgn>su</prgn> est plus commun étant donné qu'il est
utilisé sur beaucoup d'autres Unices.

<sect1>Utilisation de sudo

<p>
<prgn>sudo</prgn> autorise l'utilisateur à exécuter des commandes définies 
sous l'identité d'un autre utilisateur, même en tant que root. Si 
l'utilisateur est ajouté à
<file>/etc/sudoers</file> et est authentifié correctement, il est capable 
de lancer des commandes qui ont été définies dans 
<file>/etc/sudoers</file>. Les infractions, telles que les mots de passe 
incorrects ou les tentatives de lancement d'un programme pour lequel vous n'avez 
pas les permissions, sont logguées et envoyées au root.

<sect1>Désactiver des accès d'administration à distance
<p>Vous devriez également modifier <file>/etc/security/access.conf</file> pour
désactiver la connexion d'administration à distance. Ainsi, les
utilisateurs doivent exécuter <prgn>su</prgn> (ou <prgn>sudo</prgn>) pour
utiliser des pouvoirs administratifs et ainsi la trace d'audit appropriée sera
toujours générée.

<p>Vous devez ajouter la ligne suivante à <file>/etc/security/access.conf</file>,
le fichier de configuration par défaut Debian contient une ligne exemple commentée&nbsp;:
<example>
   -:wheel:ALL EXCEPT LOCAL
</example>

<p>Rappelez-vous d'activer le module <tt>pam_access</tt> pour chaque service (ou
configuration par défaut) dans <file>/etc/pam.d/</file> si vous voulez que vos
modifications dans <file>/etc/security/access.conf</file> soient pris en compte.

<sect1 id="user-restrict">Restriction des utilisateurs

<p>
Parfois, vous pensez avoir besoin d'utilisateurs créés dans votre système 
local de façon à fournir un service donné (service courrier pop3 ou
ftp). Avant tout, rappelez-vous que l'implémentation PAM dans Debian GNU/Linux 
vous autorise à valider les utilisateurs avec une grande variété de 
répertoires de services externes (radius, ldap, etc.) fournis par les paquets 
libpam.

<p>
Si des utilisateurs doivent être créés et que le système est 
accessible à distance, prenez en compte que des utilisateurs pourront se 
connecter au système. Ceci peut être corrigé en donnant aux utilisateurs 
un shell null (<file>/dev/null</file>) (il devra être listé dans 
<file>/etc/shells</file>). Si vous voulez autoriser les utilisateurs à accéder 
au système mais limiter leurs mouvements, vous pouvez utiliser le fichier 
<file>/bin/rbash</file>, ce qui est équivalent à l'ajout de l'option <tt>-r</tt>
dans bash (<em>RESTRICTED SHELL</em> voir <manref name="bash"
section="1">). Veuillez noter que même avec un shell restreint, un utilisateur 
ayant accès à un programme interactif (qui peut permettre l'exécution d'un 
sous-shell) peut être capable de passer outre les limites du shell.

<p>
Debian fournit actuellement dans la version unstable le module
<file>pam_chroot</file> (dans le paquet <package> libpam-chroot</package>) (et
il pourrait être inclus dans les prochaines versions stables). Une alternative à
celui-ci est de <prgn>chroot</prgn>er le service qui fournit la connexion à
distance (<prgn>ssh</prgn>, <prgn>telnet</prgn>).
<footnote><package>Libpam-chroot</package> n'a pas encore été testé en
profondeur, il fonctionne pour <prgn>login</prgn>, mais il est possible qu'il ne
soit pas facile de mettre en place l'environnement pour d'autres
programmes</footnote>

<p>
Si vous voulez restreindre <em>quand</em> les utilisateurs peuvent accéder au 
système, vous devrez personnaliser <file>/etc/security/access.conf</file> en 
fonction de vos besoins.

<p>Des informations sur comment <prgn>chroot</prgn>er des utilisateurs accédant
au système par le service <prgn>ssh</prgn> sont décrites dans <ref
id="chroot-ssh-env">.


<sect1>Audit d'utilisateur 

<p>
Si vous êtes vraiment paranoïaque, il se peut que vous vouliez configurer 
pour le système un fichier de configuration qui configure l'environnement 
pour auditer ce que les utilisateurs font sur votre système. Cette section
présente quelques conseils avec différents utilitaires que vous pouvez utiliser.

<sect2>Audit d'entrée et sortie avec script

<p>Vous pouvez utiliser la commande <prgn>script</prgn> pour auditer à la fois
ce que les utilisateurs exécutent et quels sont les résultats de leurs
commandes. Vous ne pouvez configurer <prgn>script</prgn> comme un shell (même si
vous l'ajoutez à <file>/etc/shells</file>). Mais vous pouvez faire en sorte que
le fichier d'initialisation su shell exécute les commandes suivantes&nbsp;:

<example>
umask 077
exec script -q -a "/var/log/sessions/$USER"
</example>

<p>Bien sûr, si vous faites cela pour tout le système, cela veut dire que le
shell ne continuerait pas à lire les fichiers d'initialisation personnels (car
le shell sera écrasé par <prgn>script</prgn>). Une alternative est de faire cela
dans les fichiers d'initialisation de l'utilisateur (mais alorsl'utilisateur
pourrait l'enlever, voir les commentaires sur cela ci-dessous).
</p>

<p>Vous devez également configurer les fichiers dans le répertoire d'audit (dans
l'exemple <file>/var/log/sessions/</file>) pour que les utilisateurs puissent y
écrire, mais pas supprimer le fichier. Cela pourrait être fait, par exemple, en
créant les fichiers de session d'utilisateur en avance et en leur positionnant
le drapeau <em>ajout-seulement</em> («&nbsp;append-only&nbsp;») en utilisant
<prgn>chattr</prgn>.
</p>

<p>Une alternative utile pour les administrateurs système, qui inclut des
informations de date, serait&nbsp;:

<example>
umask 077
exec script -q -a "/var/log/sessions/$USER-`date +%Y%m%d`"
</example>

<sect2>Utiliser le fichier d'historique du shell

<p>Si vous voulez passer en revue ce que les utilisateurs entrent dans le shell
(mais pas voir le résultat), vous pouvez configurer un <file>/etc/profile</file>
pour tout le système qui configure l'environnement pour que toutes les commandes
soient sauvées dans le fichier d'historique. La configuration pour tout le
système doit être réalisée de telle façon que les utilisateurs ne puissent pas
enlever les capacités d'audit de leur shell. Cela est plutôt spécifique au
shell, donc assurez-vous que tous les utilisateurs utilisent un shell qui le
gère.</p>

<p>Par exemple, pour bash, le fichier <file>/etc/profile</file> pourrait être
paramétré ainsi
<footnote>
Configurer HISTSIZE à une très grande valeur peut poser des problèmes sous
certains shells car l'historique est gardé en mémoire pour la session de chaque
utilisateur. Il peut être plus prudent de positionner cela à une valeur assez
élevée et de sauvergarder les fichiers d'historiques des utilisateurs (si vous
avez besoin de tout l'historique de l'utilisateur pour une raison ou une autre)
</footnote>&nbsp;:

<example>
  HISTFILE=~/.bash_history
  HISTSIZE=10000
  HISTFILESIZE=999999
  # Empêche les utilisateurs d'entrer des commandes qui seraient
  # ignorées dans le fichier d'historique
  HISTIGNORE=""
  HISTCONTROL=""
  readonly HISTFILE
  readonly HISTSIZE
  readonly HISTFILESIZE
  readonly HISTIGNORE
  readonly HISTCONTROL
  export HISTFILE HISTSIZE HISTFILESIZE HISTIGNORE HISTCONTROL
</example>

<p>
Afin que cela fonctionne, l'utilisateur doit être seulement capable d'ajouter 
des informations au fichier <file>.bash_history</file>. Vous devez <em>aussi</em>
positionner l'attribut <em>ajout-uniquement</em> en utilisant le programme
<prgn>chattr</prgn> sur <file>.bash_history</file> pour tous les utilisateurs.
<footnote>
Sans l'attribut ajout-uniquement les utilisateurs seraient capables de
vider le contenu du fichier des historiques avec
<tt> > .bash_history</tt>.
</footnote>

<p>
Notez que vous pouvez introduire la configuration ci-dessus dans le fichier
utilisateur <file>.profile</file>. Mais alors vous devriez configurer les permissions
correctement de façon à empêcher à l'utilisateur de modifier ce fichier. Cela
inclut&nbsp;: les répertoires personnels de l'utilisateur ne doivent
<em>pas</em> appartenir à l'utilisateur (sinon, il pourrait supprimer le
fichier), mais en même temps lui permettre de lire le fichier de configuration
<file>.profile</file>  et d'écrire dans <file>.bash_history</file>. Il serait
bien de configurer l'attribut <em>immuable</em> (également en utilisant 
<prgn>chattr</prgn>) pour le <file>.profile</file> aussi si vous procédez
ainsi.

<sect2>Audit utilisateur complet avec utilitaires de comptabilité

<p>
L'exemple précédent est une manière simple de configurer l'audit utilisateur,
mais qui peut ne pas être utile pour des systèmes complexes ou pour ceux dans
lesquels les utilisateurs ne peuvent pas exécuter de shell du tout (ou
exclusivement). Si c'est votre cas, vous devrez examiner
<package>acct</package>, les utilitaires de comptabilité. Ces utilitaires
archiveront toutes les commandes exécutées par les utilisateurs ou processus du
système au détriment de l'espace disque.

<p>
Lors de l'activation de la comptabilité, toutes les informations sur les processus et 
utilisateurs sont conservées dans <file>/var/account/</file>, plus spécifiquement dans
le fichier <file>pacct</file>. Le paquet de comptabilité 
inclut certains outils (<prgn>sa</prgn> et <prgn>ac</prgn>) afin d'analyser ces 
données.

<sect2>Autres méthodes d'audit utilisateur
<p>
Si vous êtes complètement paranoïaque et que vous voulez auditer toutes 
les commandes des utilisateurs, vous pouvez prendre les codes sources du 
<prgn>bash</prgn>, les éditer et récupérer dans un fichier toutes les commandes que 
l'utilisateur tape. Ou avoir <package>ttysnoop</package> constamment en 
attente de nouveaux ttys
<footnote>Les ttys sont créées pour les connexions locales et à distance par
ssh et telnet</footnote> et reverser toutes les sorties dans un fichier.
Un autre programme utile est <package>snoopy</package>
(voir également  <url id="http://sourceforge.net/projects/snoopylogger/"
name="la page du projet">)
qui est un programme transparent pour l'utilisateur qui se positionne
comme une librairie fournissant une encapsulation des appels <var>execve()</var>,
toute commande exécutée est loguée par <prgn>syslogd</prgn> en utilisant la facilité <tt>authpriv</tt>
(généralement stocké dans <file>/var/log/auth.log</file>).

<sect1>Inspection des profils utilisateurs

<p>
Si vous désirez <em>voir</em> ce que font vraiment les utilisateurs, 
comme l'heure à laquelle ils se connectent, vous pouvez utiliser la base 
de données <file>wtmp</file> qui contient toutes les informations 
concernant les connexions. Ce fichier peut être employé avec plusieurs 
utilitaires, parmi eux <prgn>sac</prgn> qui peut sortir un profil de chaque 
utilisateur montrant dans quel créneau horaire ils se connectent au système 
habituellement.

<p>
Dans le cas où vous avez la comptabilité activée, vous pouvez également utiliser 
les outils qu'elle fournit pour déterminer quand les utilisateurs accèdent au 
système et ce qu'ils exécutent.

<sect1>Positionner des umasks aux utilisateurs

<p>Selon vos règles d'utilisation, vous pouvez vouloir changer comment les
utilisateurs peuvent partager des informations, c'est-à-dire, quelles sont les
permissions par défaut des fichiers nouvellements créés par les utilisateurs. Ce
changement est effectué en définissant un paramètre <tt>umask</tt> correct pour
tous les utilisateurs. Vous pouvez changer le paramètre <var>UMASK</var> dans
<file>/etc/limits.conf</file>, <file>/etc/profile</file>,
<file>/etc/csh.cshrc</file>, <file>/etc/csh.login</file>,
<file>/etc/zshrc</file> et probablement dans d'autres fichiers (selon les shells
que vous avez installé sur votre système). Parmi ceux-ci, le dernier à être
chargé prendra précédence sur les autres. L'ordre est&nbsp;: le
<file>limits.conf</file> de PAM, la configuration système par défaut du shell de
l'utilisateur, le shell de l'utilisateur (son <file>~/.profile</file>,
<file>~/.bash_profile</file>, etc.).

<p>Le paramètre <tt>umask</tt> par défaut de Debian est <em>022</em>, ceci veut
dire que les fichiers (et les répertoires) peuvent être lus et accédés par le
groupe de l'utilisateur et par tout autre utilisateur du système. Si cela est
trop permissif pour votre système, vous devrez changer ce paramètre umask pour
tous les shells (et pour PAM). N'oubliez pas de modifier les fichiers sous
<file>/etc/skel/</file> car ce seront les valeurs par défaut d'un nouvel
utilisateur quand il sera créé par la commande <prgn>adduser</prgn>.

<p>Notez, cependant, que les utilisateurs peuvent modifier leur propre paramètre
<tt>umask</tt> s'ils le désirent, le rendant plus permissif ou plus restrictif.

<sect1>Limiter ce que les utilisateurs peuvent voir et accéder

<P>FIXME&nbsp;: Besoin de contenu. Indiquer les conséquences de changement des
permissions des paquets lors d'une mise à jour (et un administrateur aussi
paranoïaque que cela devrait <prgn>chroot</prgn>er ses utilisateurs).

<p>Si vous avez besoin d'accorder aux utilisateurs un accès au système avec un
shell, réfléchissez-y très soigneusement. Un utilisateur peut, par défaut à
moins d'être dans un environnement extrèmement restreint (comme une prison
<tt>chroot</tt>), récupérer un assez grand nombre d'informations concernant
votre système, y compris&nbsp;:

<list>

<item>certains fichiers de configuration dans <file>/etc</file>. Cependant, les
permissions par défaut de Debian pour certains fichiers sensible (qui peuvent,
par exemple, contenir des mots de passe) empêcheront l'accès à des informations
critiques. Pour voir quels fichiers ne sont accessibles que par l'utilisateur
root par exemple <tt>find /etc -type f -a -perm 600 -a -uid 0</tt> en tant que
super-utilisateur.

<item>vos paquets installés, soit en consultant la base de données des paquets,
soit dans le répertoire <file>/usr/share/doc</file>, soit en devinant en
regardant les binaires et bibliothèques installés sur votre système.

<item>certains fichiers journaux dans <file>/var/log</file>. Notez également que
quelqies fichiers journaux ne sont accessibles que par root et le groupe
<tt>adm</tt> (essayez <tt>find /var/log -type f -a -perm 640</tt>) et certains
ne sont même disponibles que pour l'utilisateur root (essayez <tt>find /var/log
-type f -a -perm 600 -a -uid 0</tt>).

</list>

<p>
Que peut voir un utilisateur dans votre système&nbsp;? Probablement un assez
grand nombre de choses, essayez ceci (prenez une profonde respiration)&nbsp;:
<example>
  find / -type f -a -perm +006 2>/dev/null  
  find / -type d -a -perm +007 2>/dev/null  
</example>

<p>
La liste des fichiers qu'un utilisateur peut <em>voir</em> et des répertoires
auxquels il a accès est affichée.

<sect2 id="limit-user-perm">Limiter l'accès aux informations d'autres utilisateurs

<p>Si vous accordez toujours un accès shell aux utilisateurs, vous pouvez
vouloir limiter les informations qu'ils peuvent voir des autres utilisateurs.
Les utilisateurs ayant un accès shell ont tendance à créer un grand nombre de
fichiers dans leur répertoire $HOME&nbsp;: boîtes à lettres, documents
personnels, configuration des applications X/GNOME/KDE, etc.

<p>Sous Debian, chaque utilisateur est créé avec un groupe associé et aucun
utilisateur n'appartient au groupe d'un autre utilisateur. Il s'agit du
comportement par défaut&nbsp;: quand un compte d'utilisateur est créé, un groupe
du même nom est créé et l'utilisateur lui est assigné. Ceci évite le concept d'un groupe
<em>users</em> qui peut rendre plus difficile pour les utilisateurs de cacher
des informations aux autres utilisateurs.

<p>Cependant, les répertoires <var>$HOME</var> des utilisateurs sont créés avec
les permissions 0755 (lisible par le groupe et par tout le monde). Les
permissions de groupe ne sont pas un problème car seul l'utilisateur appartient
au groupe, cependant les permissions pour les autres peut être (ou non) un
problème selon vos règles locales.

<p>Vous pouvez changer ce comportement pour la création de l'utilisateur
fournisse des permissions sur <var>$HOME</var> différentes. Pour changer ce
comportement pour les <em>nouveaux</em> utilisateurs quand il seront créés,
changez <em>DIR_MODE</em> dans le fichier de configuration
<file>/etc/adduser.conf</file> à 0750 (pas d'accès en lecture pour tout le
monde).

<p>Les utilisateurs peuvent toujours partager des informations, mais directement
dans leur répertoire <var>$HOME</var> à moins qu'ils change les permissions de celui-ci.

<p>Notez que désactiver les répertoires utilisateur lisibles par tout le monde
empêchera les utilisateurs de créer leurs pages personnelles dans le répertoire
<file>~/public_html</file> car le serveur web ne pourra pas lire un composant du
chemin &mdash; leur répertoire <var>$HOME</var>. Si vous voulez permettre aux
utilisateurs de publier des pages HTML dans leur <file>~/public_html</file>,
changez <em>DIR_MODE</em> en 0751. Ceci permettra au serveur web d'accéder à ce
répertoire (qui devrait lui-même avoir le mode 0755) et de fournir le contenu
publié par les utilisateurs. Bien sûr, nous ne parlons ici que d'une
configuration par défaut&nbsp;; les utilisateurs peuvent généralement ajuster
les permissions de leurs fichiers comme ils le désirent, ou vous pouvez
conserver le contenu destiné au web dans un emplacement séparé qui n'est pas un
sous-répertoire du répertoire <var>$HOME</var> de chaque utilisateur.

<sect1 id="user-pwgen">Générer des mots de passe utilisateur

<p>Il y a plusieurs cas dans lesquels un utilisateur a besoin de créer un grand
nombre de comptes utilisateur et de fournir des mots de passe pour tous ceux-ci.
Bien sûr, l'administrateur peut facilement positionner le mot de passer pour
être le même que le nom du compte utilisateur, mais ceci n'est pas très
conseillé sur le plan de la sécurité. Une meilleure approche est d'utiliser un
programme de génération de mots de passe. Debian fournit les paquets
<package>makepasswd</package>, <package>apg</package> et
<package>pwgen</package> qui contiennent des programmes (dont le nom est le même
que celui du paquet) qui peuvent être utilisés dans ce but.
<prgn>Makepasswd</prgn> génère des mots de passe vraiment aléatoires avec un
accent sur la sécurité plus que la prononçabilité tandis que <prgn>pwgen</prgn>
essaie de créer des mots de passe sans signification, mais prononçables (bien
sûr, cela dépend de votre langue maternelle). <prgn>Apg</prgn> dispose
d'algorithmes pour les deux (il y a une version client/serveur pour ce
programme, mais elle n'est pas incluse dans le paquet Debian).

<p><prgn>Passwd</prgn> ne permet pas une assignation non interactive des mots de
passe (car il utilise un accès direct au terminal tty). Si vous désirez changer
des mots de passe lors de la création d'un grand nombre d'utilisateurs, vous
pouvez les créer en utilisant <prgn>adduser</prgn> avec l'option
<tt>--disabled-login</tt>, puis utiliser <prgn>usermod</prgn> ou <prgn>chpasswd</prgn>
<footnote>
<prgn>Chpasswd</prgn> ne sait pas gérer la génération de mots de passe MD5, il
faut donc lui donner le mot de passe sous sa forme cryptée avant de l'utiliser
avec l'option <tt>-e</tt>.
</footnote>
(tous les deux dans le paquet <package>passwd</package>, vous les avez donc déjà d'installés). Si
vous voulez utilisez un fichier avec toutes les informations pour créer les
utilisateurs comme un processus batch, il sera probablement préférable
d'utiliser <prgn>newusers</prgn>.

<sect1>Vérifier les mots de passe utilisateur

<p>Les mots de passe des utilisateurs peuvent parfois devenir le <em>maillon
faible</em> de la sécurité d'un système donné. Cela provient du fait que
quelques utilisateurs choisissent des mots de passe faibles pour leur compte (et
plus il y a d'utilisateurs, plus sont grandes les chances que cela se produise).
Même si vous mettez en place des vérifications avec le module PAM cracklib et
les limitations sur les mots de passe comme décrites dans <ref id="auth-pam">,
les utilisateurs pourront toujours utiliser des mots de passe faibles. Comme
l'accès utilisateur peut inclure un accès à un shell à distance (on espère, par
<prgn>ssh</prgn>), il est important de rendre les mots de passe aussi difficile
à deviner que possible pour les attaquants à distance, particulièrement s'ils
ont pu récupérer des informations importantes comme les noms d'utilisateur ou
même les fichiers <file>passwd</file> et <file>shadow</file> eux-mêmes.

<p>Un administrateur système doit, pour un nombre d'utilisateurs donnés,
vérifier si les mots de passe sont cohérents avec la règle locale de sécurité.
Comment vérifier&nbsp;? Essayez de les cracker comme le ferait un attaquant s'il
avait accès aux mots de passe hachés (le fichier <file>/etc/shadow</file>).

<p>Un administrateur peut utiliser <package>john</package> ou
<package>crack</package> (tous deux utilisent la force brute pour cracker)
ensemble avec une liste de mots appropriés pour vérifier les mots de
passe utilisateurs et prendre des mesures appropriées si un mot de passe faible
est détecté.
Vous pouvez rechercher des paquets Debian contenant des listes de mots en
utilisant <prgn>apt-cache search wordlist</prgn> ou vous pouvez également
visiter des sites de listes de mots sur l'Internet classique comme <url
id="ftp://ftp.ox.ac.uk/pub/wordlists"> ou <url
id="ftp://ftp.cerias.purdue.edu/pub/dict">.

<sect1 id="idle-logoff">Déconnecter les utilisateurs inactifs (idle)

<p>L'inactivité des utilisateurs pose habituellement un problème de sécurité, un
utilisateur peut être inactif parce qu'il est parti déjeuner ou parce qu'une
connexion à distance s'est bloquée et n'a pas été rétablie. Quelqu'en soit la
raison, les utilisateurs inactifs peuvent amener à une compromission&nbsp;:

<list>
<item>car la console de l'utilisateur peut être debloquée et peut être
accédée par un intrus,

<item>car un attaquant peut être capable de se ré-attacher lui-même à une
connexion réseau fermée et envoyer des commandes au shell distant (cela est
assez facile si le shell distant n'est pas encrypté comme dans le cas
<prgn>telnet</prgn>).
</list>

<p>Certains systèmes à distance ont même été compromis à travers un
<prgn>screen</prgn> inactif (et détaché) .

<p>La déconnexion automatique des utilisateurs inactifs est habituellement une
partie qui doit être imposée par les règles de sécurité locales. Il y a
plusieurs moyens de faire cela&nbsp;:

<list>
<item>Si <prgn>bash</prgn> est le shell de l'utilisateur, un administrateur
système peut positionner une valeur <tt>TMOUT</tt> par défaut (voir <manref
section="1" name="bash">) qui entraînera la déconnexion automatique des
utilisateurs distants inactifs. Notez que ceci doit être position avec l'option
<tt>-o</tt> ou les utilisateurs pourront la changer (ou la désactiver).

<item>Installer <package>timeoutd</package> et configurer
<file>/etc/timeouts</file> selon vos règles de sécurité locales. Le démon
regardera les utilisateurs inactifs et mettra un terme à leur shell en fonction.
<!-- FIXME : does 'screen' prevent timeoutd from detecting idle time like
I think it does, or it was due to my tricks with ttysnoop -->

<item>Installer <package>autolog</package> et configurer-le pour enlever les
utilisateurs inactifs.

</list>

<p>Les démons <prgn>timeoutd</prgn> et <prgn>autolog</prgn> sont les méthodes
préférées car, après tout, les utilisateurs peuvent changer leur shell par
défaut ou il peuvent après avoir exécuter leus shell par défaut, basculer sur un
autre shell (non contrôlé).

<sect id="tcpwrappers">Utilisation de tcpwrappers 

<p>
Les TCP wrappers ont été développés quand il n'y avait pas de réels filtres de 
paquets de disponible et que les contrôles d'accès étaient nécessaires.
Toutefois, ils sont toujours très intéressants et utiles. Les TCP wrappers vous
permettent d'autoriser ou de refuser un service à un hôte
ou à un domaine et de définir une règle par défaut pour les 
autorisations et les refus (toutes réalisées au niveau applicatif). Pour plus de
détails, jetez un &oelig;il à <manref name="hosts_access" section="5">.

<p>De nombreux services installés dans Debian sont soit&nbsp;:

<list>
<item>lancés via la service tcpwrapper (<file>tcpd</file>)
<item>compilés avec le support libwrapper.
</list>

<p>
D'un côté, pour des services configurés dans 
<file>/etc/inetd.conf</file>, ceci incluant <prgn>telnet</prgn>, <prgn>ftp</prgn>, <prgn>netbios</prgn>, <prgn>swat</prgn>
et <prgn>finger</prgn>), vous observerez que le fichier de configuration exécute avant 
tout <prgn>/usr/sbin/tcpd</prgn>. D'un autre côté, même si un service 
n'est pas lancé par le super démon <prgn>inetd</prgn>, il peut être compilé avec
le support pour les règles des tcp wrappers.
Les services compilés avec support tcp wrappers dans Debian incluent 
<prgn>ssh</prgn>, <prgn>portmap</prgn>, <prgn>in.talk</prgn>,
<prgn>rpc.statd</prgn>, <prgn>rpc.mountd</prgn>, <prgn>gdm</prgn>,
<prgn>oaf</prgn> (le démon d'activation GNOME), <prgn>nessus</prgn> et beaucoup d'autres.

<p>Pour voir quels paquets utilisent tcpwrappers, essayez ceci&nbsp;:

<example>
  $ apt-cache showpkg libwrap0 | egrep '^[[:space:]]' | sort -u | \
        sed 's/,libwrap0$//;s/^[[:space:]]\+//'
</example>

<p>
Tenez compte de ceci quand vous utilisez <prgn>tcpdchk</prgn> (un vérificateur
très utile de règles et syntaxe de fichier de configuration de TCP wrappers).
Quand vous pouvez ajouter des services indépendants (qui sont liés à la bibliothèque du wrapper)
dans les fichiers <file>host.deny</file> et <file>hosts.allow</file>, 
<prgn>tcpdchk</prgn> vous informera qu'il ne peut pas trouver les 
services mentionnés étant donné qu'il les cherche dans <file>/etc/inetd.conf</file>
(la page de manuel n'est pas totalement précise ici).

<p>
À présent, voici une petite astuce et probablement le plus petit système 
de détection d'intrusions disponible. Généralement, vous devriez disposer 
d'une politique correcte concernant le pare-feu en première ligne, puis 
disposer de tcp wrappers en seconde ligne de défense. Un petit truc est 
de mettre en place une commande SPAWN <footnote>assurez-vous d'utiliser des
majuscules car <em>spawn</em> ne fonctionnera pas</footnote> dans /etc/hosts.deny qui enverra un courrier
à root quand un déclencheur wrapper pour service dénié est rencontré&nbsp;: <!-- bof, à reformuler -->

<example>
  ALL: ALL: SPAWN ( \
    echo -e "\n\
    TCP Wrappers\: Connection refused\n\
    By\: $(uname -n)\n\
    Process\: %d (pid %p)\n\
    User\: %u\n\
    Host\: %c\n\
    Date\: $(date)\n\
  " | /usr/bin/mail -s "Connection to %d blocked" root) &
</example>

<p><em>Attention</em>&nbsp;: L'exemple ci-dessus peut-être facilement sujet à
une attaque par déni de service en soumettant énormément de connexions dans une
période très courte. De nombreux courriers signifient de nombreuses E/S en
envoyant uniquement quelques paquets.

<!--
# Could this example be more interesting? 
# It also relates to the next section (jfs)
#
# era: cf hosts_access(5) manual page,
# and why are you not using logger(1) here? (FIXME?)
#
#&lt;example&gt;
#ALL: ALL: SPAWN ( \
#  /usr/local/sbin/send_syslog %u %c %d )
#&lt;example&gt;

#  With send_syslog as:
##!/usr/bin/perl -w
#
#use Sys::Syslog qw(:DEFAULT setlogsock);
#
#$user=shift(@ARGV) || 'unkown';
#$host=shift(@ARGV) || 'unkown';
#$service=shift(@ARGV) || 'unkown';
#setlogsock('unix');
#openlog("alert",'', 'user');
#syslog('warning', 'Connection from %s at %s to %s blocked.', ($user, $host, $service) );
#closelog();
#
#exit 0;
-->

<sect id="log-alerts">L'importance des logs et des alertes

<p>
Il est facile de voir que le traitement de logs et alertes est un problème
sérieux sur un système sécurisé. Supposons qu'un système est parfaitement
configuré et sécurisé à 99%. Si l'attaque représentant le 1% vient à arriver et
qu'il n'y a pas de mesures de sécurité mises en place pour, dans un premier
temps, détecter ceci et dans un deuxième temps, lancer l'alerte, le système
n'est pas sécurisé du tout.

<p>Debian GNU/Linux fournit quelques outils pour effectuer des analyses de logs,
notamment <package>swatch</package><footnote>il y a un très bon article sur
celui-ci écrit par <url id="http://www.spitzner.net/swatch.html"
name="Lance Spitzner"> </footnote>, <package>logcheck</package> ou
<package>log-analysis</package> (tous ont besoin d'être personnalisés pour
enlever les choses non nécessaires des comptes-rendus). Il peut être également
utile, si le système est proche, d'avoir les logs du système d'affichés sur une
console virtuelle. Ceci est utile car vous pouvez (depuis une distance) voir si
le système se comporte correctement. Le fichier <file>/etc/syslog.conf</file> de
Debian est fourni avec une configuration commentée par défaut&nbsp;; pour
l'activer, décommenter les lignes et redémarrez <prgn>syslogd</prgn>
(<tt>/etc/init.d/syslogd restart</tt>)&nbsp;:

<example>
  daemon,mail.*;\
        news.=crit;news.=err;news.=notice;\
        *.=debug;*.=info;\
        *.=notice;*.=warn       /dev/tty8
</example>

<p>
Pour colorer les journaux, vous pouvez jeter un &oelig;il à
<package>colorize</package>, <package>ccze</package> ou
<package>glark</package>. <p>Il y a une grande partie sur l'analyse des log qui
ne peut pas être couverte ici, une bonne ressource d'information est le site web
<url name="Log Analysis" id="http://www.loganalysis.org/">.
Dans tous les cas, même des outils automatiques ne peuvent rivaliser avec le
meilleur outil d'analyse&nbsp;: votre cerveau.

<!-- FIXME: Vérifier des informations sur SHARP, le 'syslog heuristic analysis
and response program'.  Le papier est à 
id="http://www.csis.gvsu.edu/sharp/". Est-ce un logiciel libre ? Empaqueté ?

URL doesn't exist any more, but it's archive on archive.org:
http://web.archive.org/web/20020816100838/http://www.csis.gvsu.edu/sharp/
http://web.archive.org/web/20020816100838/http://www.csis.gvsu.edu/sharp/sharp.ps

No download location is available.
-->

<sect1 id="custom-logcheck">Utiliser et personnaliser <prgn>logcheck</prgn>

<p>Le paquet <prgn>logcheck</prgn> dans Debian est divisé en trois paquets
<package>logcheck</package> (le programme principal),
<package>logcheck-database</package> (une base de données d'expressions
rationnelles pour le programme) et <package>logtail</package> (affiche les
lignes de log qui n'ont pas encore été lues). Le comportement par défaut sous Debian (dans
<file>/etc/cron.d/logcheck</file>) est que <prgn>logcheck</prgn> est exécuté
toutes les heures et une fois après le démarrage.

<p>Cet outil peut être assez utile s'il est personnalisé correctement pour
alerter l'administrateur d'événements système inhabituels.
<prgn>logcheck</prgn> peut être complètement personnalisé pour envoyer des
courriers selon les événements récupérés des logs et qui sont dignes
d'attention. L'installation par défaut inclut des profils pour des événements
ignorés et des violations de règles pour trois configurations différentes
(station de travail, serveur et paranoïaque). Le paquet Debian inclut un fichier
de configuration <file>/etc/logcheck/logcheck.conf</file>, sourcé par le
programme, qui définit à quel utilisateur sont envoyés les vérifications. Il
fournit également un moyen pour les paquets qui fournissent des services pour
implémenter de nouvelles règles dans les répertoires&nbsp;:
<file>/etc/logcheck/cracking.d/_packagename_</file>,
<file>/etc/logcheck/violations.d/_packagename_</file>,
<file>/etc/logcheck/violations.ignore.d/_packagename_</file>,
<file>/etc/logcheck/ignore.d.paranoid/_packagename_</file>,
<file>/etc/logcheck/ignore.d.server/_packagename_</file> et
<file>/etc/logcheck/ignore.d.workstation/_packagename_</file>. Cependant, peu de
paquets le font actuellement. Si vous avez une règle qui peut être utile à
d'autres utilisateurs, veuillez l'envoyer comme un rapport de bogue sur le
paquet approprié (comme un bogue de gravité <em>wishlist</em>). Pour plus
d'informations, veuillez lire <file>/usr/share/doc/logcheck/README.Debian</file>.

<p>Le meilleur moyen de configurer <prgn>logcheck</prgn> est d'éditer son
fichier de configuration principal <file>/etc/logcheck/logcheck.conf</file>
après l'avoir installé. Modifiez l'utilisateur par défaut (root) à qui seront
envoyés par courrier les comptes-rendus. Vous devriez également y positionner le
niveau de compte-rendu. <package>logcheck-database</package> a trois niveaux de
compte-rendu de verbosité croissante&nbsp;: station de travail, serveur,
paranoïaque. «&nbsp;serveur&nbsp;» étant le niveau par défaut,
«&nbsp;paranoïaque&nbsp;» n'est recommandé que pour les machines de haute
sécurité ne faisant fonctionner qu'aussi peu de services que possible et
«&nbsp;station de travail&nbsp;» est pour les machines relativement protégés et
non critiques. Si vous désirez ajouter de nouveaux fichiers journaux,
ajoutez-les simplement à <file>/etc/logcheck/logcheck.logfiles</file>. Celui-ci
est configuré pour une installation de syslog par défaut.

<p>Une fois ceci fait, vous pouvez vouloir vérifier les courriers envoyés, pour
les quelques premiers jours/semaines/mois. Si vous trouvez que vous recevez des
messages que vous ne voulez pas recevoir, ajoutez simplement l'expression
rationnalle (voir <manref name="regex" section="7"> et <manref name="egrep"
section="1">) qui correspond à ces messages au fichier
<file>/etc/logcheck/ignore.d.<var>reportlevel</var>/local</file>. Essayez de
faire correspondre à la ligne de log entière. Des détails sur l'écriture des
règles sont expliquées dans
<file>/usr/share/doc/logcheck-database/README.logcheck-database.gz</file>. C'est
un processus d'affinement perpétuel&nbsp;; une fois que les messages qui sont
envoyés sont toujours pertinents, vous pouvez considérer que l'affinement est
terminé. Notez que si <prgn>logcheck</prgn> ne trouve rien de pertinent dans
votre système, il ne vous enverra pas de courrier même s'il fonctionne (donc,
vous pouvez ne recevoir de courrier qu'une fois par semaine si vous êtes
chanceux).

<sect1>Configurer l'endroit où les alertes sont envoyées 

<p>
Debian livre une configuration standard de syslog (dans <file>/etc/syslog.conf</file>)
qui archive les messages dans les fichiers appropriés dépendant de la 
facilité du système. Vous devriez être familier avec ceci&nbsp;; jetez un &oelig;il 
au fichier <file>syslog.conf</file> et à la documentation si vous ne l'êtes 
pas. Si vous avez l'intention de maintenir un système sécurisé, vous devriez 
être conscient de l'endroit où les logs sont envoyées ainsi ils <!-- log est masculin. jpg --> ne sont 
pas perdus dans la nature. <!-- ils ne sont pas ignorés (FBO) -->

<p>
Par exemple, envoyer des messages à la console est également utile pour de 
nombreux systèmes de production. Mais pour de nombreux systèmes semblables 
il est également important d'ajouter une nouvelle machine qui servira de 
serveur de log (il reçoit les logs de tous les autres 
systèmes).
<!-- traduction de loghost. Je me suis permis de traduire.jpg-->

<p>
Le courrier de root devrait être pris en considération également, de nombreux
contrôles de sécurité (tel <package>snort</package>) envoient des alertes 
dans la boîte aux lettres de root. Celle-ci pointe généralement sur le 
premier utilisateur créé sur le système (vérifiez <file>/etc/aliases</file>). Prenez 
garde à envoyer le courrier du root à un endroit où il sera lu (soit localement 
soit à distance).

<!-- ES pluriel d'alias ? => C'est pas aliases ? Non, c'est un adverbe a la base ;) On reste donc invariable, amha. Je propose donc la correction. jpg-->

<p> Il y a d'autres comptes et alias «&nbsp;rôles&nbsp;» sur votre système. Sur un petit
système, c'est probablement le plus simple de s'assurer que tous ces alias
pointent vers le compte root, et que ce mail pour root est retransmis vers
la boîte aux lettres personnelle de l'administrateur système.

<p>FIXME: Il serait intéressant de dire comment un système Debian peut
envoyer/recevoir des messages SNMP relatifs à des problèmes de sécurité (jfs).
Voir&nbsp;: <package>snmptraglogd</package>, <package>snmp</package> et 
<package>snmpd</package>.


<sect1>Utilisation d'un hôte d'archivage (loghost)
<!-- voir pour une  traduction sur la liste. Serveur de log? jpg -->

<p>
Un <!-- Serveur de log-->loghost est un hôte qui recueille les données des syslog à travers 
le réseau. Si l'une de vos machines est piratée, l'intrus n'est pas capable de 
dissimuler ses traces, à moins qu'il ne pirate également le <!-- Serveur de log-->loghost. Par 
conséquent, le <!-- Serveur de log-->loghost devrait être particulièrement sécurisé. Faire d'une 
machine un loghost est simple. Il suffit juste de démarrer le <prgn>syslogd</prgn> 
avec <tt>syslogd -r</tt> et un nouveau <!-- Serveur de log-->loghost est né. De façon à rendre cela 
permanent dans Debian, éditez <file>/etc/init.d/sysklogd</file> et 
changez la ligne

<!-- FIXME: The following could also be interesting -->
<!-- How to hide the logging server on the network i.e. by not giving -->
<!-- it an IP address and adding a static ARP entry on the hosts using -->
<!-- the remote syslog server (only if on the same hub); if the remote -->
<!-- syslog server would be on a separate network, the default gateway -->
<!-- should be configured accordingly -->

<example>
  SYSLOGD=""
</example>
par
<example>
  SYSLOGD="-r"
</example>

Ensuite, configurez les autres machines afin qu'elles envoient les données 
au <!-- Serveur de log-->loghost.  Ajoutez une entrée comme celle qui suit dans 
<file>/etc/syslog.conf</file>&nbsp;:

<example>
  facilité.niveau           @votre_loghost
</example>

Voyez la documentation pour savoir ce qu'on peut utiliser à la place de 
<em>facilité</em> et <em>niveau</em> (ils ne devraient pas être mot pour mot comme 
ceci). Si vous voulez tout archiver à distance, il suffit d'écrire&nbsp;:

<example>
  *.*                       @votre_loghost
</example>

dans votre <file>syslog.conf</file>. 
Archiver à distance ainsi que localement est la meilleure solution 
(le pirate peut estimer avoir couvert ses traces après la suppression 
des fichiers de logs locaux). Voir les pages de manuel <manref name="syslog"
section="3">, <manref name="syslogd" section="8"> et <manref
name="syslog.conf" section="5"> pour toutes informations complémentaires.

<!-- ES garder fichiers de log ou de logs ?  => apparemment ils utilisent sur
la liste journaux d'événements ...-->

<sect1>Permissions du fichier d'archivage

<p>Il est important de décider non seulement comment les alertes sont utilisées,
mais aussi qui y accède, i.e. qui peut lire ou modifier les fichiers de log
(si on n'utilise pas un hôte d'archivage). Les alertes de sécurité que l'attaquant
peut changer ou désactiver sont de peu de valeur en cas d'intrusion. Vous devez
également tenir compte que les fichiers de log peuvent révéler un grand nombre
d'informations à propos de votre système à un intrus s'il y a accès.

<!-- Il devrait être expliqué pourquoi après l'installation ce n'est pas déjà
fait, jfs -->

<p>
Certaines permissions de fichiers de log ne sont pas parfaites après
l'installation (mais, bien sûr, cela dépend vraiment de vos règles de sécurité
locales). Premièrement <file>/var/log/lastlog</file> et <file>/var/log/faillog</file> n'ont
pas besoin  d'être lisibles par les utilisateurs normaux. Dans le <file>lastlog</file>, vous
pouvez voir qui s'est connecté récemment, et dans le <file>faillog</file>, vous voyez un
résumé des connexions qui ont échouées. L'auteur recommande de un <prgn>chmod
660</prgn> sur les deux fichiers. Faites un tour rapide de vos fichiers de log et décidez avec
beaucoup d'attention quels fichiers de log vous rendez lisible/modifiable par
un utilisateur avec un UID différent de 0 et un groupe autre que
«&nbsp;adm&nbsp;» ou «&nbsp;root&nbsp;». Vous pouvez facilement vérifier ceci
sur votre système avec&nbsp;:

<example>
  #  find /var/log -type f -exec ls -l {} \; | cut -c 17-35 |sort -u
  (voir à quels utilisateurs appartiennent les fichiers de /var/log)
  #  find /var/log -type f -exec ls -l {} \; | cut -c 26-34 |sort -u
  (voir à quels groups appartiennent les fichiers de /var/log)
  # find /var/log -perm +004
  (fichiers lisibles par tout utilisateur)
  #  find /var/log \! -group root \! -group adm -exec ls -ld {} \;
  (fichiers appartenant à des groupes autres que root ou adm)
</example>

<p>Pour personnaliser comment les fichiers de log sont créés, vous devez
probablement personnaliser le programme qui les génère. Cependant, si le fichier
de log est archivé, vous pouvez personnaliser le comportement de la création et
de l'archivage.

<!-- Ceci n'est plus vrai, vérifier le logrotate d'apache

<p>
Je voudrais souligner que les permissions du fichier de log d'apache sont
vraiment défaillantes de par le fait que l'utilisateur apache est le
propriétaire de ses fichiers de log. Si un utilisateur obtient un shell par une
voie dérobée d'apache, il pourra facilement supprimer les fichiers de log.
-->

<!--
# C'est assez personnel, à mon humble avis, car c'est du au fait que
# les privilèges root sont abandonnés au démarrage. Je préfère qu'un attaquant
# efface les fichiers de log d'un service plutot tous mes fichiers de log système.
# Dans tous les cas, cela peut être amélioré en changeant les permissions 
# utilisateur après rotation
-->

<sect id="kernel-patches">Les utilitaires pour ajouter des rustines au noyau

<p>FIXME: Cette section a besoin de couvrir la manière d'installer ces
rustines spécifiques sur Debian en utilisant les paquets kernel-2.x.x-patch-XXX.
</p>

<!-- Rendre les entrées cohérentes : est-ce que les noms de paquet devraient -->
<!-- être des liens vers les pages des paquets correspondantes ? -->

<p>
Debian GNU/Linux fournit quelques rustines pour le noyau Linux qui améliorent
sa sécurité du système. En voici quelques-unes&nbsp;:


<list>

<item>LIDS &mdash; <url id="http://www.lids.org" name="Linux Intrusion
Detection"> fourni dans le paquet <package>kernel-patch-2.4-lids</package>.
Cette rustine du noyau rend le processus de renforcement d'un système 
Linux plus facile en vous permettant de restreindre, cacher et protéger des
processus, même par rapport au root. Elle implémente des fonctionnalités de
contrôle d'accès obligatoire («&nbsp;Mandatory Access Control&nbsp;»).

<!--
Il vous permet également de protéger ou
cacher certains fichiers pour que même root ne puisse les modifier. C'est un outil incontournable
pour l'administrateur paranoïaque de système. Site Internet&nbsp;: <url
name="http://www.lids.org" id="http://www.lids.org">
-->

<item><url id="http://acl.bestbits.at/" name="POSIX Access Control Lists">
(ACL) pour Linux fourni dans le paquet <package>kernel-patch-acl</package>).
Cette rustine du noyau ajoute les listes de contrôle d'accès, une méthode
avancée pour restreindre l'accès aux fichiers, par le noyau linux. Cela vous
permet de contrôler finement l'accès aux fichiers et répertoires.

<item><url id="http://trustees.sourceforge.net/" name="Linux Trustees"> fourni
dans le paquet <package>trustees</package>). Cette rustine ajoute un
système avancé décent de gestion des permissions à votre noyau Linux. Des objets
spéciaux (les trustees) sont associés à chaque fichier ou répertoire et ils sont
stockés dans la mémoire noyau, ce qui permet un accès rapide pour
toutes les permissions.

<item>NSA Enhanced Linux (du paquet <package>selinux</package>,
également disponible depuis
<url id="http://www.coker.com.au/selinux/" name="le site web du développeur">)

<item>Le <url id="http://people.redhat.com/mingo/exec-shield/"
name="correctif exec-shield"> fourni dans le paquet
<package>kernel-patch-exec-shield</package>. Ce correctif fournit une
protection contre plusieurs dépassements de tampon (attaques par
écrasement de pile).

<item>Le <url id="http://www.grsecurity.net/" name="correctif Grsecurity">
fourni par les paquets <package>kernel-patch-2.4-grsecurity</package> et
<package>kernel-patch-grsecurity2</package>
<footnote>
Notez que ce correctif entre en conflit avec des correctifs déjà inclus dans
le paquet de source du noyau Debian. Vous devrez utiliser le noyau d'origine (sans
correctifs Debian). Vous pouvez faire cela en suivant les étapes suivantes&nbsp;:
<example>
# apt-get install kernel-source-2.4.22 kernel-patch-debian-2.4.22
# tar xjf /usr/src/kernel-source-2.4.22.tar.bz2
# cd kernel-source-2.4.22
# /usr/src/kernel-patches/all/2.4.22/unpatch/debian
</example>
<p>Pour plus d'informations, consultez <url id="http://bugs.debian.org/194225"
name="#194225">, <url id="http://bugs.debian.org/199519"
name="#199519">, <url id="http://bugs.debian.org/206458"
name="#206458">, <url id="http://bugs.debian.org/203759"
name="#203759">, <url id="http://bugs.debian.org/204424"
name="#204424">, <url id="http://bugs.debian.org/210762"
name="#210762">, <url id="http://bugs.debian.org/211213"
name="#211213"> et la <url
id="http://lists.debian.org/debian-devel/2003/debian-devel-200309/msg01133.html"
name="discussion sur debian-devel">
</footnote>
implémentent le contrôle d'accès obligatoire (<em>Mandatory Access
Control</em>) grâce à RBAC, fournissent une protection de dépassement de
tampon grâce à PaX, des ACL, un caractère aléatoire du réseau (pour rendre la
reconnaissance de système d'exploitation plus difficile) et <url
id="http://www.grsecurity.net/features.php" name="beaucoup d'autres
fonctionnalités">.

<item>Le <package>kernel-patch-adamantix</package> fournit les
correctifs développés pour <url id="http://www.adamantix.org/"
name="Adamantix">, une distribution basée sur Debian. Le correctif noyau
pour les versions 2.4.x du noyau introduit des fonctionnalités de
sécurité comme une pile non exécutable grâce à l'utilisation de
<url id="http://pageexec.virtualave.net/" name="PaX"> et du contrôle
d'accès obligatoire basé sur <url id="http://www.rsbac.org/"
name="RSBAC" >. Parmi les autres fonctionnalités, on trouve&nbsp;:
<url name="le correctif PID aléatoire"
id="http://www.vanheusden.com/Linux/sp/">, le périphérique
«&nbsp;loop&nbsp;» chiffré AES, le support MPPE et un
rétroportage&nbsp;2.6 d'IPSEC.


<item><package>cryptoloop-source</package>. Ce correctif vous permet
d'utiliser les fonctions de l'API de cryptage du noyau pour créer des
systèmes de fichiers cryptés en utilisant le périphérique
«&nbsp;loopback&nbsp;».


<item>Support IPSEC du noyau (du paquet
<package>kernel-patch-freeswan</package>). Si vous voulez utiliser le protocole IPSec avec Linux, vous avez besoin 
de cette rustine. Vous pouvez ainsi créer des VPNs très facilement, même vers les machines
Windows, puisque IPSec est un standard courant. Des fonctionnalités IPsec ont
été ajoutées au noyau de développement 2.5, cette fonctionnalité sera donc
présente par défaut dans le futur noyau Linux 2.6. Site Internet&nbsp;: <url
id="http://www.freeswan.org">. Note&nbsp;: l'utilisation de FreeSwan a
été rendue obsolète en faveur d'OpenSwan.

<em>FIXME</em>&nbsp;: les derniers noyaux&nbsp;2.4 fournis dans Debian incluent
un rétro-portage du code IPSEC du noyau&nbsp;2.5. Commentaire sur cela.

<!--
<item><package>cryptoapi-core-source</package>.  Cette rustine noyau ajoute des
fonctionnalités de cryptage au noyau Linux, comme des fonctions cipher et
digest. L'utilisation habituelle de ces fonctions est pour le cryptage des
systèmes de fichiers et du swap. Notez qu'à partir de la version 2.5.45, des
fonctionnalités semblables ont été ajoutés au noyau officiel Linux, il est donc
probable que vous n'aurez plus besoin de cette rustine dans le futur noyau 2.6.
<em>Remarque</em>&nbsp;: ce paquet n'existe pas dans les versions de Debian
antérieures à <url id="http://www.debian.org/releases/sarge/" name="Sarge">.
Site Internet&nbsp;: <url name="http://www.kerneli.org" id="http://www.kerneli.org">

<item><package>cryptoloop-source</package>. Cette rustine vous permet d'utiliser
les fonctions du paquet <package>cryptoapi-core-source</package> pour créer des
systèmes de fichiers encryptés en utilisant le périphérique loopback.
-->

</list>

<p>Les correctifs de sécurité du noyau suivants ne sont disponibles que
pour d'anciennes versions du noyau dans <em>Woody</em> et ils sont obsolètes&nbsp;:

<list>
<item><url name="Openwall" id="http://www.openwall.com/linux/"> par
Solar Designer, fourni dans le paquet
<package>kernel-patch-2.2.18-openwall</package>.  C'est un ensemble
utile de restrictions pour le noyau, comme la restriction de liens,
FIFOs dans <file>/tmp</file>, une restriction de <file>/proc</file>,
une gestion de descripeur de fichiers spéciaux, une pile de
l'utilisateur non exécutable et bien plus. Note&nbsp;: ce paquet
s'applique à la version&nbsp;2.2, aucun paquet n'est disponible pour les
correctifs de la version&nbsp;2.4 fournie par Solar.

<item><package>kernel-patch-int</package>. Cette rustine vous permet également
d'ajouter des fonctionnalités de cryptographie au noyau Linux et elle était
utile pour les versions de Debian jusqu'à Potato. Elle ne fonctionne pas avec
Woody et si vous utilisez Sarge ou une version plus récente, vous devriez
utiliser un noyau plus récent qui inclut déjà ces fonctionnalités.

</list>

<p>
Cependant, certaines rustines ne sont pas encore fournies dans Debian. Si vous
croyez que certaines devraient être incluses, veuillez le demander sur la page
des <url name="paquets en souffrance et paquets prospectifs"
id="http://www.debian.org/wnpp">.  Certains d'entre eux sont&nbsp;:

<list>

<!--
<item><url id="http://pageexec.virtualave.net/" name="
rustine PaX">
-->

<item>
<url name="rustine HAP"
id="http://www.theaimsgroup.com/~hlein/hap-linux/"> (HAP veut dire
<em>Hank Approved Paranoid Linux</em>). Une collection de correctifs de
sécurité pour les noyaux&nbsp;2.2.

<!-- 
<item>
<url name="rustine Stealth"
id="http://www.energymech.net/madcamel/fm/">

<item><em>SubDomain</em>. Une extension du noyau pour fournir un confinement de
privilèges pour des programmes potentiellement peu sûrs. SubDomain complète et
étend les contrôles d'accès natifs. Bien qu'il soit sembable à un environnement
<prgn>chroot</prgn>, il prétend être plus facile à construire et plus créer
qu'un environnement <prgn>chroot</prgn>.
-->
<!-- FIXME URL is not found, and I wasn't able to find the new location 
Homepage:
<url name="http://www.immunix.org/subdomain.html"
id="http://www.immunix.org/subdomain.html">
-->

<!--
<item><em>Correctif de contextes (ctx)</em>. Une extension du noyau conçue pour
implémenter des serveurs privés virtuels. Il est semblable à <prgn>jail</prgn> dans BSD.
Site Internet&nbsp;: <url
name="http://www.immunix.org/subdomain.html"
id="http://www.immunix.org/subdomain.html">

<item><em>UserIPAcct</em>.  Ce n'est pas réellement une rustine liée à la sécurité,
mais cela vous permet de créer des quotas par utilisateur pour le trafic sur votre
serveur. Vous pouvez aussi obtenir des statistiques sur le trafic utilisateur.
Site Internet&nbsp;: <url id="http://ramses.smeyers.be/useripacct">.
-->

</list>

<sect>Se protéger contre les dépassements de tampon

<p><em>Dépassement de tampon</em> est le nom d'une attaque courante sur un
logiciel<footnote>Si commune, en fait, qu'elles ont été la base de 20&nbsp;% des
failles de sécurité rapportés cette année, comme déterminé par les
<url id="http://icat.nist.gov/icat.cfm?function=statistics"
name="statistiques de la base de données des failles de l'ICAT"></footnote>
qui utilise insuffisamment des vérifications de limites (une erreur de
programmation courante, le plus communément dans le langage C) pour exécuter du
code machine par des entrées de programme. Ces attaques, contre des logiciels serveurs qui attendent des
connexions distantes et contre des logiciels locaux qui autorisent des
privilèges élevés aux utilisateurs (<tt>setuid</tt> ou <tt>setgid</tt>) peuvent
résulter en la compromission de tout système donné.

<p>Il y a dans l'ensemble quatre méthodes pour se protéger contre les
dépassement de tampon&nbsp;:

<list>

<item>appliquer une rustine au noyau pour empêcher l'exécution de la
pile. Vous pouvez utiliser soit Exec-shield, OpenWall ou PaX (incluant
les correctifs Grsecurity et Adamantix)&nbsp;;

<!-- FIXME: ajouter un lien vers libsafe à l'endroit principal -->

<item>utiliser une bibliothèque, comme <url
id="http://www.research.avayalabs.com/project/libsafe/"
name="libsafe">, pour ré-écrire des fonctions
vulnérables et introduire une vérification correcte (pour des informations sur
l'installation de <package>libsafe</package>, veuillez lire
<url id="http://www.Linux-Sec.net/harden/libsafe.uhow2.txt" name="ceci">)&nbsp;;

<item>corriger le code source en utilisant des outils pour trouver des fragments
qui pourraient introduire cette faille&nbsp;;

<item>recompiler le code pour introduire des vérifications corrections qui
empêchent les dépassements en utilisant, par exemple, <url
id="http://www.immunix.org/stackguard.html" name="StackGuard"> (qui est utilisé par
<url id="http://www.immunix.org" name="Immunix">) ou le correctif pour GCC <url
id="http://www.research.ibm.com/trl/projects/security/ssp/" name="Stack
Smashing Protector (SSP)"> (qui est utilisé par <url
id="http://www.adamantix.org" name="Adamantix">).

</list>

<p>Debian GNU/Linux, dans sa version&nbsp;3.0, fournit des logiciels pour
implémenter toutes ces méthodes à l'exception de la protection de la compilation
du code source (mais ceci a été demandé dans le <url
id="http://bugs.debian.org/213994" name="bogue n°&nbsp;213994">).

<p>Notez que même si Debian fournissait un compilateur qui fournit cette
fonction de protection de dépassement de tampon/pile, tous les paquets auraient
besoin d'être recompilés pour introduire cette fonctionnalité. C'est, en fait,
ce que fait Adamantix (entre autres fonctionnalités). L'effet de cette nouvelle
fonctionnalité sur la stabilité des logiciels doit encore être déterminée
(certains programmes ou architectures de processeur pourraient être cassés à
cause d'elle).

<p>Dans tous les cas, soyez conscient que même ces contournement peuvent ne pas
prévenir les dépassements de tampon cas il existe des moyens de circonvenir
ceux-ci, comme décrit dans l'<url name="édition 58"
id="http://packetstorm.linuxsecurity.com/mag/phrack/phrack58.tar.gz"> du
magazine phrack ou dans l'alerte du CORE
<url id="http://online.securityfocus.com/archive/1/269246"
name="Failles multiples dans les technologies de protection d'écrasement de la pile">.

<p>Si vous voulez tester votre protection contre les dépassements de
tampon, une fois que vous avez mis une en place (quelque que soit la
méthode), vous pouvez vouloir installer le <package>paxtest</package> et
exécuter les tests qu'il fournit.

<sect1>Correctif du noyau de protection pour les dépassements de tampon

<p>Des correctifs du noyau liés aux dépassements de tampon incluant le correctif
Openwall fournissent une protection contre les dépassements de tampon dans les
noyaux Linux&nbsp;2.2. Pour les noyaux&nbsp;2.4 et plus récents, vous devrez utiliser
l'implémentation Exec-shield ou l'implémentation PaX (fourni dans le correctif 
grsecurity, <package>kernel-patch-2.4-grsecurity</package> et dans le
correctif Adamantix, <package>kernel-patch-adamantix</package>). 
Pour plus d'informations sur l'utilisation de ces correctifs, veuillez
lire la section <ref id="kernel-patches">.

<sect1>Protection <prgn>Libsafe</prgn>

<p>Protéger un système Debian GNU/Linux avec <package>libsafe</package> est
plutôt facile. Installez simplement le paquet et répondez <em>Yes</em> pour
avoir la bibliothèque préchargée globalement. Soyez attentif, cependant, car
cela peut casser des logiciels (notamment, des programmes liés avec l'ancienne
<prgn>libc5</prgn>), donc assurez-vous de lire les <url
id="http://bugs.debian.org/libsafe" name="rapports de bogue rapportés"> en
premier et testez d'abord les programmes les plus critiques dans votre logiciel
avec le programme d'enveloppement <prgn>libsafe</prgn>.

<p><em>Note importante</em>&nbsp;: la protection <prgn>Libsafe</prgn> peut ne pas être
actuellement effective comme décrit dans <url id="http://bugs.debian.org/173227"
name="173227">. Considérez de le tester de manière approfondie avant de
l'utiliser dans un environnement de production et ne dépendez pas exclusivement
dessus pour protéger votre système.

<sect1>Tester des programmes pour les dépassements

<p>L'utilisation d'outils pour détecter des dépassements de tampon nécessitent
dans tous les cas une expérience de programmation pour corriger (et recompiler)
le code. Debian fournit par exemple&nbsp;: <package>bfbtester</package> (un
testeur de dépassement de tampon qui brutalise des binaires par la force par des
dépassements de ligne de commande et d'environnement) et
<package>njamd</package>. D'autres paquets intéressants pourraient aussi être
<package>rats</package>, <package>pscan</package>, <package>flawfinder</package>
et <package>splint</package>. 


<sect>Sécurisation des transferts de fichiers

<p>
Pendant l'administration normale du système, il est habituellement nécessaire de
transférer des fichiers à partir et vers le système installé. La copie des
fichiers de façon sécurisée d'un hôte vers un autre peut être effectuée en
utilisant le paquet serveur <package>sshd</package>. Une autre possibilité est
d'utiliser <package>ftpd-ssl</package>, un serveur FTP qui utilise <em>Secure
Socket Layer</em> pour encrypter les transmissions.

<p>
Toutes ces méthodes nécessitent des clients spécifiques. Debian
fournit des clients logiciels, comme <prgn>scp</prgn> du paquet
<package>ssh</package>, qui fonctionne comme <prgn>rcp</prgn>, mais est complètement
encrypté, donc les <em>méchants</em> ne peuvent même pas savoir CE QUE vous
copiez. Il existe également un paquet client <package>ftp-ssl</package> pour
le serveur équivalent. Vous pouvez trouver des clients pour ces logiciels, même
pour d'autres systèmes d'exploitation (non-UNIX), <prgn>putty</prgn> et
<prgn>winscp</prgn> fournissent des implémentations de copie sécurisée pour
toutes les versions des systèmes d'exploitation de Microsoft.

<p>
Notez qu'utiliser <prgn>scp</prgn> fournit un accès pour tous les utilisateurs à
tout le système de fichiers à moins de faire un <prgn>chroot</prgn> comme décrit
dans <ref id="ssh-chroot">. L'accès FTP peut être <prgn>chroot</prgn>é, ceci est
probablement plus facile selon le démon que vous choisissez, comme décrit dans <ref
id="ftp-secure">. Si vous vous inquiétez d'utilisateurs locaux pouvant parcourir
vos fichiers locaux et que vous voulez avoir une communication encryptée, vous
pouvez utiliser soit un démon FTP avec support SSL ou combiner un FTP sans
cryptage avec une configuration VPN (voir <ref id="vpn">).

<!-- Je sais bien que c'est la traduction mot pour mot, "méchant", mais ne devrait on pas
préférer intrus? jpg -->


<sect>Limites et contrôle des systèmes de fichiers

<sect1>Utilisation de quotas

<p>
Avoir une bonne politique relative aux quotas est important, vu qu'elle 
empêche les utilisateurs de remplir le(s) disque(s) dur(s).

<p>
Vous pouvez utiliser deux systèmes de quotas différents&nbsp;: les quotas utilisateur 
et les quotas groupe. Comme vous l'avez probablement deviné, les quotas utilisateur 
limitent la quantité d'espace qu'un utilisateur peut avoir, les quotas groupe 
quant à eux font la même chose pour les groupes. Retenez ceci quand vous 
calculerez les tailles des quotas.

<p>
Il y a quelques points importants auxquels il faut penser dans la mise en place 
d'un système de quotas&nbsp;:

<list>
<item>Garder les quotas suffisamment petits, ainsi les utilisateurs ne dévoreront pas 
votre espace disque.

<item>Garder les quotas suffisamment grands, ainsi les utilisateurs ne 
se plaindront pas et leur quota de courrier leur permettra d'accepter des
courriers pendant une longue période.

<item>Utilisez des quotas sur tous les espaces accessibles en écriture par les 
utilisateurs, <file>/home</file> aussi bien que <file>/tmp</file>.
</list>

<p>
Tous les répertoires et partitions auxquels les utilisateurs ont accès en écriture 
complet devraient avoir les quotas d'activés. Recherchez ces partitions et 
répertoires et calculez une taille adaptée qui combine disponibilité et 
sécurité.

<p>
Bon, maintenant vous désirez utiliser les quotas. Avant tout, vous avez besoin 
de vérifier si vous avez activé le support du quota dans votre noyau. Si non,
vous devrez le recompiler. Après cela, contrôlez si le paquet <prgn>quota</prgn> est 
installé. Si non, vous en aurez également besoin.

<!-- FIXME: Comment verifier si les quotas sont activés? Qu'y a t'il
à faire pour recompiler? -->

<p>
L'activation des quotas pour des systèmes de fichiers différents est 
aussi facile que la modification du paramètre <tt>defaults</tt> en 
<tt>defaults,usrquota</tt> dans votre fichier <file>/etc/fstab</file>.
Si vous avez besoin des quotas par groupe, remplacez 
<tt>usrquota</tt> par <tt>grpquota</tt>. Vous pouvez également utiliser les 
deux. Ensuite, créez des fichiers vides quota.user et quota.group à la racine du 
système de fichiers sur lequel vous voulez utiliser les quotas (<tt>touch
/home/quota.user /home/quota.group</tt> pour un système de fichiers <file>/home</file>).

<p>
Redémarrez <prgn>quota</prgn> en faisant <tt>/etc/init.d/quota stop;/etc/init.d/quota
start</tt>. Maintenant les quotas devraient être en fonction et leurs tailles peuvent 
être configurées.

<p>
L'édition de quotas pour un utilisateur spécifique peut être 
réalisée en faisant <tt>edquota -u &lt;user&gt;</tt>. Les quotas par groupes peuvent 
être modifiés avec <tt>edquota -g &lt;group&gt;</tt>. Ensuite, paramétrez
les quotas soft et hard et/ou les quotas pour inodes selon vos besoins.

<!-- Quota permet d'etablir des quotas par utilisateur, ou par groupe d'utilisateurs.
Il faut faire attention dans cette partie de traduction qui amha est a revoir pour affiner.jpg -->

<p>
Pour plus d'informations concernant les quotas, voir la page de manuel de la 
commande quota et le quota mini-howto
(<file>/usr/share/doc/HOWTO/en-html/mini/Quota.html</file>).

<p>
Vous pouvez apprécier ou non <package>lshell</package>, puisque il 
transgresse le FHS. Aussi prenez note que <file>pam_limits.so</file> peut vous
fournir la même fonctionnalité et <package>lshell</package>
est actuellement <url id="http://bugs.debian.org/93894" name="orphelin">
<!-- Section dupliquée "Logfile permissions" supprimée (era) -->
<!-- Section dupliquée "Setting up setuid check" supprimée (era) -->

<sect1 id="ext2attr">Les attributs spécifiques du système de fichiers ext2 (chattr/lsattr) 
<!-- section éditée en dernier par Frédéric Schütz <schutz@mathgen.ch> -->

<p>
En plus des permissions standard Unix, les systèmes de fichiers ext2 et ext3
vous offrent un ensemble d'attributs spécifiques qui vous donne plus de contrôle
sur les fichiers de votre système. À la différence des persmissions de base, ces
attributs ne sont pas affichés par la commande standard <prgn>ls -l</prgn>, ni
changés par la commande <prgn>chmod</prgn> et vous avez besoin de deux autres
utilitaires, <prgn>lsattr</prgn> et <prgn>chattr</prgn> (du paquet
<package>e2fsprogs</package>) pour les gérer. Notez que ceci veut dire que ces
attributs ne sont habituellement pas sauvés quand vous sauvegardez le système,
donc si vous changez l'un d'entre eux, il peux être utile de sauver les
commandes <prgn>chattr</prgn> successives dans un script pour pouvoir les
repositionner plus tard si vous avez à récupérer une sauvegarde.

<p>
Parmi tous les attributs disponibles, les deux plus importants pour améliorer la
sécurité sont référencés par les lettres «&nbsp;i&nbsp;» et «&nbsp;a&nbsp;» et
ils ne peuvent être positionnés (ou enlevés) que le super-utilisateur&nbsp;:

<list>
<item>L'attribut «&nbsp;i&nbsp;» (inchangeable, «&nbsp;immutable&nbsp;»)&nbsp;:
un fichier ayant cet attribut ne peut-être ni modifié ni effacé 
ou encore renommé et aucun lien ne peut le référencer, même par le
super-utilisateur.

<item>L'attribut «&nbsp;a&nbsp;» (ajout, «&nbsp;append&nbsp;»)&nbsp;: cet
attribut a le même effet que l'attribut «&nbsp;immutable&nbsp;», excepté que
vous pouvez encore ouvrir le fichier en mode ajout. Ceci veut dire que vous
pouvez encore ajouter plus de contenu au fichier, mais qu'il est impossible de
modifier un contenu précédent. Cet attribut est particulièrement utile pour les
fichiers de log stockés dans <file>/var/log/</file>, bien que vous devez
considérer qu'ils sont parfois déplacés à cause des scripts d'archivage.
</list>

<p>
Ces attributs peuvent également être positionnés pour les répertoires, dans ce
cas, le droit de modifier le contenu de la liste d'un répertoire est refusé (par
exemple, renommer ou supprimer un fichier, etc.). Quand il est appliqué à un
répertoire, l'attribut d'ajout ne permet que la création de fichiers.

<p>
Il est aisé de voir que l'attribut «&nbsp;a&nbsp;» améliore la sécurité, en
donnant aux programmes qui ne fonctionnent pas en tant que super-utilisateur, la
possibilité d'ajouter des données à un fichier sans pouvoir modifier son
précédent contenu. D'un autre côté, l'attribut «&nbsp;i&nbsp;» semble moins
intéressant&nbsp;: après tout, le super-utilisateur peut déjà utiliser les
permissions standards Unix pour restreindre l'accès à un fichier et un intrus
qui aurait accès au compte super-utilisateur peut toujours utiliser le programme
<prgn>chattr</prgn> pour supprimer l'attribut. Un tel intrus peut tout d'abord
être perplexe quand il se rendra compte qu'il ne peut pas supprimer un fichier,
mais vous ne devriez pas supposer qu'il est aveugle &mdash&nbsp; après tout, il
est entré dans votre système&nbsp;! Certains manuels (y compris une précédente
version de ce document) suggèrent de supprimer simplement les programmes
<prgn>chattr</prgn> et <prgn>lsattr</prgn> du système pour améliorer la
sécurité, mais ce genre de stratégie, aussi connu comme «&nbsp;sécurité par
l'obscurité&nbsp;», doit être absolument évitée, car elle donne un sentiment
trompeur de sécurité.

<p>
Une façon sûre de résoudre ce problème est d'utiliser les fonctionnalités du
noyau Linux, comme décrit dans <ref id="proactive">. La fonctionnalité
intéressante est appelée ici <tt>CAP_LINUX_IMMUTABLE</tt>&nbsp;: si vous la
supprimez de l'ensemble des fonctionnalités <!-- (capabilities bounding set ?) -->
<!-- --> (en utilisant par exemple la commande
<tt>lcap CAP_LINUX_IMMUTABLE</tt>), il ne sera plus possible n'importe quel attribut
«&nbsp;a&nbsp;» ou «&nbsp;i&nbsp;» sur votre système, même par le
super-utilisateur&nbsp;! Une stratégie complète serait alors la suivante&nbsp;:

<enumlist>
  <item> Positionner les attributs «&nbsp;a&nbsp;» et «&nbsp;i&nbsp;» sur tous
  les fichiers que vous désirez&nbsp;;
  <item> Ajouter la commande <tt>lcap CAP_LINUX_IMMUTABLE</tt> (ainsi que
         <tt>lcap CAP_SYS_MODULE</tt>, comme suggéré dans <ref id="proactive">)
         à l'un des scripts de démarrage&nbsp;;
<!-- Quelqu'un est-il intéressé par :
http://lists.debian.org/debian-security/2001/debian-security-200107/msg00024.html -->
  <item> Positionner l'attribut «&nbsp;i&nbsp;» sur ce script et d'autres
  fichiers de démarrage ainsi que sur le binaire <prgn>lcap</prgn> lui-même&nbsp;;
  <item> Exécuter la commande ci-dessus manuellement (ou ré-amorcer le système
  pour vous assurer que tout fonctionner comme prévu).
</enumlist>

<p>
Maintenant que la fonctionnalité a été enlevée de votre système, un intrus ne
peut plus changer aucun attribut des fichiers protégés et donc, il ne peut pas
changer ou supprimer les fichiers. S'il force la machine à redémarrer (ce qui
est la seule façon de récupérer le jeu de
fonctionnalités <!-- capabilities bounding set -->), cela sera facile à détecter
et la fonctionnalité sera de toute façon enlevée à nouveau dès que le
redémarrage du système. La seule façon de changer un fichier protégé serait de
ré-amorcer le système en mode utiliseur seul (single-user mode) ou d'utiliser
une autre image d'amorçage, deux opérations qui nécessitent un accès physique à
la machine&nbsp;!

<!-- Ajouter une note sur le fait que ce n'est pas très répandu -->

<sect1 id="check-integ">Vérifier l'intégrité des systèmes de fichiers

<p>
Êtes-vous sûr que le /bin/login présent sur votre disque dur soit le même 
que celui que vous aviez installé il y a de cela quelques mois&nbsp;? Que faire 
si c'est une version piratée, qui enregistre les mots de passe entrés 
dans un fichier caché ou les envoie en clair à travers l'Internet&nbsp;?

<p>
La seule méthode pour avoir un semblant de protection est de vérifier 
vos fichiers tous les heures/jours/mois (je préfère quotidiennement) 
en comparant l'actuel et l'ancien md5sum de ce fichier. Deux fichiers 
ne peuvent avoir le même md5sum (le MD5 est basé sur 128 bits, ainsi 
la chance que deux fichiers différents aient le même md5sum est 
approximativement de un sur 3.4e3803), donc de ce côté tout est ok, à 
moins que quelqu'un ait piraté également l'algorithme qui crée les 
md5sums sur cette machine. Ceci est extrêmement difficile et très 
improbable. Vous devriez vraiment prendre en compte que la vérification 
de vos binaires est très importante étant donné que ceci est un moyen 
facile de reconnaître des changements sur vos binaires. Les outils 
couramment utilisés pour ceci sont <package>sXid</package>,
<package>AIDE</package> (Advanced Intrusion Detection Environment),
<package>TripWire</package> (non libre&nbsp;; la nouvelle version sera en GPL),
<package>integrit</package> et <package>samhain</package>.

<p>Installer <tt>debsums</tt> vous aidera à vérifier l'intégrité du 
système de fichiers en comparant le md5sum de chaque fichier avec celui 
utilisé dans l'archive des paquets Debian. Mais faites attention, ces 
fichiers peuvent facilement être modifiés.

<p>Vous pouvez vouloir utiliser <prgn>locate</prgn> pour indexer le
système de fichiers en entier&nbsp;; si vous faites cela, envisagez les
implications de cette action. Le paquet <package>locate</package> de Debian
s'exécute en tant qu'utilisateur nobody, ainsi, il indexe les fichiers qui sont
visibles à tous les utilisateurs. Cependant, si vous changez son comportement,
vous rendrez les emplacements de tous les fichiers visibles à tous les
utilisateurs. Si vous voulez indexer tout le système de fichiers (pas les
parties que l'utilisateur nobody peut voir), vous pouvez remplacer
<package>locate</package> par <package>slocate</package>. slocate est étiqueté
comme une version améliorée au niveau sécurité de GNU locate, mais il fournit en
fait une fonctionnalité de localisation de fichier supplémentaire. Quand il
utilise <prgn>slocate</prgn>, l'utilisateur ne peut voir que les fichiers auxquels il a
vraiment accès et vous pouvez exclure tout fichier ou répertoire du système. Le
paquet <package>slocate</package> exécute le processus de mise à jour avec des privilèges augmentés
par rapport à locate et il indexe tous les fichiers. Les utilisateurs peuvent
alors rechercher rapidement tout fichier qu'ils peuvent voir. <prgn>slocate</prgn> ne leur
laisse pas voir les nouveaux fichiers&nbsp;; il filtre la sortie selon votre UID

<p>FIXME: mettre des références aux instantanés pris après l'installation.
<p>FIXME: ajouter une note concernant les paquets ne fournissant pas de
debsums pour toutes les application installées (non obligatoire)
<p>FIXME: mentionner les binaires signés utilisant bsign ou elfsign

<sect1>Mise en place de la vérification setuid

<p>
Debian fournit une tâche <prgn>cron</prgn> qui s'exécute quotidiennement dans 
<file>/etc/cron.daily/standard</file>. Cette tâche <prgn>cron</prgn> exécutera le script 
<prgn>/usr/sbin/checksecurity</prgn> qui sauvegardera l'information sur les 
changements.

<!-- FIXME: Quel est le défaut pour ceci dans le paquet cron ? jfs -->

<p>Pour que cette vérification soit faite vous devez positionner
<tt>CHECKSECURITY_DISABLE="FALSE"</tt> dans <file>/etc/checksecurity.conf</file>.
Notez que c'est la configuration par défaut, donc à moins que vous ayez changé
quelque chose, cette option sera déjà positionnée à "FALSE".

<p>Le comportement par défaut est de ne pas envoyer cette information au super-utilisateur
mais à la place de garder une copie journalière des changements dans
<file>/var/log/setuid.changes</file>. Vous devrez positionner
CHECKSECURITY_EMAIL (dans <file>/etc/checksecurity.conf</file>) à «&nbsp;root&nbsp;» pour
que cette information lui soit envoyée. Voir <manref
name="checksecurity" section="8"> pour plus d'informations sur la configuration.

 
<sect id="network-secure">Sécurisations des accès réseau

<p>FIXME. Besoin de plus de contenu (spécifique Debian)

<sect1 id="kernel-conf">Configuration des options réseaux du noyau

<p>FIXME&nbsp;: Pas de contenu

<p>
Beaucoup de fonctionnalités du noyau peuvent être modifiées en cours
de fonctionnement en envoyant quelque chose (via la commande <prgn>echo</prgn>) dans
le système de fichiers <file>/proc</file> ou en utilisant <prgn>sysctl</prgn>. En entrant
<tt>sysctl -A</tt>, vous pouvez voir ce que vous pouvez configurer et quelles
sont les options, elles peuvent être modifiées en exécutant <tt>/sbin/sysctl -w variable=valeur</tt> (voir <manref
section="8" name="sysctl">). Vous aurez seulement en de rares occasions à éditer 
quelque chose ici, mais vous pouvez augmenter la sécurité de cette manière
aussi. Par exemple&nbsp;:
 
<!-- FIXME: /proc/sys/ ne devrait-il pas préfixer tout ça ? era -->

<example>
net/ipv4/icmp_echo_ignore_broadcasts = 1
</example>

C'est un «&nbsp;émulateur Windows&nbsp;» parce que ça agit comme Windows sur 
les ping de broadcast si celui-ci est positionné à 1. C'est-à-dire que les
requêtes ICMP_ECHO envoyées à l'adresse broadcast seront ignorées.
<!-- Ce qui veut dire quoi exactement? Simplement que ça ignore les broadcasts? FIXME -->
Sinon, cela ne fait rien.

<p>Si vous voulez empêcher votre système de répondre aux requêtes d'echo ICMP, activez cette
option de configuration&nbsp;:

<example>
net/ipv4/icmp_echo_ignore_all = 1
</example>

<p>Pour enregistrer les paquets avec des adresses impossibles (à cause de routes
erronées) sur votre réseau, utilisez&nbsp;:

<example>
/proc/sys/net/ipv4/conf/all/log_martians = 1
</example>

<p>Pour plus d'informations sur ce qui peut être fait avec
<file>/proc/sys/net/ipv4/*</file>, lisez
<file>/usr/src/linux/Documentation/filesystems/proc.txt</file>. Toutes les
options sont décrites de façon complète sous
<file>/usr/src/linux/Documentation/networking/ip-sysctl.txt</file>
<footnote>Dans Debian, le paquet <package>kernel-image</package> installe les
sources sous <file>/usr/src/kernel-source-2.X.X</file>, remplacez simplement
<em>linux</em> par l'endroit où est installé votre noyau</footnote>.

<sect1 id="tcp-syncookies">Configurer syncookies

<p>Cette option est à double tranchant. D'un côté, elle protège votre système
contre le syn packet flooding&nbsp;; d'un autre côté, elle viole les standards définis (RFCs).

<!-- What does this mean? (jfs)
This option is quite dumb as it floods the
other side like it floods you, so the other side is also busy. 
Cette option est assez stupide car elle floode l'autre partie de la même manière
qu'elle vous flood, ainsi l'autre partie est aussi occupée. Si vous voulez changer
cette option vous pouvez aussi la changer dans
<tt>/etc/network/options</tt> en positionnant <tt>syncookies=yes</tt>.
-->

<!-- <p>Si vous ne voulez pas bloquer ICMP avec votre pare-feux, activez ceci. -->

<!--
Est ce que ça veut dire, si vous voulez bloquer ICMP mais pas vec votre parefeux? FIXME
-->

<example>
net/ipv4/tcp_syncookies = 1
</example>

<p>Si vous voulez changer cette option à chaque fois que le noyau fonctionne,
vous devez le faire dans <tt>/etc/network/options</tt> en positionnant
<tt>syncookies=yes</tt>. Ceci prendra effet à chaque fois que
<tt>/etc/init.d/networking</tt> est exécuté (ce qui est habituellement fait lors du démarrage)
tandis que la commande suivante aura un effet unique jusqu'au prochain redémarrage&nbsp;:

<example>
echo 1 > /proc/sys/net/ipv4/tcp_syncookies 
</example>

<p>Cette option n'est dispobile que si vous avez compilé le noyau avec
<tt>CONFIG_SYNCOOKIES</tt>. Tous les noyaux Debian sont compilés avec cette
option incluse, mais vous pouvez le vérifier en exécutant&nbsp;:

<example>
$ sysctl -A |grep syncookies
net/ipv4/tcp_syncookies = 1
</example>

<p>Pour plus d'informations sur les syncookies TCP, lisez
<url id="http://cr.yp.to/syncookies.html">.

<sect1 id="net-harden">Sécurisation du réseau pendant l'amorçage

<p>
Quand vous positionnez des options de configuration de réseau du noyau, vous
devez le configurer pour que ce soit chargé à chaque fois que le système est
redémarré. L'exemple suivant active un grand nombre des options précédentes
ainsi que d'autres options utiles.

<p><em>FIXME</em> Au lieu de fournir le script, fournir un exemple de
configuration pour <file>sysctl.conf</file> (voir&nbsp;: <manref section="5"
name="sysctl.conf">). L'envoyer également en tant que bogue souhaité sur
le paquet procps.

<p>
Créez le script dans <file>/etc/network/interface-secure</file> (le nom est
donné comme exemple) et appelez le à partir de
<file>/etc/network/interfaces</file> comme ceci&nbsp;:

<example>
auto eth0
iface eth0 inet static
        address xxx.xxx.xxx.xxx
        netmask 255.255.255.xxx
        broadcast xxx.xxx.xxx.xxx
        gateway xxx.xxx.xxx.xxx
        pre-up /etc/network/interface-secure
</example>

<example>
# Nom du script : /etc/network/interface-secure
# Modifie plusieurs comportements par défaut pour sécuriser contre
# certaines attaques et IP spoofing
#
# Fourni par Dariusz Puchalak  
#

# active la protection broadcast echo
echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
                                           
# désactive l'ip forwarding
echo 0 > /proc/sys/net/ipv4/ip_forward

# active la protection TCP syn cookie
echo 1 > /proc/sys/net/ipv4/tcp_syncookies


# Logue les paquets avec des adresses impossibles
# (cela inclut les paquets usurpés (spoofed), les paquets routés
# source, les paquets redirigés), mais faites attention à ceci
# sur les serveurs web très chargés
echo 1 >/proc/sys/net/ipv4/conf/all/log_martians 

# active la protection permanente sur la défragmentation
echo 1 > /proc/sys/net/ipv4/ip_always_defrag

# active la protection sur les mauvais messages d'erreur
echo 1 > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses


# maintenant la protection ip spoofing
echo 1 > /proc/sys/net/ipv4/conf/all/rp_filter

# et enfin, encore d'autres choses
# Désactive l'acceptation Redirect ICMP
echo 0 > /proc/sys/net/ipv4/conf/all/accept_redirects
echo 0 > /proc/sys/net/ipv4/conf/all/send_redirects

# Désactive Source Routed
echo 0 > /proc/sys/net/ipv4/conf/all/accept_source_route


echo 1 > /proc/sys/net/ipv4/conf/all/log_martians
</example>

<p>
Vous pouvez également créer un script <tt>init.d</tt> et le faire exécuter au
démarrage (en utilisant <prgn>update-rc.d</prgn> pour créer les liens
<tt>rc.d</tt> appropriés).

<!-- Fin de traduction je fais la partie suivante :) -->

<sect1 id="kernel-fw">Configuration des fonctionnalités de pare-feu
<!--- Configuration des composants du firewall. Je laisse en non traduit. jpg -->
<p>
De façon à avoir des privilèges de pare-feux, soit pour protéger le 
système local ou d'autres <em>derrière</em> lui, le noyau doit 
être compilé avec les options correspondant aux pare-feu. Le 
noyau standard 2.2 de la Debian (également 2.2) fournit <prgn>ipchains</prgn>
qui est un pare-feu pour filtrer les paquets, le noyau standard de 
la Debian 3.0 (noyau 2.4) fournit lui le pare-feu <prgn>iptables</prgn>
(netfilter). Les anciennes distributions Debian auront besoin de rustines
appropriées pour le noyau (Debian 2.1 utilise le noyau 2.0.34).

<p>
Dans tous les cas, il est relativement facile d'utiliser un noyau 
différent de celui fourni par Debian. Vous pouvez trouver des noyaux 
pré-compilés sous forme de paquets que vous pouvez facilement installer 
sur le système Debian. Vous pouvez également télécharger les sources du 
noyau en utilisant <package>kernel-source-X</package> et construire des 
paquets de noyau personnalisé en utilisant <package>make-kpkg</package>.

<p>
La mise en place de pare-feu dans Debian est abordée plus en détail dans 
<ref id="firewall-setup">.

<sect1 id="limit-bindaddr">Désactiver les problèmes d'hôtes weak-end <!-- Pas d'idée ... -->

<!-- FIXME I read this and I dont get what's the point ? -->

<p>
Les systèmes avec plus d'une interface sur différents réseaux peuvent avoir
des services configurés pour qu'ils ne puissent s'associer qu'à une adresse IP
donnée. Ceci prévient habituellement les accès aux services quand ils sont interrogés par
une adresse donnée. Cependant, cela ne veut pas dire (bien qu'il s'agisse d'une
erreur de conception commune que j'ai moi aussi faite) que le service est lié à
une adresse <em>matérielle</em> donnée (carte interface).
<footnote>
Pour reproduire ceci (exemple fourni par Felix von Leitner sur la liste de
diffusion bugtraq)&nbsp;:
<example>
   hôte a (eth0 connecté sur l'eth0 de l'hôte b):
     ifconfig eth0 10.0.0.1
     ifconfig eth1 23.0.0.1
     tcpserver -RHl localhost 23.0.0.1 8000 echo fnord

   hôte b:
     ifconfig eth0 10.0.0.2
     route add 23.0.0.1 gw 10.0.0.1
     telnet 23.0.0.1 8000
</example>
<p>
Cela semble, cependant, ne pas fonctionner avec les services liés à 127.0.0.1,
vous pourriez devoir écrire des tests utilisant des sockets raw.</p> <!-- bruts ? -->
</footnote>

<p>
Ceci n'est pas un problème ARP et ce n'est pas une violation de RFC (c'est ce
que l'on appelle le <em>weak end host</em> dans la <url
id="ftp://ftp.isi.edu/in-notes/rfc1122.txt" name="RFC1122">, section 3.3.4.2).
Rappelez-vous que les adresses IP n'ont rien à voir avec les interfaces
physiques.

<p>Sur les noyaux 2.2 (et antérieurs), ceci peut être corrigé avec&nbsp;:
<example>
# echo 1 > /proc/sys/net/ipv4/conf/all/hidden
# echo 1 > /proc/sys/net/ipv4/conf/eth0/hidden
# echo 1 > /proc/sys/net/ipv4/conf/eth1/hidden
.....
</example>
<p>Sur des noyaux postérieurs, ceci peut être corrigé avec&nbsp;:
<list>
<item>des rêgles iptables,
<item>un routage correctement configuré
<footnote>
Le fait que ce comportement puisse être changé par le routage a été décrit par
Matthew G. Marsh dans l'enfilade sur bugtraq&nbsp;:
<example>
eth0 = 1.1.1.1/24
eth1 = 2.2.2.2/24

ip rule add from 1.1.1.1/32 dev lo table 1 prio 15000
ip rule add from 2.2.2.2/32 dev lo table 2 prio 16000

ip route add default dev eth0 table 1
ip route add default dev eth1 table 2
</example>
</footnote>,
<item>des correctifs du noyau
<footnote>
Il existe des correctifs disponibles pour ce comportement comme décrit dans
l'enfilade sur bugtraq à
<url id="http://www.linuxvirtualserver.org/~julian/#hidden">
et <url id="http://www.fefe.de/linux-eth-forwarding.diff">.
</footnote>
</list>
<p>Tout au long de ce texte, il y aura plusieurs occasions pour lesquelles ils
est affiché comment configurer certains services (serveur sshd, apache, service
d'impression, etc.) pour les avoir en attente sur une adresse donnée, le lecteur
devra prendre en compte que, sans les correctifs données ici, le correctif
n'empêchera pas les accès depuis le même réseau (local).
<footnote>
Un attaquant peut avoir beaucoup de problèmes à transférer un accès après une
configuration de l'adresse IP s'il n'est pas le domaine de broadcast (même
réseauà que l'hôte attaqué. Si l'attaque passe par un routeur, il peut être
assez difficile pour les réponses de retourner quelque part. <!-- euh ? -->
</footnote>

<p>FIXME: commentaires sur bugtraq indiquant qu'il existe une méthode spécifique
Linux pour associer à une interface donnée.

<p>FIXME: Créer un bogue sur netbase pour que le correctif de routage soit le
comportement standard dans Debian&nbsp;?

<sect1>Protéger contre les attaques ARP

<p>Quand vous ne faites pas confiance aux autres machines de votre réseau (ce
qui devrait toujours être le cas parce que c'est l'attitude la plus sûre), vous
devriez vous protéger contre les différentes attaques ARP existantes.

<p>Comme vous le savez, le protocole ARP est utilisé pour lier des adresses IP à
des adresses MAC (voir la <url name="RFC826"
id="ftp://ftp.isi.edu/in-notes/rfc826.txt"> pour tous les détails). À chaque
fois que vous envoyez un paquet à une adresse IP, une résolution arp est
effectuée (en regardant en premier dans le cache local ARP, puis si l'adresse IP
n'est pas présente dans le cache, en diffusant une requête arp) pour trouver
l'adresse matérielle de la cible. Toutes les attaques ARP ont pour but d'amener
votre machine à croîre que l'adresse IP de la machine B est associée à l'adresse
MAC de la machine de l'intrus&nbsp;; puis tous les paquets que vous voudrez
envoyer à l'adresse IP associée à la machine B seront envoyée à la machine de
l'intrus, etc.

<p>
Ces attaques (empoisonnement du cache, falsification ARP, etc.) permettent à
l'attaquant de renifler le trafic même sur des réseaux switchés, pour pirater
facilement des connexions, pour déconnecter tout hôte du réseau, etc. Les
attaques arp sont puissantes et simples à implémenter et plusieurs outils
existent comme <prgn>arpspoof</prgn> du paquet <package>dsniff</package>
ou <url name="arpoison" id="http://arpoison.sourceforge.net/">.

<!-- removed <url name="arpmim"
 id="http://www.team-teso.net/releases/arpmim-0.2.tar.gz">, <url
 name="arpoison" id="http://web.syr.edu/~sabuer/arpoison/">...
 ~sabuer broken and unavailable in the new web site provided -->

<p>Cependant, il existe toujours une solution&nbsp;:

<list>

<item>Utiliser un cache statique arp. Vous pouvez mettre en place des entrées
«&nbsp;statiques&nbsp;» dans votre cache arp avec&nbsp;:

<example>
arp -s host_name hdwr_addr 
</example> 

<p>En plaçant des entrées statiques pour chaque hôte important de votre réseau,
vous garantissez que personne ne pourra créer ou modifier une entrée
(dissimulée) pour ces hôtes (les entrées statiques n'expirent pas et elles ne
peuvent pas être modifiées) et les réponses arp falsifiées seront ignorées.


<item>Détecter le trafic ARP suspect. Vous pouvez utiliser
<package>arpwatch</package>, <package>karpski</package> ou des IDS plus
générales qui peuvent également détecter le trafic arp suspect
(<package>snort</package>, <url name="prelude"
id="http://www.prelude-ids.org">, etc.).

<item>Implémenter un filtrage de trafic IP validant l'adresse MAC.
</list>


<sect id="snapshot">Prendre un instantané (snapshot) du système

<p>Avant de mettre le système en production, vous pouvez prendre un instantané
de votre système entier. Cet instantané pourrait être utilisé en cas de
compromis (see <ref id="after-compromise">). Vous devriez refaire cette mise à
jour à chaque fois que le système est mis à jour, particulièrement si vous
mettez à jour vers une nouvelle version de Debian.

<p>Pour cela, vous pouvez utiliser un support inscriptible et amovible qui peut
être positionné en lecture seule, ce peut être une disquette (en lecture seule
après utilisation) ou un CD d'une unité de CD-ROM (vous pourriez utiliser un
CD-ROM ré-inscriptible, ainsi vous pourriez même garder des sauvegardes des
md5sums à différentes dates).

<p>Le script suivant crée un tel instantané&nbsp;:

<example>
#!/bin/bash
/bin/mount /dev/fd0 /mnt/floppy
/bin/cp /usr/bin/md5sum /mnt/floppy
echo "Calcul de la base de données md5"
>/mnt/floppy/md5checksums.txt
for dir in /bin/ /sbin/ /usr/bin/ /usr/sbin/ /lib/ /usr/lib/
do
   find $dir -type f | xargs /usr/bin/md5sum >>/mnt/floppy/md5checksums-lib.txt
done
/bin/umount /dev/fd0
echo "Base de données md5 de post-installation calculée"
</example>

<p>Notez que le binaire md5sum est placé sur la disquette pour pouvoir être
utilisé plus tard pour vérifier les binaires du système (juste au cas où il
serait aussi corrompu). 

<p>L'instantané n'inclut pas les fichiers sous
<file>/var/lib/dpkg/info</file> qui incluent les hashes md5 des paquets
installés (dans les fichiers se terminant par <file>.md5sums</file>). Vous
pourriez également y copier cette information, cependant il faut que vous
remarquiez que&nbsp;:

<list>
<item>les md5sums fournis par les paquets Debian incluent tous les fichiers que
ceux-ci fournissent, ce qui rend la base de données importante (5 Mo contre
600 ko dans un système Debian GNU/Linux avec un système graphique et environ
2.5 Go de logiciels installés)

<item>tous les paquets Debian ne fournissent pas les md5sums pour les fichiers
installé car ce n'est pas (actuellement) imposé par la Charte.

</list>

<p>Une fois que l'instantané est fait, vous devriez vous assurer de placer le
support en lecture seule. Vous pouvez ensuite le stocker pour archivage ou le
placer dans le lecteur et utiliser une vérification <prgn>cron</prgn> toutes les
nuits en comparant les md5sums d'origine avec ceux de l'instantané.

<sect>Autres recommandations

<sect1>N'utilisez pas de logiciels dépendant de svgalib

<p>
SVGAlib est très bien pour les amoureux de la console comme moi mais 
dans le passé il a été prouvé plusieurs fois qu'elle est très peu sûre.
Des exploits contre <prgn>zgv</prgn> ont été diffusés et il était facile de 
devenir root. Essayez d'éviter l'utilisation de programmes utilisant la 
SVGAlib chaque fois que c'est possible.

<!-- FIXME: move this to policy section if there ever is one? -->
