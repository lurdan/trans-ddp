<!doctype linuxdoc system>

<article>

<!-- Title information -->
<title>Securing Debian HOWTO
<author>Alexander Reelsen &lt;ar@rhwd.net&gt;
<date>v1.0  Sun,  3 Dec 2000 19:00:00 +0100
<abstract>
This document describes the process of securing and hardening the default
Debian installation as good as possible.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<sect>Introduction
<p>
One of the hardest things about writing security documents is that every case
is unique. Two things you have to pay attention to are the threat environment
and the security needs of the individual site, host or network. For instance,
the security needs of a home user are completely different from a network in a
bank. While the primary threat, a home user needs to face is the script kiddie
type of cracker, the bank network has to worry about directed attacks. And the
bank has to protect their customer's data with arithmetic precision. In short,
every user has to weigh himself between usability and security/paranoia.
<p>
As a very important note I am going to tell you now, that this HOWTO only
covers software topics. It is completely your problem how you physically
secure your computer. You can place it under your workdesk, or you can place
it in a nuclearproofed bunker with an army in front of it. Nevertheless the
workdesk computer can be much more secure (from the software point of view)
than the other one. As this HOWTO is only covering the software side you also
should think about the other side. In addition this document just gives a brief
overview what you can do to increase the security of your Debian GNU/Linux
installation. Many parts of this HOWTO can be transferred to other
distributions as well.
<p>
If you have critics, additions, hints, mail them to <url
name="the author" url="mailto:ar@rhwd.net">and they will incorporated into
this HOWTO. 


<sect1>Disclaimer &amp; License
<p>
This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY.
<p>
It is (C) 2000 by Alexander Reelsen, however it underlies the terms of the GNU
free documentation license.


<sect1>Download the HOWTO
<p>
You can download or view the newest version of the Securing Debian HOWTO in the
following formats:
<itemize>
<item><url name="Textonly" url="http://joker.rhwd.de/doc/Securing-Debian-HOWTO/Securing-Debian-HOWTO.txt">
<item><url name="HTML" url="http://joker.rhwd.de/doc/Securing-Debian-HOWTO/Securing-Debian-HOWTO.html">
<item><url name="HTML, tarred &amp; gzipped" url="http://joker.rhwd.de/doc/Securing-Debian-HOWTO/Securing-Debian-HOWTO.tar.gz">
<item><url name="SGML" url="http://joker.rhwd.de/doc/Securing-Debian-HOWTO/Securing-Debian-HOWTO.sgml">
</itemize>

<sect1>Organizational Notes/Feedback
<p>
Now to the official part. At the moment I wrote most paragraphs of this HOWTO,
but in my opinion this should not stay the case. I grew up and live with free
software, it is part of my everyday use and I guess yours, too. I encourage
everybody to send me feedback, hints additions or any other suggestions, you
might have.

If you think, you can maintain a certain section or paragraph better than me,
then write this to me and you are welcome to do it. Especially if you find a
section marked as FIXME, what means I did not have the time yet or the needed
knowledge about the topic, drop me a mail immediately.

The topic of this HOWTO makes is quite clear, that it is important to keep
uptodate, and you can help to keep the quality of this HOWTO up, so do it.

<sect1>Prior knowledge
<p>
The installation of Debian GNU/Linux is not very difficult and you should have
been able to install it. If you already have some knowledge about Linux or
other Unices and you are a bit familiar with basic security, it will be easier
to understand this HOWTO, as of I cannot explain every little detail of a
feature (I should have written then a book instead of a HOWTO).


<sect1>TODO
<p>
<itemize>
<item>suidmanager/dpkg-statoverrides
<item>lpr and lprng
<item>Switching off the gnome IP things
<item>LKM, linux kernel modules, bad and good ones
</itemize>


<sect1>Credits
<p>
<itemize>
<item>Robert van der Meulen with the quota paragraphas and many good ideas
<item>Ethan Benson corrected the PAM paragraph and had some good ideas
<item>All the folks who encouraged me to write this HOWTO
<item>The whole Debian project
</itemize>



<sect>Before and during the installation

<sect1>Choose a BIOS password
<p>
Before you install any operating system on your computer, setting up a BIOS
password is essential to ensure basic security as well as changing your boot
sequence to disable floppy booting. Otherwise the cracker just needs to bring
a bootdisk with him. Disable booting without a password would be the best, if
noone should touch that system. This can be very effective if you run a server,
because usually it does not get rebooted often.


<sect1>Choose an intelligent partition scheme
<p>
An intelligent partition scheme depends on the operational area of the machine.
Rule of thumb is to be fairly liberal with your partitions and to pay attention
to the following factors.

<itemize>
<item>Any partition a user has write permissions to, should be a seperate
partition, e.g. /home and /tmp. This reduces the risk of a user DoS by filling
up your "/" mount point and rendering the system unusable that way.

<item>Any partition which can fluctuate, e.g. /var (especially /var/log). In
Debian context you should create /var a little bit bigger than normal because
the downloaded packages aka the apt cache is stored in /var/apt/cache/archives.

<item>Any partition where you want to install non-distribution software.
According to the file hierarchy standard now preferrably /opt or /usr/local. If
you keep this seperate partitions, you do not need to remove them, even if you
reinstall.
</itemize>


<sect1>Set a root password
<p>
Setting a good root password is the most basic requirement for having a secure
system.


<sect1>Activate shadow passwords and MD5 passwords
<p>
After the installation, you will be asked if the shadow passwords should be
enabled. You should say yes to this question, because then the passwords will
be kept in the file /etc/shadow. Only the root user and the group shadow
will have read access to this file. So any user will not be able to grab a
copy of this file and run a password cracker against it. Optionally, you can
switch from shadow passwords and normal passwords by using 'shadowconfig'
(what normally should not be necessary). Furthermore you are queried
during installation whether you want to use MD5 hashed passwords. This is
generally a very good idea since it offers more long passwords and better
encryption.


<sect1>No overbloating
<p>
You should not install services on your machine, which are not needed. Every
installed service introduces new, perhaps not obvious, but existant security
holes to your machine. If you still want to have some services but you use
these rarely, use the update-commands, eg 'update-inetd' for removing them
from the startup process.



<sect>After Installation

<sect1>Set a LILO or GRUB password
<p>
Anybody can easily get a root-shell and change your passwords by entering
"&lt;replace-with-name-of-your-bootimage&gt; init=/bin/sh". After changing the
passwords and rebooting the system, the person has unlimited root-access to it
and can do anything with it, which includes changing sensitive data. After this
procedure you will not have access to your system anymore, as you do not know
the root password.
<p>
To make sure that this will not happen, you should set password even for that.
You can choose between a global password or a password for a certain image. For
LILO you need to follow this steps. You need edit the file /etc/lilo.conf.
Add this line to your lilo.conf and rerun lilo:

<tscreen><verb>
image=/boot/2.2.14-vmlinuz
   label=Linux
   read-only
   password=hackme
   restricted
</verb></tscreen>

<p>
If you leave out the "restricted" above, you will always be prompted to enter a
password, regardless if you passed parameters to LILO. Well, when adding a
password you should make sure, that only root can read the lilo config file,
so make proper permission changes.
If you use GRUB instead of LILO, edit the file /boot/grub/menu.lst and add the
following to lines at the top of it. This will set a boot-password and also
boot the default entry after waiting 3 seconds:

<tscreen><verb>
timeout 3
password hackme
</verb></tscreen>


<sect1>Disallow floppy booting
<p>
This paragraph refers to a BIG flamewar in the debian-devel mailing list (I
think I will get flamed as well because I described something wrong :)).
But back to the topic. The default MBR in Debian GNU/Linux does not act as an
usual master boot record. Here is the way howto get into your system, even if
you changed the BIOS boot sequence AND gave LILO a password:
<itemize>
<item>Press shift at boot time, and Debian's MBR will give you a prompt
<item>Then press F, and your system will boot from floppy disk, and you will
get full root access to the hard disk
</itemize>

Make yourself clear, that this is a DEFAULT master boot record of
debian, so you really should change this, simply by entering:

<tt>lilo -b /dev/hda</tt>

Now LILO is put into the MBR. This goal can also be achieved by writing
"boot=/dev/hda" into lilo.conf But there is as well another solution where
you can disable mbr prompt at all:

<tt>install-mbr -i n</tt>

On the other hand, this "backdoor", of which many people are just not
aware, may save your skin as well if you run into deep trouble with your
installation out of whatever reasons.

INFO: The current bootdisks do NOT install the mbr, but only LILO by
default, so you do not have any hassle anymore. But check your upgraded
slink or old potato installations.


<sect1>Mounting partitions the right way
<p>
When mounting an ext2 partition you have several additional options you
apply to the mount call or the /etc/fstab. For instance, this my fstab
entry for the /tmp partition:
<tscreen><verb>/dev/hda7    /tmp    ext2    defaults,nosuid,noexec,nodev    0    2</verb></tscreen>
<p>
You see the difference in the options sections. The option <tt>nosuid</tt>
ignores the setuid and setgid bits completely, while <tt>noexec</tt>
forbids execution of any program on that mountpoint and <tt>nodev</tt>,
which ignores devives completely. This sounds great, but it
<itemize>
<item>applies to ext2 filesystems only
<item>can be circumvented easily
</itemize>
The <tt>noexec</tt> option allows binaries not to be executed, what seems
fine, but take a look at this:
<tscreen><verb>
alex@joker:/tmp# mount | grep tmp
/dev/hda7 on /tmp type ext2 (rw,noexec,nosuid,nodev)
alex@joker:/tmp# ./date
bash: ./date: Permission denied
alex@joker:/tmp# /lib/ld-linux.so.2 ./date
Sun Dec  3 17:49:23 CET 2000
</verb></tscreen>
<p>
However, many script kiddies do have exploits which try to create and
execute files in /tmp. If they do not have a clue, they will fall into
this pit.

<sect1>PAM - Pluggable Authentication Modules
<p>
PAM is an abbrevation for Pluggable Authentication Modules. PAM is useful for
a kind of "dynamical configuration of authentication". If you want to use PAM,
you should make sure, that the application uses PAM. Most of the applications
that are shipped with Debian 2.2 have this support compiled in. Note, that PAM
did not exist in earlier Debian versions than potato For each application there
is a seperate configuration file in /etc/pam.d/.

PAM offers you the possibiblity to go through several authentication steps
once, without the user's knowledge. You could authenticate against a berkeley
database and the passwd and the user only logs in if he authenticates correct
twice. You can restrict a lot with PAM, as well as you can open your system
doors very wide. So be careful. A typical configuration line has a control
field as its third element. Generally it should be set to "requisite", what
returns a login failure, if one module fails. (However, if you know what you
do, you can play around a lot).

The first thing I like to do, is to add MD5 s	upport to my PAM applications,
since this protects you against dictionary cracks a little bit more. These two
lines should be in all the files like 'login' or 'ssh' in /etc/pam.d/.

<tscreen><verb>
password   required     pam_cracklib.so retry=3 minlen=12 difok=3
password   required     pam_unix.so use_authtok nullok md5
</verb></tscreen>

So, what does this myth do? The first line loads the cracklib PAM module, which
provides password-strength checking and prompt for a new password with 3
retries, a minimum length of 12 characters and a difference of at least 3
characters to the old password. The second line introducs the standard
authentication module with md5 passwords and a zero password is ok. The
use_authtok directive is necessary to hand over the password from the module
before.

To make sure, that the user root can only log into the system from some local
Terminals, the following line should be enabled in /etc/pam.d/login. Then you
should add the Terminals from which the user root can log into the system into  the file /etc/security/access.conf:

<tt>auth     requisite  pam_securetty.so</tt>

And last but not least the following line should be enabled if you want to set
up some user limits. This allows the users only to use certain resources of the
system, as for example a maximum number of logins.

<tt>session  required   pam_limits.so</tt>

Now edit the file /etc/pam.d/passwd and change the first line. You should add
the option "md5" to use md5 passwords and change the minimum lenght of password
from 4 to 6 and set a maximum length if you desire. Then the line should look
like this one:

<tt>password   required   pam_unix.so nullok obscure min=6 max=11 md5</tt>

If we want to protect su, so that only some people can use it to become root on
your system, we need to add a new group "wheel" to your system (at least that
is the cleaner way, since no file has such a group permission yet). Add root
and the other users that should be able to "su" to the user root to this group.
Then create the following line in /etc/pam.d/su:

<tt>auth        requisite   pam_wheel.so group=wheel debug</tt>

This makes sure that only people from the group wheel can use to su to become
root. Other users will not be able to become root. In fact they will get a
denied message if they try to become root.

Last, but not least, create /etc/pam.d/other and enter the following lines:

<tscreen><verb>
auth     required       pam_securetty.so
auth     required       pam_unix_auth.so
auth     required       pam_warn.so
auth     required       pam_deny.so
account  required       pam_unix_acct.so
account  required       pam_warn.so
account  required       pam_deny.so
password required       pam_unix_passwd.so
password required       pam_warn.so
password required       pam_deny.so
session  required       pam_unix_session.so
sesion   required       pam_warn.so
session  required       pam_deny.so
</verb></tscreen>

This lines will provide with a good default configuration for all applications
that support PAM (deny instead of allow per default).


<sect1>The limits.conf file
<p>
You should really take a serious look into this file. Here you can define the
user resource limits. If you use PAM, this file is invalid. Use
/etc/security/limits.conf instead.
<tt>FIXME: Get a good limits.conf up here</tt>


<sect1>Edit /etc/inetd.conf
<p>
You should stop all services on your system, like echo. charges, discard,
daytime, time, talk, ntalk and the HIGHLY insecure considered r-services. After
disabling those, you again should check if you really need the inetd daemon.
Some persons, including the author, prefer to use daemons instead of calling
them via inetd, because there exist Denial of Service possibilites against
inetd, which increase the machine's load rapidly. If you still want to run some
kind of inetd service, use a more configurable inet daemon like xinetd or
rlinetd.


<sect1>Edit /etc/login.defs
<p>
The next step is to edit the basic configuration and action upon user login.

<tt>FAIL_DELAY          10</tt>

This variable should be set to a higher value to make it harder using the
terminal to log in using brute force style. If a wrong password is typed in,
he has to wait for 10 seconds to get a new login prompt, what is quite time
consuming when you test passwords. Pay attention to the fact, that this
setting is useless if using another program than getty, mingetty for example.

<tt>FAILLOG_ENAB        yes</tt>

If you enable this variable, failed logins will be logged. It is important to
know them to see if someone tries a brute force attack to get login information.

<tt>LOG_UNKFAIL_ENAB    yes</tt>

If you set the variable "FAILLOG_ENAB" to yes, then you should also set yes to
this variable. This will record unkown usernames if the login failed. If you
do this, make sure, the logs are set to the right permissions (640 I prefer,
with appropriate group settings like adm group), because if a user
incidentally enters his password as username, it gets logged and could be read
by any other user.

<tt>SYSLOG_SU_ENAB      yes</tt>

This one enables logging <tt>su</tt> tries to syslog. Quite important on serious
machines, but note that this can vulnerate privacy issues as well.

<tt>SYSLOG_SG_ENAB      yes</tt>

The same as SYSLOG_SU_ENAB, but applies to the <tt>sg</tt> call.

<tt>MD5_CRYPT_ENAB      yes</tt>

As stated above, md5 sum passwords greatly reduce the problem of
dictionary attacks, because it is really complicate to perform a crack
against MD5 hashed passwords, at least it is hard to perform a successful
crack. But before enable this option, READ the docs about MD5. This
option only applies to slink users, otherwise you set this in PAM.

<tt>PASS_MAX_LEN        50</tt>

If you activated as suggested above md5 passwords in your PAM configuration,
then you should set this variable to the same value as you used in your
PAM configuration.


<sect1>Editing /etc/ftpusers
<p>
This file contains a list of users, who are not allowed to log into this host
using ftp. Use this file, if you really want to allow ftp (which is not
recommended by the author, because it uses cleartext passwords). If your daemon supports PAM, you can also use this for allowing and denying users for a
certain service


<sect1>Using tcp wrappers
<p>
TCP wrappers have been implemented, when there were no real packet filters
available and some sort of access control was needed. The TCP wrappers allow
you to allow or deny a service for a host or a domain and define a default
allow or deny rule.
If you want more informations look into the manpage hosts_access(5).

Now, here comes a small trick and probably the smallest intrusion
detection system available. In general you should have a decent firewall
policy as a first line and tcp wrappers as the second line of defense.
One little trick is to set up a spawn command in /etc/hosts.deny that
sends mail to root whenever a denied service triggers wrappers:

<tscreen><verb>
ALL: ALL: spawn ( \
  echo -e "\n\
  TCP Wrappers\: Connection refused\n\
  By\: $(uname -n)\n\
  Process\: %d (pid %p)\n\
  User\: %u\n\
  Host\: %c\n\
  Date\: $(date)\n\
" | /bin/mail -s "Connection to %d blocked" root)
</verb></tscreen>

<em>Beware</em>: The above printed example can easily be DoS'ed by doing
lots of connections in a short period of time. Many emails mean a lot of
file I/O by sending only a few packets.


<sect1>Using su
<p>
If you really need to become the super user on your system, eg for installing
packages or adding users, you can use the command <tt>su</tt> to change your
identity. You should try to avoid any login as user root and instead use su.
Anyway, the best solution is to remove su and switch to sudo, as it does have
more features than su. However, su is more common as it also is used on many
other Unixes.


<sect1>Using sudo
<p>
sudo allows the user to execute defined commands under another users identity,
even as root. If the user is added in /etc/sudoers and authenticate himself
with his password, he is able to run commands, which have been defined in
/etc/sudoers, as user root. Security violations in forms of wrong
authentication will be mailed and logged.


<sect1>Using chroot
<p>
chroot is one of the most powerful possibilities to restrict a daemon or a
user or another service. Just imagine a jail around your target, where the
target cannot escape from (normally, but there are still a lot of conditions
how one can esacpe out of such a jail). If you do not trust a user, you can
create a change root enviroment for him (if you have enough free space,
because you need to copy the libraries as well or compile everything
statically, both eats up some space, but security is not without any cutback).
If now the user does something malicious, he will not be very harmful anymore.
A good example for this case is, if you do not authenticate against
/etc/passwd but LDAP or MySQL instead. So your ftp-daemon needs a binary and
perhaps a few libraries. A chrooted environment would be an execellent security
improvement, if a new exploit is known for this ftp-daemon. It is then only
possible to exploit the UID of the ftp-daemon-user and nothing else. Of
course, this complies with lots of other daemons as well.
<p>
As an additional note, the Debian default BIND (the name-service) is not
shipped chrooted per default, in fact no daemons come chrooted. I hope this
will change in the woody release.


<sect1>Configuring some kernel features
<p>
<tt>FIXME - Content missing</tt>
You can configure a lot of kernel settings during runtime by echoing something
into the proc file system or by using sysctl. By entering <tt>sysctl -A</tt> you
can see what you can configure and how it is configured right now. Only in
rare cases you really need to edit something here, but you can increase
security that way as well.

<tt>net/ipv4/icmp_echo_ignore_broadcasts = 0</tt>

This is a 'windows emulator', because it acts like windows on broadcast
ping, if this one is set to 1. It just does nothing.

<tt>net/ipv4/icmp_echo_ignore_all = 0</tt>

If you don't want to block ICMP on your firewall, just enable this.


<sect1>Do not use software depending on svgalib
<p>
SVGAlib is very nice for console lovers like me, but in the past it has been
proven several times, that it is very insecure. Exploits against zgv were
released, and it was simple to become root. Try to prevent using SVGAlib
programs whereever possible.


<sect1>Secure file transfers
<p>
Copying files in a secure manner from a host to another can be achieved by
using 'scp' which is included in the ssh package. It works like rcp but is
encrypted completely, so the bad guys cannot even find out WHAT you copy, what
is not bad in some situations.


<sect1>Using quotas
<p>
Having a good quota policy is important, as it keeps your users from filling
up your disk(s).&nl;
You can use two different quota systems - user quota and group quota. As you
probably figured out, user quota limits the amount of space a user can take
up, group quota does the equivalent for groups. Keep this in mind when you're
working out quota sizes.<p>

There are a few important points to think about in setting up a quota
system:&nl;
<itemize>
<item>Keep the quotas small enough, so users do not eat up your disk space
<item>Keep the quotas big enough, so users do not complain or their mail quota
keeps them from accepting mail over a longer period
<item>Use quotas on all user-writable areas, on /home as well as on /tmp to
restrict the user as good as possible.
</itemize>
<p>
Every partition/directory users have full write access should be quota enabled.
So find out those partitions and directories and calculate a valuable quota
size, which concatenates usability and security.

So, now you want to use quotas. First of all you need to check whether you
enabled quota support in your kernel. If not, you will need to recompile it.
After this, control whether the package 'quota' is installed. If not you will
need this one as well.

Enabling quota for the respective filesystems is as easy as modifying the
'defaults' setting to 'defaults,usrquota' in your /etc/fstab file. If you need
group quota, substitute 'usrquota' to 'grpquota'. You can also use them both.
Then create empty quota.user and quota.group files in the roots of the
filesystems you want to use quotas on (e.g. <tt>touch /home/quota.user</tt>,
<tt>touch /home/quota.group</tt> for a /home filesystem).

Restart quota by doing <tt>/etc/init.d/quota stop;/etc/init.d/quota
start</tt>. Now quota should be running, and quota sizes can be set.

Editing quotas for a specific user (say 'ref') can be done by
<tt>edquota -u ref</tt>. Group quotas can be modified with<tt>edquota -g
&lt;group&gt;</tt>.
Then set the soft and hard quota and/or inode quotas as needed.

For more information about quotas, read the quota man page, and the quota
mini-howto.


<sect1>Logfile permissions
<p>
Some logfile permissions are not perfect after the installation. First
/var/log/lastlog and /var/log/faillog need not to be readable for the normal
users. In the lastlog file you can see the who logged in the lasttime and in
the faillog you see a summary of the failed logins. The author recommends
chmod'ing both to 660 both files. Take a brief log over your logfiles and
decide very carefully which logfiles you make read/writeable for a user with
another UID than 0 and a group other named than 'adm' or 'root'.&nl;
I want to emphasize that the apache logfile permissions are really screwed due
to the fact, that the apache user owns the apache log files. When you get a
shell as such user with a apache backdoor, you easily can remove the logfiles
and blur your spoors.


<sect1>chattr/lsattr
<p>
These two commands are very useful, but they only work for the ext2 filesystem.
With 'lsattr' you can list the attributes of a file and with 'chattr' you can
change them. Note that attributes do not equal to permissions. In fact, they
are completely different. Here are only listed the most important attributes
for increasing your security, but there are other as well.&nl;
There are two flags which can only be set by the superuser. Those are tho most
important ones.&nl;
First there is the 'a' flag. If set on a file, this file can only be opened
for appending. This attribute is useful for some of the files in /var/log/,
though you should consider they get moved sometimes due to the log rotation
scripts.&nl;
The second flag is the 'i' flag, short for immutable. If set on a file, this
file can neither be modified nor deleted nor renamed and no link be created to
this file. If you do not want you users to look into your config files you
could set this flag and remove readability. Furthermore it might give you a
little bit security against intruders, because the cracker might confused of
not being able to remove a file. Although you should never assume that the
cracker is blind, he got into your system, so he defeated your security policy.


<sect1>Your filesystem integrity
<p>
Are you sure /bin/login on your harddrive is still the binary you installed
there some months ago? What if it is a hacked version, which stores the
entered password in a hidden file or mails it in cleartext version all over
the internet?&nl;
The only method to have some kind of protection is to check your files every
day/hour/month (I prefer daily) by comparing the actual and the old md5sum of
this file. Two files cannot have the same md5sum, so you're on the secure site
here, except someone hacked the algorithm to create md5sums on that machine,
what is, well, sticky. You really should consider this auditing of your
binaries as very important, since it is an easy way to recognize changes at
your binaries. Common tools used for this are sXid, AIDE (Advanced Intrusion
Detection Environment) and TripWire (non-free, the new version will be GPL).
<p>
Furthermore you can exchange your locate package with 'slocate' tool. slocate
is a security enhanced version of the GNU locate. When performing a locate,
the user only sees the files he really has access to and you can exclude any
files or directoriey you want to exclude.



<sect>Securing services running on your system

<sect1>Securing ssh
<p>
If you are still running telnet and not ssh, you should stop reading this
manual now and change this. You should not use the telnet for remote logins
and instead use ssh. Especially today, where it is easy to sniff traffic in
the internet and get cleartext passwords, you should use secure protocols which
use cryptography. So, perform a <tt>apt-get install ssh</tt> on your system now.
Encourage all the other users on your system to use ssh instead of telnet,
even better, uninstall telnet. In addition you should try to avoid logging
into the system using ssh as root, and use alternative methods to become root
instead, like <tt>su</tt> or <tt>sudo</tt>. The sshd_config file (located at
/etc/ssh) should be corrected a little bit as well.

<tt>PermitRootLogin No</tt>

Try not to permit Root Login wherever possible. If anyone wants to become root
via ssh, now two logins are needed and the root password cannot be brute
forced via SSH.

<tt>Listen 666</tt>

Change the listen port, so the intruder cannot be completely sure whether a
sshd daemon runs.

<tt>PermitEmptyPasswords no</tt>

Empty passwords are ugly as hell out of the security view.

<tt>AllowUsers alex ref</tt>

Allow only certain users to have access via ssh to this machine.

<tt>AllowGroups wheel admin</tt>

Allow only certain group members to have access via ssh to this machine. Both,
AllowGroups and AllowUsers have equivalent directives for denying access to a
machine. Suprisingly they were called "DenyUsers" and "DenyGroups".

<tt>PasswordAuthentication yes</tt>

It is completely your choice what you want to do. It is more secure only to
allow access to machine from users with ssh-keys placed in the
~/.ssh/authorized_keys file. If you want so, set this one to "no".

As a final note be aware, that these directives are from a OpenSSH
configuration file. Right now, there are three types of common used SSH
daemons, ssh1, ssh2 and OpenSSH by the OpenBSD people (hey, quite a cool logo,
I still need to buy a t-shirt). ssh1 was the first ssh daemon available and it
is the one, which is mainly used right now (I heard rumors it even exists a
windows port). ssh2 has many advantages over ssh1 (that is why they called it
'2' I guess) except the bad non-opensource license, what kicks this daemon for
Debian. OpenSSH is completely free ssh daemon, which is based on an old free
ssh1, but then many improvements and extensions were made and the most
important thing, the non-free code was removed, so that this is Debian's No.
1 choice right now.


<sect1>Realize the insecurity of X over network
<p>
Today X-Terminals becoming more and more interesting for companies, where one
server is needed for a lot of workstations. But this is dangerous, because you
need to allow the server to connect to the the other X server (it is a client,
but X switches the definitions of client and server). If you follow the
suggestion from many docs, you do a <tt>xhost +</tt>. This allows every X
client to connect to your system. So it is recommend to use the command 
<tt>xhost +hostname</tt> instead for certain hosts, that should be able to
connect to your X server. The best existing alternative is to use ssh to tunnel
X and encrypt the whole session. In addition, if you do not need X over the
wires, then you can switch off the binding on tcp port 6000 simply by typing:

<tt>startx -- -nolisten tcp</tt>


<sect1>The lpd and lprng issue
<p>
Imagine, you are coming to work, and the printer spits out endless amounts of
paper, because someone is DoS'ing your line printer daemon. Nasty, isn't it?
So, keep your printer servers specially secure.

<tt>FIXME. Content missing. (No lpr experience)</tt>


<sect1>Using mail securely
<p>
Reading/receiving mail is the most common cleartext protocol. If you either
use POP3 or IMAP to get your mail you send your password cleartext across the
wires, so almost everyone can read your mails from now on. So use SSL (Secure
Socket Layer) to receive your mails. The other alternative is ssh, if you have
a shell account on your box.&nl;
Look at this basic fetchmailrc:

<tscreen><verb>
poll my-imap-mailserver.org via "localhost"
  with proto IMAP port 1236
      user "ref" there with password "hackme" is alex here warnings 3600
    folders
      .Mail/debian
    preconnect 'ssh -f -P -C -L 1236:my-imap-mailserver.org:143 -l ref
     my-imap-mailserver.org sleep 15 &lt;/dev/null &gt; /dev/null'
</verb></tscreen>

The important line is the preconnect line. It fires up a ssh session and
creates the necessary tunnel, which automatically forwards connections to
localhost port 1236 to the imap mail server, but encrypted now. Another
possibility would be to use fetchmail with the ssl feature.<p>
If you want to provide encrypted mail services like POP and IMAP,
<tt>apt-get install stunnel</tt> and start your daemons now this way:&nl;
<tt>stunnel -p /etc/ssl/certs/stunnel.pem -d pop3s -l /usr/sbin/popd</tt>
This command wraps the provided daemon (-l) to the port (-d) and uses the
specified ssl cert (-p).


<sect1>Using a loghost
<p>
A loghost is a host which collects the syslog data remote over the network. If
one of your machines is cracked the intruder is not able to blur his spoors,
except he hacks that loghost as well. So, spend your loghost an extra amount
of paranoia. Making your machine a loghost is really simple. Just start the
syslogd with 'syslogd -r' and a new loghost is born. Now you have to configure
your other machines to send the data to the loghost. Add an entry like this
one in <tt>/etc/syslog.conf</tt>:<p>

<tscreen><verb>facility.level            @your_loghost</verb></tscreen>

facility should be one of authpriv, cron, daemon, kern, lpr, mail, news,
syslog, user, uucp and local1 up to local7. level should be alert, crit, err,
warning, notice, info debug. If you want to log everything remote, just write:

<tscreen><verb>*.*                       @your_loghost</verb></tscreen>

into your syslog.conf. Logging remote as well as local would be the best
solution (the attacker could presume not to be found after deletion of local
log files, an often used method to mask an intrusion). See the syslog(3),
syslogd(8) and syslog.conf(5) manpage for some additional information.


<sect1>Securing BIND
<p>
On a standard Debian installation, the name service daemon, BIND, runs as user
root and group root. It is possible and quite easy to achieve to run BIND
under another's UID. However, running BIND not as root prevents it from
detecting and using interfaces automatically, for example if you stick a
PCMCIA card into your laptop (anyway, I don't think BIND runs on a laptop per
default). Check the README.Debian file in your named documentation directory
for more information.
<p>
Anyway, noone can deny the existing security problems, which occured in the
last months concerning BIND, so switchting the user is useful where it is
possible. First you should create a seperate user and group for it (don't use
either nobody or nogroup for every service not running as root or another user).
In this case I will use user and group 'named'.
<p>
Now edit <tt>/etc/init.d/bind</tt> with your favourite editor and change the
line beginning with
<p>
<tt>start-stop-daemon --start</tt>
&nl;to&nl;
<tt>start-stop-daemon --start --quiet --exec /usr/sbin/named -- -g named -u
named</tt>
<p>
All you need to do now is to restart bind via '/etc/init.d/bind
restart', and then check your syslog for two entries like this:
<p>
<tscreen><verb>
Sep  4 15:11:08 nexus named[13439]: group = named
Sep  4 15:11:08 nexus named[13439]: user = named
</verb></tscreen>
<p>
Voila! Your named now does not run as root. To achieve maximum BIND
security, now build a chroot jail (See 3.13) around your daemon.



<sect>Before the compromise

<sect1>Follow the debian security updates
<p>
As soon as new security bugs are revealed in packages, debian maintainers and
upstream authors try to patch them within days or even hours. After the bug is
fixed, a new package is provided on <url name="http://security.debian.org"
url="http://security.debian.org">. Put the following line in your sources.list
and you will get the security updates as well.
<p>
<tt>deb http://security.debian.org/debian-security potato/updates main contrib non-free</tt>

And for most people (unless you live in a country which prohibits importing
or using strong cryptography) this one as well:

<tt>deb http://security.debian.org/debian-non-US potato/non-US main contrib non-free</tt>

If you want, you can add the deb-src lines to apt as well, see the manpage
for further details.


<sect1>Exchange software
<p>
You should try to avoid every network service which sends and receives
passwords in cleartext over a net like FTP/Telnet/NIS/RPC. The author
recommends the use of ssh instead of telnet and ftp to everybody.

Also you should stop using NIS -the network information service- , if it is
possible, because it allows password sharing. This can be highly insecure, if
your setup is broken.

Last, but for sure not least, disable RPC whereever possible. Lots of security
holes are known and can be exploited. On the other hand NFS services are quite
important in some networks, so find a balance of security and usability in a
network. Most of the DDOS (distributed denial of service) attacks use rpc
exploits to get into the system and act as a so called agent/handler.

Disabling portmap is quite simple. There are different methods. The simplest
one is to remove every symlink in /etc/rc${runlevel}.d/ (I mean you should
only remove the portmap symlinks, not the others!). You could as well chmod
644 /etc/init.d/portmap, but that gives you an error message. Or you could
strip of the "start-stop-daemon" part in the init.d shell script. Follow the
perl motto...
  
Keep in mind, that migrating from telnet to ssh, but using any other
cleartext protocol does not increase your security in ANY way! Best
would be to remove ftp, telnet, pop, imap, http and to supersede them
with their respective crypted services.

Most of these above listed hints apply to every Unix system.


<sect1>Useful kernel patches
<p>
There do exist some kernel patches, which significant enhance the system
security. Here are those one I know:
<p>
<itemize>
<item>OpenWall patch by Solar Designer&nl;
This is a useful set of kernel restrictions, like restricted links,
FIFOs in /tmp, restricted /proc, special file descriptor handling,
non-executable user stack area and some more.&nl;
Homepage: <url name="http://www.openwall.com/linux/" url="http://www.openwall.com/linux/">

<item><em>LIDS - Linux intrusion detection system by Huagang Xie &amp; Philippe Biondi</em>&nl;
This patch makes the process of creating a hardened Linux system easier. You
can restrict every process, give it rights two write or read files, or
disallow perdefault to read files. Furthermore you can also set capabilities
for certain processes. However it is still a little bit in the beta phase, but
a must for paranoia system.&nl;
Homepage: <url name="http://www.lids.org" url="http://www.lids.org">

<item><em>POSIX Access Control Lists (ACLs) for Linux</em>&nl;
This patch adds some kind of access control lists, an advanced access method
to files, to the linux kernel.&nl;
Homepage: <url name="http://acl.bestbits.at/" url="http://acl.bestbits.at/">

<item><em>Linux trustees</em>&nl;
This patch adds a decent advanced permissions system to your Linux kernel. All
the objects are stored in the kernel memory, what allows a real quick lookup
of all these permissions.&nl;
Homepage: <url name="http://www.braysystems.com/linux/trustees.html" url="http://www.braysystems.com/linux/trustees.html">

<item><em>International kernel patch</em>&nl;
This is a crypt-orientated kernel patch, therefore you have to pay
attention to your local crypt policy. It basically adds use of
encrypted file systems.&nl;
Homepage: <url name="http://www.kerneli.org" url="http://www.kerneli.org">

<item><em>SubDomain</em>&nl;
A kernel extension to create a more secure and easier to setup chroot
environment. You can specify the files needed for the chrooted service
manually and do not have to compile the services statically. (Not yet
completed at the time of writing this).&nl;
Homepage: <url name="http://www.immunix.org" url="http://www.immunix.org">

<item><em>UserIPAcct</em>&nl;
This is not really a security related patch, but it allows you to create
quotas for the traffic on your server per user. And you can fetch
statistics about the user traffic.&nl;
Homepage: <url name="http://rsmeyers.3ti.org/useripacct" url="http://rsmeyers.3ti.org/useripacct">
</itemize>


<sect1>Genius/Paranoia Ideas, what you could do
<p>
This is probably the most fluctuent and funny section, since I hope that some
of the "duh. that sounds crazy"-ideas might be realized. Following here you
will find some - well, it depends on the point of view whether you say they
are genius, paranoid, crazy or secure - ideas to increase your security
rapidly but you will not come unscathed out of it.

<itemize>
<item>Playing around with PAM&nl;
As said in the phrack 56 PAM article the nice thing with PAM is that "You are
limited only by what you can think of.". It is true. Imagine root login only
possible with fingerprint or eyescan or cryptocard (hm, why did I do an OR
conjunction and not AND here).

<item>Fascist Logging&nl;
I would say everything we talked about logging above is "soft logging". If you
want to perform real logging, get a printer with fanfold paper and log
everything hard by printing on it. Sounds funny, but it's reliable and it
cannot be removed.

<item>CD distribution&nl;
This idea is very easy to realize but the hell secure. Create a hardened
debian distribution, a damned good firewall, make an ISO of it and burn it on
CD. Make it bootable. Upshot of all this is a ro whole distribution with about
600 MB space for services and the fact to make it impossible for intruders to
get read write access on this system. Just make sure every data which should
get written, gets written over the wires. Anyway, the intruder cannot change
firewall rules, routing entries or start own daemons (he can, but reboot
and he has to hack into your system again to change them).

<item>Switch module capability off&nl;
When you disable the usage of kernel modules at kernel compile time, many
kernel based backdoors are impossible to implement, since most of them are
based on kernel modules.
</itemize>


<sect>After the compromise

<sect1>General behaviour
<p>
If you really want to clean up residual wastes, you should remove the
compromised host out of your network and install a new OS from scratch on.
This might not take any effect if you do not know how the intruder got root.
So just check everything, firewall/file integration/loghost logfiles and so
on.


</article>
