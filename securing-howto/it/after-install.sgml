
<chapt><heading>Dopo l'installazione</heading>






<p>
Dopo aver installato il sistema, bisogna renderlo sicuro; molti esempi
descritti in questo capitolo puntano ad ottenere tale risultato.
Questo dipende dal vostro setup ma per la prevenzione dagli accessi 
siete invitati a leggere i seguenti paragrafi:
<ref id="bios-boot">,<ref id="lilo-passwd">,<ref id="kernel-root-prompt">, <ref id="floppy-boot">, <ref id="restrict-console-login">, e <ref id="restrict-reboots">.</p>

<p>
Dopo essersi connessi a qualsiasi rete, specialmente se pubblica, effettuate
un aggiornamento di sicurezza (vedete <ref id="security-update">).
Opzionalmente potete fare un backup del vostro sistema (in merito guardate 
<ref id="snapshot">).</p>

<sect id="debian-sec-announce"><heading>Iscrizione alla mailing list 
Debian security announce</heading>

<p>
Per ricevere informazioni sugli aggiornamenti di sicurezza disponibili
dovreste iscrivervi alla mailing list debian-security-announce per
ricevere i Debian Security Advisories (DSA). Leggete <ref id="debian-sec-team"> per maggiori informazioni su come lavora la
squadra di Debian security.  Per informazioni su come iscriversi alle
mailing list Debian leggete <url id="http://lists.debian.org">.</p>

<p>
I DSA sono firmati con la chiave del Team di Debian Security che può
essere ottenuta da <url id="http://security.debian.org">.</p>

<p>
Si dovrebbe considerare anche l'iscrizione alla <url 
id="http://lists.debian.org/debian-security" 
name="mailing list debian-security"> per discussioni generali su problemi di 
sicurezza nel sistema operativo Debian.</p>

<p>
FIXME: aggiungere qui la chiave?</p></sect>


<sect id="security-update"><heading>Eseguire un security update</heading>



<p>
Non appena nuovi bug di sicurezza vengono scoperti nei pacchetti, i
manutentori di Debian e gli autori dei programmi generalmente li
correggono in pochi giorni o addirittura ore. Dopo di che il bug è
risolto, un nuovo pacchetto è reso disponibile su 
<url id="http://security.debian.org" name="http://security.debian.org">.</p>

<p>
Se state installando una release Debian bisogna tenere a mente che
potrebbero essere usciti nel frattempo dei security updates da quando
si è scoperto che un dato pacchetto è vulnerabile.  Ci potrebbero essere
comunque delle minor release (ce ne sono state sette in Debian 2.2
<em>potato</em>) che includono questi aggiornamenti dei pacchetti.</p>

<p>
Si deve poi annotare la data in cui i supporti removibili (se li avete
usati) sono stati preparati e controllare il sito di security per
controllare se ci sono stati aggiornamenti. Se ce sono e non potete
scaricare i pacchetti dal sito della sicuezza su un altro sistema (non siete
ancora connessi a Internet?  o si?) prima di connettervi alla rete potreste
pensare (se non siete protetti da un firewall per esempio) di
aggiungere regole al firewall per fare in modo che il sistema si 
possa connettere
solo a security.debian.org e poi eseguire l'aggiornamento.  Una
configurazione di esempio è mostrata 
in <ref id="fw-security-update">.</p>



<p>
<em>Note:</em> a partire da Debian woody 3.0, dopo 
l'installazione si ha l'opportunità di aggiungere al 
sistema gli aggiornamenti di sicurezza.
Rispondendo "yes" a questa domanda, il sistema d'installazione
provvederà ad aggiungere alla sorgente dei pacchetti gli
aggiornamenti di sicurezza del codice sorgente e, se disponete
di un collegamento a Internet, a scaricare e installare gli
aggiornamenti realizzati dopo la creazione del CD
d'installazione. Se state aggiornando una precedente versione
di Debian, o avete chiesto al sistema d'installazione di
non farlo, agite come spiegato più avanti.</p>

<p>
Per aggiornare manualmente il sistema, inserite la seguente 
riga nel vostro <file>sources.list</file> e avrete 
l'aggiornamento dal ramo security updates automaticamente, 
ogni volta che aggiornerete il vostro sistema.

<example>
deb http://security.debian.org/ stable/updates main contrib non-free
</example></p>

<p>Fatto ciò, per l'aggiornamento potete usare
<package>apt</package> o <package>dselect</package>:
<list>
<item>
<p>Se volete usare <package>apt</package> date, da root, il comando:

<example>
# apt-get update
# apt-get upgrade
</example></p></item>

<item>
<p>Se volete usare <package>dselect</package>, prima date il comando 
[U]pdate (aggiorna), quindi [I]nstall (installa) e infine, [C]onfigure
(configura) i pacchetti installati/aggiornati.</p></item>
</list></p>

<p>
Se volete, potete aggiungere anche la riga deb-src a
<file>/etc/apt/sources.list</file>. Vedete in
<manref name="apt" section="8"> per ulteriori dettagli.</p>


<p>Note: Dal momento che security.debian.org è ospitato in una località
non-US e non ha un archivio separato non-US, <em>non</em> c'è bisogno di
aggiungere la seguente linea:

<example>
  deb http://security.debian.org/debian-non-US stable/non-US main contrib non-free
</example></p></sect>


<sect id="bios-boot"><heading>Modificare il BIOS (ancora)</heading>


<p>
Ricordate il paragrafo <ref id="bios-passwd">? Bene,
fatelo ora, se non avete bisogno che l'avvio della macchina avvenga da un
supporto removibile modificate il BIOS della stessa per renderla avviabile 
<em>solamente</em> dall'hard disk. 
Ponete attenzione a non perdere la password del
BIOS, altrimenti in caso di fallimento non potrete entrare nel BIOS e 
cambiare media, ad esempio per avviare da CD-ROM.</p>

<p>
Un altro piccolo accorgimento potrebbe essere quello di cambiare la 
configurazione del
BIOS, permettendo al sistema di partire dall'hard disk e se questo fallisce
provare con un supporto removibile. A proposito, molte 
persone non usano la password per il BIOS ed è quindi facile dimenticarsene.</p></sect>



<sect id="lilo-passwd"><heading>Impostazione della password in LILO o GRUB</heading>




<p>
Chiunque può molto facilmente eseguire il login come root e cambiare la vostra
password digitando 
<tt>&lt;nome-della-vostra-immagine di avvio&gt; init=/bin/sh</tt>
al prompt di boot.
Dopo aver cambiato la password e aver riavviato il sistema, questa persona
ha un accesso illimitato come root e puo impedire l'accesso al sistema.
Con questa procedura, non avrete più l'accesso al sistema come root, perché
non ne conoscete la password.</p>

<p>
Per essere sicuri di evitare di trovarsi in questa situazione dovete 
impostare una password per il
vostro boot loader. Potete scegliere se impostare la password globalmente,
oppure per un'immagine precisa.</p>

<p>
Per LILO occorre modificare il file <file>/etc/lilo.conf</file> 
e aggiungere una <tt>password</tt> e la linea <tt>restricted</tt> 
come nell'esempio seguente.

<example>
  image=/boot/2.2.14-vmlinuz
     label=Linux
     read-only
     password=hackme
     restricted
</example></p>

<p>
Fatto questo, bisogna rieseguire lilo. Omettendo la direttiva 
<tt>restricted</tt> lilo vi inviterà nuovamente ad inserire la password,
nonostante abbiate inserito quella giusta.
I permessi predefiniti per il file <file>/etc/lilo.conf</file> 
garantiscono a root i permessi di scrittura e lettura, mentre danno 
solamente il permesso di lettura di <file>lilo.conf</file> al gruppo root.</p>

<p>
Se al posto di LILO usate GRUB, modificate <file>/boot/grub/menu.lst</file> e
aggiungete le seguenti due linee all'inizio (sostituite <tt>hackme</tt>
con la vostra password). Questo previene che si modifichi la configurazione
di avvio.
La direttiva <tt>timeout 3</tt> istruisce <prgn>grub</prgn> ad attendere 
3 secondi prima di avviare il sistema.

<example>
  timeout 3
  password hackme
</example></p>

<p>
Per conservare l'integrità delle password, si può generare una password
cifrata.Il programma <prgn>grub-md5-crypt</prgn> genera una password 
compatibile con l'algoritmo di cifratura di grub (md5). Per specificare
in <prgn>grub</prgn> che si intende usare il sistema di criptazione md5, 
bisogna usare la seguente direttiva:

<example>
  timeout 3
  password --md5 $1$bw0ez$tljnxxKLfMzmnDVaQWgjP0
</example></p>

<p>
Il parametro --md5, istruisce <prgn>grub</prgn> a usare il processo di 
autenticazione
md5. L'esempio riporta la versione cifrata con md5 della parola hackme.
Usare il metodo di cifratura delle password md5 è preferibile che lasciare 
il testo pienamente leggibile.
Potete trovare altre informazioni sull'uso delle password con 
<prgn>grub</prgn> nel pacchetto <package>grub-doc</package>.</p></sect>




<sect id="kernel-root-prompt"><heading>Rimuovere il prompt root nel kernel</heading>




<p>
I kernel Linux della versione 2.4 forniscono la possibilità di accedere
ad una shell da superutente durante il boot di sistema subito dopo il
caricamento del file system cramfs. Apparirà un messaggio che permetterà
all'amministratore di accedere ad una shell con privilegi di superutente,
questa può essere usata per caricare manualmente i moduli qualora
il riconoscimento automatico fallisca. 
Questo è il comportamento predefinito per gli
<prgn>initrd</prgn> e per <file>linuxrc</file>. 
Apparirà il seguente messaggio:

<example>
  Press ENTER to obtain a shell (waits 5 seconds)
</example></p>

<p>
Per rimuovere questo comportamento dovrete modificare
<file>/etc/mkinitrd/mkinitrd.conf</file> e impostare:

<example>
  # DELAY  The  number  of seconds the linuxrc script should wait to
  # allow the user to interrupt it before the system is brought up
  DELAY=0
</example></p>

<p>
Quindi rigenerare l'immagine del ramdisk. Lo potete fare con:

<example>
  # cd /boot
  # mkinitrd -o initrd.img-2.4.18-k7 /lib/modules/2.4.18-k7
</example></p>

<p>
Oppure (preferito):

<example>
  # dpkg-reconfigure -plow kernel-image-2.4.x-yz
</example></p>

<p>
Notate che Debian 3.0 woody consente agli utenti di installare i kernel
2.4 (selezionare <em>flavors</em>) <em>ma</em> il kernel predefinito è 
il 2.2 (per preservare alcune architetture
su cui il 2.4 non è stato portato). Se lo ritenete un bug prima
di segnalarlo considerate il 
<url id="http://bugs.debian.org/145244" name="Bug 145244">.</p></sect>




<sect id="floppy-boot"><heading>Disabilitare il boot da floppy</heading>




<p>
L' MBR predefinito di Debian prima della versione 2.2 non si comportava
come un normale master boot record e lasciava aperto un metodo per entrare
abusivamente in un sistema:

<list>

<item>
<p>Premete shift durante il boot, apparirà un prompt MBR.</p></item>

<item>
<p>Quindi premete F e il vostro sistema effettuerà l'avvio da
floppy disk. Questo sistema può essere usato per avere un 
accesso da root nel sistema.</p></item>

</list></p>

<p>Questo comportamento può essere modificato digitando:

<example>
  lilo -b /dev/hda
</example></p>

<p>
Adesso LILO è stato inserito nell' MBR. Un altro modo per eseguire
la modifica è quello di inserire 
<tt>boot=/dev/hda</tt> in <file>lilo.conf</file>.
Esiste anche un' altra soluzione che disabiliterà completamente 
il prompt MBR:

<example>
  install-mbr -i n /dev/hda
</example></p>

<p>
D'altro canto, questa "backdoor", di cui molta gente non è a conoscenza,
potrebbe salvarvi la pelle nel caso andaste incontro a grossi problemi
di qualsiasi natura sulla vostra installazione.</p>

<p>
FIXME controllare che sia effettivamente vero sulla 2.2 o era la 2.1?
INFO: I dischi di boot di Debian 2.2 NON installano l'MBR ma solo LILO.</p></sect>



<sect id="restrict-console-login"><heading>Circoscrivere l'accesso alla console</heading>



<p>
Alcune politiche di sicurezza potrebbero forzare l'amministratore ad
autenticarsi nel sistema tramite console con le proprie username e password
e successivamente diventare super utente (tramite 
<prgn>su</prgn> o <prgn>sudo</prgn>).
Questa politica viene implementata in Debian modificando il file
<file>/etc/login.defs</file> oppure <file>/etc/securetty</file> 
se viene utilizzato PAM:

<list>

<item>
<p><file>login.defs</file>, modificando la variabile CONSOLE che definisce un 
file o una lista di terminali su cui è consentito l'accesso come superutente.</p></item>
<item>
<p><file>securetty</file> aggiungendo/rimuovendo i 
terminali su cui sarà consentito l'accesso come root.</p></item>

</list></p>

<p>
Quando viene utilizzato PAM, altre modifiche al processo di
autenticazione, comprese restrizioni a livello utente e gruppo durante
orari prestabiliti, possono essere configurate 
in <file>/etc/pam.d/login</file>.
Un' interessante caratteristica è quella di poter disabilitare
l'autenticazione con password nulle. Questa caratteristica può essere
abilitata rimuovendo <em>nullok</em> dalla linea:

<example>
  auth       required   pam_unix.so nullok
</example></p></sect>



<sect id="restrict-reboots"><heading>Circoscrivere la possibilità di 
riavviare da console</heading>



<p>
Se il vostro sistema ha una tastiera, chiunque (si, <em>chiunque</em>) può
riavviare il sistema senza neanche fare il login. Questo potrebbe o non
potrebbe essere conforme alla vostra policy di sicurezza. Se volete evitarlo,
dovete controllare se nel file <file>/etc/inittab</file> la linea che 
include <tt>ctrlaltdel</tt>
chiama <prgn>shutdown</prgn> con lo switch <tt>-a</tt> 
(ricordatevi di lanciare <tt>init q</tt> dopo
aver apportato qualsiasi modifica a questo file). 
In Debian questo switch è preimpostato:

<example>
  ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
</example></p>

<p>
Ora, per permettere ad <em>alcuni</em> utenti di spengere 
il sistema, come spiega la
pagina man <manref name="shutdown" section="8">, dovete creare il 
file <file>/etc/shutdown.allow</file> e includere
lì i nomi degli utenti che possono fare un reboot. Quando si fa il <em>saluto
delle tre dita</em> (conosciuto anche come <em>ctrl+alt+del</em>) 
il programma controlla
che sia loggato almeno uno degli utenti della lista. Se non ce n'è nemmeno
uno, <prgn>shutdown</prgn> <em>non</em> eseguirà il riavvio.</p></sect>



<sect><heading>Montare le partizioni nel modo giusto</heading>



<p>
Quando si monta una partizione ext2 ci sono diverse opzioni 
aggiuntive che si possono applicare all'invocazione di mount 
o all'<file>/etc/fstab</file>. Per esempio, questa è la riga 
del mio fstab per la partizione <file>/tmp</file>:

<example>
  /dev/hda7    /tmp    ext2    defaults,nosuid,noexec,nodev    0    2
</example></p>

<p>
Potete vedere le differenze nella sezione delle opzioni. 
L'opzione <tt>nosuid</tt> ignora completamente i bit setuid e setgid, 
mentre <tt>noexec</tt> impedisce l'esecuzione di qualsiasi programma 
su quel mount point e <tt>nodev</tt> ignora i device. Sembra fantastico, ma

<list>

<item>
<p>Si applica solo ai filesystem ext2</p></item>
<item>
<p>Può essere facilmente aggirato</p></item>

</list></p>

<p>
l'opzione <tt>noexec</tt> evita l'esecuzione diretta dei file binari, ma viene 
aggirata facilmente:

<example>
  alex@joker:/tmp# mount | grep tmp
  /dev/hda7 on /tmp type ext2 (rw,noexec,nosuid,nodev)
  alex@joker:/tmp# ./date
  bash: ./date: Permission denied
  alex@joker:/tmp# /lib/ld-linux.so.2 ./date
  Sun Dec  3 17:49:23 CET 2000
</example></p>

<p>
Comunque, molti script kiddie hanno exploit che tentano di creare ed eseguire 
file in <file>/tmp</file>. Se non ci riescono, cadranno nel trabocchetto. In altri 
termini, un utente non può essere ingannato ed eseguire un binario 
trojanizzato in <file>/tmp</file>, ad esempio aggiungendo <file>/tmp</file> al suo PATH.</p>

<p>
Siete inoltre avvisati, che l'esecuzione di alcuni script dipende 
dal fatto che <file>/tmp</file> sia eseguibile. In particolare, 
questa cosa riguarda alcuni aspetti di Debconf, per maggiori 
informazioni vedete il Bug 
<url id="http://bugs.debian.org/116448" name="116448">.</p>

<p>
Il seguente è un altro esempio. Una nota: <file>/var</file> può 
essere impostata noexec, ma certo software

<footnote>
<p>Tra questi i programmi Smartlist e <package>dpkg</package>, visto 
che gli script di installazione (post, pre) e di eliminazione (post, 
pre) sono in <file>/var/lib/dpkg/</file></p>
</footnote>

mette i propri eseguibili in <file>/var</file>. Lo stesso 
si applica all'opzione nosuid.

<example>
/dev/sda6       /usr            ext2    defaults,ro,nodev       0       2
/dev/sda12      /usr/share      ext2    defaults,ro,nodev,nosuid        0       2
/dev/sda7       /var            ext2    defaults,nodev,usrquota,grpquota          0       2
/dev/sda8       /tmp            ext2    defaults,nodev,nosuid,noexec,usrquota,grpquota    0       2
/dev/sda9       /var/tmp        ext2    defaults,nodev,nosuid,noexec,usrquota,grpquota    0       2
/dev/sda10      /var/log        ext2    defaults,nodev,nosuid,noexec    0       2
/dev/sda11      /var/account    ext2    defaults,nodev,nosuid,noexec    0       2
/dev/sda13      /home           ext2    rw,nosuid,nodev,exec,auto,nouser,async,usrquota,grpquota                0       2
/dev/fd0        /mnt/fd0        ext2    defaults,users,nodev,nosuid,noexec      0       0
/dev/fd0        /mnt/floppy     vfat    defaults,users,nodev,nosuid,noexec      0       0
/dev/hda        /mnt/cdrom      iso9660 ro,users,nodev,nosuid,noexec            0       0
</example></p>




<sect1><heading>Impostare <file>/tmp</file> come noexec</heading>




<p>
State attenti a impostare <file>/tmp</file> come noexec quando 
volete installare nuovo software,  poiché alcuni programmi 
potrebbero usarla per l'installazione. 
<package>Apt</package> è uno di questi programmi (vedete
<url id="http://bugs.debian.org/116448">) se non è configurata correttamente 
<tt>APT::ExtractTemplates::TempDir</tt> 
(vedete <manref name="apt-extracttemplates" section="1">). 
Potete impostare questa variabile in <file>/etc/apt/apt.conf</file> 
in modo che punti ad un'altra directory 
diversa da <file>/tmp</file> con privilegi di esecuzione.

<!-- This is a duplicate of the example a few paragraphs up --></p>

<p>
Riguardo a noexec, fate attenzione poiché potrebbe non 
offrire tutta questa sicurezza. 
Per esempio:

<example>
  $ cp /bin/date /tmp
  $ /tmp/date
  (does not execute due to noexec)
  $/lib/ld-linux.so.2 /tmp/date
  (works since date is not executed directly)
</example></p></sect1>



<sect1><heading>Impostare /usr in sola lettura</heading>




<p>
Se si imposta <file>/usr</file> in sola lettura non si potrà 
più installare nuovi pacchetti sul proprio sistema Debian GNU/Linux. 
Si dovrà prima rimontarla in lettura-scrittura, installare i pacchetti e poi
rimontarla in sola lettura. L'ultima versione di <package>apt</package> 
(in Debian 3.0 "woody") può essere configurato per eseguire comandi 
prima e dopo l'installazione, così può essere configurato allo scopo.</p>

<p>
Per farlo modificare <file>/etc/apt/apt.conf</file> e aggiungere:  

<example>
  DPkg
  {
      Pre-Invoke  { "mount /usr -o remount,rw" };
      Post-Invoke { "mount /usr -o remount,ro" };
  };
</example></p>

<p>
Notate che Post-Invoke può fallire con un messaggio d'errore "/usr
busy". Questo succede principalmente quando si stanno usando alcuni
file durante l'update che vengono aggiornati. &Egrave; fastidioso 
ma non è un vero problema. 
Appena si è sicuri che non si stanno usando più questi file
si esegua manualmente il Post-Invoke.</p></sect1></sect>




<sect><heading>Fornire un accesso sicuro per gli utenti</heading>

<sect1 id="auth-pam"><heading>Autenticazione degli utenti: PAM</heading>

<p>
PAM (Pluggable Authentication Modules) permette agli amministratori di
sistema di scegliere come le applicazioni autenticano gli utenti. Si
noti che PAM non funziona se un'applicazione non è stata compilata con
il supporto per PAM. Molte delle applicazioni fornite con Debian 2.2
hanno questo supporto integrato. Inoltre Debian non ha il supporto PAM
per versioni precedenti alla 2.2.  L'attuale configurazione predefinita per un
qualsiasi servizio abilitato PAM è di emulare l'autenticazione UNIX
(leggete in
<file>/usr/share/doc/libpam0g/Debian-PAM-MiniPolicy.gz</file> per
ulteriori informazioni su come i servizi PAM <em>dovrebbero</em>
funzionare in Debian).</p>

<p>
Ogni applicazione con supporto PAM ha un file di configurazione
in <file>/etc/pam.d/</file> che può essere usato per modificare 
il suo comportamento:

<list>
<item>
<p>Quale programma sottostante è utilizzato per l'autenticazione.</p></item>
<item>
<p>Quale programma sottostante è utilizzato per le sessioni.</p></item>
<item>
<p>Come si comportano i controlli delle password.</p></item>

</list></p>

<p>
La seguente descrizione è lontana dall'essere completa, per ulteriori
informazioni potete leggere <url id="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam.html" name="The Linux-PAM System Administrator's Guide"> (sul
<url id="http://www.kernel.org/pub/linux/libs/pam/" name="sito primario della distribuzione PAM">),
questo documento è fornito anche dal pacchetto <package>libpam-doc</package>.</p>

<p>

PAM offre la possibilità di passare attraverso diversi fasi di
autenticazione in una volta sola, senza che l'utente se ne accorga. 
Si potrebbe autenticare con un database Berkeley e con un
normale file <file>passwd</file> e l'utente riuscirebbe a loggarsi se
autenticato correttamente da entrambi.  Si possono effettuare molte
restrizioni con PAM, così come spalancare le porte del sistema. Perciò
siate prudenti. 
Una tipica linea di configurazione ha un campo di controllo come secondo
elemento. Generalmente dovrebbe essere impostata a <tt>requisite</tt>, in modo
che ritorni un messaggio di login fallita se un modulo fallisce
nell'autenticazione.

<!-- Second in mine (old Debian v2.0 though), check this! (FIXME) (era) -->
<!-- Lots of fields in mine are "required", please elaborate? (FIXME) (era) --></p>

<p>
La prima cosa che mi piace fare è aggiungere alle applicazioni PAM il 
supporto MD5, poiché ciò protegge da dictionary cracks (le password
possono essere più lunghe se si usa MD5). Le due linee seguenti dovrebbero
essere aggiunte a tutti i file in <file>/etc/pam.d/</file> che forniscono 
un accesso alla macchina, come <tt>login</tt> e <tt>ssh</tt>.

<example>
  # Siate sicuri di aver già installato libpam-cracklib o non si riuscirà a loggarsi
  password   required     pam_cracklib.so retry=3 minlen=12 difok=3
  password   required     pam_unix.so use_authtok nullok md5
</example></p>

<p>
Ma cosa fanno queste linee? La prima carica il modulo PAM cracklib,
che fornisce un controllo sulla qualità delle password, chiede una
nuova password con una lunghezza minima di 12 caratteri, con una
differenza di almeno 3 caratteri da quella vecchia e permette un
massimo di 3 tentativi.  La seconda linea inserisce il modulo standard
di autenticazione con password MD5 e permette password di lunghezza
nulla. La direttiva <tt>use_authtok</tt> è necessaria per il passaggio
della password dal modulo precedente.  Il pacchetto dipende da una
lista di parole (come <package>wenglish</package>,
<package>wspanish</package>, <package>wbritish</package>...), accertatevi
che sia installata quella appropriata per la lingua desiderata
(altrimenti potrebbe non essere affatto utile).

<footnote>
<p>Questa dipendenza, tuttavia, non è corretta nel pacchetto in Debian 3.0.
Vedete il <url id="http://bugs.debian.org/112965" name="Bug #112965">.</p>

</footnote></p>

<p>
Per essere sicuri che l'utente root possa solo loggarsi nel sistema
da terminali locali, si dovrebbe aggiungere in <file>/etc/pam.d/login</file> 
la seguente linea:

<example>
  auth     requisite  pam_securetty.so
</example></p>

<p>
Poi si dovrebbe aggiungere in <file>/etc/security/access.conf</file> i 
terminali dai quali l'utente root può loggarsi nel sistema. 
Ed infine la seguente linea dovrebbe essere aggiunta se si vogliono 
stabilire dei limiti per gli utenti.

<!-- FIXME: This is pam.d/login you're talking about, still? Elaborate? era -->

<example>
  session  required   pam_limits.so
</example></p>

<p>
Questa linea riduce le risorse di sistema che gli utenti possono usare
(si guardi oltre in <ref id="user-limits">). 
Per esempio, si potrebbe ridurre il numero
di login concorrenti (di un certo gruppo di utenti, o globalmente)
ammesse, il numero di processi, la dimensione della memoria...</p>

<p>
Ora aprite  <file>/etc/pam.d/passwd</file> e cambiate la prima riga. Dovreste
aggiungere l'opzione "md5" per usare le password MD5, cambiare la 
lunghezza minima delle password da 4 a 6 (o più) e stabilire una lunghezza
massima, se lo desiderate. La linea che ne risulta dovrebbe essere simile a:

<example>
  password   required   pam_unix.so nullok obscure min=6 max=11 md5
</example></p>

<p>
Se si vuole una protezione per il comando su, in modo che solo alcune
persone possano usarlo per diventare root sul sistema, è necessario
aggiungere un nuovo gruppo "wheel" al sistema (questo è il modo più
pulito, poiché nessun file ha permessi relativi a quel gruppo). Aggiungete
root e  gli altri utenti che dovrebbero poter usare il
comando <prgn>su</prgn> a questo gruppo.  Quindi aggiungete la
seguente linea a <file>/etc/pam.d/su</file>:

<example>
  auth        requisite   pam_wheel.so group=wheel debug
</example></p>

<p>
Questo garantisce che solo le persone del gruppo "wheel" possano usare
<prgn>su</prgn> per diventare root. Gli altri utenti non saranno in grado di 
diventare root. Infatti otterranno un messaggio di errore se cercheranno
di diventarlo.</p>

<p>
Se si vuole che solo certi utenti siano autenticati da un servizio PAM,
ciò è ottenibile abbastanza facilmente usando file contenenti gli utenti
a cui è permesso loggarsi. Immaginate di volere che solo l'utente "ref" 
possa loggarsi tramite <prgn>ssh</prgn>. Allora dovreste inserirlo in 
<file>/etc/sshusers-allowed</file> e scrivere la linea seguente 
in <file>/etc/pam.d/ssh</file>:

<example>
  auth        required    pam_listfile.so item=user sense=allow file=/etc/sshusers-allowed onerr=fail
</example></p>

<p>
Infine, create <file>/etc/pam.d/other</file> e inserite le seguenti linee:

<example>
  auth     required       pam_securetty.so
  auth     required       pam_unix_auth.so
  auth     required       pam_warn.so
  auth     required       pam_deny.so
  account  required       pam_unix_acct.so
  account  required       pam_warn.so
  account  required       pam_deny.so
  password required       pam_unix_passwd.so
  password required       pam_warn.so
  password required       pam_deny.so
  session  required       pam_unix_session.so
  session  required       pam_warn.so
  session  required       pam_deny.so
</example></p>

<p>
Queste linee forniranno una buona configurazione di default per
tutte le applicazioni che supportano PAM (l'accesso è negato
per default).</p></sect1>




<sect1 id="user-limits">
<heading>Limitare le risorse usate: il file <file>limits.conf</file></heading>



<p>
&Egrave; buona norma verificare questo file. Qui si possono 
definire le risorse che un'utente può occupare.
Se si usa PAM, il file <file>/etc/limits.conf</file> è ignorato 
e si dovrà usare invece <file>/etc/security/limits.conf</file>.</p>

<p>
Se non si danno limitazioni alle risorse in uso, <em>ogni</em> utente
con una shell valida sul sistema (oppure anche un qualsiasi intruso che
voglia compromettere il sistema tramite un servizio) può usare tutta la
CPU, la  memoria e lo stack che il sistema può fornire. Il problema
dell'<em>esaurimento delle risorse</em> può essere risolto con l'uso
di PAM.  Notate che esistono dei modi per aumentare i limiti delle
risorse in alcune shell (per esempio, <prgn>bash</prgn> ha
<prgn>ulimit</prgn>, vedete <manref name="bash" section="1">), ma dal
momento che non tutte le shell forniscono gli stessi limiti e visto
che l'utente può cambiare shell (vedete <manref name="chsh" section="1">) è meglio porre dei limiti nei moduli PAM.</p>

<p>
Per maggiori informazioni:

<list>
<item><p><url id="http://www.samag.com/documents/s=1161/sam0009a/0009a.htm" name="PAM configuration article">.</p></item>
<item> <p><url id="http://seifried.org/security/os/linux/20020324-securing-linux-step-by-step.html" name="Seifried's Securing Linux Step by Step (Linux sicuro passo passo"> 
sezione <em>Limiting users overview</em>.</p></item>
<item><p><url id="http://seifried.org/lasg/users/" name="LASG"> sezione 
<em>Limiting and monitoring users</em>.</p></item>

</list></p>

<p>
&Egrave; consigliabile configurare opportunamente il file 
<file>limits.conf</file> come sopra.</p></sect1>




<sect1><heading>Procedura di autenticazione degli utenti: 
modificare <file>/etc/login.defs</file></heading>



<p>
Il prossimo passo è modificare la configurazione di base e le azioni dopo 
l'autenticazione degli utenti.

<example>
  FAIL_DELAY          10
</example></p>

<p>
Questa variabile è preferibile impostarla con un valore alto in modo da
rendere  difficile  l'uso di  un  terminale  per  autenticarsi con  un
attacco a forza bruta. Se una  password viene digitata in modo errato,
il possibile  attaccante (o l'utente) dovranno attendere  10 secondi per
riavere  un nuovo prompt  di autenticazione, questa pausa  può essere
usata  per testare (manualmente) la password. Attenzione, questa
precauzione  è  inutile  se  si  usano altri  programmi  al  posto  di
<prgn>getty</prgn> come ad esempio <prgn>mingetty</prgn>.

<example>
  FAILLOG_ENAB        yes
</example>

Se si abilita questa variabile, la fallita autenticazione sarà riportata 
nei log. Questo è fondamentale per tenere traccia di chiunque provi degli  
attacchi a forza bruta.

<example>
  LOG_UNKFAIL_ENAB    yes
</example></p>

<p>
Se si imposta la variabile  <var>FAILLOG_ENAB</var> su yes , allora si
dovebbe impostare su yes anche questa variabile. Questa registrerà username
sconosciuti  se l'autenticazione  fallisce.  In questo caso, assicuratevi
che i  file di log abbiano gli opportuni  permessi (il 640 ad
esempio,  con un  appropriato gruppo  come l'adm) perché  spesso gli
utenti digitano  casualmente la loro password  come username e
quindi è  consigliabile non permettere  ad altri di  consultare questi
file.

<example>
  SYSLOG_SU_ENAB      yes
</example></p>

<p>
Questo  abiliterà   il  logging  dei   tentativi  di esecuzione del comando 
<prgn>su</prgn> nel  <file>syslog</file>. Questione  molto
importante su una macchina seria ma attenzione che può creare dei
problemi con la privacy.

<example>
  SYSLOG_SG_ENAB      yes
</example></p>

<p>
&Egrave; la stessa di <var>SYSLOG_SU_ENAB</var> ma si 
applica al programma <prgn>sg</prgn>.

<example>
  MD5_CRYPT_ENAB      yes
</example></p>

<p>
Come detto in precedenza, le password di tipo MD5 riducono notevolmente 
il problema di attacchi da dizionario, poiché si possono usare password 
più lunghe. Se state usando slink, si leggete la documentazione di 
MD5 prima di abilitare questa opzione. Altrimenti questa sarà 
regolato in PAM.

<example>
  PASS_MAX_LEN        50
</example></p>

<p>
Se sono attive le password di tipo MD5 nella configurazione PAM, allora 
questa variabile dovrebbe essere impostata con lo stesso valore di cui sopra.</p></sect1>



<sect1><heading>Restrizioni ftp: modificare il file <file>/etc/ftpusers</file></heading>



<p>
Il file <file>/etc/ftpusers</file> contiene  la lista degli utenti che
non  sono  autorizzati ad  autenticarsi  all'host  usando il  servizio
ftp. Solo usando  questo metodo potete autorizzare gli  utenti ad accedere
all'ftp (solitamente questo è  sconsigliato poiché  usa le  password in
chiaro). Se tra i demoni attivi c'è PAM, si può  anche usare questo metodo
per autorizzare o negare agli utenti l'accesso ai servizi.</p>

<p>
FIXME (BUG): Questo è un bug di Debian, di default <em>non</em> include 
negli <file>ftpusers</file> tutti gli utenti amministratori 
(in <package>base-passwd</package>).</p></sect1>



<sect1><heading>Utilizzo di su</heading>



<p>
Se veramente gli utenti hanno la necessità di diventare super user
sul vostro sistema, ad esempio per installare dei pacchetti o
aggiungere utenti, potete utilizzare il comando <prgn>su</prgn> per
cambiare la vostra identità. Si dovrebbe tentare  di evitare ogni
accesso   come   utente   root    e   utilizzare   al   suo   posto
<prgn>su</prgn>. Al  momento, la  soluzione  migliore è  rimuovere
<prgn>su</prgn>   e  passare  a   <prgn>sudo</prgn>,  che   ha  più
possibilità di  <prgn>su</prgn>. Ad ogni modo, <prgn>su</prgn> è più 
comune  visto che è utilizzato su numerosi altri Unix.</p></sect1>



<sect1><heading>Utilizzo di sudo</heading>



<p>
<prgn>sudo</prgn> permette agli utenti di eseguire determinati comandi
sotto l'identità di un altro  utente, perfino come root. Se l'utente é
aggiunto a <file>/etc/sudoers</file> e si autentica correttamente, é
in   grado  di   eseguire   comandi  che   sono   stati  definiti   in
<file>/etc/sudoers</file>. Violazioni, come una password non corretta
o il tentativo di eseguire  un programma non permesso, sono registrati
e notificati via mail a root.</p></sect1>



<sect1><heading>Non permettere accessi per amministrazione remota</heading>



<p>
Si dovrebbe modificare <file>/etc/security/access.conf</file> per
impedire il login da remoto per l'amministrazione. In questo modo gli
utenti devono usare <prgn>su</prgn> (o <prgn>sudo</prgn>)
cosicché rimarrà sempre una traccia che un utente
locale vuole usare i privilegi di amministratore.</p>

<p>
Si deve aggiungere la seguente riga a <file>/etc/security/access.conf</file>, 
il file di configurazione di default di Debian ha una riga simile
commentata:

<example>
   -:wheel:ALL EXCEPT LOCAL
</example></p></sect1>




<sect1 id="user-restrict"><heading>Restrizioni agli utenti per l'accesso</heading>




<p>
A volte si potrebbe pensare di avere la necessità di creare utenti
nel proprio sistema locale per fornire un determinato servizio (pop3
mail o ftp). Prima di fare ciò, ricordate prima che 
l'implementazione di PAM in Debian GNU/Linux permette di validare
utenti con un'ampia varietà di servizi di directory esterni (radius,
ldap, ecc.) forniti dai pacchetti libpam.</p>

<p>
Se gli utenti devono essere creati ed è possibile accedere al sistema
da remoto tenete presente che gli utenti potranno effettuare il
login nel sistema. Potete rimediare a questo assegnando agli utenti una
shell vuota (<file>/dev/null</file>) (dovrebbe essere nella lista di
<file>/etc/shells</file>). Se volete permettere agli utenti di
accedere al sistema limitando i loro movimenti, potete utilizzare
<file>/bin/rbash</file>, equivalente ad aggiungere l'opzione
<tt>-r</tt> a <prgn>bash</prgn> (<em>RESTRICTED SHELL</em>, vedete
<manref name="bash" section="1">). Notate che persino con una
shell ristretta, un utente che accede a un programma interattivo (che
potrebbe permettere l'esecuzione di una sotto shell) potrebbe aggirare
i limiti della shell.</p>

<p>
Debian attualmente fornisce nella versione unstable (e dovrebbe essere
incluso nelle prossime versioni stabili) il modulo
<file>pam_chroot</file> (in <package>libpam-chroot</package>). Un'alternativa 
è usare <prgn>chroot</prgn> sul servizio che fornisce il
login remoto (<prgn>ssh</prgn>, <prgn>telnet</prgn>).

<footnote>
<p><package>Libpam-chroot</package> non è ancora stato testato in maniera
approfondita, funziona per <prgn>login</prgn> ma potrebbe non essere 
semplice configurare un ambiente per altri programmi.</p>

</footnote></p>

<p>
Se si desidera limitare il <em>quando</em> gli utenti possono accedere il
sistema si dovrà configurare <file>/etc/security/access.conf</file> per i 
propri bisogni.</p>

<p>
Informazioni su come ingabbiare con <prgn>chroot</prgn> gli utenti che 
accedono al sistema attraverso il servizio <prgn>ssh</prgn> è descritto 
in <ref id="chroot-ssh-env">.</p></sect1>



<sect1><heading>Verifica manuale degli utenti</heading>



<p>
Se siete paranoici potreste voler aggiungere un <file>/etc/profile</file> di
sistema che imposti l'ambiente in modo che gli utenti non possano
rimuovere le capacità di verifica dalla shell (i comandi sono scritti
in <tt>$HISTFILE</tt>). Il file <file>/etc/profile</file> dovrebbe essere 
impostato come segue:

<example>
  HISTFILE=~/.bash_history
  HISTSIZE=100000000000000000
  HISTFILESIZE=10000000000000000
  readonly HISTFILE
  readonly HISTSIZE
  readonly HISTFILESIZE
  export HISTFILE HISTSIZE HISTFILESIZE
</example></p>

<p>
Perché questo funzioni, l'utente può solo aggiungere informazioni al
<file>.bash_history</file>. Dovete <em>anche</em> impostare l'opzione 
<em>append-only</em> usando il programma <prgn>chattr</prgn> a 
<file>.bash_history</file> per tutti gli utenti.

<footnote>
<p>Senza il flag append-only gli utenti sarebbero in grado di
svuotare il contenuto del file di history eseguendo 
<prgn> >.bash_history</prgn>.</p>

</footnote>.</p>

<p>
Notate che si potrebbe fare ciò per il <file>.profile</file> di ciascun utente.
Ma poi dovreste impostare i permessi correttamente: con le home
directory degli utenti che <em>non</em> appartengano a loro ma abilitare gli
utenti a leggere la configurazione in <file>.profile</file> e scrivere in
<file>.bash_history</file>. Potrebbe essere buona cosa impostare il flag
<em>inmutable</em> 
(sempre usando <prgn>chattr</prgn>) per <file>.profile</file> 
anche se si procede in questo modo.</p>

<p>
Se siete completamente paranoici e volete controllare ogni comando
dell'utente, potete prendere il codice sorgente di <prgn>bash</prgn> e
modificarlo perché registri tutto ciò che l'utente scrive su un altro
file. O avere <package>ttysnoop</package> che costantemente monitora 
ogni nuova tty <footnote>I tty sono eseguiti per ogni login locale e remoto 
attraverso telnet o ssh</footnote> e scrive l'output in un file. Un altro programma utile è 
<package>snoopy</package> che è trasparente all'utente e si insinua come una libreria
fornendo un wrapper per le chiamate <var>execve()</var>, ogni comando eseguito 
é registrato con <prgn>syslogd</prgn> usando la direttiva <tt>authpriv</tt>
(solitamente registrato in <file>/var/log/auth.log</file>).</p> 

<p>
Notate che non si può usare il comando <prgn>script</prgn> per questo poiché
non funzionerà come shell (perfino se lo si aggiunge in
<file>/etc/shells</file>).</p></sect1>



<sect1><heading>Esame completo degli utenti</heading>



<p>
L'esempio precedente è un modo semplice per configurare l'esame degli
utenti ma potrebbe essere di dubbia utilità nei sistemi complessi. Se
è il vostro caso, dovete dare un'occhiata a <package>acct</package>, 
le utility per
l'accounting. Queste utility registreranno tutti i comandi impartiti
dagli utenti a spese dello spazio su disco.</p>

<p>
Quando si attiva l'accounting, tutte le informazioni sui processi e
gli utenti sono mantenute sotto <file>/var/account/</file>, più specificamente
in <file>pacct</file>. Il pacchetto di accounting include degli 
strumenti (<prgn>sa</prgn> e <prgn>ac</prgn>) per analizzare questi dati.</p></sect1>



<sect1><heading>Uno sguardo ai profili utente</heading>



<p>
Se volete <em>vedere</em> cosa facciano solitamente gli utenti, quando si
connettono potete usare il database <file>wtmp</file> che include tutte le
informazioni di login. Il file può essere processato con diverse
utility, tra cui <prgn>sac</prgn> che può restituire un profilo per ogni utente
che mostra in quale arco di tempo solitamente si connettono.</p>

<p>
Nel caso in cui abbiate attivato l'accounting, potete anche utilizzare
gli strumenti da esso forniti per determinare quando gli utenti
accedono al sistema e cosa eseguano.</p></sect1>



<sect1><heading>Impostare delle umask per gli utenti</heading>



<p>
In base alla vostra linea di condotta riguardo agli utenti, potreste
voler cambiare il modo in cui gli utenti si scambiano informazioni,
ossia quali siano i permessi predefiniti dei nuovi file creati dagli
utenti. Questo viene fatto impostando una propria <tt>umask</tt> per
ogni utente. Potete cambiare l'impostazione <var>UMASK</var> in
<file>/etc/limits.conf</file>, <file>/etc/profile</file>,
<file>/etc/csh.cshrc</file>, <file>/etc/csh.login</file>,
<file>/etc/zshrc</file> e probabilmente anche altri (a seconda delle
shell che avete installato sul vostro sistema). Di tutti questi,
l'ultimo ad essere caricato ottiene la precedenza. L'ordine è: il
<file>limits.conf</file> di PAM, la configurazione standard di
sistema per la shell utente, la shell utente (i suoi
<file>~/.profile</file>, <file>~/.bash_profile</file>...)</p>

<p>
L'impostazione predefinita di Debian per l'<tt>umask</tt> è <em>022</em> 
che significa
che i file (e le directory) possono essere letti e visitati dai
membri del gruppo dell'utente e da qualsiasi altro utente nel
sistema. Se questo risultasse troppo permissivo per il vostro sistema,
dovrete cambiare le impostazioni dell'umask per tutte le shell (e per il
PAM). Non dimenticatevi di modificare i file sotto <file>/etc/skel/</file> 
poiché saranno questi i nuovi default degli utenti creati con il comando
<prgn>adduser</prgn>.</p>

<p>
Da notare, comunque, che gli utenti possono modificare la loro <tt>umask</tt>
se lo vogliono, rendendola più permissiva o più restrittiva.</p></sect1>



<sect1><heading>Porre limiti a ciò a cui gli utenti possono accedere</heading>



<p>
FIXME. Spiegare le conseguenze del cambiare i permessi dei
pacchetti quando si aggiornano (ed un admin paranoico dovrebbe mettere in
<prgn>chroot</prgn> i suoi utenti, comunque).</p>  

<p>
Se dovete dare accesso shell
agli utenti, pensateci bene. Un utente, a meno che non sia in un
ambiente pieno di restrizioni (come una prigione <tt>chroot</tt>), può
carpire molte informazioni sul sistema, tra cui:



<list>

<item>
<p>Alcuni file di configurazione in <file>/etc</file>. 
Comunque i permessi di default per file
contenenti informazioni sensibili, in Debian (per esempio file
contenenti password), prevengono l'accesso a informazioni critiche. Per vedere
quali file sono accessibili solo da root basta un 
<tt>find /etc -type f -a -perm 600 -a -uid 0</tt> eseguito da superuser.</p></item>
<item>
<p>I pacchetti installati, sia guardando il database dei pacchetti in
<file>/usr/share/doc</file> o tirando a indovinare guardando gli 
eseguibili e le librerie.</p></item>
<item>
<p>Alcuni file di log in <file>/var/log</file>. Notate inoltre che alcuni file di
log sono accessibili solo da root e dal gruppo <tt>adm</tt> (provate un
<tt>find /var/log -type f -a -perm 640</tt>) e alcuni sono perfino
disponibili solo a root (provate un 
<tt>find /var/log -type f -a -perm 600 -a -uid 0</tt>).</p></item>

</list></p>

<p>
Cosa può visualizzare un utente nel vostro sistema? Probabilmente un
sacco di cose, provate questo (fate un respiro profondo):

<example>
  find / -type f -a -perm +006 2>/dev/null  
  find / -type d -a -perm +007 2>/dev/null  
</example></p>

<p>
L'output è la lista dei file che un utente può <em>vedere</em> e le
directory a cui ha accesso.</p>



<sect2 id="limit-user-perm"><heading>Limitare l'accesso alle 
informazioni di altri utenti</heading>


<p>
Se permettete l'accesso tramite shell da parte degli utenti potrebbe
essere desiderabile limitare quali informazioni di altri utenti possano
vedere. Gli utenti con accesso alla shell tendono a creare un gran numero
di file nella loro $HOME: caselle di posta, documenti 
personali, configurazioni di applicazioni per X/GNOME/KDE...</p>

<p>
In Debian ogni utente è creato con un gruppo associato e due utenti
non appartengono mai allo stesso gruppo. Questo è il comportamento predefinito:
quando l'utente X viene creato, un gruppo di nome X viene creato e l'utente è
assegnato ad esso. Questo evita il concetto di gruppo di <em>utenti</em>
che renderebbe più difficile per gli utenti nascondere informazioni agli
altri.</p>

<p>
Tuttavia, le directory <var>$HOME</var> degli utenti sono create con permessi
0755 (leggibili dal gruppo e da tutti gli altri). I permessi di gruppo
non sono un problema perché solo l'utente appartiene a quel gruppo,
ma i permessi globali potrebbero (ma anche no) essere un problema,
in relazione alle scelte locali.</p>

<p>
Questo comportamento può essere cambiato in modo che la creazione di
un utente fornisca permessi diversi su <var>$HOME</var>. 
Per cambiare il comportamento
per i <em>nuovi</em> utenti quanto sono creati, nel file di configurazione
<file>/etc/adduser.conf</file> cambiate 
<em>DIR_MODE</em>in 0750 (nessun permesso globale).</p>

<p>
Gli utenti possono ancora condividere informazioni, ma non direttamente
nelle loro directory <var>$HOME</var>, a meno che non cambino i loro permessi.</p>

<p>
Notate che questo impedirà agli utenti di creare la loro 
pagina web personale (<file>~utenteX</file>) se è installato un web server, 
poiché quest'ultimo non sarà in grado di leggere la directory 
<var>$HOME</var> e di conseguenza neanche la directory sottostante 
<file>public_html</file>.
Se volete permettere agli utenti di pubblicare pagine HTML nei loro
<file>~userX/public_html</file>, modificate <em>DIR_MODE</em> per avere
permessi 0751. Questo consentirà al server web di accedere a quella directory
(che dovrebbe avere permessi 0755) e fornire il contenuto pubblicato 
dagli utenti.</p></sect2></sect1>



<sect1 id="user-pwgen"><heading>Generare password per gli utenti</heading>



<p>
Ci sono molti casi in cui un amministratore ha necessità di creare
molti account e di fornire password per ognuno di essi. Ovviamente
l'amministratore potrebbe semplicemente scegliere come password il
nome scelto dall'utente per l'account, ma ciò non sarebbe molto furbo
per quanto riguarda la sicurezza. Un approccio migliore consiste nell'usare
un programma per generare password. Debian offre i 
pacchetti <package>makepasswd</package>,
<package>apg</package> e <package>pwgen</package>, 
che forniscono programmi (con nome uguale a quello del
pacchetto) che possono essere usati per questo scopo. <prgn>Makepasswd</prgn>
genererà password totalmente casuali, con enfasi sulla sicurezza piuttosto
che sulla pronunciabilità, mentre <prgn>pwgen</prgn> 
cercherà di creare password senza
senso ma pronunciabili (ovviamente questo dipende dalla lingua madre).
<prgn>Apg</prgn> ha algoritmi per entrambi 
(per questo programma esiste una versione
client/server ma non è inclusa nel pacchetto Debian).</p>

<p>
<prgn>Passwd</prgn> non permette assegnamento non interattivo di password
(poiché usa direttamente l'accesso tty). Se volete cambiare password
mentre state creando un gran numero di utenti, potete creare quest'ultimi
usando <prgn>adduser</prgn> con l'opzione <tt>--disabled-login</tt> e 
poi usando <prgn>chpasswd</prgn>

<footnote>
<p><prgn>Chpasswd</prgn> non può gestire la generazione 
di password MD5, quindi necessita della password in 
forma crittata prima di usarlo, con l'opzione <tt>-e</tt>.</p>
</footnote>

(incluso nel pacchetto <package>passwd</package>, 
che è già installato). Se si vuole
usare un file contenente tutte le informazioni 
per creare gli utenti come un processo batch può 
essere utile usare <prgn>newusers</prgn>.</p></sect1>



<sect1><heading>Controllare le password degli utenti</heading>



<p>
Le password degli utenti possono talvolta diventare il <em>componente più
debole</em> nella sicurezza di un sistema. Ciò è dovuto alla scelta da parte
degli utenti di password di scarsa qualità per i loro account (e più utenti
hanno accesso più le possibilità che questo accada crescono). Anche se
sono stati impostati controlli con il modulo PAM cracklib e limiti descritti
nella <ref id="auth-pam"> gli utenti saranno comunque
in grado di usare password deboli. Poiché l'accesso per gli utenti potrebbe
includere accesso da shell remote (si spera tramite <prgn>ssh</prgn>) 
è importante che
una persona che attacchi il sistema da remoto non sia in grado di indovinare
le password degli utenti (dopo aver ottenuto la lista degli utenti con altri
mezzi).</p>

<p>
Un amministratore di sistema deve, ipotizzando un gran numero di utenti,
controllare se le password scelte sono consistenti con le scelte di sicurezza
locali. Come effettuare questo controllo? Provando a forzarle come farebbe
una persona che attacca il sistema se avesse accesso alle password crittate
(il file <file>/etc/shadow</file>).</p>

<p>
Un amministratore di sistema può usare <package>john</package> o
<package>crack</package> (entrambi sono
crackatori di password brute force) insieme ad una appropriata lista
di parole

<footnote>
<p>Provate <prgn>apt-cache search wordlist</prgn> per ottenere 
una lista di pacchetti disponibili che potrebbero fornire 
liste di parole. Queste, inoltre, possono essere scaricate da 
molti siti ftp su Intenet. Vedete
<url id="ftp://ftp.ox.ac.uk/pub/wordlists"> o
<url id="ftp://ftp.cerias.purdue.edu/pub/dict">.</p>
</footnote>

per controllare le password degli utenti e prendere provvedimenti
appropriati quando si trova una password debole.</p></sect1>



<sect1 id="idle-logoff"><heading>Disconnettere gli utenti inattivi</heading>



<p>
Solitamente gli utenti inattivi sono un problema per la sicurezza.
Un utente potrebbe essere inattivo perché è fuori a pranzo o perché
una connessione remota interrotta non è stata ristabilita.
Qualunque sia la ragione, gli utenti inattivi possono essere causa
di problemi:

<list>
<item>
<p>Perché la console dell'utente potrebbe non essere bloccata e
un intruso potrebbe accedervi.</p></item>
<item>
<p>Perché un attaccante potrebbe riuscire a riconnettersi ad
una connessione di una rete chiusa e eseguire comandi sulla
shell remota (questo è abbastanza facile se la shell
remota non è crittata come nel caso di <prgn>telnet</prgn>).</p></item>

</list></p>

<p>
Alcuni sistemi remoti sono stati compromessi attraverso uno
<prgn>screen</prgn> inattivo (distaccato).</p> 

<p>
La disconnessione automatica degli utenti inattivi di solito è una
parte della politica di sicurezza che occorre rafforzare. Ci sono
molti modi per realizzarla:

<list>
<item>
<p>Se la shell degli utenti è <prgn>bash</prgn>, l'amministratore di sistema
può impostare un valore di default per la variabile <tt>TMOUT</tt>
(vedete <manref name="bash" section="1">) che fa sì che la shell disconnetta
automaticamente gli utenti inattivi. Notate che la variabile
va impostata con l'opzione <tt>-o</tt> altrimenti gli utenti saranno
in grado di modificarla o rimuoverla.</p></item>
<item>
<p>Installare <package>timeoutd</package> e configurare 
<file>/etc/timeouts</file> secondo la
propria politica di sicurezza locale. Il demone controllerà
se ci sono utenti inattivi e manderà in time out le loro shell
secondo la configurazione impostata.</p></item>
<item>
<p>Installare <package>autolog</package> e configurarlo per disconnettere gli
utenti inattivi.</p></item>

</list></p>

<p>
I demoni <prgn>timeoutd</prgn> e <prgn>autolog</prgn> sono i 
metodi consigliati, dal momento che gli utenti possono 
cambiare la loro shell di default o passare ad un'altra 
shell (non controllata) dopo aver avviato la
loro shell predefinita.</p></sect1></sect>



<sect><heading>Usare i tcpwrapper</heading>



<p>
I TCP wrapper sono stati sviluppati quando ancora non erano
disponibili dei veri filtri di pacchetti ed era necessario
controllare gli accessi. I TCP wrapper permettono di consentire o
negare un servizio ad un host o ad un dominio e di definire una
regola predefinita per consentire o meno l'accesso.
Se desiderate maggiori informazioni al riguardo, date
un'occhiata a <manref name="hosts_access" section="5">.</p>

<p>
Molti servizi installati in Debian sono:

<list>

<item>
<p>Lanciati mediante un servizio tcpwrapper (<file>tcpd</file>)</p></item>
<item>
<p>Compilati con il supporto a libwrapper integrato.</p></item>

</list></p>

<p>
In un caso, per i servizi configurati in <file>/etc/inetd.conf</file>
(inclusi <prgn>telnet</prgn>, <prgn>ftp</prgn>, 
<prgn>netbios</prgn>, <prgn>swat</prgn> e <prgn>finger</prgn>) si può
notare che il file di configurazione esegue prima <prgn>/usr/sbin/tcpd</prgn>.
Nell'altro, anche se il servizio è lanciato dal superdemone
<prgn>inetd</prgn>, il supporto per le regole dei tcp wrapper può essere
compilato al suo interno. In Debian, tra i servizi compilati con il
supporto ai tcp wrapper ci sono 
<prgn>ssh, portmap, in.talk, rpc.statd, rpc.mountd, gdm, oaf</prgn> 
(il demone di attivazione GNOME), <prgn>nessus</prgn> e
molti altri.</p>

<p>
Per vedere quali pacchetti usano i tcpwrapper provate con:

<example>
  $ apt-cache showpkg libwrap0 | egrep '^[[:space:]]' | sort -u | \
        sed 's/,libwrap0$//;s/^[[:space:]]\+//'
</example></p>

<p>
Occorre tenerne conto quando si usa <prgn>tcpchk</prgn>. 
I servizi compilati col supporto alla libreria wrapper 
possono essere aggiunti ai file <file>hosts.deny</file> e 
<file>hosts.allow</file> ma <prgn>tcpchk</prgn> avviserà che non è in
grado di trovare questi servizi, perché li cerca in
<file>/etc/inetd.conf</file> (la manpage non è molto 
chiara su questo punto).</p>

<p>
Di seguito riportiamo un trucchetto; probabilmente il più piccolo
sistema di rivelazione di intrusione possibile. In generale 
dovreste avere una buona politica di firewall come prima linea di difesa ed i
tcp wrapper come seconda linea. Un trucchetto è quello di
impostare un comando <var>SPAWN</var> 

<footnote>
<p>Assicurarsi di usare il maiuscolo altrimenti <em>spawn</em> 
non funzionerà</p>

</footnote> 

in <file>/etc/hosts.deny</file> che spedisce
una mail all'utente root ogni volta che un servizio viene negato
attraverso i wrapper:

<example>
  ALL: ALL: SPAWN ( \
    echo -e "\n\
    TCP Wrappers\: Connection refused\n\
    By\: $(uname -n)\n\
    Process\: %d (pid %p)\n\
    User\: %u\n\
    Host\: %c\n\
    Date\: $(date)\n\
  " | /usr/bin/mail -s "Connection to %d blocked" root) &
</example></p>

<p>
<em>Attenzione</em>: L'esempio sopra è esposto a attacchi di tipo DoS
stabilendo molte connessioni in un breve periodo di tempo. Molte
email causano un elevato I/O di file spedendo solo pochi pacchetti.

<!--
# Could this example be more interesting? 
# It also relates to the next section (jfs)
#
# era: cf hosts_access(5) manual page,
# and why are you not using logger(1) here? (FIXME?)
#
#&lt;example&gt;
#ALL: ALL: SPAWN ( \
#  /usr/local/sbin/send_syslog %u %c %d )
#&lt;example&gt;

#  With send_syslog as:
##!/usr/bin/perl -w
#
#use Sys::Syslog qw(:DEFAULT setlogsock);
#
#$user=shift(@ARGV) || 'unknown';
#$host=shift(@ARGV) || 'unknown';
#$service=shift(@ARGV) || 'unknown';
#setlogsock('unix');
#openlog("alert",'', 'user');
#syslog('warning', 'Connection from %s at %s to %s blocked.', ($user, $host, $service) );
#closelog();
#
#exit 0;
--></p></sect>



<sect id="log-alerts"><heading>L'importanza di log e avvisi</heading>



<p>
&Egrave; evidente che il modo di trattare log e avvisi è una questione
importante in un sistema sicuro. Supponiamo che un sistema sia
perfettamente configurato e sicuro al 99%. Se viene portato un attacco
al restante 1% e non ci sono misure di sicurezza pronte, innanzitutto a
rilevarlo e poi ad attivare allarmi, il sistema non è per
nulla sicuro.</p>

<p>
Debian GNU/Linux fornisce alcuni strumenti per svolgere l'analisi
dei log, in particolare <package>swatch</package>, 

<footnote>

<p>C'è un ottimo articolo in proposito scritto da
<url id="http://www.enteract.com/~lspitz/swatch.html" name="Lance Spitzner"></p>

</footnote>
<package>logcheck</package> o <package>log-analysis</package>
(tutti questi avranno bisogno di un po' di personalizzazione per
rimuovere le cose superflue dal rapporto). Potrebbe anche essere
utile, se il sistema si trova nelle vicinanze, avere i log di sistema
stampati su una console virtuale. Questo è utile perché si può (da
lontano) vedere se il sistema sta funzionando correttamente. In
Debian, il file <file>/etc/syslog.conf</file> ha già in partenza una
configurazione predefinita commentata; per abilitarla, togliete i
commenti dalle linee e riavviate <prgn>syslogd</prgn> 
(<tt>/etc/init.d/syslogd restart</tt>):

<example>
  daemon,mail.*;\
        news.=crit;news.=err;news.=notice;\
        *.=debug;*.=info;\
        *.=notice;*.=warn       /dev/tty8
</example>

<!-- FIXME: Talk about logcolorise? Is it in Debian? --></p>

<p>
C'è molto altro a proposito dell'analisi dei log che non può
essere trattato qui, una buona fonte di informazioni sono le 
<url id="http://www.counterpane.com/log-analysis.html" name="Risorse sull'analisi dei log di Counterpane">.
In ogni caso, anche gli strumenti automatizzati nulla possono 
contro il miglior strumento di analisi: il vostro cervello.

<!-- FIXME: Check information on SHARP, the 'syslog heuristic analysis
and response program'. The paper is at
http://www.csis.gvsu.edu/sharp/. Is it free-software? packaged? --></p>



<sect1 id="custom-logcheck"><heading>Usare e personalizzare <prgn>logcheck</prgn></heading>



<p>
Il pacchetto <prgn>logcheck</prgn> in Debian è diviso in due parti:
<prgn>logcheck</prgn> (il programma vero e proprio) e 
<package>logcheck-database</package> (un
database di espressioni regolari per il programma). In Debian è
predefinito (in <file>/etc/cron.d/logcheck</file>) che 
<prgn>logcheck</prgn> venga eseguito giornalmente alle 2 AM 
e una volta dopo ogni riavvio.</p>

<p>
Questo strumento, se propriamente configurato, può essere molto utile
per segnalare all'amministratore gli eventi inusuali del sistema.
<prgn>Logcheck</prgn> può essere completamente personalizzato in modo
da mandare mail a proposito di eventi registrati nei log che sembrano
degni di attenzione. L'installazione predefinita include profili (per
gli eventi da ignorare e le violazioni delle politiche adottate)
per tre diverse configurazioni (workstation, server e paranoide). Il
pacchetto Debian include un file di configurazione
<file>/etc/logcheck/logcheck.conf</file>, generato dal
programma, che definisce a quale utente vengono spedite le
verifiche. Inoltre fornisce, ai pacchetti che offrono servizi, un modo
per implementare nuove politiche nelle cartelle:
<file>/etc/logcheck/hacking.d/_packagename_</file>,
<file>/etc/logcheck/violations.d/_packagename_</file>,
<file>/etc/logcheck/violations.ignore.d/_packagename_</file>,
<file>/etc/logcheck/ignore.d.paranoid/_packagename_</file>,
<file>/etc/logcheck/ignore.d.server/_packagename_</file> e
<file>/etc/logcheck/ignore.d.workstation/_packagename_</file>.
Tuttavia, al momento, non molti pacchetti ne fanno uso. Se avete una
politica che può essere utile ad altri utenti, per favore speditela
come rapporto bug per il pacchetto appropriato (come <em>wishlist</em>
bug). Per ulteriori informazioni leggere
<file>/usr/share/doc/logcheck/README.Debian</file>.</p>

<p>
Il miglior modo di configurare <prgn>logcheck</prgn> è installarlo
(chiederà a quale utente spedire i rapporti e genererà
<file>/etc/logcheck/logcheck.logfiles</file> dalle voci di syslog). Se
si desidera aggiungere nuovi file di log, aggiungerli in
<file>/etc/logcheck/logcheck.logfiles</file>. Le dipendenze dei
pacchetti forzeranno anche l'installazione di
<package>logcheck-database</package>; durante l'installazione verrà
chiesto il livello di sicurezza desiderato: workstation, server o
paranoia. Questo farà sì che <file>/etc/logcheck/ignore.d</file> punti
alle cartelle appropriate (per mezzo di collegamenti simbolici). Per
modificare ciò eseguire <tt>dpkg-reconfigure -plow
logcheck-database</tt>. Poi, creare <file>/etc/ignore.d/local</file>;
questo file conterrà tutte le regole per escludere i messaggi che non
dovrebbero essere riportati. Per il momento, lasciatelo vuoto (un
semplice <tt>cp /dev/null /etc/ignore.d/local</tt> sarà sufficiente).</p>

<p>
Una volta fatto questo, forse vorrete controllare per i primi
giorni/settimane/mesi le email che vengono spedite. Se vengono spediti
messaggi che non desiderate ricevere, aggiungete le espressioni
regolari (vedete <manref name="regex" section="7">) 
che corrispondono a questi messaggi in
<file>/etc/ignore.d/local</file>. &Egrave; un processo di 
taratura al quale si deve
dedicare il tempo necessario; Quando i messaggi spediti saranno
sempre rilevanti la messa a punto potrà considerarsi conclusa. Notate
che, anche se <prgn>logcheck</prgn> è in esecuzione, se  non trova nulla di
rilevante nel sistema non spedirà email (così potrete ricevere un solo
messaggio a settimana, con un po' di fortuna).</p></sect1>



<sect1><heading>Configurare il file dove vengono spediti gli avvisi</heading>



<p>
Debian nasce con una configurazione standard per <tt>syslog</tt> (in 
<file>/etc/syslog.conf</file>) che registra i messaggi in file appropriati a
seconda della configurazione del sistema. Dovreste avere
dimestichezza con questo; date un'occhiata al file <file>syslog.conf</file>
e alla documentazione. Se intendete mantenere un sistema sicuro dovreste
fare attenzione a dove i messaggi di log vengono spediti
cosicché non passino inosservati.</p>

<p>
Per esempio, mandare i messaggi su una console è una configurazione
utile per sistemi di diversi livelli di produzione. Ma per altri
sistemi è ugualmente importante aggiungere una nuova macchina che
faccia da loghost (cioè riceva i log da tutte le altre macchine del
sistema).</p>

<p>
Si dovrebbe considerare anche la posta di root, molti programmi per
il controllo della sicurezza (come <package>snort</package>) mandano 
gli avvisi a root via posta. 
Questa mailbox di solito punta al primo utente creato nel
sistema (controllare <file>/etc/aliases</file>). Preoccupatevi di mandare la
posta di root in qualche posto dove verrà letta (localmente o
remotamente).</p>

<p>
Ci sono altri account di ruolo ed alias nel tuo sistema. In un piccolo
sistema é, probabilmente, più facile far sì che tutti gli alias
puntino a root e che la posta di root venga inoltrata alla casella
personale dell'amministratore di sistema.</p>

<p>
FIXME: sarebbe interessante spiegare come un sistema Debian possa
spedire/ricevere SNMP traps riguardanti problemi di sicurezza (jfs).
Controllare: <package>snmptraglogd</package>, <package>snmp</package> 
e <package>snmpd</package>.</p></sect1>



<sect1><heading>Usare un loghost</heading>



<p>
Un loghost è un host che raccoglie i dati di syslog remoti dalla
rete. Se una delle vostre macchine viene compromessa, l'intruso non
é in grado di coprire le sue tracce, a meno che non penetri anche
nella macchina loghost. Perciò, il loghost dovrebbe essere
particolarmente sicuro. Rendere una macchina un loghost è semplice.
Basta avviare <prgn>syslogd</prgn> con <tt>syslogd -r</tt> e un 
nuovo loghost è nato.
Perché questa azione sia permanente, in Debian, modificate
<file>/etc/init.d/sysklogd</file> e cambiate la riga

<!-- FIXME: The following could also be interesting -->
<!-- How to hide the logging server on the network i.e. by not giving -->
<!-- it an IP address and adding a static ARP entry on the hosts using -->
<!-- the remote syslog server (only if on the same hub); if the remote -->
<!-- syslog server would be on a separate network, the default gateway -->
<!-- should be configured accordingly -->

<example>
  SYSLOGD=""
</example>
in 
<example>
  SYSLOGD="-r"
</example>

Successivamente, configurate le altre macchine perché spediscano i
dati al loghost. Aggiungete una riga simile alla seguente al file 
<file>/etc/syslog.conf</file>:

<example>
  facility.level            @your_loghost
</example></p>

<p>
Guardate la documentazione per cosa usare al posto di <em>facility</em> e
<em>level</em> (non dovrebbero contenere queste parole). Se volete
registrare ogni cosa remotamente, scrivete:

<example>
  *.*                       @your_loghost
</example>

nel vostro <file>syslog.conf</file>. La registrazione dei log sia remota che
locale è la migliore soluzione (l'attaccante potrebbe pensare di aver
coperto le sue tracce dopo la cancellazione dei log locali). Vedete
la pagine di manuale di <manref name="syslog" section="3">, 
<manref name="syslogd" section="8"> e <manref name="syslog.conf" section="5"> 
per ulteriori informazioni.</p></sect1>



<sect1><heading>Permessi dei file di log</heading>



<p>
Non è solo importante decidere come gli vengono usati gli avvisi, ma anche
chi ha accesso in lettura/modifica dei file di log (se non si usa un
loghost remoto). Gli avvisi di sicurezza che l'attaccante può cambiare
o disabilitare non sono il peggiore danno di un'intrusione. Infatti,
dovete tenere a mente che questi file di log possono rivelare molte
informazioni riguardo il proprio sistema ad un attaccante che ne
abbia libera lettura.

<!--  It should be explained why after installation this is not
 already done, jfs --></p>

<p>
Alcuni permessi sui file di log non sono perfetti dopo una
installazione (ma questo ovviamente dipende dalla propria politica di
sicurezza locale). Per prima cosa <file>/var/log/lastlog</file> e 
<file>/var/log/faillog</file> non necessitano di essere letti dagli utenti
normali. Nel file <file>lastlog</file> potete vedere chi ha effettuato un login
recentemente e in <file>faillog</file> potete vedere un riassunto dei login
falliti. L'autore raccomanda <prgn>chmod 660</prgn> per entrambi. Date una
rapida occhiata ai vostri file di log e decidete molto attentamente
quali rendere leggibili/scrivibili per utenti con UID diversi da 0 e
gruppi che non siano "adm" o "root". Si può facilmente controllare
quanto descritto nel proprio sistema con:

<example>
  #  find /var/log -type f -exec ls -l {} \; | cut -c 17-35 |sort -u
  (see to what users do files in /var/log belong)
  #  find /var/log -type f -exec ls -l {} \; | cut -c 26-34 |sort -u
  (see to what groups do files in /var/log belong)
  # find /var/log -perm +004
  (files which are readable by any user)
  #  find /var/log \! -group root \! -group adm -exec ls -ld {} \;
  (files which belong to groups not root or adm)
</example></p>

<p>
Per personalizzare come i file di log vengono creati probabilmente si
dovrebbe modificare il programma che li genera. Se i file di log
vengono ruotati (vgs. <prgn>logrotate</prgn>), ad ogni modo, 
dovreste personalizzare il comportamento di creazione e rotazione.


<!-- This is no longer true, check apache's logrotate
<p>
I want to emphasize that the apache log file permissions are really
screwed due to the fact that the apache user owns the apache log
files. If a user gets a shell with a back door in apache, they can
easily remove the log files.
--></p></sect1></sect>



<sect id="kernel-patches"><heading>Includere le patch nel kernel
<!-- last edited by Frédéric Schütz <schutz@mathgen.ch> --></heading>



<p>
Debian GNU/Linux è provvista di molte patch per il Kernel di Linux
per migliorarne la sicurezza. Queste includono:

<list>

<item>
<p>Sistema anti intrusione (nel pacchetto <package>lids-2.2.19</package>),
di Huagang Xie e Philippe Biondi. Questa modifica del kernel 
semplifica il processo di protezione di un sistema Linux, 
permettendo la limitazione, l'occultamento e la protezione di processi
e di determinati file, in modo che nemmeno l'utente root possa 
intervenire su di essi. Per di più, si possono anche impostare 
funzionalità per alcuni processi: imperdibile, per 
l'amministratore di sistema paranoico. Pagina di riferimento:
<url id="http://www.lids.org" name="http://www.lids.org"></p></item>
<item><p><em>POSIX Access Control Lists (ACLs) for Linux</em> (nel pacchetto
<package>kernel-patch-acl</package>). Questa modifica del kernel aggiunge
delle liste di controllo degli accessi, un metodo avanzato per limitare e
controllare l'accesso a file ed a cartelle; è stato aggiunto al kernel di
sviluppo 2.5 e sarà incluso in modo predefinito nel futuro kernel 2.6. 
Pagina di riferimento: 
<url id="http://acl.bestbits.at/" name="http://acl.bestbits.at/"></p></item>
<item><p>Linux Trustees (nel pacchetto <package>trustees</package>).
Questa modifica del kernel aggiunge un sistema avanzato di 
gestione dei permessi del kernel Linux. Oggetti speciali, chiamati 
trustees (curatori) sono uniti ad ogni file o cartella e riposti 
nella memoria del kernel, questo permette un rapido controllo di
tutti i permessi. Pagina di riferimento: 
<url id="http://trustees.sourceforge.net/" name="http://trustees.sourceforge.net/"></p></item>
<item>
<p>NSA (nel pacchetto <package>selinux</package> si può anche trovare 
<url id="http://www.coker.com.au/selinux/" name="sul sito degli sviluppatori">)</p></item>
<item>
<p><package>kernel-patch-2.2.18-openwall</package>, della Solar Designer,
utile insieme di restrizioni relative al kernel, come restrizioni ai 
collegamenti,
FIFO in <file>/tmp</file>, un file system con cartella <file>/proc</file>
ad accesso ristretto, un approccio speciale nei descrittori dei file, un
divieto di esecuzione nell'area dello stack dell'utente e altro ancora.
Pagina web di riferimento: 
<url id="http://www.openwall.com/linux/" name="http://www.openwall.com/linux/"></p></item>


<item><package>kernel-patch-2.4-grsecurity</package>: La patch Grsecurity
 patch, solo per kernel 2.4
  	 <footnote>
Notate che, che dipende dal pacchetto di sorgente del kernel 2.4 potreste 
incontrare alcuni problemi applicando la patch al sorgente del kernel. Se 
questo fosse il vostro caso potreste avere bisogno di un kernel pulito non
Debian. Questo può essere fatto con i seguenti passi:
<example>
 # apt-get install kernel-source-2.4.22 kernel-patch-debian-2.4.22
 # tar xjf /usr/src/kernel-source-2.4.22.tar.bz2
 # cd kernel-source-2.4.22
 # /usr/src/kernel-patches/all/2.4.22/unpatch/debian
</example>

Per maggiori informazioni fate riferimento a
<url id="http://bugs.debian.org/194225" name="#194225">, 
<url id="http://bugs.debian.org/199519" name="#199519">, 
<url id="http://bugs.debian.org/206458" name="#206458">, 
<url id="http://bugs.debian.org/203759" name="#203759">, 
<url id="http://bugs.debian.org/204424" name="#204424">, 
<url id="http://bugs.debian.org/210762" name="#210762">, 
<url id="http://bugs.debian.org/211213" name="#211213"> e
<url id="http://lists.debian.org/debian-devel/2003/debian-devel-200309/msg01133.html" name="discussione su debian-devel">
  	 </footnote>
  	 , che implementa l'accesso mandatorio, la protezione da buffer overflow
, ACLs, casualità sulla rete (per rendere gli OS fingerprinting difficili) e
 <url id="http://www.grsecurity.net/features.php" name="più funzionalità">.
  	 

<item><p><package>kernel-patch-2.2.19-harden</package> <em>FIXME</em> 
Aggiungere contenuto.</p></item>
<item>
<p>IPSEC kernel support (nel pacchetto <package>kernel-patch-freeswan</package>).
Se si vuole usare il protocollo
IPsec con Linux, occorre questa patch, con la quale si possono creare delle
VPN, anche per macchine Windows, in modo molto semplice, dal momento che IPsec
è uno standard comune. Le funzionalità IPSec sono state aggiunte al kernel di
sviluppo 2.5 e questa caratteristica sarà inclusa in modo predefinito 
nel futuro
kernel 2.6. Pagina web di riferimento: <url id="http://www.freeswan.org">
 <em>FIXME</em>: Gli ultimi kernel 2.4 forniti in Debian includono un backport 
del codice IPSEC dal 2.5. Commenti su questo.
</p></item>
<item>
<p><package>cryptoapi-core-source</package>. 
Questa patch aggiunge al kernel delle 
funzioni di crittografia, come la cifratura e il sommario delle funzioni.
Gli usi più comuni per queste funzioni sono la codifica dei
filesystem o delle partizioni di swap. Notate che dalla versione 
2.5.45 del kernel sono state aggiunte delle funzioni simili, talmente
simili che dai kernel 2.6 non avrete bisogno di queste patch.
<em>Nota</em>: questo pacchetto non esiste in versioni di Debian 
precedenti a <url id="http://www.debian.org/releases/sarge/" name="Sarge">.
Sito di riferimento: 
<url id="http://www.kerneli.org/" name="http://www.kerneli.org/"></p></item>
<item>
<p><package>cryptoloop-source</package>. 
Queste migliorie permettono di 
usare le funzioni che si trovano nel pacchetto 
<package>crytoapi-core-source</package> per creare dei
filesystem cifrati usando il device di loopback.</p></item>
<item>
<p><package>kernel-patch-int</package>. 
Questa patch estende le funzioni di criptazione
del kernel e può essere usata dalle versioni Debian fino a Potato.
Woody non è supportata da questo, e se usate sarge o una nuova versione
vi invito ad usare il più recente <package>cryptoapi-core-source</package>.</p></item>

</list></p>

<p>FIXME: aggiungere pi&ugrave; contenuto, spiegare come queste specifiche 
patch possono essere installate in Debian usando i pacchetti kernel-2.x.x-patch-XXX packages.
</p>
  	 
<P>FIXME: dividere le patch che si applicano solo ai kernel 2.2, patch per 
kernel 2.4 e quelle che funzionano con entrambi.

<!-- Make the entries coherent: should the package names be links to the
relevant package pages ? -->
  	
<p>
Sebbene molte patch non siano ancora in Debian. Se avete bisogno che
siano incluse chiedete di loro al gruppo 
<url id="http://wnpp.debian.org" name="Work Needing and Prospective Packages">.
Alcuni di questi sono:

<!-- http://wnpp.debian.org unreachable in the last two days... -->



<list>
<item><p><url id="http://pageexec.virtualave.net/" name="PaX patch"></p></item>
<item>
<p><url id="http://www.theaimsgroup.com/~hlein/hap-linux/" name="HAP patch"></p></item>
<item>
<p><url id="http://www.energymech.net/madcamel/fm/" name="Stealth patch"></p></item>
<item>
<p><em>SubDomain</em>. Estensione del kernel progettata per limitare
al massimo i privilegi per programmi potenzialmente dannosi per la
sicurezza, Subdomain completa ed estende i controlli originari
sugli accessi. Simile all'ambiente <prgn>chroot</prgn>, si propone
come più semplice da configurare e più flessibile.
Pagina principale: <url id="http://www.immunix.org/subdomain.html" name="http://www.immunix.org/subdomain.html"></p></item>
<item>
<p><em>UserIPAcct</em>. Non è propriamente una patch per la sicurezza
ma permette di assegnare ad ogni utente delle quote e di trarre rilievi
statistici sul traffico sul sistema . Pagina principale:
<url id="http://ramses.smeyers.be/useripacct">.</p></item>

</list></p></sect>



<sect><heading>Protezione contro i buffer overflow</heading>



<p>
<em>Buffer overflow</em> è il nome di un comune attacco al software
<footnote>Così comune, in effetti, che sono alla base del 20% delle vulnerabilità di sicurezza riportate tutti gli anni come determinato da 
<url id="http://icat.nist.gov/icat.cfm?function=statistics"
name="statistics from ICAT's vulnerability database"></footnote>
che approfitta di un controllo insufficiente (un comune errore di 
programmazione) in seguito all'esecuzione di codice da un input.
Questo attacco, contro i server che rimangono in attesa di una
connessione remota e contro il software che gira localmente, ma che 
permette degli alti privilegi agli utenti (grazie ai <tt>setuid</tt>
e <tt>setgid</tt> attivi) può compromettere ogni sistema.</p>

<p>
Esistono quattro metodi principali per proteggersi dai buffer overflow:

<list>

<item>
<p>Aggiungendo delle patch al kernel così da prevenire 
l'esecuzione dello stack.
<!-- FIXME: add a link to libsafe to the main place --></p></item>

<item>
<p>Usando una libreria come <url id="http://www.research.avayalabs.com/project/libsafe/" name="libsafe">, per sovrascrivere le funzioni 
vulnerabili e introdurre i giusti rimedi (trovate le informazioni 
su come installare libsafe leggendo: 
<url id="http://www.Linux-Sec.net/harden/libsafe.uhow2.txt" name="questo documento">).</p></item>

<item>Fissando il codice usando strumenti per trovare framenti che potrebbero
introdurre vulnerabilità.

<item>
<p>Ricompilando il codice per introdurre controlli appropriati che prevengono
 gli overflow, usando per esempio: <url id="http://www.immunix.org/stackguard.html" name="StackGuard"> (che è usato da <url id="http://www.immunix.org" name="Immunix">) o la patch per GCC <url id="http://www.research.ibm.com/trl/projects/security/ssp/" name="Stack Smashing Protector (SSP)"> patch per GCC che è usata <url id="http://www.adamantix.org" name="Adamantix">)nuove utilità per prevenire gli overflow, usando per esempio stackguard.</p></item>

<item>
<p>Usando dei programmi che cercano e riparano queste vulnerabilità.</p></item>

</list></p>

<p>
Debian GNU/Linux, dalla versione 3.0, fornisce programmi per includere tutti
questi metodi di protezione all'atto della compilazione del codice sorgente 
(ma questo sono state richieste in <url id="http://bugs.debian.org/213994" name="Bug #213994">).

<p>Notate che se Debian fornisse un compilatore con protezione contro stack o
buffer overflow tutti i pacchetti doverebbero essere ricompilati per poter
introdurre questa funzionalità. Questo è, in effetti, quello che fa Adamantix
(tra le altre). L'effetto su questa nuova funzionalità del software non è
stato ancora determinato (alcuni programmi o alcune architetture di processori 
potrebbero non funzionare).

<p>
In ogni caso questi consigli non prevengono i buffer overflow
poiché esistono dei modi per aggirare queste precauzioni, metodi
descritti nel 
<url id="http://packetstorm.linuxsecurity.com/mag/phrack/phrack58.tar.gz" name="numero 58"> 
del phrack's magazine.

o in CORE Advisory
<url id="http://online.securityfocus.com/archive/1/269246"
name="Multiple vulnerabilities in stack smashing protection technologies">.
</p>

<sect1>Patch per la protezione del kernel da Kernel contro buffer overflows

<p>Le patch relative al buffer overflow includono la patch Openwall che 
fornisce protezione contro gli overflow nel kernel 2.2. Per il kernel 2.4, 
avrete bisogno di usare la patch Grsecurity (nel pacchetto
<package> kernel-patch-2.4-grsecurity</package>) che include la patch
Openwall patch e molto altro <url id="http://www.grsecurity.net/features.php"
 name="funzionalità"> (include ACL e casualità sulla rete per rendere 
difficile  l'OS fingerprinting remoto ), o i moduli Linux Security Modules 
(nei pacchetti <package>kernel-patch-2.4-lsm</package> e 
<package>kernel-patch-2.5-lsm</package>).

Per maggiori informazioni sull'uso di queste patch leggete il paragrafo 
<ref id="kernel-patches">.
  	 
 <sect1>Protezione libsafe
  	 
<p>Proteggere un sistema Debian GNU/Linux con <package>libsafe</package> è 
abbastanza semplice. Installate il pacchetto e rispondete <em>Si</em> per
avere la libreria precaricata globalmente. State, comunque, attenti, dato che
questo potrebbe guastare del software (normalmente programmi linkati alla 
vecchia <prgn>libc5</prgn>, quindi assicuratevi di leggere 
<url id="http://bugs.debian.org/libsafe" name="reported bug reports"> prima 
e testate i programmi più critici del vostro sistema prima con il programma 
wrapper di <prgn>libsafe</prgn>.
  	 
<p><em>Nota importante</em>: La protezione libsafe protection può non essere
efficace attualemente come descritto in <url id="http://bugs.debian.org/173227"
 name="173227">. Eseguite un test molto attento prima Consider testing prima di
usarla in un ambiente di produzione e non dipendete esclusivamente su questa
per la protezione del vostro sistema.
  	 
<sect1>Testare i programmi contro gli overflow
  	 
<p>L'usop di strumenti per trovare buffer overflows richeide, in ogni caso,
una esperienza di programmazione per sistemare (e ricompilare) il codice.
Debian, fornisce, per esempio: <package>bfbtester</package> (un tester per 
buffer overflow che usa l'approccio di forza bruta contro i binari usando
overflow di linea di comando o di ambiente) e  <package>njamd</package>.

<sect><heading>Trasferire file in sicurezza</heading>



<p>
Durante la normale amministrazione, solitamente si ha bisogno di 
importare o di esportare dei file dal sistema installato. Si può riuscire a 
copiare i file da un host ad un altro in maniera sicura, usando il pacchetto 
server <package>sshd</package>. Un'altra possibilità è l'impiego di 
<package>ftpd-ssl</package>, un server ftp che adotta il <em>Secure Socket 
Layer</em> per cifrare le trasmissioni.</p>

<p>
Naturalmente, tutti questi metodi necessitano di client speciali e Debian ne 
offre alcuni: per esempio, con <package>ssh</package> fornisce 
<prgn>scp</prgn>, che funziona come <prgn>rcp</prgn>
ma è completamente cifrato, cosicché i <em>cattivi ragazzi</em> 
non possano nemmeno capire 
CHE COSA si stia copiando. C'è anche un pacchetto cliente 
<package>ftp-ssl</package> per 
il server corrispettivo. Per questi programmi, si trovano client anche di 
altri sistemi operativi (non-UNIX); per copiare in 
sicurezza, <prgn>putty</prgn> e 
<prgn>winscp</prgn> forniscono un'implementazione adatta a qualsiasi 
versione del sistema operativo della Microsoft.</p>

<p>
Notate che usare <prgn>scp</prgn> consente a tutti gli utenti 
l'accesso all'intero file-system, a meno che non sia stato dato 
il comando <prgn>chroot</prgn>, come spiegato nella <ref id="ssh-chroot">. 
Si può configurare l'accesso FTP, attraverso <prgn>chroot</prgn>, 
in modo anche più semplice, a seconda del demone scelto, come illustrato 
nella <ref id="ftp-secure">. Se si teme che gli utenti sfoglino i 
file locali e si vuole avere una comunicazione cifrata, si può 
utilizzare un demone ftp con supporto SSL, o abbinare un ftp 
che trasmette testo in chiaro e un'impostazione VPN (cfr. <ref id="vpn">).</p></sect>



<sect><heading>Limitazioni e controllo del File System</heading>



<sect1><heading>Usare le quote</heading>



<p>
Avere un buon criterio di assegnazione delle quote è importante, poiché evita 
che gli utenti riempiano gli o l'hard disk.</p>

<p>
Si possono avere due differenti sistemi di quote: la quota d'utente e la 
quota di gruppo. Come si intuisce, la quota per utente limita la quantità di 
spazio di cui un utente può disporre e la quota di gruppo fa lo stesso, ma 
verso i gruppi. Ricordatene quando decidete la dimensione 
delle quote.</p>

<p>
Nell'impostare un sistema di quote, bisogna tenere conto di alcuni punti 
importanti:

<list>
<item>
<p>Fare in modo che le quote siano abbastanza piccole, in modo che gli 
utenti non divorino lo spazio del disco fisso;</p></item>
<item>
<p>Fare in modo che siano abbastanza grandi, in modo che gli utenti non 
abbiano a lagnarsene e che la loro quota-email impedisca loro di 
accettare posta per un lungo periodo;</p></item>
<item>
<p>Usare il sistema quote su tutte le aree scrivibili dagli utenti, su 
<file>/home</file> come su <file>/tmp</file>.</p></item>

</list></p>

<p>
Ogni partizione o cartella a cui gli utenti abbiano pieno accesso in scrittura 
dovrebbe essere organizzata in quote. Il calcolo e l'assegnazione di una 
quota su cui si possa lavorare, unisce utilizzabilità e sicurezza.</p>

<p>
Supponiamo che vogliate usare il sistema quote: prima di tutto, bisogna 
controllare che il supporto per le quote sia abilitato nel kernel (se non lo 
è, va ricompilato); dopo di che, controllate che il pacchetto 
<package>quota</package> sia installato (se non lo è, bisogna fare anche 
questo).

<!-- FIXME: how to check for quota support? What to tweak when
recompiling? --></p>

<p>
Per abilitare le  quote per i rispettivi file  system basta modificare
l'impostazione nel file <file>/etc/fstab</file> da <tt>defaults</tt> a
<tt>defaults,usrquota</tt>. Se c'è bisogno delle quote di gruppo a, sostituite
<tt>grpquota</tt> a <tt>usrquota</tt>. Si possono
utilizzare entrambe le opzioni. Quindi, basta creare due file vuoti
quota.user e  quota.group nella root del file system dove si vogliono
usare le quote (ad esempio,  per un file system <file>/home</file>, date
il comando <tt>touch /home/quota.user /home/quota.group</tt>).</p>

<p>
Riavviare quota lanciando: 
<tt>/etc/init.d/quota stop;/etc/init.d/quota start</tt>. 
A questo punto, dovrebbe funzionare e potete impostare 
le dimensioni delle quote.</p>

<p>
Per modificare le quote di un particolare utente (di "giorgio", 
per esempio) basta dare il comando <tt>edquota -u giorgio</tt>; 
per quelle di un gruppo, invece, <tt>edquota -g &lt;gruppo&gt;</tt>. 
Infine impostate il modo quota fissa o variabile e/o le quote inode, a piacere.</p>

<p>
Per maggiori informazioni sulle quote, leggere le relative pagine man ed il 
quota mini-HOWTO (<file>/usr/share/doc/HOWTO/en-html/mini/Quota.html</file>) 
(mini guida su quota).</p>

<p>
Può darsi che <package>lshell</package> non piaccia, dal momento 
che viola il FHS: ebbene, tenete presente che pam_limits.so 
potrebbe svolgere le medesime funzioni e che <package>lshell</package>
è attualmente <url id="http://bugs.debian.org/93894" name="orfana"> 
(senza manutentore).</p></sect1>


<sect1 id="ext2attr"><heading>Specifici attributi del filesystem ext2 (chattr/lsattr)
<!-- section last edited by Frédéric Schütz <schutz@mathgen.ch> --></heading>


<p>
Oltre ai soliti permessi di tipo Unix, i filesystem ext2 ed ext3 offrono un
insieme di attributi specifici per dare un maggiore controllo sui file del
sistema. A differenza dei permessi di base, questi non vengono mostrati con il
comando <prgn>ls -l</prgn> o modificati mediante <prgn>chmod</prgn>; per
amministrarli, occorrono altre due utilità: <prgn>lsattr</prgn> e
<prgn>chattr</prgn> (nel pacchetto <package>e2fsprogs</package>). Notate che
ciò significa che tali attributi non saranno salvati con la copia di sicurezza
del sistema; così, qualora se ne modifichi uno qualsiasi, sarebbe meglio
salvare in uno script i successivi comandi <prgn>chattr</prgn>, così da
poterli reimpostare in un secondo momento, all'atto di un eventuale ripristino.</p>

<p>
Fra tutti gli attributi disponibili, i due più importanti, nell'aumentare la
sicurezza sono richiamati dalle lettere "i" e "a" e possono essere impostati o
rimossi dal superutente:

<list>
<item>
<p>L'attributo "i" ("immutabile"): un file con questo attributo non può
essere modificato, né cancellato, né rinominato e nemmeno il superutente può
creare collegamenti ad esso.</p></item>
<item>
<p>L'attributo "a" ("appendici"): questo attributo ha lo stesso effetto
del precedente, salvo che consente di aprire il file per aggiungervi del nuovo
contenuto, pur senza poter modificare quello già esistente (append mode); è
molto utile per i file di log collocati nella cartella <file>/var/log/</file>,
anche se si dovrebbe considerare che, talvolta, questi vengono spostati, per
via degli script di rotazione dei log.</p></item>

</list></p>

<p>
Si possono impostare questi attributi anche per le cartelle; in tal caso
nessuno può modificarne i contenuti, rinominando o rimuovendo dei file.
Applicato ad una cartella, l'attributo append permette la sola creazione di
file.</p>

<p>
Si vede bene come l'attributo "a" aumenti la sicurezza, permettendo ai
programmi non eseguiti dal superutente l'aggiunta di dati ad un file, senza
poterne modificare il contenuto preesistente. Invece, l'attributo "i" sembra
meno interessante: dopotutto, per limitare l'accesso a un file, il superutente
può già usare i permessi di base di Unix, mentre un intruso che riesca ad
assumere la qualità di superutente potrebbe sempre usare il programma
<prgn>chattr</prgn> per rimuovere l'attributo: inizialmente potrebbe
confondersi, vista l'impossibilità di spostare un file, ma non si può pensare
che sia cieco - in fondo, è pur entrato nel sistema! Per aumentarne la
sicurezza, alcuni manuali (compresa una precedente versione di questo
documento) suggeriscono semplicemente di rimuovere dal sistema i programmi
<prgn>chattr</prgn> e <prgn>lsattr</prgn>, ma questo tipo di strategia, nota
come "sicurezza mediante oscurità" deve essere evitata in assoluto, in quanto
fornisce un falso senso di sicurezza.</p>

<p>
Un modo sicuro di risolvere questo problema è usare una funzionalità del
kernel Linux, chiamata <tt>CAP_LINUX_IMMUTABLE</tt>, come mostrato in <ref id="proactive">: eliminandola dalle serie delle limitazioni alle funzionalità
(per esempio, col comando <tt>lcap CAP_LINUX_IMMUTABLE</tt>) non sarà più
possibile, nemmeno al superutente, modificare qualunque attributo "a" o "i"!
Un strategia completa potrebbe essere questa:

<enumlist>

  <item> <p>Impostare gli attributi "a" ed "i" sui file desiderati;</p></item>
  <item> <p>Aggiungere il comando <tt>lcap CAP_LINUX_IMMUTABLE</tt> (o anche,
         come in <ref id="proactive">, <tt>lcap CAP_SYS_MODULE</tt>)
         a uno degli script di avvio;

<!-- Is there anything interesting in :
http://lists.debian.org/debian-security/2001/debian-security-200107/msg00024.html --></p></item>

  <item> <p>Impostare l'attributo "i" su tale script e su altri file di avvio, o
         anche sullo stesso binario <prgn>lcap</prgn>;</p></item>
  <item> <p>Eseguire manualmente detto comando (o riavviare il sistema, per
         assicurarsi che tutto funzioni a dovere).</p></item>

</enumlist></p>

<p>
Ora che la funzionalità è stata tolta dal sistema, un intruso non può cambiare
alcun attributo dei file protetti, né, quindi, modificarli o eliminarli. Se
forza il riavvio della macchina (unico modo per ripristinare la serie di
limitazioni alle funzionalità), sarà facilmente scoperto e comunque quella
funzionalità sarà nuovamente rimossa appena il sistema si sarà riavviato. Il
solo sistema di modificare un file protetto sarebbe inizializzare il sistema
nel modo singolo-utente o usando una altro disco di avvio, due operazioni che
richiedono un accesso fisico alla macchina!

<!-- Add a note about the fact that it is not widely used --></p></sect1>


<sect1 id="check-integ"><heading>Controllare l'integrità del file system</heading>

<p>
Siete sicuri che <file>/bin/login</file> sul disco fisso è ancora 
il binario installato qualche mese fa? 
Cosa accadrebbe se fosse una versione modificata, che registra
le password inserite in un file nascosto o le spedisce in 
chiaro per tutta Internet?</p>

<p>
Il solo modo per avere qualche forma di protezione è controllare i file ogni
ora/giorno/mese (preferibile quotidianamente) confrontando gli md5sums attuali
di un file con quelli vecchi. Due file non possono avere lo stesso md5sums
(l'MD5 digest è 128 bits, quindi le possibilità che due diversi 
file abbiano lo
stesso md5sum sono approssimativamente una su 3.4e3803), perciò è il metodo
più sicuro, a meno che qualcuno non abbia modificato l'algoritmo che crea
l'md5sums sulla macchina che comunque è piuttosto complicato e improbabile.
Bisogna considerare la verifica di questi binari molto importante, poiché è un
modo semplice di riconoscere le modifiche ai binari. 
Strumenti comunemente utilizzati a questo scopo 
sono <package>sXid</package>, <package>AIDE</package> 
(Advanced Intrusion Detection Environment),
<package>TripWire</package> (non libero; la nuova versione sarà GPL), 
<package>integrit</package> e <package>samhain</package>.</p>

<p>
Installare <prgn>debsums</prgn> 
può aiutare a controllare l'integrità del file system,
confrontando l'md5sums di ogni file con quello usato nell'archivio dei 
pacchetti di Debian. Ma attenzione, questi file possono facilmente 
essere modificati.</p>

<p>
Inoltre si può sostituire <package>locate</package> con 
<package>slocate</package>. Slocate è una versione
avanzata per la sicurezza di GNU locate. Quando si usa slocate, l'utente vede
solo i file a cui ha realmente accesso e si può escludere qualsiasi file o
directory del sistema.</p>

<p>
FIXME: inserire riferimenti alle immagini prese dopo l'installazione.</p>

<p>
FIXME: aggiungere una nota relativa ai pacchetti che non forniscono debsums per
tutte le applicazioni installate.</p></sect1>


<sect1><heading>Impostare il controllo di setuid</heading>


<p>
Debian fornisce un processo <prgn>cron</prgn> che lavora quotidianamente in
<file>/etc/cron.daily/standard</file>. Questo processo <prgn>cron</prgn> 
lancerà lo script <prgn>/usr/sbin/checksecurity</prgn> che registra 
le informazioni su queste modifiche.

<!-- FIXME: What is the default for this in cron package? jfs --></p>

<p>
Per rendere possibili questi controlli bisogna impostare
<tt>CHECKSECURITY_DISABLE="FALSE"</tt> in 
<file>/etc/checksecurity.conf</file>. Nota: questa è
l'impostazione predefinita, quindi finché non si apportano modifiche, questa
opzione sarà impostata su "FALSE".</p>

<p>
L'impostazione predefinita non invia questa informazione al super utente ma
conserva invece copie giornaliere delle modifiche 
in <file>/var/log/setuid.changes</file>.
Dovreste impostare CHECKSECURITY_EMAIL 
(in <file>/etc/checksecurity.conf</file>) su
"root" per spedirgli questa informazione. Confrontate
<manref name="checksecurity" section="8"> per
maggiori dettagli sulla configurazione.</p></sect1></sect>



<sect id="network-secure"><heading>Rendere sicuro l'accesso alla rete</heading>



<p>
FIXME. Servono più contenuti (specifici per Debian)</p>


<sect1 id="kernel-conf"><heading>Configurare le caratteristiche di rete del kernel</heading>


<p>FIXME: Contenuto mancante</p>

<p>
Molte caratteristiche del kernel possono essere cambiate quando 
questo è in esecuzione, effettuando un echo all'interno del filesystem 
<file>/proc</file> o usando <prgn>sysctl</prgn>.
Eseguendo <tt>/sbin/sysctl -A</tt> potete vedere cosa è possibile 
configurare e quali sono le opzioni, è possibile modificarlo eseguendo
<tt>/sbin/sysctl -w variable=value</tt> (vedete 
<manref name="sysctl" section="8">). Solo in rari casi è necessaria questa
modifica ma potete comunque incrementare la sicurezza in questo 
modo. Per esempio:

<!-- FIXME: Should the prefix on all of these be /proc/sys/? era -->

<example>
net/ipv4/icmp_echo_ignore_broadcasts = 1
</example></p>

<p>
Questo è un <em>emulatore di Windows</em> perché funziona come Windows in
broadcast ping, se questa opzione è impostata ad 1. In pratica, le richieste
ICMP_ECHO vengono ignorate. Altrimenti, non succede nulla.</p>

<p>
Se desiderate bloccare tutte le richieste sul sistema, abilitate questa
opzione di configurazione:

<example>
net/ipv4/icmp_echo_ignore_all = 0
</example></p>

<p>
Per loggare dei pacchetti destinati ad indirizzi inesistenti 
(errore dovuto ad instradamenti sbagliati) sulla propria rete, 
utilizzate:

<example>
/proc/sys/net/ipv4/conf/all/log_martians = 1
</example></p>

<p>
Per maggiori informazioni su ciò che può essere fatto con
<file>/proc/sys/net/ipv4/*</file> leggete
<file>/usr/src/linux/Documentation/filesystems/proc.txt</file>.
Tutte le opzioni sono descritte in maniera esauriente in
<file>/usr/src/linux/Documentation/networking/ip-sysctl.txt</file>

<footnote>
<p>In Debian, il pacchetto <package>kernel-source-2.X.X</package> 
installa il sorgente in <file>/usr/src/kernel-souce-2.X.X</file>.
Abbiate perciò cura di sostituire il termine <em>linux</em>
con la versione del kernel installato</p>

</footnote>.</p>



<sect2 id="tcp-syncookies"><heading>Configurare Syncookies</heading>


<p>
Questa opzione è un'arma a doppio taglio. Da un lato, protegge
il sistema contro il syn flooding, dall'altro viola degli 
standard definiti (le RFC).

<!-- What does this mean? (jfs)
This option is quite dumb as it floods the
other side like it floods you, so the other side is also busy. 
-->

<example>
net/ipv4/tcp_syncookies = 1
</example></p>

<p>
Se desiderate cambiare questa opzione, ogni volta che il kernel è in
esecuzione, allora dovrete modificare <tt>/etc/network/options</tt> 
impostando <tt>syncookies=yes</tt>. 
Questo cambiamento avrà l'effetto di eseguire ogni volta lo script 
contenuto in <tt>/etc/init.d/networking</tt> (come farlo al boot), mentre 
la seguente opzione avrà effetto solamente con il kernel in esecuzione.

<example>
echo 1 > /proc/sys/net/ipv4/tcp_syncookies 
</example></p>

<p>
Questa opzione è disponibile solamente se il kernel è stato 
compilato con l'opzione <tt>CONFIG_SYNCOOKIES</tt>. Tutti i 
kernel Debian sono compilati con questa opzione all'interno
del kernel, potete verificarlo eseguendo:

<example>
$ sysctl -A |grep syncookies
net/ipv4/tcp_syncookies = 1
</example></p>

<p>
Per maggiori informazioni sui syncookies TCP leggete
<url id="http://cr.yp.to/syncookies.html">.</p></sect2></sect1>


<sect1 id="net-harden"><heading>Rendere sicura la rete al momento del boot</heading>


<p>
Quando impostate le opzioni del kernel relative al networking,
dovete configurarle in maniera tale che siano caricate ogni volta che
il sistema viene riavviato. L'esempio seguente abilita molte delle 
precedenti opzioni che avete visto, insieme ad altre utili opzioni.</p>

<p><em>FIXME</em> Invece di fornire questo script fornire un esempio di 
configurazione per <file>sysctl.conf</file> (controllare: <manref section="5" name="sysctl.conf">). Mandare anche un bug desiderata per il pacchetto procps.

<p>
Create lo script in <file>/etc/network/interface-secure</file> 
(il nome è dato a titolo di esempio) e chiamatelo da 
<file>/etc/network/interfaces</file>, come segue:

<example>
auto eth0
iface eth0 inet static
        address xxx.xxx.xxx.xxx
        netmask 255.255.255.xxx
        broadcast xxx.xxx.xxx.xxx
        gateway xxx.xxx.xxx.xxx
        pre-up /etc/network/interface-secure
</example>

<example>
# Script-name: /etc/network/interface-secure
# Modifies some default behaviour in order to secure against 
# some TCP/IP spoofing & attacks
#
# Contributed by Dariusz Puchalak  
#
echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts 
                                           # broadcast echo protection enabled
echo 0 > /proc/sys/net/ipv4/ip_forward     # ip forwarding disabled
echo 1 > /proc/sys/net/ipv4/tcp_syncookies # TCP syn cookie protection enabled
echo 1 >/proc/sys/net/ipv4/conf/all/log_martians # Log strange packets 
                                           # but be careful with this on heavy loaded web servers
                         # but be careful with this on heavy loaded web servers
echo 1 > /proc/sys/net/ipv4/ip_always_defrag 
                                           #  defragging protection always enabled
echo 1 > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses 
                                           # bad error message protection enabled

# now ip spoofing protection
echo 1 > /proc/sys/net/ipv4/conf/*/rp_filter


# and finally some more things:
# Disable ICMP Redirect Acceptance
echo 0 > /proc/sys/net/ipv4/conf/*/accept_redirects
echo 0 > /proc/sys/net/ipv4/conf/*/send_redirects

# Disable Source Routed Packets
echo 0 > /proc/sys/net/ipv4/conf/*/accept_source_route

# Log Spoofed Packets, Source Routed Packets, Redirect Packets
echo 1 >/proc/sys/net/ipv4/conf/*/log_martians

</example></p>

<p>
&Egrave; anche possibile creare uno script <tt>init.d</tt> e farlo
eseguire all'avvio del sistema (usando <prgn>update-rc.d</prgn> per 
creare i collegamenti <tt>rc.d</tt> appropriati).</p></sect1>


<sect1 id="kernel-fw"><heading>Configurare le caratteristiche di un firewall</heading>


<p>
Per avere un firewall, sia per proteggere il sistema locale o tutto quello
che si trova <em>dietro</em>, dovete compilare nel kernel le funzionalità 
del firewall. 
Il kernel standard per Debian 2.2 (anch'esso
2.2) comprende il packet filter <prgn>ipchains</prgn> 
come firewall, in Debian 3.0 è presente anche il
kernel della serie 2.4 che è invece provvisto 
di <em>stateful</em> packet filter, <prgn>iptables</prgn> (netfilter)
come firewall. Per le vecchie distribuzioni di Debian bisogna
procurarsi le appropriate patch per il kernel (Debian 2.1 adotta
il kernel 2.0.34).</p>

<p>
In tutti i casi è vantaggioso e facile usare un kernel differente
tra quelli che Debian mette a disposizione. Potete cercare dei pacchetti
che contengano il kernel precompilato ed è semplice installarlo in un
sistema Debian. Potete anche scaricare i sorgenti del kernel usando
<package>kernel-source-X</package> e poi realizzare un 
pacchetto usando <package>make-kpkg</package>.</p>

<p>
La configurazione del firewall sarà ampiamente trattata in
<ref id="firewall-setup">.</p></sect1>


<sect1 id="limit-bindaddr"><heading>Disabilitare weak-end host</heading> 


<p>
I sistemi con più di un'interfaccia in differenti reti possono
avere configurati servizi come se avessero solamente un indirizzo IP
convenuto.
Normalmente ciò previene il fatto che vengano richiesti dati servizi da un
indirizzo prestabilito.
Comunque, questo non è un trucco (sebbene sia un normale malinteso), il
servizio si limita a delimitare l'indirizzo <em>hardware</em> 
(scheda ethernet).

<footnote>
<p>Per riprodurre questo (esempio fornito da Felix von Leitner
nella mailing list bugtraq):

<example>
   host a (eth0 connected to eth0 of host b):
     ifconfig eth0 10.0.0.1
     ifconfig eth1 23.0.0.1
     tcpserver -RHl localhost 23.0.0.1 8000 echo fnord

   host b:
     ifconfig eth0 10.0.0.2
     route add 23.0.0.1 gw 10.0.0.1
     telnet 23.0.0.1 8000
</example></p>
<p>
Comunque, non agite con i servizi impostati per l'indirizzo
127.0.0.1, è consigliato effettuare il test usando le raw sockets.</p>

</footnote></p>

<p>
Questa non è un problema di ARP e altresì non è una violazione RFC
(è chiamata <em>weak end host</em> dalla
<url id="ftp://ftp.isi.edu/in-notes/rfc1122.txt" name="RFC1122">,
la trovate nel paragrafo 3.3.4.2).
Ricordate, gli indirizzi IP non hanno nulla da spartire con le interfacce
fisiche.</p>

<p>
Nelle versione 2.2 del kernel ed anche nelle precedenti è possibile
porre rimedio con:

<example>
# echo 1 > /proc/sys/net/ipv4/conf/all/hidden
# echo 1 > /proc/sys/net/ipv4/conf/eth0/hidden
# echo 1 > /proc/sys/net/ipv4/conf/eth1/hidden
.....
</example></p>
<p>
Nei kernel più recenti si può ottenere lo stesso con:

<list>
<item>
<p>Regole per iptable</p></item>
<item><p>protocolli di instradamento debitamente configurati.

<footnote>
<p>Il fatto che questo comportamento, possa essere modificato cambiando
l'instradamento, viene descritto da Matthew G. Marsh nei thread
di bugtraq:

<example>
eth0 = 1.1.1.1/24
eth1 = 2.2.2.2/24

ip rule add from 1.1.1.1/32 dev lo table 1 prio 15000
ip rule add from 2.2.2.2/32 dev lo table 2 prio 16000

ip route add default dev eth0 table 1
ip route add default dev eth1 table 2
</example></p>

</footnote></p></item>

<item>
<p>Applicare delle patch al kernel.

<footnote>
<p>Esistono numerose patch disponibili per ottenere questo comportamento
descritte nei thread di bugtraq, potete trovarle ai seguenti indirizzi:
<url id="http://www.linuxvirtualserver.org/~julian/#hidden">
e <url id="http://www.fefe.de/linux-eth-forwarding.diff">.</p>
</footnote></p></item>

</list></p>

<p>
Nel corso di questo documento ci saranno occasioni per configurare
molti servizi (server sshd, apache, servizi di stampa...)
secondo l'ordine in cui si trovano, ascoltano ogni possibile indirizzo,
il lettore può trovare l'account in questo momento, senza sistemare
i servizi, le riparazioni non prevengono l'accesso al sistema dalla
medesima rete.

<footnote>
<p>Un aggressore potrebbe avere molti problemi ad ottenere l'accesso
dopo la configurazione degli indirizzi IP se non si trova
nel medesimo dominio (stessa rete) dell'host sotto attacco.
Se l'attacco è rivolto ad un router è molto difficoltoso per
l'aggressore riprovare.</p>

</footnote></p>

<p>
FIXME: i commenti tratti da bugtraq sono metodi specifici per proteggere
un data interfaccia in Linux.</p>

<p>
FIXME: sottoporre un bug nei confronti di netbase in modo che la riparazione della
tabella di routing sia il comportamento standard per Debian?</p></sect1>


<sect1><heading>Proteggersi dagli attacchi di tipo ARP</heading>


<p>
Quando non c'è piena fiducia verso le altre postazioni sulla propria LAN
(dovrebbe essere sempre così, è l'atteggiamento più sicuro), ci si dovrebbe
proteggere dai diversi possibili attacchi di tipo ARP.</p>

<p>
Il protocollo ARP è usato per collegare indirizzi IP a indirizzi MAC - per
tutti i dettagli vedere la 
<url id="ftp://ftp.isi.edu/in-notes/rfc826.txt" name="RFC826">.
Ogni volta che si spedisce un pacchetto a un indirizzo IP si verifica una
risoluzione ARP per trovare l'indirizzo dell'hardware interessato (in primo
luogo, consultando la cache locale di ARP; poi, se l'IP non è presente nella
cache, diffondendo un'interrogazione ARP). Tutti gli attacchi ARP mirano a
far credere ad una postazione che il proprio indirizzo IP sia associato
all'indirizzo MAC di quello dell'intruso.</p>

<p>
Quegli attacchi (Cache poisonning, ARP spoofing - avvelenamento di cache,
falsificazioni ARP) permettono all'attaccante di intercettare il traffico anche
su reti staccate, di dirottare facilmente delle connessioni, di disconnettere
un host qualunque dalla rete... Gli attacchi ARP sono potenti e semplici da
porre in esecuzione, essendovi parecchi strumenti: arpspoof (presente nel
pacchetto <package>dsniff</package>), 
<url id="http://www.team-teso.net/releases/arpmim-0.2.tar.gz" name="arpmim">, 
<url id="http://web.syr.edu/~sabuer/arpoison/" name="arpoison">...</p>

<p>
Tuttavia, una soluzione c'è sempre:

<list>

<item>
<p>Usare una cache ARP statica, nella quale impostare delle voci "statiche":

<example>
arp -s host_name hdwr_addr 
</example></p> 

<p>
Impostando voci statiche per ciascun host importante presente nella rete,
ci si assicura che nessuno crei/modifichi per detti host una voce (falsa) -
le voci statiche non hanno scadenza e non possono essere modificate -,
cosicché le repliche ARP falsificate saranno ignorate.</p></item>

<item>
<p>Scoprire un traffico ARP sospetto: si possono usare anche 
<package>arpwatch</package>, <package>karpski</package>
o un più generico IDS che possa anche svolgere tale compito
(introduzione a <package>snort</package>, 
<url id="http://www.mandrakelinux.com/prelude">...).</p></item>
<item>
<p>Eseguire un filtraggio del traffico IP in grado di convalidare gli
indirizzi MAC.</p></item>

</list></p></sect1></sect>



<sect id="snapshot"><heading>Una fotografia del sistema</heading>



<p>
Prima di mettere il sistema in produzione se ne può fotografare l'attuale
stato: il risultato dell'operazione può tornare utile in caso di
compromissione (vedete il <ref id="after-compromise">). Questo procedimento
dovrebbe essere ripetuto ad ogni aggiornamento del sistema, specialmente se
si aggiorna a una nuova versione Debian.</p>

<p>
A tale scopo si può usare un medium scrivibile e rimovibile che possa
essere impostato in sola lettura, come un floppy disk, se protetto da
scrittura dopo l'uso, o un CD aperto da un unità CD-ROM - si può usare un
CD riscrivibile, in modo da poter conservare copie di ripristino di tipo
md5 (md5sums) create in date differenti.</p>

<p>
Il seguente listato consente la fotografia del sistema:

<example>
#!/bin/bash
/bin/mount /dev/fd0 /mnt/floppy
/bin/cp /usr/bin/md5sum /mnt/floppy
echo "Calculating md5 database"
>/mnt/floppy/md5checksums.txt
for dir in /bin/ /sbin/ /usr/bin/ /usr/sbin/ /lib/ /usr/lib/
do
   find $dir -type f | xargs /usr/bin/md5sum >>/mnt/floppy/md5checksums-lib.txt
done
/bin/umout /dev/fd0
echo "post installation md5 database calculated"
</example></p>

<p>
Notate che il binario md5sum punta alla periferica del floppy, così da
poterlo utilizzare, in seguito, per il controllo dei file binari del
sistema (solo nel caso di un'infezione da virus di tipo trojan).</p>

<p>
La fotografia non comprende i file della cartella 
<file>/var/lib/dpkg/info</file>, che
racchiude le tabelle hash dei file md5, riportanti (in file con estensione
<file>.md5sums</file>) l'elenco dei 
pacchetti installati; si potrebbero copiare anche
queste informazioni, ma bisogna considerare che:

<list>

<item>
<p>I file di tipo md5 forniti dai pacchetti Debian includono tutti i file ad
essi collegati, questo rende più voluminoso il database (5MB contro 600Kb
in un sistema Debian GNU/Linux con interfaccia grafica e circa 2,5 GB di
programmi installati).</p></item>
<item>
<p>Non tutti i pacchetti Debian forniscono file di tipo md5 che elenchino ciò
che è stato installato, dal momento che (attualmente) questa non è una
linea di condotta obbligata.</p></item>

</list></p>

<p>
Una volta fatta la fotografia, accertatevi di impostare il medium in sola
lettura; a quel punto, si può accantonarlo per un futuro ripristino o
inserirlo nella periferica per un controllo periodico 
mediante <prgn>cron</prgn>, che confronti gli attuali file 
md5sum con quelli precedentemente "fotografati".</p></sect>

<sect><heading>Ulteriori raccomandazioni</heading>



<sect1><heading>Non usare software che dipende dalle librerie SVGA (svgalib)</heading>


<p>
SVGAlib è molto carina per gli amanti della console come me, ma è
stato provato diverse volte, in passato, che è molto insicura.
Sono stati rilasciati exploit contro <prgn>zgv</prgn> ed era semplice
utilizzarli per diventare root. 
&Egrave meglio che evitiate di usare programmi che fanno uso della 
SVGAlib, quando possibile.

<!-- FIXME: move this to policy section if there ever is one? --></p></sect1></sect></chapt>




















