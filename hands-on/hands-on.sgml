<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN">

<!-- BEGIN DOCUMENT -->
<article>


<!-- ARTICLE HEADER -->
<artheader>
	<title>
	Hands-on Guide to the Debian GNU Operating System
	</title>
	<author>
		<firstname>Davor</firstname>
		<surname>Ocelic</surname>
		<affiliation>
			<address>
			<email>docelic@mail.inet.hr</email>
			</address>
		</affiliation>
	</author>

	<!-- REVISION HISTORY -->
	<revhistory>
		<revision> <!-- 2.4 -->
			<revnumber>2.4</revnumber>
			<date>30 March 2002</date>
			<authorinitials>docelic</authorinitials>
			<revremark>
				This is the initial release.
			</revremark>
		</revision>
		<revision> <!-- 2.5 -->
			<revnumber>2.5</revnumber>
			<date>02 May 2002</date>
			<authorinitials>docelic</authorinitials>
			<revremark>
				Spelling & grammar corrections, Spanish translation (all by Walter Echarri)
			</revremark>
		</revision>
		<revision> <!-- 2.6 -->
			<revnumber>2.6</revnumber>
			<date>03 June 2002</date>
			<authorinitials>docelic</authorinitials>
			<revremark>
				Content improvements, Walter's grammar corrections, introduced the Kernel chapter (separate document).
			</revremark>
		</revision>
		<revision> <!-- 2.7 -->
			<revnumber>2.7</revnumber>
			<date>24 July 2002</date>
			<authorinitials>docelic</authorinitials>
			<revremark>
				Lot of improvements and new details.
				The lyx->sgml variant just didn't work, output documents were crap.
				I've re-written it manually in docbook sgml, with newbiedoc stylesheets; it's a blast!
			</revremark>
		</revision>
		<revision> <!-- 2.8 -->
			<revnumber>2.8</revnumber>
			<date>12 September 2002</date>
			<authorinitials>docelic</authorinitials>
			<revremark>
				Lot of improvements and new details.
				Thanks to G&uuml;rkan Seng&uuml;n (gurkan-AT-linuks.mine.nu) for various good tips, suggestions and links (and hosting the guide!)
			</revremark>
		</revision>
		<revision> <!-- 2.9 -->
			<revnumber>2.9</revnumber>
			<date>15 September 2002</date>
			<authorinitials>docelic</authorinitials>
			<revremark>
				Improvements; links to external resources.
			</revremark>
		</revision>
		<revision> <!-- 3.0 -->
			<revnumber>3.0</revnumber>
			<date>16 September 2002</date>
			<authorinitials>docelic</authorinitials>
			<revremark>
				Improvements; looks fine now.
			</revremark>
		</revision>
	</revhistory>
</artheader>


<!-- BODY STARTS HERE -->
<sect1 id="intro" xreflabel="Introduction">
<title>Introduction</title>
<para>
Released under the GNU GPL license.
</para>

<para>
You should read this guide after you successfully install Debian GNU system on your computer.
</para>
<para>
It is a step-by-step document which should answer most of your questions and help you build a sane mindset to continue on your own; I am known for repeating that the idea and logic count, not the exact implementation or usage details. 
</para>
<note><title>Please Note:</title>
<para>
This guide could seem a bit too long, especially if you're reading the all-in-one html version. Please be self-determined and patient, <emphasis>you</emphasis> are the one who will benefit from reading. I tried to avoid sentences which wouldn't make you any smarter.
</para>
</note>
<para>
The guide should be a balanced mix bewteen the administrator's and the user's guide; it is probably too broad for those who belong in either of the two extreme categories. The approach I used should fit home users best - people who do have a Debian installation and a root access at hand, and want to learn and experiment.
</para>
<para>
We will properly define basic terms, explain the system design goals, cover the most important end-user issues and show many command line examples. Since this is a Debian guide, we will not hesitate to use Debian-specific features and commands, but note that most of it (ideologically, at least) applies to other Linux or UNIX systems as well. Finally, by saying this is a beginner's guide, we definitely don't restrict ourselves to UNIX basics, I believe the guide is hiding many beautiful details that even experienced users might find useful (or amusing :)
<para>
Please note that all the fine information presented here can also be found in respective packages' documentation and is more detailed and comprehensive there. Therefore, it is implicitly suggested to read official software and system documentation in combination with this guide (manual pages for dpkg and apt are perfect to show there's much more of it than we mention here).
<ulink url="http://www.debian.org">www.debian.org</ulink> and <ulink url="http://www.tldp.org/">www.tldp.org</ulink> (former linuxdoc), /usr/{<ulink url="file:///usr/doc/">doc</ulink>, <ulink url="file:///usr/share/doc/">share/doc</ulink>, <ulink url="file:///usr/local/share/doc/">local/share/doc</ulink>} directories and the man and info pages on your system are generally valuable resources.
</para><para>
After you finish this guide (which should help you start moving somewhere :), you should probably read interesting manuals available from Debian's <ulink url="http://www.debian.org/doc/manuals">documentation directory</ulink>.
</para>

<sect2 id="intro-official-site" xreflabel="The official distribution sites">
<title>Official download sites</title>
<para>
Try some of those:
</para><para>
<ulink url="http://www.linuks.mine.nu/~docelic/debguide/">http://www.linuks.mine.nu/~docelic/debguide/</ulink> (primary)
</para><para>
<ulink url="http://65.105.188.108/~docelic/debguide/">http://65.105.188.108/~docelic/debguide/</ulink>
</para><para>
<ulink url="http://teleport.medri.hr/~docelic/debguide/">http://teleport.medri.hr/~docelic/debguide/</ulink>
</para><para>
<ulink url="http://213.143.79.69/~docelic/debguide/hands-on-debian-guide.html">http://213.143.79.69/~docelic/debguide/</ulink>
</para>
<para>
Anyway, my email is working now (docelic-AT-mail.inet.hr), so feel free to ask for a download location, if all URLs fail :)
</para>
</sect2>

<sect2 id="intro-acknowledgements" xreflabel="Acknowledgements">
<title>Acknowledgements</title>
<itemizedlist>
<listitem><para>
Walter Echarri &lt;wecharri-AT-infovia.com.ar&gt;: the Spanish translation, extensive proof-reading, numerous grammar/style corrections, and motivation. Thanks Wally ;)
</para></listitem>
<listitem><para>
G&uuml;rkan Seng&uuml;n (gurkan-AT-linuks.mine.nu) for various good tips, suggestions and links (and hosting the guide!).
</para></listitem>
</itemizedlist>
</sect2>
</sect1>

<!-- CONVENTIONS -->
<sect1 id="conventions" xreflabel="Conventions">
<title>Conventions</title>
<itemizedlist>
<listitem><para>
All system commands are written in "command"-style (<command>free, top, ps</command>) and optionally given in single quotes ('<command>rm</command>').
</para></listitem>

<listitem><para>
All package, file and directory names are <emphasis>emphasized</emphasis> and start with / (slash) or ~ (tilde): <emphasis>/etc/init.d/, ~/.bash_profile</emphasis>
</para></listitem>

<listitem><para>
Symbols like [PID] indicate you should replace [PID] with real PID value: kill -9 [PID]
</para></listitem>

<listitem><para>
Inside chapters, text between [ and ] brackets provides short explanations, like this: [You see which fields have to be incremented]
</para></listitem>

<listitem><para>
In code and command-line examples, all user input is prefixed with $ (for user commands) or # (for commands which require root permissions). Program output is edited for brevity and has no prefix. While this might prevent you from directly copy-pasting the instructions to your shell, it is always a good thing to use your brain and ponder while re-typing.
</para></listitem>

<listitem><para>
UNIX, GNU, Debian and Linux are words that can sometimes, depending on the context, be used interchangeably. I have listed them here in a specific order, with UNIX being the most general. Throughout the guide, I try to always use the word with the broadest scope, for which a given note applies. [e.g. We would talk about the UNIX command line, GNU tools, Debian-way to do things and Linux process management].
</para></listitem>

</itemizedlist>
</sect1>


<!-- BASIC THEORY -->
<sect1 id="theory" xreflabel="Basic Theory">
<title>Basic theory</title>
<para>
Let's use this chapter to identify some common misinterpretations and properly define the terms we will use everywhere in this document. We'll start with general terms, such as UNIX, GNU or Free Software, then say something about the Debian Project itself, and finish the chapter with an explanation of some of the most frequent terms you will be encountering in your future Debian GNU life.
</para><para>
So, let's start ...
</para>

<!-- UNIX, Linux -->
<sect2 id="theory-UNIX" xreflabel="UNIX, Linux">
<title>UNIX</title>

<para>
In earlier versions of this document, I used to mention that UNIX was a common name for a group of superior operating systems which shared most of the key design ideas. While there was nothing wrong with the statement, I went to search the Internet for some more formal explanations and here they are:
</para><para>
Short introduction from the <ulink url="http://www.ugu.com/">UGU</ulink> site:
</para>
<blockquote>
<para>
UNIX - /yoo'niks/ Plural "Unices". An interactive time-sharing operating system invented in 1969 by Ken Thompson after Bell Labs left the Multics project, originally so he could play games on his scavenged PDP-7. Dennis Ritchie, the inventor of C, is considered a co-author of the system.
</para>
</blockquote>
<para>
Similar and more detailed description from <ulink url="http://searchsolaris.techtarget.com">searchSolaris</ulink>:
</para>
<blockquote>
<para>
UNIX (often spelled "Unix" in news media) is an operating system  that originated at Bell Labs in 1969 as an interactive time-sharing system. Ken Thompson and Dennis Ritchie are considered the inventors of UNIX. The name (pronounced YEW-nihks) was a pun based on an earlier system, Multics. In 1974, UNIX became the first operating system written in the C language. UNIX has evolved as a kind of large freeware  product, with many extensions and new ideas provided in a variety of versions of UNIX by different companies, universities, and individuals.
</para><para>
Partly because it was not a proprietary operating system owned by any one of the leading computer companies and partly because it is written in a standard language and embraced many popular ideas, UNIX became the first open or standard operating system that could be improved or enhanced by anyone. A composite of the C language and shell (user command) interfaces from different versions of UNIX were standardized under the auspices of the IEEE as the Portable Operating System Interface (POSIX ). In turn, the POSIX interfaces were specified in the X/Open Programming Guide 4.2 (also known as the "Single UNIX Specification" and "UNIX 95"). Version 2 of the Single UNIX Specification is also known as UNIX 98. The "official" trademarked UNIX is now owned by the The Open Group, an industry standards organization, which certifies and brands UNIX implementations.
</para>
</blockquote>

<para>
I believe there <emphasis>is</emphasis> something about UNIX people. What confirmed my suspicions was also the <ulink url="http://www.insecure.org/stf/scoville_UNIX_as_literature.txt">There's something about UNIX people</ulink> article I found sometime before the year 2000. The other inspiring URL would definitely be the <ulink url="http://www.multicians.org">Multics</ulink> archive.
<!--
, <ulink url="http://www.pbm.com/~lindahl/real.programmers.html">Real Programmers don't use Pascal</ulink>, <ulink url="http://www.multicians.org/thvv/realprogs.html">Real Programmers don't write specs</ulink>, and the <ulink url="http://www.pbm.com/~lindahl/mel.html">Story of Mel</ulink>.
-->
</para><para>
However, weird things happen when UNIX people go crazy.
</para><para>
I found an <ulink url="http://jmo.oglesbyfamily.net/cunix.html">obscure note</ulink>, hinting UNIX was actually an April Fools prank kept alive for over 20 years.
</para><para>
I even found an <ulink url="http://catalog.com/hopkins/unix-haters/login.html">UNIX Haters</ulink> website.
</para><para>
Some people expressed their frustrations on their users and effectively became <ulink url="http://bofh.ntk.net/Bastard.html">The Bastard Operators from Hell</ulink>.
</para><para>
Some found solace in weird domain names (specifically, the <ulink url="http://www.0100101110101101.org/">http://www.0100101110101101.org/</ulink>, and the <ulink url="http://www.aunt-tillie.org">Aunt Tillie's website</ulink>, put together by her minion Melvin).
</para><para>
Some joined the Microsoft's anti-linux campaign and wrote the cute <ulink url="http://www.microsoft.com/windows/Embedded/sak/evaluation/compare/advantage.asp">competitive comparison</ulink> reports.
</para><para>
Some decided they couldn't go on anymore and turned to <ulink url="http://www.lpl.arizona.edu/~vance/www/vaxbar.html">serving beverages from Digital's VAX bars</ulink>.
</para><para>
Some even thought they finally had <ulink url="http://www.wehavethewayout.com">The Way Out</ulink>, but were ridiculed by those who had <ulink url="http://www.wehavethewayin.com">The Way In</ulink> shortly after.
</para><para>
And when we thought it was bad enough, we met the <ulink url="http://www.bumperdumper.com/">uncle Booger and his patented Bumper Dumper "invention".</ulink>
</para><para>
You can't say you haven't been warned ...
</para>
</sect2>





<!-- GNU, LINUX, Free Software, Open Source -->
<sect2 id="theory-gnu-linux" xreflabel="GNU, Linux, Free Software, Open Source">
<title>GNU, Linux, Free Software, Open Source</title>
<para>
<!--
<mediaobject>
<imageobject>
<imagedata fileref="images/rmstallman.jpg" format="jpg">
</imageobject>
<imageobject>
<imagedata fileref="images/rmstallman.eps" format="eps">
</imageobject>
</mediaobject>
-->
Richard Stallman, an MIT hacker, started an initiative to create a completely free operating system. Among other things, his decision was based on frustrations and problems he saw in non-disclosure agreements. They once prevented his colleague from giving him the source code for a laser printer driver (Stallman wanted to include automatic paper-jam notification features).
</para><para>
Highly motivated to do The Right Thing (tm), he later quit the job at MIT (so they couldn't possibly claim copyright on his work) and in 1984 he started the <ulink url="http://www.gnu.org">GNU</ulink> (Gnu's Not UNIX) project, whose goal was to protect freedom and supply users with full-featured free software packages for their computers. GNU is a wonderful effort which could affect even non computer-related areas.
</para><para>
You can see the <ulink url="http://groups.google.com/groups?selm=771%40mit-eddie.UUCP">original Stallman's announcement</ulink> from Sep 27, 1983 / 10:35:59 PST in the excellent <ulink url="http://www.google.com||google's] excellent [http://groups.google.com">Google Groups</ulink> archive!
</para>
<para>
All the way back in 1994, Peter van der Linden wrote the following in his book &ldquo;Expert C Programming; Deep C Secrets&rdquo; (ISBN 0-13-177429-8):
</para>
<blockquote>
<para>
The Free Software Foundation is a unique organization founded by ace MIT hacker Richard Stallman. By the way, we use &ldquo;hacker&rdquo; in the old benevolent sense of &ldquo;gifted programmer&rdquo;; the term has been debased by the media, so outsiders use it to mean &ldquo;evil genius&rdquo;. Like the adjective <emphasis>bad</emphasis>, &ldquo;hacker&rdquo; how has two opposing meanings, and you have to figure it our from the context.
</para>
<para>
Stallman's Free Software foundation was founded on the philosophy that software should be free and freely available to all. FSF's charter is &ldquo;to eliminate restrictions on copying, redistribution, understanding and modification of computer programs&rdquo; and their ambition is to create a public-domain implementation of UNIX called GNU (it stands for &ldquo;GNU's Not UNIX&rdquo;. Yes, really).
</para>
<para>
Many computer science graduate students and others agree with the GNU philosophy, and have worked on software products that FSF packages and distributes for free. This pool of skilled labor donating their talent has resulted in some good software. One of the FSF's best products is the GNU C compiler family. gcc is a robust, agressive optimizing compiler, available for many hardware platforms and sometimes better than the manufacturer's compiler.
</para>
</blockquote>
<para>
GNU developers have re-written all the neccessary system tools and utilities (released as Free Software - under the GNU GPL licence), and they only needed a kernel (operating system core) to accomplish the initial goal.
</para>
<para>
Independently, in 1991, Linus Torvalds from Helsinki University announced his first public release of the kernel he was working on - Linux. He was a student back then, and wanted to create a cheap alternative to high-priced UNIX systems, which would run on PC (i386) compatible machines. Combining the Linux kernel and GNU tools, the dream came true - free GNU/Linux system.  Linux itself (the kernel) was written from scratch (from zero)  and was one of the first free <emphasis>UNIX-like</emphasis> variants which, supported by the great GNU community and their software, got the Free Software movement really going.
</para><para>
However, there were other efforts, such as those by the BSD people, who still had problems with the licensing issues and copyrights, but they have rewritten all the parts in question and released free BSD variants: FreeBSD, NetBSD and OpenBSD (forked out from NetBSD by Theo de Raadt). NetBSD is known as the most portable operating system, while OpenBSD is appreciated among computer security people.
</para>

<note><title>Please Note:</title>
<para>
Linux (or other free operating systems today) picked up the best from the UNIX world but they have many end-user advantages over orthodox UNIX machines. Given the design and philosophy, it is worth pointing out that absolutely nothing is impossible with Free Software - it's only a matter of skills.
</para>
</note>
<para>
Open Source is a somewhat newer term which was generally accepted to help promote Free Software in commercial environments. It relies only on practical benefits of open source code (quality, reliability, cost of maintenance) and has no greater philosophy behind it.
</para>
<important><title>Important!</title>
<para>
Read more about the Free Software, Open Source and the <emphasis>correct interpretation of the word 'free'</emphasis> on the Debian's <ulink url="http://www.debian.org/intro/free">"What Does Free Mean?"</ulink> page.
</para>
</important>
</sect2>






<sect2 id="theory-thehurd" xreflabel="The Hurd">
<title>
GNU kernel - The Hurd
</title>
<para>
It is interesting to mention that Linux is a monolithic kernel and shares many ideas with his UNIX counterparts. However, the <ulink url="http://www.gnu.org">GNU</ulink> people have a different vision on how kernels should look like and they are working on <ulink url="http://hurd.gnu.org">The Hurd</ulink> microkernel. Others are working on a Debian GNU/Hurd variant, and you can see the current status or download it from the <ulink url="http://www.debian.org/ports/hurd/">Debian GNU/Hurd port</ulink> page.
</para>
<para>
Monolithic- and micro- kernels are fundamentally different, and there's been much of debate if microkernels would ever prove useful in real-life application. Linus Torvalds is constantly bashing microkernel operating systems ("just say NO to drugs, and maybe you won't end up like The Hurd people"), but that is a total bullshit, see <ulink url="http://www.qnx.com">QNX</ulink> for an example of a powerful, mature, UNIX microkernel. Alan Cox, the maintainer of the production tree of the Linux kernel (with more sympathies for The Hurd), <ulink url="http://www.softpanorama.org/People/Cox/index.shtml">once pointed out</ulink> The Hurd design was more about Richard Stallman's idea about how a system should work to promote community than about high perfomance OS design. In my personal opinion, The Hurd and microkernels in general offer so many advantages over the traditional UNIX kernels; their time is yet to come! If you are interested in getting more information on The Hurd, don't miss the popular <ulink url="http://www.gnu.org/software/hurd/hurd-paper.html">hurd-paper</ulink> and <ulink url="http://www.gnu.org/software/hurd/hurd-talk.html">hurd-talk</ulink> documents.
</para>
</sect2>





<sect2 id="theory-debian" xreflabel="The Debian GNU system">
<title>
The Debian GNU system, its design goals and basic ingredients
</title>
<!-- <sect3 id="debian-origins" xreflabel="Debian origins">
<title>
The Debian GNU origins
</title> -->
<para>
Let's quote something from the official <ulink url="http://www.debian.org/intro/about">About Debian</ulink> page:
</para>
<blockquote>
<para>
Debian was begun in August 1993 by Ian Murdock, as a new distribution which would be made openly, in the spirit of Linux and GNU. Debian was meant to be carefully and conscientiously put together, and to be maintained and supported with similar care. It started as a small, tightly-knit group of Free Software hackers, and gradually grew to become a large, well-organized community of developers and users.
</para><para>
Since many people have asked, Debian is pronounced 'deb ee n'. It comes from the names of the creator of Debian, Ian Murdock, and his wife, Debra.
</para><para>
Debian is produced by nearly one thousand developers spread around the world who volunteer in their spare time. Few of the developers have actually met in person. Communication is done primarily through e-mail (mailing lists at lists.debian.org) and IRC (#debian channel at irc.debian.org).
</para><para>
The Debian Project is an association of individuals who have made common cause to create a free operating system. This operating system that we have created is called Debian GNU/Linux, or simply Debian for short.
</para><para>
An operating system is the set of basic programs and utilities that make your computer run. At the core of an operating system is the kernel. The kernel is the most fundamental program on the computer and does all the basic housekeeping and lets you start other programs.
</para><para>
Debian systems currently use the Linux kernel. Linux is a completely free piece of software started by Linus Torvalds and supported by thousands of programmers worldwide.
</para><para>
However, work is in progress to provide Debian for other kernels, primarily for the Hurd. The Hurd is a collection of servers that run on top of a microkernel (such as Mach) to implement different features. The Hurd is free software produced by the GNU project.
</para><para>
A large part of the basic tools that fill out the operating system come from the GNU project; hence the names: GNU/Linux and GNU/Hurd. These tools are also free.
</para><para>
Of course, the thing that people want is application software: programs to help them get what they want to do done, from editing documents to running a business to playing games to writing more software. Debian comes with over 8710 packages (precompiled software that is bundled up in a nice format for easy installation on your machine) -- all of it free.
</para><para>
It's a bit like a tower. At the base is the kernel. On top of that are all the basic tools. Next is all the software that you run on the computer. At the top of the tower is Debian -- carefully organizing and fitting everything so it all works together.
</para><para>
You may be wondering: why would people spend hours of their own time to write software, carefully package it, and then give it all away? The answers are as varied as the people who contribute. Some people like to help others. Many write programs to learn more about computers. More and more people are looking for ways to avoid the inflated price of software. A growing crowd contribute as a thank you for all the great free software they've received from others. Many in academia create free software to help get the results of their research into wider use. Businesses help maintain free software so they can have a say in how it develops -- there's no quicker way to get a new feature than to implement it yourself! Of course, a lot of us just find it great fun.
</para><para>
Debian is so committed to free software that we thought it would be useful if that commitment was formalized in a written document. Thus, our <ulink url="http://www.debian.org/social_contract">Social Contract</ulink> was born.
</para>
</blockquote>
<!-- </sect3> -->
</sect2>





<sect2 id="theory-freq" xreflabel="Frequently used terms">
<title>
Frequently used terms
</title>
<sect3 id="theory-freq-dpkg" xreflabel="Dpkg, apt, dselect, tasksel">
<title>
Dpkg, apt, dselect, tasksel
</title>
<variablelist>
<varlistentry>
<term>
dpkg
<listitem><para>dpkg  is a medium-level tool to install, build, remove and manage Debian GNU/Linux packages. dpkg itself is controlled entirely via command line parameters, which  consist  of  exactly  one  action  and zero or more options. The action-parameter tells dpkg what  to  do  and options control the behavior of the action in some way.  
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
apt
<listitem><para>is a management system for software packages and includes apt-get, apt-cache and apt-cdrom tools. apt-get's strengths are smooth software upgrades, automatic dependency calculation and general convenience.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
dselect
<listitem><para>is a ncurses (text) frontend to dpkg. It may have more features than apt-get, but requires some time to get used to it (and it's not always as efficient as apt-get would be).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
tasksel
<listitem><para>allows you to select whole program categories at once (such as, &ldquo;install games&rdquo;).
</para>
</listitem>
</varlistentry>
</variablelist>
</sect3>
<sect3 id="theory-freq-manpages" xreflabel="Manual and info pages">
<title>
Manual and info pages
</title>
<variablelist>
<varlistentry>
<term>
man
<listitem><para>(as in manual) pages offer uniform interface to documentation under UNIX. For example, if the program is called <command>mkdir</command> and I mention it somewhere but you don't know what does it do, type 'man mkdir' and find out.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
info
<listitem><para>is GNU's way to document things. Some of the serious GNU tools have only short man pages, while the real documentation is hidden in info pages.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect3>
<sect3 id="theory-freq-root" xreflabel="System administrator, superuser, root">
<title>
System administrator, superuser, root
</title>
<para>
Terms all referring to the administrative account or an official person which has the privileges to do anything he likes (yes, that includes deleting all your files, locking you out of the system and reporting your real earnings to the IRS :). Don't confuse with '<link linkend="theory-freq-rootdir">root directory</link>' below.
</para>
</sect3>
<sect3 id="theory-freq-homedir" xreflabel="Home directory">
<title>
Home directory
</title>
<para>
When you successfully authenticate with the system, you get logged-in, and you enter your 'home directory' under which you have full control to read, write and delete files (you don't have such permissions on the rest of the system). To see which directory it is, type 'pwd' (it could look something like <emphasis>/home/your_name</emphasis>). Wherever you are, type just 'cd' to get back to your home dir. The 'tilde' (~) is a special character that expands to your home directory (try '<command>echo ~</command>' or '<command>vim ~/.bashrc</command>').
</para>
</sect3>
<sect3 id="theory-freq-rootdir" xreflabel="The root directory">
<title>
Root directory
</title>
<para>
In UNIX, disk partitions are visible (we say they are "mounted") in normal directories, and the base directory is always "/", called the "root directory". So for example, in Windows you would have disks like C: and D: but in UNIX (and Linux), you connect them to directories, so your D: disk might be mounted to /mnt/windisk-D directory under Linux (the location is arbitrary, of course).
</para>
</sect3>
<sect3 id="theory-freq-etc" xreflabel="The /etc directory">
<title>
/etc
</title>
<para>
Directory /etc contains the configuration files for your system. If someone tells you to edit the syslog's config, it means you should go to the <emphasis>/etc/</emphasis> directory and edit the <emphasis>syslog.conf</emphasis> file. As a general rule, most packages have a config file which is named <emphasis>&lt;package&gt;.conf</emphasis>, or store their config files in <emphasis>/etc/&lt;package&gt;/</emphasis> directory.
</para>
<note><title>Please Note:</title>
<para>
For a complete description of the filesystem layout and the system directories you see, check out the <ulink url="http://www.debian.org/doc/manuals/user/ch-files.html#s-files-structure">Files structure</ulink> subsection from the Debian User Reference Manual.
</para>
</note>
</sect3>
<sect3 id="theory-freq-proc" xreflabel="The /proc directory">
<title>
/proc
</title>
<para>
This is a virtual directory which looks like all the others on your system, but its dynamic content is served directly from kernel, and not from files on your disk. It is provided as a convenience in kernel-user communication (in both directions, although it was designed read-only in its early stages), and holds kernel- and process-related data. Writable files are used to tune system behavior.
</para>
</sect3>
<sect3 id="theory-freq-binary" xreflabel="Binary">
<title>
Binary
</title>
<para>
Binary is a common name for any file or data in a binary (two-digit) format. It is often a synonym for an executable file. I could say something like "where's the ttysnoop binary?" and the answer would be "the binary is located in /usr/sbin/ directory".
</para>
</sect3>
<sect3 id="theory-freq-image" xreflabel="Image">
<title>
Image
</title>
<para>
This term mostly does not refer to a picture or drawing, but to a raw, low-level data. For example, the data cdrom contains the ISO9660 filesystem and some files on it.  You could use the traditional UNIX <command>dd</command> utility to create an image of that cdrom on hard disk (the output would, of course, be a single raw file, a direct copy of bits from the original media); it also means that the file would look like a valid device and you could even mount it locally (using the 'loop' option).
</para>
</sect3>
<sect3 id="theory-freq-daemon" xreflabel="Daemon">
<title>
Daemon
</title>
<para>
A system process which runs in background, normally for a long period of time, and is dedicated to servicing user requests. Examples of daemons are httpd (Apache), telnetd, ftpd (ProFtpd) or sshd (Openssh).
</para>
</sect3>
<sect3 id="theory-freq-x" xreflabel="X11, XFree86">
<title>
X11R6, XFree86
</title>
<para>
X11R6 (the "XWindow System") is an industry standard for windowing applications. XFree86 is an open-source implementation of the X11 protocol used by most free operating systems today (see <ulink url="http://www.xfree86.org">XFree86</ulink> website).
</para>
</sect3>
<sect3 id="theory-freq-rms" xreflabel="RMS">
<title>
RMS
</title>
<para>
Richard Matthew <ulink url="http://stallman.org">Stallman</ulink> (see <ulink url="images/rmstallman.jpg">picture</ulink>), ace MIT hacker, founder of the Free Software Foundation.
</para>
</sect3>
<sect3 id="theory-freq-curses" xreflabel="curses">
<title>
curses
</title>
<para>
The curses (or the new, ncurses) library has nothing to do with cursing, it is a set of routines which gives the user a terminal-independent method of updating character screens with reasonable   optimization.    Linux  implementation  is  ``new curses'' (ncurses) and is  the  approved  replacement  for 4.4BSD classic curses, which has been discontinued.
</para><para>
So, when we say apt-setup is a ncurses application, we mean it has a nice textual user interface with windows, menus and buttons. Ncurses applications are generally very convenient and nice to use. I've found a link to the <ulink url="http://web.cs.mun.ca/~rod/ncurses/ncurses.html">ncurses programming tutorial</ulink>.
</para>
</sect3>
<sect3 id="theory-freq-epoch" xreflabel="The UNIX Epoch">
<title>
The UNIX Epoch
</title>
<para>
The time and date corresponding to 0 in an operating system's clock and timestamp values. Under most UNIX versions the epoch is 00:00:00 GMT, January 1, 1970; under VMS, it's 00:00:00 of November 17, 1858 (base date of the U.S. Naval Observatory's ephemerides); on a Macintosh, it's the midnight beginning January 1 1904.
</para><para>
System time is measured in seconds or ticks past The Epoch.
</para><para>
Weird problems may ensue when the clock wraps around, which is not necessarily a rare event; on systems counting 10 ticks per second, a signed 32-bit count of ticks is good only for 6.8 years. The 1-tick-per-second clock of UNIX is good only until January 18, 2038, assuming at least some software continues to consider it signed and that word lengths don't increase by then.
</para>
</sect3>
</sect2>
</sect1>




<!-- BASIC SYS MANAGEMENT -->
<sect1 id="sysmgmt" xreflabel="Basic system management">
<title>Basic system management and common administration tasks</title>
<para>
This is the first chapter where we actually touch the system. As usual, we will start with basic topics, such as software installation or the machine shutdown process, then cover the hardware configuration principles (including the graphical X Window System), suggest generally good things to do with fresh Debian installations and provide help and usage examples for some of the optional software packages.
</para>

<sect2 id="sysmgmt-pkg" xreflabel="Package management">
<title>Package management</title>
<para>
The first thing we will take a closer look at is the Debian's package management system. We'll take a tour of dpkg, apt and other package management related tools.
</para>
<note><title>Please Note:</title>
<para>
As many have asked, all the backends or frontends (dpkg, apt-get, synaptic, aptitute, dselect, ...) <emphasis>do</emphasis> use the same package database, of course. So yes, this means that changes made by one are seen by other tools, and you don't have to restrict yourself to using just one of them.
</para>
</note>

<sect3 id="sysmgmt-pkg-dpkg" xreflabel="dpkg">
<title>dpkg</title>
<variablelist>
<varlistentry>
<term>
-i vim_6.0.093-1.deb
<listitem><para>install package 'vim', version 6.0.093, Debian revision 1. Two things to note here:
</para>
</listitem>
</varlistentry>
</variablelist>
<orderedlist>
<listitem>
<para>
You need to know where the .deb file is located, and provide the path to it.
</para>
</listitem>
<listitem>
<para>
Dpkg does not check for dependencies so vim could be unpacked, but its configuration would be delayed until you install all the required packages (which is a boring and generally stupid job to do manually; see <command>apt-get</command> below).
</para>
</listitem>
</orderedlist>
<variablelist>
<varlistentry>
<term>
-r vim
<listitem><para>Remove package vim if there are no installed programs that depend on vim; leave configuration files on the system.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--purge vim
<listitem><para>Remove package vim and all its configuration files.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--configure vim
<listitem><para>Configure package vim.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--configure --pending
<listitem><para>Configure all pending packages.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--get-selections
<listitem><para>Retrieve current package states from dpkg database.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--set-selections
<listitem><para>Set package states. Accepts output generated from the option above. Of course, it can also be used on a per-package basis; <command>echo &ldquo;vim hold&rdquo; | dpkg --set-selections </command>would set package <emphasis>vim</emphasis> 'on hold'. Once you load the list, use <command>apt-get dselect-upgrade</command> to actually make the packages [de]install on the system.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--force-depends
<listitem><para>Option which could be used everywhere with dpkg, but it almost always leads to dpkg database corruption (specifically, version mismatches) and total dependency chaos. If you later plan to use apt-get, never use this option as it instantly breaks apt (you can, however, use 'apt-get -f install' to fix the mess).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
-l
<listitem><para>produce package list
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
-S /path/to/file
<listitem><para>find out which package does 'file' belong to
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
-L vim
<listitem><para>show all files installed by package vim
</para>
</listitem>
</varlistentry>
</variablelist>
</sect3>

<sect3 id="sysmgmt-pkg-dpkg-reconfigure" xreflabel="dpkg-reconfigure">
<title>dpkg-reconfigure</title>
<para>
dpkg-reconfigure is a tool you use to reconfigure debconf-enabled packages (those which use debconf to ask questions and get answers about the local configuration).
</para>
<variablelist>
<varlistentry>
<term>
dpkg-reconfigure gpm
<listitem><para>reconfigure package gpm. Only applicable if the package (gpm in this case) relies on debconf.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
dpkg-reconfigure debconf
<listitem><para>reconfigure debconf itself. You can choose between few types of interactive or non-interactive package configuration modes. Non-interactive mode is very useful if you are performing mass or automated installations.
</para>

<tip><title>Tip</title>
<para>
Sometimes (due to a bug in a specific package's debconf interface), you won't be able to successfuly configure the package; this is very likely to happen from time to time if you use the Debian unstable tree. Common examples would be the 'Accept' buttons which don't actually accept the input or text fields which are always considered empty. A possible hack solution for this kind of problem is to reconfigure debconf to non-interactive, then configure the problematic package and finally turn the debconf back to some sort of interactive mode.
</para>
</tip>
</listitem>
</varlistentry>
</variablelist>
</sect3>

<sect3 id="sysmgmt-pkg-apt" xreflabel="apt">
<title>apt</title>
<para>The <emphasis>apt</emphasis> package provides few command-line tools you need to successfully use <command>apt-get</command>.</para>

<sect4 id="sysmgmt-pkg-apt-setup" xreflabel="apt-setup">
<title>apt-setup</title>
<para>
<command>apt-setup</command> (beware, from the base-config package) opens up a ncurses-based apt configuration tool. Basically, it lets you edit the <emphasis>/etc/apt/sources.list</emphasis> file and then updates the package files (you can do the same manually with <command>apt-get update</command>).
</para><para>
Also check the <emphasis>netselect</emphasis> package, which should select the fastest mirror servers for you automatically.
</para><para>
And we're not finished yet, you can do <command>telnet linuks.mine.nu</command> to retrieve eventually interesting apt sources.
</para>
</sect4>

<sect4 id="sysmgmt-pkg-apt-cdrom" xreflabel="apt-cdrom">
<title>apt-cdrom</title>
<para>
If you have the packages on your cdroms, you will use the <command>apt-cdrom</command> utility to index them.
</para><para>
<screen>
# apt-cdrom add
</screen>
</para>
</sect4>

<sect4 id="sysmgmt-pkg-apt-get" xreflabel="apt-get">
<title>apt-get</title>
<para>
apt-get is an apt package handling utility. It is probably the most convenient way to install or remove packages, as it automatically calculates dependencies and adjusts package lists.
</para><para>
While dpkg allows you to install any .deb file (assuming his dependencies were satisifed), apt-get does not. It uses the file <emphasis>/etc/apt/sources.list</emphasis> as its list of 'package sources'; it parses them and creates a big list of all available packages. So whatever you do, it is restricted to packages already known to apt. This is both powerful and elegant way to deal with package management, some of the complicated tasks (such as package upgrades or whole distribution release upgrades) become so easy with Debian GNU that you hardly believe it!
</para>
<variablelist>
<varlistentry>
<term>
update
<listitem><para>Retrieve and update the package lists. Call this every time you change the <emphasis>/etc/apt/sources.list</emphasis> file, or on a daily basis if you use the remote apt sources (those that might update their contents).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
install vim
<listitem><para>Install package vim. <emphasis>apt</emphasis> uses its internal database to find out where is the package located (it could be on some of your CDs, the Internet or local apt mirror).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
apt-get install vim=6.0.093-1
<listitem><para>The same as above but installs version 6.0.093-1 specifically (use <command>apt-cache</command> to see available versions for a package).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--reinstall install vim
<listitem><para>Self-explanatory now.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
remove vim
<listitem><para>Remove package vim (and other packages which strictly depend on it).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--purge remove vim
<listitem><para>Completely remove package vim and other packages which strictly depend on it. This also removes config files, which normally stay on the system.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
upgrade
<listitem><para>Upgrade packages on the system. Whether there are any candidates for upgrade depends on the apt mirror and your local database (for example, if you set a package on Hold, it will be skipped). You can use the <command>-s</command> switch to check out which packages would actually get upgraded.
</para><para>
Some time ago, I read about RedHat's tool which allowed Internet updates, but required you to first send a list of all packages you have on your system (so that RedHat server could compare it to the database and then report new packages available). Apt doesn't work that way - it anonymously grabs whole lists and then locally decides which packages you are interested in. You would think that's the only reasonable way to do an update, but then you see people from RedHat ...
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
-f install
<listitem><para>fix Debian installation; perform neccessary steps to get internal database back in order. Handy when you previously mess it up with dpkg --force-depends (although it usually means package downgrades or mass deinstalls).
</para>
</listitem>
</varlistentry>
</variablelist>
</sect4>

<sect4 id="sysmgmt-pkg-apt-cache" xreflabel="apt-cache">
<title>
apt-cache
</title>
<para>
apt-cache can be used to query the dpkg package database.
</para>
<variablelist>
<varlistentry>
<term>
show vim
<listitem><para>show internal information on package vim (version, sizes, dependencies, conflicts, suggests, description ...)
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
search vim
<listitem><para>search the database for package names or descriptions that contain 'vim'.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
--names-only
<listitem><para>only search package's Name field (otherwise it looks in all fields).
</para>
</listitem>
</varlistentry>
</variablelist>
</sect4>
<sect4 id="sysmgmt-pkg-apt-dotty" xreflabel="Graphically representing package dependencies">
<title>
Graphically representing package dependencies
</title>
<para>
<command>apt-cache dotty</command> takes a list of packages on the command  line and  gernerates  output  suitable  for use by dotty from the <ulink url="http://www.research.att.com/sw/tools/graphviz/">GraphVis</ulink> package. The result will be  a  set  of  nodes  and edges  representing  the  relationships between the packages. By default the given packages will  trace out all dependent packages which can produce a very large graph.  This can be turned off by setting the APT::Cache::GivenOnly option (<command>man apt-preferences</command>).
</para><para>
The  resulting nodes will have several shapes, normal packages are boxes, pure  provides  are  triangles,  mixed  provides  are  diamonds, hexagons are missing packages. Orange boxes mean  recursion  was stopped  [leaf  packages],  blue  lines  are  pre-depends, green lines are conflicts.
</para><para>
<!-- TODO Fix this -->
<screen>
# apt-cache dotty vim | dot -Tps 
# apt-cache dotty $(dpkg --get-selections | grep -v deinstall | awk 'print $1') | dot -Tps packgraph.ps
</screen>
</para>
<caution><title>Caution</title>
<para>
dotty cannot graph larger  sets  of  packages.
</para>
</caution>
</sect4>
</sect3>
<sect3 id="sysmgmt-pkg-grep-dctrl" xreflabel="grep-dctrl">
<title>grep-dctrl</title>
<para>
The <command>grep-dctrl</command> utility greps Debian control files.
</para><para>
The  grep-dctrl  program can answer such questions as
</para>
<itemizedlist>
<listitem><para>
What is the Debian package foo?
</para></listitem><listitem><para>
Which version  of  the  Debian package  bar  is  now current?
</para></listitem><listitem><para>
Which Debian packages does John Doe maintain?
</para></listitem><listitem><para>
Which  Debian  packages  are  somehow related  to  the  Scheme   programming language?
</para></listitem><listitem><para>
and with some help, Who maintain the essential packages of a Debian system?
</para></listitem></itemizedlist>
<para>
It  is  a  specialised grep program that is meant for processing any file which has the general format of a  Debian package control file, as described in the Debian Packaging Manual.  These include the dpkg available file,  the  dpkg status  file,  and  the  Packages  files on a distribution medium (such as a Debian CD-ROM or an  FTP  site  carrying Debian).
</para><para>
See the usage examples in the grep-dctrl(1) man page.
</para>
</sect3>
<sect3 id="sysmgmt-pkg-debrecsug" xreflabel="debrecsug">
<title>
debrecsug
</title>
<para>
This is yet another tool you can use to see the recommended/suggested packages, and it is not a part of the standard Debian distribution.
</para><para>
<ulink url="http://62.70.58.80/~ew/debian/">erik warendorf's site</ulink>, where I downloaded the script, seems to be down.
</para>
</sect3>
<sect3 id="sysmgmt-pkg-debfoster" xreflabel="debfoster and deborphan">
<title>
debfoster and deborphan
</title>
<para>
Tools to weed out unnecessary Debian packages. Their use is trivial.
</para><para>
For example, do remove all unneccessary packages, you could do:
</para><para>
<screen>
# apt-get --purge remove `deborphan`
</screen>
</para>
</sect3>
<sect3 id="sysmgmt-pkg-dpkg-repack" xreflabel="dpkg-repack">
<title>dpkg-repack</title>
<para>dpkg-repack package provides us with a tool to put an unpacked .deb files back together. It re-creates a .deb file out of a debian package that has already been installed on  your  system.  If  any changes  have  been  made  to  the  package  while  it was unpacked (ie, files in /etc  modified),  the  new  package will inherit the changes.  
</para><para>
This  utility  can  make it easy to copy packages from one computer to another, or  to  recreate  packages  that  are installed  on  your  system, but no longer available elsewhere.
</para><para>
<screen>
# dpkg-repack vim
</screen>
</para>
</sect3>

<sect3 id="sysmgmt-pkg-dpkg-divert" xreflabel="dpkg-divert">
<title>dpkg-divert</title>
<para>dpkg-divert overrides a package's version of a file. File `diversions' are a way of forcing dpkg not to install a  file  into  its location, but to a `diverted' location.  Diversions can be used through the Debian package  scripts to  move  a  file  away  when it causes a conflict. System administrators can also use it to override some  package's configuration  file,  or whenever some files (which aren't marked as 'conffiles') need to be preserved by dpkg,  when installing  a  newer  version  of a package which contains those files.
</para><para>
I used it in our ttysnoop+ssh setup (see below):
</para><para>
<screen>
# dpkg-divert --divert /bin/login.real --add /bin/login
</screen>
</para>
</sect3>

<sect3 id="sysmgmt-pkg-dpkg-statoverride" xreflabel="dpkg-statoverride">
<title>dpkg-statoverride</title>
<para>
<emphasis>stat overrides</emphasis> are the way to tell dpkg to use a different owner  or  mode  for  a  file when a package is installed.  This can be  used  to  force programs  that  are normaly setuid to be installed without a setuid flag, or only executable by a certain group.
</para><para>
See the dpkg-statoverride(8) man page for details.
</para>
</sect3>

</sect2>





<sect2 id="sysmgmt-sysmsgs" xreflabel="Getting familiar with system messages">
<title>Getting familiar with system messages</title>

<para>
It is very important to learn how does the system communicate with its users (or administrators). One can <emphasis>always</emphasis> find the exact source of the problem and take appropriate actions (simple proven-to-be-useful tasks help in almost any situation), so this is why the chapter had priority in the final document layout.
</para>

<sect3 id="sysmgmt-sysmsgs-dmesg" xreflabel="Boot messages">
<title>Boot messages</title>
<para>
During the boot, the system kernel prints out a lot of interesting information (unless the 'quiet' option was passed to it). The copy of the messages is saved in the <emphasis>/var/log/dmesg</emphasis> file (which does not grow with time).
</para><para>
The '<command>dmesg</command>' command, however, will show you the <emphasis>last 4 KB</emphasis> of recent kernel messages.
</para>
</sect3>



<sect3 id="sysmgmt-sysmsgs-syslog" xreflabel="System logging daemon">
<title>System logging daemon</title>
<para>
UNIX machines have a standardized way for programs, applications and daemons to send messages to the global system logger ('<emphasis>syslog</emphasis>'). There are a few syslog implementations, and with Debian you can choose betweeen the default traditional BSD sysklogd, syslog-ng and msyslog.
</para><para>
Each message has an indication of the <emphasis>facility</emphasis> (message source) and severity (importance level). The date, time, host and process information is automatically generated by syslog, and should not be a part of the message itself.
The syslog daemon distributes messages to files, pipes, remote destinations or users, using the schema specified in the <emphasis>/etc/syslog.conf</emphasis> file (for the traditional BSD sysklogd).
</para><para>
All the logs from a vanilla ("out of the box") Debian system are written to files in the <emphasis>/var/log/</emphasis> directory.
</para>
<note><title>Please Note:</title>
<para>
Nothing prevents you from specifying multiple destinations for the same message.
</para>
</note>
<para>
To collect all system messages (for strictly educational purposes :) in a single file, add a line like this in /etc/syslog.conf:
</para><para>
<screen>
*.* TAB /var/log/allmessages
</screen>
</para><para>
[TAB is there to warn you that you really have to press the TAB key, spaces don't do it right]. Then create an empty /var/log/allmessages file (choose your favorite, both variants here do the same):
</para><para>
<screen>
# touch /var/log/allmessages
# > /var/log/allmessages
</screen>
</para><para>
And just reload the sysklogd daemon configuration:
</para><para>
<screen>
# /etc/init.d/sysklogd reload
</screen>
</para><para>
Now go to some idle virtual console, and type (see the tail(1) man page):
</para><para>
<screen>
$ tail -f /var/log/allmessages
</screen>
</para><para>
Do something to your system (for example, logout, login or use 'su' on another console, and watch messages appear!). This is an excellent way to learn more about the system and how it works. Also, you can detect any anomalies and error reports that would otherwise go unnoticed.
</para><para>
If you are writing shell scripts, or modifying your <emphasis>~/.bash_profile</emphasis>, you can use the '<emphasis>logger</emphasis>' command to log your messages via syslog.
</para>
<note><title>Please Note:</title>
<para>
I prefer echoing all messages to /dev/tty12, which makes them easy to check just by switching to the virtual console 12 (Alt+F12). If you are using the X graphical interface most of the time, check out the <emphasis>root-tail</emphasis> package, which monitors log files and prints messages to your root window (the background).
</para>
</note>
</sect3>

<sect3 id="sysmgmt-sysmsgs-ppp" xreflabel="Logging ppp messages">
<title>Logging ppp messages</title>
<para>
It is nice to have all ppp logs go to <emphasis>/var/log/ppp.log</emphasis>; the 'plog' command will then work as expected. The following will add a line to <emphasis>/etc/syslog.conf</emphasis> and restart the <emphasis>sysklogd</emphasis> daemon:
</para><para>
<screen>
# echo "local2.* TAB /var/log/ppp.log" >> /etc/syslog.conf
# /etc/init.d/sysklogd restart
</screen>
</para><para>
The TAB you see actually stands for the TAB key, not the text "TAB".
</para>
</sect3>

</sect2>






<sect2 id="sysmgmt-x" xreflabel="The X Window System, basic principles and Debian setup">
<title>
The X Window System, basic principles and Debian setup
</title>

<sect3 id="sysmgmt-x-xfree" xreflabel="The XFree86 Project, an open-source X Window System implementation">
<title>
The XFree86 Project, an open-source X Window System implementation
</title>
<para>
From <ulink url="http://www.xfree86.org">www.XFree86.org</ulink>:
</para>
<blockquote>
<para>
The XFree86 Project, Inc is the organization which produces XFree86 , a freely redistributable open-source implementation of the X Window System which runs on UNIX(R) and UNIX-like operating systems such as Linux, all of the BSD variants, Sun Solaris x86, Mac OS X (via Darwin), as well as other platforms like OS/2 and Cygwin. 
</para>
<para>
XFree86, the product, provides a client/server interface between display hardware (the mouse, keyboard, and video displays) and the desktop environment while also providing both the windowing infrastructure and a standardized application interface (API). XFree86 is platform-independent, network-transparent and extensible. 
</para>
<para>
With XFree86 a user cannot only choose the desktop environment they prefer, but because we are an open-source project, users can also modify and update their systems as they see best. As XFree86 has always been an unabashed supporter of freedom of the user desktop, so we encourage users to customise and personalise their desktops with the application of their choice, whether it be KDE, GNOME, Enlightenment, Blackbox, AfterStep, fvwm or twm. 
</para>
<para>
Our goal at XFree86 is to have X run on every platform available, including those we do not currently support, as the best windowing system available on that platform.
</para>
</blockquote>
</sect3>

<sect3 id="sysmgmt-x-xstrike" xreflabel="The X Strike Force: XFree86/X Window System support for Debian">
<title>
The X Strike Force: XFree86/X Window System support for Debian
</title>
<para>
Visit the <ulink url="http://www.debian.org/~branden/">X Strike Force</ulink> homepage.
</para>
</sect3>

<sect3 id="sysmgmt-x-inst" xreflabel="XFree86 Installation">
<title>
XFree86 Installation
</title>
<para>
Debian potato (2.2) is shipped with XFree86 version 3.6.6, while Debian woody (3.0) has XFree86 version 4. See current status at the X Strike Force homepage.
</para>
<para>
X4 brings a lot of improvements and is now standard in Debian. There's not much difference from administration perspective, but notes will be put where appropriate.

</para>
<para>
You can install basic X support, the <emphasis>icewm</emphasis> window manager and the <emphasis>wdm</emphasis> display manager with:
</para><para>
<screen>
# apt-get install xserver-xfree86 xbase-clients xfonts-base icewm icewm-themes wdm 	
</screen>
</para>
<note><title>Please Note:</title>
<para>
If you're using X3, do '<command>apt-cache search xserver-</command>' and install the appropriate one instead of xserver-xfree86.
</para>
<para>
wdm is a better-looking equivalent to xdm, the X Display Manager (it opens up graphical login prompts). It is nice to have it, especially if you want to install more window managers, and then select which one to use from the wdm's menu. If you are using Gnome or KDE consider using their native gdm or kdm programs.
</para>
</note>
</sect3>

<sect3 id="sysmgmt-x-cfg" xreflabel="XFree86 Server Configuration">
<title>
XFree86 Server Configuration
</title>
<para>
When you install the packages, the configuration process will start automatically. If you don't get it right the first time, you can always re-run configuration with:
</para>
<para><screen>
# dpkg-reconfigure xserver-common
# dpkg-reconfigure xserver-xfree86
</screen>
</para>
<para>
The interface is very clean and should help you create working XFree configs in no time. In case of problems, inspect the config file (/etc/X11/XF86Config-4 or /etc/X11/XF86Config) manually to make sure you have the right Driver option, and that UseFBDev option is set to false (these are the most common errors).
</para>
</sect3>

<sect3 id="sysmgmt-x-res" xreflabel="Tuning the resolution in X">
<title>
Tuning the resolution in X
</title>
<para>
When you start X, it choses appropriate color depth (usually 8, 16, 24 or 32bit), loads in the list of available resolutions for the given color depth and displays the default one. You can then cycle through defined resolutions with Ctrl+Alt+'+'.
</para>
<para>
All this is set up in /etc/X11/XF86Config-4. Here's an excerpt from the configuration for 16bit colors with default resolution 1024x768:
</para>
<para><screen>
...
Section "Screen"
 ...
 DefaultDepth 16
 SubSection "Display"
   Depth 1
   Modes "1152x864" "1024x768" "800x600" "640x480"
 EndSubSection
 ...
 SubSection "Display"
   Depth 16
   Modes "1024x768" "800x600" "640x480"
 EndSubSection
 ...
EndSection
...
</screen>
</para>
<para>
To explicitly start X with 16bit colors (if there's no DefaultDepth option or it is different), use:
</para>
<para>
<screen>
startx -- -bpp 16
</screen>
</para>
<para>
If you want to further experiment with refresh rates and resolutions, either manually tune VertRefresh, HorizSync and Modeline (in X3 only) definitions in X config file, or see <ulink url="http://www.openbsd.org/faq/faq11.html#XF86">OpenBSD's X tuning guidelines</ulink>.
</para>
<note><title>Please Note:</title>
<para>
You can use Ctrl+Alt+plus_sign/minus_sign to cycle resolutions in runtime.
</para>
</note>
</sect3>

<sect3 id="sysmgmt-x-autod" xreflabel="Device autodetection">
<title>
Device autodetection
</title>
<para>
To take advantage of some kind of device autodetection, see the following three programs:
</para>
<itemizedlist>
<listitem><para>
<emphasis>read-edid</emphasis>, hardware information-gathering tool for VESA PnP monitors
</para></listitem>
<listitem><para>
<emphasis>mdetect</emphasis>, mouse device autodetection tool
</para></listitem>
<listitem><para>
<emphasis>discover</emphasis>, hardware identification system
</para></listitem>
</itemizedlist>
</sect3>

<sect3 id="sysmgmt-x-clisrv" xreflabel="The client-server model">
<title>
The client-server model
</title>
<para>
Since X is a client-server based model (as most other things in Unix), it means you have a whole new domain of features at your disposal. We'll discuss them now.

</para>
<itemizedlist>
<listitem>
<para>
Typical local-user/local-machine session 
</para><para>
When you start X (with <command>startx, xinit</command> or <command>X</command>), it opens up first free virtual console (that is console 7 in most Linux distributions), and starts X server on it (Xserver uses the DISPLAY environment variable to detect the target display, and in this case it is &ldquo;localhost:0&rdquo;; just &ldquo;:0&rdquo; or undefined DISPLAY variable have the same effect). Xserver then starts the window manager of your preference and the desktop screen shows up.
All the files needed are found on your local disk.
You can switch back to your console screens with Ctrl+Alt+F1, F2 etc... To get back to your X display, use Alt+F7. To close X session, either find some form of a Logout button in your window manager, or use Ctrl+Alt+Backspace.

Just as you can have more virtual text consoles, you can have more completely separate X displays on a single display device (of course, even under different usernames):
Start X (with <command>startx&amp;</command> command), then switch back to text console with Ctrl+Alt+F1, and run <command>'startx -- :1&amp;</command>'. Bravo! You have two X sessions running now! Switch between them with Ctrl+Alt+F7 and Ctrl+Alt+F8.
</para>
</listitem>
<listitem>
<para>
Display from remote program on your machine
</para><para>
Let's say you have two machines, Monarch and Denali. You are sitting at Denali, and would like to start some X program on Monarch, but have the display locally on Denali's monitor (Note that this isn't a common file sharing: in our case, the program is really executed on Monarch, only the display is sent to Denali).
We will use one very convenient approach (there are other ways, of course) - we will use <command>slogin</command> program (an alias for <command>ssh</command> actually) to log in to monarch. <command>slogin</command> will set up file .Xauthority and DISPLAY variable automatically, and all we need to do is to start our application. Try <command>xeyes</command>.
Here's an example for convenience: 
</para>
</listitem>
</itemizedlist>
<para><screen>
denali:~$ slogin monarch
Enter password: xxxxx
monarch:~$ echo $DISPLAY
denali:0
monarch:~$ xeyes&
</screen></para>

<note><title>Please Note:</title>
<para>
Note however that you must have the following options enabled for the example above to work: X11Forwarding in <emphasis>/etc/ssh/sshd_config</emphasis> and ForwardX11 in <emphasis>/etc/ssh/ssh_config</emphasis>. To restart the <emphasis>ssh</emphasis> daemon, use <command>/etc/init.d/ssh restart</command>
</para>
</note>

</sect3>

<sect3 id="sysmgmt-x-dri" xreflabel="The Direct Rendering Infrastructure (DRI)">
<title>
The Direct Rendering Infrastructure (DRI)
</title>
<para>
Here's a little introduction from the <emphasis>Documentation/Configure.help</emphasis> file (the <emphasis>kernel-doc-*</emphasis> packages):
</para>
<blockquote>
<para>
AGP (the Accelerated Graphics Port) is a bus system mainly used to connect graphic cards to the rest of the system.
If you have an AGP system, it will be possible to use the AGP features of your 3D rendering video card.
Note that this is the only way to have XFree4/GLX use write-combining with MTRR support on the AGP bus. Without it,
OpenGL direct rendering will be a lot slower but still faster than PIO.
</para><para>
Kernel-level support for the Direct Rendering Infrastructure (DRI) was introduced in XFree86 4.0
(which you <emphasis>do</emphasis> have, if you use Debian Woody (3.0) or newer releases).
</para>
</blockquote>
</sect3>


<sect3 id="sysmgmt-x-notes" xreflabel="XFree86 Notes">
<title>
XFree86 Notes
</title>
<para>
X3 has less drivers and you must install specific drivers for specific groups of graphic cards (for example, xserver-rage128, mach32, mach64, i128, 3dlabs, agx, 8514, s3v etc...). In X4, we solve this by only installing xserver-xfree86, which is modular and loads appropriate modules in runtime. Also, config file is /etc/X11/XF86Config-4 for X4, and just /etc/X11/XF86Config for old X3.
</para>
</sect3>


<sect3 id="sysmgmt-x-troubles" xreflabel="Troubleshooting">
<title>
Troubleshooting
</title>
<itemizedlist>
<listitem>
<para>
Check the <emphasis>/var/log/XFree86.log</emphasis> and <emphasis>~/.xsession-errors</emphasis> files for hints.
</para>
</listitem>
<listitem>
<para>
Edit /etc/X11/XF86Config-4 and search for the line <emphasis>Option "UseFBDev" "true</emphasis>" and turn 'true' to 'false'.
</para>
</listitem>
<listitem>
<para>
If it still doesn't work, edit Driver= config parameter.
</para>
</listitem>
<listitem>
<para>
After you make sure the driver option is ok, but it still doesn't work, try tweaking HorizSync and VertRefresh values. Try with this: HorizSync 30-80 VertRefresh 40-90
</para>
</listitem>
<listitem>
<para>
Make sure you do have some version of a window manager installed, <command>apt-get install icewm</command> should do.
</para>
</listitem>
</itemizedlist>
</sect3>

<sect3 id="sysmgmt-x-wms" xreflabel="Window Managers">
<title>
Window managers
</title>
<para>
Now you have X window system running. Let's make this clear: You need the X server because it knows how to communicate with your hardware and actually display graphics. But that's all it does. How your interface really looks like depends purely on your 'window manager'. If you listened to me, you are probably running icewm, but there are others (when you install them, they become the default or show up in wdm's login menu). Try wmaker, blackbox, afterstep, xfce or enlightenment. Also try <command>twm</command>, at least for historical reasons, to understand the Unix folklore ;)
</para>
<para>
Don't be disappointed by the look of <emphasis>wdm</emphasis> or <emphasis>icewm</emphasis> (tastes difer), you have a plenty of other variants to choose; Definitely check out the <ulink url="http://www.plig.org/xwinman/">Window Managers for X</ulink> website.
</para>
<para>
To get a program which shows you graphical login (so you don't have to log in the console and type 'startx' every time), install package wdm (or any of its relatives; xdm, kdm or gdm). Also, you will be able to select which window manager to use from the wdm's menu.

</para>
<para>
You can also run X without the window manager (usually for testing purposes). Try starting '<command>xinit</command>'.
</para>
</sect3>

<sect3 id="sysmgmt-x-fonts" xreflabel="Fonts for X">
<title>
Fonts for X
</title>
<para>
Fonts you want are found in xfonts-* packages. Type this command to search for them:
</para><para>
<screen>
# apt-cache search xfonts-
</screen>
</para>
<para>
If you are interested in using the Microsoft ttf fonts, there are font servers which can handle them, and I'd recommend you try with xfstt. No fonts come with it since they all have non-free licenses. That means you have to get the ttf fonts yourself, copy them to <emphasis>/usr/share/fonts/truetype/</emphasis>, add FontPath   &ldquo;unix/:7101&rdquo; to /etc/X11/XF86Config, exec '<command>/etc/init.d/xfstt restart</command>' and then restart X.
</para><para>
To browse installed fonts, see the <command>xfontsel</command> and <command>gfontview</command> programs.
</para><para>
Also, check out the <ulink url="http://www.linuks.mine.nu/fonts/readme">http://www.linuks.mine.nu/fonts/readme</ulink> file.
</para>
</sect3>


<sect3 id="sysmgmt-x-gpmx" xreflabel="Gpm (the console mouse driver) and the XFree86">
<title>
Gpm (the console mouse driver) and the XFree86
</title>
<para>
You will most probably have problems with gpm and XFree86 running at the same time. The solution would be to set repeat type to 'raw' in gpm's config and mouse device to <emphasis>/dev/gpmdata</emphasis> in X config file, but that doesn't always give usable results. I prefer to shut down gpm.
</para>
</sect3>

</sect2>




<sect2 id="sysmgmt-vc" xreflabel="Virtual consoles">
<title>Virtual consoles</title>

<sect3 id="sysmgmt-vc-inittab" xreflabel="Virtual consoles setup in /etc/inittab">
<title>Virtual consoles setup in /etc/inittab</title>

<para>
Almost all GNU/Linux distributions are shipped with predefined 'virtual terminals' - completely separated textual screens which are available with left Alt + F1-F6 keystrokes (only 6 consoles are enabled by default). You can also use the command-line method to switch between them - see the <command>chvt</command> command.
</para>
<para>
To add more virtual consoles, edit the file<emphasis>/etc/inittab</emphasis> (as superuser, of course) and add more lines like those:
</para><para>
<screen>
5:23:respawn:/sbin/getty 38400 tty5
6:23:respawn:/sbin/getty 38400 tty6
</screen>
</para><para>
[You can see which fields have to be incremented]. For changes in that file to take effect, exit the text editor and type <command>init q</command>.
</para>
<para>
If you create more than 12 consoles, you won't be able to access them with left Alt (since the last F key you have is 12), so use right Alt key to reach consoles 13 - 24.
You can also use Alt + left_arrow or right_arrow to cycle through open consoles. Alt+print_screen key switches between two last used virtual consoles.
</para><para>
If you are switching from X to the console, you need to use Ctrl+Alt, instead of just Alt.
</para>
<para>
The <command>deallocvt</command> command frees memory still associated with virtual terminals which are no longer in use [by applications, not you of course]. This is not so important anymore, since you probably have plenty of ram and few kilobytes mean nothing to you.
</para>
</sect3>

<sect3 id="sysmgmt-vc-fonts" xreflabel="VGA console font size">
<title>VGA fonts sizes in the console</title>
<para>
If you don't like such big letters in the console, execute this:
</para><para>
<screen>
# lilo -R 'linux vga=ask' ; reboot
</screen>
</para><para>
This would set up LILO parameters on the next boot (<emphasis>linux vga=ask</emphasis>), and <command>reboot</command> the machine (since vga mode can only be set at boot, unless you mess with 'svgatextmode' package - but don't do that). When you find nice vga mode, you should edit <emphasis>/etc/lilo.conf</emphasis> and make it permanent there:
</para>
<screen>
image=/vmlinuz
label=Linux
read-only
# Just add the line below
append="vga=X"
</screen>
<para>
[X is replaced with the actual value you like, try '6' for example]. Then, run 'lilo' to apply changes.
</para><para>
If you see the penguin in the upper left corner of your screen, you are using a framebuffer (VESA mode). In that case, there are more screen modes available to you, see the table on the <ulink url="http://http://www.tldp.org/HOWTO/Framebuffer-HOWTO-5.html#ss5.3">Framebuffer HOWTO</ulink> page.
</para>
</sect3>

<sect3 id="sysmgmt-vc-fontypes" xreflabel="VGA console fonts">
<title>Font types for the console</title>
<para>
Install the <emphasis>fonter</emphasis> package and you will be able to edit/create your own fonts, or use some of the standard ones you get:
</para><para>
<screen>
$ consolechars -f /usr/share/fonter/crakrjak.fnt
$ consolechars -f /usr/share/fonter/elite.fnt
$ consolechars -f iso01.f16
</screen>
</para>
</sect3>


<sect3 id="sysmgmt-vc-ck" xreflabel="The console keymaps">
<title>The console keymaps</title>
<para>
To see current keyboard mappings, you would simply do:
</para><para>
<screen>
$ dumpkeys > keymap
</screen>
</para><para>
After you tune the 'keymap' file to your needs, load it back with the <command>loadkeys</command> command.
</para><para>
To see just how advanced the idea of the Linux console is, run the <command>loadkeys</command> program, and type the following in its prompt:
</para><para>
<screen>
string F1 = "Hello, World!"
[Ctrl+d]
</screen>
</para><para>
Then just press the F1 key to see the consequences.
</para>
</sect3>

</sect2>


<sect2 id="sysmgmt-gh" xreflabel="General notes for hardware support">
<title>
General notes for hardware support
</title>
<para>
Getting a piece of hardware to work is a fairly easy task (although it wasn't so in the past, so always show the due respect for the developer community). Basically, you have to be able to categorize the hardware and know how the specific devices are usually configured under Debian GNU or Linux.
</para>
<itemizedlist>
<listitem><para>
Hard disks and CD Roms are supported by the kernel.
</para></listitem>
<listitem><para>
Sound and network cards are supported by the kernel. Audio settings are saved in a mixer program's config (<command>aumix</command>, for example), and the setup information for the network is in the <emphasis>/etc/network/interfaces</emphasis> file; see interfaces(5) manual.
</para></listitem>
<listitem><para>
Graphic adapters <emphasis>can</emphasis> use the kernel support (mainly for AGP utiliziation and true hardware acceleration) but the drivers are usually the XFree server modules. You configure them by invoking <command>dpkg-reconfigure xserver-xfree86</command>.
</para></listitem>
<listitem><para>
Mice are supported in user space, by the console <emphasis>gpm</emphasis> package, or the graphical X server. The kernel, however, needs to support the port the mouse is connected to (serial, PS/2, USB ...). Use <command>gpmconfig</command> or <command>dpkg-reconfigure xserver-xfree86</command>.
</para></listitem>
<listitem><para>
Modems (true modems, not winmodems) require no special drivers, they are supported by the kernel serial driver which is almost certainly already active on your machine. If you have a winmodem, just forget it (supporting things which are "bad by design" doesn't make much sense in the Debian world). Configure the dial-up account with the <command>pppconfig</command> utility.
</para></listitem>
<listitem><para>
Scanners, digital cameras and USB devices use either kernel or userspace "drivers" (depending on the model and driver design), but the kernel needs to have basic support for them included).
</para></listitem>
</itemizedlist>


<para>
Debian GNU sports a nice tool for kernel module configuration - the <command>modconf</command> utility. However, the whole story with kernel modules is trivial. You have three basic commands (<command>modprobe, rmmod, lsmod</command>) and a bunch of modules in the <emphasis>/lib/modules/`uname -r`</emphasis> directory to choose from. For instance, to load the driver for a 3Com network card and an onboard AMD VIA audio chip, you would do (so, without modconf):
</para><para>
<screen>
# modprobe 3c59x
# modprobe via82cxxx_audio
</screen>
</para><para>
And to make the modules load at each boot, you'd add them to the <emphasis>/etc/modules</emphasis> file.
</para><para>
If you want to use it this way, you must know the module names. Until you get some experience, use <command>modconf</command>.
</para>

<note><title>Please Note:</title>
<para>
If you are planing to compile your own kernel, definitely use the <emphasis>kernel-package</emphasis> helper (specifically, the <command>make-kpkg</command> command), which will save you a lot of trouble. Read the <ulink url="http://http://213.143.79.69/~docelic/debguide/kernel.html">other document</ulink> I wrote, which deals with kernel compilation on Debian GNU.
</para>
</note>
</sect2>



<sect2 id="sysmgmt-cmouse" xreflabel="Enabling the mouse in text consoles">
<title>
Enabling the mouse in text consoles
</title>
<para>
It is nice to have a mouse working in text consoles; you can copy just by selecting the text, and you can paste with buttons 2 or 3.
</para>
<para>
Install the 'gpm' package and it will automatically ask you for configuration. If you want to delay it, or you don't get it right the first time, you can always re-run the config tool later (it's called <command>gpmconfig</command>).
</para>
<para>
Here's an example for you: for my wheel mouse, I answered this to gpmconfig questions:
</para>
<itemizedlist>
<listitem>
<para>
Where is your mouse? /dev/psaux (that's PS2 port, use /dev/ttyS0 or /dev/ttyS1 for serial ports 1 and 2).
</para>
</listitem>
<listitem>
<para>
What type is your mouse? imps2 (most mice work with imps2 or ps2. Try 'ms' or 'bare' for serial mice)
</para>
</listitem>
<listitem>
<para>
responsiveness? *leave empty*
</para>
</listitem>
<listitem>
<para>
repeat protocol? use 'none'
</para>
</listitem>
<listitem>
<para>
additional arguments? *leave empty*
</para>
</listitem>
</itemizedlist>
<para>
Test the config and enjoy.
</para>
</sect2>



<sect2 id="sysmgmt-hdparm" xreflabel="Hard disk throughput">
<title>
Hard disk throughput
</title>
<para>
To see how good can it be, use the <emphasis>hdparm</emphasis> utility, switch to 'single' mode and test it:
</para><para>
<screen>
# apt-get install hdparm
# init s
# sync
# hdparm -tT /dev/hda
# init 2
</screen>
</para><para>
On ~1 Ghz PC machines, you should see cache reads of about 180 MB/sec, and unbuffered disk I/O of about 35MB/sec. Things vary, though. If you see poor performance (it can get as low as 2MB/sec), recompile the kernel and test it after that; you'll most probably see enormous improvements. If you're adventureous, use <command>hdparm</command> and try to fine-tune the hard disk parameters; see if it does any good for you.
</para>
</sect2>


<sect2 id="sysmgmt-vrms" xreflabel="Monitoring non-free software on your machine">
<title>
Monitoring non-free software on your machine
</title>
<para>
<screen>
# apt-get install vrms
</screen>
</para>
</sect2>


<sect2 id="sysmgmt-firewall" xreflabel="Firewalls">
<title>Firewalls</title>
<sect3 id="sysmgmt-firewall-whatis" xreflabel="What is a firewall?">
<title>What is a firewall</title>
<para>
That question would make little sense few years ago (year &lt;1997) but it seems to be a neccessity today when most computer-related things are just dumbed down or hidden behind the graphical interfaces and children waste their time practicing skills they have no or little use for in the real world (such as getting from one box to another with a single jump in a popular computer game Quake).
</para><para>
Anyway, on to the subject. Running an UNIX machine involves a great deal of responsibility, especially today when people have high-speed Internet connections at their homes; UNIX systems don't basically make a difference between physically local and remote users. Anyone who gains access to your machine (especially to privileged accounts) can use it to compromise you and other hosts on your network or attack other Internet sites and cover his tracks. Depending on the type and success of the attack, sometimes the only solace you have is the physical access to the machine and the ability to reinstall it (let alone the backups you didn't make).
</para><para>
Therefore, we will now introduce you the firewall software:
</para>
<blockquote>
<para>
A firewall is a set of related programs, located at a network gateway server or the user's machine, which protect the private resources from unprivileged [ab]use.  Basically, a firewall examines each network packet to determine whether to forward it toward its destination. A firewall is often installed in a specially designated computer separate from the rest of the network so that no incoming request can get directly at private network resources.
</para>
</blockquote>
<para>
This means we will use firewall to control access to our machine, keeping in mind that we distinguish connections initiated by us, and those initiated by the remote ends.
</para>

<caution><title>Caution</title>
<para>
Installing and configuring a firewall is by no means enough to enforce the site usage policy or provide the satisfying level of security, but it does make a big difference compared to a vanilla ('out of the box') system. [Having a car doesn't make you a driver, but it solves a mandatory pre-requisite].
</para>
</caution>
</sect3>

<sect3 id="sysmgmt-firewall-debian" xreflabel="Firewall in Debian GNU/Linux">
<title>Firewall setup in Debian GNU/Linux</title>
<para>
Firewalls in Linux have evolved. The old 2.0 kernel series used ipfwadm, 2.2 had ipchains and the current stable 2.4 branch sports the shiny netfilter, sympathized even by those who always preferred BSD systems for that part of the job.
</para><para>
User-space part (for the netfilter) is covered by the <emphasis>iptables</emphasis> package, which is a rather low-level interface to the firewall functions so some people (yes, we too) tend to use frontends; I found <emphasis>ferm</emphasis> to be The Frontend. <command>ferm</command> is a 'firewall rule parser for linux designed to maintain and setup complicated firewall rules'. Fair enough.
</para><para>
<screen>
# apt-get install ferm
</screen>
</para>
<para>
We will now see how does a generic home-firewall setup look like. The policy we will follow is: drop everything, permit only port 113, manually specified IPs and traffic initiated by our side.
You should read <command>ferm</command> man page and the examples in <emphasis>/usr/share/doc/ferm/examples/</emphasis>, but here's my suggestion to get us going:
</para><para>
<screen>
# /etc/security/ferm.rules
# Feel free to relocate this file somewhere else.

# Options
option automod
option iptables
option clearall
option createchains

# Default policies. We drop all packets.
chain input policy drop;
chain output policy drop;
chain forward policy drop;

# We accept everything going out and all ICMP messages going in.
# TODO: update this.
chain output accept;
chain input proto icmp accept;

# On lo and eth0 interfaces, accept everything that matches
# the address range. Log and drop packets that don't.
# TODO: make this look properly
chain input if ( eth0 lo ) {
<co id="localnet">	saddr 192.168.7.110/24 accept;
	saddr 127.0.0.1 accept;
        drop log;
}

# The outgoing, Internet link.
# Accept everything from 129.70.28.189 and 161.53.41.91
# Accept everything coming to our identd (113) port
# Accept everything that belongs to already established or related connections.
# Log and drop the rest.
<co id="inet-iface">chain input if ppp0 {
        saddr 129.70.28.189 ACCEPT;
        saddr 161.53.41.91 ACCEPT;

        proto tcp dport 113 ACCEPT;

        state (established,related) ACCEPT;

        drop log;
}
</screen>
</para>
<calloutlist>
<callout arearefs="localnet">
<para>The example assumes your machine has the local IP address 192.168.7.110 and netmask 255.255.255.0.
Adjust the host IP (netmask is probably okay).</para>
<callout arearefs="inet-iface">
<para>The example assumes your Internet link is a dial-up connection ppp0. Adjust according to your setup.</para>
</calloutlist>
<tip><title>Tip</title>
<para>
If you use <emphasis>dport</emphasis> or <emphasis>sport</emphasis> options in your rules, you must also include the <emphasis>proto tcp</emphasis> or <emphasis>udp</emphasis> specification.
</para>
</tip>
<para>
To make the rules active:
</para><para>
<screen>
# ferm /etc/security/ferm.rules
</screen>
</para><para>
You could also add this command to the <emphasis>/etc/ppp/ip-up</emphasis> script, to have it start automatically, whenever the dialup link goes up.
</para>
</sect3>
</sect2>



<sect2 id="sysmgmt-ipmasq" xreflabel="Setting up IP Masquerading/NAT">
<title>
Setting up IP Masquerading/NAT
</title>
<para>
Multiple computers can all share the single connection (to the Internet usually) installed on the gateway machine. The procedure to set it up is trivial:
</para>
<itemizedlist>
<listitem>
<para>
On the 'server' machine
</para>
</listitem>
</itemizedlist>
<para>
<screen>
# apt-get install ipmasq
</screen>
</para>
<itemizedlist>
<listitem>
<para>
On client machines
</para>
</listitem>
</itemizedlist>
<para>
<screen>
# route add default gw [server.ip]
</screen>
</para>
<para>
To make client side changes permanent, add 'gateway' option to the /etc/network/interfaces file. Also, make sure the /etc/resolv.conf files on client machines are valid (copy from the main machine would do if you substitute references to 127.0.0.1 with real server's IP).
</para>
<note><title>Please Note:</title>
<para>
If it doesn't work for you (you get 'Operation not permitted' errors even on the 'server' machine), try '<command>/etc/init.d/iptables stop</command>').
</para><para>
For laptops, or computers which often change their network environment, see the <emphasis>divine</emphasis> package.
</para>
</note>
</sect2>



<sect2 id="sysmgmt-login" xreflabel="The system login procedure, shell startup and config files">
<title>
System login procedure, the shell startup and config files
</title>


<sect3 id="sysmgmt-login-login" xreflabel="The system getty">
<title>
The system getty
</title>
<para>
We've mentioned the <emphasis>/etc/inittab</emphasis> file before. During the system boot, the <command>init</command> process (it always has the PID 1, it's the first process the kernel runs) reads that file and (among other things) initializes the virtual consoles, usually by starting the <command>getty</command> program on them. The system <command>getty</command> opens up a login prompt on the specified consoles and waits for users.
</para><para>
When you enter an username and password, your authentication request reaches the PAM layer (Pluggable Authentication Modules), where it gets checked for validity (using the <emphasis>/etc/pam.d/login</emphasis> rules); the check usually includes reading the /etc/passwd, /etc/group and /etc/shadow files and verifying the user's password and expiration dates. Please note that we are talking about the defaults here, the PAM system has endless configuration options, and it wouldn't be hard to make it use the retina scan instead of passwords to authenticate users. 
</para><para>
The PAM was originally developed at Sun Microsystems, but the Linux people maintain a fairly compatible Linux-PAM tree.  For the complete Linux-PAM user, administration and developer manuals, search the <ulink url="ftp://ftp.kernel.org">kernel.org</ulink> FTP site (the PAM documentation is <emphasis>not</emphasis> on www.tldp.org).
</para>
<note><title>The hint:</title>
<para>
The getty does wait for your login, but if you do not authenticate successfully the first time, the next login prompt you would see would not be served by getty, but by the /bin/login program itself. They look almost the same, but I thought you'd appreciate this detail. You would see the original getty again either when you finish your work and log out, or you reach the maximum login retry limit, in which case the /bin/login would terminate and the init process would spawn another getty on that console.
</para><para>
If you press Enter on the empty console login prompt and it immediately servers you a new one, you know you're talking to the system getty. The /bin/login would wait for a timeout, then tell you the login is incorrect.
</para>
</note>
</sect3>



<sect3 id="sysmgmt-login-shell" xreflabel="The login shell">
<title>
The login shell
</title>
<para>
If the PAM gives you a green light, the login program would spawn a shell for you (exactly which shell is specified in the last field of your /etc/passwd record). The shell would then:
<itemizedlist>
<listitem><para>
Execute /etc/profile
</para></listitem>
<listitem><para>
Execute the ~/.bash_profile dotfile, or ~/.profile if the former doesn't exist
</para></listitem>
<listitem><para>
Finally, give you the shell prompt
</para></listitem>
</itemizedlist>
<note><title>Please Note:</title>
<para>
The <emphasis>root</emphasis> user does NOT read the <emphasis>/etc/profile</emphasis> and it's dotfile is <emphasis>/root/.profile</emphasis>. It's just a convention, the root's dotfile name is not exactly enforced by the system, <emphasis>~/.bash_profile</emphasis> would have priority if present.
</para><para>
Also, the ~/.bash_profile is parsed only if you use the bash shell (check out the last field in 'getent passwd $USER'). If your shell is /bin/sh or something else, only the ~/.profile file will be read (if it exists at all).
</para>
</note>
</sect3>

</sect2>







<sect2 id="sysmgmt-useraccs" xreflabel="Regular user accounts ">
<title>Regular user accounts</title>
<para>
If you are logged in as root, create a new regular user account with the 'adduser' command and reopen this guide in it. To illustrate why using root account for user tasks is strongly discouraged, I will quote a good summary by Debian users on IRC channel #debian@OPN:
</para>
<blockquote>
<para>
It has been said that root is the administrative account - only use it when root power is needed. So no reading mail, compiling programs, or running applications as root. And don't even think about irc'ing as root, it increases the danger from exploits and trojans (such as bliss).
</para>
</blockquote>
<para>
If you visit #debian on irc.openprojects.net, and people see you are logged in as root, they will most definitely harass you about it.
</para>
<para>
You should always be logged in as a regular user, and change current user ID (to root) only when neccessary, using the 'su' command (or install advanced control mechanisms, such as 'sudo').
</para>
</sect2>





<sect2 id="sysmgmt-nopwdroot" xreflabel="Switching to root account without a password">
<title>
Switching to root account without a password
</title>
<para>
However, the problem is that you always have to type in the root password when you want to 'su' to root. To avoid this (that is, to enable 'su'ing to root without a password), edit the <emphasis>/etc/group</emphasis> file, and insert this line (anywhere):
</para>
<para>
<screen>
wheel:x:28:username1,username2
</screen>
</para>
<para>
and in <emphasis>/etc/pam.d/su</emphasis>, uncomment this line (remove the # char at the beginning, or copy this line there if you don't have it):
</para>
<para>
<screen>
auth sufficient pam_wheel.so trust
</screen>
</para>
<para>
That will allow users named 'username1' and 'username2' to type 'su' and become root without a password. Also, it will allow them to start processes as root on command-by-command basis with <command>su -c '/command/to/execute with arguments'</command>.
</para>
<tip><title>Tip</title>
<para>
To test it for the first time, completely log out and then log back in to reinitialize user groups information.
</para>
</tip>
<caution><title>Caution</title>
<para>
Note that once you do it, the system security depends on username1 and username2 account passwords.
</para>
</caution>
</sect2>





<sect2 id="sysmgmt-logins" xreflabel="Account login regulation">
<title>
Account login regulation
</title>
<para>
Since most of the accounts on your machine will be used locally by you, you don't want people logging in remotely, do you? (they first need an account password for that, but they might get it easier than you think). Edit file <emphasis>/etc/security/access.conf</emphasis>, read short info there and add something like this to the file:
</para><para>
<screen>
-:username1 username2:ALL EXCEPT LOCAL
</screen>
</para><para>
This denies login to username1 and username2 accounts from all locations except your own machine.
</para>
<tip><title>Tip</title>
<para>
To make sshd obey the restrictions, you need to put 'UseLogin Yes' directive in the <emphasis>/etc/ssh/sshd_config</emphasis> file and restart sshd (<command>/etc/init.d/ssh restart</command>).
</para>
</tip>
</sect2>





<sect2 id="sysmgmt-tcprwappers" xreflabel="Tcp wrappers">
<title>
Tcp wrappers
</title>
<para>
Tcp wrappers are a standard part of Debian, and allow you to simply control access to system services (mostly to those started from the <emphasis>inetd</emphasis> meta daemon). If you want to deny all services to remote addresses, make sure the file <emphasis>/etc/hosts.allow</emphasis> is empty, and put this in <emphasis>/etc/hosts.deny</emphasis>:
</para><para>
<screen>
ALL: ALL EXCEPT LOCAL 127.0.0.1: DENY
</screen>
</para><para>
For more information (including on how to trigger system commands upon incomming requests) read hosts_access(5) and hosts_options(5) man pages.
</para>
<note><title>Please Note:</title>
<para>
Tcp wrappers and a firewall have very little in common; the level at which the allow/deny decision takes place is fundamentally different. With a firewall, it happens on a lowest, packet level: the packet targeted at say, an ftp port, could be dropped by the firewall as soon as it gets received by the network hardware and processed by the operating system's network layer (it wouldn't even reach the ftp daemon). With tcp wrappers, the packet does reach its destination (or the inetd, at least). The request validity check is usually performed before the server forks a new child process to service the incoming request.
</para>
</note>
</sect2>


<sect2 id="sysmgmt-dpkg-unpack" xreflabel="Manually unpacking .deb files">
<title>Manually unpacking .deb files</title>
<para>
From time to time you wish to unpack a .deb file to see its contents (or to recover some system files). Fortunately, Debian's .deb files need no special tools to be unpacked, they are simple 'ar' archives containing two files: data.tar.gz and control.tar.gz. Here are some examples:
<itemizedlist>
<listitem><para>
Using dpkg to unpack the contents of a .deb file to an arbitrary directory:
</para><para>
<screen>
$ dpkg -x package.deb /tmp/package
</screen>
</para></listitem>
<listitem><para>
Using 'ar' to unpack the data tarball:
</para><para>
<screen>
$ ar x package.deb data.tar.gz
</screen>
</para></listitem>
<listitem><para>
Using 'ar' to unpack the control tarball:
</para><para>
<screen>
$ ar x package.deb control.tar.gz
</screen>
</itemizedlist>
</para>
<note><title>Please Note:</title>
<para>
If you're not careful when upgrading/downgrading the gnu libc package on your system, you'll most probably loose the <command>/sbin/ldconfig</command> command, and most of the things you try to do will fail for that reason. If that's why you are reading this, then one solution is to unpack the libc6 package manually and copy the ldconfig command back in place; the other thing you can do is to create an empty ldconfig, which would simply return success:
</para><para>
<screen>
# echo "#!/bin/sh" > /sbin/ldconfig
# chmod 755 /sbin/ldconfig
</screen>
</para>
</note>

</sect2>



<sect2 id="sysmgmt-debsums" xreflabel="Checking the MD5 sums of installed Debian packages">
<title>Checking the MD5 sums of installed Debian packages</title>
<para>
It is often useful to verify the files on your system, either to detect unauthorized modifications or just to find out which files you once modifed and then forgot about them.
</para><para>
<screen>
# apt-get install debsums
# debsums [package]
</screen>
</para>
</sect2>


<sect2 id="sysmgmt-shared-sessions" xreflabel="Shared sessions">
<title>Shared sessions</title>
<para>
Terminal sessions shared by more concurrent users can be very useful. On a few occasions, I was asked to remotely tune machines (such as sound card drivers or XFree86 support), and the other party wanted to keep a complete track of my actions (for educational and controlling purposes).
</para><para>
It is possible to achieve that effect by using either <emphasis>screen</emphasis> or <emphasis>ttysnoop</emphasis>.
</para>
<sect3 id="sysmgmt-shared-sessions-screen" xreflabel="screen">
<title>screen</title>
<para>
Using screen to make shared sessions is very easy, but it requires both parties to cooperate (so you must trust the other end) and involves shared account passwords (which is a bad thing if it becomes your habbit).
All one must do is to login as say, 'username1' (ssh -l username1 localhost) and run 'screen', then wait for the other party to log on to the system (under the same username, of course) and run 'screen -x'.
</para><para>
(This tip was provided by electr0n@OPN).
</para>
</sect3>
<sect3 id="sysmgmt-shared-sessions-ttysnoop" xreflabel="ttysnoop">
<title>ttysnoop</title>
<para>
<emphasis>ttysnoop</emphasis> is a trivial but very convenient tool that can be used to share, monitor or control user terminals. Enabling ttysnoop on your machine is <emphasis>dangerous</emphasis>; it could violate your security policy or leave the system in an unusable state if not done properly.
The ttysnoop itself doesn't need any special setup (except the <emphasis>/etc/snooptab</emphasis> file maybe) if both parties cooperate (one starts the ttysnoops server, and the other starts the ttysnoop client). However, installing it so that the ttysnoops gets started during the login does require few changes in the system configuration files.
</para><para>
We will show here how to replace the system's login binary with ttysnoops and how to enable it for ssh connections. The procedure is delicate, as we said already, so we will comment each line you are about to execute in your shell.
</para>
<caution>
<title>Caution</title>
<para>
The <command>/bin/login</command> file, an important part of every UNIX system, will get modified. This means that all applications which use <command>/bin/login</command> will be affected; in other words, it would become possible for users who posess the root password to completely monitor and control those character data streams (with root password, they could do it anyway, but not *so* easy). You shouldn't notice any visual changes, but please understand that the <emphasis>ttysnoop server</emphasis> will hook itself between the login program and the user (/dev/ttyp*). If you want specific services <emphasis>not</emphasis> to use the snooped <command>/bin/login</command>, instruct them to use <command>/bin/login.real</command> as the login program (that's exactly what we did with the system getty).
</para>
</caution>
<para>
<screen>
<co id="tts-1"> # dpkg-divert --divert /bin/login.real --add /bin/login
<co id="tts-2"> # mv /bin/login /bin/login.real
<co id="tts-3"> # echo "* socket login /bin/login.real" > /etc/snooptab
<co id="tts-4"> # cp /etc/inittab /etc/inittab.valid
<co id="tts-5"> # perl -p -i,orig -e 's#getty#getty -l /bin/login.real#g' /etc/inittab
<co id="tts-6"> # ln -sf /usr/sbin/ttysnoops /bin/login
<co id="tts-7"> # init q
<co id="tts-8"> # echo "UseLogin yes" >> /etc/ssh/sshd_config
<co id="tts-9"> # /etc/init.d/ssh restart	
</screen>
</para>
<calloutlist>
<callout arearefs="tts-1">
<para>
We already described the dpkg-divert command above. It "diverts" the file <command>/bin/login</command> to <command>/bin/login.real</command>, meaning that new packages which contain <command>/bin/login</command> file will unpack it to a diverted location, <command>/bin/login.real</command>. To undo this step, use <command>dpkg-divert --remove /bin/login</command>.
</para>
</callout>
<callout arearefs="tts-2">
<para>
Move <command>/bin/login</command> to <command>/bin/login.real</command>. The system login will be corrupted till step 6, when we re-create the <command>/bin/login</command> file. To undo this step, use <command>mv /bin/login.real /bin/login</command>.
</para>
</callout>
<callout arearefs="tts-3">
<para>
Create the <emphasis>/etc/snooptab</emphasis> file, which contains a single rule "* socket login /bin/login.real". See man ttysnoop(8) for details.
</para>
</callout>
<callout arearefs="tts-4">
<para>
Create a copy of the <emphasis>/etc/inittab</emphasis> file in <emphasis>/etc/inittab.valid</emphasis>. This is important; if anything bad happens to <emphasis>/etc/inittab</emphasis> you could end up with an unusable system, so having a valid copy lying around is encouraged (also leave one shell opened, so that you can put the valid file back in place even if you break system login).
</para>
</callout>
<callout arearefs="tts-5">
<para>
Using Perl, the practical extraction and report language, edit the file <emphasis>/etc/inittab</emphasis> in-place, and replace every occurence of 'getty' with 'getty -l /bin/login.real'. The copy of the original file is saved in <emphasis>/etc/inittab,orig</emphasis>. *Never* run this command twice before putting the ,orig file back first (or you'll end up with something like 'getty -l /bin/login.real -l /bin/login.real'). In case of trouble, copy the .valid file from the previous step onto <emphasis>/etc/inittab</emphasis>. Also, note that we use 'getty -l' (where -l is smallcaps -L, not the number -1).
</para>
</callout>
<callout arearefs="tts-6">
<para>
We re-create the <command>/bin/login</command>, making it a symbolic link to <command>/usr/sbin/ttysnoops</command>, the ttysnoop server.
</para>
</callout>
<callout arearefs="tts-7">
<para>
Reload the <command>init</command> process, which re-reads the <emphasis>/etc/inittab</emphasis> file. If you made a mistake in some of the previous steps, your local consoles probably won't work anymore; that's why we suggested to leave one shell open and have a copy of the original /etc/inittab. If you decide to put the old inittab back, don't forget to move the login.real file back too and remove the divert.
</para>
</callout>
<callout arearefs="tts-8">
<para>
We append 'UseLogin Yes' to the end of the sshd configuration file.
</para>
</callout>
<callout arearefs="tts-9">
<para>
We restart the sshd daemon.
</para>
</callout>
</calloutlist>

<warning><title>Warning</title>
<para>
Enabling ttysnoop on your machine is <emphasis>dangerous</emphasis>; it could violate your security policy or leave the system in an unusable state if not done properly. For example, if you loose the ability to start X as a regular system user, chances are you did not make getty use the original login program so either fix that, or run <command>dpkg-reconfigure xserver-common</command> and allow anyone to run X server (a bad thing to do).
</para>
</warning>

<para>
You can test the setup locally (but the same idea applies to remote logins, of course):
<itemizedlist>
<listitem>
<para>
ssh to your localhost (execute: <command>ssh 127.0.0.1</command> or <command>ssh 0</command>, which works on Linux only)
</para></listitem><listitem><para>
switch to another virtual console (or X terminal) and login as root. Find out the correct tty device (ttyp*) for our snoop target:
<screen>
# w | grep ttyp
myuser ttyp0 - 4:20am 3.00s 0.05s 0.02s -bash 
</screen>
</para></listitem><listitem><para>
invoke the <command>ttysnoop</command> to hook to <emphasis>/dev/ttyp0</emphasis>:
<screen>
$ /usr/sbin/ttysnoop ttyp0
</screen>
</para></listitem><listitem><para>
type in root password (to authenticate with ttysnoops) and enjoy your shared view ;p
</para></listitem></itemizedlist>
<para>
When letting people log in remotely to your machine, <command>ssh</command> is strongly-preferred way to connect. Do not even bother with <command>telnet</command> (which is an unencrypted and insecure service). If you have special needs or demand telnet anyway, check out working configurations from the sample /etc/snooptab files.
</para>
</sect3>
</sect2>


<sect2 id="sysmgmt-runlevels" xreflabel="Runlevels and system services">
<title>
Runlevels and system services
</title>

<sect3 id="sysmgmt-runlevels-boot" xreflabel="System boot and the init process">
<title>
System boot and the <command>init</command> process
</title>
<para>
This is very interesting and important part of every UNIX system.
</para>
<para>
In most common scenarios, you have LILO installed as the bootloader. LILO (the LInux LOader) accepts parameters on command line, but Debian has been configured (in default configuration) not to show LILO boot prompt. To make it appear, hold Alt key at 'LILO' message (during boot, just before you see the 'Loading linux ....' message) and you'll be able to pass arbitrary parameters to kernel. You can type anything there, and it will later be visible in the <emphasis>/proc/cmdline</emphasis> file.
</para>
<para>
After the kernel gets loaded, it starts '<command>init</command>' as the first system process. Init enters default runlevel 2 (other Linux distributions mostly use runlevel 3 as the default) and executes tasks defined in <emphasis>/etc/rc2.d/</emphasis> directory. Init directories consist of symbolic links to files in <emphasis>/etc/init.d/</emphasis>; here's an example:
</para><para>
<screen>
$ ls -la /etc/rc2.d/ | cut -b 57-
...
S20net-acct -> ../init.d/net-acct
S20openldapd -> ../init.d/openldapd
S20postgresql -> ../init.d/postgresql
...
</screen>
</para><para>
The 'S' prefix starts a service, while 'K' stops it (for the given runlevel). The numbers determine the order in which the scripts are run (0 being the first).
</para>
<para>
<emphasis>init</emphasis> then excutes local scripts from <emphasis>/etc/rc.boot/</emphasis> and performs the rest of init tasks specified in <emphasis>/etc/inittab</emphasis>.
</para>
</sect3>
<sect3 id="sysmgmgt-runlevels-manipulating" xreflabel="Manipulating /etc/rcX.d/ links">
<title>
Manipulating /etc/rcX.d/ links
</title>
<para>
Debian provides a convenient tool to manage runlevels (to control when services are started and shut down); it's called <command>update-rc.d</command> and there are two most common invocation methods:
</para><para>
<screen>
# update-rc.d -f xdm remove
# update-rc.d xdm defaults
</screen>
</para><para>
The first line shows you how to remove the <emphasis>xdm</emphasis> service from startup; the second sets it back. <emphasis>xdm</emphasis> is a basic implementation of the graphical login screen. You could disable it if you prefer console logins (although nothing is stopping you from using both at the same time), or you could try <emphasis>xdm</emphasis> alternatives, such as <emphasis>kdm</emphasis>, <emphasis>gdm</emphasis> or <emphasis>wdm</emphasis>.
</para>
</sect3>
<sect3 id="sysmgmt-runlevel-startstop" xreflabel="Manual service start/stop">
<title>
Manual service start/stop
</title>
<para>
All files in <emphasis>/etc/init.d/</emphasis> share a common invocation syntax, which is defined by Debian Policy. All system services have their init script there (usually named as the service itself) which accepts generic arguments. Let's see an example:
</para><para>
<screen>
# ls -al /etc/init.d/a* | cut -b 55- 
/etc/init.d/acct
/etc/init.d/apache
# /etc/init.d/apache start
Starting web server: apache.
/usr/sbin/apachectl start: httpd started
# /etc/init.d/apache stop
Stopping web server: apache.
/usr/sbin/apachectl stop: httpd stopped
# /etc/init.d/apache invalid
Usage: /etc/init.d/apache {start|stop|reload|reload-modules|force-reload|restart}
</screen>
</para>

<note><title>Please Note:</title>
<itemizedlist>
<listitem><para>
Generic init.d script template is in <emphasis>/etc/init.d/skeleton</emphasis>, use it for your own scripts. Also check the <emphasis>/etc/init.d/bootmisc.sh</emphasis> file.
</para></listitem>
<listitem><para>
Besides the traditional System V init system, Debian also supports single-file based init. See the <emphasis>file-rc</emphasis> package if you're interested.
</para></listitem>
</itemizedlist>
</note>
</sect3>
</sect2>





<sect2 id="sysmgmt-alternatives" xreflabel="The Debian 'alternatives' system">
<title>The Debian 'alternatives' system</title>
<para>
The Debian distribution comes with a lot of software packages and chances are that you can choose between few different applications that basically perform the same task; you can even have them all installed and peacefully coexisting on the system. Since we speak of Debian, there intuitively has to be an elegant way to set system defaults; and yes, there is one: the 'alternatives' system. Here's a similar introduction and an example from the update-alternatives(8) man page:
</para>
<blockquote>
<para>
It is possible for several programs fulfilling the same or similar functions to be installed on a single system at the same time. For example, many systems have several text editors installed at once. This gives choice to the users of a system, allowing each to use a different editor, if desired, but makes it difficult for a program to make a good choice of editor to invoke if the user has not specified a particular preference.
Debian's alternatives system aims to solve this problem. A generic name in the filesystem is shared by all files providing interchangeable functionality. The alternatives system and the system administrator together determine which actual file is referenced by this generic name. For example, if the text editors ed(1) and nvi(1) are both installed on the system, the alternatives system will cause the generic name /usr/bin/editor to refer to /usr/bin/nvi by default. The system administrator can override this and cause it to refer to /usr/bin/ed instead, and the alternatives system will not alter this setting until explicitly requested to do so.
</para>
</blockquote>
<para>
To actually configure the mentioned 'editor' alternative, simply type:
</para><para>
<screen>
# update-alternatives --config editor
</screen>
</para><para>
For a list of possible alternatives, check out the <emphasis>/etc/alternatives/</emphasis> directory. You will most likely want to tune the 'x-window-manager' and 'x-session-manager' choices.
</para>
</sect2>




<sect2 id="sysmgmt-diskspace" xreflabel="Periodically checking for the available disk space">
<title>Periodically checking for the available disk space</title>
<para>
It is very important to monitor disk usage. If the disk becomes full (especially on your /home partition), you will probably damage your config files or even lose data. The XFree won't even start if there's no free disk space available. A simple crontab script which would just send you a daily disk usage reminder could be created this way:
</para><para>
<screen>
# echo '#!/bin/sh' > /etc/cron.daily/disk-usage
# echo 'df' >> /etc/cron.daily/disk-usage
# chmod 755 /etc/cron.daily/disk-usage
</screen>
</para><para>
Make sure to then edit the <emphasis>/etc/crontab</emphasis> file to adjust the time at which the <emphasis>cron.daily/</emphasis> parts are run (it defaults to 06:25 AM).
</para>
</sect2>



<sect2 id="sysmgmt-archives" xreflabel="Creating and extracting file archives">
<title>Creating and extracting file archives</title>

<para>
In UNIX, you traditionally group ('tar') many files into a single one, and then compress it using a compression alghoritm (gzip for example). We will show here how to create and extract tar, tar.gz and tar.bz2 archives.
</para><para>
<screen>
# apt-get install bzip2

# Create a plain, uncompressed tar archive
# tar -cf etc-backup.tar /etc

# Create a tar.gz (compressed) archive
# tar -zcf etc-backup.tar.gz /etc

# Create a tar.bz2 (compressed) archive (bzip2 is superior!)
# tar -jcf etc-backup.tar.gz /etc

# Unpack the tar archive 
# tar xf etc-backup.tar

# Uncompress *and* unpack the tar.gz archive 
# tar zxf etc-backup.tar

# Just uncompress the tar.bz2 archive
# bunzip2 etc-backup.tar.bz2

# Unpack etc-backup.tar to a different directory
# tar xf etc-backup.tar -C /tmp/
</screen>
</para><para>
For zip, rar, arj or cab files support, use the <command>apt-cache search</command> command to find the packages you need to install.
</para>
</sect2>



<sect2 id="sysmgmt-packs" xreflabel="Copying, mirroring and re-downloading Debian packages">
<title>
Copying, mirroring and re-downloading Debian packages
</title>


<sect3 id="sysmgmt-packs-redownload" xreflabel="Re-downloading all installed .deb packages">
<title>
Re-downloading all installed .deb packages
</title>
<para>
You might want to do that for mirroring or backup purposes, or to burn a CD set with satisifed dependencies. The trick can be achieved with:
</para><para>
<screen>
# COLUMNS=200 dpkg -l | grep '^ii' | awk '{ print $2 }' > /tmp/pkglist
# cat /tmp/pkglist | xargs apt-get --download-only --reinstall -y install
</screen>
</para><para>
After the download finishes, you should see all the .deb files in <emphasis>/var/cache/apt/archives/</emphasis>. Also, see the <command>apt-move sync</command> method below, maybe that's what you really need.
</para>
</sect3>


<sect3 id="sysmgmt-packs-hdmir" xreflabel="Setting up a Debian mirror or an apt source on the local hard disk">
<title>
Setting up a Debian mirror or an apt source on the local hard disk
</title>
<para>
This subsection could be of interest to you if you want to copy Debian CDs to your disk (so you don't have to change cdroms in the drive all the time) or export the Debian mirror to the machines on your local LAN.
</para>
<para>
The easiest way do copy Debian CDs to your hard disk would be to use the <command>dd</command> tool and directly create CD images:
</para><para>
<screen>
# dd if=/dev/cdrom of=/mnt/deb-cd1.img bs=512k
</screen>
<para>
You would then mount the image like this (of course, you add it to <emphasis>/etc/fstab</emphasis> if you want it permanent):
</para><para>
<screen>
# mkdir /mnt/deb-cd1
# mount -o loop,ro /mnt/deb-cd1.img /mnt/deb-cd1
</screen>
</para><para>
An example sources.list entry would look like this:
</para><para>
<screen>
deb file://mnt/deb-cd1 woody main contrib non-free non-US/main non-US/contrib non-US/non-free
</screen>
</para>
<note><title>Please Note:</title>
<para>
While this procedure would work and is perfectly fine if you really want the CD images (if you are say, recording Debian CDs), you'll probably find it inconvenient for other purposes (because the kernel default maximum number of loop devices in only 7 and you neccessarily have multiple sources instead of one which has everything).
</para>
</note>
</sect3>


<sect3 id="sysmgmt-packs-move" xreflabel="Using apt-move to move packages into the local hard disk repository">
<title>
Using <command>apt-move</command> to move packages into the local hard disk repository
</title>
<para>
If you have enough disk space, you'll find apt-move very convenient. You can use it to copy the cdroms to the disk, sort the downloaded files from /var/cache/apt/archives, or stay in sync with your local Debian mirror.
</para>
<itemizedlist>
<listitem><para>
First, install apt-move:
</para><para>
<screen>
apt-get install apt-move
</screen>
</para></listitem>
<listitem><para>
Edit <emphasis>/etc/apt-move.conf</emphasis>, put 'localhost' (or the Internet mirror name, of course) under APTSITES field and change the DIST option (to 'woody', if you have Debian 3.0). You could also change PKGTYPE to 'both' if you also want source packages.
</para></listitem>
<listitem><para>
Edit <emphasis>/etc/apt/sources.list</emphasis> and deactivate all lines referring to cdroms.
</para></listitem>
<listitem><para>
Export <emphasis>/cdrom</emphasis> with Apache (if using http://localhost instead of the Internet mirror as package source):
</para><para>
<screen>
# apt-get install apache
# echo "Alias /cdrom/ /cdrom/" >> /etc/apache/httpd.conf
# /etc/init.d/apache restart
# echo "deb http://localhost/cdrom/ woody contrib main non-US/contrib non-US/main non-US/non-free non-free" >> /etc/apt/sources.list
# apt-get update
</screen>
</para></listitem>
<listitem><para>
Initialize apt-move:
</para><para>
<screen>
# apt-move get
</screen>
</para></listitem>
<listitem><para>
Now for each CD you wan't to move to your hard disk, type:
</para><para>
<screen>
# mount /cdrom
# apt-get update
# apt-move mirror
# umount /cdrom
</screen>
</para><para>
If you don't use CDs but the Internet mirror directly:
</para><para>
<screen>
# To only move packages from /var/cache/apt/archives/
# apt-move move 

# To build complete mirror
# apt-move mirror 

# To copy only the packages which are installed on the system
# apt-move sync 
</screen>
</para></listitem>
<listitem><para>
When you finish it all, create the new <emphasis>Packages.gz</emphasis> and <emphasis>Sources.gz</emphasis>:
</para><para>
<screen>
# apt-move packages
# cd /mirrors/debian
# gunzip `find . -name Packages.gz`
# apt-move packages
</screen>
</para><para>
Note that the <command>gunzip ..</command> line is important, because it creates the plain Packages files; you must have them if you're later using tools like <command>debootstrap</command>. Also, you will need to copy some existing <emphasis>Release</emphasis> file to the <emphasis>dists/woody/</emphasis> directory.
</para></listitem>
<listitem><para>
Replace the <emphasis>http://localhost/cdrom/</emphasis> repository (we don't need it any more) with the newly created mirror and install <command>xplanet</command> to test it:
</para><para>
<screen>
# perl -n -i -e 'print unless m#/cdrom/#' /etc/apt/sources.list
# apt-get install apache
# echo "Alias /mirrors/debian/ /debian/" >> /etc/apache/httpd.conf
# /etc/init.d/apache reload
# echo "deb http://localhost/debian/ woody contrib main non-US/contrib non-US/main non-US/non-free non-free" \
  >> /etc/apt/sources.list
# apt-get update
# apt-get install xplanet xplanet-images
</screen>
</para><para>
Before you move on, don't forget to remove the <emphasis>/cdrom/</emphasis> entry from <emphasis>/etc/apache/httpd.conf</emphasis>.
</para>
</listitem>
</itemizedlist>
</sect3>



</sect2>





<sect2 id="sysmgmt-package-recompilation" xreflabel="Package recompilation and configurations">
<title>Package recompilation</title>
<para>
Debian software packages come precompiled for many architectures. In the case of Intel-compatibles, those packages are optimized to work with all variants from i386 up. However, it means that all the system binaries you have use nothing from the advanced features found in modern processors (Pentiums for example).
</para><para>
There's been much of a debate if local recompilation of packages would give any advantage, but the general (and sane) conclusion seems to be this:
</para>
<blockquote>
<para>
Local recompilation makes sense for kernel source, the GNU C Library (glibc), compression tools (such as gzip or bzip2) and some open-source games.
</para><para>
To recompile and install the package (say, <command>vim</command>), use:
</para><para>
<screen>
# apt-get -b source vim
</screen>
</para>
</blockquote>


<sect3 id="sysmgmt-package-sbuild" xreflabel="Building .deb packages from source">
<title>
Building .deb packages from source
</title>
<para>
TODO: 
<ulink url="source_builder.pl">source_builder.pl</ulink>,
apt-get --build,
<ulink url="cast">cast</ulink>
</para>
<para>
fakeroot dpkg-buildpackage -uc -us
</para><para>
Installing software from generic .tar.gz packages - the checkinstall project (apt-get install checkinstall)
</para>
</sect3>

<sect3 id="sysmgmt-packs-dpsyco" xreflabel="dpsyco - Debian Packages of System Configurations">
<title>
dpsyco - Debian Packages of System Configurations
</title>
<para>
Dpsyco is an acronym for Debian Packages of System Configurations and you can create and maintain "configuration packages" with it. A configuration package is a package that resides "on top" of the normal debian packages. You can overwrite normal files, patch the system, add users and groups and much more.
</para><para>
<screen>
# apt-get install dpsyco dpsyco-{skel,patch}
</screen>
</para>
</sect3>



<sect3 id="sysmgmt-packs-equivs" xreflabel="equivs - inform dpkg about localy installed packages">
<title>
equivs - inform dpkg about localy installed packages
</title>
<blockquote>
<para>
This is a package, that creates Debian packages that can be used to inform dpkg about localy installed packages and their dependancies. Also empty packages that just require other packages can be created with equivs. These can be used as "profile" packages that just mark otherones for installation.
</para><para>
Please note that this is a crude hack and if thoughtlessly used might possibly do damage to your packaging system.  And please note as well that using it is not the recom mended way of dealing with broken dependencies. Better file a bug report instead.
</para>
</blockquote>
</sect3>

</sect2>




<sect2 id="sysmgmt-netlink" xreflabel="Linking to your local Internet Service Provider">
<title>
Linking to your local Internet Service Provider
</title>
<sect3 id="sysmgmt-netlink-dialups" xreflabel="Dial-ups">
<title>
Dial-ups
</title>
<para>
You don't have load any drivers to support your modem. It's done automatically, generic 'serial.o' driver takes care for serial port communication, and all normal modems understand the AT command set. If you have a winmodem (braindamaged modem which lacks one $5 chip and its work is loaded onto machine's CPU), then just forget it (however, there is <ulink url="http://www.linmodems.org">LinModems</ulink> website, if you don't want to listen the voice of sanity). 
</para>

<sect4 id="sysmgmt-netlink-dialups-pppconfig" xreflabel="pppconfig">
<title>
pppconfig
</title>
<para>
Type <command>pppconfig</command> (as root) to create a new connection and define configuration parameters. You'll probably get it right just following the menus, but let me give you some some guidelines:
</para>
<itemizedlist>
<listitem>
<para>
Leave "provider" as the name of first connection you make (so it becomes the default).
</para>
</listitem>
<listitem>
<para>
Choose Dynamic DNS.
</para>
</listitem>
<listitem>
<para>
Authentication method: find out what method your ISP uses. Nowadays, PAP is almost always a safe bet.
</para>
</listitem>
<listitem>
<para>
Modem port speed, leave at 115200 if you use external modem, or set other value if it's internal (such as 57600).
</para>
</listitem>
<listitem>
<para>
Choose 'Yes' to automatically detect your modem, then accept the port it found (see below on what to do if it doesn't find any).
</para>
</listitem>
<listitem>
<para>
You are now on the main screen where you can modify selected options before saving them to disk. Choose 'Advanced options'. In Europe, you will probably have to change Modeminit field from 'ATZ' to 'ATx3l1m1' (use l0m0 if you dont wan't modem speaker to be heared); the 'x3' is important here: if you don't set it, you will get a 'NO DIALTONE' error.
</para>
</listitem>
</itemizedlist>
<note><title>Please Note:</title>
<para>
<command>pppconfig</command> is nothing but a convenient interface to create <emphasis>/etc/chatscripts/&lt;provider&gt;</emphasis> and <emphasis>/etc/ppp/peers/&lt;provider&gt;</emphasis> files. You could create them by hand if you wanted, too.
</para><para>
Unlike other "dialer" systems, the pon/poff method uses the pppd's ability to call the remote end. The <command>/usr/bin/pon</command> was a shell oneliner just until recently, when some description and error handling were added.
</para>
</note>
</sect4>
<sect4 id="sysmgmt-netlink-dialups-pon" xreflabel="pon and poff">
<title>
<command>pon</command>, <command>poff</command>
</title>
<para>
To connect to your default provider, type <command>pon</command>.
</para>
<para>
To terminate connection, use <command>poff</command>.
</para>
</sect4>
<sect4 id="sysmgmt-netlink-dialups-stats" xreflabel="Connection statistics">
<title>
Connection statistics
</title>
<para>
There are <command>plog</command> and <command>pppstats</command> from the <emphasis>ppp</emphasis> package. You could also install the '<command>pppstatus</command>' package for a really nice real-time monitor.
<note><title>Please Note:</title>
<para>
Before you try <command>plog</command>, make sure you add "local2.* TAB /var/log/ppp.log" to your syslogd's configuration; the exact instructions were given earlier in the document.
</para>
</note>
</para>
</sect4>
<sect4 id="sysmgmt-netlink-dialups-troubles" xreflabel="Troubleshooting">
<title>
Troubleshooting
</title>
<itemizedlist>
<listitem>
<para>
<command>pppconfig</command> doesn't detect your modem 
</para>
</listitem>
</itemizedlist>
<orderedlist>
<listitem>
<para>
make sure it's really a Hayes/Rockwell compatible modem (winmodems are not) which understands the AT command set
</para>
</listitem>
<listitem>
<para>
make sure the modem is connected properly to the machine, and try switching it off/on to reset it 
</para>
</listitem>
<listitem>
<para>
try manually specifying ports from /dev/ttyS0 to /dev/ttyS3 (com ports 1 to 4) and try, maybe you're lucky.
</para>
</listitem>
</orderedlist>
<itemizedlist>
<listitem>
<para>
<command>ping 161.53.2.66</command> works, but <command>ping www.google.com</command> doesn't:
</para>
</listitem>
</itemizedlist>
<orderedlist>
<listitem>
<para>
if the connection seems to work (modem lights are on, etc..) but you can't <command>ping</command> using FQDN (why I never really liked this name?) - it means the automatic DNS setup failed. In that case, find out what's the DNS (Domain Name Service) IP of your ISP and edit the file <emphasis>/etc/resolv.conf</emphasis>. Make it look like this: 
</para>
</listitem>
</orderedlist>
<para>
<screen>
nameserver your.dns.server.ip
</screen>
</para>
</sect4>
<sect4 id="sysmgmt-netlink-pppalterns" xreflabel="pppconfig/pon/poff alternatives">
<title>
Alternatives to <command>pppconfig/pon/poff</command>
</title>
<para>
<command>pppconfig</command>, <command>pon</command> and <command>poff</command> are superior tools. However, you could try another program, <command>wvdial</command>. The advantage of wvdial is that it can automatically detect what type of authentication your ISP accepts (and if it doesn't succeed, try setting "Stupid Mode = 1" in <emphasis>/etc/wvdial.conf</emphasis>).
</para>
</sect4>
</sect3>


<sect3 id="sysmgmt-netlink-adsl" xreflabel="ADSL with pppoe">
<title>
ADSL with pppoe
</title>
<para>
Surprisingly, the adsl+pppoe setup is trivial with Debian. Install the <emphasis>pppoe</emphasis> package, find out the exact name of your provider (by sending the PADI packet) and read last notes in README.Debian:
</para><para>
<screen>
# apt-get install pppoe
# pppoe -A
# zless /usr/share/doc/pppoe/README.Debian.gz
</screen>
</para>
<note><title>Please Note:</title>
<para>
There's also the <command>pppoeconfig</command> program. Maybe you can get away with it.
</para>
</note>
</sect3>


<sect3 id="sysmgmt-netlink-whatnext" xreflabel="I'm connected to the Internet, what should I do first?">
<title>
I'm connected to the Internet, what should I do first?
</title>
<para>
Make sure you have the <emphasis>ircii</emphasis> package installed (or some other variant of irc client, such as console <emphasis>irssi</emphasis> or graphical <emphasis>xchat</emphasis> and <emphasis>kvirc</emphasis>).
Then connect to the IRC server (irc.debian.org, which is a part of the FreeNode network [former "OpenProjects"]) and join channel #debian:
</para><para>
<screen>
# su -c 'apt-get install xchat'
# xchat

/server irc.debian.org
/join #debian
</screen>
</para><para>
You can ask for help and advice there, or just hang around and collect useful tips.
</para>
<warning><title>Warning</title>
<para>
I hope you noticed the <command>su -c ' ... '</command> above; it allows you to execute <command>apt-get install xchat</command> as root.
The implicit message is that you should not be using the root account on a regular basis.
</para>
</warning>
<note><title>Please Note:</title>
<para>
Consider visiting the <ulink url="http://liloaid.ecce.co.uk/lilo.html">The serious bit</ulink>, <ulink url="http://liloaid.ecce.co.uk/">The Parody Site</ulink>, and the <ulink url="http://www.printf.net/~chris/petition.pl">Petition page</ulink> to understand the 'Global Notice' money-requesting messages you'll be getting if you spend some time on the OPN network.
</para>
</note>
</sect3>
</sect2>


<sect2 id="sysmgmt-popc" xreflabel="The package popularity contest">
<title>
The package popularity contest
</title>
<para>
Let's just quote the <emphasis>popularity-contest</emphasis> manpage which says it all:
</para>
<blockquote>
<para>
The popularity-contest command gathers  information  about Debian  packages  installed  on the system, and prints the name of the most recently used executable program in  that package  as  well  as  its  last-accessed time (atime) and last-attribute-changed time (ctime) to stdout.
</para><para>
When aggregated with the output of popularity-contest from many  other  systems, this information is valuable because it can be used to determine which Debian packages are com monly  installed, used, or installed and never used.  This helps Debian maintainers make  decisions  such  as   which packages should be installed by default on new systems.
</para><para>
Normally,  popularity-contest  is  run from a cron(8) job, /etc/cron.weekly/popularity-contest,  which  automatically emails the results to Debian package maintainers according to the settings in /etc/popularity-contest.conf.
</para>
</blockquote>
<para>
<screen>
# apt-get install popularity-contest
</screen>
</para>
</sect2>


<sect2 id="sysmgmt-windisk" xreflabel="Accessing data on MS Windows partitions">
<title>
Accessing data on MS Windows partitions
</title>

<para>
Type 'fdisk -l' and you will see the list of partitions on all disks you have in the machine. Ignore everything (including warnings) except partitions which are of type FAT16 (for older Windows) or NTFS (for that Neandertal Technology (tm) stuff or newer). See this example output:
</para><para>
<screen>
# fdisk -l

Disk /dev/hda: 255 heads, 63 sectors, 1823 cylinders
Units = cylinders of 16065 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        62    497983+  82  Linux swap
/dev/hda2   *        63        70     64260   83  FAT16
/dev/hda3            71      1823  14080972+   5  Extended
/dev/hda5   *        71       101    248976   83  NTFS
/dev/hda6   *       102       709   4883728+  83  Linux
/dev/hda7           710      1317   4883728+  83  Linux
/dev/hda8          1318      1823   4064413+  83  Linux

Disk /dev/hdc: 16 heads, 63 sectors, 29065 cylinders
Units = cylinders of 1008 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hdc1             1     29065  14648728+  83  Linux
</screen>
</para><para>
We have two physical disks, which are called <emphasis>/dev/hda</emphasis> and <emphasis>/dev/hdc</emphasis>. Windows partitions we are searching for are named <emphasis>/dev/hda2</emphasis> and <emphasis>/dev/hda5</emphasis> (see? it says FAT16 and NTFS there). Now create <emphasis>/mnt/hda2</emphasis> and <emphasis>/mnt/hda5</emphasis> directories (using the '<command>mkdir</command>' command) and edit <emphasis>/etc/fstab</emphasis> to make your changes permanent:
</para><para>
<screen>
# mkdir /mnt/hda2 /mnt/hda5

# And append this to /etc/fstab:
/dev/hda2 /mnt/hda2 vfat defaults,ro 0 0
/dev/hda5 /mnt/hda5 ntfs defaults,ro 0 0
</screen>
</para><para>
As root, type '<command>mount /mnt/hda2</command>' and windows data will be there, under <emphasis>/mnt/hda2/</emphasis>. The same procedure applies to the hda5 partition.
</para>
<para>
By adding the above to <emphasis>/etc/fstab</emphasis> we ensured it gets mounted on every boot. If you don't want that, add the 'noauto' option to the Options field ('defaults,ro'). Also, replace 'ro' with 'rw' if you want full read-write access.
</para>
<para>
Also, to mount MS windows partitions, you need appropriate kernel module support, but Linux loads it automatically. See 'lsmod' output, you should see 'vfat' or 'nfts' there after you mount some windows partition.
</para>
</sect2>

</sect1>




<!-- LINUX PROCESSES -->
<sect1 id="lproc" xreflabel="Linux processes">
<title>
Linux processes
</title>

<para>
In this chapter we will explain the processes and the way they run under the Linux kernel. Furthermore, you will learn common methods to start, stop and control them.
</para>

<sect2 id="lproc-basics" xreflabel="Introduction">
<title>
Introduction
</title>
<para>
In order to get us clear on what does the word "process" really mean, I searched for a formal, fluent explanation from the <ulink url="http://www.whatis.com">WhatIs</ulink> database:
</para>
<blockquote>
<para>
A process is an instance of a program running in a computer. It is close in meaning to 'task', a term used in some operating systems. In UNIX, a process is started when a program is initiated (either by a user entering a shell command or by another program). Like a task, a process is a running program with which a particular set of data is associated, so that the process can be kept track of. An application that is being shared by multiple users will generally have one process at some stage of execution for each user.
</para><para> 
A process can initiate a subprocess, which is a called a child process (and the initiating process is sometimes referred to as its parent ). A child process is a replica of the parent process and shares some of its resources, but cannot exist if the parent is terminated.
</para><para> 
Processes can exchange information or synchronize their operation through several methods of interprocess communication (IPC).
</para>
</blockquote>
<para>
Processes in Linux work in isolated memory areas (called 'segments') and if a process start behaving badly, it surely won't affect the rest of the system.
</para>
</sect2>


<sect2 id="lproc-basiccmds" xreflabel="Basic process-related commands">
<title>
Basic process-related commands
</title>



<sect3 id="lproc-basiccmds-procs" xreflabel="Process lists">
<title>
Process lists
</title>

<para>
To see the full list of current processes on the system, type:
</para><para>
<screen>
$ ps aux
$ ps auxwww
</screen>
</para>
<para>
And the sample output would be:
</para>
<para>
<screen>
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
root       398  0.0  0.8  2872 1084 tty1     S    11:57   0:00 -bash
root       399  0.0  0.3  2136  412 tty2     S    11:57   0:00 /sbin/getty 38400 tty2
root       400  0.0  0.3  1616  412 tty3     S    11:57   0:00 /sbin/getty 38400 tty3
root       401  0.0  0.3  1484  412 tty4     S    11:57   0:00 /sbin/getty 38400 tty4
root       402  0.0  0.3  2292  412 tty5     S    11:57   0:00 /sbin/getty 38400 tty5
docelic   2850  0.0  0.7  2768  984 tty6     S    15:39   0:00 -sh
docelic   3114  0.0  0.6  2472  772 tty6     S    16:57   0:00 /bin/sh /usr/bin/X11/startx
docelic   3409  0.0  1.0  2332 1300 pts/2    S    17:20   0:00 -sh
docelic   3410  0.3  4.9  9048 6260 pts/2    S    17:20   0:04 gvim hands-on.sgml
docelic   3415  0.0  1.0  3032 1312 pts/4    S    17:21   0:00 -sh
docelic   3428  0.0  3.4  7524 4344 pts/4    S    17:24   0:00 gvim hands-on-guide,editing.sgml
docelic   3611  0.0  1.0  3040 1276 pts/0    S    17:43   0:00 -sh
root      3612  0.2  1.0  2648 1288 pts/0    S    17:43   0:00 bash
root      3614  0.0  1.2  3940 1604 pts/0    R    17:43   0:00 ps auwww
</screen>
</para>
<para>
Column names are in the first row. Few explanations:
</para>
<itemizedlist>
<listitem>
<para>
USER: Owner of the process (this also indicates the privileges a process has).
</para>
</listitem>
<listitem>
<para>
PID: Unique Process ID. Process IDs are used to distinguish processes, and are usually given incrementally. The numbers are not reused until the PID reaches its maximum value (32768 mostly) and begins from the start. 
</para>
</listitem>
<listitem>
<para>
CPU, MEM: Total time the CPU spent executing the task (notice this, the <emphasis>CPU</emphasis> time, not the real time), and the current ammount of memory occupied by the process.
</para>
</listitem>
<listitem>
<para>
TTY: The controlling terminal for a process (usually a place where the process was started from). If that field is empty (contains the <emphasis>?</emphasis> character), it means the process has detached from its terminal, or wasn't even started in an interactive mode.
</para>
</listitem>
<listitem>
<para>
STAT: Current process state: SW = swapped, S = sleeping, R = running.
</para>
</listitem>
</itemizedlist>
<note><title>Please Note:</title>
<itemizedlist>
<listitem>
<para>
The incremental order in which PIDs are selected can be changed; most of the system security patches modify this behavior (such as <ulink url="http://www.grsecurity.org">grsecurity</ulink>).
</para>
</listitem>
<listitem>
<para>
It is possible to restrict the list of processes a person can see (usually to its own processes).  Most of the system security patches will suggest you to do it.
</para>
</listitem>
<listitem>
<para>
It may happen that you see processes hung in states D or Z. The Z character indicates 'zombie' processes; those whose parent process didn't shut them down properly, (usually) due to its own abnormal termination. The 'D' indicates a process which is blocked in a kernel function call; such states are normal for a short periods of time, but if you see them in  the <command>ps</command> output, you'd better check what's actually going on.
</para>
</listitem>
</itemizedlist>
</note>
</sect3>


<sect3 id="lproc-basiccmds-mem" xreflabel="System, processor and memory information">
<title>
System, processor and memory information
</title>


<sect4 id="lproc-basiccmds-mem-uptime" xreflabel="uptime">
<title>uptime</title>
<para>
The <command>uptime</command> command reports current time, machine uptime, the number of login shells and the machine load:
</para><para>
<screen>
$ uptime
20:30:17 up  8:33,  5 users,  load average: 1.15, 1.19, 1.16
</screen>
<note><title>Please Note:</title>
<para>
The three numbers show load averages for the past 1, 5 and 15 minutes.
<!-- dodat ovdje mozda, da je to ono, process time distribution, ideal load 1.00 -->
</para>
</note>
</sect4>

<sect4 id="lproc-basiccmds-mem-free" xreflabel="free">
<title>free</title>
<para>
<command>free</command> displays the amount of free and used memory in the system:
</para><para>
<screen>
$ free
             total       used       free     shared    buffers     cached
Mem:        126500     100780      25720          0       7624      49324
-/+ buffers/cache:      43832      82668
Swap:       497972      31796     466176
</screen>
</para>

<itemizedlist>

<listitem>
<para>
Mem: The total ammount of available, used and free system memory. The 'shared' field should tell you how much memory is shared among processes, but you will most probably see <emphasis>zero</emphasis> (0) there, since the interface has changed in 2.4 kernel series, and the field was left for compatibility reasons.
</para>
</listitem><listitem>
<para>
The Swap: line shows the same information for the swap space.  A swap space is usually located on your hard disk and used as the virtual memory extension of a computer's real memory (random access memory). Having a swap space allows the kernel to pretend that you have more RAM than you actually do.
</para>
</listitem>
</itemizedlist>

<note><title>Please Note:</title>
<para>
<itemizedlist>
<listitem>
<para>
System programs never get swapped out to the swap space; only the user and modified data does (because the location of a binary file actually <emphasis>is</emphasis> its swap file :)
</para>
</listitem>
<listitem><para>
Many have asked why does the system use so much RAM (see the 100MB in our sample output). The answer to this question is very short, but let's not miss the opportunity to gain some more insight:
</para>
<blockquote>
<para>
Looking at the memory installed in a computer, we make the following diagram:
<mediaobject>
<imageobject>
<imagedata fileref="images/speeds.jpg" format="jpg">
</imageobject>
<imageobject>
<imagedata fileref="images/speeds.eps" format="eps">
</imageobject>
</mediaobject>
</para><para>
Hard disks are big (> 50 GB) but their access time is poor; RAM is faster and affordable in 512-1024MB ammounts; the processor cache is very fast but typically only 128-512KB big (on typical PC computers). Such structure is dictated by the cost of the components on the market.
</para><para>
Now, the processor cache and the system RAM are just subsets of the hard disk memory (except for the runtime-generated data, of course).
It is a total waste (and an agression on system performance) to delete data from the system RAM; the runtime cost to retrieve it again from the hard disk is high. Therefore, the system keeps it loaded for as long as possible. To see the realistic RAM usage, refer to the "-/+ buffers/cache:" column in the <command>free</command> output, which subtracts the buffer and cache sizes from the total ammount of used memory.
</para>
</blockquote>
</listitem>
<listitem>
<para>
Commands to check out if you're interested in system swap memory are <command>mkswap, swapon</command> and <command>swapoff</command> (and the swap space is, of course, configured in the <emphasis>/etc/fstab</emphasis> file).
</para>
</listitem>
</itemizedlist>
</note>
</sect4>

<sect4 id="lproc-basiccmds-mem-top" xreflabel="top">
<title>top</title>
<para>
The <command>top</command> command is an interactive process monitor which shows system, processor and memory status, and the periodically updated list of most intensive system processes.
</para>
</sect4>

<sect4 id="lproc-basiccmds-mem-other" xreflabel="Other commands">
<title>Other commands</title>
<para>
Other interesting commands include <command>sar, iostat and mpstat</command> (from the <emphasis>sysstat</emphasis> package), <command>vmstat</command> (from the <emphasis>procps</emphasis> package), the graphical <emphasis>lavaps</emphasis> and native Gnome or KDE frontends.
</para>
</sect4>
</sect3>

<sect3 id="lproc-basiccmds-misc" xreflabel="Misc commands">
<title>Misc commands</title>
<para>
Three commands we definitely can't miss are <command>strace, lsof</command> and <command>fuser</command>. Maybe you won't use them right now, but consider this as an investment for the future.
</para><para>
The <command>strace</command> tool traces system calls and signals; its output could be overwhelming for you, but that's where the manpages and practice come into play.
</para><para>
<screen>
# strace ls
</screen>
</para><para>
<command>lsof</command> is an extremely useful tool that will give you a list of all open files (on a system or process basis).
</para><para>
<screen>
# lsof -p 1
</screen>
</para><para>
Finally, the <command>fuser</command> command will tell you which processes keep a file you specify in use.
</para><para>
<screen>
# fuser -v /dev/tty1
</screen>
</para>
</sect3>

</sect2>



<sect2 id="lproc-bintypes" xreflabel="Two distinct types of executable files">
<title>
Two distinct types of executable files
</title>
<para>
The process is, as we said already, an instance of a program. A program can either be a compiled (binary) file, or a script which needs an interpreter to run. Install the <emphasis>file</emphasis> package now, so that we can use the <command>file</command> command in our demonstration. The <command>/bin/ls</command> program is an example of a binary file:
</para><para>
<screen>
$ file /bin/ls
/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), stripped

$ vim /bin/ls
^?ELF^A^A^A^@^@^@^@^@^@^@^@
[we get a garbage of course ]
</screen>
</para><para>
Let's see what does <command>file</command> say for some other system executables:
</para><para>
<screen>
$ file `which dpkg`
/usr/bin/dpkg: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), stripped

$ file `which apt-cache`
/usr/bin/apt-cache: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), stripped

$ file `which pon`
/usr/bin/pon: Bourne shell script text executable

$ file /usr/bin/822-date 
/usr/bin/822-date: perl script text executable
</screen>
</para><para>
Now we know that <command>dpkg</command> and <command>apt-cache</command> are compiled, binary executables as well. We also know that the <command>pon</command> command is actually a Bourne shell script and the <command>822-date</command> is a Perl script. Try viewing them in a text editor.
</para><para>
From the UNIX system perspective, there's no real difference between the compiled and script executables. All the files need to have the exec bit set to be considered executable. File modes and permissions won't be explained here, see the <ulink url="http://www.debian.org/doc/manuals/user/ch-files.html#s-files-permissions">Debian User Reference Manual, section 4.4</ulink> for an explanation.
</para><para>
In addition to the exec bit, script files need to contain a "shebang" line, the special directive which specifies the intepreter to invoke if none was specified on the command line (in case you just type <command>/usr/bin/822-date</command> instead of <command>perl /usr/bin/822-date</command>, or <command>/usr/bin/pon</command> instead of <command>sh /usr/bin/pon</command>). Let's check out the first few lines from the <command>822-date</command> script and verify our predictions (don't get confused here, we are interested in the first line only):
</para><para>
<screen>
#! /usr/bin/perl --
# I hereby place this in the public domain - Ian Jackson, 1995.
# Changes by Klee Dienes also placed in public domain (1997). 

# time structure:
# [ sec min hour mday mon year wday yday isdst ]

@ARGV && die "usage: 822-date\n";

   .... ....

</screen>
</para><para>
Very well. This section actually has the purpose to teach you the following three things:
<itemizedlist>
<listitem><para>
Executable files are not neccessarily compiled binaries; they can be script files too, and if the shebang line is present, they can be started the same way the true binaries are (that is, just by typing in their name).
</para></listitem>
<listitem><para>
Script files are always associated with a specific interpreter. You could invoke "/usr/bin/pon", as well as "sh /usr/bin/pon" ( [interpreter name] [script file] [arguments] ).
</para></listitem>
<listitem><para>
Compiled, binary files have a variant of an interpreter too, although most people are not aware of it. For example, to run the <command>ls</command> command using an "interpreter" (it's actually "the helper program for shared library executables"), you would do:
</para><para>
<screen>
$ /lib/ld-linux.so.2 /bin/ls
</screen>
</para><para>
This thing could come very handy; I, however, leave it as an exercise for the reader to find out exactly when and how it can be used. [Don't you just love when the documentation says "an exercise for the reader" at point where it becomes the most interesting?]
</para></listitem>
</itemizedlist>
</para>
</sect2>




<sect2 id="lproc-start" xreflabel="How to start a process">
<title>
How to start a process
</title>
<itemizedlist>
<listitem>
<para>
Type the program name at the command prompt. This is okay if the program does its job quickly and then exits, or is a daemon process (which puts itself to background). Otherwise you won't get your command line back, since the program will open the terminal as its STDIN (Standard Input) channel.
</para><para>
<screen>
$ ls
</screen>
</para>
</listitem>
<listitem>
<para>
Type the program name followed by '&amp;'.
This is called a 'background process'. It returns the command prompt back to you, and the process resumes in background (or if it can't work in background, as it is the case with <command>tee</command> - it will wait till you resume it in foreground).
</para><para>
<screen>
$ tee&
</screen>
</para>
</listitem>
<listitem>
<para>
Use <command>nohup</command> to run a command immune to hangups, and with output redirected to a non-tty. Useful if you want to leave a task running on the system while you're gone (and logged out).
</para><para>
<screen>
$ nohup ls
</screen>
</para>
</listitem>
<listitem>
<para>
Use <command>nice</command> to run a command with specific priority.
</para><para>
<screen>
$ nice -n 5 top
</screen>
</para>
</listitem>
</itemizedlist>
<note><title>Please Note:</title>
<para>
If you try to run some of your own programs from the current directory just by typing their name, you'll most probably get the "Command not found" error [followed by my lesson on the PATH variable :) ].
</para><para>
PATH is an environment variable which holds the names of directories to search for executable files. When you type in the <command>ls</command> command, the system locates it (using the hints from the PATH variable) in the <emphasis>/bin/</emphasis> directory and executes from there. Only few standard directories are included in the path, so you'll have to prefix your non-standard command with "./" to indicate you want the specific command in a specific (current) directory:
</para><para>
<screen>
# Let's create a tmp directory, 'cd' into it and create a sample executable file to use in the demonstration
$ mkdir tmp; cd tmp
$ echo "echo Hello, World" > test.sh
$ chmod 755 test.sh

# Now let's try to run it (it will fail, because our current directory is not listed in the PATH)
$ test.sh
sh: test.sh: command not found

# Let's try it The Right Way
$ ./test.sh
Hello, World

$ cd ..
$ ./test.sh
sh: ./test.sh: No such file or directory

$ ./tmp/test.sh
Hello, World
</screen>
</para>
</note>

</sect2>

<sect2 id="lproc-term" xreflabel="How to terminate a process">
<title>
How to terminate a process
</title>
<itemizedlist>
<listitem>
<para>
Wait for process to terminate normally (when it finishes its job).
</para><para>
<screen>
$ who
</screen>
</para>
<note><title>Please Note:</title>
<para>
The <command>who</command> command has a very famous history, it originally appeared in 1967!
</para>
</note>
</listitem>
<listitem>
<para>
Log to another virtual console, use the <command>ps</command> command to find out the Process ID, and <command>kill</command> it.
</para><para>
<screen>
# This will work unless the process is in a bad state or ignoring the regular kill signals
$ kill [PID]

# This is the unconditional kill, which blows it out of the sky for good.
$ kill -9 [PID]
</screen>
</para>
<note><title>Please Note:</title>
<para>
The <command>kill</command> command is actually used to send any signal to a process, not just kill; see the kill(1) manpage.
</para>
</note>
</listitem>
<listitem>
<para>
If the process is interactive (i.e. it holds your command prompt), use Ctrl+C or Ctrl+D to finish it. The difference here is that Ctrl+C is intended to cancel the process, while Ctrl+D indicates 'end of input', so Ctrl+D is sometimes used to the tell the program to stop reading input, and to continue processing it.
</para><para>
<screen>
$ tee
 [Ctrl+c]
$
</screen>
</para>
</listitem>
<listitem>
<para>
If you started a process with '&amp;' at the end (and you're still on the same terminal), type '<command>jobs</command>' to see the list of background processes. Then just type <command>kill %[JOB]</command>
</para>
<para>
<screen>
$ tee&
[1] 5652

$ jobs
[1]+  Stopped(SIGTTIN)        tee

$ kill %1
[1]+  Terminated              tee
</screen>
</listitem>

<listitem><para>
Use the <command>killall</command> command, to kill processes by name.
</para><para>
<screen>
# killall ssh
</screen>
</para></listitem>

<listitem><para>
Use the <command>pkill</command> command to look up or signal processes based on name and other attributes.
</para></listitem>

</itemizedlist>
<note><title>Please Note:</title>
<para>
When the process terminates, you can see its exit status (that is, the exit status of the last executed command) by typing: 'echo $?'. Zero (0) indicates success; for other (error) values see the program documentation.
</para>
</note>

<note><title>Please Note:</title>
<para>
Be careful with <command>killall</command>. Its behavior is not the same on all UNIX machines.
</para>
</note>

</sect2>

<sect2 id="lproc-sleep" xreflabel="How to put a process on sleep">
<title>
How to put a process on sleep?
</title>

<para>
By sending a signal to it:
</para><para>
<screen>
kill -STOP [PID]
kill -CONT [PID]
</screen>
</para>

<para>
When you start a process in foreground, and it takes your prompt away, you can press 'Ctrl+z' to put it in background and stop it. Later you can issue <command>bg</command> or <command>fg</command> (to resume it in background or foreground). You can even put it to background, and then at some later point use <command>fg</command> to get back to it (but not after you close the controlling terminal, because logout disassociates tty from the process).
</para>

<para>
You can also press <emphasis>ctrl+s</emphasis> and <emphasis>ctrl+q</emphasis> on a process STDIN channel (usually your terminal) to pause/resume it.
</para>
</sect2>


<sect2 id="lproc-pri" xreflabel="Process priorities">
<title>
Process priorities
</title>
<para>
Linux (and other Unix) systems have a way to specify the priority of a process, which is (on Linux) in range from -20 (absolute priority) to 19 (which runs when there's nothing else to run).
Kernel process scheduler is a serious piece of software and it works as expected (unlike schedulers found in some non-Unix systems).
</para>
<para>
Regular users can only use values from 0 to 19 (and 0 is the default). To run a program with altered priority (for example, 'top'), do: 
</para>
<para><screen>
$ nice -n 10 top
# renice -10 -p [PID]
</screen></para>
</sect2>


<sect2 id="lproc-op" xreflabel="Processes and their input/output functions">
<title>
Processes and their input/output functions
</title>
<para>
Generally, each process will open 3 communication channels:
</para>
<orderedlist>
<listitem>
<para>
STDIN (Standard Input, 0) to retrieve the input data
</para>
</listitem>
<listitem>
<para>
STDOUT (Standard Output, 1) to output data
</para>
</listitem>
<listitem>
<para>
STDERR (Standard Error, 2) to print error messages
</para>
</listitem>
</orderedlist>
<para>
In a typical user session (just typing 'ls', for example), all three are open to your terminal - it's the place where you input information, and the place where the application outputs any info for you (including errors). However, those descriptors may be opened to a socket, pipe or any other place you can think of (including as input to another program or remote computer).
</para>
<para>
Let's look at an example:
(<command>grep</command> will search all files and print file lines which contain the string '/var/log/messages' in them):
</para>
<para><screen>
$ cd /etc
$ grep '/var/log/messages' *

grep: shadow: Permission denied
grep: shadow-: Permission denied 
grep: skel: Is a directory
grep: sound: Is a directory 
grep: ssh: Is a directory 
grep: syslog-ng: Is a directory 
syslog.conf:*.warn;mark.*;auth,authpriv.none /var/log/messages 
syslog.conf,old: mail,news.none -/var/log/messages 
syslog.conf.syslog-facility-old:*.=info;*.=notice;*.=warn %classic /var/log/messages 
grep: t1lib: Is a directory 
grep: terminfo: Is a directory 
grep: texmf: Is a directory
</screen></para>
<para>
Obviously, one part of output is valid data (reports from <emphasis>syslog.conf</emphasis> and <emphasis>syslog.conf,old</emphasis>), and the other part are error messages ('Is a directory' and 'Permission denied'). Now examine the following slightly modified commands and their descriptions:
</para>
<para><screen>
# redirect the stderr channel to the /tmp/errdata file
$ grep '/var/log/messages' * 2> /tmp/errdata

# redirect stdout to /tmp/errdata, and stderr to the stdout destination
$ grep '/var/log/messages' * > /tmp/outdata 2>&1

# same as the previous line (it's shorter, but doesn't work on some UNIX systems)
$ grep '/var/log/messages' * >& /tmp/outdata

# Send the contents of the /etc/syslog.conf file as input (stdin) to the tee command
$ tee < /etc/syslog.conf

# pass the output of 'ps aux' to the next command, 'cut', which discards everything but the first column and then prints it
$ ps aux | cut -d" " -f 1

# redirect the output of the 'ls -al' command to 'less', which lets you scroll the output
$ ls -al | less

# pass output to the 'grep' command which only prints lines containing the word 'root' and drops the rest
$ ls -al | grep root
</screen></para>





<sect2 id="lproc-leave" xreflabel="Leaving processes running while you're away">
<title>
Leaving processes running while you're away
</title>
<para>
You might want your processes to run while you are not logged in.
</para>
<para>
The first trick is to use <command>nohup</command> or '&' at program startup time (as we mentioned before).
</para>
<para>
If you already have it running, you might protect it with '<command>disown -h</command>' (but you won't find the <command>disown</command>'s man page, it's one of bash shell's built-ins, and is described in bash(1) manpage).
</para>
<para>
<screen>
$ ./mycommand &
$ nohup ./mycommand2
$ nohup ./mycommand3 &
$ disown -h %1
</screen>
<note><title>Please Note:</title>
<para>
Note however that you won't be able to re-gain control of the process input/output functions once you log back in, you only ensure they are not closed along with your shell when you log out.
</para>
</note>

<para>
The superior way is to use the <command>screen</command> utility which allows you to resume complete sessions.
Use Ctrl+a,d to detach and <command>screen -r [ID]</command> to resume a session. Familiarity with <emphasis>screen</emphasis> comes handy on remote UNIX shells or systems which don't have virtual consoles yet (such as The Hurd).
</para>
</sect2>
</sect1>








<!-- USING DEBIAN GNU -->
<sect1 id="debuser" xreflabel="Using Debian GNU">
<title>Using Debian GNU</title>

<sect2 id="debuser-vc-ks" xreflabel="Common keystrokes">
<title>Common keystrokes</title>

<itemizedlist>
<listitem>
<para>
Use Shift + PageUp/PageDown keys to scroll the text that ran out of the visible screen area
</para>
</listitem>
<listitem>
<para>
Ctrl+l to clear the screen (or type <command>clear</command>)
</para>
</listitem>
<listitem>
<para>
Ctrl+s to stop terminal output (actually, to stop the application producing it), and Ctrl+q to resume.
</para>
</listitem>
<listitem>
<para>
You can use <emphasis>splitvt</emphasis> utility to split virtual console in two separate terminals. Once you start it (simply <command>splitvt</command>), you can switch between open consoles with Ctrl+w. Additional keystrokes are:
</para>

<itemizedlist>
<listitem><para>
Ctrl+o,q : quit
</para></listitem>
<listitem><para>
Ctrl+o,4- : make current window 4 lines smaller
</para></listitem>
<listitem><para>
Ctrl+o,2+ : make current window 2 lines bigger
</para></listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
To dump contents of a screen to a file, use <command>screendump</command> command.
</para>
</listitem>
</itemizedlist>
</sect2>



<sect2 id="debuser-terms" xreflabel="Terminal settings">
<title>
Terminal settings
</title>
<para>
For more on terminal settings, see: setterm(1), reset(1), tput(1), tset(1), stty(1), termcap(3) and terminfo(3X) man pages. We'll cover them only briefly here:
</para>
<itemizedlist>
<listitem>
<para>
disable screen blanking (otherwise primitive screensaver)
<screen>
setterm -blank 0
</screen>
</para>
</listitem>
<listitem>
<para>
disable beeps
<screen>
setterm -blength 0
</screen>
</para>
<note><title>Please Note:</title>
<para>
Under X, use <command>xset b off</command>.
</para>
</note>
</listitem>
<listitem>
<para>
set foreground and background
<screen>
setterm -foreground black; setterm -background white
</screen>
</para>
</listitem>
<listitem>
<para>
hide/show cursor
<screen>
setterm -cursor off; setterm -cursor on
tput civis; tput cnorm
</screen>
</para>
</listitem>
</itemizedlist>
<para>
Also, check out the console_codes(4) man page.
</para>
</sect2>

<!-- TODO: ENV VARS HERE -->

<sect2 id="debuser-vim" xreflabel="Learning and using the vim editor">
<title>
Learning and using the vim editor
</title>
<para>
The UNIX core is text based and your primary input device should be a keyboard. I can understand that you most probably won't be attracted to an open source OS until you see the Gnome or KDE graphical desktop environments, but when you decide to get deeper in the system, you'll value your keyboard.
</para><para>
Having a text editor (not the word processor, note the difference!) of preference is a <emphasis>must</emphasis> with UNIX; almost everything you do will somehow be related to a plain text format.
</para><para>
Most people would tell you to start with joe, nano, pico or some graphical editor ("just until you get the grip"), but I consider this approach to be wrong. Text editing is too important task to be learned the wrong way from the beginning. After all, there's nothing to be learned about those editors - they are simple, functionality-limited, and their common keystrokes are listed at the bottom of the screen so you should understand the whole story the first time you start them.
</para><para>
The category of professional text editors is reserved for the two old rivals - Richard Stallman's <emphasis>GNU Emacs</emphasis> and Bram Moolenaar's <emphasis>Visual IMproved</emphasis> (or the old traditional <command>vi</command>). As you chould have guessed from the title, I prefer vim, but there's no doubt both editors are professional, and one's personal preference should be respected.
</para><para>
I don't want to harass verified Emacs users, they have my permission to skip the rest of this subsection.
</para><para>
VIM is the professional programmers' text editor. Apart from having ultra fast keystrokes, macros, abbreviations, editing modes, syntax highlighting and keyword completion, it can literally solve it's way out of a maze (see  <emphasis>/usr/share/doc/vim/macros/maze/</emphasis>).
</para><para>
To install <emphasis>vim</emphasis> and the related tools, you would typically do:
</para><para>
<screen>
# apt-get install vim vim-gtk vim-scripts exuberant-ctags
</screen>
</para>
<para>
Maybe the biggest advantage of <emphasis>vim</emphasis> (or plain old <emphasis>vi</emphasis> in this context) is that it is probably installed on every UNIX system you can think of. If you ever get to using some of the traditional UNIX operating systems, you'll thank me for it :)
</para><para>
Additionally, you can use vim as the default text editor inside your Gnome apps, using the Bonobo system (and there is a standalone, graphical interface to vim - <command>gvim</command>). KDE users should see <command>kvim</command>.
</para><para>
A very important thing to note is that <emphasis>vim</emphasis> supports few different <emphasis>editing modes</emphasis>. When you run it, it automatically enters the <emphasis>command</emphasis> mode, meaning that you can't just start typing; letters would be interpreted as commands, not the characters you'd like to appear in the text document.
</para><para>
The <emphasis>most trivial</emphasis> thing you could do is to type "a" or "i" (Append or Insert) when you want to enter the insert mode (so that you can actually type something in your document). To save and quit, you'd press ESC (which switches back to command mode) and type ":wq" (to Write and Quit).
</para><para>
The subject is, of course, too complex to cover here; I'll point you to "vimtutor" and few external resources:
</para>
<itemizedlist>
<listitem><para>
Type <command>vimtutor</command> on the command line
</para></listitem>
<listitem><para>
<ulink url="http://vim.sf.net">Vim sourceforge project page</ulink>
</para></listitem>
<listitem><para>
<ulink url="http://metacosm.dhs.org/tutorial.html">An excellent vim guide by MetaCosm</ulink>
</itemizedlist>

<note><title>Please Note:</title>
<para>
Definitely don't miss the opportunity to learn <emphasis>vim</emphasis> or <emphasis>GNU Emacs</emphasis> before continuing! It is an effort that pays off before you even start ;-)
</para>
</note>
</sect2>


<sect2 id="debuser-bashbind" xreflabel="The readline key and function bindings">
<title>
The readline key and function bindings
</title>
<para>
Fire up the bash(1) man page, press <emphasis>/^SHELL BUILTIN COMMANDS</emphasis> (to search for that phrase at the beginning of a line), and then search for 'bind' (type <emphasis>/bind</emphasis>).
</para><para>
More information can be found in the <emphasis>/usr/share/doc/bash/</emphasis> directory.
</para>
</sect2>


<sect2 id="debuser-cfgs" xreflabel="User configuration files">
<title>
User configuration files
</title>
<para>
As you probably know by now, standard UNIX system users do not have write permissions everywhere, the list is often limited to various temporary locations and their home directory. 
</para><para>
While most system services keep their configuration files in the /etc/ directory, it's obvious the users can't do the same, they need private and isolated areas to save their preferences (and finally, they don't have permissions to put anything in /etc/). Therefore, their configuration information is saved in <emphasis>dotfiles</emphasis> in their home directory. The <emphasis>dotfile</emphasis> is simply a file whose name starts with a dot (say, ".vimrc"); such files are considered hidden, and are not shown in the directory listing output, unless you use the <command>-a</command> (--all) switch.
</para><para>
Applications generally use fallbacks to load the configuration information. It means they first check the [runtime] command line options which have the highest priority. Next are the environment varibles, followed by dotfiles and finally the generic configs (could be from /etc/).
</para><para>
Typically, an application will create its dotfiles when you run it for the first time.
</para>
</sect2>




<sect2 id="debuser-alias" xreflabel="Command aliases">
<title>
Command aliases
</title>
<para>
Let's say you like the structured output of 'ls -al', but you would like to type 'll' instead of the complete 'ls -al'. The solution to his problem is called 'an alias' and is implemented on the shell level. Edit your ~/.bash_profile and add something like this:
</para><para>
<screen>
alias ll='ls -al'
</screen>
</para><para>
Re-read that config file:
</para><para>
<screen>
# Type
$ source ~/.bash_profile

# Or
$ . ~/.bash_profile 

# Or press
 Ctrl+x,Ctrl+r 
</screen>
</para><para>
Type <command>ll</command> and enjoy :)
</para>
<note><title>Please Note:</title>
<para>
As you might have noticed, format of .bash_profile and .bashrc files is very simple, you put the same commands you would type on the command line there. We have saved the alias information in ~/.bash_profile because we want to have it when we log in some other time too (otherwise we could have just executed the alias command on the command line).
</para>
</note>
</sect2>



<sect2 id="debuser-af" xreflabel="Advanced command line features">
<title>Advanced command line features</title>
<para>
Most probably, you are using the bash shell (<command>echo $SHELL</command>) with the 'readline' support included. Readline is "the library that handles reading input when using an interactive shell". While traditional Unix users despise bash (a waste of memory, they say), bash and readline form a deadly efficient user environment.
</para>
<para>
Let's take a look at just few of their features:
</para>
<itemizedlist>
<listitem>
<para>
Type 'history' to see a list of previously executed commands. History is saved in your ~/.bash_history file. New commands get appended to the file after you close a terminal session. If you want to exit without saving history, you can close the shell with <command>kill -9 $$</command> or <command>kill -9 0</command> . However, that is not the regular way - the regular way is to read about history feature in 'bash' man page and disable it properly (bash manpage is large, when you open it, type '/hist' to search for sections talking about the history feature).
</para>
</listitem>

<listitem>
<para>
Use Arrow Up and Arrow Down keys to scroll through the history buffer (which is saved between sessions). Use Home and End keys to move cursor position within the line. If they don't work (the home or end key), you can achieve the same with Ctrl+a, Ctrl+e (and backspace with Ctrl+h).
</para>
</listitem>

<listitem>
<para>
Use TAB to complete commands or file names. Type 'cat /etc/syslog.' and press TAB, you'll see what it does.
</para>
</listitem>

<listitem>
<para>
Use Alt+. (dot) or Esc,Shift+_ to repeat the last argument from the previous command. To choose which argument you want repeated, use longer form: Esc, arg_number, Ctrl+Alt+y.
Try something like: 
</para><para>
<screen>
mkdir x
cd Alt+.
</screen>
</para>
</listitem>

<listitem>
<para>
Events
</para>

<itemizedlist>
<listitem>
<para>
!! : repeats last command
</para>
</listitem>
<listitem>
<para>
!-1 : repeats last command
</para>
</listitem>
<listitem>
<para>
!co : repeats last command starting with 'co'
</para>
</listitem>
<listitem>
<para>
!n : executes command N from the history list
</para>
</listitem>
</itemizedlist>
</listitem>

<listitem>
<para>
Press Ctrl+R, then start typing a command until you see the line you want (this "reverse search" searches the history buffer for command which is most similar to the fragment of text you type in).
</para>
</listitem>
<listitem>
<para>
When changing directories, there are a few hints: you can get back to previous dir you were in by typing 'cd -'. You achieve the same (although you can put more directory names in the list) with pushd and popd (say, 'cd /bin; pushd /etc/; popd')
</para>
</listitem>
<listitem>
<para>
You would then most probably like to find out the names of programs you can start from the command line. Here's one nice little trick:
Type 'a' and press the TAB key twice. It will show you all available commands starting with 'a' (but that's not magic, you can see the same information by just typing 'ls' in <emphasis>/bin</emphasis>, <emphasis>/usr/bin</emphasis> and <emphasis>/usr/local/bin</emphasis> directories).
</para>
</listitem>
</itemizedlist>
</sect2>


<sect2 id="debuser-xsess" xreflabel="Customizing the X session">
<title>
Customizing the X session
</title>
<para>
Just as the name suggests, the file to look for is <emphasis>~/.xsession</emphasis>. You can find a proper example in <emphasis>/usr/share/doc/xfree86-common/examples/</emphasis>.
</para>
<para>
The <emphasis>~/.Xdefaults</emphasis> file would be a place to tune Xresources information (invoke <command>xrdb -load ~/.Xdefaults</command> command from the <emphasis>~/.xsession</emphasis> file to load it up).
</para>


<sect3 id="debuser-xsess-xbg" xreflabel="Choosing X backgrounds">
<title>
Choosing X backgrounds
</title>
<para>
Tastes vary; some prefer single-color backgrounds, some like gradients, some set pictures as backgrounds.
</para><para>
I've found it's possible to create very nice-looking backgrounds using the xplanet package (install xplanet and xplanet-images):
</para><para>
<screen>
$ xplanet -blend -grid  -label -projection mercator -quality 100 -rotate 45   -cloud_image clouds_2000.jpg&
$ xplanet -blend -grid  -label -projection mercator -quality 100              -cloud_image clouds_2000.jpg&
$ xplanet -blend -grid  -label -projection mercator -quality 100 -latitude 15 -cloud_image clouds_2000.jpg&
</screen>
</para>
<note><title>Please Note:</title>
<para>
The clouds_2000.jpg picture is located at the <ulink url="http://xplanet.sf.net/clouds_2000.jpg">xplanet project page</ulink> and is a realistic map of clouds surrounding the Earth (refreshed every 3 hours, and the image is about 500kb big).
</para><para>
It is possible to have xplanet generate a new picture every 5 minutes; see the xplanetbg(1) manpage and add it to the ~/.xsession file if you like the idea.
</para>
</note>
<para>
Good background pictures can be found in the <emphasis>debian-propaganda</emphasis> package.
</para><para>
Manually, you can set backgrounds with the <command>xsetbg</command>, <command>xsetroot</command> or <command>Esetroot</command> (from the <emphasis>eterm</emphasis> package) commands.
</para>
</sect3>


<sect3 id="debuser-xsess-scrnshot" xreflabel="Taking screenshots">
<title>
Taking screenshots
</title>
<para>
<screen>
# Use the traditional xwd
$ xwd -root >screenshot.xwd; convert screenshot.xwd screenshot.png; pngcrush screenshot.png; rm screenshot.xwd

# Use scrot 
$ scrot scrnshot.png

# Use import from the imagemagick package
$ import -comment "Gnome2 + theme xy" -compress jpeg -frame -screen screenshot.jpg
</screen>
</para>
</sect3>

</sect2>

<sect2 id="debuser-reportbug" xreflabel="Reporting bugs">
<title>Reporting bugs</title>


<itemizedlist>
<listitem><para>
Make sure the bug is reproducible and that you are using the latest version.
</para></listitem>
<listitem><para>
Set DEBMAIL and DEBFULLNAME environment variables:
</para><para>
<screen>
# export DEBMAIL="someone@something.org"
# export DEBFULLNAME="Your Name"
</screen>
</para></listitem>
<listitem><para>
<screen>
# reportbug  -bx [package]
</screen>
</para></listitem>
</itemizedlist>

<caution><title>Caution</title>
<para>
Do <emphasis>not</emphasis> get involved in reporting a bug unless you are 100% sure you have found a real problem; before thinking "It's a bug", ask yourself if you're actually experienced enough (in particular subject) to say what's a bug and what's not. Then definitely check if the problem was already reported. Package maintainers have enough work to do without your false and ridicule "bug" reports.
</para><para>
However great it might seem to report bugs (and feel you're "contributing" to the project), you should watch not to bee too passionate about it, there are better ways to contribute to Debian (writing documentation and man pages, for example).
</para>
</caution>

</sect2>




</sect1>



<sect1 id="tryy" xreflabel="Try it yourself first">
<title>Try to do it yourself first</title>

<para>
We are now really close to the end of this guide. One of the things I said in the introduction note was this:
</para>
<blockquote>
<para>
It is a step-by-step document which should answer most of your questions and help you build a sane mindset to continue on your own; I am known for repeating that the idea and logic count, not the exact implementation or usage details. 
</para>
</blockquote>

<para>
<!-- TODO: Can we say it like this -->
To finish in style (and fullfil the promise, of course), we will now summarize the key points I tried to promote throughout the document:
</para>
<itemizedlist>
<listitem><para>
Debian does not underestimate the intelligence of an average system user.
</para></listitem>
<listitem><para>
It is normal not to know all the usage details directly from your memory (especially if you haven't learned them yet :). Having the correct logic is, however, mandatory to know how to help yourself in UNIX.
</para></listitem>
</itemizedlist>


<sect2 id="ires-tasklist" xreflabel="A generic tasklist">
<title>A generic tasklist</title>

<para>
Here's the theoretical list of tasks you should perform for each problem to get in business:
</para>

<itemizedlist>
<listitem><para>
Properly define the problem:
</para>

<itemizedlist>
<listitem><para>
What do you want to do?
</para><para>
Divide your problem by logical steps. If you can't precisely express what exactly do you need done, let it mature overnight. Approach it from the perspective as broad as possible. 
</para></listitem>
<listitem><para>
Does your idea make sense?
</para><para>
If it works "most of the time", has obvious problems or needs additional effort to cover "special cases", chances are that you got it all wrong; you are using an environment designed to be free of half-assed solutions, remember? Re-evaluate your problem and call again tomorrow.
</para></listitem>
</itemizedlist>


<listitem><para>
How are problems similar to yours usually solved in UNIX/GNU/Debian/Linux?
</para><para>
Having little experience and trying hard to reinvent the wheel the wrong way is a waste of time and money. Try to spot a similar problem already solved and re-use the general mechanism.
</para>

<itemizedlist>
<listitem><para>
Try searching the <emphasis>man</emphasis> and <emphasis>info</emphasis> pages on your system.
Make sure your man-db is installed setuid root (<command>dpkg-reconfigure man-db</command>), then run <command>mandb</command> to re-generate the cache indexes. This will allow you to use the <command>apropos</command> and <command>whatis</command> commands, which can help you find the page(s) containing an answer.
</para><para>
To extract man or info pages into text files, just take advantage of UNIX pipes:
<screen>
$ man dpkg | col -b > /tmp/dpkg.man.txt
</screen>
</para>

</listitem>

<listitem><para>
Check out the appropriate directories under <emphasis>/usr/share/doc/</emphasis>. You can use the <command>find</command> and <command>grep</command> utilities to filter the useful material.
</para></listitem>

<listitem><para>
Check out the relevant web sites; <ulink url="http://www.debian.org">debian.org</ulink>, <ulink url="http://www.tldp.org">The Linux Documentation project</ulink> or others more closely related to your problem (listed in the Links section of this guide).
</para></listitem>

<listitem><para>
Use <ulink url="http://www.google.com">Google</ulink>, google.com/{<ulink url="http://www.google.com/linux">linux</ulink>,<ulink url="http://www.google.com/bsd">bsd</ulink>}, or the Google groups service and search by keywords (results from the mailing lists will be included too).
</para></listitem>
</itemizedlist>
</itemizedlist>

<sect2 id="ires-ircs" xreflabel="Getting help on IRC">
<title>getting help on IRC</title>

<para>
IRC, the Internet Relay Chat service, is a very convenient way to get help directly from the community, from the people who use or develop the same software you're using.
</para>

<sect3 id="ires-ircs-servs" xreflabel="IRC servers and channels">
<title>IRC servers and channels</title>

<itemizedlist>
<listitem><para>
irc.oftc.net : #kernelnewbies,#lartc,#holarse
</para></listitem>
<listitem><para>
irc.openprojects.net : #debian,#debian.de,#debian-bugs,#debian-kde,#debian-oo,#c,#offtopic,#perl,#security,#crystalspace,#blenderchat,#vim,#devtools
</para></listitem>
</itemizedlist>

<para>
You can use <emphasis>/msg chanserv info #[channel]</emphasis> to get more information about a specific channel.
</para>
</sect2>



<sect2 id="ires-ircs-ques" xreflabel="How not to ask questions on IRC">
<title>How <emphasis>not</emphasis> to ask questions on IRC</title>

<para>
IRC itself is just a protocol. Many written and spoken conventions have been established on top of it (especially since the Free Software networks started appearing).
</para><para>
The <emphasis>rules</emphasis> are very 'natural' and do not impose restrictions, they just define few things you could do to avoid annoying other people on the channel, and to raise the probability of getting an answer to your question.
</para><para>
Many newcomers start discussing completely off-topic issues (including, but not limited to, their private lives) on channels like #debian (which is a very much Debian-related (who would guess?) place). When someone warns them, they feel insulted and not welcome. Please note that #debian is a <emphasis>big</emphasis> channel (500+ people) and we all have to follow some rules, if we want the whole thing to function.
</para><para>
I've tried to compile a summary (mostly taken from the <emphasis>apt</emphasis>'s database [apt is an IRC robot (bot) on #debian]) of things you should[n't] do:
</para>
<itemizedlist>
<listitem><para>
If you have a question, please just *ask it*. And don't address specific people - ask the channel. If somebody knows, they'll answer :) To get help quicker, don't ask "can I ask a question," "can anyone help," or "does anybody use/know about foo". Be as specific as you can. Specific, Informative, Complete, Concise, and On-topic. Don't be demanding or insulting; please don't /msg people without permission.
</para></listitem>
<listitem><para>
Do not start by saying your program doesn't work. Look buddy, doesn't work is an ambiguous statement.  Does it sit on the couch all day?  Does it want more money?  Does it waste its time on IRC all day long?  Please be specific!  Define 'it' and what it isn't doing.
</para></listitem>
<listitem><para>
Do not ask questions such as "Can someone guide me through <emphasis>xyz</emphasis>?" or "Could somebody tell me about xyz?". If you're a normal person at all, you'd come to conclusion that we are not willing to write a book for you (in realtime!) or be your handholder. Most of the subjects we're talking about are very broad, so in absence of your proper problem description we wouldn't even know where to start.
</para><para>
All the documentation you need is already available, and there's no excuse for not reading it. Asking the channel instead of examining it <emphasis>first</emphasis> (and trying it on your own, of course) is a dangerous shortcut you should not be taking.
</para></listitem>
<listitem><para>
Don't repeat yourself, use excessive punctuation, paste blocks in non-#flood channels, or repeatedly annoy people in private. "Playing" ascii graphics is the other nasty one you should avoid.
</para></listitem>
<listitem><para>
If you're a Debian newbie (a beginner), do not try to answer other people's questions unless you're 100% sure you're right. The reason you came to the channel is learning, not misinforming other people; don't make the channel's life harder.
</para></listitem>
<listitem><para>
When talking to a specific person in the channel, please prefix the messages with his/her nick. Most IRC clients support TAB nick completion nowadays.
</para></listitem>
</itemizedlist>

<para>
The spectre of possible problems is very broad and the effort needed to describe the problem varies. Generally:
<itemizedlist>
<listitem><para>
Do not press ENTER instead of the Spacebar; do not waste lines. Ideally, everything should fit in a single line (and if it doesn't, your client will probably split it automatically, so you just don't bother about the line length).
</para></listitem>
<listitem><para>
We assume you tried to solve the problem on your own before asking on IRC, therefore include the information on:

<itemizedlist>
<listitem><para>
How did you obtain the software (i.e. "apt-get install xxx")
</para></listitem>
<listitem><para>
What was the initial goal you wanted to accomplish 
</para></listitem>
<listitem><para>
How did you approach it
</para></listitem>
<listitem><para>
Where specifically did you run into trouble
</para></listitem>
</itemizedlist>

<para>
By constructing such correct and precise question, you allow people to identify your problem and answer without asking numerous other subquestions.
</para><para>
Besides, some people try to do things the wrong way. They start asking about an issue, and after 30 mins of discussion, they finally mention it's a part of "something else" they wanted to do, and then we come to the conclusion they took the completely wrong path. By describing the problem properly, you allow other people to evaluate your whole idea, not just the specific problem.
</para>
</itemizedlist>
</para>

</sect2>


<sect2 id="ires-links" xreflabel="Links">
<title>Links</title>


<para>Debian GNU related</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.debian.org">The official Debian website</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://people.debian.org/~igenibel/">Debian package information (by developer)</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.debian.org/doc/">The official Debian documentation</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://people.debian.org/~blade/install/">The Debian GNU installation guide</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.apt-cacher.org/">The Apt-Cacher website</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://people.debian.org/~branden/">The Debian's X Strike Force homepage</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://newbiedoc.sf.net/">The Newbiedoc project: Debian documentation</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.debianplanet.org/">Debian community website (debianplanet), see unofficial apt sources there</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.dedasys.com/pow/">Debian Package of the Week</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.esdebian.org/">Debian community, Spain (esdebian)</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.debianworld.org/">DebianWorld</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.emdebian.org/">Embedded Debian (emdebian)</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.debianshop.org/">Support Debian by buying from DebianShop</ulink>
</para></listitem>

</itemizedlist>


<para>GNU</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.gnu.org/">The GNU project and The Free Software Foundation</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://hurd.gnu.org/">The Hurd</ulink>
</para></listitem>
</itemizedlist>


<para>Linux</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.kernel.org/">The Linux Kernel homepage</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.kerneltrap.org/">The KernelTrap website</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.linux-mm.org/">The Linux-MM website</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.kernelnewbies.org/">The Linux KernelNewbies website</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.bitwizard.nl/sig11/">The Sig11 problem (during the kernel compilation)</ulink>
</para></listitem>
</itemizedlist>

<para>Software indices and projects</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.freshmeat.net/">Application and GUI theme index (freshmeat)</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.gnome.org/">The Gnome Project</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.kde.org/">The KDE Project</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://vim.sf.net/">Vim homepage</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.openoffice.org">The OpenOffice homepage</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.xfree86.org/">The XFree86 homepage</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://netfilter.samba.org">The netfilter/iptables homepage</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.cups.org">CUPS - The Common Unix Printing System</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.linuxprinting.org">LinuxPrinting website</ulink>
</para></listitem>
</itemizedlist>

<para>Pictures, logs and banners</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.linuks.mine.nu/volkany/">Debian GNU banners and logos</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://gnuart.onshore.com/">The GnuArt website</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.gamers.org/~quinet/lilo/">Animated LILO boot screens</ulink>
</para></listitem>
</itemizedlist>

<para>Misc</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.oftc.net/">The Open and Free Technology Network</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.cs.utk.edu/~shuford/terminal_index.html">The Archive of Video Terminal Information</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.cs.wustl.edu/~levine/Hints.html">The David Levine's Hints Page</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.linuks.mine.nu/ibackup/">The iBackup</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.bell-labs.com/history/unix/">UNIX history</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.sasquatch.com/%7Eshad/hacker-t.html">The hacker test</ulink>
</para></listitem>
</itemizedlist>

<para>Documentation</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.tldp.org/HOWTO/mini/X-Big-Cursor.html">The X11-big-cursor Mini-Howto</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.whitefang.com/sup/">An excellent UNIX Secure Programming FAQ</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://iptables-tutorial.haringstad.com/">The IPTables Tutorial</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.itprc.com/tcpipfaq/default.htm">The TCP/IP FAQ</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://sources.redhat.com/autobook/">The GNU Autoconf, Automake and Libtool</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.tldp.org/LDP/abs/html/">The Advanced Bash Scripting HOWTO</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.infodrom.org/Debian/doc/maint/">The Debian Maintenance HOWTO</ulink>
</para></listitem>
</itemizedlist>

<para>Games</para>

<itemizedlist>

<listitem><para>
<ulink url="http://www.nethack.org/">NetHack</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.frozen-bubble.org/">The Frozen Bubble game</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.jumpbump.mine.nu">Jump'n'Bump</ulink>
</para></listitem>

<listitem><para>
<ulink url="http://www.freeciv.org">FreeCiv</ulink>
</para></listitem>

</itemizedlist>

</sect2>

</sect1>

</article>

