<!-- Debian Network Administartor's Manual - Overview of TCP/IP -->

    <chapt id="tcpip">

      <heading>TCP/IP</heading>

      <p>
      автор = Duncan C Thomson <email>duncan@sciuro.demon.co.uk</email>
      </p>

      <p>
	обсуждаемые вопросы = IP протокол, TCP протокол, IP адресация,
	IP интерфейсы, маршрутизация
      </p>


<sect>Введение
<p>TCP/IP, как следует из названия, состоит из пары протоколов, на которых
построена большая часть сети Интернет. Хотя, физически, Интернет влкючает в
себя широкий круг сетевых технологий, от медленных модемных линий с Ethernet до
высокоскоростных сетей ATM, а круг приложений, работающих через них велик -
WWW и e-mail, протоколов, которые связывают всё воедино только два -
Internet Protocol (IP), и возможно, один из самых распространённых,
Transmission Control Protocol. Другой протокол, UDP, используется в некоторых
приложениях вместо TCP, особенно в LAN средах, но в Интернет безраздельно
властвует TCP/IP.</p>

<p>диаграмма: различные физические сети, IP, TCP и UDP, приложения</p>

<p>В начале главы описываются основы IP сетей, далее некоторые наиболее продвинутые свойства TCP/IP, доступные пользователю Debian.
</p>
</sect>

<sect>IP адресация

<p>Каждому компьютеру, подключаемому напрямую к Интернет (или к любой IP сети)
присваивается IP адрес. Адреса IP имеют длину четыре байта и обычно
записываются в виде четырёх десятичных чисел, разделяемых точками.
Примеры:
<list>
<item>10.34.92.111</item>
<item>127.0.0.1</item>
<item>172.19.220.2</item>
<item>192.168.50.109</item>
</list>
<p>IP адреса, обычно, определяют две вещи. Во-первых, они указывают на сеть, в
которой находится данный компьютер. Во-вторых, они указывают на определённый
компьютер в этой сети. Обе части этой информации заложены в IP адресе, и их
иногда называют <em>сетевая часть</em> и <em>машинная часть</em>. Для машинной
части определено два специальных значения - если машинная часть состоит из всех нулей, то этот адрес задаёт сеть (т.е. это <em>адрес сети</em>, а не
<em>адрес машины</em>). Если машинная часть состоит из всех единиц, то такой
адрес указывает на все машины в сети (т.е. это <em>широковещательный</em>
адрес).</p>

<p>Чтобы задать, какая часть IP адреса будет являться машинной частью, а какая сетевой частью, используется два метода. Первый (самый старый) метод лёгок для понимания, так что посмотрим как он работает. IP адреса делятся на несколько
<em>классов</em>, и каждый класс определяет как делится на сетевую и машинные части IP адрес.
<taglist>
<tag>Класс A</tag>
<item>В IP адресах класса А значения первого байта лежат в диапазоне от 1 до 126. Он задаёт номер сети, а оставшиеся три байта определяют номер машины.</item>
<tag>Класс B</tag>
<item>В IP адресах класса B значения первого байта лежат в диапазоне от 128 до
191. Первые два байта адреса определяют номер сети, а оставшиеся два байта
задают номер машины в этой сети.</item>
<tag>Класс C</tag>
<item>В IP адресах класса C значения первого байта лежат в диапазоне от192 до 223. Первые три байта задают номер сети, а оставшийся байт определяет номер отдельной машины этой сети.</item>
</taglist></p>

<p>Из списка выше вам могло показаться, что IP адреса, начиная с 224 и выше,
оказались незадействованными. Они принадлежат другим классам IP адресов, не
используются для обычных IP машин и не будут обсуждаться в этом разделе.</p>

<p>Также вам могло показаться, что IP адреса, начинающиеся с 127 не
используются. Эти IP адреса называются <em>кольцевыми (loopback)</em> адресами,
и используются для тестирования TCP/IP без фактического подключения к сети.</p>

<p>Всё это, конечно, хорошо, но что, если у нас имеется сеть адресов класса C, а
мы хотим разделить её на несколько сетей? Для этого существует второй метод
задания сетевых и машинных частей. В этом методе задаётся, помимо IP адреса,
<em>маска подсети</em>, в которой установленные биты указывают на сетевую
часть, а сброшенные - машинную часть. Так, например, вот маски подсети по умолчанию для различных классов сетей:
<taglist>
<tag>Класс A</tag>
<item>255.0.0.0</item>
<tag>Класс B</tag>
<item>255.255.0.0</item>
<tag>Класс C</tag>
<item>255.255.255.0</item>
</taglist></p>

<p>Они не дают нам никакой дополнительной информации по сравнению с
первоначальными классами адресов, о которых мы говорили ранее. Гибкость при
использовании масок подсетей в том, что мы можем произвольно выбирать разделение на сетевую и машинную части - например, маска сети 255.255.255.192 позволяет нам разделить сеть класса C на четыре части, по 64 машинных адреса в каждой. Удивлены? Давайте рассмотрим этот пример подробней.</p>

<p>Предположим, что у нас имеется сеть класса C с IP адресами, начинающимися
с 192.168.50. Если мы представим маску сети 255.255.255.192 в двоичной форме,
то обнаружим, что у последнего байта первые два бита равны единице (т.е., они
включаются в сетевую часть адреса), а последние шесть бит нулевые (т.е., они
формируют машинную часть). Итак, указывая вместе с IP адресами маску сети,
разделим нашу сеть на четыре, с <em>адресами сетей</em>, у которых младшие два бита будут установлены в четыре их возможные комбинации (00, 01, 10, 11), сохраняя при этом в машинной части адреса нули (т.е. это адрес сети, не конкретной машины):
<list>
<item>192.168.50.0</item>
<item>192.168.50.64</item>
<item>192.168.50.128</item>
<item>192.168.50.192</item>
</list></p>

<p>Теперь мы понимаем, откуда появились четыре сетевых адреса. А что с нашими адресами машин? Они получаются установкой машинной части в каждой <em>подсети</em>в значения от 000001 до 111110 (вспомните -все единицы это широковещательный адрес). Это и даёт нам по 62 машины в каждой сети, диапазоны адресов:
<list>
<item>192.168.50.1 - 192.168.50.62</item>
<item>192.168.50.65 - 192.168.50.126</item>
<item>192.168.50.129 - 192.168.50.190</item>
<item>192.168.50.193 - 192.168.50.254</item>
</list></p>

<p>В Linux, если мы не указываем, что используем маску сети, программное
обеспечение обычно предполагает, что мы хотим использовать маску сети по умолчанию для определённого класса IP адресов. Вам нужно указывать маску сети, если вы пользуетесь одной из нестандартных схем для некоторого класса IP адресов. В любом случае, задать маску сети никогда не повредит.</p>

<p>Каждый IP адрес должен быть <em>уникальным</em> в сети Интернет или другой сети IP. Это означает, что вы не должны назначать IP адреса наобум, т.к. большинство IP адресов уже используется в Интернет. Чтобы получить законный набор IP адресов для ваших машин, обычно вы можете обратиться к Провайдеру услуг Интернет (ISP). Если у вас нет такого выделенного диапазона адресов, то вы должны использовать один из диапазонов <em>частных</em> IP адресов, стоящих отдельно от интернет или используемых для тестирования. Проверьте, что вы не сможете подключиться к Интернет напрямую из такой сети; для этого вам нужно воспользоваться одним из Трансляторов Сетевых Адресов (NAT). Вот диапазоны для частного использования:
<list>
<item>10.0.0.0: одна сеть класса A</item>
<item>172.16.0.0 - 172.31.0.0: 16 сетей класса B</item>
<item>192.168.0.0 - 192.168.255.0: 256 сетей класса C</item>
</list></p>

</sect>

<sect>Настройка IP интерфейса

<p>Когда мы знаем, какой IP адрес нам нужно использовать для нашей машины, мы
можем поднять один из наших сетевых интерфейсов и назначить ему этот IP адрес (возможно, вместе с маской сети). В большинстве систем Debian, это выполняется при установке системы и для простой системы обычно редко требуется менять его.</p>

<p>Для присвоения IP адресов интерфейсам используется команда
<prgn>ifconfig</prgn>. В ядре Linux существует несколько различных сетевых
интерфейсов, некоторые из которых представлены ниже:
<taglist>
<tag>Loopback</tag>
<item>Кольцевому интерфейсу (<tt>lo</tt>), обычно присваивается IP адрес 127.0.0.1</item>
<tag>Ethernet</tag>
<item>Ethernet интерфейс (с именами типа <tt>eth0</tt>, <tt>eth1</tt>,
    <tt>eth2</tt>) используется для доступа к картам Ethernet</item>
<tag>PPP</tag>
<item>PPP поднимается Point-to-Point протоколом и используется для запуска
различных сетевых протоколов, включая IP, в последовательных каналах (null модем, модем, ISDN).  Они имеют имена типа <tt>ppp0</tt>, <tt>ppp1</tt></item>
<tag>Token Ring</tag>
<item>Устройства Token Ring доступны через устройства с именами типа <tt>tr0</tt>, <tt>tr1</tt></item>
<tag>Dummy</tag>
<item>Фиктивные сетевые драйвера используются в системах, которые имеют не всегда задействованные интерфейсы, чтобы иметь постоянный IP интерфейс для относящихся к делу адресов. Это устройства с именами <tt>dummy</tt>, или <tt>dummy0</tt>, <tt>dummy1</tt>, и так далее.
</item>
</taglist>
Также имеется широкий диапазон других сетевых устройств, включая SLIP, PLIP
(последовательный и параллельный канал IP), `shaper' устройства для управления
нагрузкой определённых интерфейсов, возможность иметь несколько IP адресов на
одном устройстве, такие как frame relay, AX.25, X.25, ARCnet, LocalTalk и
другие. Однако, здесь, мы остановимся на одном из наиболее распространённых - интерфейсе Ethernet.</p>

<p>В большинстве случаев, если вы хотите, чтобы ядро автоматически загружало
модули драйверов определённых устройств, то вам потребуется сделать изменения в
файле <prgn>/etc/conf.modules</prgn> или <prgn>/etc/modules</prgn>. Например,
для автоматической загрузки драйвера NE2000, вам требуется строчка:
<example>
alias eth0 ne
</example>
в файле <prgn>/etc/conf.modules</prgn>.</p>

<p>Простейший путь вызова <prgn>ifconfig</prgn> это просто набрать его имя:
<example>
# /sbin/ifconfig
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Bcast:127.255.255.255  Mask:255.0.0.0
          UP BROADCAST LOOPBACK RUNNING  MTU:3584  Metric:1
          RX packets:18584 errors:0 dropped:0 overruns:0 frame:0
          TX packets:18584 errors:0 dropped:0 overruns:0 carrier:0
          Collisions:0 
</example>.
В этом случае она просто покажет информацию о настроенных в данный момент
интерфейсах. Теперь, если мы хотим поднять Ethernet интерфейс с адресом 192.168.50.23, то требуется указать имя интерфейса и IP адрес в командой строке
<prgn>ifconfig</prgn>:
<example>
# /sbin/ifconfig eth0 192.168.50.23
# /sbin/ifconfig
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Bcast:127.255.255.255  Mask:255.0.0.0
          UP BROADCAST LOOPBACK RUNNING  MTU:3584  Metric:1
          RX packets:18584 errors:0 dropped:0 overruns:0 frame:0
          TX packets:18584 errors:0 dropped:0 overruns:0 carrier:0
          Collisions:0 

eth0      Link encap:Ethernet  HWaddr 00:00:E8:C5:64:2A  
          inet addr:192.168.50.23   Bcast:192.168.50.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:55 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5 errors:0 dropped:0 overruns:0 carrier:0
          Collisions:7 
          Interrupt:10 Base address:0x300 
</example>
Как видно из примера, <prgn>ifconfig</prgn> теперь выдаёт информацию о новом
интерфейсе, включая маску сети, статистику по сети и информацию о самом
драйвере сети. <prgn>ifconfig</prgn> также позволяет задать маску сети для настраевоемого интерфейса, например:
<example>
# /sbin/ifconfig eth0 192.168.50.23 netmask 255.255.255.192
</example>
Наконец, чтобы опустить интерфейс, используется такой вызов <prgn>ifconfig</prgn>:
<example>
# /sbin/ifconfig eth0 down
</example>
Полная информация о параметрах <prgn>ifconfig</prgn> описана в странице
справочника - <manref name="ifconfig" section="8">.</p>

<p>Если вы настроили IP адресацию на машине при установке Debian GNU/Linux, то
вы обнаружите, что команда <prgn>ifconfig</prgn> запускается при загрузке машины автоматически. Это делается из файла <prgn>/etc/init.d/network</prgn>. Файл выглядит примерно так:
<example>
IPADDR=192.168.50.23
NETMASK=255.255.255.0
BROADCAST=192.168.50.255
ifconfig eth0 ${IPADDR} netmask ${NETMASK} broadcast ${BROADCAST}
</example>
Именно здесь настраивается Ethernet интерфейс. Чуть выше этих строк, вы можете
обнаружить настройку кольцевого интерфейса, а также должны увидеть несколько
строк, в которой появляется команда с именем <prgn>route</prgn>. Это программа, и её функции описаны в следующем разделе.</p>
</sect>

<sect>Основы IP маршрутизации
<p>Теперь, когда IP интерфейс поднят, необходимо указать ядру Linux куда
посылать информацию для различных машин IP сети. В ядре есть таблица, называемая <em>таблицей маршрутов</em>, которая содержит номера машин или адреса сетей вместе с информацией о том, как посылать IP пакеты по своему назначению.</p>

<p>Команда <prgn>route</prgn> используется для проверки и обновления этой
таблицы. Если вы настроили только кольцевой интерфейс, то эта команда выдаст
информацию только о нём в следующем виде:
<example>
# /sbin/route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
127.0.0.0       *               255.0.0.0       U     0      0        2 lo
</example>
<p>Эта строка говорит о том, что весь поток для сети `127' должен направляться
через кольцевой интерфейс (<tt>lo</tt>). Колонка `genmask' указывает, в форме
напоминающей маску сети, что эта запись таблицы маршрутов должна применяться ко
всем соответствующим IP адресам, начинающимся с номера 127, независимо от
остальной части.</p>

<p>Если наша машина подключена к сети Ethernet, то нам надо проверить, что
таблица маршрутов ядра знает как посылать информацию в сеть. Предположим, что
наша машина будет 192.168.50.23 с маской сети класса C по умолчанию. Следующей
командой добавим запись в таблицу маршрутов для нашей локальной сети:
<example>
# /sbin/route add -net 192.168.50.0
# /sbin/route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
127.0.0.0       *               255.0.0.0       U     0      0        2 lo
192.168.50.0    *               255.255.255.0   U     0      0      137 eth0
</example>
<p>Это скажет ядру, что все IP адреса, начинающиеся с 192.168.50 находятся в
нашей локальной сети Ethernet и доступны через `eth0' интерфейс. Если вы используете нестандартную маску сети, то её можно задать параметром командной строки команды <prgn>route</prgn>:
<example>
/sbin/route add -net 192.158.50.0 netmask 255.255.255.192
</example>
<p>Этой команды достаточно, если наша TCP/IP сеть состоит из только одной сети
и не с кем не соединена. Однако, мощь TCP/IP заключается в её способностях <em>межсетевого взаимодействия</em>, а нормальная IP сеть состоит из более чем одной сети. Чтобы перенаправлять IP пакеты с вашей машины в другие сети, вам нужно указать <em>шлюзовые</em> машины (часто называемые маршрутизаторами), которые знают как посылать информацию в другие сети. Для этого есть две возможности.</p>

<p>Первая возможность применяется, если мы хотим пересылать IP пакеты в
определённую сеть и знаем адрес шлюзовой машины или маршрутизатор, который
доставляет информацию в эту сеть. Например, предположим, что в нашей сети существует машина 192.168.50.1, которая является маршрутизатором в сеть 172.20.0.0 (сеть класса B). Зададим команде <prgn>route</prgn> следующие параметры:
<example>
# route add -net 172.20.0.0 gw 192.168.50.1
</example>
<p>Т.к. наша таблица маршрутов уже содержит запись о том, как посылать
информацию в 192.168.50.1 (это в нашей локальной сети), то весь поток в
удалённую сеть 172.20.0.0 теперь будет посылаться через эту машину, которая
поступит с ним соответственно.</p>

<p>Другая возможность состоит в том, что мы можем воспользоваться определённым
шлюзом как <em>маршрутом по умолчанию</em> - маршрутом, используемым для всех
IP пакетов, для которых нет правил в нашей таблице маршрутов. Например, если
машина с IP адресом 192.168.50.254 является маршрутизатором в остальной мир
(Интернет, например), то мы используем команду <prgn>route</prgn> следующим
образом:
<example>
# /sbin/route add default gw 192.168.23.254
</example>
<p>Давайте ещё раз взглянем на нашу таблицу маршрутов:
<example>
# /sbin/route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
127.0.0.0       *               255.0.0.0       U     0      0        2 lo
192.168.50.0    *               255.255.255.0   U     0      0      137 eth0
172.20.0.0      192.168.50.1    255.255.0.0     UG    1      0        7 eth0
default         192.168.50.254  0.0.0.0         UG    1      0       36 eth0
</example>
	<p>Разберём её по строкам:
<enumlist>
<item>Во-первых, мы задаём кольцевой адрес для всех адресов 127.*.*.*</item>
<item>Далее, мы указываем, как добраться ко всем машинам нашей локальной сети,
определяемых как 192.168.50.*</item>
<item>Далее, мы задаём маршрут для всех машин в сети (172.20.*.*) через машину
192.168.50.1, которая является маршрутизатором (или шлюзом) для этой сети </item>
<item>Наконец, мы указываем, что машина 192.168.50.254 обрабатывает весь
остальной поток IP сообщений</item>
	  </enumlist>
</p>
<p>Сейчас, мы не будем обращать внимание что означают различные `flags', `metric' и `ref'.</p>

<p>Давайте ещё раз посмотрим на обычный файл <prgn>/etc/init.d/network</prgn>,
настроенный процедурой установки Debian для обычной машины, подключённой к Ethernet:
<example>
#! /bin/sh
ifconfig lo 127.0.0.1
route add -net 127.0.0.0
IPADDR=192.168.50.23
NETMASK=255.255.255.0
NETWORK=192.168.50.0
BROADCAST=192.168.50.255
GATEWAY=192.168.50.254
ifconfig eth0 ${IPADDR} netmask ${NETMASK} broadcast ${BROADCAST}
route add -net ${NETWORK}
[ "${GATEWAY}" ] && route add default gw ${GATEWAY} metric 1
</example>
<p>Первые две строки из сценария shell поднимают кольцевой интерфейс
и добавляют для него запись в таблицу маршрутов. Далее, переменным
присваиваются значение IP адреса нашей машины, маска сети, адрес нашей
локальной сети, широковещательный адрес и IP адрес нашего маршрутизатора по
умолчанию. Наконец, командой <prgn>ifconfig</prgn>, поднимается наш локальный Ethernet интерфейс, а два вызова команды <prgn>route</prgn> добавляют записи в таблицу маршрутов: первый для локальной сети, а второй для нашего маршрутизатора по умолчанию.</p>

<p>У вас может получиться так, что адреса (сетей или машин) в выводе команды
<prgn>route</prgn> будут представлены не в форме IP адресов, а по именам. Имена
сетей можно задать в файле <prgn>/etc/networks</prgn> ( который, обычно,
настраивается процедурами настройки Debian во время установки), а имена машин могут прийти с различных машин и из файла <prgn>/etc/hosts</prgn> и Службы именования доменов (DNS).
Теперь давайте, взглянем на DNS, что же это такое.</p>

</sect>

<sect>Служба именования доменов (DNS)
<p>Каждый компьютер, подключённый к Интернет или любой сети, использующей IP в качестве сетевого протокола, имеет IP адрес, чтобы он мог правильно отправлять и принимать информацию. IP адреса несколько сложны для запоминания человеком, и по этой причине каждой машине обычно присваивается ещё и имя. Во время установки Debian одним из вопросов, который вам задают, является вопрос о имени вашей машины.</p>

<p>Имя вашего компьютера хранится в нескольких местах. Вы можете узнать имя
вашего компьютера набрав команду <prgn>hostname</prgn>, которая возвращает
значение из файла <prgn>/etc/hostname</prgn>.
Если вы подключены к Интернет, это имя, обычно, состоит из нескольких частей, отделяемых друг от друга точками, например:
<example>
debian.anon.com
</example>
Первое слово до точки является именем вашего компьютера - оставшуюся часть
называют <em>доменным именем</em> - в примере это часть <tt>anon.com</tt>. Т.к. существует вероятность нескольких компьютеров в Интернет с одинаковыми именами, то для того чтобы имя было уникальным, каждый компьютер помещается в один из своих доменов. В домене, обычно, имеется человек, отвечающий за присвоение имён и адресов компьютерам, и который, к тому же, ведёт базу данных, хранящую все имена и адреса компьютеров этого домена. Эта система называется DNS и похожа на телефонный справочник - вы можете найти компьютер по имени и узнать его IP адрес.</p>

<p>До DNS людям приходилось запоминать IP адреса, чтобы работать в Интернет, а имена были только у небольшого числа машин, обычно находящихся в локальной сети и ещё, может быть, у одной или двух машин, с которыми имелась постоянная связь. Эти имена хранились в отдельном файле - <prgn>/etc/hosts</prgn> - вы обнаружите в нём имя вашей машины и IP адрес, которые добавляются в этот файл при установке Debian.</p>

<p>DNS является довольно сложной системой, и мы рассмотрим её немного позднее, вместе с программный обеспечением (<prgn>bind</prgn>), которое позволяет видеть дальше вашего домена с помощью DNS.</p>

<p>Однако, здесь мы рассмотрим как работает DNS с точки зрения
<em>клиента</em>, т.е. машины, которой нужно только находить другие машины с
помощью DNS, а не работать в качестве службы DNS.</p>

<p>Когда машине Debian требуется по имени другого компьютера определить его IP
адрес, он задействует набор процедур из библиотеки C, называемых <em>resolver</em>. Resolver процедуры, по очереди, просматривают, во-первых, файл <prgn>/etc/nsswitch.conf</prgn>, который, в отличие от <tt>hosts</tt>, описывает места, которые должен проверить resolver, чтобы определить IP адрес. Здесь может быть три типа возможных записей и если есть более одной, то resolver проверяет по порядку одну за одной. Типы записей:
<taglist>
<tag>files
<item>Искать имена машин в файле <prgn>/etc/hosts</prgn>
<tag>nis
<item>Искать имена машин базе данных NIS (которая будет рассмотрена позже)
<tag>dns
<item>Искать в службе именования доменов
</taglist>
Типичный файл <prgn>/etc/nsswitch</prgn>:
<example>
hosts:         files dns
</example>
Он говорит resolver, во-первых, искать в файле <prgn>/etc/hosts</prgn>, а затем
сделать запрос в DNS.</p>

<p>DNS настраивается в файле <prgn>/etc/resolv.conf</prgn>. Этот файл, обычно,
задаёт две вещи - во-первых, домен, в котором находится наша машина, а
во-вторых, адреса серверов имён, у которых можно узнать дополнительную
информацию.
Пример:
<example>
domain anon.org
nameserver 172.19.0.1
nameserver 172.19.5.1
</example>
Первая строка говорит библиотеке resolver о том, что если мы запрашиваем адрес
машины и не указываем имя домена, то к имени машины добавляется <tt>anon.org</tt>, т.е. resolver предполагает, что машины расположена в нашем домене. Две строки, начинающиеся с <tt>nameserver</tt>, задают IP адреса машин, которые обрабатывают DNS запросы. Они всегда должны задаваться IP адресами, а не именами, по вполне понятным причинам.</p>

<p>Большинство сетевых утилит автоматически определяют IP машины по её имени,
но если вы хотите обратиться к DNS напрямую, то для этого в пакете <tt>dnsutils</tt> есть программа <prgn>nslookup</prgn>. <prgn>nslookup</prgn> можно использовать, задавая имя машины в командной строки или интерактивно, просто запустив её как <prgn>nslookup</prgn>. Интерактивный режим позволяет осуществлять поиск IP адресов и содержит некоторые подсказки.</p>

<p><prgn>nslookup</prgn>, вместе с другими программами работы с DNS и
программным обеспечением, предоставляющим DNS сервис, подробно описывается далее.</p>

<p>Дальнейшую информацию по DNS смотрите в <ref id="bind">.

</sect>

<sect>Поиск неисправностей в ICMP и IP
</sect>

<sect>TCP и UDP
</sect>

<sect>Сервера, демоны и суперсервер
</sect>


    </chapt>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:"network-administrator.sgml chapt sect"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->

