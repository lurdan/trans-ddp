<!-- Debian Network Administartor's Manual - Overview of TCP/IP -->

    <chapt id="tcpip">

      <heading>TCP/IP</heading>

      <p>
      autor = Duncan C Thomson <email>duncan@sciuro.demon.co.uk</email>
      </p>

      <p>
	topics = protocolo IP, protocolo TCP, direcciones IP, interfaces IP, Enrutado
      </p>


<sect>Introducción
<p>TCP/IP, como su nombre sugiere, son dos protocolos, 
en los que esta basada la mayor parte de Internet. Internet
está construida físicamente por una gran cantidad de tecnologías de
telecomunicaciones, desde un lento modem que conecta a través de 
Ethernet, hasta redes conmutadas basadas en tecnología ATM de alta velocidad,
un gran número de aplicaciones funcionan sobre ellos - el WEB y el correo 
electrónico son sólo dos de todas ellas, los protocolos que manejan 
todo son IP (Internet Protocol o Protocolo de Internet), y, quizás el más 
importante en uso, TCP (Transmission Control Protocol o Protocolo de Control 
de Transmisiones). Otro Protocolo, UDP, es usado en vez de TCP por algunas 
aplicaciones, especialmente en redes LAN, pero en Internet es TCP/IP , el 
modelo por el que se rige todo.</p>

<p>diagrama: Varias redes físicas, IP, TCP y UDP, aplicaciones</p>

<p>Este capítulo describe en primer lugar las bases de las redes IP,y luego 
describirá algunas de las más avanzadas características del TCP/IP disponibles 
para el usuario de Debian.</p>
</sect>

<sect>Direcciones IP

<p>Cada ordenador conectado directamente a Internet (o a cualquier red basada 
en IP) está identificado por una dirección IP. La dirección IP consta de cuatro 
bytes largos, y normalmente se escribe con 4 números en decimal separados por 
puntos, como se puede ver en el siguiente ejemplo.
<list>
<item>10.34.92.111</item>
<item>127.0.0.1</item>
<item>172.19.220.2</item>
<item>192.168.50.109</item>
</list>
<p>La dirección IP típicamente identifica dos cosas. Primero, identifica 
la red en la que se encuentra un ordenador. Y segundo, identifica 
un ordenador en esa red. Ambos componentes de información residen 
en una dirección IP,y pueden ser llamados: la <em>parte de la red</em> 
y la <em>parte del puesto</em>.
Hay dos valores especiales de la parte del puesto que deberían ser 
mencionados aquí - si la parte del puesto son todos ceros ("0"), la dirección 
se refiere a toda la red (es decir, será una <em>dirección de la red</em> en 
vez de una <em>dirección de puesto</em>). En cambio, si la parte del puesto 
son todos unos ("1"), la dirección se referirá a todos los puestos de la red 
(es decir, será una dirección <em>broadcast</em>).</p>

<p>A fin de indentificar cuál es la parte que corresponde a la parte del 
puesto y cuál a la de la red, existen dos métodos a usar. El primero ( y el 
original) es más sencillo pero más difícil de entender, así que pasemos a ver 
cómo funciona. La dirección IP está dividida entre un número de <em>clases</em>,
y cada clase nos mostrará cómo dividir cada una de las dos partes de la dirección IP.
<taglist>
<tag>Clase A</tag>
<item>Una clase A de direcciones IP tiene como primer byte un número entre 1 
y 126. El primer byte de una clase A de direcciones IP identifica la red,
y los siguientes tres bytes identifican al puesto en esa red.</item>
<tag>Clase B</tag>
<item>Una clase B de direcciones IP tiene como primer byte un número entre 128 
y 191. Sus primeros dos bytes identifican la red,y los siguientes dos bytes al 
puesto en esa red.</item>
<tag>Clase C</tag>
<item>Una clase C de direcciones IP tienes como primer byte un número entre 192 
y 223. Sus primeros tres bytes identifican la red, y el siguiente byte identifica 
al puesto en esa red.</item>
</taglist></p>

<p>De esta lista se puede sacar la conclusión de que las direcciones IP 
que van desde el 224 hacia arriba no se usan. A no ser que estemos en otras 
clases, en las que no se usan IP´s normales, aunque esto no es tema de discusión 
en esta sección.</p>

<p>También habrá notado que las direcciones IP que comienzan por 127 no se han 
nombrado, estas direcciones son conocidas como direcciones <em>loopback</em> o 
de retorno, y pueden ser usadas para probar el TCP/IP sin estar conectado en ese 
momento a una red.</p>

<p>Esto está muy bien pero, ¿que sucedería si quisiéramos dividir una clase C de 
direcciones en varias redes? Entonces es cuando usaríamos el segundo método para 
averiguar cuáles son las diferentes partes de una dirección IP. Este método 
especifica en una dirección IP, una <em>máscara de red</em>, en la cuál son unos 
("1") en la parte de la red, y ceros ("0") en la parte del puesto.
Así que, por ejemplo, las máscaras de red de serie para las distintas clases son 
las siguientes:
<taglist>
<tag>Clase A</tag>
<item>255.0.0.0</item>
<tag>Clase B</tag>
<item>255.255.0.0</item>
<tag>Clase C</tag>
<item>255.255.255.0</item>
</taglist></p>

<p>Esto no nos da ninguna información adicional de la que nos dan las clases.
Pero la flexibilidad que nos permite usar máscaras de red,  es la de elegir 
arbitrariamente la división entre las partes de la red y la del puesto - por 
ejemplo una máscara de red como 255.255.255.192 nos permitirá dividir una clase C 
en cuatro partes, cada una de ellas de 62 direcciones para puestos. ¿Confundido? 
estudiemos el ejemplo con más detalle.</p>

<p>Supongamos que tenemos una red en clase C con  dirección IP que comienza por 
192.168.50 . Si convertimos la máscara de red 255.255.255.192 a binario,
podemos ver en el último byte, que los primeros dos bits son uno("1")(esto es,
están incluidos en la parte de la red de la dirección) y los últimos seis bits 
son ceros ("0") (éstos forman parte de la parte del puesto). Así que usando la 
dirección IP que le hemos dado, unido a su máscara de red, hemos dividido nuestra 
red en cuatro, con <em>direcciones de red</em> dadas por configuración, estos 
dos bits pueden tener las siguientes cuatro posibles combinaciones (00, 01, 10, 11) 
mientras que se mantenga la parte del puesto a cero
(para indentificar a la red):
<list>
<item>192.168.50.0</item>
<item>192.168.50.64</item>
<item>192.168.50.128</item>
<item>192.168.50.192</item>
</list></p>

<p>Ahora ya sabemos de donde vienen nuestras direcciones de red.
¿Y qué hay de las direcciones de puesto? Las tendremos en la configuración 
de la parte del host en cada <em>subred</em>  que irán los valores desde 
el 000001 hasta el 111110 (recuerda - con todo unos será la dirección de 
broadcast). Ésto nos dá un total de 62 puestos por cada red con direcciones:
<list>
<item>192.168.50.1 - 192.168.50.62</item>
<item>192.168.50.65 - 192.168.50.126</item>
<item>192.168.50.129 - 192.168.50.190</item>
<item>192.168.50.193 - 192.168.50.254</item>
</list></p>

<p>En Linux, si no indicamos que máscara de red estamos usando, se asumirá 
normalmente por el software que queremos usar la máscara de red por defecto 
para esa clase particular de direcciones.
Sólo haría falta especificar una máscara de red, si estás utilizando una que 
no es estandar para una clase particular de direcciones IP.
Pero tampoco pasa nada si la especificas.</p>

<p>Cada dirección IP debería ser <em>única</em> en Internet, o cualquier 
dirección de red a la que te conectes.  Esto significa que no puedes asignar 
direcciones IP al azar para tus puestos, porque la mayor parte de las 
direcciones IP se están usando en Internet. Así que para obtener un
conjunto de direcciones IP legales para tus puestos, tendrás acceso a través
de un ISP (Internet Service Provider o Proveedor de Servicios de Intenet).
Si no tienes asignado un rango de direcciones , deberias usar un rango de 
direcciones IP <em>privadas</em>, utilizadas para estar fuera de internet
o para pruebas. Ten cuidado, ya que no podrás conectarte a Internet 
directamente desde una red, necesitarás utilizar una forma de NAT 
(Network Address Translation o Traducción de Direcciones de Red) para hacer 
esto. Los rangos de direcciones IP utilizados para uso privado son:
<list>
<item>10.0.0.0: una sóla red de clase A</item>
<item>172.16.0.0 - 172.31.0.0: 16 redes de clase B</item>
<item>192.168.0.0 - 192.168.255.0: 256 redes de clase C</item>
</list></p>

</sect>

<sect>Configuración del Interdace IP

<p>Una vez que sabemos lo que es una dirección IP, desemos usarla para uno
de nuestros puestos, tendremos que traer una de nuestras NIC´s (Network
Interface Card o Tarjeta de Interface de Red) y asignarle una dirección de 
red (y posiblemente con su respectiva máscara de red).  En la mayor parte 
de los sistemas Debian esto se hace en la instalación y rara vez tendrás 
que cambiar en un sistema sencillo.</p>

<p>El comando <prgn>ifconfig</prgn> es el que se encarga de asignar las 
direcciones IP a las NIC´s. Hay un gran número de interfaces de red 
diferentes soportadas por el kernel de Linux,como las que pasamos 
a enumerar:
<taglist>
<tag>Loopback</tag>
<item>El interface loopback (<tt>lo</tt>), normalmente es configurado para 
la dirección IP  127.0.0.1</item>
<tag>Ethernet</tag>
<item>Los interfaces Ethernet (con nombres como <tt>eth0</tt>, <tt>eth1</tt>,
    <tt>eth2</tt>) son usados para las tarjetas Ethernet</item>
<tag>PPP</tag>
<item>El PPP (Point-to-Point Protocol o Protocolo Punto a Punto), es usado 
    como plataforma de otros protocolos, incluido IP, sobre toso tipo de 
    lineas serie (modem-nulo, modem, RDSI). Tiene nombres como <tt>ppp0</tt>,
    <tt>ppp1</tt></item>
<tag>Token Ring</tag>
<item>A los dispositivos Token Ring se acceden a través de nombre como <tt>tr0</tt>,
    <tt>tr1</tt></item>
<tag>Dummy</tag>
<item>Los controladores de red dummy son usados para sistemas que tienen 
    una interface de red que no siempre es, para mantener un interfaz de red
    permanente para una dirección importante. Los nombres de dispositivos son 
    de tipo <tt>dummy</tt>, o <tt>dummy0</tt>, <tt>dummy1</tt>, y siguientes.</item>
</taglist>
Hay gran cantidad de otros dispositivos de red sopotados, como SLIP, PLIP 
(Líneas serie y paralelo IP), dispositivos `shaper' para controlar el tráfico
de ciertos interfaces, la abilidad de tener varias direcciones IP asignadas a 
un sólo dispositivo, como las frame relay, AX.25, X.25, ARCnet, LocalTalk
y más.  Aunque aquí nos concentraremos en uno de los más comunes - el 
interfaz Ethernet.</p>

<p> En muchos casos , si quieres que el kernel cargue automáticamente 
ciertos controladores de dispositivo, puede requerir que hagas cambios 
en tu fichero <prgn>/etc/conf.modules</prgn> o <prgn>/etc/modules</prgn>. 
Por ejemplo , para cargar automáticamente el controlador NE2000, tendríamos 
la linea:
<example>
alias eth0 ne
</example>
en tu fichero <prgn>/etc/conf.modules</prgn>.</p>

<p>La manera más sencilla de llamar a <prgn>ifconfig</prgn> es teclear 
su nombre:
<example>
# /sbin/ifconfig
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Bcast:127.255.255.255  Mask:255.0.0.0
          UP BROADCAST LOOPBACK RUNNING  MTU:3584  Metric:1
          RX packets:18584 errors:0 dropped:0 overruns:0 frame:0
          TX packets:18584 errors:0 dropped:0 overruns:0 carrier:0
          Collisions:0 
</example>
Que devuelve la información sobre los interfaces configurados en ese 
momento. Si deseamos activar un interfaz Ethernet con la dirección 
192.168.50.23, especificaríamos el nombre de interfaz y la dirección 
IP en el comando <prgn>ifconfig</prgn>:
<example>
# /sbin/ifconfig eth0 192.168.50.23
# /sbin/ifconfig
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Bcast:127.255.255.255  Mask:255.0.0.0
          UP BROADCAST LOOPBACK RUNNING  MTU:3584  Metric:1
          RX packets:18584 errors:0 dropped:0 overruns:0 frame:0
          TX packets:18584 errors:0 dropped:0 overruns:0 carrier:0
          Collisions:0 

eth0      Link encap:Ethernet  HWaddr 00:00:E8:C5:64:2A  
          inet addr:192.168.50.23   Bcast:192.168.50.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:55 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5 errors:0 dropped:0 overruns:0 carrier:0
          Collisions:7 
          Interrupt:10 Base address:0x300 
</example>
Como podemos ver en el ejemplo, <prgn>ifconfig</prgn> nos da ahora 
información sobre el nuevo interfaz, incluida la máscara de red, las
estadísticas de red, e información sobre el controlador de red en sí 
mismo. <prgn>ifconfig</prgn> también permite la especificación de una 
máscara de red cuando el interfaz está configurado, por ejemplo:
<example>
# /sbin/ifconfig eth0 192.168.50.23 netmask 255.255.255.192
</example>
Por último, para desactivar un interfaz, usaremos la siguiente invocación 
de <prgn>ifconfig</prgn>:
<example>
# /sbin/ifconfig eth0 down
</example>
Toda la información disponible de las opciones de <prgn>ifconfig</prgn> se 
encuentra en la página de manual - <manref name="ifconfig" section="8">.</p>

<p>Si configuras la dirección IP de tu puesto en la instalación de 
Debian GNU/Linux, deberías encontrar que el comando <prgn>ifconfig</prgn> 
se arranca automáticamente en el inicio del sistema. Este trabajo lo 
realiza el fichero <prgn>/etc/init.d/network</prgn>. Si miramos este 
fichero veremos un número de líneas similares a éstas:
<example>
IPADDR=192.168.50.23
NETMASK=255.255.255.0
BROADCAST=192.168.50.255
ifconfig eth0 ${IPADDR} netmask ${NETMASK} broadcast ${BROADCAST}
</example>
Aquí es donde la configuración del interfaz Ethernet toma lugar. Bajo 
éstas líneas, deberíamos ver otra con la configuración del interfaz 
looback, y veríamos un número de líneas el las que aparece la llamada 
al comando <prgn>route</prgn>. Este programa, y sus funciones, son 
objeto de la siguiente sección.</p>
</sect>

<sect>Bases del Enrutado IP
<p>Una vez que el interfaz de red ha sido configurado,es necesario que 
le digamos al kernel  de Linux donde mandar la información para varios 
puestos en la red IP. El kernel mantiene una tabla, llamada una 
<em>tabla de enrutado</em>, en la cuál hay una lista de nñumeros de 
puestos o direcciones de red, junto con información de cómo mandar los 
paquetes IP a sus destinatarios.</p>

<p>El comando <prgn>route</prgn> es usado para examinar o actualizar 
esta tabla. Si el único interfaz configurado es el looback, este 
comando usado por sí sólo dará normalmente una salida como la que 
se muestra a continuación:
<example>
# /sbin/route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
127.0.0.0       *               255.0.0.0       U     0      0        2 lo
</example>
<p>Éste nos dice que ningún tráfico proveniente del identificador de 
red 127 debería ser enrutado a la interfaz loopback (<tt>lo</tt>). La 
columna `genmask' especifica, de alguna manera una máscara de red, por 
ésto esta tabla de enrutado debería ser usada para designar cualquier 
dirección IP que comience por el número 127, sin importar lo que le siga.</p>

<p>Si nuestro puesto está conectado a una red Ethernet, entonces 
debemos asegurarnos que la tabla de enrutado de kernel sabe a dónde 
mandar la información. Si asumimos que hemos configurado nuestro puesto 
para ser 192.168.50.23, con una máscara de red por defecto para una 
clase C, el siguiente comando añadirá una entrada para nuestra red local:
<example>
# /sbin/route add -net 192.168.50.0
# /sbin/route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
127.0.0.0       *               255.0.0.0       U     0      0        2 lo
192.168.50.0    *               255.255.255.0   U     0      0      137 eth0
</example>
<p>Ésto le dice al kernel que cualquier dirección IP que comience por 
192.168.50 está en nuestra red local Ethernet, y que debería ser enrutada 
a través del interfaz 'eth0'. Si estuviéramos usando una máscara de red 
no estandar, esto puede ser especificado por la opción de la línea de 
comandos del comando <prgn>route</prgn>:
<example>
/sbin/route add -net 192.158.50.0 netmask 255.255.255.192
</example>
<p>Un comando como los de arriba debería de ser suficiente si tu red 
TCP/IP consiste sólo en una red simple, sin conectarla a ningún otro 
sitio. De todas maneras, la mayore fuerza del TCP/IP son sus 
habilidades para el <em>trabajo en red en Internet</em>, y normalmente 
una red basda en IP consiste en más de una red. Así que para enrutar 
paquetes IP de tus puestos a otras redes, será necesario especificar 
puestos de <em>gateway o puerta de enlace</em> (también llamados 
<em>routers</em>) que tratan de mandar información a esas otras redes. 
Hay entonces dos posibilidades.</p>

<p>La primera es que queremos enrutar paquetes IP a una red específica, 
y sabemos la dirección del puesto gateway o router que entrega la 
información a esa red. Supongamos, por ejemplo, que ese es el puesto 
192.168.50.1 en nuestra red, que es una router de la red 172.20.0.0 
(una red de clase B). Las siguientes opciones del comando <prgn>route</prgn> 
lo especifican:
<example>
# route add -net 172.20.0.0 gw 192.168.50.1
</example>
<p>Nuestra tabla de enrutado ya contiene una entrada que nos dice cómo 
mandar la información a 192.168.50.1 (en nuestra red local), cualquier 
tráfico de la red remota 172.20.0.0 se mandado a este puesto, que lo 
entegará paropiadamente.</p>

<p>La otra posibilidad es que usamos un cierto gateway como una 
<em>default route</em> - una ruta usada por los paquetes IP que no 
corresponden con las leyes de nuestra tabla de enrutado. Si por 
ejemplo, el puesto con dirección IP 192.168.50.254 es nuestro router 
al resto del mundo (Internet, poe ejemplo), usaremos el comando 
<prgn>route</prgn> como sigue :
<example>
# /sbin/route add default gw 192.168.23.254
</example>
<p>Ahora, echemos un vistazo a la tabla de enrutado:
<example>
# /sbin/route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
127.0.0.0       *               255.0.0.0       U     0      0        2 lo
192.168.50.0    *               255.255.255.0   U     0      0      137 eth0
172.20.0.0      192.168.50.1    255.255.0.0     UG    1      0        7 eth0
default         192.168.50.254  0.0.0.0         UG    1      0       36 eth0
</example>
	<p>Expliquemos la tabla empezando desde arriba:
<enumlist>
<item>En primer lugar hemos especificado una dirección loopback para 
    todas las direcciones del tipo 127.*.*.*</item>
<item>Luego, hemos especificado como alcanzar todos los puestos de 
    nuestra, identificados como  192.168.50.*</item>
<item>Después, hemos dado una ruta a todos los puestos de la red 
    (172.20.*.*) conectados al puesto 192.168.50.1, que es un router 
    (o gateway) para esa red</item>
<item>Y finalmente, hemos especificado que el puesto 192.168.50.254 
    repartirá todo el tráfico restante</item>
	  </enumlist>
</p>
<p>Por ahora, no nos hemos ficjado el significan los acrónimos 
`flags', `metric' y `ref'.</p>

<p>Echemos una mirada a un típico fichero <prgn>/etc/init.d/network</prgn>,
configurado por la instalación de Debian en un puesto conectado a 
una red Ethernet normal:
<example>
#! /bin/sh
ifconfig lo 127.0.0.1
route add -net 127.0.0.0
IPADDR=192.168.50.23
NETMASK=255.255.255.0
NETWORK=192.168.50.0
BROADCAST=192.168.50.255
GATEWAY=192.168.50.254
ifconfig eth0 ${IPADDR} netmask ${NETMASK} broadcast ${BROADCAST}
route add -net ${NETWORK}
[ "${GATEWAY}" ] && route add default gw ${GATEWAY} metric 1
</example>
<p>Las primeras línes de este shell script configuran el interfaz 
loopback, y lo añaden como una entrada a la tabla de enrutado. La 
definición de las variables siguientes asignan una dirección IP a 
nuestro puesto, la máscara de red, la dirección de nuestra red, la 
dirección broadcast y la dirección de nuestro router por defecto. 
Finalmente, nuestro interfaz de red es configurado  con <prgn>ifconfig</prgn>, 
y dos llamadas al comando <prgn>route</prgn> añadiendo entradas para 
nuestra red local y luego para el gateway por defecto.</p>

<p>Ahora puedes ver las direcciónes ( de red y de puestos) en la 
salida del comando <prgn>route</prgn> no aparecen como direcciones 
IP, sino con nombres. Los nombres de redes pueden ser configurados 
en el fichero <prgn>/etc/networks</prgn> (que es normalmente 
configurado por las rutinas de configuración de red de Debian en la 
instalación), y los nombre de los puestos son incluidos en el fichero 
<prgn>/etc/hosts</prgn> y en el DNS (Domain Name Service o Servicio 
de Nombres de Dominio). Ahora pasamos a ver que es un DNS y que es 
lo que hace.</p>

</sect>

<sect>Servicio de Nombres de Dominio (DNS)
<p>Cada computadora conectada a Internet, o a cualquier red que usa IP 
como su protocolo de red, tiene una dirección IP, con el fin de que la 
información pueda ser enrutada hacia y desde ella. Las direcciones IP 
son un poco difíciles de recordar por los humanos, y por esta razón, 
a cada puesto se le asigna también un nombre. Cuando se instala Debian 
esta es una de las preguntas que se le hacen - Cuál es el nombre que se 
le dará a su puesto.</p>

<p>El nombre de tu ordenador será almacenado en pocas localizaciones. 
Puedes averiguar el nombre de tu ordenador tecleando el comando 
<prgn>hostname</prgn>, que devuelve el valor del archivo 
<prgn>/etc/hostname</prgn>.
Si estás conectado a Internet, este nombre tendrá normalmente varias 
partes, separadas por puntos, por ejemplo:
<example>
debian.anon.com
</example>
El nombre de tu ordenador es sólo la primera parte de éste- el resto 
es conocido como el <em>nombre de dominio</em> - que en este caso es
la parte <tt>anon.com</tt>. Seguramente habrá varios ordenadores con 
el mismo nombre en Internet, cada uno único en su propio dominio. 
Sin un dominio, normalmente una persona es responsable de dar los 
nombres a cada ordenador, y administrar la base de datos que maneja 
todos los nombre y direcciones de los ordenadores en el esedominio.
Este sistema es conocido como DNS, y es como una agenda telefónica 
- puedes buscar un ordenador por su nombre y averiguarás su dirección 
IP.</p>

<p>Antes de que existiera el DNS, la gente tenía que memorizar las 
direcciones IP para usar Internet, y los nombres sólo eran conocidos 
por un conjunto reducido de ordenadores - normalmente en una red local, 
y tal vez uno o dos ordenadores a los que estaban permanentemente 
conectados a nuestro puesto. Estos nombre se almacenaban en un sólo 
fichero - <prgn>/etc/hosts</prgn> - y en el que normalmente se encontraba 
el nombre y la dirección de nuestro propio ordenador que son añadidos el 
la instalación de Debian.</p>

<p>El DNS es un sitema moderadamente complejo, en el que entraremos con más 
detalles más tarde, a través del sotfware (<prgn>bind</prgn>) que permite 
manejar tu propio dominio DNS.</p>

<p>Ahora veremos como funciona el DNS desde el punto de vista del cliente 
- es decir desde el punto de vista de un puesto que sólo necesita localizar 
puestos, diferente del que los provee el servicio DNS.</p>

<p>Cuando un puesto con Debian necesita localizar el nombre de computador
a fin de encontrar su dirección IP, se usan una serie de rutinas de la 
librería de C llamadas <em>resolver</em>. Las rutinas resolver, consultan
en primer lugar el fichero <prgn>/etc/nsswitch.conf</prgn>, el cuál, en la 
entrada para <tt>hosts</tt> listará los lugares en los que el resolver 
comprobará en orden para averiguar la dirección IP. Aquí caben tres 
posibilidades, si hay presentes más de uno, el resolver comprobará cada 
uno de ellos en orden. Éstan son:
<taglist>
<tag>ficheros
<item>Comprueba el fichero <prgn>/etc/hosts</prgn> por cualquier entrada 
    con el nombre de puesto requerido
<tag>nis
<item>Comprueba la base de datos NIS (que explicaremos más tarde) buscando 
    el nombre de puesto requerido
<tag>dns
<item>Comprueba el Sericio de Nombre de Dominio
</taglist>
Un contenido típico en el fichero <prgn>/etc/nsswitch</prgn> puede ser:
<example>
hosts:         files dns
</example>
Esto nos dice que el resolver comprobará primero el fichero <prgn>/etc/hosts</prgn>
y luego consultará al DNS.</p>

<p>El DNS es configurado por el fichero <prgn>/etc/resolv.conf</prgn>. 
Éste fichero especifica normalmente dos cosas, cual es el dominio en que 
se encuentra nuestro ordenador, y segundo, una lista de servidores de 
nombre a los que preguntar información. Un ejemplo prodría ser:
<example>
domain anon.org
nameserver 172.19.0.1
nameserver 172.19.5.1
</example>
La primera línea le dice a la librería resolver si preguntamos por un 
puesto y no especificamos un nombre de dominio, éste debería ser 
<tt>anon.org</tt> añadido a él - es decir la librería resolver lo 
buscaría, asumiendo que el puesto está en tumismo dominio.
Las dos líneas siguientes que comienzan con <tt>nameserver</tt> 
especifican la dirección IP de los puestos que consultaría usando DNS.
Éstos deberían estar siempre con direcciones IP - sin nombres - por
razones obvias.</p>

<p>La mayor parte de las utilidades en red buscarán automáticamente 
la dirección IP del puesto si especificas un nombre, pero si quieres 
consultar directamente al DNS, el paquete <tt>dnsutils</tt> contiene 
un programa llamado <prgn>nslookup</prgn>.  
<prgn>nslookup</prgn> puede ser usado tanto, de una vez, dando el 
nombre del puesto que estás buscando, con la posibilidad de argumentos 
en línea de comandos, o interactivamente, siplemente tecleando 
<prgn>nslookup</prgn> . El modo interactivo permite hacer un número de 
búsquedas y tiene una ayuda limitada.</p>

<p><prgn>nslookup</prgn>, como otros programas de consulta de DNS y el 
software que provee los servicios de DNS, serán descritos en más 
detalle más adelante.</p>

<p>Para más información sobre DNS, por favor lee <ref id="bind">.

</sect>

<sect>Solucíon de problemas con ICMP y IP
</sect>

<sect>TCP y UDP
</sect>

<sect>Servidores, Demonios y el  Superservidor
</sect>


    </chapt>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:"network-administrator.sgml chapt sect"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->

