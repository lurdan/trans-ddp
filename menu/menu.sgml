<!doctype debiandoc system>

<!--
 Debian Menu System
 Copyright (C)1997 Joost Witteveen, Joey Hess, Christian Schwarz;
 released under the terms of the GNU
 General Public License, version 2 or (at your option) any later.
 -->

<book>

<title>Debian Menu System
<author>Joost Witteveen <email/joostje@debian.org/
<author>Joey Hess <email/joey@kite.ml.org/
<author>Christian Schwarz <email/schwarz@debian.org/
<version>version 1.3, <date>

<abstract>
The <tt/menu/ package was inspired by the <tt/install-fvwm2-menu/
program from the old <prgn/fvwm2/ package. However, tries to provide a
somewhat more general interface for menu building.  With the
<prgn/update-menus/ command from this package, no package needs to be
modified for every X window manager again, and it provides a unified
interface for both text- and X-oriented programs.
</abstract>

<copyright>Copyright &copy;1997 Joost Witteveen, Joey Hess, Christian Schwarz.
<p>

This manual is free software; you may redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.
<p>

This is distributed in the hope that it will be useful, but
<em>without any warranty</em>; without even the implied warranty of
merchantability or fitness for a particular purpose.  See the GNU
General Public License for more details.
<p>

A copy of the GNU General Public License is available as
<tt>/usr/doc/copyright/GPL</tt> in the Debian GNU/Linux distribution
or on the World Wide Web at
<tt>http://www.gnu.org/copyleft/gpl.html</tt>. You can also obtain it
by writing to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.
<p>

<toc sect>

<chapt>Introduction
<p>

Each package includes a file <tt>/usr/lib/menu/package-name</tt>. In
this file, it will have one line per menu-entry, like this (copied
from <tt>/usr/lib/menu/xbase</tt>):
<example>
   ?package(xbase):command="/usr/bin/X11/xedit" icon="none" needs="X11" \
                section="Apps/Editors" title="Xedit"
</example>
This describes the type of interface the package needs (X11),
the menu section the menu entry should be in, possibly
an icon, the menu text, and the command that should be exectued.
<p>

Whenever <tt/root/ runs <prgn/update-menus/, it will check all new or
changed menufiles in <tt>/etc/menu</tt> and <tt>/usr/lib/menu</tt>,
and run the installation scripts that display managers like <prgn/fvwm2/
should provide in <tt>/etc/menu-methods</tt>.
<p>

The menu package itself provides a set of default menu files,
for people to get the idea, and to speed up things a bit.
(These files should be incorporated into the package.)
<p>

Note, that substantial changes took place with the menu-1.0 release.
This document describes menu-1.0. Most notible changes to previous
revisions are listed in the file README.changes in the menu package.
To convert old menu entry files to the new format, you may use
<prgn>/usr/bin/convert-menuentry</> (though for users it certainly isn't
necessary to do so).
<p>

<chapt>What packages with applications should do
<p>

<sect>Registering your applications
<p>
A package of an application should provide a menu file
<tt>/usr/lib/menu/&lt;package-name&gt;</tt> that contains some
information about each program it likes to make available in the
menus.
<p>

Here is an example to describe the syntax of such a file:
<example>
  ?package(gnuplot):\            specifies what packages need to be installed
     needs=text\                 what kind of terminal this command expects
                                 needs=X11: if this program runs only on X11
  			         needs=text: if it only runs on text terminals
					   (the window manager should spawn 
					    an xterm or rxvt in this case)
			         needs=vc: runs only at linux console
			         needs=wm: this starts another windowmanager
     section=Apps/Math\	         in what section this menu entry should be
     title="Gnuplot"\            the title of the menu entry
                                 (please make it short!)
     command="/usr/bin/gnuplot"  the command to run.
</example>
<p>

A program like gnuplot which can be run on X11 as well as on a text
terminal should <em/not/ have an extra entry with <tt/needs=X11/
because it will then be next to impossible to configure the window
managers to spawn <prgn/rxvt/ instead of the default <prgn/xterm/.
<p>

On the other hand, if a program like <prgn/emacs/ can be run as real X
application as well as in a terminal two entries should be listed,
otherwise the program will always be run in an <prgn/xterm/.
<p>

You should add a line like this to your <tt/postinst/ and <tt/postrm/
script:
<example>
  if test -x /usr/bin/update-menus; then update-menus; fi
</example>
This updates the menus on the system.
<p>

Please, do not make your package <em/depend/ on the menu package!
<p>

<sect>Preferred menu structure
<p>

Here is the <em/authoritative list of Debian's menu structure/. If you
have a package which does not fit in here or if you have any
suggestions how to improve this structure, please send an email to
the maintainer of the <tt/menu/ package, Joost Witteveen
<email/joostje@debian.org/.
<p>

Please do <em/not/ put your packages into any other sections without
asking for permission first!
<p>

<example>
       Apps            -- normal apps
         Editors       -- editors (run it in xterm, if nothing else)
         Net           -- mail, news, web, irc, etc.
         Programming   -- debuggers, etc.
         Shells        -- bash, ksh, zsh, etc.
         Tools         -- other tools: xclock, xmag, xman, etc.
         Viewers       -- Picture viewers, gs, etc.
         Math          -- gnuplot, octave, oleo, etc.
         Graphics      -- xpaint, xfig, xtiff, etc.
         Emulators     -- dosemu, etc.
         Sound         -- TkMidity, etc.
         System        -- system administration and monitoring tools
       Games           -- games and recreations
         Adventure     -- walk around virtual space, zork, MOO's, etc
         Arcade        -- (any game where reflexes count)
         Board         -- Like: Gnuchess, pente, gnugo
         Card          -- solitare, etc
         Puzzles       -- Stuff from xpuzzles, ...
	 Sports        -- Games derived from "real world" sports
	 Strategy      -- Build your world (Games like lincity, freeciv)
         Tetris-like   -- games involving falling blocks
         Toys          -- (oneko, xeyes, etc.)
       Screen          --
         Lock          -- xlock, etc.
         Screen-saver  --
         Root-window   -- things that fill the root window
       Window-managers -- (change between fvwm, afterstep, etc)
         Modules       -- fvwm modules, etc. 
       XShells         -- shells (like xterm, rxvt, ...)
</example>
<p>

<sect>Icons
<p>

Please, make sure the icons you specify are always available on the system.
So, if you want to have an icon with your menu entry, the preferred method
is to supply the icon with that package. Also, to prevent the distribution
of icons files to turn too much into a mess, please put all icon
files in the directory <tt>/usr/X11R6/include/X11/{bitmap,pixmap}</>.
<p>

Debian package maintainers should ensure that any icons they include
for use in the debian menus conform to the following points:
<enumlist>
<item>The icons should be in xpm format.
<item>The icons may not be larger than 32x32 pixels, although smaller
sizes are ok.
<item>The icons should use only the 24 colors present in cmap.xpm,
which comes with the <tt/menu/ package.
<item>The background area of the icon should be transparent, if
possible.
</enumlist>

If you have Imagemagick installed, you can make your icons meet requirements
1, 2, and 3 with the following command, but you will need to edit the icon
afterwards to clean it up and make the background transparent:
<example>
  $ mogrify -format xpm -geometry 32x32 -map cmap.xpm &lt;filenames&gt;
</example>

If you, as a system admin, don't like the icons in the menus, simply
remove the <tt/$%{icon}/ from the files in
<tt>/etc/menu-methods/$wm</>, and run <prgn/update-menus/.
<p>

It's also possible to specify an icon for a submenu. However, if each
package would supply its own icons for the sub menus we can never be
sure that the icon files are available. Thus, only the <tt/menu/
package is allowed to specify icons for sub menus. The syntax for this
is:
<example>
  X11 Apps menu/apps /usr/X11R6/include/X11/pixmap/icon.xpm "Editors"
</example>

<sect>Fvwm's task and title bars
<p>

The problem with the stuff in the taskbar is that all items are
displayed all of the time. So, if 200 debian packages all were to
register a button, the buttons would quickly fill the screen, making
the exercise useless. The few applications that are considered
important enough to be listed in the taskbar usually vary widely on
each system, making it impossible to select a ``happy few'' apps that
are allowed there on every debian system. If you want your
<prgn/fvwm2/ to have a few buttons, you can install files for those
packages in <tt>/usr/lib/menu/$package</>, containing a menu entry
like this:
<example>
  ?Package(xmball):needs=button\
                section=Games/Puzzles\
                icon=path-to-pixmap.xpm\
                title="Xmball"\
                command=/usr/games/xmball
</example>
Then, do the following:
<example>
  cd /etc/menu-methods/
  cp fvwm2 fvwm2button
  vi fvwm2button
</example>
and remove all the "supported" entries, adding the one below. For the rest,
leave everything the same except those listed below.
<example>
  supported 
    button="+ Style \"" $title "\" TitleIcon" $icon " Exec "  $command "\n"
  endsupported
  startmenu:   "AddToTitlebar \n"
  endmenu:     "\n"
  submenutitle:""
  mainmenu:
  genmenu:   "buttondefs.hook"
</example>

<chapt>What packages with menu managers should do
<p>

Each package containing a <em/menu manager/ (i.e. a program that can
display a menu) should provide a script or program in
<tt>/etc/menu-methods/</> that can read the menu files. This script
will be executed by <prgn/update-menus/, which will feed the menu
entries to be installed to your script via standard input (stdin).
<p>

The scripts in <tt>/etc/menu-methods/</> should be configuration
files, so the user can tune the behaviour of the script.
<p>

Good examples for these scripts of nearly all debian window managers
are included in the <tt/menu/ package in
<tt>/usr/doc/menu/examples</>. 
<p>

Run <prgn/update-menus/ (if it exists) in your <tt/postinst/ script,
and remove the execute bit from the <tt>/etc/menu-methods/</> script
in the <tt/postrm/ when called with option ``remove.''
<p>

Here is an example of such a <tt/postinst/ script using <prgn/bash/:
<example>
  #!/bin/sh
  set -e
  inst=/etc/menu-methods/twm  #or fvwm, ... whatever manager you're installing
  case "$1" in
     remove)
         chmod a-x $inst
     ;;
     purge)
         #remove the files that install-fvwmgenmenu creates:
         rm /etc/X11/twm/{system.twmrc,menus.dat,menudefs.hook}
         #maybe also rm $inst, if dpkg doesn't do that itself.
     ;;
     upgrade);;
     *)
         echo "postrm called with unknown argument \`$1'" >&2
         exit 0
     ;;
  esac
</example>

And here is a good example for a <tt/postrm/ script:
<example>
  #!/bin/sh
  set -e
  inst=/etc/menu-methods/pdmenu #or fvwm, ... whatever manager you're installing
  if [ -x /usr/bin/update-menus ] ; then 
    if [ -f $inst ]; then
       chmod a+x $inst
       update-menus; 
    fi  
  fi
</example>

<chapt>How a user can override the menus
<p>

<sect>Configuring the menus
<p>

A user can specify his/her own menu entries in the <tt>~/.menu</> directory.
The files can have an arbitrary file name as long as the new syntax
for the menu entries is used. They should start with either
<example>
  ?package(installed-package):
</example>
or
<example>
  ?package(local.mystuff):
</example>
if it's something that isn't ``debian-officially'' installed. (Any
``package'' that starts with ``<tt/local./'' is considered installed.)
<p>

If you are using the old format, the menu entry files should have
names of installed packages or have to be called
``<tt/local.name/''. (Note, that due to a bug in <tt/menu-1.3/ this
did not work then.)
<p>

Files including entries with the old syntax either have to use names
of installed packages or have to be named <tt/local.name/, since
<prgn/update-menus/ assumes any "package" who's name starts
with "local" is installed.
<p>

If a user wants to have his/her own menu methods, he/she should create
a <tt>~/.menu-methods</> directory and put all scripts he/she wants to
be run in it. (If <tt>~/.menu-methods</> exists,
<tt>/etc/menu-methods</> will not be searched when a user runs
<prgn/update-menus/).
<p>

A system admin should place system-wide menu entries in <tt>/etc/menu</>
(not in <tt>/usr/lib/menu/package</>, since these files will probably
be overwritten by a package upgrade).
<p>

<sect>Specifying a ``no-menu entry''
<p>

If a user wants to remove an entry from the system menu (in
<tt>/etc/menu</>), then this will do the trick:
<example>
  echo -n  > ~/.menu/package
</example>
The zero-size file will tell <prgn/update-menus/ that the
corresponding package should not have any menu entries listed.
<p>

<chapt>The internals of the menu package
<p>

<sect>The update-menus program
<p>

On startup, update-menus checks the file
<tt>/var/run/update-menus.pid</> and the pid in it. If there's an
<prgn/update-menus/ process with that pid it kills it.
If <tt>/var/lib/dpkg/lock</> exists, it forks to background and
returns control to dpkg. The background process checks the
<tt>/var/lib/dpkg/lock</> file approx. every second until the file's
gone. 
<p>

After that, the following steps are performed:
<enumlist>
<item> sets a variable <tt/$dirs/ to 
<example>
  dirs="/etc/menu /usr/lib/menu /usr/lib/menu/default"
</example>
(and if a user runs prgn/update-menus/, it will add ~/.menu to the
front of that list)
<item> it reads the list of installed packages
<item>
<example>
  for d in $dirs; do
     - read files in $d
     - check if corresponding package is installed, and, is listed
       in the $d/.updated-menus file, checking the mod time in 
       $d/.updated-menus.
       Depending on that information, either put the menufile $file in the
       the install-menu-list, or the menuentry in the $remove-entries,
       and do put the entries in the  already-correctly-installed-list
</example>
<item> after going through all dirs, do
<example>
  for method in `ls /etc/menu-methods`; do
	$cat install-menu-list | method -f --stdin 
  done
</example>
</enumlist>

Ad step 3+4: The <tt>$d/.updated-menus</> file lists not only the
files in that directory and it's modification time (to check for
changes), it also lists the known menu-managers (i.e., the output of
`ls /etc/menu-methods`) at the time of the last installation. Based on
this information, steps 3+4 are changed a bit, to update/remove
new/old menu-managers.
<p>

Ad step 1+2+3+4: Although I've used a sh-like syntax here, it's
written in C++.
<p>

Ad step 4: There's a hack here for backwards compatibilty with the old
<prgn/install-fvwmgenmenu/: if the script in <tt>/etc/menu-methods</>
doesn't start with <tt>"#!/usr/sbin/install-menu"</>, the old
data format will be sent to the script.
<p>

<sect>The install-menu program
<p>

The files <tt>/etc/menu-methods/fvwm*</> are ``executable'' config
files that start with the line
<example>
  #!/usr/sbin/install-menu
</example>
and thus start that program, handing it the configuration file for the
specific window manager in the first command line argument. This
configuration consists of:
<enumlist>
<item>the compatibility mode ("menu-1").
<item>where the various files should be stored/read.
<item>what "needs" are supported, and what wrapper files should
   be used for each "type".
</enumlist>
See <tt>/usr/doc/menu/examples/</> of the menu package for more
comments.
<p>

Options to <prgn/install-fvwmgenmenu/:
<example>
  -v              be verbose
  -d              Produce loads of debugging output
</example>

The <tt/-f/ and <tt/--stdin/ "options" exist because old versions used to
have cache files and other complicated stuff. This didn't result
in any speedups, and did complicate stuff. So we (Joey and Joost) decided
to make <tt/-f/ and <tt/--stdin/ options that are always on (and can thus be
ignored).
<p>

Some window managers don't support the <prgn/m4/ or <prgn/cpp/
preprocessing, and cannot read the <tt/menudefs.hook/ file from their
<tt/system.*rc/ config file. To still be able to use them,
<prgn/install-fvwmgenmenu/ will copy the file
<tt/$path/$examplercfile/ to <tt/$path/$rcfile/ (with <tt/$path/,
<tt/$examplercfile/ and <tt/$rcfile/ defined in the
<prgn/install-fvwmgenmenu/ config file), and replace all occurences of
``install-menu-defs'' with the <tt/$genmenu/ file it just
generated. Although this approach looks quite clumsy, it does allow
for one <tt>$path/$examplercfile</> on the system.  (The
<prgn/m4//<prgn/cpp/ approach puts a
<tt>"include(/etc/X11/*/menudefs.hook)"</> in the <tt/system.*rc/
file, so users will never load their <tt/menudefs.hook/ file).
<p>

To activate the file copying in this way, simply define the
<tt/$examplercfile/ and <tt/$rcfile/ variables in the
<prgn/install-fvwmgenmenu/ configuration file
(<tt>/etc/menu-methods/fvwm*</>), and make sure there is a
<tt>$path/$examplercfile</> (<tt>$path</> being either
<tt/$rootprefix/, or <tt/$userprefix/.)
<p>

If you are wringing a menu method, you can use the following to
debug it somewhat easier:
<enumlist>
<item>use the "cat" menu-method in <tt>/usr/doc/menu/examples/cat</>
to create a list of menuentries in <tt>/tmp/menu-stdin</> (put it in
<tt>~/.menu-methods</>, and run <prgn/update-menus/), and then
<item>you can run just your menu-method with (if it's called wm):
<example>
  ./wm -v < /tmp/menu-stdin
</example>
(Use <tt/-v/ for verbose, <tt/-d/ for debugging, and you'll get loads
of output!)
</enumlist>
<p>

<sect>The install-menu config script definitions
<p>

The menu-methods in <tt>/etc/menu-methods/*</> are basically made up of
a lot of ``section=string'' definitions, explaining <prgn/install-menu/
how to generate a <tt/system.$wmrc/ script. This way you can tune
the look of generated <tt/system.$wmrc/ to your needs.
<p>

In the following, something like 
<example>
  treewalk="c(m)"
</example>
means that the treewalk variable by default has the value "c(m)".
<p>

For examples of what these scripts can look like, see
<tt>/usr/doc/menu/examples/*</>.
<p>

<taglist>
<tag><tt/compat="menu-1"/
<item>
Should always be "menu-1". Please, make this the first non-comment
line in the script.

<tag><tt/supported/
<tag><tt/unsupported/
<item>
Between the <tt/supported/ and <tt/endsupported/ keywords you define
what "needs" are supported by this window manager. So, the following
is an example for a wm that supports both needs=x11 and needs=text:
<example>
  supported
    x11=" ShowEntry("title=\"" $title "\", command=\"" $command "\"")
    text=" ShowEntry("title=\"" $title "\", command=\""\
             "xterm -T " $title " -e " $command "\"")
  endsupported
</example>

For the variable substitution (and functions, not shown above), see
the next paragraph. In the above example, you'll notice that for the
menuentries that "need=text", an xterm is spawned for the command to
run in.  Also, as x11 is higher up in the supported list than text, a
package that supplies both a "needs=x11" and a "needs=text" entry will
have the needs=x11 entry installed, in favour of the needs=text entry.
You can continue lines on the next line with a \, but do make sure you
don't add any spaces after the \.

<tag><tt/startmenu=""/
<tag><tt/endmenu=""/
<tag><tt/submenutitle=""/
<item>
These define what to print for the beginning/end of a menu, and
how to the print a menuentry that pops up another menuentry.
They are subsituted the same way as the "supported" stuff is.
(see next paragraph).

<tag><tt/treewalk="c(m)"/
<item>
This string defines in what order to dump the <tt/$startmenu/, <tt/$endmenu/,
and <tt/$submenutitle/ (and its children). Each char in the string
refers to:
<example>
    c  : dump children of menu.
    m  : dump this menu's $submenutitles
    (  : dump $startmenu
    )  : dump $endmenu
    M  : dump all $sumbmenutitles of this menu and this menu's children.
</example>

The default is "c(m)". For olvwm, one needs: "(M)"

<tag><tt/genmenu=""/
<item>
The menufile to generate (usually something like <tt>system."$wm"rc</>).
The file itself may depend on the level or title that is currently
being work on, like 
<example>
    genmenu="/subdir/" replacewith($section," ","_") "/rc.menu"
</example>
(Substitution works just like the supported stuff, see above).
Note that the files made this way are truncated upon
opening, so if you have a genmenu like the example above, then
your <tt/endmenu=/ will override the startmenu stuff (but you probably
only need one of the two anyway).

<tag><tt>rootsection="/Debian"</>
<item>
the prefix, every <tt/$section/ variable gets.

<tag><tt/prerun=""/
<tag><tt/postrun=""/
<item>
The commands to run before resp. after the actual generation of the
<tt/menudefs.hook/ (genmenu) file. Commands will be executed by <prgn/sh/.
Example: 
<example>
  prerun="rm -rf " prefix() "/*"
  postrun="killall -USR1 fvwm2"
</example>
(Substitution works just like the supported stuff, see above).

<tag><tt>preoutput="#Automatically generated file. Do not edit (see /usr/doc/menu/README)\n\n"</tt>
<tag><tt>postoutput=""</tt>
<item>
Text to put at the beginning resp. end of the generated file ($genmenu).

<tag><tt/command=""/
<item>
A command to run instead of <prgn/install-menus/. This command will
receive the menu entries <prgn/install-menus/ would have received on
stdin. This option is necessary, as there is otherwise (apart from
replacing <tt>/usr/sbin/install-menus</> with a sh script) no way to
write the "new-format" stdin to a file, for debugging or other purposes.
(Just replacing the first line in the <tt>/etc/menu-methods</> script with
<tt>#!/bin/bash</> will not work, as the script will get old-format
input then.)
<p>

Example:
<example>
  command="cat > /tmp/menu-stdin"
</example>

<tag><tt/hotkeyexclude=""/
<item>
Keys not to use for hotkey generation. You can use the same 
variables and functions here as in for example the startmenu
sections.
<p>

Example:
<example>
  hotkeyexclude="q" $section
</example>

<tag><tt/hotkeycase="insensitive"/
<item>
can be either "insensitive" or "sensitive". Determines
whether the hotkeys can be of mixed case (fvwm2 reads
the hotkeys case-insensitive, pdmenu case-sensitive).
In case of the titles "Xa" and "xb", hotkey will generate
"X" and "b", whereas sensitive would generate "X" and "x".

<tag><tt/rcfile=""/
<item>
If the window manager doesn't support an "include filename" or
"read(filename)" statement in it's config file, you can rename
the wm's config file to <tt/system."$wm"rc-menu/, and insert
a "install-menu-defs" line (without the quotes, or whitespace around
it, and "install-menu-defs" must be the only thing on the line)
in the <tt/system."$wm"rc-menu/ file. This will then get replaced
by the <tt/$genmenu/ file that <tt/wasrcfile=""/ just created (see
also <tt/$examplercfile/).
  
<tag><tt/examplercfile=""/
<item>
if needed (see rcfile), this is the <tt/system.rc"$wm"-menu/ file.
In that case, make <tt/rcfile=system.rc"$wm"/.

<tag><tt/rootprefix=""/
<item>
The prefix to use when running as root (applies to $genmenu, $rcfile,
$examplercfile  and other old cache files)

<tag><tt/userprefix=""/
<item>
see <tt/rootprefix/, but when running as user.

</taglist>


<sect>Variables and functions in the install-menu scripts
<p>

The supported "needs" definitions and "startmenu=", "endmenu="
and "submenutitle=" are interpreted as follows:

<example>
String constants:
  Anything matching with \"[^\"]*\" is interpreted as a string, and
  is written verbatim to the output file.
  Stuff like \n, \t, ... will be substituted for their C expansions 
  (But not \0xx).

Variables:
  Anything matching $[a-z,A-Z,_]* is interpreted as a variable, and
  the corresponding definition from the menuentry is substituted. So,
  for a menuentry.
  
  Special variables:
    The following variables are treated in a special way by install-menus,
    either because they are used for other purposes too, or because they
    are modified by install-menus (the ones with a "!" are modified
    by install-menus).
    
    needs:   used to determine whether the window manager supports this
             menuentry.
    command: If this is undefined, this menuentry is taken as defining
             a submenu. (this way you can specify icons of submenus).
    title!:  Used for sorting (see section).
             For submenuentries (those with empty command), this
	     is initialised to the last part of the section.
	     Please, keep the title short (two words at maximum).
	     The title is for people who already know what programme
	     they want to start. See "longtitle" and "description" below
	     for longer descriptions.
    sort:    used for sorting (see section).
    section!:Used to determine the section of the menuentry.
             The menuentries that have a empty $command, have their
	     $section changed to modify the current level.	     
             The menuentries that have a non-empty $command have their
	     $section modified to $section/$title, or $section/$sort:$title
	     if $sort is defined. The menuentries within one section
	     are sorted according to $section.
    hotkey!: Modified to reflect what install-menus thinks is the
             most suitable hotkey for this menuentry. The hotkey=
	     in the menuentry file is taken as a suggestion, that could
	     be overwritten if there is another entry with the same hotkey=.
	     To suggest two possible hotkeys for an entry use
	     hotkey="ab", with "a" being the most prefered hotkey.

  Suggested variables:
    The following aren't special for install-menus, but it's nice 
    (read: essential) to use the same variables for the same things.
    So, I'll suggest some here. If you want to invent new ones, please
    do so and mail them to me so that I can include them here.

    icon:    The location of the iconfile for this menuentry.
             If you don't have an iconfile, just leave out the icon=
	     in the menuentry.
    longtitle: For people that like descriptive titles (about one line)
             It is probably best to include this in your menuentries,
	     while the window-managers don't (by default) put it in the
	     menus. That way, people who want descriptive titles can
	     turn them on, but others don't need to use them.
    description:An even longer description (about 5 lines).
             For example, a description of the documentation in
	     the dwww generated html pages.
   

Functions:
  Anything matching [a-z,A-Z,_] is taken as a function (and an error
  is generated if the function doesn't exist). The arguments of the
  functions can be other functions, string contsants or variables.
  
  prefix()
     returns the current prefix dir: either $rootprefix, or
     $HOME/$userprefix, depending on who runs install-menu

  ifroot($rootarg, $userarg)
     if(getuid()==0) print $rootarg, else print $userarg

  print($arg)    
     Same as just $arg; if $arg is empty, generate an error.

  esc($arg1,$arg2)
     Print $arg1, but escape all occurences of characters in $arg2
     with a \. (thus, if arg1="hello", arg2="lo", print "he\l\l\o").

  escwith($arg1, $arg2, $arg3)
     Same as esc, but use $arg3 as escape sequence.

  escfirst($arg1, $arg2, $arg3)
     Same as escwith, but only escapes thirst occurence of $arg2.

  tolower($arg)
  toupper($arg)
     Returns the argument set in lowercases resp uppercases. 

  replacewith($s, $replace, $with)
     Search s for occurences of characters from string replace, and
     replace them by the corresponding character in $with.
     Example:
      replacewith_string("hello $world, %dir", "$% ", "123")
      returns:   "hello31world,32dir"

  ifempty($arg1, $arg2)
     If $arg1 is empty, print $arg2, otherwise print nothing.
     For compatibility, the string "none" is seen as empty.

  ifnempty($arg1, $arg2)     
     If $arg1 is not empty, print $arg2.
     For compatibility, the string "none" is seen as empty.

  ifelse($arg1,$arg2)
     If $arg1 is non-empty, print $arg1, otherwise $arg2.
     For compatibility, the string "none" is seen as empty.

  ifeq($arg1, $arg2, $arg3)
     If ($arg1==$arg2) then print $arg3
  ifneq($arg1, $arg2, $arg3)
     If ($arg1!=$arg2) then print $arg3
  ifeqelse($arg1, $arg2, $arg3, $arg4)
     If ($arg1==$arg2) then print $arg3 else print $arg4

  cond_surr($arg1, $arg2, $arg3)
     If $arg1 is non-empty print $arg2$arg1$arg3, otherwise print nothing.
     For compatibilty, $arg1="none" is interpreted as empty.

  iffile($arg1, $arg2)
     If file $arg1 exists, and can be opened for reading by whoever
     started the current process, return $arg2, otherwise return nothing.
  
  parent($arg)
     for arg a "directory", return parent directory:
     parent("/Debian/Apps/Editors") = "/Debian/Apps".

  basename($arg)
     return the last part of the parent direcotry:
     basename("/Debian/Apps/Editors") = "Apps".

String constants, variables and functions can be concatenated 
by placing them after each other with a space inbetween, like

"hello" $ifelse($comma, $comma, "sorry" $period " no comma def") " world"
</example>
  
</book>
