<!-- CVS revision of this document "$Revision: 1.12 $"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->
<!-- DON't TOUCH GROFF SECTION!!! -->


<chapt id="program">Programming


<p>
Do not use "test" as the name of an executable test file. <prgn>test</prgn> is
a shell builtin.
<sect>Where to start
<p>
<em>Linux Programming Bible</em> (John Goerzen/IDG books)
<p>
Documents and examples under <file>/usr/share/doc/&lt;packages&gt;</file>
<p>
Many long info documents can be obtained as paperbacks from 
<url id="&gnuhome;" name="GNU">.
<p>
The next four sections contain sample scripts in different languages for
creating a text file of account information to be added to
<file>/etc/passwd</file> using a batch processor such as the
<prgn>newusers</prgn> program. Each script requires as input a file with lines
of the form <tt>firstname lastname password</tt>.  (Actual user home
directories will not be created via these scripts.)
</sect>

<sect>Bash
<p>
<em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
<example>
$ info bash
$ mc   /usr/share/doc/bash/examples/ /usr/share/doc/bash/
</example>
(Install the <package>bash-doc</package> package to see the example files.)
<p>
Short program example (create account entries for <prgn>newusers</prgn> from
standard input):
<example>
#!/bin/bash
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>
<p>
Few packages provide POSIX shell in &debian;:
<list compact>
 <item><package>ash</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 180
  <item>Smaller and much faster &mdash; good for initial boot:
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essential: yes
  <item>Priority: required
  <item>Installed-Size: 580
  <item>Larger and featureful &mdash; many extensions implimented:
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 408
  <item>Complete AT&amp;T ksh look-alike
 </list>
</list>
</sect>

<sect>Awk
<p>
<em>Effective awk Programming</em>, 3rd edition, and <em>sed &amp; awk</em>,
2nd edition (O'Reilly)
<example>
$ man awk
$ info awk
</example>
Short program example (create <prgn>newusers</prgn> command entry):
<example>
#!/usr/bin/awk -f
# Script to create a file suitable for use in the 'newusers' command,
# from a file consisting of user IDs and passwords in the form:
# First Last password
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
	startuid = ARGV[1]
	delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
	  "...where startUID is the starting userid " \
	  "to add, and file is \n" \
	  "an input file in form firstname last name password\n" \
	)
	exit
    }

    infile = ARGV[1]
    printf( "Starting UID: %s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n",  \
	user, passwd, uid, gid, first, last, user \
	)
}
</example>
<p>
2 packages provide POSIX <package>awk</package> in &debian;:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priority: required
  <item>Installed-Size: 228
  <item>Smaller and much faster &mdash; good for default install:
  <item>Compile-time limits exist
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020.
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 1708
  <item>Larger and featureful &mdash; many extensions implimented:
  <list compact>
   <item>System V Release 4 version of UNIX
   <item>Bell Labs awk
   <item>GNU-specific
  </list>
 </list>
</list>
</sect>

<sect>Perl
<p>
<em>Programming Perl</em>, 3rd edition (O'Reilly)
<example>
$ man perl
</example>
Short program example (create <prgn>newusers</prgn> command entry):
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
	if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Install Perl module <var>module name</var>:
<example>
# perl -MCPAN -e 'install <var>modulename</var>'
</example>
 
</sect>

<sect>Python
<p>
<em>Learning Python</em> (O'Reilly).
It's a nice interpreter.
<example>
$ man python
</example>
Short program example (create <prgn>newusers</prgn> command entry):
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input file name. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirstname lastname password\n"
		return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crash with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n" %  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: %d\n" % uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: %s\n\n" % infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>Make
<p>
<em>Managing Projects with make</em>, 2nd edition (O'Reilly)
<example>
$ info make
</example>
Simple automatic variables:
<p>
Rule syntax:
<example>
Target: [ Prerequisite ... ]
&nbsp; [TAB] &nbsp; command1
&nbsp; [TAB] &nbsp; -command2 # ignore errors
&nbsp; [TAB] &nbsp; @command3 # suppress echoing
</example>
Each line is interpreted by the shell after make variable substitution. 
Use <tt>\</tt> at the end of line to continue script.
Use <tt>$$</tt> to enter <tt>$</tt> for environment values for a shell script.
<p>
Implicit rule equivalents:
<example>
.c:   header.h == %  : %.c header.h
.o.c: header.h == %.c: %.o header.h
</example>
Automatic variables for above rules:
<example>
foo.o: new1.c new2.c.c old1.c new3.c
$@ == foo.o                         (target)
$< == new1.c                        (first one)
$? == new1.c new2.c new3.c          (newer ones)
$^ == new1.c new2.c.c old1.c new3.c (all)
$* == `%' matched stem in the target pattern.
</example>
Variable references:
<example>
foo1 := bar    # One-time expansion
foo2  = bar    # Recursive expansion
foo3 += bar    # Append
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:%.c=%.o) 
OBJS := $(patsubst %.c,%.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extracts "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Run <tt>make -p -f/dev/null</tt> to see automatic internal rules. 
</sect>

<sect>C
<p>
Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 2nd edition
(Prentice Hall).
For the GNU C library function reference:
<example>
# apt-get install glibc6-doc manpages-dev
</example>
For the C library function reference, use "<prgn>info libc</prgn>".
Each C function is documented in section 3 of the system manual, e.g. <tt>man 3
printf</tt>.

<sect1>Simple C program (<prgn>gcc</prgn>)
<p>
A simple example to compile <prgn>example.c</prgn> with a library
<prgn>libm</prgn> into an executable <prgn>run_example</prgn>:
<example>
$ cat &gt; example.c 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
	double x;
	char y[11];
	x=sqrt(argc+7.5);
	strncpy(y, argv[0], 10); /* prevent buffer overflow */
	y[10] = '\0'; /* fill to make sure string ends with '\0' */
	printf("%5i, %5.3f, %10s, %10s\n", argc, x, y, argv[1]);
	return 0;
}

$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
    1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
    2, 3.082, ./run_exam, 1234567890qwerty
</example>
Here, <tt>-l<strong>m</strong></tt> is needed to link library
<tt>lib<strong>m</strong></tt> for sqrt().  The actual library is in
<file>/lib</file> with filename <file>libm.so.6</file>, which is a softlink to
<file>libm-2.1.3.so</file>.
<p>
Look at the last parameter in the output text.  There are more than 10
characters even though <tt>%10s</tt> is specified.  
<p>
The use of pointer memory operation functions without boundary checks, such as
<prgn>sprintf</prgn> and <prgn>strcpy</prgn>, is deprecated to prevent buffer
overflow exploits that leverage the above overrun effects.  Instead, use
<prgn>snprintf</prgn> and <prgn>strncpy</prgn>.
</sect1>

<sect1>Debugging

<sect2>Debugging with (<prgn>gdb</prgn>)
<p>
Use <prgn>gdb</prgn> to debug a program compiled with the <tt>-g</tt> option.  
Many commands can be abbreviated.  Tab expansion works as in the shell.
<example>
$ info gdb               # tutorial
...
$ gdb program
(gdb) b 1                # set breakpoint at line 1
(gdb) run arg1 arg2 arg3 # run program
(gdb) next               # next line
...
(gdb) step               # step forward
...
(gdb) p parm             # print parm 
...
(gdb) p parm=12          # set value to 12
</example>
<p>
The following commands will also be useful:
<list compact>
<item><prgn>ldd</prgn>:    print shared library dependencies
<item><prgn>strace</prgn>: trace system calls and signals
<item><prgn>ltrace</prgn>: trace library calls
</list>
<p>
For debugging from within Emacs, refer to <ref id="editkey">.
</sect2>

<sect2>Debugging with Memory leak detection tools
<p>
There are several memory leak detection tools available in &debian;.
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package>
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> from 
  <url id="&parasofthome;" name="Parasoft">. (non-free, commercial for fee)
</list>
Also check out <url id="&mallocdebughome;" 
  name="Debugging Tools for Dynamic Storage Allocation and Memory Management">.

<sect1>Flex &ndash; a better Lex
<p>
<prgn>flex</prgn> is fast lexical analyzer generator.
<p>
You need to provide your own <prgn>main()</prgn> and <prgn>yywrap()</prgn>, or
your <prgn>program.l</prgn> should look like this to compile without a library
(<prgn>yywrap</prgn> is a macro; <tt>%option main</tt> turns on <tt>%option
noyywrap</tt> implicitly):
<example>
%option main
%%
.|\n	ECHO ;
%%
</example>
Alternatively, you may compile with the -<tt>lfl</tt> linker option at the 
end of your <prgn>cc</prgn> command line (like ATT-Lex with <tt>-ll</tt>). No
<tt>%option</tt> is needed in this case.
</sect1>

<sect1>Bison &ndash; a better Yacc
<p>
Few packages provide Yacc compatible LALR parser generator in &debian;:
<list compact>
 <item><package>bison</package>: GNU LALR parser generator
 <item><package>byacc</package>: The Berkeley LALR parser generator
 <item><package>byyacc</package>: Backtracking parser generator based on byacc
</list>
<p>
You need to provide your own <prgn>main()</prgn> and <prgn>yyerror()</prgn>.
<prgn>main()</prgn> calls <prgn>yyparse()</prgn> which calls
<prgn>yylex()</prgn>, usually created with FleX.
<example>
%%

%%
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> is a tool for producing shell scripts that 
automatically configure software source code packages to adapt to 
many kinds of UNIX-like systems using the entire GNU build system.  
<p>
<prgn>autoconf</prgn> produces configuration script 
<prgn>configure</prgn>.  <prgn>configure</prgn> 
automatically creates customized <prgn>Makefile</prgn> and
<prgn>Makefile.am</prgn>.
 
<sect2>Compile and install program
<p>
&debian; does not toutch files in /usr/local.  So if you compile a program 
from the source, install them into /usr/local so it will not interfaire 
with &debian;.
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # this puts the files in the system
</example>

<sect2>Uninstall program
<p>
If you still have the source and If it uses autoconf/automake and If you
can remember how you configured it:
<example>
$ ./configure all-of-the-options-you-gave-it
# make uninstall
</example>
<p>
Alternatively, if you are absolutely sure there are nothing important 
in /usr/local, you can erase them all by:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>

</sect1>

</sect>

<sect>Document preperation
<p>

<sect1><tt>roff</tt> type-setting
<p>
Traditionally, <tt>roff</tt> is the main text processing system of Unix.
<p>
See <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7">, and
"<tt>info groff</tt>".

<sect1>SGML
<p>
SGML enables management of multiple formats of a document. One easy SGML
system is Debiandoc, which is used here.  This requires minor conversion from
original text files for the following characters:
<example>
&lt;   &amp;lt;
&gt;   &amp;gt;
&amp;   &amp;amp;
&copy;   &amp;copy;
&ndash;   &amp;ndash;
&mdash;   &amp;mdash;
</example>
To mark a section as a non-printable comment, enter:
<example>
&lt;!-- State issue here ... --&gt;
</example>
To mark a section with a switchable comment, enter:
<example>
&lt;![ %FIXME [ State issue here ... ]]&gt;
</example>
In SGML, the <em>first definition</em> of an entity wins.  For example:
<example>
&lt;!entity % qref "INCLUDE"&gt;
&lt;![ %qref [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
This ends up as "Data 1".  If the first line has "IGNORE" instead of
"INCLUDE", this ends up as "Data 2" (the second line is a conditional
statement).
<p>
For more details, do <tt>apt-get install debiandoc-sgml-doc</tt>.  
Also, read
<em>DocBook: The Definitive Guide</em>, by Walsh and Muellner (O'Reilly)
</sect>

<sect id="packaging">Packaging
<p>
Read documentation supplied in the package <package>packaging-manual</package>
(Potato) or <package>debian-policy</package> (Woody).
<p>
Use <prgn>dh_make</prgn> from the <package>dh-make</package> package to create
a baseline package.  Then, proceed according to instructions in <manref
name="dh-make" section="1">.
This uses <prgn>debhelper</prgn> in <prgn>debian/rules</prgn>.
<p>
An older approach is to use <prgn>deb-make</prgn> from the
<package>debmake</package> package.  This uses no <prgn>debhelper</prgn>
scripts and depends only on the shell.
<p>
For examples of multiple-source packages, see "mc" (<tt>dpkg-source -x
mc_4.5.54.dsc</tt>), which uses "sys-build.mk" by Adam Heath
(<email>doogie@debian.org</email>), and "glibc" (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>), which uses another system by Joel Klecker
(<email>espy@debian.org</email>).
</sect>

</chapt>
