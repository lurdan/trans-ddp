<!-- CVS revision of this document "$Revision: 1.2 $"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="program">Programming

<![%FIXME[<p>===Proof reading by dsew: DONE ===]]>

<p>
Do not use "test" as the name of an executable test file. "test" is a 
shell builtin.
<sect>Where to start
<p>
<em>Linux Programming Bible</em> (John Goerzen/IDG books)
<p>
Documents and examples under /usr/share/doc/&lt;packages&gt;
<p>
Many long info documents can be obtained as paperbacks from 
<url id="http://www.gnu.org/" name="GNU">.
<p>
The next four sections contain sample scripts in different languages for
creating a text file of account information to be added to /etc/passwd using a
batch processor such as the "newusers" program. Each script requires as input a
file with lines of the form <tt>firstname lastname password</tt>.  (Actual
user home directories will not be created via these scripts.)
</sect>

<sect>BASH
<p>
<em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
<example>
$ info bash
$ mc   /usr/share/doc/bash/examples/ /usr/share/doc/bash/
</example>
(Install the bash-doc package to see the example files.)
<p>
Short program example (create account entries for "newusers" from standard
input):
<example>
#!/bin/bash
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>
</sect>

<sect>AWK
<p>
<em>Effective awk Programming</em>, 3rd edition, and <em>sed &amp; awk</em>,
2nd edition (O'Reilly)
<example>
$ man awk
$ info awk
</example>
Short program example (create newusers command entry):
<example>
#!/usr/bin/awk -f
# Script to create a file suitable for use in the 'newusers' command,
# from a file consisting of user IDs and passwords in the form:
# First Last password
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
	startuid = ARGV[1]
	delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
	  "...where startUID is the starting userid to add, and file is \n" \
	  "an input file in form firstname last name password\n" \
	)
	exit
    }

    infile = ARGV[1]
    printf( "Starting UID: %s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n",  \
	user, passwd, uid, gid, first, last, user \
	)
}
</example>
</sect>

<sect>PERL
<p>
<em>Programming Perl</em>, 3rd edition (O'Reilly)
<example>
$ man perl
</example>
Short program example (create newusers command entry):
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
	if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Install Perl module &lt;module name&gt;:
<example>
# perl -MCPAN -e 'install &lt;module name&gt;'
</example>
 
</sect>

<sect>PYTHON
<p>
<em>Learning Python</em> (O'Reilly).
It's a nice interpreter.
<example>
$ man python
</example>
Short program example (create newusers command entry):
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
		print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input file name. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirstname lastname password\n"
		return 1

def parsefile(startuid):
	#
	# main filtering
	#
	uid = startuid
	while 1:
		line = infile.readline()
		if not line:
			break
		if line[0] == '#':
			continue
		(first, last, passwd) = string.split(string.lower(line))
		# above crash with wrong # of parameters :-)
		user = first[0] + last
		gid = uid
		lineout = "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n" %  \
			(user, passwd, uid, gid, first, last, user)
		sys.stdout.write(lineout)
		++uid

if __name__ == '__main__':
	if len(sys.argv) == 1:
		usages()
	else:
		uid = int(sys.argv[1])
		#print "# UID start from: %d\n" % uid
		if len(sys.argv) &gt; 1:
			infilename   = string.join(sys.argv[2:])
			infile = open(infilename, 'r')
			#print "# Read file from: %s\n\n" % infilename
		else:
			infile = sys.stdin
		parsefile(uid)
</example>
</sect>

<sect>MAKE
<p>
<em>Managing Projects with make</em>, 2nd edition (O'Reilly)
<example>
$ info make
</example>
Simple automatic variables:
<p>
Rule syntax:
<example>
Target: [ Prerequisite ... ]
&lt; TAB &gt; command1
&lt; TAB &gt; -command2 # ignore errors
&lt; TAB &gt; @command3 # suppress echoing
</example>
Each line is interpreted by the shell after make variable substitution. 
Use "\" at the end of line to continue script.
Use "$$" to enter "$" for environment values for a shell script.
<p>
Implicit rule equivalents:
<example>
.c:   header.h == %  : %.c header.h
.o.c: header.h == %.c: %.o header.h
</example>
Automatic variables for above rules:
<example>
foo.o: new1.c new2.c.c old1.c new3.c
$@ == foo.o                         (target)
$< == new1.c                        (first one)
$? == new1.c new2.c new3.c          (newer ones)
$^ == new1.c new2.c.c old1.c new3.c (all)
$* == `%' matched stem in the target pattern.
</example>
Variable references:
<example>
foo1 := bar    # One-time expansion
foo2  = bar    # Recursive expansion
foo3 += bar    # Append
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:%.c=%.o) 
OBJS := $(patsubst %.c,%.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extracts "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Run "make -p -f/dev/null" to see automatic internal rules. 
</sect>

<sect>C
<p>
Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 2nd edition
(Prentice Hall).
For the GNU C library function reference:
<example>
# apt-get install glibc6-doc manpages-dev
</example>
For the C library function reference, use "<prgn>info libc</prgn>".
For each function such as "printf", use "<prgn>man 3 printf</prgn>".

<sect1>Simple C program (gcc)
<p>
A simple example to compile "example.c" with a library "libm" into 
an executable "run_example":
<example>
$ cat &gt; example.c 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
	double x;
	char y[11];
	x=sqrt(argc+7.5);
	strncpy(y, argv[0], 10); /* prevent buffer overflow */
	y[10] = '\0'; /* fill to make sure string ends with '\0' */
	printf("%5i, %5.3f, %10s, %10s\n", argc, x, y, argv[1]);
	return 0;
}

$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
    1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
    2, 3.082, ./run_exam, 1234567890qwerty
</example>
Here, "-l<em>m</em>" is needed to link library "lib<em>m</em>" for sqrt().  
The actual library is in "/lib" with filename "libm.so.6", which is a softlink
to "libm-2.1.3.so".
<p>
Look at the last parameter in the output text.  There are more than 10
characters even though "%10s" is specified.  
<p>
The use of pointer memory operation functions without boundary checks, such as
sprintf and strcpy, is deprecated to prevent buffer overflow exploits that
leverage the above overrun effects.  Instead, use snprintf and strncpy.
</sect1>

<sect1>Debugging (gdb)
<p>
<url id="http://www.dirac.org/linux/gdb" name="GDB tutorial">
<p>
Use gdb to debug a program compiled with the -g option.  
Many commands can be abbreviated.  Tab expansion works as in the shell.
<example>
$ info gdb
...
$ gdb program
(gdb) b 1                # set breakpoint at line 1
(gdb) run arg1 arg2 arg3 # run program
(gdb) next               # next line
...
(gdb) step               # step forward
...
(gdb) p parm             # print parm 
...
(gdb) p parm=12          # set value to 12
</example>
For debugging from within emacs, refer to <ref id="editkey">.
</sect1>

<sect1>Flex &ndash; a better Lex
<p>
You need to provide your own main() and yywrap(), or your program.l 
should look like this to compile without a library (yywrap is a macro;
"%option main" turns on "%option noyywrap" implicitly):
<example>
%option main
%%
.|\n	ECHO ;
%%
</example>
Alternatively, you may compile with the -l<em>fl</em> linker option at the 
end of your cc command line (like ATT-Lex with -l<em>l</em>). No %option is
needed in this case.
</sect1>

<sect1>Bison &ndash; a better Yacc
<p>
You need to provide your own main() and yyerror(). Main() calls yyparse() 
which calls yylex(), usually created with FleX.
<example>
%%

%%
</example>
</sect1>

<sect1>Autoconf &ndash; uninstall
<p>
IF you still have the source and IF it uses autoconf/automake and IF you
can remember how you configured it:
<example>
$ ./configure all-of-the-options-you-gave-it
# make uninstall
</example>
</sect1>

</sect>

<sect>SGML
<p>
SGML enables management of multiple formats of a document. One easy SGML
system is Debiandoc, which is used here.  This requires minor conversion from
original text files for the following characters:
<example>
&lt;   &amp;lt;
&gt;   &amp;gt;
&amp;   &amp;amp;
&copy;   &amp;copy;
&ndash;   &amp;ndash;
&mdash;   &amp;mdash;
</example>
To mark a section as a non-printable comment, enter:
<example>
&lt;!-- State issue here ... --&gt;
</example>
To mark a section with a switchable comment, enter:
<example>
&lt;![ %FIXME [ State issue here ... ]]&gt;
</example>
In SGML, the <em>first definition</em> of an entity wins.  For example:
<example>
&lt;!entity % qref "INCLUDE"&gt;
&lt;![ %qref [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
This ends up as "Data 1".  If the first line has "IGNORE" instead of
"INCLUDE", this ends up as "Data 2" (the second line is a conditional
statement).
<p>
For more details, do "<prgn>apt-get install debiandoc-sgml-doc</prgn>".  
Also, read
<em>DocBook: The Definitive Guide</em>, by Walsh and Muellner (O'Reilly)
</sect>

<sect>Packaging
<p>
Read documentation supplied in the package "packaging-manual" (Potato) or
"debian-policy" (Woody).
<p>
Use dh_make from the dh-make package to create a baseline package. 
Then, proceed according to instructions in "<prgn>man dh_make</prgn>"
This uses debhelper in debian/rules.  
<p>
An alternative approach is to use deb-make from the debmake package.  This uses
no debhelper scripts and depends only on the shell.
<p>
For examples of multiple-source packages, see "mc" (dpkg-source -x
mc_4.5.54.dsc), which uses "sys-build.mk" by Adam Heath
&lt;doogie@debian.org&gt;, and "glibc" (dpkg-source -x glibc_2.2.4-1.dsc),
which uses another system by Joel Klecker &lt;espy@debian.org&gt;.
</sect>

</chapt>
