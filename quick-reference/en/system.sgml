<!-- CVS revision of this document "$Revision: 1.18 $"  -->
<chapt id="system">Debian fundamentals

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for potato and woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
This chapter provides fundamental information on the Debian system 
for non-developers.  For authoritative information, see:
<p>
<list compact>
<item>Debian Policy Manual
<item>Debian Packaging Manual (potato)
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
<p>
</list>
listed under <ref id="references">.

<p>
If you are looking for less detailed "how-to" explanations,
jump directly to <ref id="package"> or other relevant chapters.
<p>
This chapter consists of documents taken from the "Debian FAQ", greatly
reorganized to allow the ordinary Debian system administrator to get started.

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">The Debian archives

<sect1 id="dirtree">Directory structures

<p>The software that has been packaged for &debian; is available in one
of several directory trees on each 
<url id="&mirror-site;" 
     name="Debian mirror site">
through FTP or HTTP.

<p>The following directories can be found on each Debian mirror site
under the <tt>/debian/</tt> directory:
<taglist>
  <tag><file>/dists/</file>:
    <item>This directory contains the "distributions", and this used 
    to be the canonical way to access the currently available 
    packages in Debian releases and pre-releases. Some old packages 
    and <tt>Packages.gz</tt> files are still in here.
  <tag><file>/pool/</file>:
    <item>New physical location for all packages of Debian
    releases and pre-releases.
  <tag><file>/tools/</file>:
    <item>DOS utilities for creating boot disks, partitioning
    your disk drive, compressing/decompressing files, and booting Linux.
  <tag><file>/doc/</file>:
    <item>The basic Debian documentation, such as the FAQ, the bug reporting
          system instructions, etc.
  <tag><file>/indices/</file>:
    <item>The Maintainers file and the override files.
  <tag><file>/project/</file>:
    <item>mostly developer-only materials, such as:
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>This directory contains packages and tools which are still
        being developed, and are still in the alpha testing stage.  Users
        shouldn't be using packages from here, because they can be dangerous
        and harmful even for the most experienced.
      <tag><file>project/orphaned/</file>:
        <item>Packages that have been orphaned by their old maintainers, and
        withdrawn from the distribution.
    </taglist>
</taglist>

<sect1 id="dists">Debian distributions

<p>Normally there are three Debian distributions in the <tt>dists</tt> 
directory. They are named the "stable" distribution, the
"testing" distribution, and the "unstable" distribution. Sometimes there is
also a "frozen" distribution.  Each distribution 
is defined as a symlink to the actual directory with a codename in the
<tt>dists</tt> directory.

<sect1 id="stable">The <tt>stable</tt> distribution

<p>Package entries for the <tt>stable</tt> distribution, &stabledebian;, 
are recorded into the <tt>stable</tt> (symlink to <tt>&stablecodename;</tt>) directory:
<list>
  <item><file>stable/main/</file>:
  This directory contains the packages which formally constitute the most
  recent release of the &debian; system.

  <p>These packages all comply with the <url name="Debian Free Software
  Guidelines" id="&social-contract;#guidelines"> (also available as
  <file>&f-social-contract;</file> installed by 
  <package>&p-social-contract;</package>),
  and are all freely usable and distributable.

  <item><file>stable/non-free/</file>:  This directory contains packages
  distribution of which is restricted in a way that requires that distributors
  take careful account of the specified copyright requirements.

  <p>For example, some packages have licenses which prohibit commercial
  distribution.  Others can be redistributed but are in fact shareware
  and not free software.  The licenses of each of these packages must be
  studied, and possibly negotiated, before the packages are included in
  any redistribution (e.g., in a CD-ROM).

  <item><file>stable/contrib/</file>: This directory contains packages which are
  DFSG-free and <em>freely distributable</em> themselves, but somehow depend
  on a package that is <em>not</em> freely distributable and thus available only
  in the non-free section.
</list>
Now in adition to above locations, new phisical packages are 
located under the <tt>pool</tt> directory (<ref id="pools">).  

<p>The current status of <tt>stable</tt> distribution bugs is reported 
on the <url id="&stable-problems;" name="Stable Problems"> Web page.

<sect1 id="testing">The <tt>testing</tt> distribution

<p>Package entries for the <tt>testing</tt> distribution, &testingdebian;, 
are recorded into the <tt>testing</tt> (symlink to <tt>&testingcodename;</tt>) directory after they 
have undergone some degree of testing in <tt>unstable</tt>.  
Now in adition to above locations, new phisical packages are 
located under the <tt>pool</tt> directory (<ref id="pools">).  
There are also
<tt>main</tt>, <tt>contrib</tt> and <tt>non-free</tt> subdirectories in
<tt>testing</tt>, which serve the same functions as in <tt>stable</tt>.

<p>These packages must be in sync on all
architectures where they have been built and mustn't have dependencies that
make them uninstallable; they also have to have fewer release-critical bugs
than the versions currently in <tt>unstable</tt>. This way, we hope that
<tt>testing</tt> is
always close to being a release candidate.  More details of the testing 
mechanism are at <url id="&testing-notes;">.

<p>The latest status of the <tt>testing</tt> distribution is reported at these
sites:
<list compact>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="other bugs and bug squashing party notes">
</list>

<sect1 id="unstable">The <tt>unstable</tt> distribution

<p>Package entries for the <tt>unstable</tt> distribution, <tt>sid</tt>, 
are recorded into the <tt>unstable</tt> (symlink to <tt>sid</tt>) directory after
they are uploaded to the Debian archive and stay here until they are moved to
<tt>testing</tt>.  New physical packages are located under the <tt>pool</tt> directory
(<ref id="pools">).  There are also <tt>main</tt>, <tt>contrib</tt> and
<tt>non-free</tt> subdirectories in <tt>unstable</tt>, which serve the same
functions as in <tt>stable</tt>.

<p>The <tt>unstable</tt> distribution contains a snapshot of the most current 
development system. Users are welcome to use and test these packages, 
but are warned
about their state of readiness. The advantage of using the <tt>unstable</tt>
distribution is that you are always up-to-date with the latest in the &debian;
software project&mdash;but if it breaks, you get to keep both parts :-)

<p>The current status of <tt>unstable</tt> distribution bugs is reported 
on the <url id="&unstable-problems;" name="Unstable Problems"> Web page.

<!-- Above was enough
<sect1 id="sid">The "sid" distribution

<p><em>sid</em> or <em>unstable</em> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <em>testing</em>,
in order to be released in <em>stable</em> later on. sid contains packages
for both released and unreleased architectures.

<p>The name "sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">The <tt>frozen</tt> distribution

<p>When the <tt>testing</tt> distribution is mature enough, it becomes frozen,
meaning no new code is accepted anymore, just bugfixes, if necessary.
Also, a new testing tree is created in the <tt>dists</tt> directory,
assigned a new codename. The frozen distribution passes through a few months
of testing, with intermittent updates and deep freezes called "test cycles".
(The recent <tt>woody</tt> release process did not create a symbolic link
<tt>frozen</tt>, so <tt>frozen</tt> was not a distribution but just a
development stage of the <tt>testing</tt> distribution.)

<p>We keep a record of bugs in the frozen distribution that can delay a
package from being released or bugs that can hold back the whole release.
Once that bug count lowers to maximum acceptable values, the frozen
distribution becomes stable, it is released, and the previous stable
distribution becomes obsolete (and moves to the archive).

<sect1 id="codenames">Debian distribution codenames

<p>Physical directory names in the <tt>dists</tt> directory, such as
<tt>&stablecodename;</tt> and <tt>&testingcodename;</tt>, are just "codenames". When a &debian;
distribution is in the development stage, it has no version number, but a
codename instead. The purpose of these codenames is to make the mirroring of
the &debian; distributions easier (if a real directory like <tt>unstable</tt>
suddenly changed its name to <tt>stable</tt>, a lot of stuff would have to be
needlessly downloaded again).

<p>Currently, <tt>stable</tt> is a symbolic link to <tt>&stablecodename;</tt>, 
and <tt>testing</tt> is a symbolic link to
<tt>&testingcodename;</tt>. This means that <tt>&stablecodename;</tt> is the current stable
distribution and <tt>&testingcodename;</tt> is the current testing distribution.

<p><tt>unstable</tt> is a permanent symbolic link to <tt>sid</tt>, as
<tt>sid</tt> is always the unstable distribution. <!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">Codenames used in the past

<p>Other codenames that have already been used are: <tt>buzz</tt> for
release 1.1, <tt>rex</tt> for release 1.2, <tt>bo</tt> for releases 1.3.x,
<tt>hamm</tt> for release 2.0, <tt>slink</tt> for release 2.1, 
and <tt>potato</tt> for release 2.2.


<sect1 id="sourceforcodenames">The source for codenames

<p>So far they have been characters taken from the movie <em>Toy Story</em> by
Pixar.
<list compact>
  <item><em>buzz</em> (Buzz Lightyear) was the spaceman,
  <item><em>rex</em> was the tyrannosaurus,
  <item><em>bo</em> (Bo Peep) was the girl who took care of the sheep,
  <item><em>hamm</em> was the piggy bank,
  <item><em>slink</em> (Slinky Dog) was the toy dog,
  <item><em>sarge</em> was a leader of the Green Plastic Army Men,
  <item><em>potato</em> was, of course, Mr. Potato Head,
  <item><em>woody</em> was the cowboy.
  <item><em>sid</em> was a boy next door who destroyed toys.
</list>
<!--
  more info in http://www.pixar.com/feature/toystory/toystory.html 
  or better yet http://us.imdb.com/M/title-exact?Toy%20Story%20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Sarge and The Green Plastic Army Men
    - Andy (the kid)
    - Etch (Etch-a-Sketch) (the blackboard)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">The <tt>pool</tt> directory

<p>Historically, packages were kept in the subdirectory of <tt>dists</tt>
corresponding to the distribution that contained them. This turned out to
cause various problems, such as large bandwidth consumption on mirrors when
major changes were made.

<p>Packages are now kept in a large "pool", structured according to the name
of the source package. To make this manageable, the pool is subdivided by
section (<tt>main</tt>, <tt>contrib</tt> and <tt>non-free</tt>) and by the
first letter of the source package name. These directories contain several
files: the binary packages for each architecture, and the source packages from
which the binary packages were generated.

<p>You can find out where each package is placed by executing a command like
<tt>apt-cache showsrc <var>mypackagename</var></tt> and looking at the
"Directory:" line. For example, the <package>apache</package> packages are
stored in <file>pool/main/a/apache/</file>. Since there are so many
<tt>lib*</tt> packages, these are treated specially: for instance,
<package>libpaper</package> packages are stored in
<file>pool/main/libp/libpaper/</file>.

<p>The <tt>dists</tt> directories are still used for the index files used by
programs like <tt>apt</tt>. Also, at the time of writing, older
distributions have not been converted to use pools so you'll see paths
containing distributions such as potato or woody in the Filename header
field.

<p>Normally, you won't have to worry about any of this, as new <tt>apt</tt> and
probably older <tt>dpkg-ftp</tt> (see <ref id="howtocurrent">) will handle it
seamlessly. If you want more information, see the
<url id="&pool-faq;" name="Debian Package Pools FAQ">.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Historical notes about <tt>sid</tt>

<p>When the present-day <tt>sid</tt> did not exist, the <!--FTP removed --> 
Debian archive site organization had one major flaw: there was an assumption
that when an architecture was created in the current <tt>unstable</tt>, it
would be released when that distribution became the new <tt>stable</tt>. For
many architectures that wasn't the case, with the result that those
directories had to be moved at release time. This was impractical because the
move would chew up lots of bandwidth.

<p>The archive administrators worked around this problem for several years by
placing binaries for unreleased architectures in a special directory called
<tt>sid</tt>. For those architectures not yet released, the first time they
were released there was a link from the current <tt>stable</tt> to
<tt>sid</tt>, and from then on they were created inside the <tt>unstable</tt>
tree as usual. This layout was somewhat confusing to users.

<p>With the advent of package pools (see <ref id="pools">) during the 
<tt>woody</tt> distribution development, binary packages
began to be stored in a canonical location in the pool, regardless of the
distribution, so releasing a distribution no longer causes large bandwidth
consumption on the mirrors (there is, however, a lot of gradual bandwidth
consumption throughout the development process).

<sect1 id="incoming">Uploaded packages in <file>incoming</file>
<p>
Uploaded packages are first located at <url id="&incoming;"> 
before being checked to insure that they really come from a Debian
developer.  Once they're checked, they are moved out of <tt>incoming</tt>
to <tt>unstable</tt>.
<p>
In an emergency, you may want to install packages from <tt>incoming</tt>
before they reach <tt>unstable</tt>.  You can fetch them manually,
check the GPG signature and MD5sums in the <file>.changes</file> and
<file>.dsc</file> files, and then install them.
</sect1>

<sect1 id="snapshot">Retrieve an older package
<p>
While the most recent Debian distributions are kept under the <tt>debian</tt>
directory on each 
<url id="&mirror-site;" name="Debian mirror site">, 
archives for older Debian distributions 
such as <tt>slink</tt> are kept under the <tt>debian-archive</tt> directory 
on each <url id="&mirror-site;" name="Debian mirror site">
or <url id="&archivehome;">.
<p>
Older <tt>testing</tt> and <tt>unstable</tt> packages can be located at
<url id="&snapshothome;">.

</sect1>

<sect1 id="archsections">Architecture sections
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>Within each of the major directory trees (<file>dists/stable/main</file>,
<file>dists/stable/contrib</file>, <file>dists/stable/non-free</file>, 
<file>dists/unstable/main/</file>, etc.), the binary package entries reside in
subdirectories whose names indicate the chip architecture for which they
were compiled.

<list>
  <item><file>binary-all/</file>, for packages which are architecture-independent.
    These include, for example, Perl scripts, or pure documentation.
  <item><file>binary-<var>platform</var>/</file>, for packages which execute on a particular
  binary platform.
  <!-- Yes I simplified this -->
</list>

<p>Please note that the actual binary packages for <tt>testing</tt> and
<tt>unstable</tt> no longer reside in these directories, but in the top-level
<tt>pool</tt> directory. The index files (<file>Packages</file> and
<file>Packages.gz</file>) have been kept, though, for backwards compatibility.

<p>For the actual binary architectures supported, see Release Notes 
for each distribution.  They can be located at the Release Notes sites
for <url id="&stable-release;" name="stable"> and
<url id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">The source code

<p>Source code is included for everything in the Debian system. Moreover,
the license terms of most programs in the system <em>require</em> that
source code be distributed along with the programs, or that an offer to
provide the source code accompany the programs.

<p>Normally the source code is distributed in the <tt>source</tt> directories,
which are parallel to all the architecture-specific binary directories, or
more recently in the <tt>pool</tt> directory (see <ref id="pools">). To
retrieve the source code without having to be familiar with the structure of
the <!--FTP--> Debian archive, try a command like <tt>apt-get source 
<var>mypackagename</var></tt>.

<p>Some packages, notably <package>pine</package>, are only available in
source package due to their licensing limitations.  (Recently the
<package>pine-tracker</package> package has been provided to facilitate Pine
installation.) The procedures described in <ref id="port"> and <ref
id="packaging"> provide ways to build a package manually.

<p>Source code may or may not be available for packages in the "contrib"
and "non-free" directories, which are not formally part of the Debian system.

<sect id="pkg-basics">The Debian package management system

<sect1 id="package-basics">Overview of Debian packages

<p>Packages generally contain all of the files necessary to implement
a set of related commands or features.  There are two types of Debian
packages:
<list>
  <item><em>Binary packages</em>, which contain executables, configuration
  files, man/info pages, copyright information, and other documentation.
  These packages are distributed in a Debian-specific archive format
  (see <ref id="deb-format">); they are usually distinguished by having
  a <tt>.deb</tt> file extension. Binary packages can be unpacked using the Debian
  utility <tt>dpkg</tt>; details are given in its manual page.
  
  <item><em>Source packages</em>, which consist of a <tt>.dsc</tt> file
  describing the source package (including the names of the following
  files), a <tt>.orig.tar.gz</tt> file that contains the original
  unmodified source in gzip-compressed tar format, and usually a
  <tt>.diff.gz</tt> file that contains the Debian-specific changes to the
  original source.  The utility <tt>dpkg-source</tt> packs and unpacks
  Debian source archives; details are provided in its manual page.
</list>

<p>Installation of software by the package system uses "dependencies" which
are carefully designed by the package maintainers.  These dependencies are
documented in the <tt>control</tt> file associated with each package.
For example, the package containing the GNU C compiler (<package/gcc/)
"depends" on the package <package/binutils/ which includes the linker and
assembler. If a user attempts to install <package/gcc/ without having first
installed <package/binutils/, the package management system (dpkg) will send
an error message that it also needs <package/binutils/, and stop installing
<package/gcc/. (However, this facility can be overridden by the insistent
user, see <manref name="dpkg" section="8">.)  For additional details, see
<ref id="depends"> below.

<p>Debian's packaging tools can be used to:
<list>
  <item>manipulate and manage packages or parts of packages,
  <item>aid the user in the splitting of packages that must be transmitted
    through a limited-size medium such as floppy disks,
  <item>aid developers in the construction of package archives, and
  <item>aid users in the installation of packages which reside on a remote
    <!--FTP-->Debian archive site.
</list>

<sect1 id="deb-format">Debian <!--binary--> package format

<p>A Debian "package", or a Debian archive file, contains the executable
files, libraries, and documentation associated with a particular program
suite or set of related programs.  Normally, a Debian archive file has
a filename that ends in <tt>.deb</tt>.

<p>The internals of this Debian binary package format are described in the
<manref name="deb" section="5"> manual page. Because this internal format is
subject to change (between major releases of &debian;), always use
<manref name="dpkg-deb" section="8"> for manipulating <tt>.deb</tt>
files.

<!-- Below added by Osamu XXX Not sure but should be right -->

<p>Through at least the <tt>woody</tt> distribution, all Debian archive files
have been manipulable by the standard Unix commands <prgn>ar</prgn> and
<prgn>tar</prgn>, even when dpkg commands are not available.

<sect1 id="pkgname">Naming conventions for Debian package filenames
<!--
Why are Debian package file names so long? 
-->
<p>The Debian <!--binary--> package filenames conform to the following convention:
<example>
<var>foo</var>_<var>VersionNumber</var>-<var>DebianRevisionNumber</var>.deb
</example>
where <var>foo</var> represents the package name. As a check,
one can determine the package name associated with a particular Debian archive
file (<tt>.deb</tt> file) in one of these ways:
<list>
  <item>inspect the "Packages" file in the directory where it was stored
  at a Debian <!--FTP--> archive site.  This file contains a stanza describing
  each package; the first field in each stanza is the formal package name.
  
  <item>use the command <tt>dpkg --info <var>foo_VVV-RRR</var>.deb</tt> (where
  <var>VVV</var> and <var>RRR</var> are the version and revision of the
  package in question, respectively).  This displays, among other things, the
  package name corresponding to the archive file being unpacked.
</list>

<p>The <var>VVV</var> component is the version number specified by the
upstream developer.  There are no standards governing version numbers, so they
may have formats as different as "19990513" and "1.3.8pre1".

<p>The <var>RRR</var> component is the Debian revision number, and is
specified by the Debian developer (or an individual user if he chooses
to build the package himself).  This number corresponds to the revision
level of the Debian package; thus, a new revision level usually signifies
changes in the Debian Makefile (<tt>debian/rules</tt>), the Debian control
file (<tt>debian/control</tt>), the installation or removal scripts
(<tt>debian/p*</tt>), or in the configuration files used with the package.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Preservation of the local configuration
<!--
What is a Debian conffile
-->
<p>Preservation of user-configurable files is enabled through &debian;'s
"conffiles" mechanism.  User configuration files (usually placed in
<file>/etc</file>) are specified in the <tt>conffiles</tt> within the Debian
package system.  The package management system guarantees not to overwrite
these files when the package is upgraded.
<p>
When it is possible to configure the system without modifying files that belong
to various &debian; packages, it is usually a good idea not to modify them
even if they are "conffiles".  This ensures faster and smoother upgrade
operations.
<!--
<p>Conffiles is a list of configuration files (usually placed in <tt>/etc</tt>)
that the package management system will not overwrite when the package is
upgraded. This ensures that local values for the contents of these files
will be preserved, and is a critical feature enabling the in-place upgrade
of packages on a running system.
-->
<p>To determine exactly which files are preserved during an upgrade, run:
<example>
dpkg --status <var>package</var>
</example>
and look under "Conffiles:".

<p>
Specifics regarding the contents of a Debian <tt>conffiles</tt> file are
provided in the Debian Policy Manual, section 11.7 (see <ref id="references">).

<sect1 id="maintscripts">Debian maintenance scripts
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian maintenance scripts
are executable scripts which are automatically run before
or after a package is installed. Along with a file named <tt>control</tt>,
all of these files are part of the "control" section of a Debian archive file.

<p>The individual files are:
<taglist>
<tag/preinst/
  <item>This script executes before its package is unpacked from its
  Debian archive (<tt/.deb/) file. Many "preinst" scripts stop services for
  packages which are being upgraded until their installation or upgrade is
  completed (following the successful execution of the "postinst" script).

<tag/postinst/
  <item>This script typically completes any required configuration of a
  package once it has been unpacked from its Debian
  archive (<tt/.deb/) file. Often, 'postinst' scripts ask the user for input,
  and/or warn the user that if he accepts default values, he should remember
  to go back and reconfigure that package as the situation warrants.
  Many "postinst" scripts then execute any commands necessary to start or
  restart a service once a new package has been installed or upgraded.

<tag/prerm/
  <item>This script typically stops any daemons which are associated with
  a package.  It is executed before the removal of files associated with
  the package.

<tag/postrm/
  <item>This script typically modifies links or other files associated with
  a package, and/or removes files created by it. (Also see
  <ref id="virtual">.)
</taglist>

<p>Currently all of the control files can be found in the directory
<file>/var/lib/dpkg/info</file>. The files relevant to package <tt>foo</tt>
begin with the name "foo" and have file extensions of "preinst", "postinst",
etc., as appropriate.  The file <tt>foo.list</tt> in that directory
lists all of the files that were installed with the package <tt>foo</tt>.
(Note that the location of these files is a dpkg internal, and may be
subject to change.)

<sect1 id="priority">Package priorities
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Each Debian package is assigned a <em>priority</em> by the distribution
maintainers, as an aid to the package management system.  The priorities are:

<list>
  <item><strong>Required</strong> packages are necessary for the proper
    functioning of the system.
    <p>This includes all tools that are necessary to repair system defects.
    You must not remove these packages or your system may become totally broken
    and you may probably not even be able to use dpkg to put things back.
    Systems with only the Required packages are probably unusable, but they do
    have enough functionality to allow the sysadmin to boot and install more
    software.
  <item><strong>Important</strong> packages should be found on any Unix-like
    system.
    <p>Other packages without which the system will not run well or be usable 
    will be here. This does <em>not</em> include Emacs or X11 or TeX or any
    other large applications. These packages only constitute the bare
    infrastructure.
  <item><strong>Standard</strong> packages are standard on any Linux system,
    including a reasonably small but not too limited character-mode system.
    <p>This is what will install by default if users do not select anything
    else. It does not include many large applications, but it does include
    Emacs (this is more a piece of infrastructure than an application)
    and a reasonable subset of TeX and LaTeX (if this turns out to be
    possible without X).
  <item><strong>Optional</strong> packages include all those that you might
    reasonably want to install even if you are unfamiliar with them, and if
    you don't have have specialized requirements.
    <p>This includes X11, a full TeX distribution, and lots of applications.
  <item><strong>Extra</strong>: packages that either conflict with others
    with higher priorities, are only likely to be useful if you already know
    what they are, or have specialized requirements that make them
    unsuitable for "Optional".
</list>

<sect1 id="virtual">Virtual packages

<p>A virtual package is a generic name that applies to any one of a group
of packages, all of which provide similar basic functionality. For example,
both the <tt>tin</tt> and <tt>trn</tt> programs are news readers, and
should therefore satisfy any dependency of a program that required a news
reader on a system, in order to work or to be useful.
They are therefore both said to provide the "virtual package" called
<tt>news-reader</tt>.

<p>Similarly, <tt>exim</tt> and <tt>sendmail</tt> both provide the
functionality of a mail transport agent.  They are therefore said to
provide the virtual package "mail transport agent".
If either one is installed, then any program depending on the
installation of a <tt>mail-transport-agent</tt> will be satisfied by
the existence of this virtual package.

<p>Debian has a mechanism so that, if more than one package which
provides the same virtual package is installed on a system, the system
administrator can set one as the preferred package. The relevant command
is <tt>update-alternatives</tt>, and is described further in
<ref id="alternatives">.

<sect1 id="depends">Package dependencies
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>The Debian package system has a range of package "dependencies"
which are designed to indicate (in a single flag) the level at which
Program A can operate independently of the existence of Program B on
a given system:
<list>
  <item>Package A <em>depends</em> on Package B if B absolutely must be
  installed in order to run A.  In some cases, A depends not only on B, but on
  a specific version of B.  In this case, the version dependency is usually a
  lower limit, in the sense that A depends on any version of B more recent
  than some specified version.
  <item>Package A <em>recommends</em> Package B if the package maintainer
    judges that most users would not want A without also having the
    functionality provided by B.
  <item>Package A <em>suggests</em> Package B if B contains files that
    are related to (and usually enhance) the functionality of A.
  <item>Package A <em>conflicts</em> with Package B when A will not
    operate if B is installed on the system.  Most often, conflicts are
    cases where A contains files which are an improvement over those in B.
    "Conflicts" are often combined with "replaces".
  <item>Package A <em>replaces</em> Package B when files installed
    by B are removed and (in some cases) overwritten by files in A.
  <item>Package A <em>provides</em> Package B when all of the files and
    functionality of B are incorporated into A.  This mechanism provides
    a way for users with constrained disk space to get only that part of
    package A which they really need.
</list>

<p>More detailed information on the use of each these terms can be found
in the Packaging manual and the Policy manual.

<p>Note that <prgn>dselect</prgn> has more fine-grained 
control over packages specified by <em>recommends</em> and 
<em>suggests</em> than <file>apt-get</file>, which simply pulls all 
the packages specified by <em>recommends</em> and leaves all
the packages specified by <em>suggests</em>.  Both programs in modern 
form use APT as their back end.

<sect1 id="pre-depends">The meaning of Pre-depends

<p>"Pre-depends" is a special dependency. In the case of an ordinary package,
<prgn>dpkg</prgn> will unpack its archive file (i.e., its <tt>.deb</tt> file)
independently of whether or not the files on which it depends exist on the
system.  Simplistically, unpacking means that <prgn>dpkg</prgn> will extract
the files from the archive file that were meant to be installed on your
file system, and put them in place.  If those packages <em>depend</em> on
the existence of some other packages on your system, <prgn>dpkg</prgn> will
refuse to complete the installation (by executing its "configure" action)
until the other packages are installed.

<p>However, for some packages, <prgn>dpkg</prgn> will refuse even to unpack
them until certain dependencies are resolved.  Such packages are said
to "pre-depend" on the presence of some other package(s).
The Debian project provided this mechanism to support the safe upgrading
of systems from <tt>a.out</tt> format to <tt>ELF</tt> format, where
the <em>order</em> in which packages were unpacked was critical. There are
other large upgrade situations where this method is useful, e.g. for
packages with "required" priority and their libc dependency.

<p>Once again, more detailed information about this can be found in the
Packaging manual.

<sect1 id="pkgstatus">Package status
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Package status can be "unknown", "install", "remove", "purge", or 
"hold".
These "want" flags tell what the user wanted to do with a package (as
indicated either by the user's actions in the "Select" section of
<prgn>dselect</prgn>, or by the user's direct invocations of <prgn>dpkg</prgn>).

<p>Their meanings are:
<list>
  <item>unknown  - the user has never indicated whether he wants the package.
  <item>install  - the user wants the package installed or upgraded.
  <item>remove   - the user wants the package removed, but does not want to
    remove any existing configuration files.
  <item>purge    - the user wants the package to be removed completely,
    including its configuration files.
  <item>hold     - the user wants this package not to be processed, i.e., he
    wants to keep the current version with the current status whatever that is.
</list>

<sect1 id="puttingonhold">Holding back packages from an upgrade
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>There are two mechanisms of holding back packages from the upgrade, 
through <prgn>dpkg</prgn>, or, in woody, through APT.

<p>With <prgn>dpkg</prgn>, first export the list of package selections:
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
Then edit the resulting file <file><var>selections.txt</var></file>, changing the line
containing the package you wish to hold, e.g. <package/libc6/, from this:
<example>
libc6                       install
</example>
to this:
<example>
libc6                       hold
</example>
Save the file, and reload it into <prgn>dpkg</prgn> database with:
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
Or, if you know the package name to hold, simply run:
<example>
echo libc6 hold | dpkg --set-selections
</example>
This process holds packages at the install process of each package file.

<p>The same effect can be obtained through <prgn>dselect</prgn>. Simply enter
the [S]elect screen, find the package you wish to hold in its present state,
and press the `=' key (or `H'). The changes will take effect immediately after
you exit the [S]elect screen.

<p>The APT system in the woody distribution has a new alternative mechanism
for holding packages during the archive retrieval process using
<tt>Pin-Priority</tt>.  See the manual page <manref name="apt_preferences"
section="5">.

<!--- XXX apt-howto, apt_preferences, pointer within this.  -->

<sect1 id="sourcepkgs">Source packages

<p>
<!--
Debian source packages can't actually be "installed", they are just
unpacked in whatever directory you want to build the binary packages they
produce.
-->
Source packages are distributed in a directory called <tt>source</tt>, and
you can either download them manually, or use
<example>
apt-get source <var>foo</var>
</example>
to fetch them (see the <manref name="apt-get" section="8"> manual page on how
to set up APT for doing that).

<!-- XXX 
Pointer to building package   
mention deb-src thing here 
-->

<sect1 id="sourcebuild">Building binary packages from a source package

<p>For a package <tt><var>foo</var></tt>, you will need all of <file><var>foo_*</var>.dsc</file>,
<file><var>foo_*</var>.tar.gz</file> and <file><var>foo_*.diff</var>.gz</file> to compile the source
(note: there is no <tt>.diff.gz</tt> for a Debian native package).

<p>Once you have them, if you have the <package/dpkg-dev/ package installed,
the command
<example>
dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
will extract the package into a directory called <tt><var>foo-version</var></tt>.

<p>If you want just to compile the package, you may cd into
the <tt>foo-version</tt> directory and issue the command
<example>
# debian/rules build
</example>
to build the program, then
<example>
# debian/rules binary
</example>
as root, to build the package, and then
<example>
dpkg -i ../<var>foo_version-revision_arch</var>.deb
</example>
to install the newly built package.

<!-- XXX woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Creating new Debian packages

<p>For a more detailed description, read the New Maintainers' Guide,
available in the <package/maint-guide/ package, or at
<url id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Upgrading a Debian system

<p>One of Debian's goals is to provide a consistent upgrade path and a secure
upgrade process, and we always do our best to make a new release smoothly
upgradable from the previous ones.  Packages will alert the user when there
are important notices during the upgrade process, and will often provide a
solution to a possible problem.

<p>You should also read the Release Notes, the document that describes the
details of specific upgrades, shipped on all Debian CDs, and available on
the WWW at <url id="&stable-release;"> or <url id="&testing-release;">.

<p>
A practical guide to upgrades is provided in <ref id="package">.  This section 
describes the fundamental details.

<!-- XXX make this into generic link -->

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Methods for upgrading a Debian system

<p>One could simply execute an anonymous FTP or <prgn>wget</prgn> call to a
Debian archive, peruse the directories until one finds the desired file, fetch
it, and finally install it using <prgn>dpkg</prgn>.  Note that
<prgn>dpkg</prgn> will install upgrade files in place, even on a running
system.  Sometimes, a revised package will require the installation of a newly
revised version of another package, in which case the installation will fail
until/unless the other package is installed.

<p>Many people find this approach much too time-consuming, since Debian
evolves so quickly&mdash;typically, a dozen or more new packages are uploaded
every week.  This number is larger just before a new major release.
To deal with this avalanche, many people prefer to use an automated
program.  Several specialized package management tools are available 
for this purpose.

<sect1 id="pkgtools">Package management tools overview

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>The Debian package management system has two objectives: the manipulation 
of the package file itself and the retrieval of package files from 
the Debian archive.  <prgn>dpkg</prgn> performs the former task, APT and
<prgn>dselect</prgn> the latter.

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>This is the main program for manipulating package files; read
<manref name="dpkg" section="8"> for a full description.
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> comes with several primitive supplemental programs.

<list>
<item>dpkg-deb: Manipulate <tt>.deb</tt> files. 
 <manref name="dpkg-deb" section="1">
<item>dpkg-ftp: An older package file retrieval command. 
 <manref name="dpkg-ftp" section="1">
<item>dpkg-mountable: An older package file retrieval command. 
 <manref name="dpkg-mountable" section="1">
<item>dpkg-split: Splits a large package into smaller files. 
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> and <prgn>dpkg-mountable</prgn> have been superseded
by the introduction of the APT system.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT is an advanced interface to the Debian packaging system. 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn> and <prgn>apt-cdrom</prgn> 
are the command-line tools for handling packages.  These also function 
as the user's "back-end" programs to other tools, such as <prgn/dselect/ 
and <prgn/aptitude/.

<p>For more information, install the <package/apt/ package and read
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (woody), and
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>An alternative source of information is the
<url id="&apt-howto;" name="APT HOWTO">.
This can be installed by <package/apt-howto/ at
<file>/usr/share/doc/apt-howto/en/apt-howto-en.html/index.html</file>.

<p><tt>apt-get upgrade</tt> and <tt>apt-get dist-upgrade</tt> have a 
tendency to pull in all packages listed under "Suggests:".  
To avoid this, use <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>This program is a menu-driven user interface to the Debian package management
system. It is particularly useful for first-time installations and
large-scale upgrades.  See <ref id="dselect">.

<p>For more information, install the <package/install-doc/ package and read
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> or
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <tt>start-stop-daemon</tt> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Upgrade a running system

<p>The kernel (file system) in &debian; systems supports replacing files even
while they're being used.

<p>We also provide a program called <prgn/start-stop-daemon/ which is used
to start daemons at boot time or to stop daemons when the kernel runlevel is
changed (e.g., from multi-user to single-user or to halt). The same program
is used by installation scripts when a new package containing a daemon is
installed, to stop running daemons, and restart them as necessary.

<p>Note that the Debian system does not require 
use of the single-user mode to upgrade a running system.

<sect1 id="savedebs">Downloaded and cached <tt>.deb</tt> archive files

<p>If you have manually downloaded the files to your disk 
(which is not absolutely necessary, see above for the description of 
<prgn>dpkg-ftp</prgn> or APT), then after
you have installed the packages, you can remove them from your system.

<p>If APT is used, these files are cached in the
<file>/var/cache/apt/archives/</file> directory.  You may erase them after
installation (<tt>apt-get clean</tt>) or copy them to another machine's
<file>/var/cache/apt/archives/</file> directory to save downloading during
subsequent installations.

<!-- insert apt-get clean... thing and dselect configuration here XXXX -->

<sect1 id="keepingalog">Record-keeping for upgrades

<p><prgn/dpkg/ keeps a record of the packages that have been unpacked,
configured, removed, and/or purged, but does not (currently) keep a log
of terminal activity that occurred while a package was being so manipulated.

<p>The simplest way to work around this is to run your
<prgn>dpkg</prgn>, <prgn>dselect</prgn>, <prgn>apt-get</prgn>, etc.,
sessions within the <manref name="script" section="1"> program.

<sect id="boot">The Debian boot process

<sect1 id="init">The <tt>init</tt> program

<p>Like all Unices, Debian boots up by executing the program <tt>init</tt>.
The configuration file for <tt>init</tt> (which is <tt>/etc/inittab</tt>)
specifies that the first script to be executed should be
<tt>/etc/init.d/rcS</tt>.  This script runs all of the scripts in
<tt>/etc/rcS.d/</tt> by sourcing or forking subprocess depending on their file
extension to perform initialization such as to check and to mount file systems,
to load modules, to start the network services, to set the clock, and to
perform other initialization.  Then, for compatibility, it runs the files
(except those with a `.' in the filename) in <tt>/etc/rc.boot/</tt> too. Any
scripts in the latter directory are usually reserved for system administrator
use, and using them in packages is deprecated.  See <ref id="init-hints"> for
more info.

<sect1 id="runlevels">Runlevels

<p>After completing the boot process, <tt>init</tt> executes all start
scripts in a directory specified by the default runlevel (this runlevel
is given by the entry for <tt>id</tt> in <tt>/etc/inittab</tt>).
Like most <!-- all? SGK --> System V compatible Unices, Linux has 7 runlevels:
<list compact>
  <item>0 (halt the system),
  <item>1 (single-user mode),
  <item>2 through 5 (various multi-user modes), and
  <item>6 (reboot the system).
</list>
Debian systems come with <tt>id=2</tt>, which indicates that the default
runlevel will be 2 when the multi-user state is entered, and the
scripts in <tt>/etc/rc2.d/</tt> will be run.

<p>In fact, the scripts in any of the directories <file>/etc/rc<var>N</var>.d/</file>
are just symbolic links back to scripts in <file>/etc/init.d/</file>.  However,
the <em>names</em> of the files in each of the <file>/etc/rc<var>N</var>.d/</file>
directories are selected to indicate the <em>way</em> the scripts in
<file>/etc/init.d/</file> will be run.  Specifically, before entering any
runlevel, all the scripts beginning with `K' are run; these scripts kill
services.  Then all the scripts beginning with `S' are run; these scripts
start services.  The two-digit number following the `K' or `S' indicates
the order in which the script is run.  Lower-numbered scripts are executed
first.

<p>This approach works because the scripts in <tt>/etc/init.d/</tt> all
take an argument which can be either "start", "stop", "reload", "restart"
or "force-reload" and will then do the task indicated by the argument.
These scripts can be used even after a system has been booted, to control
various processes.

<p>For example, with the argument "reload" the command
<example>
# /etc/init.d/sendmail reload
</example>
sends the sendmail daemon a signal to reread its configuration file.

<sect1 id="custombootscripts">Customizing the boot process
<p>
Debian does not use a BSD-style
<tt>rc.local</tt> directory to customize the boot process; what facilities
are provided for doing this?

<p>Suppose a system needs to execute script <tt>foo</tt> on start-up,
or on entry to a particular (System V) runlevel.  Then the system
administrator should:
<enumlist>
  <item>Enter the script <tt>foo</tt> into the directory
    <file>/etc/init.d/</file>.
  <item>Run the Debian command <prgn>update-rc.d</prgn> with appropriate
    arguments, to set up links between the (command-line-specified)
    directories <tt>rc<var>?</var>.d</tt> and <file>/etc/init.d/foo</file>.
    Here, <var>?</var> is a number from 0 through 6 that corresponds to one of
    the System V runlevels.
  <item>Reboot the system.
</enumlist>

<p>The command <tt>update-rc.d</tt> will set up links between files in
the directories <tt>rc<var>?</var>.d</tt> and the script in <file>/etc/init.d/</file>.
Each link will begin with an `S' or a `K', followed by a number, followed
by the name of the script.  Scripts beginning with `S' in
<file>/etc/rcN.d/</file> are executed when runlevel <tt>N</tt> is entered.
Scripts beginning with a `K' are executed when leaving runlevel <tt>N</tt>.

<p>One might, for example, cause the script <tt>foo</tt> to execute at
boot-up, by putting it in <file>/etc/init.d/</file> and installing the links
with <tt>update-rc.d foo defaults 19</tt>.  The argument <tt>defaults</tt>
refers to the default runlevels, which are 2 through 5.  The argument
<tt>19</tt> ensures that <tt>foo</tt> is called before any scripts containing
numbers 20 or larger.

<sect id="diverse">Supporting diversity
<p>
Debian offers several avenues to accommodate any wishes of the system 
administrator without breaking the system. 
<list>
<item><prgn>dpkg-divert</prgn>, see <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, see <ref id="equivs">.
<item><prgn>update-alternative</prgn>, see <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> can accommodate many boot loaders. 
      See <manref name="make-kpkg" section="1"> and <ref id="kernel-debian">.
</list>
Any files under <file>/usr/local/</file> belong to the system administrator 
and &debian; will not touch them. Most (or all) files under <file>/etc</file> are 
<tt>conffiles</tt> and &debian; will not overwrite them upon upgrade unless 
the system administrator requests so explicitly.

<sect id="nonenglish">Non-English locales

<p>
Support for conventions that differ according to language and/or culture is
provided through <tt>locale</tt> technology.  See <manref name="locale"
section="7">.
<p>
A locale is a set of language and cultural rules. These
cover aspects such as the language of system messages, different
character sets, spelling conventions, etc. A program
needs to be able to determine its locale and act accordingly 
to be portable to different cultures.
<p>
The following environment variables are evaluated in this order to provide
locale values to programs:
<enumlist>
<item>LANGUAGE: This environment variable consists of a colon-separated 
      list of locale names in order of priority. Used only if the POSIX
      locale is set to a value other than "C" [in woody; the potato version
      always has priority over the POSIX locale]. (GNU extension)
<item>LC_ALL: If this is non-null, the value is used for all locale
      categories. (POSIX.1) Usually "" (null).
<item>LC_*: If this is non-null, the value is used
      for the corresponding category (POSIX.1).  Usually "C".
<p>
      LC_* variables are:
 <list compact>
<item>LC_CTYPE: Character classification and case conversion.
<item>LC_COLLATE: Collation order.
<item>LC_TIME: Date and time formats.
<item>LC_NUMERIC: Non-monetary numeric formats.
<item>LC_MONETARY: Monetary formats.
<item>LC_MESSAGES: Formats of informative and diagnostic messages and
            interactive responses.
<item>LC_PAPER: Paper size.
<item>LC_NAME: Name formats.
<item>LC_ADDRESS: Address formats and location information.
<item>LC_TELEPHONE: Telephone number formats.
<item>LC_MEASUREMENT: Measurement units (Metric or Other).
<item>LC_IDENTIFICATION: Metadata about the locale information.
 </list>
<item>LANG:   If this is non-null and LC_ALL is undefined, the value is used
      for all LC_* locale categories with undefined values. (POSIX.1) Usually
      "C".
</enumlist>
Note that some applications (e.g. Netscape 4) ignore LC_* settings.
<p>
For more information, see the internationalization document, <url
id="&intro-i18n;" name="Introduction to i18n">. It is aimed at developers but
is also useful for system administrators.
<list>
  <item>&debian; is distributed with keymaps for nearly two dozen
    keyboards, and with utilities (in the <tt>kbd</tt> package) to install,
    view, and modify the tables. <!-- XXXX kbd or console ??? -->
    <p>The installation prompts the user to specify the keyboard he will use.
  <item>The vast majority of Debian software packages support entering
    non-US-ASCII characters used in other Latin languages (e.g. ISO-8859-1
    or ISO-8859-2), and a number of programs support multi-byte languages
    such as Japanese or Chinese.
  <item>Currently, support for German-, Spanish-, Finnish-, French-,
    Hungarian-, Italian-, Japanese-, Korean- and Polish-language manual pages
    is provided through the <tt>manpages-<var>LANG</var></tt> packages (where
    <var>LANG</var> is the two-letter ISO country code). To access an NLS
    manual page, the user must set the shell LC_MESSAGES variable to the
    appropriate string.
    <p>For example, in the case of the Italian-language manual pages,
    LC_MESSAGES needs to be set to <tt>it</tt>.  The <prgn/man/ program will
    then search for Italian manual pages under <file>/usr/share/man/it/</file>.
  <item>Note that Debian does <strong>not</strong> come with all available
    locales pre-compiled. Check <file>/usr/lib/locale</file> to see which
    locales (besides the default "C") are compiled for your system. If the one
    you need is not present, you have two options:
    <enumlist compact>
    <item>Edit <file>/etc/locale.gen</file> to add the desired locale, then
      run <prgn>locale-gen</prgn> as root to compile it. See <manref
      name="locale-gen" section="8"> and the manpages listed in its "SEE ALSO"
      section.
    <item>Run <tt>dpkg-reconfigure locales</tt> to reconfigure the
      <package>locales</package> package.
    </enumlist>
</list>

<sect id="kernel-details">Debian and the kernel
<p>
See <ref id="kernel">.

<sect1 id="non-debian-kernel">Compiling a kernel from non-Debian source

<p><!--Yes.  But you have-->
One has to understand the Debian policy with respect to headers.

<p>The Debian C libraries are built with the most recent <em>stable</em>
releases of the <strong>kernel</strong> headers.

<p>For example, the Debian-1.2 release used version 5.4.13 of the headers.
This practice contrasts with the Linux kernel source packages distributed
at all Linux FTP archive sites, which use even more recent versions of
the headers.  The kernel headers distributed with the kernel source are
located in <file>/usr/include/linux/include/</file>.

<p>If you need to compile a program with kernel headers that are newer
than those provided by <package/libc6-dev/, then you must add
<tt>-I/usr/src/linux/include/</tt> to your command line when compiling.
This came up at one point, for example, with the packaging of the
automounter daemon (<package/amd/).  When new kernels changed some
internals dealing with NFS, <prgn>amd</prgn> needed to know about them.
This required the inclusion of the latest kernel headers.

<sect1 id="customkernel">Tools to build custom kernels

<p>Users who wish to (or must) build a custom kernel are encouraged to
download the package <package/kernel-package/.  This package contains
the script to build the kernel package, and provides the capability to
create a Debian kernel-image package just by running the command
<example>
# make-kpkg kernel_image
</example>
in the top-level kernel source directory.
Help is available by executing the command
<example>
# make-kpkg --help
</example>
and through the manual page <manref name="make-kpkg" section="8">
and <ref id="kernel">.

<p>Users must separately download the source code for the most recent
kernel (or the kernel of their choice) from their favorite Linux archive
site, unless a kernel-source-<var>version</var> package is available 
(where <var>version</var> stands for the kernel version).  The Debian
<file>initrd</file> boot script requires a special kernel patch called
<prgn>initrd</prgn>; see <url id="&bug-initrd;">.

<p>Detailed instructions for using the <package/kernel-package/ package
are given in the file <tt>/usr/doc/kernel-package/README</tt>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">Alternative boot loaders
<p>
To employ alternative boot loaders such as <package/grub/ or
<package/loadlin/, copy the compiled Linux kernel <file>bzimage</file> to
other locations (e.g., to <file>/boot/grub</file> or to an MS-DOS partition).
</sect1>

<sect1 id="custombootdisk">Custom boot floppies

<p>The task of making a custom boot floppy is greatly aided by the Debian
package <package/boot-floppies/, normally found in the <tt>admin</tt> section
of the Debian FTP archive.  Shell scripts in this package produce boot
floppies in <prgn>syslinux</prgn> format.  These are MS-DOS formatted floppies
whose master boot records have been altered so that they boot Linux directly
(or whatever other operating system has been defined in the
<tt>syslinux.cfg</tt> file on the floppy). Other scripts in this package
produce emergency root disks and can even reproduce the base disks.

<p>You will find more information about this in the
<file>/usr/doc/boot-floppies/README</file> file after installing the
<package/boot-floppies/ package.

<sect1 id="modules">Special provisions for dealing with modules

<p>Debian's <package/modconf/ package provides a shell script
(<file>/usr/sbin/modconf</file>) which can be used to customize the
configuration of modules.  This script presents a menu-based interface,
prompting the user for particulars on the loadable device drivers in his
system.  The responses are used to customize the file
<file>/etc/modules.conf</file> (which lists aliases, and other arguments that
must be used in conjunction with various modules) through files in
<file>/etc/modutils/</file>, and <file>/etc/modules</file> (which lists the
modules that must be loaded at boot time).

<p>Like the (new) Configure.help files that are now available to support
the construction of custom kernels, the <package/modconf/ package comes with a
series of help files (in <file>/usr/lib/modules_help/</file>) which provide
detailed information on appropriate arguments for each of the modules.

<!-- XXXX need section for initrd -->

<sect1 id="removeoldkernel">De-installing an old kernel package

<p>The <tt>kernel-image-<var>NNN</var>.prerm</tt> script checks to see whether
the kernel you are currently running is the same as the kernel you are trying
to de-install.  Therefore you can safely remove unwanted kernel image packages
using this command:

<example>
dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(replace <var>NNN</var> with your kernel version and revision number, of course)
</sect>
