<!-- CVS revision of this document "$Revision: 1.55 $"  -->
<chapt id="system">Debian fundamentals

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
This chapter provides fundamental information on the Debian system 
for non-developers.  For authoritative information, see:
<p>
<list compact>
<item>Debian Policy Manual
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
<p>
</list>
listed under <ref id="references">.

<p>
If you are looking for less detailed "how-to" explanations,
jump directly to <ref id="package"> or other relevant chapters.
<p>
This chapter is based on documents taken from the "Debian FAQ", greatly
reorganized to allow the ordinary Debian system administrator to get started.

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">The Debian archives

<sect1 id="dirtree">Directory structures

<p>The software that has been packaged for &debian; is available in one
of several directory trees on each 
<url id="&mirror-site;" 
     name="Debian mirror site">
through FTP or HTTP.

<p>The following directories can be found on each Debian mirror site
under the <file>debian</file> directory:
<taglist>
  <tag><file>dists/</file>:
    <item>This directory contains the "distributions", and this used 
    to be the canonical way to access the currently available 
    packages in Debian releases and pre-releases. Some old packages, 
    the <file>Contents-*.gz</file>
    and <file>Packages.gz</file> files are still in here.
  <tag><file>pool/</file>:
    <item>The new physical location for all packages of Debian
    releases and pre-releases.
  <tag><file>tools/</file>:
    <item>DOS utilities for creating boot disks, partitioning
    your disk drive, compressing/decompressing files, and booting Linux.
  <tag><file>doc/</file>:
    <item>The basic Debian documentation, such as the FAQ, the bug reporting
          system instructions, etc.
  <tag><file>indices/</file>:
    <item>The Maintainers file and the override files.
  <tag><file>project/</file>:
    <item>mostly developer-only materials, such as:
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>This directory contains packages and tools which are still
        being developed, and are still in the alpha testing stage.  Users
        shouldn't be using packages from here, because they can be dangerous
        and harmful even for the most experienced.
      <tag><file>project/orphaned/</file>:
        <item>Packages that have been orphaned by their old maintainers, and
        withdrawn from the distribution.
    </taglist>
</taglist>

<sect1 id="dists">Debian distributions

<p>Normally there are three Debian distributions in the <file>dists</file> 
directory. They are named the <tt>stable</tt> distribution, the
<tt>testing</tt> distribution, and the <tt>unstable</tt> distribution. 
Sometimes there was
also a <tt>frozen</tt> distribution (currently it is just a development 
stage of the testing distribution).  Each distribution 
is defined as a symlink to the actual directory with a codename in the
<file>dists</file> directory.

<sect1 id="stable">The <tt>stable</tt> distribution

<p>Package entries for the <tt>stable</tt> distribution, &stabledebian;, 
are recorded into the <file>stable</file> (symlink to
<file>&stablecodenamedir;/</file>) directory:
<list>
  <item><file>stable/main/</file>:
  This directory contains the package versions belonging to the most
  recent official release of the &debian; system.

  <p>These packages are all free; that is, they all comply with the
  <url name="Debian Free Software Guidelines"
  id="&social-contract;#guidelines"> (DFSG)
  (also available as
  <file>&f-social-contract;</file> installed by 
  <package>&p-social-contract;</package>).

  <item><file>stable/non-free/</file>:
  This directory contains packages that fail to qualify as free
  according to the DFSG.
  <p>
  For example, some packages have licenses that prohibit commercial
  distribution. Others can be redistributed but are shareware.

  <item><file>stable/contrib/</file>: Each package in this directory
  is itself DFSG-free but somehow Depends on a package that is
  <strong>not</strong> DFSG-free.
</list>
Now, in addition to the above locations, nowadays physical packages are
located under the <file>pool</file> directory (<ref id="pools">).  

<p>The current status of <tt>stable</tt> distribution bugs is reported 
on the <url id="&stable-problems;" name="Stable Problems"> web page.


<sect1 id="testing">The <tt>testing</tt> distribution

<p>Package entries for the <tt>testing</tt> distribution, &testingdebian;, 
are recorded into the <file>testing</file> (symlink to <file>&testingcodenamedir;/</file>) directory after they 
have undergone some degree of testing in <tt>unstable</tt>.  
Nowadays physical packages are
located under the <file>pool</file> directory (<ref id="pools">).  
There are also
<file>main</file>, <file>contrib</file>, and <file>non-free</file> subdirectories in
<file>testing/</file>, which serve the same functions as in <file>stable/</file>.

<p>These packages must be in sync on all
architectures where they have been built and must be installable;
they must also have fewer release-critical bugs
than the versions currently in <tt>unstable</tt>. This way, we hope that
<tt>testing</tt> is
always close to being a release candidate.  More details of the testing 
mechanism are at <url id="&testing-notes;">.

<p>The latest status of the <tt>testing</tt> distribution is reported at these
sites:
<list compact>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="other bugs and bug-squashing party notes">
</list>

<sect1 id="unstable">The <tt>unstable</tt> distribution

<p>Package entries for the <tt>unstable</tt> distribution, always codenamed "Sid",
are recorded into the <file>unstable</file> (symlink to <file>sid/</file>) directory after
they are uploaded to the Debian archive and stay here until they are moved to
<file>testing/</file>.  Nowadays physical packages are located under the <file>pool</file> directory
(<ref id="pools">).  There are also <file>main</file>, <file>contrib</file>, and
<file>non-free</file> subdirectories in <file>unstable/</file>, which serve the same
functions as in <file>stable/</file>.

<p>The <tt>unstable</tt> distribution contains a snapshot of the most current 
development system. Users are welcome to use and test these packages, 
but are warned
about their state of readiness. The advantage of using the <tt>unstable</tt>
distribution is that you are always up-to-date with the latest in the &debian;
software project&mdash;but if it breaks, you get to keep both parts. :-)

<p>The current status of <tt>unstable</tt> distribution bugs is reported 
on the <url id="&unstable-problems;" name="Unstable Problems"> web page.

<!-- Above was enough
<sect1 id="sid">The Sid distribution

<p>Sid or <tt>unstable</tt> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <tt>testing</tt>,
in order to be released in <tt>stable</tt> later on. Sid contains packages
for both released and unreleased architectures.

<p>The name "Sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">The <tt>frozen</tt> distribution

<p>When the <tt>testing</tt> distribution is mature enough, it becomes frozen,
meaning no new code is accepted anymore, just bugfixes, if necessary.
Also, a new testing tree is created in the <file>dists</file> directory,
assigned a new codename. The frozen distribution passes through a few months
of testing, with intermittent updates and deep freezes called "test cycles".

<p>We keep a record of bugs in the frozen distribution that can delay a
package from being released or bugs that can hold back the whole release.
Once that bug count lowers to maximum acceptable values, the frozen
distribution becomes <tt>stable</tt>, it is released, and the previous stable
distribution becomes obsolete (and moves to the archive).

<sect1 id="codenames">Debian distribution codenames

<p>Physical directory names in the <file>dists</file> directory, such as
<file>&stablecodenamedir;/</file> and <file>&testingcodenamedir;/</file>, are just "codenames". When a &debian;
distribution is in the development stage, it has no version number, but a
codename instead. The purpose of these codenames is to make the mirroring of
the &debian; distributions easier. (If <file>unstable</file> would be a
real directory and it's name would suddenly change to <file>stable/</file>,
a lot of stuff would have to be needlessly downloaded again).

<p>Currently, <file>stable/</file> is a symbolic link to <file>&stablecodenamedir;/</file>, 
and <file>testing/</file> is a symbolic link to
<file>&testingcodenamedir;/</file>. This means that <tt>&stablecodename;</tt> is the current stable
distribution and <tt>&testingcodename;</tt> is the current testing distribution.

<p><file>unstable/</file> is a permanent symbolic link to <file>sid/</file>, as
Sid is always the unstable distribution. <!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">Codenames used in the past

<p>Codenames that have already been used are: 
"Buzz" for release 1.1, 
"Rex" for release 1.2, 
"Bo" for releases 1.3.x,
"Hamm" for release 2.0, 
"Slink" for release 2.1, 
"Potato" for release 2.2,
"Woody" for release 3.0, and
"Sarge" for release 3.1.


<sect1 id="sourceforcodenames">The source for codenames

<p>So far they have been characters taken from the movie <em>Toy Story</em> by
Pixar.
<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) was the spaceman,
  <item><strong>Rex</strong> was the tyrannosaurus,
  <item><strong>Bo</strong> (Bo Peep) was the girl who took care of the sheep,
  <item><strong>Hamm</strong> was the piggy bank,
  <item><strong>Slink</strong> (Slinky Dog) was the toy dog,
  <item><strong>Potato</strong> was, of course, Mr. Potato Head,
  <item><strong>Woody</strong> was the cowboy,
  <item><strong>Sarge</strong> was a leader of the Green Plastic Army Men,
  <item><strong>Etch</strong> (Etch-a-Sketch) was the blackboard,
  <item><strong>Sid</strong> was a boy next door who destroyed toys.
</list>
<!--
  more info in http://www.pixar.com/featurefilms/ts/index.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">The <file>pool</file> directory

<p>Historically, packages were kept in the subdirectory of <file>dists</file>
corresponding to the distribution that contained them. This turned out to
cause various problems, such as large bandwidth consumption on mirrors when
major changes were made.

<p>Packages are now kept in a large "pool", structured according to the name
of the source package. To make this manageable, the pool is subdivided by
section (<tt>main</tt>, <tt>contrib</tt>, and <tt>non-free</tt>) and by the
first letter of the source package name. These directories contain several
files: the binary packages for each architecture, and the source packages from
which the binary packages were generated.

<p>You can find out where each package is placed by executing a command like
<tt>apt-cache showsrc <var>mypackagename</var></tt> and looking at the
"Directory:" line. For example, the <package>apache</package> packages are
stored in <file>pool/main/a/apache/</file>. Since there are so many
<tt>lib*</tt> packages, these are treated specially: for instance,
<package>libpaper</package> packages are stored in
<file>pool/main/libp/libpaper/</file>.

<p>The <file>dists</file> directories are still used for the index files used by
programs like <prgn>apt</prgn>.

<p>Normally, you won't have to worry about any of this, as new <prgn>apt</prgn> and
probably older <prgn>dpkg-ftp</prgn> will handle it
seamlessly. If you want more information, see the
<url id="&pool-faq;" name="RFC: implementation of package pools">.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Historical notes about Sid

<p>When the present-day Sid did not exist, the <!--FTP removed --> 
Debian archive site organization had one major flaw: there was an assumption
that when an architecture was created in the current <file>unstable/</file>, it
would be released when that distribution became the new <tt>stable</tt>. For
many architectures that wasn't the case, with the result that those
directories had to be moved at release time. This was impractical because the
move would chew up lots of bandwidth.

<p>The archive administrators worked around this problem for several years by
placing binaries for unreleased architectures in a special directory called
<file>sid</file>. When an architecture was released the first time there
was a link from the current <file>stable/</file> to <file>sid/</file>,
and from then on they were created inside the <file>unstable/</file>
tree as usual. This layout was somewhat confusing to users.

<p>With the advent of package pools (see <ref id="pools">) during the 
Woody distribution development, binary packages
began to be stored in a canonical location in the pool, regardless of the
distribution, so releasing a distribution no longer causes large bandwidth
consumption on the mirrors (there is, however, a lot of gradual bandwidth
consumption throughout the development process).

<sect1 id="incoming">Uploaded packages in <file>incoming/</file>
<p>
Uploaded packages are first located at <url id="&incoming;"> 
after being checked to insure that they really come from a Debian
developer (and are put in the <file>DELAYED</file> subdirectory in the case of
a Non-Maintainer Upload (NMU)).  Once a day, they are moved out of
<file>incoming/</file> to <file>unstable/</file>.
<p>
In an emergency, you may want to install packages from <file>incoming/</file>
before they reach <file>unstable/</file>.  
</sect1>

<sect1 id="snapshot">Retrieving an older package
<p>
While the most recent Debian distributions are kept under the <file>debian</file>
directory on each <url id="&mirror-site;" name="Debian mirror site">, 
archives for older Debian distributions such as Slink are kept 
on <url id="&archivehome;"> or under the <file>debian-archive</file> 
directory on each Debian mirror site.
<p>
Older <tt>testing</tt> and <tt>unstable</tt> packages can be located at
<url id="&snapshothome;">.

</sect1>

<sect1 id="archsections">Architecture sections
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>Within each of the major directory trees (<file>dists/stable/main</file>,
<file>dists/stable/contrib</file>, <file>dists/stable/non-free</file>, 
<file>dists/unstable/main</file>, etc.), the binary package entries reside in
subdirectories whose names indicate the chip architecture for which they
were compiled.

<list>
  <item><file>binary-all/</file>, for packages which are architecture-independent.
    These include, for example, Perl scripts, or pure documentation.
  <item><file>binary-<var>platform</var>/</file>, for packages which execute on a particular
  binary platform.
  <!-- Yes I simplified this -->
</list>

<p>Please note that the actual binary packages
no longer reside in these directories, but in the top-level
<file>pool</file> directory. The index files (<file>Packages</file> and
<file>Packages.gz</file>) have been kept, though, for backwards compatibility.

<p>For the actual binary architectures supported, see the Release Notes 
for each distribution.  They can be located at the Release Notes sites
for <url id="&stable-release;" name="stable"> and
<url id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">The source code

<p>Source code is included for everything in the Debian system. Moreover,
the license terms of most programs in the system <strong>require</strong> that
source code be distributed along with the programs, or that an offer to
provide the source code accompany the programs.

<p>Normally the source code is distributed in the <file>source</file> directories,
which are parallel to all the architecture-specific binary directories, or
more recently in the <file>pool</file> directory (see <ref id="pools">). To
retrieve the source code without having to be familiar with the structure of
the <!--FTP--> Debian archive, try a command like <tt>apt-get source 
<var>mypackagename</var></tt>.

<p>Some packages, notably <package>pine</package>, are only available in
a source package due to their licensing limitations.  (Recently the
<package>pine-tracker</package> package has been provided to facilitate Pine
installation.) The procedures described in <ref id="port"> and <ref
id="packaging"> provide ways to build a package manually.

<p>Source code may or may not be available for packages in the
<file>contrib</file> and <file>non-free</file> directories, which are not
formally part of the Debian system.

<sect id="pkg-basics">The Debian package management system

<sect1 id="package-basics">Overview of Debian packages

<p>Packages generally contain all of the files necessary to implement
a set of related commands or features.  There are two types of Debian
packages:
<list>
  <item><strong>Binary packages</strong>, which contain executables, configuration
  files, man/info pages, copyright information, and other documentation.
  These packages are distributed in a Debian-specific archive format
  (see <ref id="deb-format">); they are usually distinguished by having
  a <tt>.deb</tt> file extension. Binary packages can be unpacked using the Debian
  utility <prgn>dpkg</prgn>; details are given in its manual page.
  
  <item><strong>Source packages</strong>, which consist of a <tt>.dsc</tt> file
  describing the source package (including the names of the following
  files), a <tt>.orig.tar.gz</tt> file that contains the original
  unmodified source in gzip-compressed tar format, and usually a
  <tt>.diff.gz</tt> file that contains the Debian-specific changes to the
  original source.  The utility <prgn>dpkg-source</prgn> packs and unpacks
  Debian source archives; details are provided in its manual page.
</list>

<p>Installation of software by the package system uses "dependencies" which
are declared by the package maintainers.  These dependencies are
documented in the <file>control</file> file associated with each package.
For example, the package containing the GNU C compiler (<package>gcc</package>)
Depends on the package <package>binutils</package> which includes the 
linker and assembler. If a user attempts to install <package>gcc</package> 
without having first installed <package>binutils</package>, the package 
management system (dpkg) will print an error message that it also needs 
<package>binutils</package>, and stop installing <package>gcc</package>. 
(However, this facility can be overridden by the insistent
user; see <manref name="dpkg" section="8">.)  For additional details, see
<ref id="depends"> below.

<p>Debian's packaging tools can be used to:
<list>
  <item>manipulate and manage packages or parts of packages,
  <item>aid the user in the splitting of packages that must be transmitted
    through a limited-size medium such as floppy disks,
  <item>aid developers in the construction of package archives, and
  <item>aid users in the installation of packages which reside on a remote
    <!--FTP-->Debian archive site.
</list>

<sect1 id="deb-format">Debian <!--binary--> package format

<p>A Debian "package", or a Debian archive file, contains the executable
files, libraries, and documentation associated with a particular program
suite or set of related programs.  Normally, a Debian archive file has
a filename that ends in <tt>.deb</tt>.
<footnote>
<!-- Below added by Osamu based on a message posted by Colin Watson -->
<p>The <prgn>debian-installer</prgn> project introduced package filenames
that ends in <tt>.udeb</tt>.  In short, it is a micro-<tt>.deb</tt>
format which doesn't need to follow Debian policy exactly, lacks
contents such as documentation and is meant to be used only by the
<prgn>debian-installer</prgn>, the new Debian installer developed
initially for the Sarge release.  The file format of <tt>.deb</tt> and
<tt>.udeb</tt> are identical.  The <prgn>udpkg</prgn> program used to handle
<tt>.udeb</tt> packages has more limited capability than standard
<prgn>dpkg</prgn> and supports fewer package relationships.  The
difference in name is because the Debian archive maintainers weren't
happy with <tt>.deb</tt>s in the archive that didn't follow policy, so a
different name was chosen to accentuate this and to make it less likely
that people would unwittingly install them on real systems. <tt>.udeb</tt>s
are used in an initial ramdisk during the base install only to create a
very restricted Debian system.
</footnote>

<p>The internals of this Debian binary package format are described in the
<manref name="deb" section="5"> manual page. Because this internal format is
subject to change (between major releases of &debian;), always use
<manref name="dpkg-deb" section="1"> for manipulating <tt>.deb</tt>
files.

<!-- Below added by Osamu Not sure but should be right -->

<p>Through at least the Sarge distribution, all Debian archive files
have been manipulable by the standard Unix commands <prgn>ar</prgn> and
<prgn>tar</prgn>, even when <prgn>dpkg</prgn> commands are not available.


<sect1 id="pkgname">Naming conventions for Debian package filenames
<!--
Why are Debian package filenames so long? 
-->
<p>The Debian <!--binary--> package filenames conform to the following convention:
<example>
<var>foo</var>_<var>ver</var>-<var>rev</var>_<var>arch</var>.deb
</example>
where, usually, <var>foo</var> is the package name,
<var>ver</var> is the upstream version number,
<var>rev</var> is the Debian revision number, and
<var>arch</var> is the target architecture.
Files are easily renamed, of course.
You can find out what package is really contained in
any given file of name <var>filename</var> by running
the following command:
<example>dpkg --info <var>filename</var></example>

<p>The Debian revision number is specified by the Debian developer
or by whoever built the package.
A change in revision number usually indicates that some aspect
of the packaging has changed.

<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Preservation of local configuration
<!--
What is a Debian conffile
-->
<p>Files that are intended to be changeable by the local
administrator are kept in <file>/etc/</file>.
&debian; policy dictates that all changes to locally configurable
files be preserved across package upgrades.
<p>
If a default version of a locally configurable file is shipped
in the package itself then the file is listed as a "conffile".
The package management system does not upgrade conffiles
that have been changed by the administrator since the package
was last installed without getting the administrator's permission.
On the other hand, if the conffile has not been changed by the
administrator then the conffile will be upgraded along with the
rest of the package.
This is almost always desirable and so
it is advantageous to minimize changes to conffiles.

<p>To list the conffiles belonging to a package
run the following command:
<example>
dpkg --status <var>package</var>
</example>
The list follows the "Conffiles:" line.

<p>
For more information about conffiles you can read the
section of the Debian Policy Manual entitled
"Configuration files".
(See <ref id="references">).

<sect1 id="maintscripts">Debian maintenance scripts
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian maintenance scripts
are executable scripts which are automatically run before
or after a package is installed. Along with a file named <file>control</file>,
all of these files are part of the "control" section of a Debian archive file.

<p>The individual files are:
<taglist>
<tag>preinst
  <item>This script executes before its package is unpacked from its
  Debian archive (<tt>.deb</tt>) file. Many "preinst" scripts stop services for
  packages which are being upgraded until their installation or upgrade is
  completed (following the successful execution of the "postinst" script).

<tag>postinst
  <item>This script typically completes any required configuration of a
  package once it has been unpacked from its Debian
  archive (<tt>.deb</tt>) file. Often, "postinst" scripts ask the user for input,
  and/or warn the user that if he accepts default values, he should remember
  to go back and reconfigure the package as the situation warrants.
  Many "postinst" scripts then execute any commands necessary to start or
  restart a service once a new package has been installed or upgraded.

<tag>prerm
  <item>This script typically stops any daemons which are associated with
  a package.  It is executed before the removal of files associated with
  the package.

<tag>postrm
  <item>This script typically modifies links or other files associated with
  a package, and/or removes files created by it. (Also see
  <ref id="virtual">.)
</taglist>

<p>Currently all of the control files can be found in the directory
<file>/var/lib/dpkg/info</file>. The files relevant to package <tt>foo</tt>
begin with the name "foo" and have file extensions of "preinst", "postinst",
etc., as appropriate.  The file <file>foo.list</file> in that directory
lists all of the files that were installed with the package <tt>foo</tt>.
(Note that the location of these files is a <prgn>dpkg</prgn> internal, and may be
subject to change.)

<sect1 id="priority">Package priorities
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Each Debian package is assigned a <strong>priority</strong> by the distribution
maintainers, as an aid to the package management system.  The priorities are:

<list>
  <item><strong>Required</strong> packages are necessary for the proper
    functioning of the system.
    <p>This includes all tools that are necessary to repair system defects.
    You must not remove these packages or your system may become totally
    broken and you may not even be able to use <prgn>dpkg</prgn> to 
    restore things.  Systems with only the Required packages are probably
    inadequate for most purposes, but they do have enough functionality to
    allow the sysadmin to boot and install more software.
  <item><strong>Important</strong> packages should be found on any Unix-like
    system.
    <p>Other packages without which the system will not run well or be usable 
    will carry this priority. This does <strong>not</strong> include Emacs or
    X11 or TeX or any other large applications. These packages only constitute
    the bare infrastructure.
  <item><strong>Standard</strong> packages are standard on any Linux system,
    including a reasonably small but not too limited character-mode system.
    <p>This is what will install by default if users do not select anything
    else. "Standard" does not include many large applications, but it does
    include Emacs (this is more a piece of infrastructure than an application)
    and a reasonable subset of TeX and LaTeX (if this turns out to be possible
    without X).
  <item><strong>Optional</strong> packages include all those that you might
    reasonably want to install even if you are unfamiliar with them, and if
    you don't have specialized requirements.
    <p>This includes X11, a full TeX distribution, and lots of applications.
  <item><strong>Extra</strong> packages either conflict with others
    with higher priorities, have little use to users who are unfamiliar
    with them, or have specialized requirements that make them
    unsuitable for "Optional".
</list>
<p>Please note the differences among "Priority: required", "Section:
base" and "Essential: yes" in the package description.  "Section: base"
means that this package is installed before everything else on a new
system. Most of the packages in "Section: base" have the "Priority:
required" or at least "Priority: important", and many of them are
tagged with "Essential: yes".  "Essential: yes" means that this package
requires to specify an extra force option to the package management
system such as <prgn>dpkg</prgn> when removing from the system.  For
example, <package>libc6</package>, <package>mawk</package>, and
<package>makedev</package> are "Priority: required" and "Section: base"
but are not "Essential: yes".

<sect1 id="virtual">Virtual packages

<p>A virtual package is a generic name that applies to any one of a group
of packages, all of which provide similar basic functionality.
For example, both the <prgn>tin</prgn> and <prgn>trn</prgn> programs
are news readers, and either
one should therefore satisfy the need of a program that requires a news
reader on the system in order to be useful. They are therefore both
said to Provide the "virtual package" called <package>news-reader</package>.

<p>Similarly, many packages such as <package>exim</package>, 
<package>exim4</package>, <package>sendmail</package>, and 
<package>postfix</package>, provide the
functionality of a mail transport agent.  They are therefore said to
Provide the virtual package <package>mail-transport-agent</package>.
If either one is installed, then any program that Depends on the
installation of a mail transport agent will be satisfied by
the existence of this virtual package.

<p>Debian has a mechanism such that, if more than one package which
Provides the same virtual package is installed on a system, the system
administrator can set one as the preferred package. The relevant command
is <prgn>update-alternatives</prgn>, and is described further in
<ref id="alternatives">.

<sect1 id="depends">Package dependencies
<p>The Debian packaging system handles dependency declarations
which are used to express the fact that one package requires another
package to be installed in order to work or in order to work better.
<list>
  <item>Package A <strong>Depends</strong> on Package B if B absolutely must be
  installed in order to use A.  In some cases, A Depends not only on B, but on
  a specific version of B.  In this case, the version dependency is usually a
  lower limit, in the sense that A Depends on any version of B more recent
  than some specified version.

  <item>Package A <strong>Recommends</strong> Package B if the package maintainer
    judges that most users would not want A without also having the
    functionality provided by B.

  <item>Package A <strong>Suggests</strong> Package B if B contains files that
    are related to and enhance the functionality of A.
    The same relationship is expressed by declaring that
    Package B <strong>Enhances</strong> Package A.

  <item>Package A <strong>Conflicts</strong> with Package B when A will not
    operate properly if B is installed on the system.
    "Conflicts" status is often combined with "Replaces".

  <item>Package A <strong>Replaces</strong> Package B when files installed
    by B are removed or overwritten by files in A.

  <item>Package A <strong>Provides</strong> Package B when all of the files and
    functionality of B are incorporated into A.
</list>

<p>More detailed information on the use of each these terms can be found
in the <em>Packaging Manual</em> and the <em>Policy Manual</em>.

<p>Note that <prgn>aptitude</prgn> and <prgn>dselect</prgn> have more fine-grained 
control over packages specified by <strong>Recommends</strong> and 
<strong>Suggests</strong> than <prgn>apt-get</prgn>, which simply pulls all 
the packages specified by <strong>Depends</strong> and leaves all
the packages specified by <strong>Recommends</strong> and <strong>Suggests</strong>.  Both programs in modern 
form use APT as their back end.

<sect1 id="pre-depends">The meaning of "Pre-Depends"

<p><prgn>dpkg</prgn> always configures a package upon which another
package Depends before it configures the package that Depends on it.
However, <prgn>dpkg</prgn> normally unpacks archive files in arbitrary
order, independently of dependencies.
(Unpacking consists of extracting files from the archive file
and putting them in the right place.)
If, however, a package <strong>Pre-Depends</strong> on another then
the other package is unpacked and configured before the one that
Pre-Depends is even unpacked.

<footnote>
This mechanism was provided in order to support safe upgrading of systems from
<tt>a.out</tt> format to ELF format, where the <strong>order</strong> in which
packages were unpacked was critical.
</footnote>

The use of this dependency is kept to a minimum.

<sect1 id="pkgstatus">Package status
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Package status can be "unknown", "install", "remove", "purge", or 
"hold".
These "want" flags indicate what the user wanted to do with a package (either
by making choices in the "Select" section of <prgn>dselect</prgn>, or by
directly invoking <prgn>dpkg</prgn>).

<p>Their meanings are:
<list compact>
  <item><strong>unknown</strong>  - the user has never indicated whether he
                wants the package.
  <item><strong>install</strong>  - the user wants the package installed or
                upgraded.
  <item><strong>remove</strong>   - the user wants the package removed, but
                does not want to remove any existing configuration files.
  <item><strong>purge</strong>    - the user wants the package to be
                removed completely, including its configuration files.
  <item><strong>hold</strong>     - the user wants this package not to be
                processed, i.e., he wants to keep the current version with the current
                status, whatever that is.
</list>

<sect1 id="puttingonhold">Holding back packages from an upgrade
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>There are two mechanisms for holding back packages from an upgrade, 
through <prgn>dpkg</prgn>, or, beginning with Woody, through APT.

<p>With <prgn>dpkg</prgn>, first export the list of package selections:
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
Then edit the resulting file <file><var>selections.txt</var></file>, changing the line
containing the package you wish to hold, e.g. <package>libc6</package>, from this:
<example>
libc6                       install
</example>
to this:
<example>
libc6                       hold
</example>
Save the file, and reload it into <prgn>dpkg</prgn> database with:
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
Or, if you know the package name to hold, simply run:
<example>
echo libc6 hold | dpkg --set-selections
</example>
This procedure holds packages at the install process of each package file.

<p>The same effect can be obtained through <prgn>dselect</prgn>. Simply enter
the [S]elect screen, find the package you wish to hold in its present state,
and press the `=' key (or `H'). The changes will take effect immediately after
you exit the [S]elect screen.

<p>The APT system in the Woody distribution has a new alternative mechanism
for holding packages during the archive retrieval process using
<tt>Pin-Priority</tt>.  See the manual page <manref name="apt_preferences"
section="5">, along with <url id="&apt-howto;"> or the
<package>&p-apt-howto;</package> package.

<sect1 id="sourcepkgs">Source packages

<p>
Source packages are distributed in a directory called <file>source</file>, and
you can either download them manually, or use
<example>
apt-get source <var>foo</var>
</example>
to fetch them (see the <manref name="apt-get" section="8"> manual page on how
to set up APT for doing that).


<sect1 id="sourcebuild">Building binary packages from a source package

<p>For a package <tt><var>foo</var></tt>, you will need all of <file><var>foo_*</var>.dsc</file>,
<file><var>foo_*</var>.tar.gz</file>, and <file><var>foo_*.diff</var>.gz</file> to compile the source
(note: there is no <tt>.diff.gz</tt> for a Debian native package).

<p>Once you have them, if you have the <package>dpkg-dev</package> 
package installed, the command
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
will extract the package into a directory called 
<tt><var>foo-version</var></tt>.

<p>Issue the following command to build the binary package:
<example>
$ cd foo-version
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
Then,
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
to install the newly built package. See <ref id="port">.

<!-- Woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Creating new Debian packages

<p>For detailed information on creating new packages, read the <em>New
Maintainers' Guide</em>, available in the <package>maint-guide</package> 
package, or at <url
id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Upgrading a Debian system

<p>One of Debian's goals is to provide a smooth, secure and reliable
upgrade process.  The packaging system alerts the administrator
to important changes and sometimes asks the administrator to take
decisions.
You should also read the Release Notes;
it is shipped on all Debian CDs and is available on the WWW at
<url id="&stable-release;"> or <url id="&testing-release;">.

<p>
A practical guide to upgrades is provided in <ref id="package">.
This section merely provides an outline, beginning with the
packaging tools.

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>This is the main program for manipulating package files; read
<manref name="dpkg" section="8"> for a full description.
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> comes with several primitive supplemental programs.

<list>
<item><prgn>dpkg-deb</prgn>: Manipulate <tt>.deb</tt> files. 
 <manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>: An older package file retrieval command. 
 <manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>: An older package file retrieval command. 
 <manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>: Splits a large package into smaller files. 
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> and <prgn>dpkg-mountable</prgn> have been superseded
by the introduction of the APT system.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT (the Advanced Packaging Tool) is an advanced interface to the Debian
packaging system consisting of several programs whose names typically begin
with "apt-". 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn>, and <prgn>apt-cdrom</prgn> 
are the command-line tools for handling packages.  These also function 
as the user's "back end" programs to other tools, such as 
<prgn>dselect</prgn> and <prgn>aptitude</prgn>.  

Currently  <prgn>aptitude</prgn> is the preferred tool for system maintenance.

<p>For more information, install packages <package>apt</package> and <package>aptitude</package> and read
<manref name="aptitude" section="8">,
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, and
<manref name="apt_preferences" section="5">.

<p>An alternative source of information is the
<url id="&apt-howto;" name="APT HOWTO">.
This can be installed by <package>apt-howto</package> at
<file>&f-apt-howto;</file>.

<p><tt>apt-get upgrade</tt> and <tt>apt-get dist-upgrade</tt>
pull only the packages listed under "Depends:" and overlook all 
the packages listed under "Recommends:" and "Suggests:".
To avoid this, use <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>This program is a menu-driven user interface to the Debian package management
system. It is particularly useful for first-time installations and
large-scale upgrades.  See <ref id="dselect">.

<p>For more information, read
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single-user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <prgn>start-stop-daemon</prgn> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Upgrading a running system

<p>The kernel (filesystem) in &debian; systems supports replacing files even
while they're being used.
When packages are upgraded any services provided by those packages
are restarted if they are configured to run in the current runlevel.
The Debian system does not require 
use of the single-user mode to upgrade a running system.

<sect1 id="savedebs">Downloaded and cached <tt>.deb</tt> archive files

<p>If you have manually downloaded package files to your disk (which is not
absolutely necessary, see above for the description of <prgn>dpkg-ftp</prgn>
or APT), then after you have installed the packages, you can remove the
<tt>.deb</tt> files from your system.

<p>If APT is used, these files are cached in the
<file>/var/cache/apt/archives</file> directory.  You may erase them after
installation (<tt>apt-get clean</tt>) or copy them to another machine's
<file>/var/cache/apt/archives</file> directory to save downloading during
subsequent installations.

<sect1 id="keepingalog">Record-keeping for upgrades

<p><prgn>dpkg</prgn> keeps a record of the packages that have been unpacked,
configured, removed, and/or purged, but does not (currently) keep a log
of terminal activity that occurred while a package was being so manipulated.

<p>The simplest way to work around this is to run your
<prgn>dpkg</prgn>, <prgn>dselect</prgn>, <prgn>apt-get</prgn>, etc.,
sessions within the <manref name="script" section="1"> program.

<sect id="boot">The Debian boot process

<sect1 id="init">The <prgn>init</prgn> program

<p>Like all Unixes, Debian boots up by executing the program <prgn>init</prgn>.
The configuration file for <prgn>init</prgn> (which is <file>/etc/inittab</file>)
specifies that the first script to be executed should be
<file>/etc/init.d/rcS</file>.
<p>
What happens next depends on whether the <package>sysv-rc</package>
package or the <package>file-rc</package> package is installed.
The following assumes that the <package>sysv-rc</package> package
is installed.  (<package>file-rc</package> contains its own
<file>/etc/init.d/rcS</file> script and uses a file instead of
symlinks in rc directories to control which services are started
in which runlevels.)
<p>
The <file>/etc/init.d/rcS</file> file from the <package>sysv-rc</package>
package runs all of the scripts in <file>/etc/rcS.d/</file> in order
to perform initialization such as checking and mounting file
systems, loading modules, starting the network services,
setting the clock, and so on.
Then, for compatibility, it also runs all the files
(except those with a `.' in the filename)
in <file>/etc/rc.boot/</file>.
The latter directory is reserved for system administrator use,
and using it is deprecated.
See <ref id="init-hints"> and
<url id="&sysvinit;" name="System run levels and init.d scripts">
in the Debian Policy Manual for more info.
<p>
Debian does not use a BSD-style <tt>rc.local</tt> directory.

<sect1 id="runlevels">Runlevels

<p>After completing the boot process, <prgn>init</prgn> starts all
services that are configured to run in the default runlevel.
The default runlevel is given by the entry for <tt>id</tt> in
<file>/etc/inittab</file>.
Debian ships with <tt>id=2</tt>.
<p>
Debian uses the following runlevels:
<list compact>
  <item>1 (single-user mode),
  <item>2 through 5 (multiuser modes), and
  <item>0 (halt the system),
  <item>6 (reboot the system).
</list>
Runlevels 7, 8, and 9 can also be used but their rc directories are
not populated when packages are installed.
<p>
Switch runlevels using the <prgn>telinit</prgn> command.
<p>
When entering a runlevel all scripts in
<file>/etc/rc<var>runlevel</var>.d/</file>
are executed.
The first letter in the name of the script determines the
<strong>way</strong> in which the script is run:
scripts whose names begin with <tt>K</tt> are run with the argument
<tt>stop</tt>.
Scripts beginning with <tt>S</tt> are run with the argument
<tt>start</tt>.
The scripts are run in the alphabetical order of their names;
thus "stop" scripts are run before "start" scripts and the
two-digit numbers following the <tt>K</tt> or <tt>S</tt> determine
the order in which the scripts are run.
<p>
The scripts in <file>/etc/rc<var>runlevel</var>.d</file>
are in fact just symbolic links back to scripts in
<file>/etc/init.d/</file>.
These scripts also accept "restart" and "force-reload" as argument;
the latter methods can be used after a system has been booted
in order to restart services
or force them to reload their configuration files.

<p>For example:
<example>
# /etc/init.d/exim4 force-reload
</example>

<sect1 id="custombootscripts">Customizing runlevels
<p>
Customizing runlevels is an advanced system administration task.
The following advice holds for most services.
<p>
To enable service <var>service</var> in runlevel <var>R</var>
create the symbolic link
<file>/etc/rc<var>R</var>.d/S<var>xy</var><var>service</var></file>
with target
<file>../init.d/<var>service</var></file>.
The sequence number <var>xy</var> should be the sequence number
that was assigned to the service when the package was installed.
<p>
To disable the service, rename the symbolic link so that its
name begins with a <tt>K</tt> instead of with an <tt>S</tt>
and its sequence number is 100 minus <var>xy</var>.
<p>
It is convenient to use a runlevel editor such as
<prgn>sysv-rc-conf</prgn> or <prgn>ksysv</prgn>
for these purposes.
<p>
It is possible to delete the <tt>S</tt> symlink for a service
in a particular runlevel directory
instead of renaming it.
This does not disable the service
but leaves it in a "floating" state
as far as the <package>sysv-rc</package> init system is concerned:
on runlevel changes the service will be neither started nor stopped
but will be left as it was, whether running or not running.
Note, however, that a service left in such a floating state
will be started if its package is upgraded whether or not
it was running before the upgrade.
This is a known shortcoming of the current Debian system.
Note also that you should retain a service's <tt>K</tt> symlinks
in runlevels 0 and 6.
If you delete all the symlinks for a service
then on upgrade the service's package will restore the symlinks
to their factory default state.
<p>
It is <strong>not</strong> advisable to make any changes to symlinks
in <file>/etc/rcS.d/</file>.

<sect id="diverse">Supporting diversity
<p>
Debian offers several avenues to accommodate any wishes of the system 
administrator without breaking the system. 
<list>
<item><prgn>dpkg-divert</prgn>, see <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, see <ref id="equivs">.
<item><prgn>update-alternative</prgn>, see <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> can accommodate many boot loaders. 
      See <manref name="make-kpkg" section="1"> and <ref id="kernel-compile">.
</list>
Any files under <file>/usr/local/</file> belong to the system administrator 
and &debian; will not touch them. Most files under <file>/etc/</file> are 
<!-- mtab is an exception -->
<tt>conffiles</tt> and &debian; will not overwrite them upon upgrade unless 
the system administrator requests so explicitly.

<sect id="i18n">Internationalization
<p>
The &debian; system is internationalized and provides support for character
display and entry in many languages, both within the console and under X. Many
documents, manual pages, and system messages have been translated into a
growing number of languages. During installation, Debian prompts the user to
choose an installation language (and sometimes a local language variant).
<p>
If your installed system does not support all the language features you need,
or if you need to change languages or install a different keyboard to support
your language, see <ref id="l10n">.

<sect id="kernel-details">Debian and the kernel
<p>
See <ref id="kernel">.

<sect1 id="non-debian-kernel">Compiling a kernel from non-Debian source

<p><!--Yes.  But you have-->
One has to understand the Debian policy with respect to headers.

<p>The Debian C libraries are built with the most recent <strong>stable</strong>
releases of the <strong>kernel</strong> headers.

<p>For example, the Debian-1.2 release used version 5.4.13 of the headers.
This practice contrasts with the Linux kernel source packages distributed
at all Linux FTP archive sites, which use even more recent versions of
the headers.  The kernel headers distributed with the kernel source are
located in <file>/usr/include/linux/include/</file>.

<p>If you need to compile a program with kernel headers that are newer
than those provided by <package>libc6-dev</package>, then you must add
<tt>-I/usr/src/linux/include/</tt> to your command line when compiling.
This came up at one point, for example, with the packaging of the
automounter daemon (<package>amd</package>).  When new kernels changed some
internals dealing with NFS, <prgn>amd</prgn> needed to know about them.
This required the inclusion of the latest kernel headers.

<sect1 id="customkernel">Tools to build custom kernels

<p>Users who wish to (or must) build a custom kernel are encouraged to
download the package <package>kernel-package</package>.  This package contains
the script to build the kernel package, and provides the capability to
create a Debian kernel-image package just by running the command
<example>
# make-kpkg kernel_image
</example>
in the top-level kernel source directory.
Help is available by executing the command
<example>
# make-kpkg --help
</example>
and through the manual page <manref name="make-kpkg" section="1">
and <ref id="kernel">.

<p>Users must separately download the source code for the most recent
kernel (or the kernel of their choice) from their favorite Linux archive
site, unless a kernel-source-<var>version</var> package is available 
(where <var>version</var> stands for the kernel version).  The Debian
<file>initrd</file> boot script requires a special kernel patch called
<prgn>initrd</prgn>; see <url id="&bug-initrd;">.

<p>Detailed instructions for using the <package>kernel-package</package> package
are given in the file <file>/usr/share/doc/kernel-package/README.gz</file>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="modules">Special provisions for dealing with modules

<p>Debian's <package>modconf</package> package provides a shell script
(<file>/usr/sbin/modconf</file>) which can be used to customize the
configuration of modules.  This script presents a menu-based interface,
prompting the user for particulars on the loadable device drivers in his
system.  The responses are used to customize the file
<file>/etc/modules.conf</file> (which lists aliases, and other arguments that
must be used in conjunction with various modules) through files in
<file>/etc/modutils/</file>, and <file>/etc/modules</file> (which lists the
modules that must be loaded at boot time).

<p>Like the (new) <file>Configure.help</file> files that are now 
available to support the construction of custom kernels, the 
<package>modconf</package> package comes with a series of help files (in 
<file>/usr/share/modconf/</file>) which provide detailed information on 
appropriate arguments for each of the modules.

<sect1 id="removeoldkernel">De-installing an old kernel package

<p>The <prgn>kernel-image-<var>NNN</var>.prerm</prgn> script checks to see whether
the kernel you are currently running is the same as the kernel you are trying
to de-install.  Therefore you can safely remove unwanted kernel image packages
using this command:

<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(Replace <var>NNN</var> with your kernel version and revision number, of
course.)
</sect>
