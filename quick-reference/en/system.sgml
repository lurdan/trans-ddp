<!-- CVS revision of this document "$Revision: 1.8 $"  -->
<chapt id="system">Debian fundamentals
<![%FIXME[<p>===Proof reading: NONE ===]]>

<!-- 

Mereged from 4 SGML files in FAQ Feburuary 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding nonenglish is added.

Mereged from another SGML files in FAQ Feburuary 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suits "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suite more for ptato and woody.
Unless slink is used, howmany people care dpkg-ftp :)

-->

<p>
This chapter explains information on Debian system from its fundamentals
for non-developers.  For authoritative information, see:
<list>
<item>Debian Policy Manual
<item>Debian Packaging Manual (potato)
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
</list>
listed under <ref id="references">.

<p>
If one is looking for an explanation focused on their solutions but without 
their details, jump directly to <ref id="package"> or other relevant chapters.
<p>
This chaper consists of documents taken from the "Debian FAQ" and heavily 
reorganized to get ordinaly Debian system administrator to get started.

<!-- 
"FTP archives" is now changed as simple "archives" since it can be reached 
throgh HTTP and other method
-->

<sect id="ftparchives">The Debian archives

<sect1 id="dirtree">Directory structures

<p>The software that has been packaged for &debian; is available in one
of several directory trees on each 
<url id="&mirror-site;" 
     name="Debian mirror site">
through FTP or HTTP.

<p>There are the following directories on each Debian mirror site
under <tt>/debian/</tt> directory:
<taglist>
  <tag><em>/dists/</em>:
    <item>This directory contains the "distributions", and this used 
    to be the canonical way to access the currently available 
    packages in Debian releases and pre-releases. Some old packages 
    and <tt>Packages.gz</tt> files are still in here.
  <tag><em>/pool/</em>:
    <item>New location to keep all phisical packages of Debian 
    releases and pre-releases.
  <tag><em>/tools/</em>:
    <item>DOS utilities for creating boot disks, partitioning
    your disk drive, compressing/decompressing files, and booting Linux.
  <tag><em>/doc/</em>:
    <item>The basic Debian documentation, such as the FAQ, the bug reporting
          system instructions, etc.
  <tag><em>/indices/</em>:
    <item>The Maintainers file and the override files.
  <tag><em>/project/</em>:
    <item>mostly developer-only materials, such as:
    <taglist>
      <tag><em>project/experimental/</em>:
        <item>This directory contains packages and tools which are still
        being developed, and are still in the alpha testing stage.  Users
        shouldn't be using packages from here, because they can be dangerous
        and harmful even for most experienced people.
      <tag><em>project/orphaned/</em>:
        <item>Packages that have been orphaned by their old maintainers, and
        withdrawn from the distribution.
    </taglist>
</taglist>

<sect1 id="dists">Debian distributions

<p>Normally there are three Debian distributions in <tt>dists</tt> 
directory. They are named as the "stable" distribution, the
"testing" distribution, and the "unstable" distribution. Sometimes there is
also a "frozen" distribution (see <ref id="frozen">).  Each distribution 
is defined as a symlink to the actual directory with a codename in the
<tt>dists</tt> directory.

<sect1 id="stable">The <tt>stable</tt> distribution

<p>Stable distribution is kept under <tt>stable</tt> directory:
<list>
  <item>stable/main/:
  This directory contains the packages which formally constitute the most
  recent release of the &debian; system.

  <p>These packages all comply with the <url name="Debian Free Software
  Guidelines" id="&social-contract;#guidelines">,
  and are all freely usable and distributable.

  <item>stable/non-free/:  This directory contains packages distribution of
  which is restricted in a way that requires that distributors take careful
  account of the specified copyright requirements.

  <p>For example, some packages have licenses which prohibit commercial
  distribution.  Others can be redistributed but are in fact shareware
  and not freeware.  The licenses of each of these packages must be
  studied, and possibly negotiated, before the packages are included in
  any redistribution (e.g., in a CD-ROM).

  <item>stable/contrib/: This directory contains packages which are
  DFSG-free and <em>freely distributable</em> themselves, but somehow depend
  on a package that is <em/not/ freely distributable and thus available only
  in the non-free section.
</list>
<p>Latest status of <tt>stable</tt> distribution is reported at:
<url id="&stable-problems;" name="stable problems">.

<sect1 id="testing">The <tt>testing</tt> distribution

<p>Package entries are recorded into the `testing' directory after they 
have undergone some degree of testing in unstable.  New packages are 
located under pool directory <ref id="pools">.  There are also main, 
contrib and non-free subdirectories in `testing', separated on the 
same criteria as in `stable'.

<p>They must be in sync on all
architectures where they have been built and mustn't have dependencies that
make them uninstallable; they also have to have fewer release-critical bugs
than the versions currently in testing. This way, we hope that `testing' is
always close to being a release candidate.  More details of testing 
mechanism at <url id="&testing-notes;">.

<p>Latest status of <tt>testing</tt> distribution is reported at:
<list>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="Release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="Base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="Bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="Other bugs and bug squashing party notes">
</list>

<sect1 id="unstable">The <tt>unstable</tt> distribution

<p>Package entries are recorded into the `unstable' directory after they 
are uploaded to the Debian archive and stay here until they are moved to
`testing' after some time.  New packages are 
located under pool directory <ref id="pools">.  
There are also main, contrib and non-free subdirectories in `unstable',
separated on the same criteria as in `stable'.

<p>The `unstable' distribution contains a snapshot of the most current 
development system. Users are welcome to use and test these packages, 
but are warned
about their state of readiness. The advantage of using the unstable
distribution is that you are always up-to-date with the latest in &debian;
software industry, but if it breaks: you get to keep both parts :-)

<p>Latest status of <tt>unstable</tt> distribution is reported at:
<url id="&unstable-problems;" name="unstable problems">.

<!-- Above was enough
<sect1 id="sid">The "sid" distribution

<p><em>sid</em> or <em>unstable</em> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <em>testing</em>,
in order to be released in <em>stable</em> later on. sid contains packages
for both released and unreleased architectures.

<p>The name "sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">The <tt>frozen</tt> distribution

<p>When the testing distribution is mature enough, it becomes frozen,
meaning no new code is accepted anymore, just bugfixes, if necessary.
Also, a new testing tree is created in the <tt>dists</tt> directory,
having a new codename. The frozen distribution passes through a few months
of testing, with intermittent updates and deep freezes called `test cycles'.

<p>We keep a record of bugs in the frozen distribution that can hold off a
package from being released or bugs that can hold back the whole release.
Once that bug count lowers to maximum acceptable values, the frozen
distribution becomes stable, it is released, and the previous stable
distribution becomes obsolete (and moves to the archive).

<sect1 id="codenames">Debian distribution codenames

<p>Physical directory names in <tt>dists</tt> directory, such as <tt>potato</tt>, 
and <tt>woody</tt>, are just "codenames". When a Debian distribution is in the
development stage, it has no version number but a codename. The purpose
of these codenames is to make the mirroring of the Debian
distributions easier (if a real directory like <tt>unstable</tt> suddenly changed
its name to <tt>stable</tt>, a lot of stuff would have to be needlessly
downloaded again).

<!-- XXX update for new distros -->
<p>Currently, <tt>stable</tt> is a symbolic link to <tt>potato</tt>
(i.e. &debian; &release;) and <tt>testing</tt> is a symbolic link to
<tt>woody</tt>. This means that <tt>potato</tt> is the current stable
distribution and <tt>woody</tt> is the current testing distribution.

<p><tt>unstable</tt> is a permanent symbolic link to <tt>sid</tt>, as
<tt>sid</tt> is always the unstable distribution. <!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">Codenames used in the past

<p>Other codenames that have been already used are: <tt>buzz</tt> for
release 1.1, <tt>rex</tt> for release 1.2, <tt>bo</tt> for releases 1.3.x,
<tt>hamm</tt> for release 2.0, and <tt>slink</tt> for release 2.1.

<p>While the most recent Debian distributions are kept under <tt>debian</tt>,
directory on each Debian mirror site, archives for older Debian distributions 
such as <tt>slink</tt> are kept under <tt>debian-archive</tt> directory 
on each Debian mirror site.

<sect1 id="sourceforcodenames">The source for codenames

<p>So far they have been characters taken from the movie "Toy Story" by Pixar.
<list>
  <item><em>buzz</em> (Buzz Lightyear) was the spaceman,
  <item><em>rex</em> was the tyrannosaurus,
  <item><em>bo</em> (Bo Peep) was the girl who took care of the sheep,
  <item><em>hamm</em> was the piggy bank,
  <item><em>slink</em> (Slinky Dog) was the toy dog,
  <item><em>potato</em> was, of course, Mr. Potato,
  <item><em>woody</em> was the cowboy.
  <item><em>sid</em> was a boy next door who destroyed toys.
</list>
<!--
  more info in http://www.pixar.com/feature/toystory/toystory.html 
  or better yet http://us.imdb.com/M/title-exact?Toy%20Story%20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Sarge and The Green Plastic Army Men
    - Andy (the kid)
    - Etch (Etch-a-Sketch) (the blackboard)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">The <tt>pool</tt> directory

<p>Historically, packages were kept in the subdirectory of <tt>dists</tt>
corresponding to which distribution contained them. This turned out to cause
various problems, such as large bandwidth consumption on mirrors when major
changes were made.

<p>Packages are now kept in a large `pool', structured according to the name
of the source package. To make this manageable, the pool is subdivided by
section (`main', `contrib' and `non-free') and by the first letter of the
source package name. These directories contain several files: the binary
packages for each architecture, and the source packages from which the binary
packages were generated.

<p>You can find out where each package is placed by executing a command like
<tt>apt-cache showsrc mypackagename</tt> and looking at the `Directory:'
line. For example, the <tt>apache</tt> packages are stored in
<tt>pool/main/a/apache/</tt>. Since there are so many <tt>lib*</tt>
packages, these are treated specially: for instance, libpaper packages are
stored in <tt>pool/main/libp/libpaper/</tt>.

<p>The <tt>dists</tt> directories are still used for the index files used by
programs like <tt>apt</tt>. Also, at the time of writing, older
distributions have not been converted to use pools so you'll see paths
containing distributions such as potato or woody in the Filename header
field.

<p>Normally, you won't have to worry about any of this, as new <tt>apt</tt> and
probably older <tt>dpkg-ftp</tt> (see <ref id="howtocurrent">) will handle it
seamlessly. If you want more information, see the
<url id="&pool-faq;" name="Debian Package Pools FAQ">.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Historical notes about <tt>sid</tt>

<p>When the present-day sid did not exist, the <!--FTP removed --> 
Debian archive site organization had one
major flaw: there was an assumption that when an architecture is created in
the current unstable, it will be released when that distribution becomes the
new stable. For many architectures that isn't the case, with the result that
those directories had to be moved at release time. This was impractical
because the move would chew up lots of bandwidth.

<p>The archive administrators worked around this problem for several years
by placing binaries for unreleased architectures in a special directory
called "sid". For those architectures not yet released, the first time they
were released there was a link from the current stable to sid, and from
then on they were created inside the unstable tree as normal. This layout
was somewhat confusing to users.

<p>With the advent of package pools (see <ref id="pools">) during the 
"woody" distribution development, binary packages
began to be stored in a canonical location in the pool, regardless of the
distribution, so releasing a distribution no longer causes large bandwidth
consumption on the mirrors (there is, however, a lot of gradual bandwidth
consumption throughout the development process).

<sect1 id="incoming">Uploaded packages in incoming
<p>
Uploaded packages are first located at <url id="&incoming;"> 
before checked that they really come from a Debian
developer.  Once they're checked, they are moved out of <tt>incoming</tt>
to <tt>unstable</tt>.
<p>
In case of some emergency, you may want to install packages from here 
before they reach <tt>unstable</tt>.  You can fetch them manually
and check the GPG signature and MD5sums in the .changes and .dsc files, 
then install them.
</sect1>

<sect1 id="archsections">Architecture sections
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplifed this !!!
-->

<p>Within each of the major directory trees (<tt>dists/stable/main</tt>,
<tt>dists/stable/contrib</tt>, <tt>dists/stable/non-free</tt>, and
<tt>dists/unstable/main/</tt>, etc.), the binary package entries reside in
subdirectories whose names indicate the chip architecture for which they
were compiled.

<list>
  <item>binary-all/, for packages which are architecture-independent.
    These include, for example, Perl scripts, or pure documentation.
  <item>binary-.../, for packages which execute on a particular
  binary platform.
  <item>...
  <!-- Yes I simplified this -->
</list>

<p>Please note that the actual binary packages for <em/testing/ and
<em/unstable/ no longer reside in these directories, but in the top
level <tt/pool/ directory. The index files (Packages and Packages.gz)
have been kept, though, for backwards compatibility.

<p>For the actual binary archtectures supported, see Release Notes 
for each distributions.  They can be located at
<url id="&stable-release;" name="stable Release Notes links"> and
<url id="&testing-release;" name="testing Release Notes links">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">The source code

<p>Source code is included for everything in the Debian system. Moreover,
the license terms of most programs in the system <em>require</em> that
source code be distributed along with the programs, or that an offer to
provide the source code accompany the programs.

<p>Normally the source code is distributed in the "source" directories,
which are parallel to all the architecture-specific binary directories, or
more recently in the <tt>pool</tt> directory (see <ref id="pools">). To
retrieve the source code without having to be familiar with the structure of
the <!--FTP--> Debian archive, try a command like <tt>apt-get source 
mypackagename</tt>.

<p>Some packages, notably <package>pine</package>, are only available in 
source package due to their licensing limitations.  Recently 
<package>pine-tracker</package> is provided for the needed.
Procedures described in <ref id="port"> and <ref id="packaging"> shall 
provide avanues to build package manually.

<p>Source code may or may not be available for packages in the "contrib"
and "non-free" directories, which are not formally part of the Debian system.

<sect id="pkg_basics">Debian Package Management System

<sect1 id="package-basics">Overview of Debian packages

<p>Packages generally contain all of the files necessary to implement
a set of related commands or features.  There are two types of Debian
packages:
<list>
  <item><em>Binary packages</em>, which contain executables, configuration
  files, man/info pages, copyright information, and other documentation.
  These packages are distributed in a Debian-specific archive format
  (see <ref id="deb-format">); they are usually distinguished by having
  a '.deb' file extension. Binary packages can be unpacked using the Debian
  utility <tt>dpkg</tt>; details are given in its manual page.
  
  <item><em>Source packages</em>, which consist of a <tt>.dsc</tt> file
  describing the source package (including the names of the following
  files), a <tt>.orig.tar.gz</tt> file that contains the original
  unmodified source in gzip-compressed tar format and usually a
  <tt>.diff.gz</tt> file that contains the Debian-specific changes to the
  original source.  The utility <tt>dpkg-source</tt> packs and unpacks
  Debian source archives; details are provided in its manual page.
</list>

<p>Installation of software by the package system uses "dependencies" which
are carefully designed by the package maintainers.  These dependencies are
documented in the <tt>control</tt> file associated with each package.
For example, the package containing the GNU C compiler (<package/gcc/)
"depends" on the package <package/binutils/ which includes the linker and
assembler. If a user attempts to install <package/gcc/ without having first
installed <package/binutils/, the package management system (dpkg) will send
an error message that it also needs <package/binutils/, and stop installing
<package/gcc/. (However, this facility can be overridden by the insistent
user, see <manref name="dpkg" section="8">.)  See more in <ref id="depends">
below.

<p>Debian's packaging tools can be used to:
<list>
  <item>manipulate and manage packages or parts of packages,
  <item>aid the user in the break-up of packages that must be transmitted
    through a limited-size medium such as floppy disks,
  <item>aid developers in the construction of package archives, and
  <item>aid users in the installation of packages which reside on a remote
    <!--FTP-->Debian archive site.
</list>

<sect1 id="deb-format">Debian <!--binary--> package format

<p>A Debian "package", or a Debian archive file, contains the executable
files, libraries, and documentation associated with a particular suite of
program or set of related programs.  Normally, a Debian archive file has
a filename that ends in <tt>.deb</tt>.

<p>The internals of this Debian binary packages format are described in
the <manref name="deb" section="5"> manual page. This internal format is
subject to change (between major releases of &debian;), therefore please
always use <manref name="dpkg-deb" section="8"> for manipulating <tt>.deb</tt>
files.

<!-- Below added by Osamu XXX Not sure but should be right -->

<p>At least up to "woody" distribution, any Debian archive files have been
able to be manipulated by standard Unix commands <prgn>ar</prgn> 
and <prgn>tar</prgn> even when dpkg commands are not available.

<sect1 id="pkgname">Naming convention of the Debian package file names
<!--
Why are Debian package file names so long? 
-->
<p>The Debian <!--binary--> package file names conform to the following convention:
&lt;foo&gt;_&lt;VersionNumber&gt;-&lt;DebianRevisionNumber&gt;.deb

<p>Note that <tt>foo</tt> is supposed to be the package name. As a check,
one can learn the package name associated with a particular Debian archive
file (.deb file) in one of these ways:
<list>
  <item>inspect the "Packages" file in the directory where it was stored
  at a Debian <!--FTP--> archive site.  This file contains a stanza describing
  each package; the first field in each stanza is the formal package name.
  
  <item>use the command <tt>dpkg --info foo_VVV-RRR.deb</tt> (where VVV and
  RRR are the version and revision of the package in question, respectively).
  This displays, among other things, the package name corresponding to the
  archive file being unpacked.
</list>

<p>The <tt>VVV</tt> component is the version number specified by the
upstream developer.  There are no standards in place here, so the version
number may have formats as different as "19990513" and "1.3.8pre1".

<p>The <tt>RRR</tt> component is the Debian revision number, and is
specified by the Debian developer (or an individual user if he chooses
to build the package himself).  This number corresponds to the revision
level of the Debian package, thus, a new revision level usually signifies
changes in the Debian Makefile (<tt>debian/rules</tt>), the Debian control
file (<tt>debian/control</tt>), the installation or removal scripts
(<tt>debian/p*</tt>), or in the configuration files used with the package.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Preservation of the local configuration
<!--
What is a Debian conffile
-->
<p>Preservation of user configurable files are enabled through Debian
conffiles mechanism.  User configuration files (usually placed in 
<tt>/etc</tt>) are specified in the <tt>conffiles</tt> within Debian package
system.  The package management system guarantees not to overwrite these 
files when the package is upgraded.
<!-- 
<p>Conffiles is a list of configuration files (usually placed in <tt>/etc</tt>)
that the package management system will not overwrite when the package is
upgraded. This ensures that local values for the contents of these files
will be preserved, and is a critical feature enabling the in-place upgrade
of packages on a running system.
-->
<p>To determine exactly which files are preserved during an upgrade, run:
  <example>dpkg --status package</example>
And look under "Conffiles:".

<p>
Specifics regarding the contents of a Debian conffiles file are provided
in the Debian Policy Manual, section 11.7, see <ref id="references">.

<sect1 id="maintscripts">Debian maintenance scripts
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian maintenance scripts
are executable scripts which are automatically run before
or after a package is installed. Along with a file named <tt>control</tt>,
all of these files are part of the "control" section of a Debian archive file.

<p>The individual files are:
<taglist>
<tag/preinst/
  <item>This script executes before that package will be unpacked from its
  Debian archive (".deb") file. Many 'preinst' scripts stop services for
  packages which are being upgraded until their installation or upgrade is
  completed (following the successful execution of the 'postinst' script).

<tag/postinst/
  <item>This script typically completes any required configuration of the
  package <tt>foo</tt> once <tt>foo</tt> has been unpacked from its Debian
  archive (".deb") file. Often, 'postinst' scripts ask the user for input,
  and/or warn the user that if he accepts default values, he should remember
  to go back and re-configure that package as the situation warrants.
  Many 'postinst' scripts then execute any commands necessary to start or
  restart a service once a new package has been installed or upgraded.

<tag/prerm/
  <item>This script typically stops any daemons which are associated with
  a package.  It is executed before the removal of files associated with
  the package.

<tag/postrm/
  <item>This script typically modifies links or other files associated with
  <tt>foo</tt>, and/or removes files created by the package. (Also see
  <ref id="virtual">.)
</taglist>

<p>Currently all of the control files can be found in directory
<tt>/var/lib/dpkg/info</tt>. The files relevant to package <tt>foo</tt>
begin with the name "foo" and have file extensions of "preinst", "postinst",
etc., as appropriate.  The file <tt>foo.list</tt> in that directory
lists all of the files that were installed with the package <tt>foo</tt>.
(Note that the location of these files is a dpkg internal; you should not
rely on it.)

<sect1 id="priority">Package priority
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Each Debian package is assigned a <em>priority</em> by the distribution
maintainers, as an aid to the package management system.  The priorities are:

<list>
  <item><strong>Required</strong>: packages that are necessary for the proper
    functioning of the system.
    <p>This includes all tools that are necessary to repair system defects.
    You must not remove these packages or your system may become totally broken
    and you may probably not even be able to use dpkg to put things back.
    Systems with only the Required packages are probably unusable, but they do
    have enough functionality to allow the sysadmin to boot and install more
    software.
  <item><strong>Important</strong> packages should be found on any Unix-like
    system.
    <p>Other packages which the system will not run well or be usable without
    will be here. This does <em>NOT</em> include Emacs or X11 or TeX or any
    other large applications. These packages only constitute the bare
    infrastructure.
  <item><strong>Standard</strong> packages are standard on any Linux system,
    including a reasonably small but not too limited character-mode system.
    <p>This is what will install by default if users do not select anything
    else. It does not include many large applications, but it does include
    Emacs (this is more of a piece of infrastructure than an application)
    and a reasonable subset of TeX and LaTeX (if this turns out to be
    possible without X).
  <item><strong>Optional</strong> packages include all those that you might
    reasonably want to install if you did not know what it was, or do not
    have specialized requirements.
    <p>This includes X11, a full TeX distribution, and lots of applications.
  <item><strong>Extra</strong>: packages that either conflict with others
    with higher priorities, are only likely to be useful if you already know
    what they are, or have specialized requirements that make them
    unsuitable for "Optional".
</list>

<sect1 id="virtual">Virtual Package

<p>A virtual package is a generic name that applies to any one of a group
of packages, all of which provide similar basic functionality. For example,
both the <tt>tin</tt> and <tt>trn</tt> programs are news readers, and
should therefore satisfy any dependency of a program that required a news
reader on a system, in order to work or to be useful.
They are therefore both said to provide the "virtual package" called
<tt>news-reader</tt>.

<p>Similarly, <tt>exim</tt> and <tt>sendmail</tt> both provide the
functionality of a mail transport agent.  They are therefore said to
provide the virtual package, "mail transport agent".
If either one is installed, then any program depending on the
installation of a <tt>mail-transport-agent</tt> will be satisfied by
the existence of this virtual package.

<p>Debian provides a mechanism so that, if more than one package which
provide the same virtual package is installed on a system, then system
administrators can set one as the preferred package. The relevant command
is <tt>update-alternatives</tt>, and is described further in
<ref id="alternatives">.

<sect1 id="depends">Package dependencies
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>The Debian package system has a range of package "dependencies"
which are designed to indicate (in a single flag) the level at which
Program A can operate independently of the existence of Program B on
a given system:
<list>
  <item>Package A <em>depends</em> on Package B if B absolutely must
    be installed in order to run A.  In some cases, A depends not only
    on B, but on a version of B.  In this case, the version dependency is
    usually a lower limit, in the sense that A depends on any version
    of B more recent than some specified version.
  <item>Package A <em>recommends</em> Package B, if the package maintainer
    judges that most users would not want A without also having the
    functionality provided by B.
  <item>Package A <em>suggests</em> Package B if B contains files that
    are related to (and usually enhance) the functionality of A.
  <item>Package A <em>conflicts</em> with Package B when A will not
    operate if B is installed on the system.  Most often, conflicts are
    cases where A contains files which are an improvement over those in B.
    "Conflicts" are often combined with "replaces".
  <item>Package A <em>replaces</em> Package B when files installed
    by B are removed and (in some cases) over-written by files in A.
  <item>Package A <em>provides</em> Package B when all of the files and
    functionality of B are incorporated into A.  This mechanism provides
    a way for users with constrained disk space to get only that part of
    package A which they really need.
</list>

<p>More detailed information on the use of each these terms can be found
in the Packaging manual and the Policy manual.

<p>It should be reminded that <tt>dselect</tt> has more fine grained 
control over packages specified by <em>recommends</em> and 
<em>suggests</em> than <tt>apt-get</tt> which simply pulls all 
the packages specified by <em>recommends</em> and leaves all
the packages specified by <em>suggests</em>.  Both programs in modern 
form use APT as their back-end.

<sect1 id="pre-depends">Meaning of Pre-Depends

<p>"Pre-Depends" is a special dependency. In the case of most packages,
<tt>dpkg</tt> will unpack its archive file (i.e., its <tt>.deb</tt> file)
independently of whether or not the files on which it depends exist on the
system.  Simplistically, unpacking means that <tt>dpkg</tt> will extract
the files from the archive file that were meant to be installed on your
file system, and put them in place.  If those packages <em>depend</em> on
the existence of some other packages on your system, <tt>dpkg</tt> will
refuse to complete the installation (by executing its "configure" action)
until the other packages are installed.

<p>However, for some packages, <tt>dpkg</tt> will refuse even to unpack
them until certain dependencies are resolved.  Such packages are said
to "Pre-depend" on the presence of some other packages.
The Debian project provided this mechanism to support the safe upgrading
of systems from <tt>a.out</tt> format to <tt>ELF</tt> format, where
the <em>order</em> in which packages were unpacked was critical. There are
other large upgrade situations where this method is useful, e.g. the
packages with the required priority and their LibC dependency.

<p>As before, more detailed information about this can be found in the
Packaging manual.

<sect1 id="pkgstatus">Package status
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Package status can be "unknown", "install", "remove", "purge", or 
"hold".
These "want" flags tell what the user wanted to do with a package (as
indicated either by the user's actions in the "Select" section of
<tt>dselect</tt>, or by the user's direct invocations of <tt>dpkg</tt>).

<p>Their meanings are:
<list>
  <item>unknown  - the user has never indicated whether he wants the package
  <item>install  - the user wants the package installed or upgraded
  <item>remove   - the user wants the package removed, but does not want to
    remove any existing configuration files.
  <item>purge    - the user wants the package to be removed completely,
    including its configuration files.
  <item>hold     - the user wants this package not to be processed, i.e., he
    wants to keep the current version with the current status whatever that is.
</list>

<sect1 id="puttingonhold">Holding back packages from the upgrade
<!--
How do I put a package on hold?
Made major rewite to accomodate new /etc/apt/preferences in progress
-->
<p>There may be two mechanisms of holding back packages from the upgrade, 
through "dpkg", or, in woody, through APT.

<p>With dpkg, you just have to export the list of package selections, with:
  <example>dpkg --get-selections &gt; selections.txt</example>
Then edit the resulting file <file/selections.txt/, change the line
containing the package you wish to hold, e.g. <package/libc6/, from this:
  <example>libc6                                           install</example>
to this:
  <example>libc6                                           hold</example>
Save the file, and reload it into dpkg database with:
  <example>dpkg --set-selections &lt; selections.txt</example>
Or, if one knew package name to hold, simply run:
  <example>echo libc6 hold | dpkg --set-selections</example>
This process holds packages at the install process of each package file.

<p>The same effect can be obtained through dselect. One just have to enter 
the [S]elect screen, find the
package you wish to hold in its present state, and press the `=' key (or
`H'). The changes will go live immediately after you exit the [S]elect
screen.

<p>APT system in the new woody distribution has an new alternative mechanism 
to hold packages at archive retrieval process using <tt>Pin-Priority</tt>.
See manual page <manref name="apt_preferences" section="5">.

<!--- XXX apt-howto, apt_preferences, pointer withing this.  -->

<sect1 id="sourcepkgs">Source package

<p>
<!--
Debian source packages can't actually be "installed", they are just
unpacked in whatever directory you want to build the binary packages they
produce.
-->
Source packages are distributed in a directory called <tt>source</tt>, and
you can either download them manually, or use
  <example>apt-get source foo</example>
to fetch them (see <manref name="apt-get" section="8"> manual page on how
to setup APT for doing that).

<!-- XXX 
Pointer to building package   
mention deb-src thing here 
-->

<sect1 id="sourcebuild">Build binary packages from a source package

<p>You will need all of foo_*.dsc, foo_*.tar.gz and foo_*.diff.gz to compile
the source (note: there is no .diff.gz for a Debian native package).

<p>Once you have them, if you have the <package/dpkg-dev/ package installed,
the following command:
  <example>dpkg-source -x foo_version-revision.dsc</example>
will extract the package into a directory called <tt>foo-version</tt>.

<p>If you want just to compile the package, you may cd into
<tt>foo-version</tt> directory and issue the command
  <example>debian/rules build</example>
to build the program, then
  <example>debian/rules binary</example>
as root, to build the package, and then
  <example>dpkg -i ../foo_version-revision_arch.deb</example>
to install the newly-built package.

<!-- XXX woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Creating new Debian packages

<p>For more detailed description on this, read the New Maintainers' Guide,
available in the <package/maint-guide/ package, or at
<url id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rerely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rerely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Upgrade Debian System

<p>One of Debian goals is to provide a consistent upgrade path and a secure
upgrade process, and we always do our best to make the new release smoothly
upgradable from the previous ones. In case there's some important note to
add to the upgrade process, the packages will alert the user, and often
provide a solution to a possible problem.

<p>You should also read the Release Notes, document that describes the
details of specific upgrades, shipped on all Debian CDs, and available on
the WWW at <url id="&stable-release;"> or <url id="&testing-release;">.

<p>
Practical guide is provided in <ref id="package">.  This section 
describes fundamental detail.

<!-- XXX make this into generic link -->

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Methods for upgrading Debian system

<p>One could simply execute an anonymous ftp or wget call to a Debian archive, then
peruse the directories until he finds the desired file, and then fetch it,
and finally install it using <tt>dpkg</tt>.  Note that <tt>dpkg</tt>
will install upgrade files in place, even on a running system.
Sometimes, a revised package will require the installation of a newly revised
version of another package, in which case the installation will fail
until/unless the other package is installed.

<p>Many people find this approach much too time-consuming, since Debian
evolves so quickly -- typically, a dozen or more new packages are uploaded
every week.  This number is larger just before a new major release.
To deal with this avalanche, many people prefer to use an automated
programs.  Several specialized package management tools are available 
for this purpose.

<sect1 id="pkgtools">Package management tools overview

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>Debian package management system has 2 focuses, i.e., the manipulation 
of the package file itself and the retrieval of package files from 
the Debian archive.  <tt>dpkg</tt> is the former. <tt>APT</tt> and
<tt>dselect</tt> are the latters.

<sect1 id="dpkg">dpkg

<p>This is the main program to manipulate package files.
<p>For more information, install <package/dpkg/ package and read
<manref name="dpkg" section="8">.


<p><prgn>dpkg</prgn> comes with several primitive supplimental programs.

<list>
<item>dpkg-deb: Manipulate <tt>.deb</tt>) files. 
 <manref name="dpkg-deb" section="1">
<item>dpkg-ftp: Older package file retrieval command. 
 <manref name="dpkg-ftp" section="1">
<item>dpkg-mountable: Older package file retrieval command. 
 <manref name="dpkg-mountable" section="1">
<item>dpkg-split: Splits large package into smaller files. 
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> and <prgn>dpkg-mountable</prgn> are obsoleted by 
the introduction of APT system.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT is an advanced interface to the Debian packaging system. 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn> and <prgn>apt-cdrom</prgn> 
are the command-line tool for handling packages.  These also function 
as the user's "back-end" programs to other tools, such as <prgn/dselect/ 
and <prgn/aptitude/.

<p>For more information, install <package/apt/ package and read
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (woody), and
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>Alternative source of information exists as
<url id="&apt-howto;" name="APT HOWTO">.
This can be installed by <package/apt-howto/ at
<file>/usr/share/doc/apt-howto/en/apt-howto-en.html/index.html</file>.

<p><tt>apt-get upgrade</tt> and <tt>apt-get dist-upgrade</tt> have a 
tendancy to pull-in all packages listed under "Suggests:".  
To avoid this, use <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics">dselect

<p>This program is a menu-driven user interface to the Debian package management
system. It is particularly useful for first-time installations and
large-scale upgrades.

<p>For more information, install <package/install-doc/ package and read
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> or
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <tt>start-stop-daemon</tt> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Upgrade running system

<p>The kernel (file system) in &debian; systems supports replacing files even
while they're being used.

<p>We also provide a program called <prgn/start-stop-daemon/ which is used
to start daemons at boot time or to stop daemons when the kernel runlevel is
changed (e.g., from multi-user to single-user or to halt). The same program
is used by installation scripts when a new package containing a daemon is
installed, to stop running daemons, and restart them as necessary.

<p>It is noteworthy to mention that the Debian system does not require 
use of the single user mode to upgrade running system.

<sect1 id="savedebs">Downloaded and cached .deb archive files

<p>If you have downloaded the files to your disk (which is not
absolutely necessary, see above for the description of dpkg-ftp),
then after you have installed the packages, you can remove them from
your system.

<p>If APT is used, these files are cached in
<file>/var/cache/apt/archives/</file> directory.  
You may erase them after installation or copy to another machine's
<file>/var/cache/apt/archives/</file> directory to save downloading
during following installations.

<!-- insert apt-get clean... thing and dselect configuration here XXXX -->

<sect1 id="keepingalog">Record keeping for upgrade

<p><prgn/dpkg/ keeps a record of the packages that have been unpacked,
configured, removed, and/or purged, but does not (currently) keep a log
of terminal activity that occured while a package was being so manipulated.

<p>The simplest way to work around this is to run your
<prgn>dpkg</prgn>/<prgn>dselect</prgn>/<prgn>apt-get</prgn>/whatever
sessions within the <manref name="script" section="1"> program.

<sect id="boot">Boot process of Debian

<sect1 id="init"><tt>init</tt> program

<p>Like all Unices, Debian boots up by executing the program <tt>init</tt>.
The configuration file for <tt>init</tt> (which is <tt>/etc/inittab</tt>)
specifies that the first script to be executed should
be <tt>/etc/init.d/rcS</tt>.  This script checks and mounts file systems,
loads modules, starts the network services, sets the clock, performs other
initialization, and then runs all of the scripts (except those with a `.'
in the filename) in <tt>/etc/rc.boot/</tt>. Any scripts in the latter
directory are usually reserved for system administrator use, and using them
in packages is deprecated.

<sect1 id="runlevels">Runlevels

<p>After completing the boot process, <tt>init</tt> executes all start
scripts in a directory specified by the default runlevel (this runlevel
is given by the entry for <tt>id</tt> in <tt>/etc/inittab</tt>).
Like most <!-- all? SGK --> System V compatible Unices, Linux has 7 runlevels:
<list>
  <item>0 (halt the system),
  <item>1 (single-user mode),
  <item>2 through 5 (various multi-user modes), and
  <item>6 (reboot the system).
</list>
Debian systems come with id=2, which indicates that the default
runlevel will be '2' when the multi-user state is entered, and the
scripts in <tt>/etc/rc2.d/</tt> will be run.

<p>In fact, the scripts in any of the directories, <tt>/etc/rcN.d/</tt>
are just symbolic links back to scripts in <tt>/etc/init.d/</tt>.  However,
the <em>names</em> of the files in each of the <tt>/etc/rcN.d/</tt>
directories are selected to indicate the <em>way</em> the scripts in
<tt>/etc/init.d/</tt> will be run.  Specifically, before entering any
runlevel, all the scripts beginning with 'K' are run; these scripts kill
services.  Then all the scripts beginning with 'S' are run; these scripts
start services.  The two-digit number following the 'K' or 'S' indicates
the order in which the script is run.  Lower numbered scripts are executed
first.

<p>This approach works because the scripts in <tt>/etc/init.d/</tt> all
take an argument which can be either `start', `stop', `reload', `restart'
or `force-reload' and will then do the task indicated by the argument.
These scripts can be used even after a system has been booted, to control
various processes.

<p>For example, with the argument `reload' the command
  <example>/etc/init.d/sendmail reload</example>
sends the sendmail daemon a signal to reread its configuration file.

<sect1 id="custombootscripts">Customize boot process
<p>
It looks as if Debian does not use
  <tt>rc.local</tt> to customize the boot process; what facilities
  are provided?

<p>Suppose a system needs to execute script <tt>foo</tt> on start-up,
or on entry to a particular (System V) runlevel.  Then the system
administrator should:
<list>
  <item>Enter the script <tt>foo</tt> into the directory <tt>/etc/init.d/</tt>.
  <item>Run the Debian command <tt>update-rc.d</tt> with appropriate
  arguments, to set up links between the (command-line-specified) directories
  rc?.d and <tt>/etc/init.d/foo</tt>.  Here, '?' is a number from 0 through 6
  and corresponds to each of the System V runlevels.
  <item>Reboot the system.
</list>

<p>The command <tt>update-rc.d</tt> will set up links between files in
the directories rc?.d and the script in <tt>/etc/init.d/</tt>.
Each link will begin with a 'S' or a 'K', followed by a number, followed
by the name of the script.  Scripts beginning with 'S' in
<tt>/etc/rcN.d/</tt> are executed when runlevel <tt>N</tt> is entered.
Scripts beginning with a 'K' are executed when leaving runlevel <tt>N</tt>.

<p>One might, for example, cause the script <tt>foo</tt> to execute at
boot-up, by putting it in <tt>/etc/init.d/</tt> and installing the links with
<tt>update-rc.d foo defaults 19</tt>.  The argument 'defaults' refers
to the default runlevels, which are 2 through 5.  The argument '19' ensures
that <tt>foo</tt> is called before any scripts containing numbers 20
or larger.

<sect id="diverse">Support of diversity
<p>
Debian offers several avenues to accomodate any wishes of the system 
administrator without breaking the system. 
<list>
<item><prgn>equivs</prgn>, see <ref id="apt-trouble">.
<item><prgn>dpkg-divert</prgn>, see <ref id="dpkg-divert">.
<item><prgn>update-alternative</prgn>, see <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> can accomodate many boot loaders. 
      See <manref name="make-kpkg" section="1">.
</list>
Any files under <file>/usr/local/</file> belongs to the system administrator 
and &debian; will not touch them. Most (or all) files under <file>/etc</file> are 
<tt>conffiles</tt> and &debian; will not overwrite them upon upgrade unless 
the system administrator requests so explicitly.

<sect id="nonenglish">Non-English locale

<p>
<url id="&intro-i18n;" name="Introduction to i18n"> is aimed at the developers 
but also useful for the system administrators.
<list>
  <item>&debian; is distributed with keymaps for nearly two dozen
    keyboards, and with utilities (in the <tt>kbd</tt> package) to install,
    view, and modify the tables. <!-- XXXX kbd or console ??? -->
    <p>The installation prompts the user to specify the keyboard he will use.
  <item>Vast majority of the software we packaged supports entering
    non-US-ASCII characters used in other Latin languages (e.g. ISO-8859-1
    or ISO-8859-2), and a number of programs support multi-byte languages
    such as Japanese or Chinese.
  <item>Currently, support for German-, Spanish-, Finnish-, French-,
    Hungarian-, Italian-, Japanese-, Korean- and Polish-language
    manual pages is provided through the <tt>manpages-LANG</tt> packages
    (where LANG is the two-letter ISO country code). To access an NLS manual
    page, the user must set the shell LC_MESSAGES variable to the appropriate
    string.
    <p>For example, in the case of the Italian-language manual pages,
    LC_MESSAGES needs to be set to 'italian'.  The <prgn/man/ program will
    then search for Italian manual pages under <tt>/usr/share/man/it/</tt>.
</list>

<sect id="kernel-details">Debian and the kernel

<sect1 id="non-debian-kernel">Compile a kernel from non-debian source

<p><!--Yes.  But you have-->
One has to understand the Debian policy with respect to headers.

<p>The Debian C libraries are built with the most recent <em>stable</em>
releases of the <strong>kernel</strong> headers.

<p>For example, the Debian-1.2 release used version 5.4.13 of the headers.
This practice contrasts with the Linux kernel source packages distributed
at all Linux FTP archive sites, which uses even more recent versions of
the headers.  The kernel headers distributed with the kernel source are
located in <tt>/usr/include/linux/include/</tt>.

<p>If you need to compile a program with kernel headers that are newer
than those provided by <package/libc6-dev/, then you must add
<tt>-I/usr/src/linux/include/</tt> to your command line when compiling.
This came up at one point, for example, with the packaging of the
automounter daemon (<package/amd/).  When new kernels changed some
internals dealing with NFS, <tt>amd</tt> needed to know about them.
This required the inclusion of the latest kernel headers.

<sect1 id="customkernel">Tools to build custom kernels

<p>Users who wish to (or must) build a custom kernel are encouraged to
download the package <package/kernel-package/.  This package contains
the script to build the kernel package, and provides the capability to
create a Debian kernel-image package just by running the command
  <example>make-kpkg kernel_image</example>
in the top-level kernel source directory.
Help is available by executing the command
  <example>make-kpkg --help</example>
and through the manual page <manref name="make-kpkg" section="8">.

<p>Users must separately download the source code for the most recent
kernel (or the kernel of their choice) from their favorite Linux archive
site, unless a kernel-source-version package is available (where "version"
stands for the kernel version). See <ref id="kernel-compile">.

<p>Detailed instructions for using the <package/kernel-package/ package
are given in the file <tt>/usr/doc/kernel-package/README</tt>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">Alternative boot loader
<p>
To employ alternative boot loaders such as <package/grub/ or
<package/loadlin/, copy the compiled Linux kernel <file>bzimage</file> 
to other locations (e.g., to /boot/grub or to an <tt>MS-DOS</tt> partition).
</sect1>

<sect1 id="custombootdisk">Custom boot floppy

<p>This task is greatly aided by the Debian package <package/boot-floppies/,
normally found in the <tt>admin</tt> section of the Debian FTP archive.
Shell scripts in this package produce boot floppies in the <tt>SYSLINUX</tt>
format.  These are <tt>MS-DOS</tt> formatted floppies whose master boot
records have been altered so that they boot Linux directly (or whatever
other operating system has been defined in the syslinux.cfg file on the
floppy). Other scripts in this package produce emergency root disks and
can even reproduce the base disks.

<p>You will find more information about this in the
<tt>/usr/doc/boot-floppies/README</tt> file after installing the
<package/boot-floppies/ package.

<sect1 id="modules">Special provisions to deal with modules

<p>Debian's <package/modconf/ package provides a shell script
(<tt>/usr/sbin/modconf</tt>) which can be used to customize the
configuration of modules.  This script presents a menu-based interface,
prompting the user for particulars on the loadable device drivers
in his system.  The responses are used to customize the file
<tt>/etc/modules.conf</tt> (which lists aliases, and other arguments that
must be used in conjunction with various modules) through files in
<tt>/etc/modutils/</tt>, and <tt>/etc/modules</tt> (which lists the
modules that must be loaded at boot time).

<p>Like the (new) Configure.help files that are now available to support
the construction of custom kernels, the modconf package comes with a
series of help files (in <tt>/usr/lib/modules_help/</tt>) which provide
detailed information on appropriate arguments for each of the modules.

<!-- XXXX need section for initrd -->

<sect1 id="removeoldkernel">De-install an old kernel package

<p>Yes.  The <tt>kernel-image-NNN.prerm</tt> script checks to see whether
the kernel you are currently running is the same as the kernel you are trying
to de-install.  Therefore you can remove unwanted kernel image packages using
this command:

<example>dpkg --purge --force-remove-essential kernel-image-NNN</example>

(replace "NNN" with your kernel version and revision number, of course)
</sect>
