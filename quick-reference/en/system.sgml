<!-- CVS revision of this document "$Revision: 1.45 $"  -->
<chapt id="system">Debian fundamentals

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
This chapter provides fundamental information on the Debian system 
for non-developers.  For authoritative information, see:
<p>
<list compact>
<item>Debian Policy Manual
<item>Debian Packaging Manual (Potato)
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
<p>
</list>
listed under <ref id="references">.

<p>
If you are looking for less detailed "how-to" explanations,
jump directly to <ref id="package"> or other relevant chapters.
<p>
This chapter is based on documents taken from the "Debian FAQ", greatly
reorganized to allow the ordinary Debian system administrator to get started.

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">The Debian archives

<sect1 id="dirtree">Directory structures

<p>The software that has been packaged for &debian; is available in one
of several directory trees on each 
<url id="&mirror-site;" 
     name="Debian mirror site">
through FTP or HTTP.

<p>The following directories can be found on each Debian mirror site
under the <file>debian</file> directory:
<taglist>
  <tag><file>dists/</file>:
    <item>This directory contains the "distributions", and this used 
    to be the canonical way to access the currently available 
    packages in Debian releases and pre-releases. Some old packages 
    and <file>Packages.gz</file> files are still in here.
  <tag><file>pool/</file>:
    <item>The new physical location for all packages of Debian
    releases and pre-releases.
  <tag><file>tools/</file>:
    <item>DOS utilities for creating boot disks, partitioning
    your disk drive, compressing/decompressing files, and booting Linux.
  <tag><file>doc/</file>:
    <item>The basic Debian documentation, such as the FAQ, the bug reporting
          system instructions, etc.
  <tag><file>indices/</file>:
    <item>The Maintainers file and the override files.
  <tag><file>project/</file>:
    <item>mostly developer-only materials, such as:
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>This directory contains packages and tools which are still
        being developed, and are still in the alpha testing stage.  Users
        shouldn't be using packages from here, because they can be dangerous
        and harmful even for the most experienced.
      <tag><file>project/orphaned/</file>:
        <item>Packages that have been orphaned by their old maintainers, and
        withdrawn from the distribution.
    </taglist>
</taglist>

<sect1 id="dists">Debian distributions

<p>Normally there are three Debian distributions in the <file>dists</file> 
directory. They are named the <tt>stable</tt> distribution, the
<tt>testing</tt> distribution, and the <tt>unstable</tt> distribution. Sometimes there is
also a <tt>frozen</tt> distribution.  Each distribution 
is defined as a symlink to the actual directory with a codename in the
<file>dists</file> directory.

<sect1 id="stable">The <tt>stable</tt> distribution

<p>Package entries for the <tt>stable</tt> distribution, &stabledebian;, 
are recorded into the <file>stable</file> (symlink to
<file>&stablecodenamedir;/</file>) directory:
<list>
  <item><file>stable/main/</file>:
  This directory contains the packages which formally constitute the most
  recent release of the &debian; system.

  <p>These packages all comply with the <url name="Debian Free Software
  Guidelines (DFSG)" id="&social-contract;#guidelines"> (also available as
  <file>&f-social-contract;</file> installed by 
  <package>&p-social-contract;</package>),
  and are all freely usable and distributable.

  <item><file>stable/non-free/</file>:  This directory contains packages
  distribution of which is restricted in a way that requires that distributors
  take careful account of the specified copyright requirements.

  <p>For example, some packages have licenses which prohibit commercial
  distribution.  Others can be redistributed but are in fact shareware
  and not free software.  The licenses of each of these packages must be
  studied, and possibly negotiated, before the packages are included in
  any redistribution (e.g., in a CD-ROM).

  <item><file>stable/contrib/</file>: This directory contains packages which are
  DFSG-free and <strong>freely distributable</strong> themselves, but somehow depend
  on a package that is <strong>not</strong> freely distributable and thus available only
  in the non-free section.
</list>
Now, in addition to the above locations, new physical packages are 
located under the <file>pool</file> directory (<ref id="pools">).  

<p>The current status of <tt>stable</tt> distribution bugs is reported 
on the <url id="&stable-problems;" name="Stable Problems"> web page.


<sect1 id="testing">The <tt>testing</tt> distribution

<p>Package entries for the <tt>testing</tt> distribution, &testingdebian;, 
are recorded into the <file>testing</file> (symlink to <file>&testingcodenamedir;/</file>) directory after they 
have undergone some degree of testing in <tt>unstable</tt>.  
Now, in addition to the above locations, new physical packages are 
located under the <file>pool</file> directory (<ref id="pools">).  
There are also
<file>main</file>, <file>contrib</file>, and <file>non-free</file> subdirectories in
<file>testing/</file>, which serve the same functions as in <file>stable/</file>.

<p>These packages must be in sync on all
architectures where they have been built and mustn't have dependencies that
make them uninstallable; they also have to have fewer release-critical bugs
than the versions currently in <tt>unstable</tt>. This way, we hope that
<tt>testing</tt> is
always close to being a release candidate.  More details of the testing 
mechanism are at <url id="&testing-notes;">.

<p>The latest status of the <tt>testing</tt> distribution is reported at these
sites:
<list compact>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="other bugs and bug-squashing party notes">
</list>

<sect1 id="unstable">The <tt>unstable</tt> distribution

<p>Package entries for the <tt>unstable</tt> distribution, always codenamed "Sid",
are recorded into the <file>unstable</file> (symlink to <file>sid/</file>) directory after
they are uploaded to the Debian archive and stay here until they are moved to
<file>testing/</file>.  New physical packages are located under the <file>pool</file> directory
(<ref id="pools">).  There are also <file>main</file>, <file>contrib</file>, and
<file>non-free</file> subdirectories in <file>unstable/</file>, which serve the same
functions as in <file>stable/</file>.

<p>The <tt>unstable</tt> distribution contains a snapshot of the most current 
development system. Users are welcome to use and test these packages, 
but are warned
about their state of readiness. The advantage of using the <tt>unstable</tt>
distribution is that you are always up-to-date with the latest in the &debian;
software project&mdash;but if it breaks, you get to keep both parts. :-)

<p>The current status of <tt>unstable</tt> distribution bugs is reported 
on the <url id="&unstable-problems;" name="Unstable Problems"> web page.

<!-- Above was enough
<sect1 id="sid">The Sid distribution

<p>Sid or <tt>unstable</tt> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <tt>testing</tt>,
in order to be released in <tt>stable</tt> later on. Sid contains packages
for both released and unreleased architectures.

<p>The name "Sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">The <tt>frozen</tt> distribution

<p>When the <tt>testing</tt> distribution is mature enough, it becomes frozen,
meaning no new code is accepted anymore, just bugfixes, if necessary.
Also, a new testing tree is created in the <file>dists</file> directory,
assigned a new codename. The frozen distribution passes through a few months
of testing, with intermittent updates and deep freezes called "test cycles".
(The recent Woody release process did not create a symbolic link
<file>frozen/</file>, so <tt>frozen</tt> was not a distribution but just a
development stage of the <tt>testing</tt> distribution.)

<p>We keep a record of bugs in the frozen distribution that can delay a
package from being released or bugs that can hold back the whole release.
Once that bug count lowers to maximum acceptable values, the frozen
distribution becomes stable, it is released, and the previous stable
distribution becomes obsolete (and moves to the archive).

<sect1 id="codenames">Debian distribution codenames

<p>Physical directory names in the <file>dists</file> directory, such as
<file>&stablecodenamedir;/</file> and <file>&testingcodenamedir;/</file>, are just "codenames". When a &debian;
distribution is in the development stage, it has no version number, but a
codename instead. The purpose of these codenames is to make the mirroring of
the &debian; distributions easier (if a real directory like <file>unstable</file>
suddenly changed its name to <file>stable/</file>, a lot of stuff would have to be
needlessly downloaded again).

<p>Currently, <file>stable/</file> is a symbolic link to <file>&stablecodenamedir;/</file>, 
and <file>testing/</file> is a symbolic link to
<file>&testingcodenamedir;/</file>. This means that <tt>&stablecodename;</tt> is the current stable
distribution and <tt>&testingcodename;</tt> is the current testing distribution.

<p><file>unstable/</file> is a permanent symbolic link to <file>sid/</file>, as
Sid is always the unstable distribution. <!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">Codenames used in the past

<p>Other codenames that have already been used are: "Buzz" for
release 1.1, "Rex" for release 1.2, "Bo" for releases 1.3.x,
"Hamm" for release 2.0, "Slink" for release 2.1, 
and "Potato" for release 2.2.


<sect1 id="sourceforcodenames">The source for codenames

<p>So far they have been characters taken from the movie <em>Toy Story</em> by
Pixar.
<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) was the spaceman,
  <item><strong>Rex</strong> was the tyrannosaurus,
  <item><strong>Bo</strong> (Bo Peep) was the girl who took care of the sheep,
  <item><strong>Hamm</strong> was the piggy bank,
  <item><strong>Slink</strong> (Slinky Dog) was the toy dog,
  <item><strong>Sarge</strong> was a leader of the Green Plastic Army Men,
  <item><strong>Potato</strong> was, of course, Mr. Potato Head,
  <item><strong>Woody</strong> was the cowboy,
  <item><strong>Sid</strong> was a boy next door who destroyed toys.
</list>
<!--
  more info in http://www.pixar.com/featurefilms/ts/index.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Etch (Etch-a-Sketch) (the blackboard)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">The <file>pool</file> directory

<p>Historically, packages were kept in the subdirectory of <file>dists</file>
corresponding to the distribution that contained them. This turned out to
cause various problems, such as large bandwidth consumption on mirrors when
major changes were made.

<p>Packages are now kept in a large "pool", structured according to the name
of the source package. To make this manageable, the pool is subdivided by
section (<tt>main</tt>, <tt>contrib</tt>, and <tt>non-free</tt>) and by the
first letter of the source package name. These directories contain several
files: the binary packages for each architecture, and the source packages from
which the binary packages were generated.

<p>You can find out where each package is placed by executing a command like
<tt>apt-cache showsrc <var>mypackagename</var></tt> and looking at the
"Directory:" line. For example, the <package>apache</package> packages are
stored in <file>pool/main/a/apache/</file>. Since there are so many
<tt>lib*</tt> packages, these are treated specially: for instance,
<package>libpaper</package> packages are stored in
<file>pool/main/libp/libpaper/</file>.

<p>The <file>dists</file> directories are still used for the index files used by
programs like <prgn>apt</prgn>. Also, at the time of writing, older
distributions have not been converted to use pools, so you'll see paths
containing distribution names such as <tt>potato</tt> or <tt>woody</tt> in the
"Directory" header field.

<p>Normally, you won't have to worry about any of this, as new <prgn>apt</prgn> and
probably older <prgn>dpkg-ftp</prgn> (see <ref id="howtocurrent">) will handle it
seamlessly. If you want more information, see the
<url id="&pool-faq;" name="RFC: implementation of package pools">.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Historical notes about Sid

<p>When the present-day Sid did not exist, the <!--FTP removed --> 
Debian archive site organization had one major flaw: there was an assumption
that when an architecture was created in the current <file>unstable/</file>, it
would be released when that distribution became the new <tt>stable</tt>. For
many architectures that wasn't the case, with the result that those
directories had to be moved at release time. This was impractical because the
move would chew up lots of bandwidth.

<p>The archive administrators worked around this problem for several years by
placing binaries for unreleased architectures in a special directory called
<file>sid</file>. For those architectures not yet released, the first time they
were released there was a link from the current <file>stable/</file> to
<file>sid/</file>, and from then on they were created inside the <file>unstable/</file>
tree as usual. This layout was somewhat confusing to users.

<p>With the advent of package pools (see <ref id="pools">) during the 
Woody distribution development, binary packages
began to be stored in a canonical location in the pool, regardless of the
distribution, so releasing a distribution no longer causes large bandwidth
consumption on the mirrors (there is, however, a lot of gradual bandwidth
consumption throughout the development process).

<sect1 id="incoming">Uploaded packages in <file>incoming/</file>
<p>
Uploaded packages are first located at <url id="&incoming;"> 
after being checked to insure that they really come from a Debian
developer (and are put in the <file>DELAYED</file> subdirectory in the case of
a Non-Maintainer Upload (NMU)).  Once a day, they are moved out of
<file>incoming/</file> to <file>unstable/</file>.
<p>
In an emergency, you may want to install packages from <file>incoming/</file>
before they reach <file>unstable/</file>.  
</sect1>

<sect1 id="snapshot">Retrieving an older package
<p>
While the most recent Debian distributions are kept under the <file>debian</file>
directory on each <url id="&mirror-site;" name="Debian mirror site">, 
archives for older Debian distributions such as Slink are kept 
on <url id="&archivehome;"> or under the <file>debian-archive</file> 
directory on each Debian mirror site.
<p>
Older <tt>testing</tt> and <tt>unstable</tt> packages can be located at
<url id="&snapshothome;">.

</sect1>

<sect1 id="archsections">Architecture sections
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>Within each of the major directory trees (<file>dists/stable/main</file>,
<file>dists/stable/contrib</file>, <file>dists/stable/non-free</file>, 
<file>dists/unstable/main/</file>, etc.), the binary package entries reside in
subdirectories whose names indicate the chip architecture for which they
were compiled.

<list>
  <item><file>binary-all/</file>, for packages which are architecture-independent.
    These include, for example, Perl scripts, or pure documentation.
  <item><file>binary-<var>platform</var>/</file>, for packages which execute on a particular
  binary platform.
  <!-- Yes I simplified this -->
</list>

<p>Please note that the actual binary packages for <tt>testing</tt> and
<tt>unstable</tt> no longer reside in these directories, but in the top-level
<file>pool</file> directory. The index files (<file>Packages</file> and
<file>Packages.gz</file>) have been kept, though, for backwards compatibility.

<p>For the actual binary architectures supported, see the Release Notes 
for each distribution.  They can be located at the Release Notes sites
for <url id="&stable-release;" name="stable"> and
<url id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">The source code

<p>Source code is included for everything in the Debian system. Moreover,
the license terms of most programs in the system <strong>require</strong> that
source code be distributed along with the programs, or that an offer to
provide the source code accompany the programs.

<p>Normally the source code is distributed in the <file>source</file> directories,
which are parallel to all the architecture-specific binary directories, or
more recently in the <file>pool</file> directory (see <ref id="pools">). To
retrieve the source code without having to be familiar with the structure of
the <!--FTP--> Debian archive, try a command like <tt>apt-get source 
<var>mypackagename</var></tt>.

<p>Some packages, notably <package>pine</package>, are only available in
a source package due to their licensing limitations.  (Recently the
<package>pine-tracker</package> package has been provided to facilitate Pine
installation.) The procedures described in <ref id="port"> and <ref
id="packaging"> provide ways to build a package manually.

<p>Source code may or may not be available for packages in the
<file>contrib</file> and <file>non-free</file> directories, which are not
formally part of the Debian system.

<sect id="pkg-basics">The Debian package management system

<sect1 id="package-basics">Overview of Debian packages

<p>Packages generally contain all of the files necessary to implement
a set of related commands or features.  There are two types of Debian
packages:
<list>
  <item><strong>Binary packages</strong>, which contain executables, configuration
  files, man/info pages, copyright information, and other documentation.
  These packages are distributed in a Debian-specific archive format
  (see <ref id="deb-format">); they are usually distinguished by having
  a <tt>.deb</tt> file extension. Binary packages can be unpacked using the Debian
  utility <prgn>dpkg</prgn>; details are given in its manual page.
  
  <item><strong>Source packages</strong>, which consist of a <tt>.dsc</tt> file
  describing the source package (including the names of the following
  files), a <tt>.orig.tar.gz</tt> file that contains the original
  unmodified source in gzip-compressed tar format, and usually a
  <tt>.diff.gz</tt> file that contains the Debian-specific changes to the
  original source.  The utility <prgn>dpkg-source</prgn> packs and unpacks
  Debian source archives; details are provided in its manual page.
</list>

<p>Installation of software by the package system uses "dependencies" which
are carefully designed by the package maintainers.  These dependencies are
documented in the <file>control</file> file associated with each package.
For example, the package containing the GNU C compiler (<package/gcc/)
"depends" on the package <package/binutils/ which includes the linker and
assembler. If a user attempts to install <package/gcc/ without having first
installed <package/binutils/, the package management system (dpkg) will send
an error message that it also needs <package/binutils/, and stop installing
<package/gcc/. (However, this facility can be overridden by the insistent
user; see <manref name="dpkg" section="8">.)  For additional details, see
<ref id="depends"> below.

<p>Debian's packaging tools can be used to:
<list>
  <item>manipulate and manage packages or parts of packages,
  <item>aid the user in the splitting of packages that must be transmitted
    through a limited-size medium such as floppy disks,
  <item>aid developers in the construction of package archives, and
  <item>aid users in the installation of packages which reside on a remote
    <!--FTP-->Debian archive site.
</list>

<sect1 id="deb-format">Debian <!--binary--> package format

<p>A Debian "package", or a Debian archive file, contains the executable
files, libraries, and documentation associated with a particular program
suite or set of related programs.  Normally, a Debian archive file has
a filename that ends in <tt>.deb</tt>.
<footnote>
<!-- Below added by Osamu based on a message posted by Colin Watson -->
<p>The <prgn>debian-installer</prgn> project introduced package filenames
that ends in <tt>.udeb</tt>.  In short, it is a micro-<tt>.deb</tt>
format which doesn't need to follow Debian policy exactly, lacks
contents such as documentation and is meant to be used only by the
<prgn>debian-installer</prgn>, the new Debian installer being 
developed for the Sarge release.  The file format of <tt>.deb</tt> and
<tt>.udeb</tt> are identical.  The <prgn>udpkg</prgn> program used to handle
<tt>.udeb</tt> packages has limited capability than standard
<prgn>dpkg</prgn> and supports fewer package relationships.  The
difference in name is because the Debian archive maintainers weren't
happy with <tt>.deb</tt>s in the archive that didn't follow policy, so a
different name was chosen to accentuate this and to make it less likely
that people would unwittingly install them on real systems. <tt>.udeb</tt>s
are used in an initial ramdisk during the base install only to create a
very restricted Debian system.
</footnote>

<p>The internals of this Debian binary package format are described in the
<manref name="deb" section="5"> manual page. Because this internal format is
subject to change (between major releases of &debian;), always use
<manref name="dpkg-deb" section="8"> for manipulating <tt>.deb</tt>
files.

<!-- Below added by Osamu Not sure but should be right -->

<p>Through at least the Sarge distribution, all Debian archive files
have been manipulable by the standard Unix commands <prgn>ar</prgn> and
<prgn>tar</prgn>, even when <prgn>dpkg</prgn> commands are not available.


<sect1 id="pkgname">Naming conventions for Debian package filenames
<!--
Why are Debian package filenames so long? 
-->
<p>The Debian <!--binary--> package filenames conform to the following convention:
<example>
<var>foo</var>_<var>VersionNumber</var>-<var>DebianRevisionNumber</var>.deb
</example>
where <var>foo</var> represents the package name. As a check,
one can determine the package name associated with a particular Debian archive
file (<tt>.deb</tt> file) in one of these ways:
<list>
  <item>inspect the "Packages" file in the directory where it was stored
  at a Debian <!--FTP--> archive site.  This file contains a stanza describing
  each package; the first field in each stanza is the formal package name.
  
  <item>use the command <tt>dpkg --info <var>foo_VVV-RRR</var>.deb</tt> (where
  <var>VVV</var> and <var>RRR</var> are the version and revision of the
  package in question, respectively).  This displays, among other things, the
  package name corresponding to the archive file being unpacked.
</list>

<p>The <var>VVV</var> component is the version number specified by the
upstream developer.  There are no standards governing version numbers, so they
may have formats as different as "19990513" and "1.3.8pre1".

<p>The <var>RRR</var> component is the Debian revision number, and is
specified by the Debian developer (or an individual user if he chooses
to build the package himself).  This number corresponds to the revision
level of the Debian package; thus, a new revision level usually signifies
changes in the Debian makefile (<file>debian/rules</file>), the Debian control
file (<file>debian/control</file>), the installation or removal scripts
(<file>debian/p*</file>), or the configuration files used with the package.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Preservation of the local configuration
<!--
What is a Debian conffile
-->
<p>Preservation of user-configurable files is enabled through &debian;'s
"conffiles" mechanism.  User configuration files (usually placed in
<file>/etc/</file>) are specified in the <file>conffiles</file> within the Debian
package system.  The package management system guarantees not to overwrite
these files when the package is upgraded.
<p>
When it is possible to configure the system without modifying files that belong
to various &debian; packages, it is usually a good idea not to modify them
even if they are "conffiles".  This ensures faster and smoother upgrade
operations.
<!--
<p>Conffiles is a list of configuration files (usually placed in <file>/etc</file>)
that the package management system will not overwrite when the package is
upgraded. This ensures that local values for the contents of these files
will be preserved, and is a critical feature enabling the in-place upgrade
of packages on a running system.
-->
<p>To determine exactly which files are preserved during an upgrade, run:
<example>
dpkg --status <var>package</var>
</example>
and look under "Conffiles:".

<p>
Specifics regarding the contents of a Debian <file>conffiles</file> file are
provided in the Debian Policy Manual, section 11.7 (see <ref id="references">).

<sect1 id="maintscripts">Debian maintenance scripts
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian maintenance scripts
are executable scripts which are automatically run before
or after a package is installed. Along with a file named <file>control</file>,
all of these files are part of the "control" section of a Debian archive file.

<p>The individual files are:
<taglist>
<tag/preinst/
  <item>This script executes before its package is unpacked from its
  Debian archive (<tt/.deb/) file. Many "preinst" scripts stop services for
  packages which are being upgraded until their installation or upgrade is
  completed (following the successful execution of the "postinst" script).

<tag/postinst/
  <item>This script typically completes any required configuration of a
  package once it has been unpacked from its Debian
  archive (<tt/.deb/) file. Often, "postinst" scripts ask the user for input,
  and/or warn the user that if he accepts default values, he should remember
  to go back and reconfigure the package as the situation warrants.
  Many "postinst" scripts then execute any commands necessary to start or
  restart a service once a new package has been installed or upgraded.

<tag/prerm/
  <item>This script typically stops any daemons which are associated with
  a package.  It is executed before the removal of files associated with
  the package.

<tag/postrm/
  <item>This script typically modifies links or other files associated with
  a package, and/or removes files created by it. (Also see
  <ref id="virtual">.)
</taglist>

<p>Currently all of the control files can be found in the directory
<file>/var/lib/dpkg/info</file>. The files relevant to package <tt>foo</tt>
begin with the name "foo" and have file extensions of "preinst", "postinst",
etc., as appropriate.  The file <file>foo.list</file> in that directory
lists all of the files that were installed with the package <tt>foo</tt>.
(Note that the location of these files is a <prgn>dpkg</prgn> internal, and may be
subject to change.)

<sect1 id="priority">Package priorities
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Each Debian package is assigned a <strong>priority</strong> by the distribution
maintainers, as an aid to the package management system.  The priorities are:

<list>
  <item><strong>Required</strong> packages are necessary for the proper
    functioning of the system.
    <p>This includes all tools that are necessary to repair system defects.
    You must not remove these packages or your system may become totally
    broken and you may not even be able to use <prgn>dpkg</prgn> to 
    restore things.  Systems with only the Required packages are probably
    inadequate for most purposes, but they do have enough functionality to
    allow the sysadmin to boot and install more software.
  <item><strong>Important</strong> packages should be found on any Unix-like
    system.
    <p>Other packages without which the system will not run well or be usable 
    will carry this priority. This does <strong>not</strong> include Emacs or
    X11 or TeX or any other large applications. These packages only constitute
    the bare infrastructure.
  <item><strong>Standard</strong> packages are standard on any Linux system,
    including a reasonably small but not too limited character-mode system.
    <p>This is what will install by default if users do not select anything
    else. "Standard" does not include many large applications, but it does
    include Emacs (this is more a piece of infrastructure than an application)
    and a reasonable subset of TeX and LaTeX (if this turns out to be possible
    without X).
  <item><strong>Optional</strong> packages include all those that you might
    reasonably want to install even if you are unfamiliar with them, and if
    you don't have specialized requirements.
    <p>This includes X11, a full TeX distribution, and lots of applications.
  <item><strong>Extra</strong> packages either conflict with others
    with higher priorities, have little use to users who are unfamiliar
    with them, or have specialized requirements that make them
    unsuitable for "Optional".
</list>
<p>Please note the differences among "Priority: required", "Section:
base" and "Essential: yes" in the package description.  "Section: base"
means that this package is installed before everything else on a new
system. Most of the packages in "Section: base" have the "Priority:
required" or at least "Priority: important", and many of them are
tagged with "Essential: yes".  "Essential: yes" means that this package
requires to specify an extra force option to the package management
system such as <prgn>dpkg</prgn> when removing from the system.  For
example, <package>libc6</package>, <package>mawk</package>, and
<package>makedev</package> are "Priority: required" and "Section: base"
but are not "Essential: yes".

<sect1 id="virtual">Virtual packages

<p>A virtual package is a generic name that applies to any one of a group
of packages, all of which provide similar basic functionality. For example,
both the <prgn>tin</prgn> and <prgn>trn</prgn> programs are news readers, and either
one should therefore satisfy any dependency of a program that requires a news
reader on a system in order to work or to be useful. They are therefore both
said to provide the "virtual package" called <package>news-reader</package>.

<p>Similarly, many packages such as <package>exim</package>, 
<package>exim4</package>, <package>sendmail</package>, and 
<package>postfix</package>, provide the
functionality of a mail transport agent.  They are therefore said to
provide the virtual package <package>mail-transport-agent</package>.
If either one is installed, then any program depending on the
installation of a mail transport agent will be satisfied by
the existence of this virtual package.

<p>Debian has a mechanism so that, if more than one package which
provides the same virtual package is installed on a system, the system
administrator can set one as the preferred package. The relevant command
is <prgn>update-alternatives</prgn>, and is described further in
<ref id="alternatives">.

<sect1 id="depends">Package dependencies
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>The Debian package system has a range of package "dependencies"
which are designed to indicate (in a single flag) the level at which
Program A can operate independently of the existence of Program B on
a given system:
<list>
  <item>Package A <strong>depends</strong> on Package B if B absolutely must be
  installed in order to run A.  In some cases, A depends not only on B, but on
  a specific version of B.  In this case, the version dependency is usually a
  lower limit, in the sense that A depends on any version of B more recent
  than some specified version.
  <item>Package A <strong>recommends</strong> Package B if the package maintainer
    judges that most users would not want A without also having the
    functionality provided by B.
  <item>Package A <strong>suggests</strong> Package B if B contains files that
    are related to (and usually enhance) the functionality of A.
  <item>Package A <strong>conflicts</strong> with Package B when A will not
    operate if B is installed on the system.  Most often, conflicts are
    cases where A contains files which are an improvement over those in B.
    "Conflicts" status is often combined with "replaces".
  <item>Package A <strong>replaces</strong> Package B when files installed
    by B are removed and (in some cases) overwritten by files in A.
  <item>Package A <strong>provides</strong> Package B when all of the files and
    functionality of B are incorporated into A.  This mechanism provides
    a way for users with constrained disk space to get only that part of
    package A which they really need.
</list>

<p>More detailed information on the use of each these terms can be found
in the <em>Packaging Manual</em> and the <em>Policy Manual</em>.

<p>Note that <prgn>dselect</prgn> has more fine-grained 
control over packages specified by <strong>recommends</strong> and 
<strong>suggests</strong> than <prgn>apt-get</prgn>, which simply pulls all 
the packages specified by <strong>depends</strong> and leaves all
the packages specified by <strong>recommends</strong> and <strong>suggests</strong>.  Both programs in modern 
form use APT as their back end.

<sect1 id="pre-depends">The meaning of "pre-depends"

<p>"Pre-depends" is a special dependency. In the case of an ordinary package,
<prgn>dpkg</prgn> will unpack its archive file (i.e., its <tt>.deb</tt> file)
independently of whether or not the files on which it depends exist on the
system.  Unpacking basically means that <prgn>dpkg</prgn> will extract
the files from the archive file that were meant to be installed on your
filesystem, and put them in place.  If those packages <strong>depend</strong> on
the existence of some other packages on your system, <prgn>dpkg</prgn> will
refuse to complete the installation (by executing its "configure" action)
until the other packages are installed.

<p>However, there are some packages that <prgn>dpkg</prgn> will refuse even to
unpack until certain dependencies are resolved.  Such packages are said to
"pre-depend" on the presence of some other package(s).  The Debian project
provided this mechanism to support the safe upgrading of systems from
<tt>a.out</tt> format to ELF format, where the <strong>order</strong> in which
packages were unpacked was critical. There are other large upgrade situations
where this method is useful, e.g., for packages with "required" priority and
their libc dependency.

<p>Once again, more detailed information about this can be found in the
<em>Packaging Manual</em>.

<sect1 id="pkgstatus">Package status
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Package status can be "unknown", "install", "remove", "purge", or 
"hold".
These "want" flags indicate what the user wanted to do with a package (either
by making choices in the "Select" section of <prgn>dselect</prgn>, or by
directly invoking <prgn>dpkg</prgn>).

<p>Their meanings are:
<list compact>
  <item><strong>unknown</strong>  - the user has never indicated whether he
                wants the package.
  <item><strong>install</strong>  - the user wants the package installed or
                upgraded.
  <item><strong>remove</strong>   - the user wants the package removed, but
                does not want to remove any existing configuration files.
  <item><strong>purge</strong>    - the user wants the package to be
                removed completely, including its configuration files.
  <item><strong>hold</strong>     - the user wants this package not to be
                processed, i.e., he wants to keep the current version with the current
                status, whatever that is.
</list>

<sect1 id="puttingonhold">Holding back packages from an upgrade
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>There are two mechanisms for holding back packages from an upgrade, 
through <prgn>dpkg</prgn>, or, beginning with Woody, through APT.

<p>With <prgn>dpkg</prgn>, first export the list of package selections:
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
Then edit the resulting file <file><var>selections.txt</var></file>, changing the line
containing the package you wish to hold, e.g. <package/libc6/, from this:
<example>
libc6                       install
</example>
to this:
<example>
libc6                       hold
</example>
Save the file, and reload it into <prgn>dpkg</prgn> database with:
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
Or, if you know the package name to hold, simply run:
<example>
echo libc6 hold | dpkg --set-selections
</example>
This procedure holds packages at the install process of each package file.

<p>The same effect can be obtained through <prgn>dselect</prgn>. Simply enter
the [S]elect screen, find the package you wish to hold in its present state,
and press the `=' key (or `H'). The changes will take effect immediately after
you exit the [S]elect screen.

<p>The APT system in the Woody distribution has a new alternative mechanism
for holding packages during the archive retrieval process using
<tt>Pin-Priority</tt>.  See the manual page <manref name="apt_preferences"
section="5">, along with <url id="&apt-howto;"> or the
<package>&p-apt-howto;</package> package; <ref id="apt-preferences"> also
contains a brief explanation.

<sect1 id="sourcepkgs">Source packages

<p>
Source packages are distributed in a directory called <file>source</file>, and
you can either download them manually, or use
<example>
apt-get source <var>foo</var>
</example>
to fetch them (see the <manref name="apt-get" section="8"> manual page on how
to set up APT for doing that).


<sect1 id="sourcebuild">Building binary packages from a source package

<p>For a package <tt><var>foo</var></tt>, you will need all of <file><var>foo_*</var>.dsc</file>,
<file><var>foo_*</var>.tar.gz</file>, and <file><var>foo_*.diff</var>.gz</file> to compile the source
(note: there is no <tt>.diff.gz</tt> for a Debian native package).

<p>Once you have them, if you have the <package/dpkg-dev/ package installed,
the command
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
will extract the package into a directory called 
<tt><var>foo-version</var></tt>.

<p>Issue the following command to build the binary package:
<example>
$ cd foo-version
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
Then,
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
to install the newly built package. See <ref id="port">.

<!-- Woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Creating new Debian packages

<p>For detailed information on creating new packages, read the <em>New
Maintainers' Guide</em>, available in the <package/maint-guide/ package, or at <url
id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Upgrading a Debian system

<p>One of Debian's goals is to provide a consistent upgrade path and a secure
upgrade process, and we always do our best to make a new release smoothly
upgradable from the previous ones.  Packages will alert the user when there
are important notices during the upgrade process, and will often provide a
solution to a possible problem.

<p>You should also read the Release Notes, the document that describes the
details of specific upgrades, shipped on all Debian CDs, and available on
the WWW at <url id="&stable-release;"> or <url id="&testing-release;">.

<p>
A practical guide to upgrades is provided in <ref id="package">.  This section 
describes the fundamental details.

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Methods for upgrading a Debian system

<p>One can always simply execute an anonymous FTP or <prgn>wget</prgn> call to
a Debian archive, peruse the directories until one finds a desired file, fetch
it, and finally install it using <prgn>dpkg</prgn>.  (Note that
<prgn>dpkg</prgn> will install upgrade files in place, even on a running
system.)  Sometimes, however, a revised package will require the installation
of a newly revised version of another package, in which case the installation
will fail until/unless the other package is installed.

<p>Many people find this manual approach much too time-consuming, since Debian
evolves so quickly&mdash;typically, a dozen or more new packages are
uploaded every week.  This number is larger just before a new major release.
To deal with this avalanche, many people prefer to use an automated program
for upgrading.  Several specialized package management tools are available for
this purpose.

<sect1 id="pkgtools">Package management tools overview

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>The Debian package management system has two objectives: the manipulation 
of the package file itself and the retrieval of package files from 
the Debian archive.  <prgn>dpkg</prgn> performs the former task, APT and
<prgn>dselect</prgn> the latter.

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>This is the main program for manipulating package files; read
<manref name="dpkg" section="8"> for a full description.
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> comes with several primitive supplemental programs.

<list>
<item><prgn>dpkg-deb</prgn>: Manipulate <tt>.deb</tt> files. 
 <manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>: An older package file retrieval command. 
 <manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>: An older package file retrieval command. 
 <manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>: Splits a large package into smaller files. 
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> and <prgn>dpkg-mountable</prgn> have been superseded
by the introduction of the APT system.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT (the Advanced Packaging Tool) is an advanced interface to the Debian
packaging system consisting of several programs whose names typically begin
with "apt-". 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn>, and <prgn>apt-cdrom</prgn> 
are the command-line tools for handling packages.  These also function 
as the user's "back end" programs to other tools, such as <prgn/dselect/ 
and <prgn/aptitude/.

<p>For more information, install the <package/apt/ package and read
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (Woody), and
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>An alternative source of information is the
<url id="&apt-howto;" name="APT HOWTO">.
This can be installed by <package/apt-howto/ at
<file>&f-apt-howto;</file>.

<p><tt>apt-get upgrade</tt> and <tt>apt-get dist-upgrade</tt>
pull only the packages listed under "Depends:" and overlook all 
the packages listed under "Recommends:" and "Suggests:".
To avoid this, use <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>This program is a menu-driven user interface to the Debian package management
system. It is particularly useful for first-time installations and
large-scale upgrades.  See <ref id="dselect">.

<p>For more information, install the <package/install-doc/ package and read
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> or
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single-user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <prgn>start-stop-daemon</prgn> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Upgrading a running system

<p>The kernel (filesystem) in &debian; systems supports replacing files even
while they're being used.

<p>We also provide a program called <prgn/start-stop-daemon/ which is used
to start daemons at boot time or to stop daemons when the kernel runlevel is
changed (e.g., from multiuser to single-user or to "halt"). The same program
is used by installation scripts when a new package containing a daemon is
installed, to stop running daemons, and to restart them as necessary.

<p>Note that the Debian system does not require 
use of the single-user mode to upgrade a running system.

<sect1 id="savedebs">Downloaded and cached <tt>.deb</tt> archive files

<p>If you have manually downloaded package files to your disk (which is not
absolutely necessary, see above for the description of <prgn>dpkg-ftp</prgn>
or APT), then after you have installed the packages, you can remove the
<tt>.deb</tt> files from your system.

<p>If APT is used, these files are cached in the
<file>/var/cache/apt/archives</file> directory.  You may erase them after
installation (<tt>apt-get clean</tt>) or copy them to another machine's
<file>/var/cache/apt/archives</file> directory to save downloading during
subsequent installations.

<sect1 id="keepingalog">Record-keeping for upgrades

<p><prgn/dpkg/ keeps a record of the packages that have been unpacked,
configured, removed, and/or purged, but does not (currently) keep a log
of terminal activity that occurred while a package was being so manipulated.

<p>The simplest way to work around this is to run your
<prgn>dpkg</prgn>, <prgn>dselect</prgn>, <prgn>apt-get</prgn>, etc.,
sessions within the <manref name="script" section="1"> program.

<sect id="boot">The Debian boot process

<sect1 id="init">The <prgn>init</prgn> program

<p>Like all Unices, Debian boots up by executing the program <prgn>init</prgn>.
The configuration file for <prgn>init</prgn> (which is <file>/etc/inittab</file>)
specifies that the first script to be executed should be
<file>/etc/init.d/rcS</file>.
<p>
What happens next depends on whether the <package>sysv-rc</package>
package or the <package>file-rc</package> package is installed.
The following assumes that the <package>sysv-rc</package> package
is installed.  (<package>file-rc</package> contains its own
<file>/etc/init.d/rcS</file> script and uses a file instead of
symlinks in rc directories to control which services are started
in which runlevels.)
<p>
The <file>/etc/init.d/rcS</file> file from the <package>sysv-rc</package>
package runs all of the scripts in <file>/etc/rcS.d/</file> in order
to perform initialization such as checking and mounting file
systems, loading modules, starting the network services,
setting the clock, and so on.
Then, for compatibility, it also runs all the files
(except those with a `.' in the filename)
in <file>/etc/rc.boot/</file>.
The latter directory is reserved for system administrator use,
and using it is deprecated.
See <ref id="init-hints"> and
<url id="&sysvinit;" name="System run levels and init.d scripts">
in the Debian Policy Manual for more info.
<p>
Debian does not use a BSD-style <tt>rc.local</tt> directory.

<sect1 id="runlevels">Runlevels

<p>After completing the boot process, <prgn>init</prgn> starts all
services that are configured to run in the default runlevel.
The default runlevel is given by the entry for <tt>id</tt> in
<file>/etc/inittab</file>.
Debian ships with <tt>id=2</tt>.
<p>
Debian uses 7 runlevels:
<list compact>
  <item>0 (halt the system),
  <item>1 (single-user mode),
  <item>2 through 5 (various multiuser modes), and
  <item>6 (reboot the system).
</list>
Runlevels 7, 8, and 9 can also be used but their rc directories are
not populated when packages are installed.
<p>
Switch runlevels using the <prgn>telinit</prgn> command.
<p>
If the <package>sysv-rc</package> package is installed
then in order to enter the default runlevel
all start scripts in <file>/etc/rc<var>runlevel</var>.d/</file>
(where <var>runlevel</var> is the default runlevel)
are executed.
The scripts in <file>/etc/rc<var>runlevel</var>.d</file> are in fact
just symbolic links back to scripts in <file>/etc/init.d/</file>.
However, the first letter in the name of the symbolic link
determines the <strong>way</strong> in which the script in
<file>/etc/init.d/</file> is run.
Specifically, before entering any runlevel,
all the scripts beginning with `K' are run; these scripts stop services.
Then all the scripts beginning with `S' are run;
these scripts start services.
The two-digit numbers following the `K' or `S' determine
the order in which the scripts are run:
lower-numbered scripts are executed first.

<p>This approach works because each script in <file>/etc/init.d/</file>
takes a "start" or a "stop" argument and acts appropriately.
Each script also accepts "restart" and "force-reload";
these methods can be used after a system has been booted
in order to restart services
or force them to reload their configuration files.

<p>For example:
<example>
# /etc/init.d/sendmail force-reload
</example>

<sect1 id="custombootscripts">Customizing the boot process
<p>
Suppose you want to add service <tt>foo</tt> to the set of those
services started after boot.
Take the following steps:
<enumlist>
  <item>Install initscript <file>/etc/init.d/foo</file>.
  <item>Execute <prgn>update-rc.d</prgn> with appropriate arguments.
</enumlist>

<sect id="diverse">Supporting diversity
<p>
Debian offers several avenues to accommodate any wishes of the system 
administrator without breaking the system. 
<list>
<item><prgn>dpkg-divert</prgn>, see <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, see <ref id="equivs">.
<item><prgn>update-alternative</prgn>, see <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> can accommodate many boot loaders. 
      See <manref name="make-kpkg" section="1"> and <ref id="kernel-debian">.
</list>
Any files under <file>/usr/local/</file> belong to the system administrator 
and &debian; will not touch them. Most files under <file>/etc/</file> are 
<!-- mtab is an exception -->
<tt>conffiles</tt> and &debian; will not overwrite them upon upgrade unless 
the system administrator requests so explicitly.

<sect id="i18n">Internationalization
<p>
The &debian; system is internationalized and provides support for character
display and entry in many languages, both within the console and under X. Many
documents, manual pages, and system messages have been translated into a
growing number of languages. During installation, Debian prompts the user to
choose an installation language (and sometimes a local language variant).
<p>
If your installed system does not support all the language features you need,
or if you need to change languages or install a different keyboard to support
your language, see <ref id="l10n">.

<sect id="kernel-details">Debian and the kernel
<p>
See <ref id="kernel">.

<sect1 id="non-debian-kernel">Compiling a kernel from non-Debian source

<p><!--Yes.  But you have-->
One has to understand the Debian policy with respect to headers.

<p>The Debian C libraries are built with the most recent <strong>stable</strong>
releases of the <strong>kernel</strong> headers.

<p>For example, the Debian-1.2 release used version 5.4.13 of the headers.
This practice contrasts with the Linux kernel source packages distributed
at all Linux FTP archive sites, which use even more recent versions of
the headers.  The kernel headers distributed with the kernel source are
located in <file>/usr/include/linux/include/</file>.

<p>If you need to compile a program with kernel headers that are newer
than those provided by <package/libc6-dev/, then you must add
<tt>-I/usr/src/linux/include/</tt> to your command line when compiling.
This came up at one point, for example, with the packaging of the
automounter daemon (<package/amd/).  When new kernels changed some
internals dealing with NFS, <prgn>amd</prgn> needed to know about them.
This required the inclusion of the latest kernel headers.

<sect1 id="customkernel">Tools to build custom kernels

<p>Users who wish to (or must) build a custom kernel are encouraged to
download the package <package/kernel-package/.  This package contains
the script to build the kernel package, and provides the capability to
create a Debian kernel-image package just by running the command
<example>
# make-kpkg kernel_image
</example>
in the top-level kernel source directory.
Help is available by executing the command
<example>
# make-kpkg --help
</example>
and through the manual page <manref name="make-kpkg" section="8">
and <ref id="kernel">.

<p>Users must separately download the source code for the most recent
kernel (or the kernel of their choice) from their favorite Linux archive
site, unless a kernel-source-<var>version</var> package is available 
(where <var>version</var> stands for the kernel version).  The Debian
<file>initrd</file> boot script requires a special kernel patch called
<prgn>initrd</prgn>; see <url id="&bug-initrd;">.

<p>Detailed instructions for using the <package/kernel-package/ package
are given in the file <file>/usr/share/doc/kernel-package/README.gz</file>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">Alternative boot loaders
<p>
To employ alternative boot loaders such as <package/grub/ or
<package/loadlin/, copy the compiled Linux kernel <file>bzimage</file> to
other locations (e.g., to <file>/boot/grub</file> or to an MS-DOS partition).
</sect1>

<sect1 id="custombootdisk">Custom boot floppies

<p>The task of making a custom boot floppy was greatly aided by the Debian
<!-- FIXME: boot-floppies is no package in Woody but an installation program
 Is this Potato specific? -->
package <package/boot-floppies/, used to be found in the <tt>admin</tt> section
of the Debian FTP archive for Potato and older. Shell scripts in this package produce boot
floppies in <prgn>syslinux</prgn> format.  These are MS-DOS formatted floppies
whose master boot records have been altered so that they directly boot Linux 
(or whatever other operating system has been defined in the
<file>syslinux.cfg</file> file on the floppy). Other scripts in this package
produce emergency root disks and can even reproduce the base disks.

<p>You will find more information about this in the
<file>/usr/doc/boot-floppies/README</file> file after installing the
<package/boot-floppies/ package.

<sect1 id="modules">Special provisions for dealing with modules

<p>Debian's <package/modconf/ package provides a shell script
(<file>/usr/sbin/modconf</file>) which can be used to customize the
configuration of modules.  This script presents a menu-based interface,
prompting the user for particulars on the loadable device drivers in his
system.  The responses are used to customize the file
<file>/etc/modules.conf</file> (which lists aliases, and other arguments that
must be used in conjunction with various modules) through files in
<file>/etc/modutils/</file>, and <file>/etc/modules</file> (which lists the
modules that must be loaded at boot time).

<p>Like the (new) <file>Configure.help</file> files that are now available to support
the construction of custom kernels, the <package/modconf/ package comes with a
series of help files (in <file>/usr/share/modconf/</file>) which provide
detailed information on appropriate arguments for each of the modules.
See <ref id="kernel-modules"> for examples.

<sect1 id="removeoldkernel">De-installing an old kernel package

<p>The <prgn>kernel-image-<var>NNN</var>.prerm</prgn> script checks to see whether
the kernel you are currently running is the same as the kernel you are trying
to de-install.  Therefore you can safely remove unwanted kernel image packages
using this command:

<example>
dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(Replace <var>NNN</var> with your kernel version and revision number, of
course.)
</sect>
