<!-- CVS revision of this document "$Revision: 1.9 $"  -->

<chapt id="tips"> &debian; tips

<![%FIXME[<p>===Proof reading: DONE by dsew ===]]>

<sect>Booting the system
<p>
See BootPrompt-HOWTO (LDP) for detailed information on the boot prompt.

<sect1 id="crackroot">"I forgot the root password!" (1)
<p>
It is possible to boot a system and log on to the root account without knowing
the root password as long as one has an access to the console keyboard.  (This
assumes there are no password requests from the BIOS or from a boot-loader
such as <prgn>lilo</prgn> that would prevent one from booting the system.)
<p>
This is a procedure which requires no external boot disks and
no change in BIOS boot settings. Here, "Linux" is the label for
booting the Linux kernel in the default Debian install.
<p>
At the <prgn>lilo</prgn> boot screen, as soon as <tt>boot:</tt> appears
(you must press a shift key at this point on some systems to prevent
automatic booting), enter:
<example>
boot: Linux init=/bin/sh
</example>
This causes the system to boot the kernel and run <file>/bin/sh</file> instead
of its standard <prgn>init</prgn>.  Now you have gained root privileges and a
root shell.  Since <file>/</file> is currently mounted read-only and many disk
partitions have not been mounted yet, you must do the following to have a
reasonably functioning system.
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(If the second data field in <file>/etc/passwd</file> is "x" for every
username, your system uses shadow passwords, and you must edit
<file>/etc/shadow</file>.) To disable the root password, edit the second data
field in the password file so that it is empty.  Now the system can be
rebooted and you can log on as root without a password.  Unlike some older
Linuxes, the current Debian (Potato) requires a password only when booting
into runlevel 1.
</sect1>

<sect1>"I forgot the root password!" (2)
<p>
Boot from any emergency boot/root disk set.  If <file>/dev/hda3</file> is the
original root partition, the following will let one edit the password file
just as easily as the above.
<example>
# mkdir fixit
# mount /dev/hda3 fixit
# cd fixit/etc
# vi shadow
# vi passwd
</example>
<p>
The advantage of this approach over the previous method is one does not need
to know the <prgn>lilo</prgn> password (if any).  But to use it one must be
able to access the BIOS setup to allow the system to boot from floppy disk or
CD, if that is not already set.
</sect1>

<sect1>Cannot boot the system
<p>
No problem, even if you didn't bother to make a boot disk during install.
If <prgn>lilo</prgn> is broken, grab the boot disk from the Debian installation set and
boot your system from it.  At the boot prompt, assuming the root partition of
your Linux installation is on <file>/dev/hda12</file> and you want runlevel 3, enter:
<example>
boot: rescue root=/dev/hda12 3
</example>
Then you are booted into an almost fully functional system using the kernel on
the floppy. (There may be minor glitches due to lack of kernel features or
modules.) 
<p>
If you need a custom boot floppy, follow <prgn>readme.txt</prgn> on the rescue disk.
</sect1>

<sect1 id="bootprompt">Other boot tricks with the boot prompt
<p>
The system can be booted into a particular runlevel and configuration
using the <prgn>lilo</prgn> boot prompt. Details are given in
BootPrompt-HOWTO (LDP).
<p>
If you want to boot the system into runlevel 4, use the following 
input at the <prgn>lilo</prgn> boot prompt.
<example>
boot: Linux 4
</example>
<p>
If you want to boot the system into normally functioning single-user mode
and you know the root password, one of the following examples at the
<prgn>lilo</prgn> boot prompt will work.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
If you want to boot the system with less memory than system actually has
(say 48MB for a system with 64MB), use this input at the <prgn>lilo</prgn>
boot prompt:
<example>
boot: Linux mem=48M
</example>
Make sure not to specify more than the actual memory size here, otherwise the
kernel will crash.  If one has more than 64MB of memory, e.g. 128MB, unless
one executes <tt>mem=128M</tt> at the boot prompt or includes a similar append
line in <file>/etc/lilo.conf</file>, old kernels and/or a motherboard with an
old BIOS will not use memory beyond 64MB.
</sect1>
</sect>

<sect>Recording activities
<sect1 id="script">Recording shell activities
<p>
System administration involves much more elaborate tasks in a Unix environment
than in an ordinary personal computer environment.  Make sure to know the most
basic means of configuration in case you need to recover from system trouble.
X-window-based GUI configuration tools look nice and convenient but are often
unsuitable in these emergency situations.
<p>
In this context, recording shell activities is a good practice,
especially as root.
<p>
Emacs: Use <tt>M-x shell</tt> to start recording into a buffer, and
use <tt>C-x C-w</tt> to write the buffer to a file.
<p>
Shell: Use the <prgn>script</prgn> command.
<example>
$ script
Script started, file is typescript
 ... do whatever ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
The following can be used instead of <prgn>script</prgn>:
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>
<sect1>Recording X activities
<p>
If you need to record the graphic image of an X application, including an
xterm display, use <prgn>gimp</prgn> (GUI).  It can capture each window or the whole
screen. Alternatives are <prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>), or <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>
</sect>

<sect>Copy and archive a whole subdirectory
<sect1>Basic commands for copying a whole subdirectory
<p>
If you need to rearrange file structure, move content including file links by:
<example>
Standard method:
# cp -a /source/directory /dest/directory # must be GNU
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
If hardlink is involved, petandic method is needed:
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
If remote:
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
If there are no linked files:
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
Here, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> and <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
Method of copy a whole subdirectory is based on the information provided by 
Manoj Srivastava &lt;srivasta@debian.org&gt; on debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Traditionally, cp was not really a candidate since it did not
derenference symbolic links, or preserve hard links
either. Another thing to consider was sparse files (with
holes).
<p>
GNU cp has overcome these limitations, however, on a non GNU
system, cp could still have problems. Also, you can't genrate
small, portable archives using cp.
<example>
% cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
Tar overcame some of the problems that cp had with symbolic
links. However, `cpio' handles special files; traditional
`tar' doesn't.
<p>								
`tar's way of handling multiple hard links to a file places
only one copy of the link on the tape, but the name attached
to that copy is the <em>only</em> one you can use to retrieve the
file; `cpio's way puts one copy for every link, but you can
retrieve it using any of the names.
</sect1>

<sect1><prgn>pax</prgn>
<p>
The new, POSIX (IEEE Std 1003.2-1992, pages 380-388 (section
4.48) and pages 936-940 (section E.4.48)), all singing, all
dancing, Portable archive interchange utility.  pax will read,
write, and list the members of an archive file, and will copy
directory hierarchies.  pax operation is independent of the
specific archive format, and supports a wide variety of
different archive formats.
<p>
pax implementations are still new and wet behind the ears.
<example>
$ pax -rw -p e . newdir
 or
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
copies files into or out of a cpio or tar archive, The archive
can be another file on the disk, a magnetic tape, or a pipe.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
Afio is a better way of dealing with cpio-format archives. It is
generally faster than cpio, provides more diverse magnetic tape
options and deals somewhat gracefully with input data corruption.  It
deals somewhat gracefully with input data corruption.  Supports
multi-volume archives during interactive operation.  Afio can make
compressed archives that are much safer than compressed tar or cpio
archives.  Afio is best used as an `archive engine' in a backup
script.
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
All my backups onto tape use afio. 
</sect1>

</sect>

<sect>Modify files with regular-expression substitution
<p>
Replace all instances of FROM_REGEX with TO_REGEX in
all of the files FILES ...:
<example>
# perl -i -p -e 's/FROM_REGEX/TO_REGEX/g;' FILES ...
</example>
<tt>-i</tt> is for "in-place editing", <tt>-p</tt> is for "implicit loop over
FILES ...".  If the substitution is complex, you can make recovery from errors
easier by using the parameter <tt>-i.bak</tt> instead of <tt>-i</tt>; this
will keep each original file, adding <tt>.bak</tt> as a file extension.
</sect>


<sect>System freeze recovery
<sect1>Kill process
<p>
Run <prgn>top</prgn> to see what process is acting funny. Press "P" to sort by cpu 
time, "M" to sort by memory, and "k" to kill a process.
<p>
Use <prgn>kill</prgn> to kill (or send a signal to) a process by process ID,
<prgn>killall</prgn> to do the same by process command name. Frequently used
signals:
<example>
 1: HUP,  restart daemon
15: TERM, normall kill
 9: KILL, kill hard
</example>

</sect1>

<sect1>ALT-SysRq
<p>
Insurance against system malfunction is provided by the kernel compile option
"Magic SysRq key".
Pressing <tt>ALT-SysRq</tt> on an i386, followed by one of the keys <tt>r 0 k
e i s u b</tt>,
does the magic.
<p>
Un<tt>R</tt>aw restores the keyboard after things like X crashes.  Changing
the console loglevel to <tt>0</tt> reduces error messages.  sa<tt>K</tt>
(system attention key) kills all processes on the current virtual console.
t<tt>E</tt>rminate kills all processes on the current terminal except init.
k<tt>I</tt>ll kills all processes except init.
<p>
<tt>S</tt>ync, <tt>U</tt>mount, and re<tt>B</tt>oot are for getting out of
really bad situations.
<p>
Debian default installation kernels are not compiled with this option at the
time this document is written.  Recompile the kernel to activate this
function.  Detailed information is in
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>

<sect>Config files

<sect1 id="loginctrl">Login control
<p>
<![%FIXME[<p>=== Expansion needed here ===]]>
<example>
/etc/securetty           # controls root login by console
/etc/hosts.{allow|deny}  # controls access to services by host
/etc/pam.d/login         # controls login
</example>
<p>
Comment out "ALL: PARANOID" in <file>/etc/hosts.deny</file> if it exists.
<p>
Change the content of <file>/etc/pam.d/login</file> as follows, if you want
insecure but passwordless console terminals at your own risk.
<example>
#auth       required   pam_unix.so nullok
auth       required   pam_permit.so
</example>
NFS and other RPC-based programs require the sunrpc portmapper for login
(<manref name="portmap" section="8">).
</sect1>

<sect1>Defaults
<p>
<example>
/etc/defaults/rcS        # boot defaults (motd, sulogin,...)
/etc/syslog.conf         # system log mode
</example>
Check the <package>colorize</package> package for a program to colorize system log files.
</sect1>
</sect>

<sect>Nifty little commands to remember
<sect1>Free memory
<p>
<prgn>free</prgn> and <prgn>top</prgn> give good information on memory
resources.  Do not worry about the size of "used" in the "Mem:" line, but read
the one under it (38792 in the example below). 
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
Exact physical memory can be confirmed by <tt>grep '^Memory'
/var/log/dmesg</tt>,
which in this case gives "Memory: 256984k/262144k available (1652k kernel
code, 412k reserved, 2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
About 5MB is not usable by the system because the kernel uses it.
</sect1>

<sect1>Set time (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
This will set system and hardware time to MM/DD hh:mm, CCYY.
Times are displayed in local time but hardware time uses UTC.
<p>
Set system clock to the correct time automatically via a remote server:
<example>
# ntpdate &lt;server&gt;
</example>
This is good to have in <file>/etc/cron.daily</file> if your system has a
permanent Internet connection.
</sect1>

<sect1>How to disable the screensaver
<p>
In the Linux console:
<example>
# setterm -powersave off
</example>
<p>
Start the kon2(kanji) console with:
<example>
# kon -SaveTime 0
</example>
<p>
While running X:
<example>
# xset s off
 or
# xset -dpms
 or
# xscreensaver-command -prefs
</example>
Read the corresponding man pages.
</sect1>

<sect1>Disable sound (beep)
<p>
One can always unplug the PC speaker ;-)  For the shell:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc:
</example>
</sect1>

<sect1>Error messages on the console screen
<p>
In order to quiet on-screen error messages, first place to check is 
<file>/etc/init.d/klogd</file>.  Set <tt>KLOGD="-c 4"</tt> in this script and 
run <tt>/etc/init.d/klogd restart</tt>.
<p>
Alternative method is to run <tt>dmesg -n1</tt>.
<p>
Another place to look may be <file>/etc/syslog.conf</file>.
<p>
</sect1>

<sect1>Get the console back to a sane state
<p>
When the screen goes berserk after <tt>$ cat binaryfile</tt> (you may not be able to
see the command echoed as you type):
<example>
$ reset
</example>
</sect1>

<sect1>Convert text file from DOS to Unix style
<p>
Convert a DOS (end-of-line=^M^J) text file to a Unix file(^J).
<example>
# apt-get install sysutils
$ dos2unix dosfile
</example>
</sect1>

<sect1>Convert a large file into small files
<p>
<example>
$ split -b 650m file   # split file into 650 MB chunks
$ cat x* >largefile    # merge files into 1 large file
</example>
</sect1>

<sect1>Script snippets for piping commands
<p>
The following scripts will do nice things as a part of a pipe.
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # find all files in /usr excluding some files
xargs -n 1 command   # run command for all items from stdin
xargs -n 1 echo|     # split white space separated items into lines
grep -e pattern|     # extract lines containing pattern
cut -d: -f3 -|       # extract third field separated by :  
                     # (passwd file etc.)
col -bx |            # remove backspace and expand tabs to spaces
expand -|            # expand tabs
sort -u|             # sort and remove duplicates
tr '\n' ' '|         # concatenate lines into one line
tr '\r' ''|          # remove CR
tr 'A-Z' 'a-z'|      # convert uppercase to lowercase
sed 's/^/# /'|       # make each line a comment
sed 's/\.ext//g'|    # remove .ext
sed  -n -e 2p|       # print the second line 
head -n 2 -|         # print the first 2 lines
tail -n 2 -|         # print the last 2 lines
</example>
</sect1>

<sect1>Get text or a mailing list archive from a web page
<p>
The following will read a Web page into a text file.
Very useful when copying configurations off the Web.
<example>
$ lynx -dump http://www.remote-site.com/help-info.html &gt;textfile
</example>
<p>
If this is a mailing list archive, use <tt>munpack</tt> to obtain mime contents from text.
</sect1>

<sect1>Time a command
<p>
Display time used by a process.
<example>
# time df >/dev/null
real    0m0.035s       # time on wall clock (elapsed real time)
user    0m0.000s       # time in user mode
sys     0m0.020s       # time in kernel mode
</example>
</sect1>

<sect1><prgn>nice</prgn> command
<p>
Use <prgn>nice</prgn> (from the GNU shellutils package) to set a command's
nice value when starting. <prgn>renice</prgn> (bsdutild) or <prgn>top</prgn>
can renice a process. A nice value of 19 represents the slowest (lowest
priority) process; negative values are "not-nice", with -20 being a very fast
(high priority) process. Only the superuser can set negative nice values.
<example>
# nice  -19 top                                         # very nice
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img # very fast
</example>
</sect1>

<sect1>Schedule activity (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Use <prgn>cron</prgn> and <prgn>at</prgn> to schedule tasks under Linux.
See <manref name="at" section="1">, <manref name="crontab" section="5">,
<manref name="crontab" section="8">. 
<p> 
Run the command <tt>crontab -e</tt> to create or edit a crontab file to set up
regularly scheduled events. Example of a crontab file:
<example>
# use /bin/sh to run commands, no matter what /etc/passwd says
SHELL=/bin/sh
# mail any output to `paul', no matter whose crontab this is
MAILTO=paul
# Min Hour DayOfMonth Month DayOfWeek command (Day... are ORed)
# run at 00:05, every day
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# run at 14:15 on the first of every month -- output mailed to paul
15 14 1  * *   $HOME/bin/monthly
# run at 22:00 on weekdays(1-5), annoy Joe. % for newline, last % for cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe%Joe,%%Where are your kids?%.%%
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# run at 03:40 on the first Monday of each month
40 3 1-7 * *   [ "$(date +%a)" == "Mon" ] && command -args
</example>
Run the <prgn>at</prgn> command to schedule a one-time job:
<example>
$ echo 'command -args'| at 3:40 monday
</example>
</sect1>

<sect1>Console switching with <prgn>screen</prgn>
<p>
The <prgn>screen</prgn> program allows you to run multiple virtual terminals, each with
its own interactive shell, on a single physical terminal or terminal emulation
window. Even if you use Linux virtual consoles or multiple xterm windows, it
is worth exploring <prgn>screen</prgn> for its rich feature set, which
includes scrollback history, copy-and-paste, output logging, digraph entry,
and the ability to detach an entire <prgn>screen</prgn> session from your
terminal and reattach it later. If you frequently log on to a Linux machine
from a remote terminal or using a VT100 terminal program, <prgn>screen</prgn>
will make your life much easier.
<p>
Once you start <prgn>screen</prgn>, all keyboard input is sent to your current
window except for the command keystroke, by default <tt>^A</tt>. All
<prgn>screen</prgn> commands are entered by typing <tt>^A</tt> plus a single
key [plus any parameters]. Useful commands:
<example>
^A ?     show a help screen (display key bindings)
^A c     create a new window and switch to it
^A n     go to next window
^A p     go to previous window
^A 0     go to window number 0
^A w     show a list of windows
^A a     send a Ctrl-A to current window as keyboard input
^A h     write a hardcopy of current window to file 
^A H     begin/end logging current window to file
^A ^X    lock the terminal (password protected)
^A d     detach screen session from the terminal
^A DD    detach screen session and log out
</example>
<prgn>screen</prgn>'s "detach" feature is very powerful. Suppose you are
logged in via a dialup connection, and are running a complex
<prgn>screen</prgn> session with editors and other programs open in several
windows. Suddenly you need to leave your terminal, but you don't want to lose
your work by hanging up. Simply type <tt>^A d</tt> to detach the session, then
log out. (Or, even quicker, type <tt>^A DD</tt> to have <prgn>screen</prgn>
detach and log you out itself.) When you log on again later, enter the command
<tt>screen -r</tt>, and <prgn>screen</prgn> will magically reattach all the windows
you had open. 
<p>
This is only a small subset of <prgn>screen</prgn>'s commands and features. If
there's something you want <prgn>screen</prgn> to be able to do, chances are
it can! "man screen" for details.
<p>
<em>Note:</em> If you find that backspace and/or Ctrl-H do not work properly
when you are running <prgn>screen</prgn>, edit <file>/etc/screenrc,</file>
find the line reading
<example>
bindkey -k kb stuff "\177"
</example>
and comment it out (i.e., add "#" as the first character). 
<![%FIXME[<p>=== Add "xmove" for X if desired ===]]>
</sect1>

<sect1>Network testing basics
<p>
Install  
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (for 2.2 Kernel),
<package>iptables</package> (for 2.4 Kernel), and
<package>net-tools</package> packages and:
<example>
$ ping yahoo.com            # check Internet connection
$ traceroute yahoo.com      # trace IP packets
$ ifconfig                  # check host config
$ route -n                  # check routing config
$ dig [@dns-server.com] host.dom [{a|mx|any}] |less
      # check host.dom DNS records [@ dns-server.com] for a [{mx|any}] 
      # record
$ ichains  -L -n |less      # check packet filter (2.2 kernel)
$ iptables -L -n |less      # check packet filter (2.4 kernel)
$ netstat -a                # find all open ports
$ netstat -l --inet         # find listening ports
$ netstat -ln --tcp         # find listening tcp ports (numeric)
</example>
</sect1>

<sect1>Flush mails from local spool
<p>
To flush mails from the local spool:
<example>
# exim -q    # flush waiting mails
# exim -qf   # flush all mails
# exim -qff  # flush even frozen mails
</example>
"-qff" may be better for /etc/ppp/ip-up.d/exim script.
</sect1>

<sect1>Remove frozen mails from local spool
<p>
To remove frozen mail from the local spool with the delivery error message:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Clear file contents
<p>
Do not use <tt>rm</tt> in case the file is accessed by others.
<example>
$ :>file-to-be-cleared
</example>
</sect1>

<sect1>Dummy files
<p>
<example>
$ dd if=/dev/zero    of=filename bs=1k count=5 # 5KB of zero content
$ dd if=/dev/urandom of=filename bs=1m count=7 # 7MB of random content
$ touch filename #  create 0B file or update mtime
</example>
</sect1>

<sect1>chroot
<p>
You can create an independent system that shares the same kernel.
<example>
# mount /dev/hda1 /mnt/target   
 ... supposing /dev/hda1 contains one whole system
# chroot /mnt/target
 ... Now the contents of /dev/hda1 are seen as the root directory.
# mount proc /proc              # just in case
 ... run command within /dev/hda1
</example>
This enables stable/testing/unstable to be loaded on one machine.  Also, one
may run a memory-hungry program such as <prgn>dselect</prgn> by running it on
a host machine while NFS-mounting a satellite machine to the host as r/w and
pointing <prgn>chroot</prgn> to the satellite machine.
<p>
chroot system can easily be created by <prgn>debootstrap</prgn> command 
in woody.
<example>
# mkdir potatochroot
# debootstrap potato potatochroot
# chroot potatochroot
# apt-setup # set-up /etc/apt/sources.list
</example>
</sect1>

<sect1>Samba
<p>
Basics of getting files from Windoze:
<example>
# mount -t smbfs -o username=myname,uid=my_uid,gid=my_gid \
        //server/share /mnt/smb  # mount Windows file to Linux
# smbmount //server/share /mnt/smb \
        -o "username=myname,uid=my_uid,gid=my_gid"
# smbclient -L 192.168.1.2 # list the shares on a computer
</example>
</sect1>

</sect>

</chapt>

