<!-- CVS revision of this document "$Revision: 1.47 $"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="tutorial">&debian; tutorials
<p>
<!-- new content -->
This section provides a basic orientation to the &debian; world for the
real newbie. If you have been using any Unix-like system for a while,
you probably know everything I explained here.  Please use this as a
reality check.

<sect id="first">Getting started
<p>
<!-- new content -->
After the installation of the &debian; system on your PC, you need to learn
few things to make it useful.  Let us give you an express training.

<sect1 id="login-root">Login to a shell prompt as root
<p>
<!-- new content -->
Upon rebooting the system, you will be presented either the graphical
login screen or the character based login screen depending on your
initial selection of packages.  For the sake of simplicity, if you are
presented with the graphical login screen, press Ctrl-Alt-F1 
<footnote>
The left-Ctrl-key, the left-Alt-key, and the F1-key are pressed together.
</footnote>
to gain the character based login screen. 
<p>
Suppose your hostname is <tt><var>foo</var></tt>, the login prompt looks
like:
<example>
<var>foo</var> login:
</example>
Type <tt>root</tt> , press the Enter-key and type the password which
you selected during the install process.   In the &debian; system,
following the Unix tradition, the password is case sensitive.  Then the
system starts with the greeting message and presents you with the root
command prompt waiting for your input.
<footnote>
Note that if you edited the greeting message in <file>/etc/motd</file>,
this will be different.
</footnote>
<example>
<var>foo</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
You are ready to perform the system administration from this root
command prompt.  This root account is also called superuser or
privileged user.  From this account, you can do anything:
<list compact>
<item>read, write, and remove any files on the system irrespective of their
file permissions
<item>set file ownership and permission of any files on the system
<item>set the password of any non-privileged users on the system
<item>login to any accounts without their passwords
</list>
<p>
It is extremely bad idea to share the access to the root account by
sharing the password. Use of program such as <manref name="sudo"
section="8"> is the good way to share the administrative privileges.
<p>
Please note that it is considered a good Unix habit to login to the
non-privileged user account first even when you plan to perform
administrative activities.  Use commands <tt>sudo</tt>, <tt>super</tt>,
or <tt>su -c</tt> to gain the limited root privileged when needed.
See <ref id="sudo">.
<footnote>
I have to admit I used to use the superuser account more often
than needed just because it was easy and I was sloppy.
</footnote>

<sect1 id="newbiefix">Set up minimal newbie environment
<p>
<!-- new content -->
I think learning a computer system is like learning a new foreign
language.  Although tutorial books are helpful, you have to practice it
with helper tools.  In this context, I think it is a good idea to
install few additional packages such as <package>mc</package>,
<package>vim</package>, <package>lynx</package>, 
<package>doc-linux-text</package> and 
<package>debian-policy</package>.
<footnote>
It may also be a good idea to install <package>gpm</package>,
<package>emacs21</package> and <package>doc-linux-html</package>.  See
<ref id="gpm"> and <ref id="edit">.
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
</example>
If you already had these packages installed, nothing will be installed.

<sect1 id="newuser">Add a user account
<p>
<!-- new content -->
During the installation, you usually created a non-privileged user account
who receives e-mails sent to the root account.  
<footnote>
I tend to name this account created during installation as
<tt>admin</tt> but this can be any arbitrary name. 
</footnote>
Since you do not want to use this special user account for the following
training activities either, you should create another new user account.
<p>
Suppose you wish this new username to be <tt><var>penguin</var></tt>,
type: 
<example>
root@<var>foo</var>:root# adduser <var>penguin</var>
... answer all the questions
</example>
will create it.  
<footnote>
You may want to add this user <tt><var>penguin</var></tt> to the
<tt>adm</tt> group to enable read access to the many logfiles in
<file>/var/log/</file>.  See <manref name="passwd" section="5">, <manref
name="group" section="5">, <manref name="shadow" section="5">, <manref
name="group" section="5">, <manref name="vipw" section="8">, and <manref
name="vigr" section="8">.  For the official meanings of users and
groups, see a recent version of the <url id="&f-users-and-groups;"
name="Users and Groups"> document.
</footnote>
Before going further, let's learn few things first.

<sect1 id="sw-console">Switch between virtual console
<p>
<!-- modified old content -->
In the default &debian; system, there are six independent
pseudo-terminals available, i.e., you can use the PC's VGA character
console screen as 6 switchable VT-100 terminals.  Switch from one to
another by pressing the Left-Alt-key and one of the F1&ndash;F6 keys
simultaneously.  Each pseudo-terminal allows independent login to
accounts. The multiuser environment is a great Unix feature, and very
addictive.
<p>
<!-- new content -->
If you accidentally typed Alt-F7 on a system running the X Window System and
the console screen displays graphic screen, regain the access to the
character console by pressing Ctrl-Alt-F1.  Just try to move to
different console and come back to the original one to get used to this.

<sect1 id="shutdown">How to shut down
<p>
<!-- heavily modified content -->
Just like any other modern OSs where the file operation involves caching
data in
the memory, the &debian; system needs the proper shutdown procedure
before power
can safely be turned off to maintain the integrity of files. Use the
following command from the root command prompt to shutdown the system:
<example>
# shutdown -h now
</example>
This is for the normal multiuser mode.  If you are in the single-user mode,
use following from the root command prompt:
<example>
# poweroff -i -f
</example>
Alternatively, you may type Ctrl-Alt-Delete to shutdown.
<footnote>
The left-Ctrl-key, the left-Alt-Key, and the Delete are pressed together
from the console.  In the default system, this will cause system reboot.
You need to modify <file>/etc/inittab</file> to have <prgn>shutdown</prgn>
command with <tt>-h</tt> option as described in <ref id="post-inst">.
</footnote>
<p>
Wait until the system displays "System halted" then shut off power.  If
the APM or ACPI function has been turned on by the BIOS and Linux properly, the
system will power down by itself.  See <ref id="apm"> for the detail.

<sect1 id="playtime">Play time
<p>
<!-- new content -->
Now you are ready to play with the &debian; system without risks as long
as you use this non-privileged user account <tt><var>penguin</var></tt>.
<footnote>
This is because the &debian; system is, even just after the default
installation, configured with the proper file permissions which prevent
non-privileged user to damage the system. Of course, there may still
exist some holes which can be exploited but those who worry about this
issue should not be reading this section but should be reading 
<url id="&securing-debian-howto;" name="Securing Debian Manual">.
</footnote>
<p>
Let's login to the <tt><var>penguin</var></tt>.   
If you are at root shell prompt, type Ctrl-D 
<footnote>
The left-Ctrl-key and the d-key are pressed together.  No need to press
the Shift-key even though these control characters are referred as
"control D" with the upper case.
</footnote>
at the root command prompt to close the root shell activity and return
to the login prompt.  Enter your newly created username
<tt><var>penguin</var></tt> and the corresponding password.
<footnote>
If you enter <tt>root</tt> instead of <tt><var>penguin</var></tt> here
and the corresponding password, you will gain the access to the
<tt>root</tt> account.  This procedure will be needed to regain the
access to the <tt>root</tt> account.
</footnote>
You will be presented with the following command prompt.
<example>
<var>penguin</var>@<var>foo</var>:<var>penguin</var>$ 
</example>
<p>
From here on, the example given will use simplified command prompt for
the sake of simplicity. I will use:
<list compact>
<item><tt>#</tt> : root shell prompt
<item><tt>$</tt> : non-privileged user shell prompt
</list>
<p>
We will start learning the &debian; system first with the easy way <ref
id="mc"> and later with the proper way <ref id="unixlike">.

<sect id="mc">Midnight Commander (MC)
<p>
<!-- old content -->
Midnight Commander (MC) is a GNU "Swiss army knife" for the Linux console and
other terminal environments.  This gives newbie a menu driven console
experience which is much easier to learn than standard Unix commands. 
<!-- New content -->
<p>
Use this command to explore the &debian; system.  This is the best way
to learn.  Please explore few key locations just using the cursor keys
and Enter key:
<list compact>
<item><file>/etc</file> and its subdirectories.
<item><file>/var/log</file> and its subdirectories.
<item><file>/usr/share/doc</file> and its subdirectories.
<item><file>/sbin</file> and <file>/bin</file>
</list>

<sect1 id="mc-enhance">Enhance MC
<p>
<!-- modified old content -->
In order to make MC to change working directory upon exit, you need to
modify <file>~/.bashrc</file> (or <file>/etc/bash.bashrc</file>, 
called from <file>.bashrc</file>), as detailed in its manual page,
<manref name="mc" section="1">, under the <tt>-P</tt> option.
<footnote>
If you do not understand what exactly I am talking here, you can do this
later.
</footnote>

<sect1 id="mc-start">Start MC
<p>
<!-- modified old content -->
<example>
$ mc
</example>
MC takes care of all file operations through its menu, requiring minimal 
user effort.  Just press F1 to get the help screen.  You can play with
MC just by pressing cursor-keys and function-keys.
<footnote>
If one is in a terminal, such as <prgn>kon</prgn> and <prgn>kterm</prgn> for
Japanese, that has issues with certain graphics characters, 
adding <tt>-a</tt> to
MC's command line may help prevent problems.
</footnote>

<sect1 id="mc-fm">File manager in MC
<p>
<!-- old content -->
The default is two directory panels containing file lists.  Another useful
mode is to set the right window to "information" to see file access privilege
information, etc. Following are some essential keystrokes. With the
<prgn>gpm</prgn> daemon
running, one can use a mouse, too.  (Make sure to press the shift-key to
obtain the normal behavior of cut and paste in MC.)
<list compact>
<item>F1: Help menu
<item>F3: Internal file viewer
<item>F4: Internal editor
<item>F9:  Activate pulldown menu
<item>F10: Exit Midnight Commander
<item>Tab: Move between two windows
<item>Insert: Mark file for a multiple-file operation such as copy
<item>Del: Delete file (be careful&mdash;set MC to safe delete mode)
<item>Cursor keys: Self-explanatory
</list>

<sect1 id="mc-cl">Command-line tricks in MC
<p>
<!-- old content -->
<list compact>
<item>Any <prgn>cd</prgn> command will change the directory shown on the selected screen.
<item>Ctrl-Enter or Alt-Enter will copy a filename to the command line. Use
this with the <prgn>cp</prgn> or <prgn>mv</prgn> command together with command-line editing.
<item>Alt-Tab will show shell filename expansion choices.
<item>One can specify the starting directory for both windows as arguments to
MC; for example, <tt>mc /etc /root</tt>.
<item>Esc + <var>numberkey</var> == F<var>n</var> (i.e.,
      Esc + `1' = F1, etc.;
      Esc + `0' = F10)
<item>Esc-key       == Alt-key (= Meta,
      M-); i.e., type Esc + `c' for Alt-C.
<!-- control characters are referred with the upper case. -->
</list>

<sect1 id="mcedit">Editor in MC
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
The internal editor has an interesting cut-and-paste scheme. Pressing
F3 marks the start of a selection, a second F3 marks
the end of selection and highlights the selection. Then you can move
your cursor. If you press F6, the selected area will be moved
to the cursor location. If you press F5, the selected area will
be copied and inserted at the cursor location.  F2 will save
the file. F10 will get you out. Most cursor keys work
intuitively.
<p>
This editor can be directly started on a file:
<example>
$ mc -e filename_to_edit
$ mcedit filename_to_edit
</example>
<p>
This is not a multi-window editor, but one can use multiple Linux consoles
to achieve the same effect. To copy between windows, use Alt-F<var>n</var> keys to switch
virtual consoles and use "File-&gt;Insert file" or "File-&gt;Copy to file"
to move a portion of a file to another file.
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I see .. but for now I do this not to hack LaTeX
-->
<p>
This internal editor can be replaced with any external editor of choice.
<p>
Also, many programs use environment variables <tt>EDITOR</tt> or 
<tt>VISUAL</tt> to decide which editor to use.  If you are uncomfortable
with <prgn>vim</prgn>, set these to <tt>mcedit</tt> by adding these lines to
<file>~/.bashrc</file>:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
I do recommend setting these to <tt>vim</tt> if possible.  Getting used to 
<prgn>vim</prgn> commands is the right thing to do, since Vi-editor is always there in 
the Linux/Unix world.
<footnote>
Actually, <prgn>vi</prgn> or <prgn>nvi</prgn> are the programs you find
everywhere. I chose <prgn>vim</prgn> insted for newbie since it offers
you help through F1 key while it is similar enough and more powerful.
</footnote>

<sect1 id="mc-view">Viewer in MC
<p>
<!-- almost old content -->
Very smart viewer. This is a great tool for searching words in documents.  I
always use this for files in the <file>/usr/share/doc</file> directory. This is the fastest
way to browse through masses of Linux information. This viewer can be directly
started like so:
<example>
$ mc -v filename_to_view
</example>

<sect1 id="ma-auto">Auto-start features of MC
<p>
<!-- almost old content, tar.gz and deb are new -->
Press Enter on a file, and the appropriate program will
handle the content of the file. This is a very convenient MC feature.
<example>
executable file:   Execute command
man, html file:    Pipe content to viewer software
tar.gz, deb file:  Browse its contents as if subdirectory
</example>
In order to allow these viewer and virtual file features to function, viewable
files should not be set as executable. Change their status using the
<prgn>chmod</prgn> command or via the MC file menu.

<sect1 id="mc-ftp">FTP virtual filesystem of MC
<p>
<!-- old content -->
MC can be used to access files over the Internet using FTP. Go to the menu
by pressing F9, then type `p' to activate the FTP virtual filesystem. Enter
a URL in the form <tt>username:passwd@hostname.domainname</tt>, which will retrieve a
remote directory that appears like a local one.
<p>
<!-- new content -->
Try <tt>&ftp-debian;</tt> as URL and browse &debian; file
archive.  See <ref id="ftparchives"> for how these are organized.

<sect id="unixlike">Unix-like work environment
<p>
<!-- new content -->
Although MC enables you to do almost everything, it is very important
for you to learn how to use the command line tools invoked from the
shell prompt and become familiar with the Unix-like work environment.
<footnote>
In this tutorial chapter, the shell means <prgn>bash</prgn>.  For more
insight into the different shells, see <ref id="shell">.
</footnote>

<sect1 id="sp-keys">Special key strokes
<p>
<!-- practically new content -->
In the Unix-like environment, there are few key strokes which have special
meanings.
<footnote>
On a normal Linux character console, only the left-hand Ctrl and Alt
keys work as expected.
</footnote>
<list compact>
<item>Ctrl-U: Erase line before cursor.
<item>Ctrl-H: Erase a character before cursor.
<item>Ctrl-D: Terminate input. (exit shell if you are using shell)
<item>Ctrl-C: Terminate a running program.
<item>Ctrl-Z: Temporarily stop program. (put it to the background
job, see <ref id="cmd-back">)
<item>Ctrl-S: Halt output to screen.
<footnote>
You can disable this terminal feature using 
<manref name="stty" section="1">.
</footnote>
<item>Ctrl-Q: Reactivate output to screen.
</list>
<p>
The default shell, <prgn>bash</prgn>, 
has history-editing and tab-completion capabilities to aide the
interactive use.
<list compact>
<item>up-arrow:  Start command history search.
<item>Ctrl-R:  Start incremental command history search.
<item>TAB: Complete input of the filename to the command line.
<item>Ctrl-V TAB: Input TAB without expansion to the command line.
</list>
<p>
Other important keystrokes to remember:
<list compact>
<item>Ctrl-Alt-Del:  Reboot/halt the system, see <ref id="post-inst">.
<item>Left-click-and-drag mouse: Select and copy to the clipboard.
<item>Click middle mouse button: Paste clipboard at the cursor.
<item>Meta-key (Emacs terminology) is assigned traditionally to
Left-Alt-key. Some system may be configured to use Windows-key for
Meta-key.
</list>
Here, in order to use a mouse in the Linux character console, you need to have
<prgn>gpm</prgn> running as daemon.
<footnote>
In the X Window environment, the mouse functions in the same way with
the Xterm program.
</footnote>
See <ref id="gpm">.

<sect1 id="unixcmds">Basic Unix commands
<p>
<!-- new content -->
Let's learn the basic Unix commands.  
<footnote>
Here I use "Unix" in its generic sense.  Any Unix clone OSs usually
offer the equivalent commands.  The &debian; system is no exception.  
Do not worry
if some commands do not work as you wish now.  These examples are not
meant to be executed in this order.
</footnote>
Try all the following commands from the non-privileged user account
<tt><var>penguin</var></tt> :
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>Display name of current/working directory.
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>Display current user name.
 </list>
<item><tt>file <var>foo</var></tt>
 <list compact>
 <item>Display a type of file for the file <var>foo</var>.
 </list>
<item><tt>type -p <var>commandname</var></tt>
 <list compact>
 <item>Display a file location of command <tt><var>commandname</var></tt>.
 <item><tt>which <var>commandname</var></tt> does the same.
 </list>
<item><tt>type <var>commandname</var></tt>
 <list compact>
 <item>Display information on command <tt><var>commandname</var></tt>.
 </list>
<item><tt>apropos <var>key-word</var></tt>
 <list compact>
 <item>Find commands related to <tt><var>key-word</var></tt>.
 <item><tt>man -k <var>key-word</var></tt> does the same.
 </list>
<item><tt>whatis <var>commandname</var></tt>
 <list compact>
 <item>Display one line explanation on command
  <tt><var>commandname</var></tt>.
 </list>
<item><tt>man -a <var>commandname</var></tt>
 <list compact>
 <item>Display short explanation on command
  <tt><var>commandname</var></tt>. (Unix style)
 </list>
<item><tt>info <var>commandname</var></tt>
 <list compact>
 <item>Display rather long explanation on command
  <tt><var>commandname</var></tt>.  (GNU style)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>List contents of directory. (non-dot files and directories)
  <footnote>
Unix has a tradition to hide filenames which start with "<tt>.</tt>".
They are traditionally files that contain configuration information and
user preferences.
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>List contents of directory. (all files and directories)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>List contents of directory. (almost all files and directories,
 i.e., skip "<file>..</file>" and "<file>.</file>")
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>List all contents of directory with detail information. See <ref
  id="file-system">.
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>List all directories under the current directory.
 </list>
<item><tt>lsof <var>foo</var></tt>
 <list compact>
 <item>List open status of file <tt><var>foo</var></tt>.
 </list>
<item><tt>mkdir <var>foo</var></tt>
 <list compact>
 <item>Make a new directory <tt><var>foo</var></tt> in the current directory.
 </list>
<item><tt>rmdir <var>foo</var></tt>
 <list compact>
 <item>Remove a directory <tt><var>foo</var></tt> in the current directory.
 </list>
<item><tt>cd <var>foo</var></tt>
 <list compact>
 <item>Change directory to the directory <file><var>foo</var></file> 
  in the current directory or in the directory listed in the variable
  <tt>CDPATH</tt>. See <prgn>cd</prgn> command in 
  <manref name="builtins" section="7">.
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>Change directory to the root directory.
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>Change directory to the current user's home directory.
 </list>
<item><tt>cd /<var>foo</var></tt>
 <list compact>
 <item>Change directory to the absolute path directory 
 <file>/<var>foo</var></file>.
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>Change directory to the parent directory.
 </list>
<item><tt>cd ~<var>foo</var></tt>
 <list compact>
 <item>Change directory to the home directory of the user
  <tt><var>foo</var></tt>.
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>Change directory to the previous directory.
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>Display contents of <file>/etc/motd</file> using the default pager.
   See <ref id="cmd-stdin">.
  <footnote>
Default pager of the bare bone &debian; system is <prgn>more</prgn>
which can not scroll back.  By installing <package>less</package>
package using command line <tt>apt-get install less</tt>,
<prgn>less</prgn> becomes default pager and you can scroll back with
cursor keys.
  </footnote>
 </list>
<item><tt>touch <var>junkfile</var></tt>
 <list compact>
 <item>Create a empty file <file><var>junkfile</var></file>.
 </list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Copy a existing file <file><var>foo</var></file> to a new
  file <file><var>bar</var></file>.
 </list>
<item><tt>rm <var>junkfile</var></tt>
 <list compact>
 <item>Remove a file <file><var>junkfile</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Rename an existing file <file><var>foo</var></file> to a new
  name <file><var>bar</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
 <list compact>
 <item>Move an existing file <file><var>foo</var></file> to a new
  location with a new name <file><var>bar/baz</var></file>. The
  directory <file><var>bar/</var></file> must exist.
 </list>
<item><tt>chmod 600 <var>foo</var></tt>
 <list compact>
 <item>Make an existing file <file><var>foo</var></file> to be
 non-readable and non-writable by the other people. (non-executable for all)
 </list>
<item><tt>chmod 644 <var>foo</var></tt>
 <list compact>
 <item>Make an existing file <file><var>foo</var></file> to be
 readable but non-writable by the other people. (non-executable for all)
 </list>
<item><tt>chmod 755 <var>foo</var></tt>
 <list compact>
 <item>Make an existing file <file><var>foo</var></file> to be readable
 but non-writable by the other people. (executable for all)
 </list>
<item><tt>top</tt>
 <list compact>
 <item>Display process information using full screen.  Type "q" to quit.
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>Display information on all the running processes using BSD style
  output. See <ref id="cmd-pipe">.
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>Display information on all the running processes using Unix
  system-V style output.
 </list>
<item><tt>ps aux | grep -e "[e]xim"</tt>
 <list compact>
 <item>Display all processes running <prgn>exim</prgn>.  Learn the 
 regular expression from <manref name="grep" section="1"> manual page
 by typing <tt>man grep</tt>.
 </list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item>Display information on all the running processes with ASCII art
  output.
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>Kill a process identified by the process ID: <var>1234</var>.
 See <ref id="kill">.
 </list>
<item><tt>grep -e "<var>pattern</var>" *.html</tt>
 <list compact>
 <item>Find a "<var>pattern</var>" in all of the files ending with
  <tt>.html</tt> in current directory and display them all.
 </list>
<item><tt>gzip <var>foo</var></tt>
 <list compact>
 <item>Compress <file><var>foo</var></file> to create
  <file><var>foo</var>.gz</file> using the Lempel-Ziv coding (LZ77).
 </list>
<item><tt>gunzip <var>foo</var>.gz</tt>
 <list compact>
 <item>Decompress <file><var>foo</var>.gz</file> to create
  <file><var>foo</var></file>.
 </list>
<item><tt>bzip2 <var>foo</var></tt>
 <list compact>
 <item>Compress <file><var>foo</var></file> to create
  <file><var>foo</var>.bz2</file> using the Burrows-Wheeler block sorting
text compression algorithm, and Huffman coding. (Better compression
than <prgn>gzip</prgn>)
 </list>
<item><tt>bunzip2 <var>foo</var>.bz2</tt>
 <list compact>
 <item>Decompress <file><var>foo</var>.bz2</file> to create
  <file><var>foo</var></file>.
 </list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
 <list compact>
 <item>Extract files from <file><var>foo</var>.tar</file> archive.
 </list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
 <list compact>
 <item>Extract files from gzipped <file><var>foo</var>.tar.gz</file>
  archive.
 </list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
 <list compact>
 <item>Extract files from <file><var>foo</var>.tar.bz2</file> archive.
  <footnote>
<tt>--bzip2</tt> is used here instead of new short option <tt>-j</tt> to
ensure this to work with old version of <prgn>tar</prgn> in Potato.
  </footnote>
 </list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
 <list compact>
 <item>Archive contents of folder <file><var>bar</var>/</file> in
  <file><var>foo</var>.tar</file> archive.
 </list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
 <list compact>
 <item>Archive contents of folder <file><var>bar</var>/</file> in
  compressed <file><var>foo</var>.tar.gz</file> archive.
 </list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
 <list compact>
 <item>Archive contents of folder <file><var>bar</var>/</file> in
  <file><var>foo</var>.tar.bz2</file> archive.
  <footnote>
<tt>--bzip2</tt> is used here again to ensure compatibility.
  </footnote>
 </list>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>Display contents of compressed
  <file>README.gz</file> using the default pager.
 </list>
<item><tt>zcat README.gz &gt; foo</tt>
 <list compact>
 <item>Create a file <file>foo</file> with the decompressed content of 
  <file>README.gz</file>.
 </list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
 <list compact>
 <item>Append the decompressed content of <file>README.gz</file> to the
  end of the file <file>foo</file>. (If it does not exist, create it
  first.)
 </list>
<item><tt>find . -name <var>pattern</var></tt>
 <list compact>
 <item>find matching filenames using shell <tt><var>pattern</var></tt>. 
  (slower)
 </list>
<item><tt>locate -d . <var>pattern</var></tt>
 <list compact>
 <item>find matching filenames using shell <tt><var>pattern</var></tt>.
  (quicker using regularly generated database)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
Please traverse directories and peek into the system using above
commands as a training.  If you have questions on any of the console
commands, please make sure to read the manual page.  For example, these
commands are the good start:
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
Also this is a good timing to start <prgn>vim</prgn> and press F1-key.
You should at least read the first 35 lines. Then do the online training
course by moving cursor to <tt>|tutor|</tt> and pressing Ctrl-].
See <ref id="edit"> to learn more about editors.
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
Please note that many Unix-like commands including ones from GNU and BSD
will display brief help information if you invoke them in one of the
following ways (or without any arguments in some cases):
<example>
$ <var>commandname</var> --help
$ <var>commandname</var> -h
</example>
<p>
Try also examples in <ref id="tips"> as your self training.

<sect1 id="cmd-exec">The command execution
<p>
<!-- new content -->
Now you have some feel on how to use the &debian; system.  Let's look
deep into the mechanism of the command execution in the &debian; system.
<footnote>
Here, I have simplified reality for the newbie.  See <manref name="bash"
section="1"> for the exact explanation.
</footnote>

<sect1 id="cmd-simple">Simple command
<p>
<!-- new content -->
A simple command is a sequence of 
<enumlist compact>
<item>variable assignments (optional)
<item>command name
<item>arguments (optional)
<item>redirections (optional: <tt>&gt;</tt> , <tt>&gt;&gt;</tt> ,
<tt>&lt;</tt> , <tt>&lt;&lt;</tt> , etc.)
<item>control operator (optional: <tt>&amp;&amp;</tt> , <tt>||</tt> ;
&lt;newline&gt; , <tt>;</tt> , <tt>&amp;</tt> , <tt>(</tt> , <tt>)</tt>
)
</enumlist>
<p>
For more complex commands with quotations and substitutions, see <ref
id="clprocess">.

<sect1 id="cmd-env">Command execution and environment variable
<p>
<!-- new content -->
Typical command execution uses a shell line sequence like the following:
<footnote>
To obtain the following output, you need to install French locale, see
<ref id="locales">.  This is not essential for the tutorial.  This is
done only to indicate its potential effects.
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
Here, the program <prgn>date</prgn> is executed in the foreground job.
The environment variable <tt>LC_ALL</tt> is:
<list compact>
<item>unset (system default, same as <tt>C</tt>) for the first command
<item>set to <tt>fr_FR</tt> (French locale) for the second command
</list>
Most command executions usually do not have preceding environment
variable definition.  For the above example, you can alternatively execute:
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
As you can see here, the output of command is affected by the
environment variable to produce French output.  If you want the
environment variable to be inherited to the subprocesses (e.g., when
calling shell script), you need to "export" it instead by using:
<example>
$ export LC_ALL
</example>


<sect1 id="cmd-path">Command search path
<p>
<!-- new content -->
When you type a command into the shell, the shell searches the command
in the list of directories contained in the <tt>PATH</tt> environment
variable.  The value of the <tt>PATH</tt> environment variable is also
called the shell's search path.
<p>
In the default &debian; installation, the <tt>PATH</tt> environment variable of 
user account may not include <file>/sbin</file>.  So if you want to run
any commands such as <prgn>ifconfig</prgn> from <file>/sbin</file>, 
you must change the <tt>PATH</tt> environment variable to include it.
The <tt>PATH</tt> environment variable is usually set by the initialization
file <file>~/.bash_profile</file>, see <ref id="bashconf">.

<sect1 id="cmd-opt">Command line options
<p>
<!-- new content -->
Some commands take arguments.  The arguments starting with <tt>-</tt> or
<tt>--</tt> are called options and control the behavior of the command.
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
Here the command-line argument <tt>-R</tt> changes the <prgn>date</prgn>
command behavior to output RFC-2822 compliant date string.

<sect1 id="cmd-wild">Shell wildcards
<p>
<!-- new content -->
Often you want a command to work with a group of files without typing
all of them.  The filename expansion pattern using the shell
<strong>wildcards</strong> facilitate this needs.
<list compact>
<item><tt>*</tt>
<list compact>
<item>This matches any group of 0 or more characters.
<item>This does not match a filename started with "<tt>.</tt>".
</list>
<item><tt>?</tt>
<list compact>
<item>This matches exactly one character.
</list>
<item><tt>[...]</tt>
<list compact>
<item>This matches exactly one character with any character enclosed in
brackets
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>This matches exactly one character with any character between
<tt>a</tt> and <tt>z</tt>.
</list>
<item><tt>[^...]</tt>
<list compact>
<item>This matches exactly one character other than any character enclosed 
in brackets (excluding "^").
</list>
</list>
<p>
For example, try the following and think yourself:
<example>
$ mkdir junk; cd junk; $ touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rmdir junk
</example>

<sect1 id="cmd-return">Return value of the command
<p>
Each command returns its exit status as the return value.
<list compact>
<item>return value = 0 if the command executes successfully.
<item>return value = non-zero if the command exits with error.
</list>
This return value can be accessed by the <tt>$?</tt> shell variable
immediately after the execution.
<p>
Please note that, when the return value is used in the logical context
for the shell, <strong>success</strong> is treated as the logical
<strong>TRUE</strong>.  This is somewhat non-intuitive since
<strong>success</strong> bears value <strong>zero</strong>.
<p>
See <ref id="shell-cond">.

<sect1 id="cmd-typical">Typical command sequences
<p>
<!-- new content in this whole sect1 ind sect2s -->
Let's try to remember following shell command idioms.  
See <ref id="shell-param">, <ref id="shell-redirect">, 
<ref id="shell-cond">, and <ref id="clprocess"> after reading these
idioms.

<sect2 id="cmd-back"><tt>command &amp;</tt>
<p>
The <prgn>command</prgn> is executed in the subshell in the
<strong>background</strong>.  Background jobs allow users to run
multiple programs in a single shell.
<p>
The management of the background process involves the shell built-ins:
<prgn>jobs</prgn>, <prgn>fg</prgn>, <prgn>bg</prgn>, and
<prgn>stop</prgn>. Please read the sections of the <manref name="bash"
section="1"> manual page under "SIGNALS",  "JOB CONTROL", and "SHELL
BUILTIN COMMANDS".
<footnote>
The &debian; system is a multi-tasking system.
</footnote>
 
<sect2 id="cmd-pipe"><tt>command1 | command2</tt>
<p>
The standard output of <prgn>command1</prgn> is fed to the standard
input of <prgn>command2</prgn> .  Both commands may be running
<strong>concurrently</strong>.  This is called <strong>pipeline</strong>.

<sect2 id="cmd-list"><tt>command1 ; command2</tt>
<p>
The <prgn>command1</prgn> and <prgn>command2</prgn>
are executed <strong>sequentially</strong>.
 
<sect2 id="cmd-and"><tt>command1 &amp;&amp; command2</tt>
<p>
The <prgn>command1</prgn> is executed.  If successful,
<prgn>command2</prgn> is also executed <strong>sequentially</strong>.
Return success if both <prgn>command1</prgn> <strong>and</strong>
<prgn>command2</prgn> are successful.
 
<sect2 id="cmd-or"><tt>command1 || command2</tt>
<p>
The <prgn>command1</prgn> is executed.  If not successful,
<prgn>command2</prgn> is also executed <strong>sequentially</strong>.
Return success if <prgn>command1</prgn> <strong>or</strong>
<prgn>command2</prgn> are successful.

<sect2 id="cmd-stdout"><tt>command &gt; <var>foo</var></tt>
<p>
Redirect standard output of <prgn>command</prgn> to a file
<tt><var>foo</var></tt>. (overwrite)

<sect2 id="cmd-stdout2"><tt>command &gt;&gt; <var>foo</var></tt>
<p>
Redirect standard output of <prgn>command</prgn> to a file
<tt><var>foo</var></tt>. (append)

<sect2 id="cmd-stderr"><tt>command &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
Redirect both standard output and standard error of <prgn>command</prgn>
to a file <tt><var>foo</var></tt>.

<sect2 id="cmd-stdin"><tt>command &lt; <var>foo</var></tt>
<p>
Redirect standard input of <prgn>command</prgn> to a file
<tt><var>foo</var></tt>.  Try:
<example>
$ &lt;/etc/motd pager
 ... (the greetings)
$ pager &lt;/etc/motd
 ... (the greetings)
$ pager /etc/motd
 ... (the greetings)
$ cat /etc/motd | pager
 ... (the greetings)
</example>
Although all 4 syntaxes display the same thing, the last example runs extra
<prgn>cat</prgn> command and waists resources with no reason.

<sect1 id="cmd-alias">Command alias
<p>
<!-- new content -->
You can set an alias for the frequently used command.  For example:
<example>
$ alias la='ls -la'
</example>
Now, <prgn>la</prgn> works as a short hand for <tt>ls -la</tt> which
lists all files in the long listing format.
<p>
You can identity exact path or identity of the command using
<prgn>type</prgn> command. For example:
<example>
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
</example>
Here <prgn>ls</prgn> was recently searched while <prgn>file</prgn> was
not, thus <prgn>ls</prgn> is "hashed", i.e., the shell has an internal
record for the quick access to the location of the <prgn>ls</prgn>
command.

<sect id="text-process">Unix-like text processing
<p>
There are few standard text processing tools which are used very often
on the Unix-like system.
<list compact>
<item>No regular expression is used:
<list compact>
<item><prgn>head</prgn> outputs the first part of files.
<item><prgn>tail</prgn> outputs the last part of files.
<item><prgn>sort</prgn> sorts lines of text files.
<item><prgn>uniq</prgn> removes duplicate lines from a sorted file.
<item><prgn>tr</prgn> translates or deletes characters.
<item><prgn>diff</prgn> compares files line by line.
</list>
<item>Basic regular expression (BRE) is used:
<list compact>
<item><prgn>grep</prgn> matches text with the pattern.
<item><prgn>ed</prgn> is a primitive line editor.
<item><prgn>sed</prgn> is a stream editor.
<item><prgn>vi</prgn> is a screen editor.
<item><prgn>emacs</prgn> is a screen editor.
</list>
<item>Extended regular expression (ERE) is used:
<list compact>
<item><prgn>egrep</prgn> matches text with pattern.
<item><prgn>awk</prgn> does simple text processing.
 See <ref id="awk">.
<item><prgn>perl</prgn> does every conceivable text processing. 
 See <ref id="perl">.
</list>
</list>
See <ref id="perl-i">, <ref id="scrp-snip">, and <ref id="perl-mad"> 
for some script examples.


<sect1 id="regex">Regular expressions
<p>
Regular expressions are used in many text processing tools.  They are
analogous to the shell wildcards (see <ref id="cmd-wild">), but they are
both more complicated and more powerful.
<p>
The regular expression describes the matching pattern and is made up of
text characters and <strong>metacharacters</strong>. The metacharacter
is just a character with a special meaning.  There are 2 major styles,
BRE and ERE, depending on the text tools as described in 
<ref id="text-process">.
<p>
For the EREs, the <strong>metacharacters</strong> include "<tt> \ . [ ] ^
&dollar; * + ? ( ) { } | </tt>". The regular expression means:
<list compact>
<item><tt>c</tt>
<list compact>
<item>This matches the non-metacharacter "<tt>c</tt>".
</list>
<item><tt>\c</tt>
<list compact>
<item>This matches the literal character "<tt>c</tt>".
</list>
<item><tt>.</tt>
<list compact>
<item>This matches any character including newline.
</list>
<item><tt>^</tt>
<list compact>
<item>This matches the beginning of a string.
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>This matches the end of a string.
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>This matches the beginning of a word.
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>This matches the end of a word.
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>This character list matches any of the characters "<tt>abc...</tt>".
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>This negated character list matches any of the characters except 
 "<tt>abc...</tt>".
</list>
<item><tt>r*</tt>
<list compact>
<item>This matches zero or more regular expressions identified by
 "<tt>r</tt>".
</list>
<item><tt>r+</tt>
<list compact>
<item>This matches one or more regular expressions identified by
 "<tt>r</tt>".
</list>
<item><tt>r?</tt>
<list compact>
<item>This matches zero or one regular expressions identified by
 "<tt>r</tt>".
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>This matches one of the regular expressions identified by
 "<tt>r1</tt>" or "<tt>r2</tt>".
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>This matches one of the regular expressions identified by
 "<tt>r1</tt>" or "<tt>r2</tt>" and treats it as a
 <strong>bracketed</strong> regular expression.
</list>
</list>
<p>
In BREs the <strong>metacharacters</strong> "<tt> + ? ( ) { } | </tt>"
lose their special meaning; instead use the backslashed versions "<tt>
\+ \? \( \) \{ \} \| </tt>".  Thus the grouping construct
<tt>(r1|r2)</tt> needs to be quoted as <tt>\(r1|r2\)</tt> in BREs.
Since <prgn>emacs</prgn>, although being basically BRE, treats "<tt> + ?
</tt>" as the <strong>metacharacters</strong>.  
Thus there are no needs to quote them.  See <ref id="replaceex"> for how
the grouping construct is used.
<p>
For example, <prgn>grep</prgn> can be used to perform the text search
using the regular expression:
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">Replacement expressions
<p>
For the replacement expression, following characters have special meanings:
<list>
<item><tt>&amp;</tt> 
<list compact>
<item>This represents what the regular expression matched.
(use <tt>\&amp;</tt> in <prgn>emacs</prgn>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>This represents what the <var>n</var>-th <strong>bracketed</strong>
 regular expression matched.  
</list>
</list>
For Perl replacement string, <tt>&dollar;<var>n</var></tt> is used
instead of <tt>\<var>n</var></tt> and <tt>&amp;</tt> has no special
meaning.
<p>
For example:
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
Here please pay extra attention to the style of the
<strong>bracketed</strong> regular expression and how the matched
strings are used in the text replacement process on different tools.
<p>
These regular expressions can be used for the cursor movements and the
text replacement actions in the editors too.
<p>
Please read all the related manual pages to learn these commands.

<sect id="unixfile">Unix-like filesystem
<p>
<!-- 
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
In the GNU/Linux and other Unix-like OS systems, the
<strong>files</strong> are organized into <strong>directories</strong>.
<footnote>
<strong>Directories</strong> are called <strong>folders</strong> on some
other systems. 
</footnote>
All <strong>files</strong> and <strong>directories</strong> are arranged
in one big tree, the file hierarchy, rooted at <file>/</file>.
<p>
These files and directories can be spread out over several devices. The
<manref name="mount" section="8"> command serves to attach the file
system found on some device to the big file tree.  Conversely, the
<manref name="unmount" section="8"> command will detach it again.

<sect1 id="file-basics">Unix file basics
<p>
<!-- new content -->
Here are the basics:
<list compact>
<item> Filenames are case sensitive. That is,
<file>MYFILE</file> and <file>MyFile</file> are <strong>different</strong>
files.

<item>The root directory is referred to as simply
<file>/</file>. Don't confuse this "root" with the root
user.  See <ref id="login-root">. 

<item>Every directory has a name which can contain any
letters or symbols <strong>except</strong> <file>/</file>. 
<footnote>
While you <strong>can</strong> use almost any letters or symbols in a
file name, in practice it's a bad idea. It is better to avoid any
characters that often have special meanings on the command line,
including spaces, tabs, newlines and other special characters:
<tt>{ } ( ) [ ] ' ` &quot; \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> .
<p>
If you want to separate words in a name, good choices are the period,
hyphen, and underscore. You could also capitalize each word,
<tt>LikeThis</tt>.
</footnote>
The root directory is an exception; its name is <file>/</file>
(pronounced "slash" or "the root directory") and it cannot be renamed.

<item>Each file or directory is designated by a <strong>fully-qualified
filename</strong>, <strong>absolute filename</strong>, or
<strong>path</strong>, giving the sequence of directories which must be
passed through to reach it. The three terms are synonymous. All absolute
filenames begin with the <file>/</file> directory, and there's a
<file>/</file> between each directory or file in the filename. The first
<file>/</file> is the name of a directory, but the others are simply
separators to distinguish the parts of the filename.
<p>
The words used here can be confusing. Take the following example:
<example>
/usr/share/keytables/us.map.gz
</example>
This is a fully-qualified filename; some people call it a
<strong>path</strong>. However, people will also refer to
<file>us.map.gz</file> alone as a filename.
<footnote> 
There is also another use for the word <strong>path</strong>.  See <ref
id="cmd-path">.  The intended meaning is usually clear from the context.
</footnote>

<item>The root directory has a number of branches, such as
<file>/etc</file> and <file>/usr</file>. These subdirectories in turn
branch into still more subdirectories, such as <file>/etc/init.d</file>
and <file>/usr/local</file>. The whole thing together is called the
<strong>directory tree</strong>.
<p>
You can think of an absolute filename as a route from the base of the
tree (<file>/</file>) to the end of some branch (a file). You'll also
hear people talk about the directory tree as if it were a
<strong>family</strong> tree: thus subdirectories have
<strong>parents</strong>, and a path shows the complete ancestry of a
file.
<p>
There are also relative paths that begin somewhere other than the root
directory.  You should remember that the directory <file>../</file>
refers to the parent directory. 

<item>There's no directory that corresponds to a physical device, such
as your hard disk. This differs from CP/M, DOS, and Windows, where all
paths begin with a device name such as <tt>C:\</tt>. See <ref
id="file-system">.
</list>

<p>
The detailed best practices for the file hierarchy are described in the
<url id="&f-fhs;" name="Filesystem Hierarchy Standard">.  You should
remember the following facts as the starter:
<list compact>
<item><file>/</file>
<list compact>
<item>A simple <file>/</file> represents the root directory.
<p>
</list>
<item><file>/etc</file>
<list compact>
<item>This is the place for the system wide configuration files.
</list>
<item><file>/var/log</file>
<list compact>
<item>This is the place for the system log files.
</list>
<item><file>/home</file>
<list compact>
<item>This is the directory which contains all the home directories for
all non-privileged users.
</list>
</list>

<sect1 id="file-system">The filesystem concept in &debian;
<p>
<!-- old content modified with fs.h reference -->
Following the Unix tradition, the &debian; system provides the
filesystem under which physical data on harddisks and other storage
devices, and the interaction with the hardware devices such as console
screens and remote serial consoles are represented in an unified manner.
<p>
Each file, directory, named pipe, or physical device on a &debian;
system has a data structure called an <strong>inode</strong> which
describes its associated attributes such as the user who owns it (owner),
the group that it belongs to, the time last accessed, etc..  See <url
id="&f-inode-def;"> for the exact definition of <tt>struct inode</tt> in
the &debian; GNU/Linux system.
<p>
This unified representation of physical entities is very powerful since
this allows us to use the same command for the same kind of operation on
many totally different devices.
<p>
All your files could be on one disk --- or you could have 20 disks, some
of them connected to a different computer elsewhere on the network.  You
can't tell just by looking at the directory tree, and nearly all
commands work just the same way no matter what physical device(s) your
files are really on.

<sect1 id="file-perm">File and directory access permissions
<p>
<!-- old content -->
File and directory access permissions are defined separately for 
the following three categories of affected users:
<list compact>
<item>the <strong>user</strong> who owns the file (u), 
<item>other users in the <strong>group</strong>  which the file belongs
to (g), and
<item>all <strong>other</strong> users (o).
</list>
<p>
For a file, each corresponding permission allows:
<list compact>
<item><strong>read</strong> (r): to examine contents of the file,
<item><strong>write</strong> (w): to modify the file, and
<item><strong>execute</strong> (x): to run the file as a command.
</list>
<p>
For a directory, each corresponding permission allows:
<list compact>
<item><strong>read</strong> (r): to list contents of the directory,
<item><strong>write</strong> (w): to add or remove files in the
directory, and
<item><strong>execute</strong> (x): to access files in the directory.
</list>
Here, <strong>execute</strong> permission on the directory means not 
only to allow reading of files in its directory but also to allow 
viewing their attributes, such as the size and the modification time.
<p>
To display permission information (and more) for files and directories, 
<prgn>ls</prgn> is used.  See <manref name="ls" section="1">.  
When <prgn>ls</prgn> invoked with the <tt>-l</tt> option, it displays 
the following information in the order given:
<list compact>
<item>the <strong>type of file</strong> (first character)
 <list compact>
 <item><tt>-</tt>: normal file
 <item><tt>d</tt>: directory
 <item><tt>l</tt>: symlink
 <item><tt>c</tt>: character device node
 <item><tt>b</tt>: block device node
 <item><tt>p</tt>: named pipe
 <item><tt>s</tt>: socket
 </list>
<item>the file's access <strong>permissions</strong> (the next nine
 characters, consisting of three characters each for user, group, and other
 in this order)
<item>the <strong>number of hard links</strong> to the file 
<item>the name of the <strong>user</strong> who owns the file
<item>the name of the <strong>group</strong> which the file belongs to
<item>the <strong>size</strong> of the file in characters (bytes)
<item>the <strong>date and time</strong> of the file (mtime)
<item>the <strong>name</strong> of the file.
</list>
<p>
To change the owner of the file, <prgn>chown</prgn> is used from the
root account.  To change the group of the file, <prgn>chgrp</prgn> is
used from the file's owner or root account.  To change file and
directory access permissions, <prgn>chmod</prgn> is used from the file's
owner or root account. Basic syntax to manipulate <file>foo</file> file
is:
<example>
# chown <var>newowner</var> foo
# chgrp <var>newgroup</var> foo 
# chmod  [ugoa][+-=][rwx][,...] foo 
</example>
See <manref name="chown" section="1">,
<manref name="chgrp" section="1">, and
<manref name="chmod" section="1"> for the detail.

<p>
For example, in order to make a directory tree to be owned by a user
<var>foo</var> and shared by a group <var>bar</var>, issue the following
commands from the root account: 
<example>
# cd /some/location/
# chown -R <var>foo</var>:<var>bar</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
There are three more special permission bits:
<list compact>
<item><strong>set user ID</strong> (s or S instead of user's x),
<item><strong>set group ID</strong> (s or S instead of group's x), and
<item><strong>sticky bit</strong> (t or T instead of other's x).
</list>
Here the output of <prgn>ls -l</prgn> for these bits is capitalized if 
execution bits hidden by these outputs are unset.
<p>
Setting <strong>set user ID</strong> on an executable file allows a user
to execute the executable file with the owner ID of the file (for
example <strong>root</strong>). Similarly,
setting <strong>set group ID</strong> on an executable file allows a
user to execute the executable file with the group ID of the file (for
example <strong>root</strong>). Because these settings can
cause security risks, enabling them requires extra caution.
<p>
Setting <strong>set group ID</strong> on a directory enables the
BSD-like file creation scheme where all files created in the directory
belong to the <strong>group</strong> of the directory.  
<p>
Setting the <strong>sticky bit</strong> on a directory prevents a file in
the directory from being removed by a user who is not the owner of the file.
In order to secure the contents of a file in world-writable directories
such as <file>/tmp</file> or in group-writable directories, one must not
only set <strong>write</strong> permission off for the file but also set
the <strong>sticky bit</strong> on the directory.  Otherwise, the file can
be removed and a new file can be created with the same name by any user
who has write access to the directory.
<p>
Here are a few interesting examples of the file permissions.
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
There is an alternative numeric mode to describe file permissions in
<manref name="chmod" section="1"> commands.  This numeric mode uses 3 to
4 digit wide octal (radix=8) numbers.  Each digit corresponds to:
<list compact>
<item>1st optional digit: sum of <strong>set user ID</strong> (=4), 
 <strong>set group ID</strong> (=2), and <strong>sticky bit</strong> (=1)
<item>2nd digit: sum of  
 <strong>read</strong> (=4), <strong>write</strong> (=2), and 
 <strong>execute</strong> (=1) permissions
 for <strong>user</strong>
<item>3rd digit: ditto for <strong>group</strong>
<item>4th digit: ditto for <strong>other</strong>
</list>
<p>
This sounds complicated but it is actually quite simple.  If you look at
the first few (2-10) columns from <tt>ls -l</tt> command output and read
it as a binary (radix=2) representation of file permissions ("-" being
"0" and "rwx" being "1"), this numeric mode value should make sense as
an octal (radix=8) representation of file permissions to you.
<footnote>
Of course this method works only for 3 digit wide numeric mode.
</footnote>
For example, try:
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
The default file permission mask can be set by using the <prgn>umask</prgn>
shell built-in command.  See <manref name="builtins" section="7">.
</sect1>

<sect1 id="timestamp">Timestamps
<p>
<!-- old content, minor edit -->
There are three types of timestamps for a GNU/Linux file:
<list compact>
<item><strong>mtime</strong>: the modification time (<tt>ls -l</tt>),
<item><strong>ctime</strong>: the status change time (<tt>ls -lc</tt>), and
<item><strong>atime</strong>: the last access time  (<tt>ls -lu</tt>).
</list>
Note that <strong>ctime</strong> is not file creation time.  
<list compact>
<item>Overwriting a file will change all of <strong>mtime</strong>,
  <strong>ctime</strong>, and <strong>atime</strong> of the file.
<item>Changing permission or owner of a file will change
  <strong>ctime</strong> and <strong>atime</strong> of the file.
<item>Reading a file will change <strong>atime</strong> of the file.
</list>
Note that even simply reading a file on the &debian; system will normally
cause a file write operation to update <strong>atime</strong>
information in the <strong>inode</strong>.  Mounting a filesystem with
the <tt>noatime</tt> option will let the system skip this operation and will
result in faster file access for the read.  See <manref name="mount"
section="8">.
<p>
<!-- new content -->
Use <manref name="touch" section="1"> command to change timestamps of
existing files.
</sect1>

<sect1 id="links">Links
<p>
<!-- old content -->
There are two methods of associating a file <var>foo</var> with a different 
filename <var>bar</var>.
<list compact>
<item>a <strong>hard link</strong> is a duplicate name for an existing file
 (<tt>ln <var>foo</var> <var>bar</var></tt>),
<item>a <strong>symbolic link</strong>, or "symlink", is a special file that
  points to another file by name
 (<tt>ln -s <var>foo</var> <var>bar</var></tt>).
</list>
See the following example for the changes in link counts and the subtle 
differences in the result of the <prgn>rm</prgn> command.
<example>
$ echo "Original Content" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # hard link
$ ln -s <var>foo</var> <var>baz</var>  # symlink
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "New Content" &gt; <var>foo</var>
$ cat <var>bar</var>
Original Content
$ cat <var>baz</var>
New Content
</example>
<!-- minor update below -->
The symlink always has nominal file access permissions of "rwxrwxrwx",
as shown in
the above example, with the effective access permissions dictated by the
permissions of the file that it points to.

<p>
The <file>.</file> directory links to the directory that it appears in, thus
the link count of any new directory starts at 2.  The <file>..</file> directory
links to the parent directory, thus the link count of the directory increases
with the addition of new subdirectories.

<sect1 id="fifo">Named pipes (FIFOs)
<p>
<!-- DDP Debian Tutorial content -->
<p>
A named pipe is a file that acts like a pipe. You put something into the
file, and it comes out the other end. Thus it's called a FIFO, or
First-In-First-Out: the first thing you put in the pipe is the first
thing to come out the other end.
<p>
If you write to a named pipe, the process which is writing to the pipe
doesn't terminate until the information being written is read from the
pipe. If you read from a named pipe, the reading process waits until
there's something to read before terminating. The size of the pipe is
always zero --- it doesn't store data, it just links two processes like
the shell <tt>|</tt>. However, since this pipe has a name, the two
processes don't have to be on the same command line or even be run by
the same user.
<p>
You can try it by doing the following:
<example>
$ cd; mkfifo mypipe
$ echo "hello" &gt;mypipe &amp; # put into background
[1] <var>5952</var>
$ ls -l mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
$ cat mypipe
hello
[1]+  Done                    echo hello &gt;mypipe
$ ls mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
$ rm mypipe
</example>

<sect1 id="sockets">Sockets
<p>
<!-- new content -->
The socket is similar to the named pipe (FIFO) and allows processes to
exchange information.  For the socket, those processes do not need to be
running at the same time nor need to be the children of the same
ancestor process.  This is the endpoint for the inter process
communication.   The exchange of information may occur over the network
between different hosts.

<sect1 id="device">Device files
<p>
<!-- DDP Debian Tutorial content, modified -->
Device files refer to physical or virtual devices on your system, such
as your hard disk, video card, screen, or keyboard. An example of a
virtual device is the console, represented by <tt>/dev/console</tt>.
<p>
There are two types of devices: 
<list compact>
<item><strong>character device</strong>
<list compact>
<item>This can be accessed one character at a time, that is, the
smallest unit of data which can be written to or read from the device is
a character (byte).
</list>
<item><strong>block device</strong>
<list compact>
<item>This must be accessed in larger units called blocks, which contain
a number of characters. Your hard disk is a block device.
</list>
</list>
<p>
You can read and write device files, though the file may well contain
binary data which may be an incomprehensible-to-humans gibberish.
Writing data directly to these files is sometimes useful for the
troubleshooting of hardware connections.  For example, you can dump a
text file to the printer device <file>/dev/lp0</file> or send modem
commands to the appropriate serial port <file>/dev/ttyS0</file>.  But,
unless this is done carefully, it may cause a major disaster.  So be
cautious.

<sect2 id="devnull"><file>/dev/null</file> etc.
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> is a special device file that discards anything
you write to it. If you don't want something, throw it in
<file>/dev/null</file>.  It's essentially a bottomless pit. If you read
<file>/dev/null</file>, you'll get an end-of-file (EOF) character
immediately. 
<p>
<file>/dev/zero</file> is similar, only if you read from it you get the
<tt>\0</tt> character (not the same as the number zero ASCII).  See <ref
id="dummyfile">.

<sect2 id="node">Device node number
<p>
<!-- new content -->
The device node number are displayed by executing <prgn>ls</prgn> as:
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
Here,
<list compact>
<item><file>/dev/hda</file> has the major device number 3 and the minor
device number 0. This is read/write accessible by the user who belongs
to <tt>disk</tt> group,
<item><file>/dev/ttyS0</file> has the major device number 4 and the minor
device number 64. This is read/write accessible by the user who belongs
to <tt>dialout</tt> group, and
<item><file>/dev/zero</file> has the major device number 1 and the minor
device number 5. This is read/write accessible by anyone.
</list>
<p>
In the older system, the installation process creates the device
nodes using <prgn>/sbin/MAKEDEV</prgn> command.  See <manref
name="MAKEDEV" section="8">.
<p>
In the newer system, the filesystem under in the <file>/dev</file>
is automatically populated by the device filesystem similar to the
<file>/proc</file> filesystem.

<sect1 id="procfs"><file>/proc</file> filesystem
<p>
<!-- modified heavily, original from Debian Guide -->
The <file>/proc</file> filesystem is a pseudo-filesystem and contains
information about the system and running processes.
<p>
People frequently panic when they notice one file in particular -
<file>/proc/kcore</file> - which is generally huge. This is (more or
less) a copy of the contents of your computer's memory. It's used to
debug the kernel. It doesn't actually exist anywhere, so don't worry
about its size.
<p>
See <ref id="proc-sys"> and <manref name="proc" section="5">.

<sect id="xtuto">X Window System
<p>
<!-- practically new content -->
See <ref id="x">.

<sect1 id="xstart">Start the X Window System
<p>
The X Window System can be started automatically with
<prgn>xdm</prgn>-like graphical login daemon or type following from the
console. 
<example>
$ exec startx
</example>

<sect1 id="xmenu">Menu in the X Window System
<p>
Since X environment can accommodate many window managers, their user
interfaces vary quite a bit.  Please remember that right-clicking the
root window will bring up menu selections.  This is always available.
<list compact>
<item>To gain the shell command prompt, start Xterm from menu:
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>For graphical browsing of the web pages, start Mozilla from menu:
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>For graphical browsing of the PDF files, start Xpdf from menu:
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
If you do not find menu entry, install the pertinent packages.  See
<ref id="apt-install">.

<sect1 id="xkeys">Keyboard sequence for the X Window System
<p>
Followings are the important keystrokes to remember when running the X
Window System.
<list compact>
<item>Ctrl-Alt-F1 through F6:  Switch to other pseudo-terminals (from an X
window, DOSEMU, etc.)
<item>Alt-F7:               Switch back to X window
<item>Ctrl-Alt-minus:       Change screen resolution in X window (minus
refers to the keys on the numeric keypad)
<item>Ctrl-Alt-plus:        Change screen resolution opposite way in X
window (plus refers to the keys on the numeric keypad)
<item>Ctrl-Alt-Backspace:   Terminate the X Server program
<item>Alt-X, Alt-C, Alt-V:  Usual Windows/Mac Cut, Copy, Paste keys 
        combinations with Ctrl- keys are replaced by these Alt- keys
        in some programs such as Netscape Composer.
</list>

<sect id="cmd-study">Further study
<p>
At this moment, I recommend you to read the key guide books from
<url id="&tldp-guide;" name="The Linux Documentation Project: Guides">:
<list compact>
<item>"The Linux System Administrators' Guide",
<list compact>
<item>This covers all of the aspects of keeping the system running,
handling user accounts, backups, configuration of the system.
<item>package: <package>&p-sysadmin-guide;</package>
<item>file: <url id="&f-sysadmin-guide;">
<item>web: <url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition",
<list compact>
<item>This is a single reference for network administration in a Linux
environment.
<item>package: <package>&p-netadmin-guide;</package>
<item>file: <url id="&f-netadmin-guide;">
<item>web: <url id="&w-netadmin-guide;">
</list>
<item>"The Linux Cookbook",
<list compact>
<item>This provides over 1,500 time-saving recipes and hints for busy
modern computer users.
<item>package: <package>&p-linuxcookbook;</package>
<item>file: <url id="&f-linuxcookbook;">
<item>web: <url id="&w-linuxcookbook;">
</list>
</list>
<p>
See <ref id="support"> for more learning resources.
</chapt>

