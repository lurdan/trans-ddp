<!-- CVS revision of this document "$Revision: 1.13 $"  -->
<!-- CVS revision of original english document "1.40"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="vcs">Versions-Kontroll-Systeme

<sect id="cvs">Concurrent Versions System (CVS) &ndash; System für simultane
               Versionen
<p>
Überprüfen Sie <file>/usr/share/doc/cvs/html-cvsclient</file>, 
<file>/usr/share/doc/cvs/html-info</file> und
<file>/usr/share/doc/cvsbook</file> mit <prgn>lynx</prgn> oder starten Sie
<tt>info cvs</tt> und <tt>man cvs</tt> für detaillierte Informationen.

<sect1 id="cvs-inst">Installation eines CVS Servers
<p>
Das folgende Setup erlaubt commit's ins CVS Repository nur durch ein Mitglied
der "src" Gruppe und die Administration des CVS nur durch ein Mitglied der
"staff" Gruppe. Dies reduziert die Möglichkeit, den Server versehentlich zu
misskonfigurieren.
<example>
# cd <var>/var/lib</var>; umask 002; mkdir <var>cvs</var> # [Woody] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=<var>/var/lib/cvs</var>
# cd $CVSROOT
# chown root:src .         # "staff" um bei neuen Projekten mehr
                           # zu restriktieren
# chmod 3775 .             # bei "staff" statt "src", 2775 verwenden
# cvs -d <var>/var/lib/cvs</var> init # es ist sicherer -d anzugeben
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect1>

<sect1 id="cvs-examples">Beispiele für CVS Sitzungen
<p>
Das folgende stellt die Shell Umgebung für den CVS Repository Zugriff ein.

<sect2>Anonymes CVS (nur Download)
<p>
Entfernter nur lesbarer Zugang:
<example>
$ export CVSROOT=:pserver:<var>anonymous@cvs.sf.net:/cvsroot/qref</var>
$ cvs login
$ cvs -z3 co <var>qref</var>
</example>
</sect2>

<sect2>Nutzen eines lokalen CVS Servers
<p>
Lokaler Zugang von der Shell auf der selben Maschine:
<example>
$ export CVSROOT=<var>/var/lib/cvs</var>
</example>
</sect2>

<sect2>Nutzen eines entfernten CVS pserver
<p>
Entfernter Zugriff ohne SSH (verwenden Sie das RSH Protokoll in
<prgn>cvs</prgn>):
<example>
$ export CVSROOT=:pserver:<var>account@cvs.foobar.com:/var/lib/cvs</var>
$ cvs login
</example>
Dies ist für Lauschangriffe anfällig.
</sect2>

<sect2>Nutzen von entfernten CVS mittels <prgn>ssh</prgn>
<p>
Entfernter Zugriff mit SSH:
<example>
$ export CVSROOT=:ext:<var>account@cvs.foobar.com:/var/lib/cvs</var>
</example>
oder für SourceForge:
<example>
$ export CVSROOT=:ext:<var>account@cvs.sf.net:/cvsroot/qref</var>
</example>
Man kann auch RSA Authentifizierung nutzen (<ref id="ssh-rsa">), was die
Passwortabfrage überflüssig macht.
</sect2>

<sect2>Erzeugen eines neuen CVS Archivs
<p>
Für
<example>
EINTRAG          WERT              BEDEUTUNG
Quellbaum:       ~/<var>Projekt-x</var>       gesamter Quellcode
Projektname:     <var>Projekt-x</var>         der Name dieses Projekts
Vendor Tag:      <var>Hauptzweig</var>        Wert für ganzen Zweig
Release Tag:     <var>Release-initial</var>   Wert für eine spezielle Version
</example>
Danach
<example>
$ cd ~/<var>Projekt-x</var>                # wechseln ins Quellverzeichnis
 ... Erzeugen des Quellcodes ...
$ cvs import -m <var>"Starte Projekt-x" Projekt-x Hauptzweig Release-initial</var>
$ cd ..; rm -R ~/<var>Projekt-x</var>
</example>
</sect2>

<sect2>Arbeiten mit CVS
<p>
Um mit <var>Projekt-x</var> unter Verwendung des lokalen CVS Repositories zu
arbeiten:
<example>
$ cd                            # ins Arbeitsverzeichnis wechseln
$ cvs co <var>Projekt-x</var>              # Quellen aus dem CVS kopieren
$ cd <var>Projekt-x</var>
 ... ändern des Codes ...
$ cvs diff -u                   # wie diff -u Repository/ lokal/
$ cvs up -C <var>modifizierte_Datei</var>  # Änderungen rückgängig machen
$ cvs ci -m "<var>Änderungen</var>"        # sichern der lokalen Quellen
$ vi <var>neue_hinzugefügte_Datei</var>    #   ... ins CVS
$ cvs add <var>neue_hinzugefügte_Datei</var>
$ cvs ci -m "<var>Neue Datei neue_hinzugefügte_Datei</var>"
$ cvs up                        # verschmelzen mit der letzten
                                # Version aus dem CVS
 ... zum Erzeugen aller neu erstellten Unterverzeichnisse im CVS
 ... ist "cvs up -d -P" stattdessen zu verwenden
 ... achten Sie auf Ausgaben, die mit "C <var>Dateiname</var>" starten
 ... nicht modifizierter Code wird nach `.#<var>Dateiname</var>.Version'
     verschoben
 ... suchen Sie nach "&lt;&lt;&lt;&lt;&lt;&lt;&lt;" und "&gt;&gt;&gt;&gt;&gt;&gt;&gt;" in der Datei
$ cvs tag <var>Release-1</var>             # hinzufügen des Release Tag
 ... weitere Änderungen ...
$ cvs tag -d <var>Release-1</var>          # entfernen des Release Tag
$ cvs ci -m "<var>mehr Kommentare</var>"
$ cvs tag <var>Release-1</var>             # erneutes hinzufügen des Tag
$ cd                            # ins Arbeitsverzeichnis wechseln
$ cvs co -r <var>Release-initial</var> -d <var>alt</var> <var>Projekt-x</var>
 ... Originalversion ins <var>alt</var> Verzeichnis kopieren
$ cd alt
$ cvs tag -b <var>Release-initial-bugfixes</var> # erzeuge Zweig (-b)
 ... nun kann mit der alten Version gearbeitet werden (Tag=sticky)
$ cvs update -d -P              # keine leeren Verz. erstellen
 ... Quellbaum hat nun den sticky Tag "Release-initial-bugfixes"
 ... arbeiten in diesem Zweig
$ cvs up -d -P                  # synchronisieren mit von anderen
                           # modifizierten Dateien in diesem Zweig
$ cvs ci -m "<var>einchecken in diesen Zweig</var>"
$ cvs update -kk -A -d -P
 ... entfernen des sticky Tag und Inhalt vergessen
 ... Aktualisierung des Haupt"trunk" ohne Schlüsselwortersetzung
$ cvs update -kk -d -P -j <var>Release-initial-bugfixes</var>
 ... vermengen des <var>Release-initial-bugfixes</var> Zweigs in den
 ... Haupt"trunk" ohne Schlüsselwortersetzung. Beseitigen Sie
 ... Konflikte mit einem Editor.
$ cvs ci -m "<var>vermenge Release-initial-bugfixes</var>"
$ cd
$ tar -cvzf <var>Projekt-x-alt.tar.gz</var> <var>alt</var> # Archiv erstellen, -j für bz2
$ cvs release -d <var>alt</var>            # lokale Quellen entfernen (optional)
</example>
Nette Optionen zur Erinnerung (als erstes Argument von <prgn>cvs</prgn>
nutzen):
<example>
-n      Probelauf, hat keinen Effekt
-t      Anzeigen von Mitteilungen zur CVS Aktivität
</example>
</sect2>

<sect2>Exportieren von Dateien aus dem CVS
<p>
Um die letzte Version aus dem CVS zu nutzen, verwenden Sie "tomorrow"
(morgen):
<example>
$ cvs ex -D tomorrow <var>Modulname</var>
</example>
</sect2>

<sect2>Verwalten des CVS
<p>
Fügen Sie ein Alias zum Projekt hinzu (lokaler Server):
<example>
$ su - admin           # ein Mitglied von staff
$ export CVSROOT=<var>/var/lib/cvs</var>
$ cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "<var>px</var> -a <var>Projekt-x</var>" &gt;&gt;modules
$ cvs ci -m "<var>Nun ist px ein Alias für Projekt-x</var>"
$ cvs release -d .
$ exit                 # oder Strg-D um von su zurückzukehren
$ cvs co -d <var>Projekt</var> <var>px</var> 
 ... auschecken von <var>Projekt-x</var> (Alias: <var>px</var>) aus dem CVS ins
 ... Verzeichnis Projekt
$ cd Projekt
 ... Änderungen vornehmen ...
</example>
</sect2>

<sect1 id="cvs-trouble">Fehlersuche im CVS

<sect2>Dateirechte im Repository
<p>
CVS überschreibt nicht die Datei im Repository, sondern ersetzt sie mit einer
anderen. Deshalb sind <em>Schreibrechte im Repository Verzeichnis</em>
wichtig. Für jedes neue Repository ist folgendes zu starten, um diese
Bedingung zu sichern.
<example>
# cd <var>/var/lib/cvs</var>
# chown -R root:src <var>Repository</var>
# chmod -R ug+rwX   <var>Repository</var>
# chmod 2775 <var>Repository</var> # wenn nötig, auch bei Unterverzeichnissen
</example>
</sect2>

<sect2>Das ausführbar-Bit
<p>
Das ausführbar-Bit einer Datei wird beibehalten beim Checkout. Wann immer 
Sie Probleme mit dem ausführbar-Recht in ausgecheckten Dateien haben, ändern
Sie die Rechte der Datei im CVS Repository mit dem folgenden Kommando:
<example>
# chmod ugo-x <var>Dateiname</var>
</example>
</sect2>

</sect1>

<sect1 id="cvs-short">CVS Kommandos
<p>
Es folgen CVS Kommandos mit deren Kürzeln.
<example>
{add|ad|new} [-k kflag] [-m 'Bemerkung'] Dateien...
{admin|adm|rcs} [rcs-Optionen] Dateien...
{annotate|ann} [Optionen] [Dateien...]
{checkout|co|get} [Optionen] Module...
{commit|ci|com} [-lnR] [-m 'Bemerkung fürs Protokoll' | -f Datei] \
        [-r Revision] [Dateien...]
{diff|di|dif} [-kl] [rcsdiff_Optionen] [[-r rev1 | -D Datum1] \
        [-r rev2 | -D Datum2]] [Dateien...]
{export|ex|exp} [-flNn] -r rev|-D Datum [-d dir] [-k kflag] Modul...
{history|hi|his} [-report] [-flags] [-options args] [Dateien...]
{import|im|imp} [-options] Repository vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] rlog-Optionen [Dateien...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] Module...
{release|re|rel} [-d] Verzeichnisse...
{remove|rm|delete} [-lR] [Dateien...]
{rtag|rt|rfreeze} [-falnR] [-b] [-d] [-r Tag | -D Datum] \
         symbolic_tag Module...
{status|st|stat} [-lR] [-v] [Dateien...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r Tag | -D Datum]  [-f] \
         symbolic_tag [Dateien...]
{update|up|upd} [-AdflPpR] [-d] [-r Tag|-D Datum] Dateien...
</example>
</sect1>

<sect id="svn">Subversion
<p>
Subversion ist ein Versions-Kontroll-System der nächsten Generation, das
einmal CVS ersetzen soll. Die Entwickler betrachten es zur Zeit als im
"alpha" Stadium befindlich, aber es ist wahrscheinlich für die meisten
Anwendungen stabil genug. Während dies geschrieben wird, ist Subversion
nur in Debian <tt>unstable</tt> verfügbar.

<sect1 id="svn-inst">Installation eines Subversion Servers
<p>
Das <package>subversion-server</package> Meta-Paket hängt von den benötigten
Paketen <package>libapache2-dav-svn</package> und
<package>subversion-tools</package> ab, um einen Server aufzusetzen.

<sect2>Aufsetzen eines Repository
<p>
Zur Zeit setzt das <package>subversion</package> Paket kein Repository auf,
man muss es manuell erzeugen. Eine mögliche Stelle für ein Repository ist
in <file>/var/local/repos</file>.
<p>
Erzeugen des Verzeichnisses
<example>
# mkdir -p /var/local/repos
</example>
und der Repository Datenbank:
<example>
# svnadmin create /var/local/repos
</example>
Nun ist das Repository für den WWW Server schreibbar zu machen:
<example>
# chown -R www-data:www-data /var/local/repos
</example>
</sect2>

<sect2>Konfiguration von Apache2
<p>
Um den Zugriff auf das Repository mittels Nutzerauthentifizierung zu
ermöglichen, fügen Sie folgendes zu 
<file>/etc/apache2/mods-available/dav_svn.conf</file> hinzu (oder
kommentieren Sie dies aus):
<example>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/local/repos
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt/Location&gt
</example>
Danach erzeugen Sie eine Nutzerauthentifizierungsdatei mit dem Kommando:
<example>
htpasswd2 -c /etc/subversion/passwd ein-Nutzer
</example>
Starten Sie Apache2 neu und Ihr neues Subversion Repository wird unter
der URL http://<var>hostname</var>/repos verfügbar sein.
</sect2>
</sect1>

<sect1 id="svn-cvs">Verschieben eines CVS Repositories nach Subversion
<!-- FIXME write me? -->
</sect1>

<sect1 id="svn-usage">Anwendungsbeispiele von Subversion
<p>
Die folgenden Abschnitte erklären die Verwendung verschiedener Kommandos in
Subversion.

<sect2>Erzeugen eines neuen Subversion Archivs
<p>
Um ein neues Subversion Archiv zu erstellen, verwenden Sie folgendes:
<example>
$ cd ~/<var>Projekt</var>         # ins Quellcodeverzeichnis wechseln
$ svn import http://localhost/repos <var>Projekt</var> <var>Projektname</var> \
      -m "erster Projektimport"
</example>
<p>
Dies erzeugt ein Verzeichnis namens <var>Projektname</var> im Subversion
Repository, das die Projektdateien enthält. Schauen Sie unter
http://localhost/repos/, um zu sehen, ob die Datei vorhanden ist.
</sect2>

<sect2>Arbeiten mit Subversion
<p>
Arbeiten mit <var>Projekt-y</var> und Subversion:
<example>
$ cd                            # ins Arbeitsverzeichnis wechseln
$ svn co http://localhost/repos/<var>Projekt-y</var>  # Quellcode auschecken
$ cd <var>Projekt-y</var>
 ... Änderungen durchführen ...
$ svn diff                      # wie diff -u Repository/ lokal/  
$ svn revert <var>modifizierte_Datei</var> # Änderungen rückgängig machen
$ svn ci -m "<var>Änderungen</var>"        # Änderungen einchecken
$ vi <var>neue_hinzugefügte_Datei</var>
$ svn add <var>neue_hinzugefügte_Datei</var>
$ svn add <var>Verzeichnis1</var>          # alle Dateien unter <var>Verzeichnis1</var>
                                # rekursiv hinzufügen
$ svn add -N <var>Verzeichnis2</var>       # Verz. nicht rekursiv hinzufügen
$ svn ci -m "neue Dateien hinzugefügt"
$ svn up                        # vermenge mit neuester Version
                                # aus Repository
$ svn log                       # zeige alle eingebrachten Änd.
$ svn copy http://localhost/repos/<var>Projekt-y</var> \
      http://localhost/repos/<var>Projekt-y-branch</var> \
      -m "erzeuge Zweig von <var>Projekt-y</var>" 
$ svn copy http://localhost/repos/<var>Projekt-y</var> \
      http://localhost/repos/<var>Proj-y_release1.0</var> \
      -m "<var>Projekt-y</var> 1.0 Release"# fügte release Tag hinzu
 ... Es ist zu beachten, dass das Erzeugen eines Zweigs und eines
 ... Tags das selbe ist. Der einzige Unterschied ist, dass Zweige
 ... "committed" werden, Tags nicht.
 ... Änderungen im Zweig durchführen ...

$ # vermengen der Kopie des Zweiges mit Hauptkopie
$ svn merge http://localhost/repos/<var>Projekt-y</var> \
   http://localhost/repos/<var>Projekt-y-branch</var>
$ svn co -r 4 http://localhost/repos/<var>Projekt-y</var> # Rev. 4 besorgen
</example>

</sect2>

</sect1>
</sect>
</chapt>
