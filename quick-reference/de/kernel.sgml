<!-- CVS revision of this document "$Revision: 1.4 $"  -->
<!-- CVS revision of original english document "1.47"  -->

<chapt id="kernel">Der Linux Kernel unter Debian
<p>
Debian hat eine eigene Methode einen Kernel und dazugehörige Module zu
kompilieren. Weitere Infos sind in <ref id="kernel-details"> zu finden.

<sect id="kernel-compile">Neukompilieren des Kernels
<p>
Die Tools <prgn>gcc</prgn>, <prgn>binutils</prgn> und
<prgn>modutils</prgn> aus Debian <tt>unstable</tt> sind sehr
hilfreich, wenn man einen aktuellen Linux Kernel kompilieren möchte.
Siehe <file>&f-kernel-readme;</file> um offizielle Informationen zu erhalten,
besonders der untere Teil ist interessant.
<p>

Einen eigenen Kernel zu kompilieren ist eine nicht ganz einfache Sache,
womit selbst begnadete Entwickler Schwierigkeiten haben könnten, gerade auch
weil diese Thematik eine sich ständig weiter entwickelnde ist.
<taglist compact>
<tag>Manoj Srivastava schrieb:
<item><tt>--initrd</tt> benötigt einen Debian-eigenen cramfs Patch.
<tag>Herbert Xu schrieb:
<item>Nein, das tut es nicht. Das einzige was nötig ist, um ein anderes
Dateisystem als CRAMFS zu nutzen, ist, MKIMAGE in
<file>/etc/mkinitrd/mkinitrd.conf</file> zu setzen.
</taglist>

<p>
Seien Sie vorsichtig und ziehen Sie <file>&f-kernel-readme;</file> von Manjo
und Kent stets zur Hilfe. Desweiteren stellen Sie sicher, dass Sie immer die
aktuellste Version des unstable <package>kernel-package</package> Paketes
haben, wenn Sie einen instabilen Kernel kompilieren möchten
<p>

Für einen Kernel, der nur für eine Maschine kompiliert ist, wird
<tt>initrd</tt> nicht benötigt. Weil ich aber möchte, dass mein Kernel der
gleiche ist, wie der, der von kernel-image bereitgestellt wird, nutze ich es
trotzdem. Wenn Sie <tt>initrd</tt> nutzen möchten, lesen Sie bitte
<manref name="mkinitrd" section="8"> und <manref name="mkinitrd.conf" section="5">.
Siehe auch <url id="&bug-initrd;">.


<sect1 id="kernel-debian">Die Debian Standard Methode
<p>
Beachten Sie Fehler Meldungen für <package>kernel-package</package>,
<prgn>gcc</prgn>, <prgn>binutils</prgn> und <prgn>modutils</prgn>.
Benutzen Sie neue Versionen von diesen Programmen wenn nötig.
<p>
Einen angepassten Kernel unter Debian zu kompilieren, bedarf ein
wenig Sorgfalt. Verwenden Sie die Option <tt>--append_to_version</tt> zusammen
mit <prgn>make-kpkg</prgn>, um mehrere Kernel zu verwalten.
<example>
# apt-get install debhelper modutils kernel-package libncurses5-dev
# apt-get install kernel-source-<var>2.4.18</var>   # installiere die aktuellste Version
# apt-get install fakeroot
# vi /etc/kernel-pkg.conf                # fügen Sie meinen Namen und meine eMail-Adresse hinzu
$ cd /usr/src                            # Arbeitsverzeichnis 
$ tar --bzip2 -xvf kernel-source-<var>2.4.18</var>.tar.bz2
$ cd kernel-source-<var>2.4.18</var>                # wenn das Ihre Kernel Sourcen sind
$ rm -rf */pcmcia 
    # [OPTIONAL] Abhängig davon, ob Module aus pcmcia-cs gebraucht werden
$ cp /boot/config-<var>2.4.18-386</var> .config     # verwenden Sie aktuelle .config als Default
$ make menuconfig                        # den Anforderungen entsprechend zusammenstellen
$ make-kpkg clean                        # muss laut 'man make-kpkg' ausgeführt werden
$ fakeroot make-kpkg --append_to_version -<var>486</var> --initrd \
        --revision=<var>rev.01</var> kernel_image \
        modules_image # modules_image ist für pcmcia-cs* und weitere...
$ cd ..
# dpkg -i kernel-image*.deb pcmcia-cs*.deb # installiert den Kernel
</example>

<tt>make-kpkg kernel_image</tt> führt <tt>make oldconfig</tt> und
<tt>make dep</tt> aus. Verwenden Sie <tt>--initrd</tt> nicht, wenn initrd
nicht ausgewählt wurde.
<p>
Ein <tt>rm -fr */pcmcia</tt> kann durch auswählen von "General setup
&mdash;&gt;" zu "PCMCIA/CardBus support  &mdash;&gt;" im <tt>make menuconfig
</tt> auf "&lt;&nbsp;&gt; PCMCIA/CardBus support" (deaktivieren der Box),
ersetzt werden.
<p>

Auf einer SMP Maschine, setzen Sie CONCURRENCY_LEVEL der <manref
name="kernel-pkg.conf" section="5"> entsprechend.
</sect1>

<sect1 id="kernel-classic">Klassische Methode
<p>
Laden Sie den "reinen" Quellcode von
<list compact>
<item>Linux:     <url id="&linuxsrc;">
<item>pcmcia-cs: <url id="&pcmciasrc;">
</list>
herunter oder verwenden Sie einen equivalenten Quellcode in Debian und führen
Sie folgende Schritte aus:
<example>
# cd /usr/src
# tar xfvz linux-<var>Version</var>.tar.gz
# rm -rf linux
# ln -s linux-<var>Version</var> linux
# tar xfvz pcmcia-cs-<var>Version</var>.tar.gz
# ln -s pcmcia-cs-<var>Version</var> pcmcia
# cd linux
# rm -rf */pcmcia   
    # [OPTIONAL] abhängig davon, ob Module aus pcmcia-cs gebraucht werden
# make menuconfig
... den Anforderungen entsprechend konfigurieren ...
# make dep
# make bzImage
... Konfiguration von lilo / grub ...
... kopieren von /usr/src/linux/arch/i386/boot/bzImage nach /boot ...
... /sbin/lilo oder grub ausführen
# make modules; make modules_install
# cd ../pcmcia
# make config
# make all
# make install
... Hinzufügen von benötigten Modulen zu /etc/modules
# shutdown -r now
... nun den neuen Kernel booten ...
</example>
</sect1>

<sect1 id="kernel-headers">Kernelheader
<p>
Die meisten Programme brauchen die Kernelheader Dateien nicht, und einige
Programme lassen sich sogar nicht erfolgreich kompilieren, wenn die Header
Dateien genutzt werden. Statt dessen sollten die Programme beim Kompilieren
gegen die Header Dateien gelinkt werden, gegen die auch <strong><prgn>glibc
</prgn> gelinkt wurde</strong>. Auf einem &debian; System sind diese
Kernelheader Dateien in <file>/usr/include/linux</file> und
<file>/usr/include/asm</file> zu finden.
<p>
Entgegen einigen veralteten Dokumentationen, sollten keine symbolischen
Links in <file>/usr/src/linux</file> von <file>/usr/include/linux</file> 
und <file>/usr/include/asm</file> erstellt werden.
<p>
Es sollte, wenn ein Programm bestimmte Kernelheader Dateien für
Kernel-spezifische Programme benötigt, statt dessen das <file>Makefile</file>
so angepasst werden, dass der Pfad der einzubindenden Header Dateien folgende
Pfade enthält <file><var>Verzeichnis-bestimmter-Kernelheader
</var>/include/linux</file> und
<file><var>Verzeichnis-bestimmter-Kernelheader</var>/include/asm</file>.
</sect1>

</sect>

<sect id="kernel-modules">Der modularisierte Kernel 2.4
<p>
Die neuen Debian 2.4 Kernel, welche von kernel-image-2.4.<var>NN</var>
zur Verfügung gestellt werden, sind sehr stark modularisiert. Es muss
sichergestellt sein, dass Module die verwendet werden sollen auch aktiviert
sind, damit der Kernel wie gewünscht arbeitet.
<p>
Obwohl ich viele Beispiele für <file>/etc/modules</file> im folgenden
Abschnitt als schnellen Fix habe, höre ich immer wieder, dass der richtige
Weg, diese Modul abhängigen Probleme zu lösen, ist Aliase für die Geräte in
Dateien unterhalb von <file>/etc/modutils/</file> anzulegen.
<p>
Siehe <file>Documentation/*.txt</file> im Linux Quellcode, um genauere
Informationen zu erhalten.

<sect1 id="kernel-pcmcia">PCMCIA
<p>
<file>/etc/modules</file> sollte folgendes enthalten, damit PCMCIA korrekt
funktioniert:
<example>
# ISA PnP Treiber
isa-pnp
# Lowlevel PCMCIA Treiber
# yenta_socket # in meinem Fall jedoch nicht nötig
</example>
Für den Rest von PCMCIA sorgen die Skripte (aus dem
<package>pcmcia-cs</package> Paket)
<prgn>depmod</prgn> und <prgn>kmod</prgn>. <prgn>isa-pnp</prgn>
brauchte ich auch, weil mein Laptop ein altes ISA-PCMCIA Modell ist.
Neuere Laptops mit Cardbus/PCMCIA sollten dies nicht mehr brauchen.
<p>
Ein Zitat vom großzügigen Miquel van Smoorenburg
<email>miquels@cistron.nl</email>: <!-- FIXME: gibt es ein <quote> ? -->
<p>
"Ich habe einfach alles was mit PCMCIA zu tun hat, inklusive cardmgr,
von meinem Laptop gelöscht und einen 2.4 Kernel mit CardBus Unterstützung
installiert, plus das neue <package>hotplug</package> Paket aus woody.
<p>
Solange man nur 32-bit Karten hat, wird das pcmcia Paket nicht benötigt;
2.4 stellt die nötigen Karten-Dienste von sich aus zur Verfügung.
Und der Standard tulip Treiber sollte wunderbar mit der dlink Karte arbeiten.
<p>
&ndash; Mike."
</sect1>

<sect1 id="kernel-scsi">SCSI
<p>  <!-- Osamu: maybe test this section? I do not have SCSI :(  
                                     But this is almost sure :) -->
[NICHT GETESTET] <file>/etc/modules</file> braucht folgendes damit
SCSI funktioniert:
<example>
# SCSI core
scsi_mod
# SCSI generic driver
sg
# SCSI disk
sd_mod
# Alle anderen HW Module
...
</example>
<prgn>depmod</prgn> sollte auf die oben genannten Module achten.
</sect1>

<sect1 id="kernel-net">Netzwerk Funktionalität
<p>
<file>/etc/modules</file> sollte für zusätzliche Netzwerk Funktionalität
folgendes enthalten:
<example>
# net/ipv-4
ip_gre
ipip

# net/ipv-4/netfilter
# iptable (in Reihenfolge)
ip_tables
ip_conntrack
ip_conntrack_ftp
iptable_nat
iptable_filter
iptable_mangle
#
ip_nat_ftp
ip_queue
#
ipt_LOG
ipt_MARK
ipt_MASQUERADE
ipt_MIRROR
ipt_REDIRECT
ipt_REJECT
ipt_TCPMSS
ipt_TOS
ipt_limit
ipt_mac
ipt_mark
ipt_multiport
ipt_owner
ipt_state
ipt_tcpmss
ipt_tos
ipt_unclean
#
#ipchains
#ipfwadm
</example>
Oben genanntes ist nicht optimiert. <prgn>depmod</prgn> sollte auf die oben
genannten Module achten.
</sect1>

<sect1 id="ext3">EXT3 Dateisystem ( &gt; 2.4.17)
<p>
Die Journaling Funktionalität für das EXT3 Dateisystem mit einem
vorkompilierten Kernel-Image ( &gt; 2.4.17) von Debian zu aktivieren, setzt
die folgenden Schritte voraus:
<example>
# cd /etc; mv fstab fstab.old
# sed 's/ext2/ext3,ext2/g' &lt;fstab.old &gt;fstab
# vi /etc/fstab
... setzen Sie den root Dateisystem Typ auf "auto" anstelle von "ext3,ext2"
# cd /etc/mkinitrd
# echo jbd &gt;&gt;modules
# echo ext3 &gt;&gt;modules
# echo ext2 &gt;&gt;modules
# cd /
# apt-get update; apt-get install kernel-image-<var>2.4.17-686-smp</var>
... installieren Sie den aktuellsten Kernel und konfigurieren Sie LILO
dementsprechend
# tune2fs -j -i 0 <var>/dev/hda1</var>
# tune2fs -j -i 0 <var>/dev/hda2</var>
... tune2fs für alle EXT2 Dateisysteme wiederholen
# shutdown -r now
</example>
Von nun an ist EXT3 Journaling aktiviert.
Für den Fall, dass der Kernel EXT3 für root Partitionen nicht unterstützt,
erweist sich <tt>ext3,ext2</tt> als Dateisystem "Typ" in der
<prgn>fstab</prgn> als sehr hilfreich, da so sicher ein "Fall-Back" gemacht
werden kann.
<p>
Wenn Sie schon zuvor einen 2.4 Kernel installiert haben, und ihn nicht erneut
installieren möchten, dann führen Sie die oben genannten Befehle bis zu dem
<prgn>apt-get</prgn> Kommando aus, und dann folgende:
<example>
# mkinitrd -o /boot/initrd.img-<var>2.4.17-686-smp</var>
/lib/modules/<var>2.4.17-686-smp</var>
# lilo
# tune2fs -j -i 0 <var>/dev/hda1</var>
# tune2fs -j -i 0 <var>/dev/hda2</var>
... tune2fs für alle EXT2 Dateisysteme wiederholen
# shutdown -r now
</example>
Von nun an ist EXT3 Journaling aktiviert.
<p>
Wenn <file>/etc/mkinitrd/modules</file> nicht gesetzt war als
<prgn>mkinitrd</prgn> ausgeführt wurde, und Sie während der Boot-Phase
zusätzliche Module hinzufügen möchten:
<example>
... um eine Shell (5 sec.) an dem initrd Prompt zu erhalten, RETURN drücken
# insmod jbd
# insmod ext3 # modprobe ext3 sollte alles nötige berücksichtigen
# insmod ext2
# ^D
... weiter geht's mit dem Boot-Vorgang
</example>
Die Meldung "cramfs: wrong magic" könnte in den System Meldungen beim
Boot-Vorgang (<prgn>dmesg</prgn>) auftreten, diese wird jedoch als harmlos
eingestuft. Dieses Problem wurde in Sarge (2002/10) gelöst. Siehe
<url id="&bug-ext3;"> und das <url id="&howtoext3;"
name="EXT3 File System mini-HOWTO"> oder <file>&f-howtoext3;</file> um
weitere Informationen zu erhalten.
<p>
Es wurde berichtet, dass auf einigen Systemen einige Kernel lock-ups
auftraten wenn EXT3 aktiviert war, aber was meinen 2.4.17 Kernel angeht,
hatte ich keine Probleme.
</sect1>

<sect1 id="ss-rtl8139">Realtek RTL-8139 Unterstützung in Kernel 2.4
<p>
Aus irgendwelchen Gründen heißt das RTL-8139 Modul ab dem 2.4er Kernel
8139too und nicht mehr rtl8139. Wenn Sie also von einem 2.2er Kernel
auf einen 2.4er upgraden, änderen Sie einfach die <file>/etc/modules</file>
dementsprechend ab.
</sect1>

<sect1 id="parport">Parallel Port Unterstützung
<p>
Von <package>kernel-image-2.4.*</package> wird Parallel Port Unterstützung
als Modul angeboten. Aktivieren Sie es wie folgt:
<example>
# modprobe lp
# echo lp >> /etc/modules
</example>
Siehe auch <file>Documentation/parport.txt</file> im Linux Quellcode.
</sect1>

<sect1 id="proc-sys">Zu viele geöffnete Dateien
<p>
Der Linux Kernel könnte unter Umständen die Meldung "Too many open files"
("Zu viele geöffnete Dateien") ausgeben. Der Grund hierfür ist, dass der
Standardwert (8096) für <tt>file-max</tt> sehr klein gewählt wurde.
Um dieses Problem zu lösen, führen Sie folgende Schritte als root aus oder
fügen Sie folgende Kommandos in ein init Script in <file>/etc/rcS.d/*</file>
ein.
<example>
# echo "65536"  >/proc/sys/fs/file-max  # für 2.2 und 2.4 Kernel
# echo "131072" >/proc/sys/fs/inode-max # nur für 2.2 Kernel
</example>
Um mehr Informationen über änderbare Kernel Parameter über das
<file>/proc</file> Dateisystem zu erhalten, lesen Sie die Linux Quellen
in <file>Documentation/sysctl/*</file>.
<p>
Für weitere Beispiele zur Manipulation von Kernel Parametern lesen Sie
<file>/etc/init.d/networking</file> und <ref id="killecn">.
</sect1>

</sect>
</chapt>
