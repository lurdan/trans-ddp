<!-- CVS revision of this document "$Revision: 1.12 $"  -->
<!-- CVS revision of original english document "1.63"  -->

<chapt id="kernel">Der Linux Kernel unter Debian
<p>
Debian hat eine eigene Methode einen Kernel und dazugehörige Module zu
kompilieren. Weitere Infos sind in <ref id="kernel-details"> zu finden.

<sect id="kernel-compile">Neukompilieren des Kernels
<p>
Die Tools <prgn>gcc</prgn>, <prgn>binutils</prgn> und
<prgn>modutils</prgn> aus Debian <tt>unstable</tt> sind sehr
hilfreich, wenn man einen aktuellen Linux Kernel kompilieren möchte.
Siehe <file>&f-kernel-readme;</file> um offizielle Informationen zu erhalten,
besonders der untere Teil ist interessant.
<p>

Einen eigenen Kernel zu kompilieren ist eine nicht ganz einfache Sache,
womit selbst begnadete Entwickler Schwierigkeiten haben könnten, gerade auch
weil diese Thematik eine sich ständig weiter entwickelnde ist.
<taglist compact>
<tag>Manoj Srivastava schrieb:
<item><tt>--initrd</tt> benötigt einen Debian-eigenen cramfs Patch.
<tag>Herbert Xu schrieb:
<item>Nein, das tut es nicht. Das einzige was nötig ist, um ein anderes
Dateisystem als CRAMFS zu nutzen, ist, MKIMAGE in
<file>/etc/mkinitrd/mkinitrd.conf</file> zu setzen.
</taglist>

<p>
Seien Sie vorsichtig und ziehen Sie <file>&f-kernel-readme;</file> von Manjo
und Kent stets zur Hilfe. Desweiteren stellen Sie sicher, dass Sie immer die
aktuellste Version des unstable <package>kernel-package</package> Paketes
haben, wenn Sie einen instabilen Kernel kompilieren möchten
<p>

Für einen Kernel, der nur für eine Maschine kompiliert ist, wird
<tt>initrd</tt> nicht benötigt. Weil ich aber möchte, dass mein Kernel nahezu
der gleiche ist, wie der, der von den kernel-image Paketen bereitgestellt
wird, nutze ich es
trotzdem. Wenn Sie <tt>initrd</tt> nutzen möchten, lesen Sie bitte
<manref name="mkinitrd" section="8"> und <manref name="mkinitrd.conf" section="5">.
Siehe auch <url id="&bug-initrd;">.


<sect1 id="kernel-debian">Die Debian Standardmethode
<p>
Beachten Sie Fehler Meldungen für <package>kernel-package</package>,
<prgn>gcc</prgn>, <prgn>binutils</prgn> und <prgn>modutils</prgn>.
Benutzen Sie neue Versionen von diesen Programmen wenn nötig.
<p>
Einen angepassten Kernel unter Debian zu kompilieren, bedarf ein
wenig Sorgfalt. Verwenden Sie die Option <tt>--append_to_version</tt> zusammen
mit <prgn>make-kpkg</prgn>, um mehrere Kernel zu verwalten.
<example>
# apt-get install debhelper modutils kernel-package libncurses5-dev
# apt-get install kernel-source-<var>2.4.18</var>   # installiere die aktuellste Version
# apt-get install fakeroot
# vi /etc/kernel-pkg.conf                # fügen Sie meinen Namen und meine eMail-Adresse hinzu
$ cd /usr/src                            # Arbeitsverzeichnis 
$ tar --bzip2 -xvf kernel-source-<var>2.4.18</var>.tar.bz2
$ cd kernel-source-<var>2.4.18</var>                # wenn das Ihre Kernel Sourcen sind
$ cp /boot/config-<var>2.4.18-386</var> .config     # verwenden Sie aktuelle .config als Default
$ make menuconfig                        # den Anforderungen entsprechend zusammenstellen
$ make-kpkg clean                        # muss laut 'man make-kpkg' ausgeführt werden
$ fakeroot make-kpkg --append_to_version -<var>486</var> --initrd \
        --revision=<var>rev.01</var> kernel_image \
        modules_image # modules_image ist für pcmcia-cs* und weitere...
$ cd ..
# dpkg -i kernel-image*.deb pcmcia-cs*.deb # installiert den Kernel
</example>

<tt>make-kpkg kernel_image</tt> führt <tt>make oldconfig</tt> und
<tt>make dep</tt> aus. Verwenden Sie <tt>--initrd</tt> nicht, wenn initrd
nicht ausgewählt wurde.
<p>
Wenn Kernel-Module aus pcmcia-cs oder ohne pcmcia benötigt werden, 
sollte im <tt>make menuconfig</tt> unter "General setup&mdash;&gt;" der 
Eintrag "PCMCIA/CardBus support  &mdash;&gt;" ausgewählt und die 
Konfiguration auf "&lt;&nbsp;&gt; PCMCIA/CardBus support" gesetzt werden, 
beispielsweise durch Deaktivieren der Box.
<p>

Auf einer SMP Maschine, setzen Sie CONCURRENCY_LEVEL der <manref
name="kernel-pkg.conf" section="5"> entsprechend.
</sect1>

<sect1 id="kernel-classic">Klassische Methode
<p>
Laden Sie den "reinen" Quellcode von
<list compact>
<item>Linux:     <url id="&linuxsrc;">
<item>pcmcia-cs: <url id="&pcmciasrc;">
</list>
herunter oder verwenden Sie einen äquivalenten Quellcode in Debian und führen
Sie folgende Schritte aus:
<example>
# cd /usr/src
# tar xfvz linux-<var>Version</var>.tar.gz
# rm -rf linux
# ln -s linux-<var>Version</var> linux
# tar xfvz pcmcia-cs-<var>Version</var>.tar.gz
# ln -s pcmcia-cs-<var>Version</var> pcmcia
# cd linux
# make menuconfig
... den Anforderungen entsprechend konfigurieren ...
# make dep
# make bzImage
... Konfiguration von lilo / grub ...
... kopieren von /usr/src/linux/arch/i386/boot/bzImage nach /boot ...
... /sbin/lilo oder grub ausführen
# make modules; make modules_install
# cd ../pcmcia
# make config
# make all
# make install
... Hinzufügen von benötigten Modulen zu /etc/modules
# shutdown -r now
... nun den neuen Kernel booten ...
</example>
</sect1>

<sect1 id="kernel-headers">Kernelheader
<p>
Die meisten Programme brauchen die Kernelheader Dateien nicht, und einige
Programme lassen sich sogar nicht erfolgreich kompilieren, wenn die Header
Dateien genutzt werden. Statt dessen sollten die Programme beim Kompilieren
gegen die Header Dateien gelinkt werden, gegen die auch
<strong><prgn>glibc</prgn> gelinkt wurde</strong>.
Auf einem &debian;-System sind diese
Kernelheader-Dateien in <file>/usr/include/linux</file> und
<file>/usr/include/asm</file> zu finden.
<p>
Entgegen einigen veralteten Dokumentationen, sollten keine symbolischen
Links in <file>/usr/src/linux</file> von <file>/usr/include/linux</file> 
und <file>/usr/include/asm</file> erstellt werden.
<p>
Es sollte, wenn ein Programm bestimmte Kernelheader Dateien für
Kernel-spezifische Programme benötigt, statt dessen das Makefile
so angepasst werden, dass der Pfad der einzubindenden Header Dateien folgende
Pfade enthält
<file><var>Verzeichnis-bestimmter-Kernelheader</var>/include/linux</file> und
<file><var>Verzeichnis-bestimmter-Kernelheader</var>/include/asm</file>.
</sect1>

</sect>

<sect id="kernel-modules">Der modularisierte Kernel 2.4
<p>
Die neuen Debian 2.4 Kernel, welche von
<package>kernel-image-2.4.<var>NN</var></package>
zur Verfügung gestellt werden, sind sehr stark modularisiert. Es muss
sichergestellt sein, dass Module die verwendet werden sollen auch aktiviert
sind, damit der Kernel wie gewünscht arbeitet.
<p>
Obwohl ich viele Beispiele für <file>/etc/modules</file> im folgenden
Abschnitt als schnellen Fix habe, höre ich immer wieder, dass der richtige
Weg, diese Modul abhängigen Probleme zu lösen, ist, Aliase für die Geräte in
Dateien unterhalb von <file>/etc/modutils/</file> anzulegen, da es genug
davon in aktuellen Kernel gibt. Einige Module könnten automatisch von
Hardwareerkennungsprogrammen wie <package>discover</package> aktiviert
werden. Vergleichen Sie auch <ref id="hdetect-x">.
<p>
Siehe <ref id="modules"> und <file>Documentation/*.txt</file> im Linux Quellcode, um genauere
Informationen zu erhalten.

<sect1 id="kernel-pcmcia">PCMCIA
<p>
<file>/etc/modules</file> muss eventuell folgendes enthalten, damit alte
PCMCIA-Hardware korrekt funktioniert:
<example>
# ISA PnP Treiber
isa-pnp
# neuer lowlevel PCMCIA-Treiber
# yenta_socket # in meinem Fall jedoch nicht nötig
</example>
Für den Rest von PCMCIA sorgen die Skripte (aus dem
<package>pcmcia-cs</package> Paket)
<prgn>depmod</prgn> und <prgn>kmod</prgn>. <prgn>isa-pnp</prgn>
brauchte ich auch, weil mein Laptop ein altes ISA-PCMCIA Modell ist.
Neuere Laptops mit Cardbus/PCMCIA sollten dies nicht mehr brauchen.
<p>
Ein Zitat vom genialen Miquel van Smoorenburg
<email>miquels@cistron.nl</email>: <!-- FIXME: gibt es ein <quote> ? -->
<p>
"Ich habe einfach alles was mit PCMCIA zu tun hat, inklusive cardmgr,
von meinem Laptop gelöscht und einen 2.4 Kernel mit CardBus Unterstützung
installiert, plus das neue <package>hotplug</package> Paket aus Woody.
<p>
Solange man nur 32-bit Karten hat, wird das pcmcia Paket nicht benötigt;
2.4 stellt die nötigen Karten-Dienste von sich aus zur Verfügung.
Und der Standard tulip Treiber sollte wunderbar mit der Dlink Karte arbeiten.
<p>
&ndash; Mike."
<p>
Sehen Sie dazu auch das <url id="&pcmcia-howto;" name="Linux PCMCIA HOWTO">
und <ref id="trigger-pcmcia">.
</sect1>

<sect1 id="kernel-scsi">SCSI
<p>  <!-- Osamu: maybe test this section? I do not have SCSI :(  
                                     But this is almost sure :) -->
[NICHT GETESTET] <file>/etc/modules</file> braucht folgendes damit
SCSI funktioniert:
<example>
# SCSI core
scsi_mod
# SCSI generic driver
sg
# SCSI disk
sd_mod
# Alle anderen HW Module
...
</example>
<prgn>depmod</prgn> sollte auf die oben genannten Module achten.
</sect1>

<sect1 id="kernel-net">Netzwerk Funktionalität
<p>
<file>/etc/modules</file> sollte für zusätzliche Netzwerk Funktionalität
folgendes enthalten:
<example>
# net/ipv-4
ip_gre
ipip

# net/ipv-4/netfilter
# iptable (in Reihenfolge)
ip_tables
ip_conntrack
ip_conntrack_ftp
iptable_nat
iptable_filter
iptable_mangle
#
ip_nat_ftp
ip_queue
#
ipt_LOG
ipt_MARK
ipt_MASQUERADE
ipt_MIRROR
ipt_REDIRECT
ipt_REJECT
ipt_TCPMSS
ipt_TOS
ipt_limit
ipt_mac
ipt_mark
ipt_multiport
ipt_owner
ipt_state
ipt_tcpmss
ipt_tos
ipt_unclean
#
#ipchains
#ipfwadm
</example>
Oben genanntes ist nicht optimiert. <prgn>depmod</prgn> sollte auf die oben
genannten Module achten.
</sect1>

<sect1 id="ext3">EXT3 Dateisystem ( &gt; 2.4.17)
<p>
Die Journaling Funktionalität für das EXT3 Dateisystem mit einem
vorkompilierten Kernel-Image ( &gt; 2.4.17) von Debian zu aktivieren, setzt
die folgenden Schritte voraus:
<example>
# cd /etc; mv fstab fstab.old
# sed 's/ext2/ext3,ext2/g' &lt;fstab.old &gt;fstab
# vi /etc/fstab
... setzen Sie den root Dateisystem Typ auf "auto" anstelle von "ext3,ext2"
# cd /etc/mkinitrd
# echo jbd &gt;&gt;modules
# echo ext3 &gt;&gt;modules
# echo ext2 &gt;&gt;modules
# cd /
# apt-get update; apt-get install kernel-image-<var>2.4.17-686-smp</var>
... installieren Sie den aktuellsten Kernel und konfigurieren Sie LILO
dementsprechend
# tune2fs -j -i 0 <var>/dev/hda1</var>
# tune2fs -j -i 0 <var>/dev/hda2</var>
... tune2fs für alle EXT2 Dateisysteme wiederholen
# shutdown -r now
</example>
Von nun an ist EXT3 Journaling aktiviert.
Für den Fall, dass der Kernel EXT3 für root Partitionen nicht unterstützt,
erweist sich <tt>ext3,ext2</tt> als Dateisystem "Typ" in der
<prgn>fstab</prgn> als sehr hilfreich, da so sicher ein "Fall-Back" gemacht
werden kann.
<p>
Wenn Sie schon zuvor einen 2.4 Kernel installiert haben, und ihn nicht erneut
installieren möchten, dann führen Sie die oben genannten Befehle bis zu dem
<prgn>apt-get</prgn> Kommando aus, und dann folgende:
<example>
# mkinitrd -o /boot/initrd.img-<var>2.4.17-686-smp</var>
/lib/modules/<var>2.4.17-686-smp</var>
# lilo
# tune2fs -j -i 0 <var>/dev/hda1</var>
# tune2fs -j -i 0 <var>/dev/hda2</var>
... tune2fs für alle EXT2 Dateisysteme wiederholen
# shutdown -r now
</example>
Von nun an ist EXT3 Journaling aktiviert.
<p>
Wenn <file>/etc/mkinitrd/modules</file> nicht gesetzt war als
<prgn>mkinitrd</prgn> ausgeführt wurde, und Sie während der Boot-Phase
zusätzliche Module hinzufügen möchten:
<example>
... um eine Shell (5 sec.) an dem initrd Prompt zu erhalten, RETURN drücken
# insmod jbd
# insmod ext3 # modprobe ext3 sollte alles nötige berücksichtigen
# insmod ext2
# ^D
... weiter geht's mit dem Boot-Vorgang
</example>
Die Meldung "cramfs: wrong magic" könnte in den System Meldungen beim
Boot-Vorgang (<prgn>dmesg</prgn>) auftreten, diese wird jedoch als harmlos
eingestuft. Dieses Problem wurde in Sarge (2002/10) gelöst. Siehe
<url id="&bug-ext3;"> und das <url id="&howtoext3;"
name="EXT3 File System mini-HOWTO"> oder <file>&f-howtoext3;</file> um
weitere Informationen zu erhalten.
<p>
Es wurde berichtet, dass auf einigen Systemen einige Kernel lock-ups
auftraten wenn EXT3 aktiviert war, aber was meinen 2.4.17 Kernel angeht,
hatte ich keine Probleme.
</sect1>

<sect1 id="ss-rtl8139">Realtek RTL-8139 Unterstützung in Kernel 2.4
<p>
Aus irgendwelchen Gründen heißt das RTL-8139 Modul ab dem 2.4er Kernel
8139too und nicht mehr rtl8139. Wenn Sie also von einem 2.2er Kernel
auf einen 2.4er upgraden, ändern Sie einfach die <file>/etc/modules</file>
dementsprechend ab.
</sect1>

<sect1 id="parport">Parallel Port Unterstützung
<p>
Von <package>kernel-image-2.4.*</package> wird Parallel Port Unterstützung
als Modul angeboten. Aktivieren Sie es wie folgt:
<example>
# modprobe lp
# echo lp >> /etc/modules
</example>
Siehe auch <file>Documentation/parport.txt</file> im Linux Quellcode.
</sect1>
</sect>

<sect id="proc-sys">Tunen des Kernels mittels des proc Dateisystems
<p>
Das Verhalten des Linux Kernels kann dynamisch durch das proc Dateisystem
geändert werden.
<p>
Für grundlegende Informationen über das Ändern von Kernelparametern durch das
<file>/proc</file> Dateisystem, lesen Sie im Linux Quellcodeverzeichnis
<file>Documentation/sysctl/*</file>.
<p>
Einige Beispiele der Kernelparametermanipulation können in
<file>/etc/init.d/networking</file> und <ref id="killecn"> gefunden werden.
<p>
Sehen Sie in <manref name="sysctl.conf" section="5"> wie man den Kernel zur
Bootzeit mittels des <file>/proc</file> Dateisystems konfigurieren kann.
Dazu wird das Skript <file>/etc/init.d/procps.sh</file> genutzt, das in der
Regel aus <file>/etc/rcS.d/S30procps.sh</file> gestartet wird.

<sect1 id="many-files">Zu viele geöffnete Dateien
<p>
Der Linux Kernel könnte unter Umständen die Meldung "Too many open files"
("Zu viele geöffnete Dateien") ausgeben. Der Grund hierfür ist, dass der
Standardwert (8096) für <tt>file-max</tt> sehr klein gewählt wurde.
Um dieses Problem zu lösen, führen Sie folgende Schritte als root aus:
<example>
# echo "65536"  &gt; /proc/sys/fs/file-max  # für 2.2 und 2.4 Kernel
# echo "131072" &gt; /proc/sys/fs/inode-max # nur für 2.2 Kernel
</example>
Alternativ können Sie folgendes in <file>/etc/sysctl.conf</file> eintragen,
um diese Änderungen permanent zu aktivieren:
<example>
file-max=65536   # für 2.2 und 2.4 Kernel
inode-max=131072 # nur für 2.2 Kernel
</example>

<sect1 id="bdflush">Disk Flush Intervalle
<p>
Sie können Disk Flush Intervalle durch das proc Dateisystem ändern. Das
folgende kürzt das Intervall von standardmäßig fünf Sekunden auf eine
Sekunde.
<example>
# echo "40 0 0 0 100 30000 60 0 0"  &gt; /proc/sys/vm/bdflush
</example>
Dies kann die Ein-/Ausgabe-Performance ein klein wenig negativ beeinflussen. 
Aber dies sichert den Dateiinhalt mit Ausnahme der letzten Sekunde, was
kürzer ist als die standardmäßigen fünf Sekunden. Dies ist selbst für die
Journaling Dateisysteme wahr.
</sect1>

<sect1 id="over-commit">Trägheit alter Maschinen mit wenig Speicher
<p>
Für einige alte Systeme mit wenig Speicher kann es immer noch sinnvoll sein,
over-commit von Speicher durch das proc Dateisystem zu aktivieren:
<example>
# echo 1 &gt; /proc/sys/vm/overcommit_memory
</example>
</sect1>

</sect>
</chapt>
