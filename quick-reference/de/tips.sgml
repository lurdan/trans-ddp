<!-- CVS revision of this document "$Revision: 1.12 $"  -->
<!-- CVS revision of original english document "1.98"  -->
<!-- This file is part of the german Version of the debian reference -->
<!-- Document is available at qref.sourceforge.net -->
<!-- Uebersetzung 11/2002 Stefan Schroeder, stefan@fkp.uni-hannover.de -->

<chapt id="tips">&debian;-Tipps

<sect id="booting">Booten des Systems
<p>
Detaillierte Informationen über den Boot-Prompt (also die Eingabeaufforderung
beim Systemstart) gibt es beim LDP 
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO">.

<sect1 id="crackroot">"Ich habe das root-Passwort vergessen!" (1)
<p>
Sobald man Zugriff auf die Tastatur eines Rechners hat, kann das
System gestartet werden und ein Login stattfinden, auch ohne das
root-Passwort zu kennen. (Dies setzt allerdings voraus, dass keine
zusätzlichen Schutzmaßnahmen ergriffen wurden, wie z.B. ein 
BIOS-Passwort oder eine Passwortabfrage durch <prgn>lilo</prgn>, was ein
Booten des Systems verhindern würde.)
<p>
Dies ist ein Vorgehen, das keine externen Boot-Medien und Änderungen der
BIOS-Einstellungen benötigt. Die Bezeichnung für die voreingestellte
Boot-Option sei "Linux".
<p>
Sobald die <prgn>lilo</prgn>-Boot-Meldung <tt>boot:</tt> erscheint
(auf einigen Systemen muss die Shift-Taste/Umschalt-Taste gedrückt werden,
um einen automatischen Bootvorgang zu unterbrechen), ist folgendes
einzugeben:
<example>
boot: Linux init=/bin/sh
</example>
Das System startet nun den Kernel und daraufhin das Programm
<file>/bin/sh</file> anstelle des üblichen <prgn>init</prgn>-Prozesses.
Die nun erlangte Shell hat root-Privilegien. Da das Hauptverzeichnis
<file>/</file> nur les- aber nicht schreibbar ist und viele während des
üblichen Boot-Prozesses eingeklinkten Verzeichnisse nicht erreichbar sind,
müssen diese nachträglich gemountet werden, um ein vernünftiges Arbeiten
zu ermöglichen:
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(Wenn in der Datei <file>/etc/passwd</file> das zweite Datenfeld
bei allen Einträgen ein "x" ist, dann
benutzt das System shadow-Passwörter. In diesem Fall muss statt
<file>/etc/passwd</file> die Datei <file>/etc/shadow</file> editiert
werden.) Um das root-Passwort zurückzusetzen, muss das zweite Feld des
root-Eintrags gelöscht werden. Nach einem Neustart ist das
root-Passwort leer und kann neu vergeben werden. Wenn das System in den
Runlevel 1 fährt, wird (zumindest bei Debian-Versionen nach Potato)
ein Passwort benötigt.
<p>
Ein Editor im
<file>/bin/</file>-Verzeichnis ist absolut empfehlenswert, für den Fall, dass
der <file>/usr/</file>-Baum nicht erreichbar ist (siehe dazu auch
<ref id="bin-editor">).
<p>
Für Notfälle hat sich außerdem <package>sash</package> (stand
alone shell) bewährt. Wenn das System nicht mehr gebootet werden kann, geben
Sie am <prgn>lilo</prgn>-Prompt folgendes ein:
<example>
boot: Linux init=/bin/sash
</example>
Das Programm <prgn>sash</prgn> dient als Ersatz für <prgn>sh</prgn>, selbst
wenn <file>/bin/sh</file> nicht nutzbar ist. Es ist statisch gelinkt und hat
viele Standardbefehle eingebaut.
(Wenn <prgn>sash</prgn> gestartet ist, wird "help" eine kurze Referenz
anzeigen.)
</sect1>

<sect1 id="crackroot2">"Ich habe das root-Passwort vergessen!" (2)
<p>
Starten Sie das System mit einer Rettungsdiskette/-CD. Sei
<file><var>/dev/hda3</var></file> die root-Partition. Dann kann die
Passwortdatei editiert werden durch:
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
Der Vorteil dieser Variante ist, dass ein eventuell vergebenes
<prgn>lilo</prgn>-Passwort umgangen werden kann. Erforderlich ist allerdings,
dass im BIOS die Einstellung für das Boot-Laufwerk manipuliert werden kann
(falls es nicht schon entsprechend eingestellt ist).
</sect1>

<sect1 id="dead-lilo">Das System kann nicht gestartet werden
<p>
Dies ist kein Problem, selbst wenn Sie keine Boot-Diskette während der
Installation angelegt haben. Wenn <prgn>lilo</prgn> defekt ist, können
Sie die Boot-Disk des Debian-Installationsets verwenden und davon Ihr System
booten. Wenn Ihre root-Partition <file><var>/dev/hda12</var></file> ist und
im Runlevel 3 gestartet werden soll, geben Sie folgendes am Boot-Prompt ein:
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
Danach haben Sie ein fast vollständig funktionsfähiges System mit dem Kernel
des Installationsmediums gestartet. (Es kann einige kleinere Probleme 
aufgrund fehlender Kerneleigenschaften oder Module geben.)
<p>
Vergleichen Sie <ref id="un-bootable"> wenn Sie ein defektes System haben.
<p>
Benötigen Sie eine angepasste Boot-Diskette, folgen Sie den Anweisungen in
<file>readme.txt</file> auf der Rettungsdiskette.
</sect1>

<sect1 id="no-x-start">Abschalten von X beim Booten
<p>
Dem Nachjagen von <tt>unstable/sid</tt> ist lustig, aber ein fehlerhaftes
<prgn>xdm</prgn>, <prgn>gdm</prgn>, <prgn>kdm</prgn> und <prgn>wdm</prgn>, das
während des Boot-Prozesses gestartet wird, kann sehr unangenehm sein.
<p>
Zuerst sollten Sie Zugang zu einer root-Shell erlangen, indem Sie folgendes
am Boot-Prompt eingeben:
<example>
boot: <var>Linux</var> vga=normal s
</example>
Hier steht <var>Linux</var> für das Kernel-Image das Sie starten;
"vga=normal" stellt sicher, dass <prgn>lilo</prgn> im normalen VGA Modus
startet und "s" (oder "S") ist der Parameter der an <prgn>init</prgn>
weitergegeben wird und für Single-User-Modus steht.  Geben Sie das root
Passwort am Prompt ein.
<p>
Es gibt mehrere Möglichkeiten alle Daemonen die X starten zu deaktivieren:
<list>
<item>Starten von <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6 .</tt>
<item>Einfügen von "exit 0" am Anfang der
      <file>/etc/init.d/<var>?</var>dm</file> Dateien.
<item>Umbenennen aller <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>
      Dateien in <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>Entfernen aller <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>
      Dateien.
<item>Starten von <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Hier muss die Nummer in <file>rc<var>2</var>.d</file> dem Runlevel entsprechen, das in der 
<file>/etc/inittab</file> Datei angegeben wurde. <file><var>?</var>dm</file>
bedeutet, dass das Kommando mehrfach ausgeführt wird, wobei es jeweils durch
<prgn>xdm</prgn>, <prgn>gdm</prgn>, <prgn>kdm</prgn> und
<prgn>wdm</prgn> ersetzt wird.
<p>
Nur der erste Weg ist "der eine wahre Weg" in &debian;.  
Der letzte ist einfach, funktioniert aber nur in &debian; und erfordert, dass
der Display-Manager später mit <prgn>dpkg-reconfigure</prgn> gesetzt wird.
Alles andere sind allgemeine Methoden um Daemonen zu deaktivieren.
<p>
Sie können immer noch X mit dem <prgn>startx</prgn> Kommando von einer
beliebigen Konsole starten.
</sect1>

<sect1 id="bootprompt">Weitere Tricks mit dem Boot-Prompt
<p>
Mittels des <prgn>lilo</prgn>-Boot-Prompts kann das System in einem
beliebigen Runlevel gestartet werden. Details dazu finden sich im
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Soll das System im Runlevel 4 starten, verwenden Sie folgende Eingabe am
<prgn>lilo</prgn> Boot-Prompt.
<example>
boot: Linux 4
</example>
<p>
Wenn das System im normal funktionierendem Einzelnutzer-Modus gestartet werden
soll und Sie das root Passwort kennen, so kann eins der folgenden Beispiele
am <prgn>lilo</prgn> Boot-Prompt verwendet werden.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Auch der benutzte Speicherbereich kann eingeschränkt werden. Das folgende
Beispiel weist das System an, nur 48MB des verfügbaren Speichers zu 
belegen.
<example>
boot: Linux mem=48M
</example>
Achtung: Wird an dieser Stelle mehr Speicher angegeben als vorhanden, wird
der Kernel abstürzen. Wenn man mehr als 64 MB Speicher hat, kann es bei
alten Kernels und/oder Mainboards passieren, dass das System nur 64MB nutzt.
In diesem Fall kann man versuchen den ungenutzten Speicher mit
<tt>mem=128M</tt> zu aktivieren. Äquivalent dazu ist ein Eintrag in der
Datei <file>/etc/lilo.conf</file>.
</sect1>

<sect1 id="bootgrub">Setzen von GRUB Boot-Parametern
<p>
GRUB ist ein neuer Boot-Manager des GNU Hurd Projekts und ist viel flexibler
als Lilo aber handhabt die Boot-Parameter etwas anders.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Sie müssen die Hurd Gerätenamen kennen:
<example>
Hurd/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,1)             /dev/hda1           C: (usually)
 (hd0,4)             /dev/hda4           F: (usually)
 (hd1,4)             /dev/hdb4           ?
</example>
Vergleichen Sie <file>&f-grub;</file> und <file>&f-grub-doc;</file> für
Details.
</sect>

<sect>Aufzeichnung von Aktivitäten

<sect1 id="script">Aufzeichnen von Shell-Eingaben 
<p>
Um ein Unix-artiges System gekonnt zu administrieren, sind mitunter
knifflige oder raffinierte Aufgaben zu erledigen. Machen Sie sich
deshalb mit den grundlegenden Konfigurationsaufgaben vertraut, so 
dass Sie im Notfall wissen, wo Sie Hand anlegen müssen.
Fensterbasierte Konfigurations-Werkzeuge sind nett und bequem, nutzen
aber nichts, wenn man versucht eine defekte X-Window-Konfiguration
wieder herzustellen.
<p>
Die Aufzeichnung von Tastatur-Eingaben ist, insbesondere als root, 
hin und wieder nützlich.
<p>
Emacs: M-x <tt>shell</tt> startet die Aufzeichnung. ("M" steht hier für
die Meta-Taste, meist Alt oder auch Esc.) C-x C-w schreibt die
aufgezeichnete Sequenz in eine Datei.
<p>
Shell: Verwenden Sie das <prgn>screen</prgn> Kommando mit "^A H", wie in
<ref id="screen"> beschrieben oder dass <prgn>script</prgn> Kommando. 
<example>
$ script
Script wurde gestartet, die Datei ist typescript
 ... irgendwelche Eingaben ...
 Strg-D
$ col -bx &lt;typescript &gt;Sicherung
$ vi Sicherung
</example>
Falls das <prgn>script</prgn>-Programm fehlt, kann diese Funktion mit
der Shell simuliert werden:
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>X Aktivitäten aufzeichnen
<p>
Um den grafischen Bildschirm aufzunehmen, auch X-Terminals und andere
beliebige Fenster, kann <prgn>gimp</prgn> benutzt werden. 
Alternativen sind <prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>) und <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>

</sect>

<sect id="archiving">Kopieren und Archivieren eines Unterverzeichnis
<sect1>Grundlegende Kommandos zum Kopieren eines Unterverzeichnis
<p>
Möchte man seine Verzeichnisstruktur neu arrangieren, verschiebt man den
Inhalt inklusive Datei-Links wie folgt:
<example>
Standardmethode:
# cp -a /source/directory /dest/directory # erfordert GNU cp
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
Wenn ein harter Link beteiligt ist, benötigt man eine pedantische
Methode:
# cd /Pfad/zum/alten/Verzeichnis
# find . -depth -print0 | afio -p -xv -0a /neues/Verzeichnis
Vom entfernten Rechner:
# (cd /Quell/Verzeichnis &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /Ziel/Verzeichnis &amp;&amp; tar xvfp - )
Wenn es keine Links gibt:
# scp -pr user1@host1.dom:/Quell/Verzeichnis \
          user2@host2.dom:/Ziel/Verzeichnis
</example>
Hier gilt <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> und <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
Die folgenden vergleichenden Informationen zum Kopieren eines kompletten
Unterverzeichnis wurden von Manoj Srivastava
<email>srivasta@debian.org</email> auf debian-user@lists.debian.org
aufgeführt.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Ursprünglich war das <prgn>cp</prgn> Programm für diesen Zweck nicht gut 
geeignet, da es keine symbolischen Links auflösen oder harte Links
beibehalten konnte. Ein anderer Punkt waren spärliche (sparse) Dateien
(Dateien mit Löchern).
<p>
Die GNU-Version von <prgn>cp</prgn> überwand zwar diese Probleme, doch auf
nicht-GNU-Systemen kann es noch zu Schwierigkeiten kommen. Desweiteren kann
<prgn>cp</prgn> keine kleinen, portablen Archive erzeugen.
<example>
&percnt; cp -a . neuesverzeichnis
</example>

<sect1><prgn>tar</prgn>
<p>
Das Archivierungsprogramm <prgn>tar</prgn> kann im Gegensatz zu
<prgn>cp</prgn> mit symbolischen Links umgehen. Obwohl <prgn>cpio</prgn>
mit speziellen Dateien umgehen kann, konnten ältere <prgn>tar</prgn>
Versionen dies nicht.
<p>                                                             
Wenn <prgn>tar</prgn> auf mehrere harte Links einer Datei stößt, wird
nur einmal die Datei in das Archiv kopiert; die Datei kann dann <em>nur</em>
unter dem Namen der ursprünglichen Datei zurückgewonnen werden.
<prgn>cpio</prgn> dagegen kopiert für jeden harten Link die komplette Datei
in das Archiv, so dass sie unter jedem der Link-Namen wiedergeholt werden
kann.
<p>
Das <prgn>tar</prgn> Kommando hat die Option für das Packen mit
<file>.bz2</file> Dateien zwischen Potato und Woody umbenannt. Empfohlen wird
deshalb in Skripten die Option <tt>--bzip2</tt> statt der Kurzform <tt>-I</tt>
(Potato) oder <tt>-j</tt> (Woody).
</sect1>

<sect1><prgn>pax</prgn>
<p>
Hinter dem Namen <prgn>pax</prgn> (IEEE-Standard 1003.2-1992, 
Seiten 380&ndash;388 (Abschnitt 4.48) und Seiten 936&ndash;940 (Abschnitt
E.4.48)) verbirgt sich ein multifunktionales POSIX-Werkzeug zum Austausch von
portablen Archiven.
<prgn>pax</prgn> liest und schreibt Archive, listet deren Inhalt auf,
und kopiert Verzeichnishierarchien. <prgn>pax</prgn> arbeitet unabhängig von
einem spezifischen Archivformat und unterstützt eine große Bandbreite an
Formaten.
<p>
<prgn>pax</prgn> ist noch neu und es können noch Kinderkrankheiten
auftreten.
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 oder
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
Das Kommando verwaltet die gleichnamigen Archive oder auch solche, die
mit <prgn>tar</prgn> erstellt wurden.
Das Archiv kann statt einer Datei auch eine Pipe oder ein Magnetband sein.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> ersetzt <prgn>cpio</prgn>. Es liest dessen Archive
schneller, unterstützt mehr Laufwerksoptionen, hat eine bessere Fehlerkorrektur
und kann das Archiv auf mehrere Medien verteilen. Die Kompression mit
<prgn>afio</prgn> ist zuverlässiger als die von <prgn>tar</prgn> und
<prgn>cpio</prgn>. Am besten benutzt man <prgn>afio</prgn> in 
Backup-Skripts als "Archiv-Maschinerie".
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
Ich mache alle meine Backups auf Band mit <prgn>afio</prgn>. 
</sect1>
</sect>

<sect id="diff-backup">Differenzielles Backup und Datensynchronisation
<p>
Differenzielle Backups und Datensynchronisation kann mit verschiedenen
Methoden implementiert werden:
<list>
<item><package>rcs</package>:  Backups, auch mehrerer älterer Versionen, nur
      für Texte
<item><package>rdiff-backup</package>: Backups, auch mehrerer älterer
      Versionen. Symbolische Links werden unterstützt.
<item><package>pdumpfs</package>: Backups, auch mehrerer älterer Versionen
      in einem Dateisystem. Symbolische Links werden unterstützt.
<item><package>rsync</package>:  1-Wege Synchronisation
<item><package>unison</package>:  2-Wege Synchronisation
<item><package>cvs</package>:  Mehr-Wege Synchronisation mit
      Server-Backups, auch mehrerer älterer Versionen, nur für Texte,
      ausgereift. Vergleichen Sie mit <ref id="cvs">.
<item><package>arch</package>:  Mehr-Wege Synchronisation mit Server-Backups,
      auch mehrerer älterer Versionen. Es gibt keine Dinge wie
      "Arbeitsverzeichnis".
<item><package>subversion</package>: Mehr-Wege Synchronisation mit 
      Server-Backups, auch mehrerer älterer Versionen, Apache.
</list>
Kombinationen einer dieser Methoden mit der Archivierungsmethode, die in
<ref id="archiving"> beschrieben ist und den automatisierten Jobs in
<ref id="cronjob"> bilden ein nettes Backup-System.
<p>
Ich werde drei einfach zu nutzende Hilfsmittel angeben.

<sect1 id="rdiff-backup">Differenzielles Backup mit rdiff
<p>
<package>rdiff-backup</package> bietet ein nettes und einfaches Backup mit
differenziellen Versionen für beliebige Dateitypen, inklusive symbolischen
Links. Sichern des Großteils von <file>~/</file> nach <file>/mnt/backup</file>:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
Wiederherstellen von drei Tage alten Daten aus diesem Archiv nach
<file>~/old</file>:
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
Vergleichen Sie <manref name="rdiff-backup" section="1">.

<sect1 id="pdumpfs-backup">Tägliches Backup mit <package>pdumpfs</package>
<p>
<package>pdumpfs</package> ist ein einfaches System zum täglichen Backup,
ähnlich zu Plan9's <prgn>dumpfs</prgn>, das tägliche Schnappschüsse bewahrt.
Man kann auf die letzten Schnappschüsse zu beliebiger Zeit zugreifen, um eine
Datei eines bestimmten Tages wiederherzustellen. Führen Sie ein Backup Ihres
Homeverzeichnisses mit <prgn>pdumpfs</prgn> und <prgn>cron</prgn> aus!
<p>
<prgn>pdumpfs</prgn> erstellt die Schnappschüsse <tt>YYYY/MM/DD</tt> im
Zielverzeichnis. Alle Quelldateien werden in das Schnappschussverzeichnis
kopiert, wenn <prgn>pdumpfs</prgn> das erste Mal gestartet wird. Beim zweiten
und folgenden Male kopiert <prgn>pdumpfs</prgn> nur aktualisierte oder neu
erstellte Dateien und speichert nicht geänderte Dateien als harte Links auf
die Dateien vom Schnappschuss des letzten Tages, um Speicherplatz zu sparen.
<example>
$ pdumpfs <var>src-dir</var> <var>dest-dir</var> [<var>dest-basename</var>]
</example>
Vergleichen Sie <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">Regelmäßige differenzielle Backups mit RCS
<p>
<package>Changetrack</package> zeichnet Änderungen von textbasierten
Konfigurationsdateien regelmäßig in RCS Archiven auf.  
Sehen Sie <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>

<sect>Wiederherstellen eines eingefrorenen Systems
<sect1 id="kill">Einen Prozess killen/beenden
<p>
<prgn>top</prgn> hilft außer Kontrolle geratene
Prozesse zu identifizieren. `P' sortiert die Spalten nach CPU-Last, `M'
nach Speicherverbrauch und `k' kann einen Prozess "abschießen".
Alternativ kann das BSD-artige <tt>ps aux | less</tt> oder System V-artige
<tt>ps -efH | less</tt> verwendet werden. Die System V-artige Syntax zeigt
die IDs der Elternprozesse (<tt>PPID</tt>), die zum Killen von
Zombie-Kindprozessen genutzt werden können.
<p>
Verwenden Sie <prgn>kill</prgn> zum Killen eines Prozesses mittels der
Prozess-ID-Nummer (oder um ihm Signale zu senden). <prgn>killall</prgn>
bewerkstelligt das selbe über den Namen des Programms. Oft verwendete
Signale sind
<example>
 1: HUP,  Daemon neustarten
15: TERM, normales Beenden
 9: KILL, erzwungenes Beenden
</example>

</sect1>

<sect1>Alt-SysRq
<p>
Wenn der Kernel mit Unterstützung der "magischen SysRq-Taste" kompiliert
wurde, kann das System mit etwas Glück auch aus dem totalen Nirwana geholt
werden. Drücken von Alt-SysRq (SysRq ist oft mit "Druck" beschriftet) bei
einem i386, gefolgt von einer der Tasten
<tt>r 0 k e i s u b</tt>, aktiviert die Kernel-Notbremse.
<p>
`r' stellt die Tastatur wieder her, nachdem beispielsweise X abgestürzt ist.
`0' setzt den Level mit dem Fehlermeldungen auf der Konsole ausgegeben
werden herunter. `k' (system attention key) killt alle Prozesse auf der
aktuellen virtuellen Konsole. `t' beendet alle Prozesse des aktuellen
Terminals außer <prgn>init</prgn>. `i' killt alle Prozesse außer
<prgn>init</prgn>.
<p>
`S'ync, `u'mount  und re`b'oot sind wirklich nur für den allerletzten
Notfall.
<p>
Debian Standard Kernel sind, zur Zeit der dieses Dokument geschrieben wird,
nicht mit dieser Option kompiliert. Es muss zur Nutzung dieser Taste ein
neuer Kernel kompiliert werden. Detaillierte Informationen finden sich in 
<file>/usr/share/doc/kernel-doc-<var>version</var>/Documentation/sysrq.txt.gz</file>
oder
<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>


<sect id="nifty">Elegante kleine Kommandos zum Merken

<sect1>Dateibetrachter
<p>
<prgn>less</prgn> ist der Standard-Dateibetrachter, der Textdateien seitenweise
ausgibt. Hilfe bietet `h'. <prgn>less</prgn> kann mehr als dessen Urahn 
<prgn>more</prgn>. Es kann mit <tt>eval $(lesspipe)</tt> oder <tt>eval
$(lessfile)</tt> in einer Shell-Startdatei überladen (erweitert) werden.
Sehen Sie hierzu <file>&f-lessopen;</file>. Die Option <tt>-R</tt> erlaubt die
Ausgabe von Sonderzeichen (raw characters) und schaltet die ANSI Farbsequenzen
ein. Vergleichen Sie <manref name="less" section="1">.
<p>
<prgn>w3m</prgn> kann für einige Code-Systeme (EUC) eine Alternative sein.

<sect1>Freier Speicher
<p>
<prgn>free</prgn> und <prgn>top</prgn> informieren über freien Speicher und
dessen Verbrauch. Sorgen Sie sich nicht um die Größe des "used"-Eintrags in
der zweite Datenzeile, sondern lesen Sie den Wert darunter ab (hier: 38792)
<example>
$ free -k # für 256MB Hauptspeicher
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
Die präzise Menge an Hauptspeicher, die zur Verfügung steht, kann mit
<tt>grep '^Memory' /var/log/dmesg</tt> bestätigt werden, was in diesem Fall
"Memory: 256984k/262144k available (1652k kernel code, 412k reserved,
2944k data, 152k init)" ergibt.
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Etwa 5MB können nicht vom System verwendet werden, da der Kernel sie in
Beschlag nimmt.
</sect1>

<sect1>Setzen der Uhrzeit (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
Dies setzt die Hardware-Uhr auf MM/DD hh:mm, CCYY. Dabei stehen die Kürzel
für DD=Tag, MM=Monat, hh=Stunde, mm=Minute, CCYY=Jahr. Die Zeiten werden in
lokaler Zeit ausgegeben, die Hardware-Uhr verwendet jedoch UTC als Zeitzone.

<sect1>Setzen der Uhrzeit (NTP)
<p>
Referenz: <url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">.
<p>
<sect2>Setzen der Zeit bei permanenter Internet-Verbindung
<p>
Die Uhrzeit kann automatisch mit Hilfe eines Zeit-Servers korrekt gesetzt
werden:
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
Dies sollte in <file>/etc/cron.daily/</file> verwendet werden, wenn man eine
permanente Internet-Verbindung hat.

<sect2>Setzen der Uhrzeit bei sporadischer Internet-Verbindung
<p>
Das Paket <package>chrony</package> hilft hier weiter.
</sect1>

<sect1 id="setterm">Konsole-Eigenschaften wie den Bildschirmschoner steuern
<p>
Zum Deaktivieren des Bildschirmschoners sind folgende Kommandos geeignet:
<p>
Auf der Konsole:
<example>
# setterm -powersave off
</example>
<p>
Start der kon2 (kanji) Konsole mit:
<example>
# kon -SaveTime 0
</example>
<p>
Während X-Windows läuft:
<example>
# xset s off
 oder
# xset -dpms
 oder
# xscreensaver-command -prefs
</example>
Lesen Sie die entsprechenden Handbuchseiten um zu erfahren, wie man andere
Eigenschaften der Konsole steuert. Vergleichen Sie auch <manref name="stty"
section="1"> zum Ändern und zur Ausgabe von Terminal-Line Einstellungen.
</sect1>

<sect1 id="getent">Durchsuchen von Datenbanken zur Systemverwaltung
<p>
Die glibc-Bibliothek ermöglicht das Durchsuchen von System-Datenbanken,
nach beispielsweise passwd, group, hosts, services, protocols oder networks
mittels <manref name="getent" section="1">.
<example compact>
getent database [key ...]
</example>

<sect1>Sound abstellen (beep)
<p>
Im Zweifelsfall kann man immer den Stecker des Lautsprechers herausziehen
;-) Für die Bash-Shell gilt:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Fehlermeldungen auf der Konsole
<p>
Wenn übermäßig viele Fehlermeldungen die Konsole unbrauchbar werden lassen,
sollte man zuerst in <file>/etc/init.d/klogd</file> nachsehen. Um das
Warnlevel zu ändern kann man hier <tt>KLOGD="-c <var>3</var>"</tt> setzen.
Neustart des Daemons mit <file>/etc/init.d/klogd restart</file> aktiviert
die neuen Werte. Alternativ kann <tt>dmesg -n<var>3</var></tt> benutzt
werden.
<p>
Das Warnlevel schlüsselt sich wie folgt auf:
<list compact>
<item>0: KERN_EMERG,   System ist unbenutzbar
<item>1: KERN_ALERT,   sofortiger Eingriff nötig
<item>2: KERN_CRIT,    kritischer Zustand
<item>3: KERN_ERR,     Fehler
<item>4: KERN_WARNING, Warnung
<item>5: KERN_NOTICE,  normale aber bedeutende Nachricht
<item>6: KERN_INFO,    Information
<item>7: KERN_DEBUG,   reine debug Nachricht
</list>
<p>
Wenn eine bestimmte unkritische Fehlermeldung oft auftritt,
kann diese auch durch einen trivialen Kernelpatch unterbunden werden. (Siehe
dazu das Beispiel <file>shutup-abit-bp6</file> im 
<url id="&examples;" name="Beispielverzeichnis">.)
<p>
Auch ein Blick in <file>/etc/syslog.conf</file> kann hilfreich sein, um zu
verstehen, welche Nachrichten auf der Konsole ausgegeben werden.
</sect1>

<sect1>Setzen des korrekten Konsole-Typs
<p>
Die Konsole wird in Unix-artigen Systemen üblicherweise mit den Routinen
aus der (n)curses-Bibliothek angesteuert. Dies erlaubt eine im wesentlichen
von der Terminal-Art unabhängige Ausgabe mit vernünftiger Update-Strategie.
Siehe <manref name="ncurses" section="3X"> und
<manref name="terminfo" section="5">.
<p>
&debian; bietet eine ganze Reihe von Voreinstellungen:
<example>
$ toe | less                  # alle Einträge
$ toe /etc/terminfo/ | less   # Benutzer einstellbare Einträge
</example>
Die Auswahl kann durch Export der Umgebungsvariablen <tt>TERM</tt>
aktiviert werden.
<p>
Wenn der terminfo-Eintrag für <prgn>xterm</prgn> mit einem <prgn>xterm</prgn>,
das remote aufgerufen wird und das nicht auf Debian läuft, nicht funktioniert,
kann der Terminaltyp von "xterm" auch auch eine der primitiveren Varianten,
wie "xterm-r6", umgestellt werden.
Sehen Sie <file>&f-libncurse;</file> für weitere Informationen.
Der kleinste gemeinsame Nenner für terminfo ist "dumb".
</sect1>

<sect1>Die Konsole wiederherstellen
<p>
Ist der Bildschirm auf Grund von <tt>cat <var>Binärdatei</var></tt>
unleserlich (und sogar eingetippte Kommandos sind nicht sichtbar), so hilft:
<example>
$ reset
</example>
</sect1>

<sect1>Konvertieren einer Textdatei von DOS nach Unix
<p>
Eine DOS-Textdatei (Zeilenende von <tt>^M^J</tt>),
kann mit einem einzigen Kommando in eine Unix-Textdatei (Zeilenende =
<tt>^J</tt>) umgewandelt werden:
<example>
# apt-get install sysutils
$ dos2unix <var>dosDatei</var>
</example>
</sect1>

<sect1 id="perl-i">Ersetzung regulärer Ausdrücke
<p>
Alle Vorkommen des regulären Ausdrucks <var>REGEX</var> können durch
<var>TEXT</var> in allen Dateien <var>DATEIEN</var> ersetzt werden durch:
<example>
$ perl -i -p -e 's/<var>REGEX</var>/<var>TEXT</var>/g;' <var>DATEIEN</var> ...
</example>
<tt>-i</tt> zeigt an, dass die Orginaldateien bearbeitet werden, 
<tt>-p</tt> sorgt ausdrücklich für die Iteration über die Dateinamen. Wenn
der reguläre Ausdruck kompliziert ist, kann man sich versichern, indem man
die Originaldateien behält: Durch <tt>-i.bak</tt> anstelle von <tt>-i</tt>
bleiben die Originale erhalten und bekommen die Endung <tt>.bak</tt>.
</sect1>

<sect1>Bearbeiten einer Datei mittels eines Skripts
<p>
Das folgende Skript entfernt die Zeilen 5&ndash;10 und 16&ndash;20 ohne Umweg
über eine temporäre Datei.
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
Die <prgn>ed</prgn>-Kommandos sind die selben wie beim <prgn>vi</prgn> im
Kommandomodus. Das Bearbeiten der Datei von hinten erleichtert die Arbeit.
</sect1>

<sect1>Extrahieren von Unterschieden und Einbringen von Updates für
       Quelldateien
<p>
Die folgenden Kommandos bestimmen die Unterschiede zwischen zwei Quelldateien
und erzeugen diff-Dateien <var>Datei.patch0</var> und <var>Datei.patch1</var>
im "unified"-Stil:
<example>
$ diff -u <var>Datei.alt</var> <var>Datei.neu1</var> &gt; <var>Datei.patch0</var>
$ diff -u <var>alt/Datei</var> <var>neu1/Datei</var> &gt; <var>Datei.patch1</var>
</example>
Die diff-Datei (alternativ wird sie auch patch-Datei genannt) wird verwendet,
um Veränderungen zu beschreiben. Jeder der diese Datei erhält, kann diese
Änderungen auf eine andere Datei wie folgt anwenden:
<example>
$ patch -p0 <var>Datei</var> &lt; <var>Datei.patch0</var>
$ patch -p1 <var>Datei</var> &lt; <var>Datei.patch1</var>
</example>
Wenn drei Versionen des Quellcodes vorliegen, können diese einfacher mit
<prgn>diff3</prgn> vermengt werden:
<example>
$ diff3 -m <var>Datei.meine</var> <var>Datei.alt</var> <var>Datei.deine</var> &gt; <var>Datei</var>
</example>
</sect1>

<sect1>Eine große Datei in kleine zerlegen
<p>
<example>
$ split -b 650m <var>Datei</var>   # in 650MB große Stücke trennen
$ cat x* &gt;<var>großeDatei</var>    # wieder zusammenfügen
</example>
</sect1>

<sect1>Extrahieren von Daten aus Tabellen in Textdateien
<p>
Sei <file>DPL</file> der Name einer Textdatei, in welcher alle vorherigen
&debian;-Projektleiter mit Namen und Einführungsdatum, durch Freizeichen
getrennt, aufgeführt sind.
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   Januar  1998
Wichert Akkerman  Januar  1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr März    2003
</example>
Awk wird oft benutzt, um Daten aus dieser Art von Datei zu extrahieren.
<example>
$ awk '{ print $3 }' &lt;DPL                   # Monat des Beginns
August
April
Januar
Januar
April
April
März
$ awk '($1=="Ian") { print }' &lt;DPL          # Vorname Ian
Ian     Murdock   August  1993
Ian     Jackson   Januar  1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # wann fing Perens an
April 1996
</example>
<p>
Shells wie Bash sind ebenfalls in der Lage, Dateien dieser Art auszulesen:
<example>
$ while read Vorname Nachname Monat Jahr; do 
    echo $Monat
  done &lt;DPL
... selbe Ausgabe wie beim ersten Awk Beispiel
</example>
Das eingebaute <prgn>read</prgn> Kommando verwendet die Zeichen in $IFS 
(interne Feld-Separatoren), um Zeilen in Wörter aufzuteilen.
<p>
Wenn IFS auf ":" gesetzt wird, kann <file>/etc/passwd</file> leicht mit der
Shell ausgelesen werden:
<example>
$ altIFS="$IFS"   # alten Wert sichern
$ IFS=":"
$ while read Benutzer Passwort uid gid Zeilenrest; do
    if [ "$Benutzer" = "osamu" ]; then 
      echo "$Benutzer's ID ist $uid"
    fi
  done < /etc/passwd
osamu's ID ist 1001
$ IFS="$altIFS"   # Wert zurücksetzen
</example>
(Wenn Awk dazu verwendet wird, so wird der Spaltentrenner mit <tt>FS=":"</tt>
angegeben.)
<p> 
IFS wird auch von der Shell benutzt, um die Ergebnisse von
Parameterauswertungen, Kommando-Substitutionen und arithmetischen
Auswertungen aufzuteilen. Dies geschieht nicht innerhalb von doppelten oder
einfachen Anführungszeichen. Der Standardwert von IFS sind die Werte
&lt;Freizeichen&gt;, &lt;Tabulator&gt; und &lt;neue Zeile&gt;.
<p>
Man muss bei der Verwendung von IFS-Tricks vorsichtig sein. Eigenartige Dinge
können geschehen, wenn die Shell Teile eines Skripts als
<strong>Eingabe</strong> interpretiert.
<example>
$ IFS=":,"                        # ":" und "," seien Feldtrenner
$ echo IFS=$IFS,   IFS="$IFS"     # echo ist ein Bash Kommando
IFS=  , IFS=:,
$ date -R                         # nur eine Kommandoausgabe
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # Untershell --&gt; Eingabe der Haupt-Shell
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # zurücksetzen von IFS auf den Standardwert
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>
</sect1>


<sect1 id="scrp-snip">Skript-Auszüge für Pipe-Kommandos
<p>
Hier folgen einige kleine lehrreiche Beispiele zur Verwendung von Pipes:
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # Finde alle Dateien unterhalb /usr 
                     # mit Ausnahme bestimmter Pfade
xargs -n 1 <var>Kommando</var>  # Starte Kommando für alle Eingaben von stdin
xargs -n 1 echo |    # Beliebige Leerzeichen werden zu Zeilenumbrüchen
xargs echo      |    # alle Zeilen zu einer zusammenfassen
grep -e <var>Muster</var>|     # Gebe Zeilen aus, die <var>Muster</var> 
                     # enthalten
cut -d: -f3 -|       # gebe das dritte Feld aus, : sei Trenner  
                     # (z.B. für die Passwortdatei passwd)
awk '{ print $3 }' | # extrahiere das dritte Feld, Freizeichen sei Trenner
awk -F'\t' '{ print $3 }' |
                     # gib drittes Feld aus mit Tab als Trenner
col -bx |            # Entferne Backspace und expandiere Tabs zu Leerzeichen
expand -|            # expandiere Tabs zu Leerzeichen
sort -u|             # Sortiere und entferne doppelte Einträge

tr '\n' ' '|         # mehrere Zeilen zu einer zusammenfügen
tr '\r' ''|          # CR entfernen
tr 'A-Z' 'a-z'|      # Großbuchstaben in Kleinbuchstaben umwandeln
sed 's/^/# /'|       # aus der Zeile einen Kommentar machen
sed 's/\<var>.ext</var>//g'|    # Entferne <var>.ext</var>
sed  -n -e 2p|       # zeige die zweite Zeile
head -n 2 -|         # zeige die ersten beiden Zeilen
tail -n 2 -|         # zeige die letzten beiden Zeilen
</example>
</sect1>

<sect1>Skript-Auszüge zum Durchlaufen mehrerer Dateien
<p>
Die folgenden Möglichkeiten zum Durchlaufen aller auf
<tt>*.<var>ext</var></tt> passenden Dateien sind auch dann geeignet, wenn
die Dateinamen Sonderzeichen wie Leerzeichen enthalten und bewirken alle
dasselbe:
<list>
<item>Shell-Schleife:
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>Kommando</var> "$<var>x</var>"
  fi
done
</example>
<item><prgn>find</prgn> und <prgn>xargs</prgn> Kombination:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>Kommando</var>
</example>
<item><prgn>find</prgn> mit <tt>-exec</tt> Option mit einem Kommando:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>Kommando</var> '{}' \;
</example>
<item><prgn>find</prgn> mit <tt>-exec</tt> Option mit einem kurzen Shell-Skript:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>Kommando</var> '{}' && echo 'erfolgreich'" \;
</example>
</list>
</sect1>

<sect1 id="perl-mad">Kurze Perl-Skripte
<p>
Obwohl jedes Awk-Skript automatisch in ein Perl-Skript mittels
<manref name="a2p" section="1"> umgeschrieben werden kann, sollten einzeilige
Awk-Skripte am besten manuell nach Perl konvertiert werden. Zum Beispiel ist
<example>
awk '($2=="1957") { print $3 }' |
</example>
äquivalent zu allen der folgenden Zeilen:
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
Da alle Leerräume im <prgn>perl</prgn>-Argument in der obigen Zeile entfernt
werden können und unter Ausnutzung der automatischen Umwandlung zwischen
Zahlen und Zeichenketten in Perl kann auch folgendes verwendet werden:
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
Man vergleiche <manref name="perlrun" section="1"> für die
Kommandozeilenoptionen. Für noch verrücktere Perl-Skripte wird auf
<url id="&perlgolf;"> verwiesen.
</sect1>

<sect1>Text oder ein Mailing-Listenarchiv aus einer Webseite extrahieren
<p>
Das folgende liest eine Webseite aus und schreibt die Ausgabe in eine
Textdatei. Dies ist sehr nützlich, wenn man Konfigurationen aus dem Web
kopieren will.
<example>
$ lynx -dump http://<var>www.adresse.de/info.html</var> &gt;<var>Textdatei</var>
</example>
<prgn>links</prgn> und <prgn>w3m</prgn> können hier auch verwendet werden,
die Ergebnisse sich aber eventuell leicht unterschiedlich.
<p>
Falls ein Archiv einer Mailing-Liste geladen wird, kann <prgn>munpack</prgn>
benutzt werden, um den MIME-Inhalt zu extrahieren.
</sect1>

<sect1>Formatierte Ausgabe von Webseiten
<p>
Um eine Webseite zu drucken, kann diese in das PostScript-Format umgewandelt
werden:
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Man vergleiche <ref id="lprlpd">.  Alternativ können auch das
<prgn>a2ps</prgn> oder <prgn>mpage</prgn> Paket zum Erzeugen von
PostScript-Dateien verwendet werden.
</sect1>

<!--FIXME Jens bis hier -->
<sect1>Formatierte Ausgabe einer Handbuchseite
<p>
The following will print a manual page into a PostScript file/printer.  
<example>
$ man -Tps <var>some-manpage</var> | lpr
$ man -Tps <var>some-manpage</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Merge two PostScript or PDF files
<p>
You can merge two PostScript or PDF files.
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>
    
<sect1>Ausführungsdauer messen
<p>
Um die verschiedenen Zeiten, die mit einem Prozessablauf verbunden sind,
anzuzeigen, kann <prgn>time</prgn> verwendet werden.
<example>
# time <var>some-command</var> &gt;/dev/null
real    0m0.035s       # "Echte" Zeit
user    0m0.000s       # Zeit in Benutzermodus
sys     0m0.020s       # Zeit in Kernelmodus
</example>
</sect1>

<sect1><prgn>nice</prgn>-Befehl
<p>
Der <prgn>nice</prgn>-Befehl dient dazu, die Priorität eines Prozesses zu
setzen. Dessen Verwandter <prgn>renice</prgn> (Paket
<package>bsdutils</package>) ändert die Priorität eines bereits laufenden
Prozesses. Letzteres kann auch aus <prgn>top</prgn> heraus geschehen. Ein
<prgn>nice</prgn>-Wert von 19 bedeutet niedrigste Priorität - der Prozess
ist langsam --, absteigend wird die Priorität erhöht. Kleinere Werte als 0
kann nur der Administrator setzen, -20 ist die höchste Priorität.
<example>
# nice  -19 <var>top</var>                                         # sehr nett
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # sehr schnell
</example>
Manchmal kann ein sehr langsamer Prozess dem System mehr schaden als
nützen, also ist Vorsicht geboten.
</sect1>

<sect1 id="cronjob">Terminplanung für Prozesse (<prgn>cron</prgn>,
                    <prgn>at</prgn>)
<p>
Mit <prgn>cron</prgn> und <prgn>at</prgn> können zu bestimmten Terminen
Befehle ausgeführt werden. Siehe <manref name="at" section="1">,
<manref name="crontab" section="5">, <manref name="crontab" section="8">. 
<p> 
Die Tabelle für wiederkehrende Ausführung kann mit <tt>crontab -e</tt>
bearbeitet werden. (Ein anderer Editor als <prgn>vi</prgn> kann mit der
Umgebungsvariablen <tt>EDITOR</tt> festgelegt werden.) Beispiele einer
crontab-Tabelle:
<example>
# Verwende /bin/sh zur Ausführung, egal was passwd sagt
SHELL=/bin/sh
# Standardausgabe wird an `paul' geschickt.
MAILTO=paul
# Min Stunde TagDesMonats Monat TagDerWoche Befehl (Komma wird 'und')
# starte um 00:05, jeden Tag
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# starte unm 14:15 am Monatsersten -- Ausgabe per Email an Paul
15 14 1  * *   $HOME/bin/monthly
# starte um 22:00 an Werktagen (1-5), schicke Email an Joe. &percnt; für Zeilenumbruch, letztes &percnt; für cc:
0 22 *   * 1-5 mail -s "Es ist 10 Uhr" joe&percnt;Joe,&percnt;&percnt;Gute Nacht?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "Startet 23 Minuten nach 0 Uhr, 2 Uhr, 4 Uhr ..., am 1. Feb."
5  4 *   * sun echo "Startet um 04:05 jeden Sonntag"
# Startet um 03:40 an jedem ersten Montag des Monats
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
Um einen Befehl zur einmaligen Ausführung zu terminieren dient <prgn>at</prgn>
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Konsolenumschaltung mit <prgn>screen</prgn>
<p>
Mit <prgn>screen</prgn> kann man mehrere virtuelle Terminals
auf einer einzigen Konsole starten, jedes mit einer eigenen interaktiven
Shell. Selbst wenn man immer zwischen virtuellen Terminals umschalten kann
oder mehrere xterm-Fenster offen hält, sollte man sich <prgn>screen</prgn>
wegen seiner vielfältigen Möglichkeiten anschauen. Dazu gehören
<list compact>
<item>Kommando-Rückholung,
<item>Kopieren-Einfügen,
<item>protokollieren,
<item>Eingabe von Umlauten und
<item>die Möglichkeit eine komplette Sitzung an einem Terminal anzuhalten
      und später fortzusetzen.
</list>

<sect2>Beispiel für einen Fernzugriff
<p>
Wenn man sich häufig mit einem VT100-Terminal-Programm über ein Netzwerk
auf einem PC einwählt, wird man das Sitzungsmanagement mit
<prgn>screen</prgn> sicherlich nützlich finden.
<p>
<enumlist compact>
<item>Angenommen man ist über eine Telefonverbindung eingeloggt, eine
      <prgn>screen</prgn>-Sitzung ist gestartet und man hat einen längeren
      Text mit einem Editor geschrieben. Aus irgendwelchen Gründen, muss man
      jetzt die Verbindung unterbrechen.
<item>Durch Drücken von <tt>^A d</tt> wird die aktuelle Sitzung gesichert.
      (Noch schneller geht es mit <tt>^A DD</tt>, dann wird sogar gleich der
      Logout für einen vorgenommen.)
<item>Wenn man sich später wieder einwählt kann man mit <tt>screen -r</tt>
      die Sitzung holen, und <prgn>screen</prgn> wird die Sitzung so
      restaurieren, wie sie verlassen wurde.
</enumlist>

<sect2>Typische <prgn>screen</prgn>-Befehle
<p>
Wenn der <prgn>screen</prgn>-Prozess gestartet ist, reicht dieser alle
Tastatureingaben an das aktuelle Fenster, bis auf die Kommandosequenz, die
auf <tt>^A</tt> voreingestellt ist. Alle <prgn>screen</prgn>-Befehle
beginnen mit <tt>^A</tt> und werden dann von einem einzelnen Buchstaben
gefolgt (ggf. folgen dann die Parameter). Beispiele für Befehle:
<example>
^A ?     Hilfe (Tastaturbelegung)
^A c     Neues Fenster und wechsele dorthin
^A n     Gehe zum nächsten Fenster
^A p     Gehe zum vorherigen Fenster
^A <var>0</var>     Gehe zum Fenster Nummer <var>0</var>
^A w     Zeige eine Liste der Fenster
^A a     Gebe das ^A an die Applikation weiter
^A h     Hardcopy des Fensters in Datei
^A H     Starte/Beende Protokoll des aktuellen Fensters in eine Datei
^A ^X    Sichere das Terminal mit einem Passwort
^A d     Aktuelle Sitzung vom Terminal abmelden
^A DD    Vom Terminal abmelden und Logout
</example>
Dies ist nur eine kleine Auswahl der Befehle, die das mächtige
<prgn>screen</prgn> unterstützt. Siehe <manref name="screen" section="1"> für 
weitere Details.

<sect2>Backspace und/oder Strg-H in einer <prgn>screen</prgn> Sitzung
<p>
Wenn die Backspace- oder Strg-H-Taste während einer
<prgn>screen</prgn>-Sitzung nicht funktionieren, muss die Zeile 
<example compact>
bindkey -k kb stuff "\177"
</example>
in der Datei <file>/etc/screenrc</file> auskommentiert ("#") werden.

<sect2><prgn>screen</prgn>-Äquivalent unter X
<p>
Siehe Paket <prgn>xmove</prgn> und dort <manref name="xmove" section="1">.

</sect1>

<sect1 id="net-test">Grundlagen - Prüfung des Netzwerks
<p>
Installiere um die grundlegenden Funktionen des Netzwerks zu überprüfen
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (für 2.2 Kernel),
<package>iptables</package> (für 2.4 Kernel), und das
<package>net-tools</package> Paket und führe folgende Sequenz aus:
<example>
$ ping <var>yahoo.com</var>            # teste Internetverbindung
$ traceroute <var>yahoo.com</var>      # tracen der IP-Pakete
$ ifconfig                  # testen der host-Konfiguration
$ route -n                  # testen der routing-Konfiguration
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # teste <var>host.dom</var> DNS-Einträge am <var>dns-server.com</var> 
      # und suche dort nach <var>{mx|any}</var> Eintrag
$ ipchains  -L -n |less     # teste packet-Filter (2.2 kernel)
$ iptables -L -n |less      # teste packet-Filter (2.4 kernel)
$ netstat -a                # Finde alle offenen Ports
$ netstat -l --inet         # Finde alle auf Eingabe wartenden Ports
$ netstat -ln --tcp         # Ebenso (TCP, numerisch) Ports
</example>
</sect1>

<sect1 id="flush-mail">Email aus dem lokalen Spooler leiten (flush)
<p>
Um Email aus dem lokalen Spooler weiterzuleiten:
<example>
# exim -q    # wartende Email anstoßen
# exim -qf   # alle Emails weiterleiten
# exim -qff  # dasselbe, auch Email mit Status 'frozen' wird weitergeleitet
</example>
<tt>-qff</tt> wäre wohl die bessere Wahl in dem Skript
<file>/etc/ppp/ip-up.d/exim</file>.
</sect1>

<sect1 id="remove-mail">'Frozen' Email aus dem lokalen Spooler entfernen
<p>
Um nicht weiter vermittelbare Email aus dem lokalen Spooler zu entfernen
und eine Fehlermeldung zurückzugeben dient:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Redeliver mbox contents
<p>
You need to manually deliver mails to the sorted mailboxes in your 
home directory from <file>/var/mail/<var>username</var></file>
if your home directory became full and procmail failed.  After making 
disk space in the home directory, run:
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>username</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>Dateiinhalte zurücksetzen
<p>
Um eine Datei zurückzusetzen, z.B. ein Log-Datei, sollte nicht <tt>rm</tt>
benutzt werden, da diese Dateien im Sekundenrhythmus geschrieben werden.
Sicherer ist:
<example>
$ :&gt;<var>dateiname</var>
</example>
</sect1>

<sect1 id="dummyfile">Dummy-Dateien
<p>
Die folgenden Befehle erzeugen leere Dateien beliebiger Größe:
<example>
$ dd if=/dev/zero    of=<var>dateiname</var> bs=1k count=5 # 5KB große, aber leere Datei
$ dd if=/dev/urandom of=<var>dateiname</var> bs=1m count=7 # 7MB mit Zufallsinhalt
$ touch <var>dateiname</var> #erzeuge 0B Datei (wenn sie existiert, setze mtime neu)
</example>
</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<p>
Wenn man neben seiner &debian;-Distribution noch eine andere installiert
hat (dies kann auch jede andere Distribution sein), z.B. auf der Partition
<file><var>/dev/hda1</var></file>, dann kann dieses zweite System mit dem
aktuellen Kernel ohne Warmstart gestartet werden.

<example>
# mount <var>/dev/hda1 /mnt/target</var>
 ... dies nimmt an, dass das zweite System auf <var>/dev/hda1</var> liegt
# chroot /mnt/target
 ... Jetzt wird der Inhalt von <var>/dev/hda1</var> als root-Verzeichnis betrachtet
# mount proc /proc              # reine Vorsicht
 ... Ausgeführte Befehle stammen nun von  <var>/dev/hda1</var>
</example>
So kann man verschiedene Stabilitätszweige (stable/testing/unstable) auf
einer Maschine testen. Eine weitere Möglichkeit wäre, ein fremdes System
per NFS zu mounten und <prgn>chroot</prgn> auf dieses neu gemountete
Verzeichnis anzuwenden.
<p>
Ein auf <prgn>chroot</prgn> basierendes System kann leicht mit 
<prgn>debootstrap</prgn> (in Woody) erzeugt werden.
<example>
# mkdir <var>potatochroot</var>
# debootstrap potato <var>potatochroot</var>
# chroot <var>potatochroot</var>
# apt-setup # set-up /etc/apt/sources.list
</example>
<p>
Es gibt ein ausgefeilteres <prgn>chroot</prgn>-Paket,
<package>pbuilder</package>. Es erzeugt eine <prgn>chroot</prgn>-Umgebung
und stellt ein &debian;-Paket in dieser Sandbox zusammen. So kann man
Paketabhängigkeiten definieren, erkennen und aufzulösen.
<p>
See <url id="&setup-chroot;">
</sect1>

<sect1>How to check hard links
<p>
You can check whether two files are the same file with two hard links by:
<example> 
$ ls -li <var>file1</var> <var>file2</var>
</example>

<sect1>Ein Festplatten-Image <prgn>mount</prgn>en 
<p>
Wenn <file><var>file.img</var></file> ein Festplatten-Image enthält und die
Quellfestplatte eine Konfiguration wie <var>xxxx</var> = (Byte/Sektor) *
(Sektor/Zylinder) hat, dann kann dieses Image mit dem folgenden Befehl nach
<file>/mnt</file> gemountet werden:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
Die meisten Festplatten haben 512 bytes/Sektor

<sect1 id="smbmount">Samba
<p>
Grundlagen um auf Windows-Dateien zuzugreifen:
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # freigegebene Windows-Laufwerke mounten
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # Freigaben anzeigen
</example>
<p>
Die Netzwerk-Nachbarschaft kann angezeigt werden mit:
<example>
# smbclient -N -L <var>eigene_IP_Address</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>Utilities for foreign filesystems
<p>
Many foreign filesystems have Linux kernel support, and can thus
be accessed simply by mounting the devices containing the filesystems.  For
certain filesystems, there are also a few specialized tools to access the
filesystems without mounting the devices.  This is accomplished with
user-space programs so that kernel filesystem support is not needed. 
<list compact>
<item><package>mtools</package>: for MSDOS filesystem (MS-DOS, Windows)
<item><package>cpmtools</package>: for CP-M filesystem
<item><package>hfsutils</package>: for HFS filesystem (native Macintosh)
<item><package>hfsplus</package>: for HFS+ filesystem (modern Macintosh)
</list>
In order to create and check an MS-DOS FAT filesystem,
<package>dosfstools</package> is useful.
</sect1>

</sect>

<sect id="oops">Typical mistakes to be noted
<p>
Here are few examples of dangerous actions.  The negative impacts will be
enhanced if you are using privileged account: <tt>root</tt>.

<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>
<!-- 
I know using quotes here are irregular but it is hard to read without it. 
-->
In "<tt>rm -rf .*</tt>", "<tt>.*</tt>" expands to include "<tt>.</tt>" and
"<tt>..</tt>", and if you happen to have privileges to write to the parent
directory then you'll end up removing all directories
<strong>next</strong> to your current directory as well.
<p>
<list compact>
<item>"<tt>rm -rf .</tt>" : removes everything under current directory and
current directory itself.
<item>"<tt>rm -rf *</tt>" : removes every non-dot files and  non-dot
directories under current directory
<item>"<tt>rm -rf .[^.]*</tt>" : removes every dot files and
dot-directories under current directory.
<item>"<tt>rm -rf .*</tt>" : removes everything under parent directory and
parent directory itself.
</list>

<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
Loss of some important files such as <file>/etc/passwd</file> through
your stupidity is tough.  The &debian; system makes regular backups of
them in <file>/var/backups</file>.  When you restore these files, you may
manually have to set the proper permissions.
<example>
# cp /var/backups/passwd /etc/passwd
# chmod 644 /etc/passwd
</example>
See also <ref id="recover-status">.

</chapt>

