<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.46"  -->
<!-- This file is part of the german Version of the debian reference -->
<!-- Document is available at qref.sourceforge.net -->
<!-- Uebersetzung 11/2002 Stefan Schroeder, stefan@fkp.uni-hannover.de -->

<chapt id="tips"> &debian; Tipps

<sect>Booten des Systems
<p>
Weitere Informationen über den Boot-Prompt (also die Eingabeaufforderung
beim Systemstart) gibt es beim LDP 
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO">.

<sect1 id="crackroot">"Ich habe das root-Passwort vergessen!" (1)
<p>
Sobald man Zugriff auf die Tastatur eines Rechners hat, kann das
System gestartet werden und ein Login stattfinden, auch ohne das
root-Passwort zu kennen. (Dies setzt allerdings voraus, dass keine
zusätzlichen Schutzmaßnahmen ergriffen wurden, wie z.B. ein 
BIOS-Passwort oder eine Passwortabfrage im <prgn>lilo</prgn>.)
<p>
Der hier beispielhaft durchgeführte Login-Vorgang erfordert keine
externen Boot-Medien oder Änderungen der BIOS-Einstellungen. Die
Bezeichnung für den voreingestellte Boot-Option sei "Linux".
<p>
Sobald die <prgn>lilo</prgn>-Boot-Meldung erscheint (<tt>boot:</tt>),
sollte zuerst kurz die Shift-Taste/Umschalt-Taste gedrückt werden,
um einen eventuell voreingestellten automatischen Start zu unterbrechen.
Dann gibt man folgendes am Prompt ein:
<example>
boot: Linux init=/bin/sh
</example>
Das System startet nun den Kernel und daraufhin das Programm
<file>/bin/sh</file> anstelle des üblichen <prgn>init</prgn>-Prozesses.
Die nun erlangte Shell hat root-Privilegien. Da das Hauptverzeichnis
<file>/</file> nur les- aber nicht schreibbar ist und viele während des
üblichen Boot-Prozesses eingeklinkten Verzeichnisse nicht erreichbar sind,
müssen diese nachträglich gemountet werden, um ein vernünftiges Arbeiten
zu ermöglichen:
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
Wenn in der Datei <file>/etc/passwd</file> das zweite Datenfeld (der
Trenner ist der Doppelpunkt) bei allen Einträgen ein "x" ist, dann
benutzt das System shadow-Passwörter. In diesem Fall muss statt
<file>/etc/passwd</file> die Datei <file>/etc/shadow</file> editiert
werden. Um das root-Passwort zurückzusetzen, muss das zweite Feld des
root-Eintrags gelöscht werden. Nach einem sauberen Neustart ist das
root-Passwort leer und kann neu vergeben werden. Wenn das System in den
Runlevel 1 fährt, wird (zumindest bei Debian-Versionen >= Potato)
die Vergabe eines nichtleeren root-Passwortes eingefordert.
<p>
Für den gezeigten und ähnliche gelagerte Fälle ist ein Editor im
<file>/bin</file>-Verzeichnis absolut empfohlen, für den Fall, dass
der <file>/usr</file>-Baum nicht erreichbar ist (siehe dazu auch
<ref id="bin-editor">).
<p>
Für Notfälle hat sich außerdem die <package>sash</package> (stand
alone shell) bewährt. Wenn das System nicht mehr gebootet werden kann, geben
Sie am <prgn>lilo</prgn>-Prompt ein:
<example>
boot: Linux init=/bin/sash
</example>
Das Programm <prgn>sash</prgn> dient als Ersatz für die Shell
<file>/bin/sh</file>. Es ist statisch gelinkt und hat viele Standardbefehle
eingebaut.
(Wenn <prgn>sash</prgn> gestartet ist, wird "help" eine kurze Referenz
anzeigen.)
</sect1>

<sect1 id="crackroot2">"Ich habe das root-Passwort vergessen!" (2)
<p>
Starten Sie das System mit einer Rettungsdiskette/-CD. Sei
<file><var>/dev/hda3</var></file> die root-Partition. Dann kann die
Passwortdatei editiert werden durch:
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
Der Vorteil dieser Variante ist, dass ein eventuell vergebenes
<prgn>lilo</prgn>-Passwort umgangen werden kann. Erforderlich ist allerdings,
dass im BIOS die Einstellungen für das Boot-Laufwerk manipuliert werden kann
(falls es nicht schon auf A: oder CDROM eingestellt ist).
</sect1>

<sect1 id="dead-lilo">Das System kann nicht gestartet werden
<p>
Der erste Versuch sollte sein, das System mit der Installations-Diskette/-CD
zu starten. Wenn nur der <prgn>lilo</prgn> defekt ist, kann das System dann
durch Angabe der root-Partition (in diesem Beispiel
<file><var>/dev/hda12</var></file>) und des Runlevels hochfahren:
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
Wurde das System mit dem Kernel des Rettungsmediums erfolgreich gestartet,
kann <prgn>lilo</prgn> benutzt werden, um den Bootsektor zu erneuern.
Falls besondere Kernel-Module benötigt werden, kann es natürlich
Einschränkungen geben. In diesem Fall sollte eine angepasste Boot-Diskette
erzeugt werden. Siehe hierzu <prgn>readme.txt</prgn> auf der
Standard-Rettungsdiskette.
</sect1>

<sect1 id="no-x-start">"Let me disable X on boot!"
<p>
Chasing <tt>unstable/sid</tt> is fun, but buggy <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn>, and <prgn>wdm</prgn> started
during the boot process can bite you bad.
<p>
First get the root shell by entering followings at the boot prompt:
<example>
boot: <var>Linux</var> vga=normal s
</example>
Here, <var>Linux</var> is the label for the kernel image you are booting
"vga=normal" will make sure lilo runs in normal VGA screen,
and "s" (or "S") is the parameter passed to <prgn>init</prgn>
to invoke single user mode.  Enter the root password at the prompt.
<p>
There are few ways to disable all the X starting deaemons:
<list>
<item>run <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6</tt>
<item>insert "exit 0" at the start of all <file>/etc/init.d/<var>?</var>dm</file> files.
<item>rename all <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> files to <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>remove all <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> files.
<item>run <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Here, <file>rc<var>2</var>.d</file> must correspond to the runlevel
specified in the <file>/etc/inittab</file>.  Also
<file><var>?</var>dm</file> means all of the <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn>, and <prgn>wdm</prgn>.
<p>
Only the first one in the list is "the one true way" in &debian;.
Last one is easy but only works on &debian; and requires you to set
it again later using <prgn>dpkg-reconfigure</prgn>.
Others are generic methods to disable daemons.
<p>
You can still start X by <prgn>startx</prgn> command from any console shell.
</sect1>


<sect1 id="bootprompt">Weitere Tricks mit dem Boot-Prompt
<p>
Mittels des <prgn>lilo</prgn>-Boot-Prompts kann das System in einen
beliebigen Runlevel gestartet werden. Details dazu bietet:

<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Soll das System in den Runlevel 4 starten, dient dazu der
Bezeichner des Standardsystem (s.o., "Linux") neben dem gewünschten
Runlevel:
<example>
boot: Linux 4
</example>
<p>
Der Einzelbenutzer-Modus (nur für Wartungszwecke gedacht) wird mit einem
der folgenden Kommandos erreicht:
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Auch der benutzte Speicherbereich kann eingeschränkt werden. Das folgende
Beispiel weist das System an, nur 48 MB des verfügbaren Speichers zu 
belegen.
<example>
boot: Linux mem=48M
</example>
Achtung: Wird an dieser Stelle mehr Speicher angegeben als vorhanden, wird
der Kernel abstürzen. Wenn man mehr als 64 MB Speicher hat, kann es bei
alten Kernels und/oder Mainboards passieren, dass das System nur 64 MB nutzt.
In diesem Fall kann man versuchen den ungenutzten Speicher mit
<tt>mem=128M</tt> zu aktivieren. Äquivalent dazu ist ein Eintrag in der
Datei <file>/etc/lilo.conf</file>.
</sect1>

<sect1 id="bootgrub">How do I set boot parameters (GRUB)
<p>
GRUB is a new boot manager from Hurd project and is much more flexible
than Lilo but has slightly different handling of boot parameters.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Here, you must be aware of Hurd device names:
<example>
HURD/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,1)             /dev/hda1           C: (usually)
 (hd0,4)             /dev/hda4           F: (usually)
 (hd1,4)             /dev/hdb4           ?
</example>
See <file>&f-grub;</file> and <file>&f-grub-doc;</file> for the detail.
</sect>
    
<sect>Aufzeichnung und Abspielen von Aktivitäten

<sect1 id="script">Shell-Eingaben 
<p>
Um ein Unix-artiges System gekonnt zu administrieren, sind mitunter
knifflige oder raffinierte Aufgaben zu erledigen. Machen Sie sich
deshalb mit den grundlegenden Konfigurationsaufgaben vertraut, so 
dass Sie im Notfall wissen, wo Sie Hand anlegen müssen.
Fensterbasierte Konfigurations-Werkzeuge sind nett und bequem, nützen
aber nichts, wenn man versucht eine defekte X-Window-Konfiguration
wieder herzustellen.
<p>
Die Aufzeichnung von Tastatur-Eingaben ist, insbesondere als root, 
hin und wieder nützlich.
<p>
Emacs: <tt>M-x shell</tt> startet die Aufzeichnung. ("M" steht hier für
die Meta-Taste, meist Alt oder auch Esc.) <tt>C-x C-w</tt> schreibt die
aufgezeichnete Sequenz in eine Datei.
<p>
Shell: Das <prgn>script</prgn>-Kommando dient auf Shell-Ebene zum Aufzeichnen.
with "^A H" as described in
<ref id="screen"> or <prgn>script</prgn> command.
<example>
$ script
Script started, file is typescript
 ... irgendwelche Eingaben ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
Falls das <prgn>script</prgn>-Programm fehlt, kann diese Funktion mit
der Shell simuliert werden:
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>X Aktivitäten aufzeichnen
<p>
Um den grafischen Bildschirm aufzunehmen, auch X-Terminals und andere
beliebige Fenster, kann <prgn>gimp</prgn> benutzt werden. Es besteht meist
die Möglichkeit nur ein aktives Fenster oder den ganzen Schirm aufzunehmen
und als Bilddatei auf der Festplatte zu speichern. Alternativen sind
<prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>), oder <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>

</sect>

<sect id="archiving">Kopieren und Archivieren eines Verzeichnisbaumes
<sect1>Grundlegende Kommandos zum Kopieren eines Unterverzeichnisses
<p>
Möchte man seine Verzeichnisstruktur neu arrangieren, kopiert man den
Inhalt eines Verzeichnisses <file>directory</file> von <file>/source</file>
nach <file>/destination</file> durch die Standardmethode (soft links
bleiben erhalten):
<example>
# cp -a /source/directory /dest/directory # erfordert GNU cp
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
</example>

Wenn hard links im Unterverzeichnis vorliegen, ist etwas mehr Aufwand
nötig:
<example>
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /ort/neues/verzeichnis
</example>

Kopieren über eine Netzwerkverbindung:
<example>
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
</example>

Netzwerkkopie, falls keine Links vorliegen:
<example>
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
(<prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> und <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.)
<p>
Der folgende Vergleich über die verschiedenen Kopiermodi stammt von 
Manoj Srivastava &lt;srivasta@debian.org&gt; präsentiert in der 
Debian-Mailing-Liste debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Das ursprüngliche <prgn>cp</prgn>-Programm war für nur wenige Zwecke 
geeignet. Es konnte keine Links auflösen und war auch für zerstreute Dateien
wenig brauchbar.
<p>
Die GNU-Version von <prgn>cp</prgn> überwand zwar diese Probleme, doch auf
nicht-GNU-Systemen kann es noch zu Schwierigkeiten kommen. Desweiteren kann
<prgn>cp</prgn> keine portablen Archive erzeugen.
Dennoch ein Beispiel:
<example>
&percnt; cp -a . neuesverzeichnis
</example>

<sect1><prgn>tar</prgn>
<p>
Das Archivierungsprogramm <prgn>tar</prgn> kann im Gegensatz zu
<prgn>cp</prgn> mit symbolischen Links umgehen. Zusätzlich kann
<prgn>cpio</prgn> allerdings auch mit "special files" umgehen.
<p>                                                             
Wenn <prgn>tar</prgn> auf mehrfache hard links einer Datei stößt, wird doch
nur einmal die Datei in das Archiv kopiert; die Datei kann dann <em>nur</em>
unter dem Namen der ursprünglichen Datei zurückgewonnen werden.
<prgn>cpio</prgn> dagegen kopiert für jeden hard link die komplette Datei
in das Archiv, so dass sie unter jedem der Link-Namen wiedergeholt werden
kann.
<p>
Die Autoren des <prgn>tar</prgn>-Kommandos haben die Option für das Packen
mit <prgn>bzip2</prgn> umbenannt. Empfohlen wird in Skripts die lange
Option <tt>--bzip2</tt> zu benutzen. Die Kurzform <tt>-I</tt> (Potato)
oder <tt>-j</tt> (Woody) könnte zu Portabilitätsproblemen führen.
</sect1>

<sect1><prgn>pax</prgn>
<p>
Hinter dem Namen <prgn>pax</prgn> (POSIX-Standard (IEEE Std 1003.2-1992, 
Seite 380&ndash;388 (section 4.48) und Seite 936&ndash;940 (section
E.4.48)), verbirgt sich ein multifunktionales Werkzeug zum Austausch von
Archiven (Portable Archive Interchange utility).  
<prgn>pax</prgn> liest und schreibt Archive und listet deren Inhalt,
kopiert Verzeichnisse hinein und heraus und all dies unabhängig von einem
spezifischen Archivformat. Mit anderen Worten, eine große Bandbreite von
Formaten wird unterstützt.
<p>
<prgn>pax</prgn> ist noch neu und es können noch Kinderkrankheiten
auftreten.
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 oder
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
Das Kommando verwaltet die gleichnamigen Archive oder auch solche, die
mit <prgn>tar</prgn> erstellt wurden.
Das Archiv kann statt einer Datei auch eine Pipe oder ein Magnetband sein:
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> ersetzt <prgn>cpio</prgn>. Es liest dessen Archive
schneller, unterstützt mehr Laufwerke, hat eine bessere Fehlerkorrektur
und kann das Archiv auf mehrere Medien verteilen. Die Kompression mit
<prgn>afio</prgn> ist zuverlässiger als die von <prgn>tar</prgn> und
<prgn>cpio</prgn>. Also benutzt man am besten <prgn>afio</prgn> statt derer.
Zum Beispiel in einem Skript, das folgende Zeilen enthält:
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
Ich mache alle meine Backups auf Band mit <prgn>afio</prgn>. 
</sect1>
</sect>

<sect id="diff-backup">Differential backup and data synchronization
<p>
Differential backup and data synchronization can be implimented
with several methods:
<list>
<item><package>rcs</package>:  backup and history, text-only
<item><package>rdiff-backup</package>:  backup and history. symlink OK.
<item><package>rsync</package>:  1-way synchronization
<item><package>unison</package>:  2-way synchronization
<item><package>cvs</package>:  multi-way synchronization with server
 backup and history, text-only, mature. See <ref id="cvs">.
<item><package>arch</package>:  multi-way synchronization with server
 backup and history, no such thing as a "working directory".
<item><package>subversion</package>:  multi-way synchronization with
 server backup and history, Apache.
</list>
Combination of one of this with the archiving method described in
<ref id="archiving"> and the automated regular job described
in <ref id="cronjob"> will make a nice backup system.
<p>
I will explain 2 easy-to-use utilities.
   
<sect1 id="rdiff-backup">Differential backup with rdiff
<p>
<package>Rdiff-backup</package> offers nice and simple backup with
the differential history for any types of files including symlinks.
To back up most of <file>~/</file> to <file>/mnt/backup</file>:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
To restore 3 day old data from this archive to <file>~/old</file>:
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
See <manref name="rdiff-backup" section="1">.
</sect1>

<sect1 id="backup">Regular differential backup with RCS
<p>
<package>Changetrack</package> will record changes to the text-based
configuration files in RCS archives regularly.
See <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>Einfrieren von Prozessen
<sect1>Einen Prozess killen/beenden
<p>
<prgn>top</prgn> (table of processes) hilft außer Kontrolle geratene
Prozesse zu identifizieren. `P' sortiert die Spalten nach CPU-Last, `M'
nach Speicherverbrauch und `k' kann einen Prozess "abschießen".
Alternatively,
BSD style <tt>ps aux | less</tt> or System V style <tt>ps -efH | less</tt>
may be used.  The System V style syntax displays parents process ID
<tt>PPID</tt> which can be used for killing zombie (defunct) child.
<p>
Von der Kommandozeile hat <prgn>kill</prgn> die gleiche Funktion. Statt
den Prozess nur zu beenden gibt es aber auch die Möglichkeit, fein abgestufte
Signale an Prozesse zu senden. Während <prgn>kill</prgn> einen Prozess
über die Prozess-Identifikationsnummer adressiert, ist es leichter
den Prozess mittels <prgn>killall</prgn> über den Namen des Programms
anzusprechen. Die meist gebrauchten Signale sind
<example>
 1: HUP,  Daemon neustarten
15: TERM, Normales Beenden
 9: KILL, Sofortiges Beenden!
</example>

</sect1>

<sect1>ALT-SysRq
<p>
Wenn der Kernel mit der "magischen SysRq Taste" kompiliert wurde, kann das
System mit etwas Glück auch aus dem totalen Nirvana geholt werden. Drücken
der Tasten <tt>ALT-SysRq</tt> bei einem i386, gefolgt von einer der Tasten
<tt>r 0 k e i s u b</tt>, aktiviert die Kernel-Notbremse.
<p>
`r' = restore, versucht die Tastatur wieder zu beleben, wenn X abstürzt.
`0' setzt den Level mit dem Fehlermeldungen auf der Konsole ausgegeben
werden herunter. `k' = (system attention key) beendet alle Prozesse auf der
aktuellen virtuellen Konsole. `t' beendet alle Prozesse des aktuellen
Terminals außer init. `i' beendet <em>alle</em> Prozesse außer init.
<p>
`s'ync, `u'mount  und re`b'oot sind wirklich nur für den allerletzten
Notfall.
<p>
Debian Standard (default) Kernels sind nicht mit dieser Option kompiliert
(11/2002). Es muss zur Nutzung dieser Tasten einen neuer Kernel kompiliert
werden. Weitere Informationen zu dieser "Notbremse" in 
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>
oder
<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>


<sect>Raffinierte merk-würdige Kommandos 

<sect1>Dateibetrachter
<p>
<prgn>less</prgn> ist ein Dateibetrachter, der Textdatei seitenweise
ausgibt. Hilfe bietet `h'. <prgn>less</prgn> kann mehr als dessen Urahn 
<prgn>more</prgn>. Mit <tt>eval $(lesspipe)</tt> können Filter eingerichtet
werden, um so z.B. gepackte Dateien anzusehen. Diese Filter können auch
permanent eingerichtet werden, indem man Filter in einer der
Shell-Startdateien (mit <tt>eval $(lessfile)</tt>) festlegt. Siehe hierzu
auch <file>&f-lessopen;</file>. Die Option <tt>-R</tt> erlaubt die Ausgabe
von Sonderzeichen (raw characters) und schaltet die ANSI Farbsequenzen ein.
Siehe <manref name="less" section="1"> für noch mehr Möglichkeiten.

<p>
<prgn>w3m</prgn> kann für einige Systeme eine Alternative zum Betrachten
von Dateiinhalten sein. (EUC).???

<sect1>Freier Speicher
<p>
<prgn>free</prgn> und <prgn>top</prgn> informieren über freien Speicher und
dessen Verbrauch. Ausschlaggebend ist an dieser Stelle der "used"-Eintrag
in der zweite Datenzeile (hier: 38792)
<example>
$ free -k # für 256MB Hauptspeicher
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
Die präzise Menge an Hauptspeicher, die zur Verfügung steht erfährt man
außerdem mit <tt>grep '^Memory' /var/log/dmesg</tt>, was in diesem Fall
"Memory: 256984k/262144k available (1652k kernel code, 412k reserved,
2944k data, 152k init)" ergibt.
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Ca. 5MB können nicht vom System verwendet werden, da der Kernel sie in
Beschlag nimmt.
</sect1>

<sect1>Setzen der Uhrzeit (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Dies setzt die Hardware-Uhr auf die Zeit DD=Tag, MM=Monat, hh=Stunde,
mm=Minute, CCYY=Jahr. Die Systemuhr wird dann mit der Hardwareuhr
synchronisiert und zudem wird UTC (Coordinated Universal Time) als Zeitzone
definiert.

<sect1>Setzen der Uhrzeit (NTP)
<p>
Siehe: <url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">.
<p>
<sect2>Setzen der Zeit bei permanenter Internetverbindung
<p>
Die Uhrzeit kann mit Hilfe eines Zeit-Servers gesetzt werden:
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
Durch ein Skript in <file>/etc/cron.daily</file> kann man so täglich die
Rechnerzeit mit dem Zeit-Server synchronisieren.

<sect2>Setzen der Uhrzeit bei nur sporadischer Internet-Verbindung
<p>
Das Paket <package>chrony</package> hilft hier weiter.
</sect1>

<sect1>Den Bildschirmschoner deaktivieren
<p>
Auf der Konsole
<example>
# setterm -powersave off
</example>
<p>
Start der kon2(kanji) Konsole mit:
<example>
# kon -SaveTime 0
</example>
<p>
Während X-Windows läuft
<example>
# xset s off
 oder
# xset -dpms
 oder
# xscreensaver-command -prefs
</example>
Weiteres liefern die entsprechenden <file>man</file>-Seiten.
</sect1>

<sect1 id="getent">Durchsuchen von Datenbanken zur Systemverwaltung
<p>
Die glibc-Bibliothek ermöglicht das Durchsuchen von System-Datenbanken,
z.B. passwd, group, hosts, services, protocols, networks. Der Befehl dazu
lautet <prgn>getent</prgn>
<example compact>
getent database [key ...]
</example>

<sect1>Sound abstellen (beep)
<p>
Im Zweifelsfall kann man immer den Stecker des Lautsprechers herausziehen
;-) Für die Bash-Shell gilt:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Fehlermeldungen auf der Konsole
<p>
Wenn übermäßig viele Fehlermeldungen die Konsole unbrauchbar werden lassen,
sollte man zuerst in <file>/etc/init.d/klogd</file> nachsehen. Um den
Warnlevel zu ändern kann man hier <tt>KLOGD="-c <var>3</var>"</tt> setzen.
Neustart des Daemons mit <file>/etc/init.d/klogd restart</file> aktiviert
die neuen Schwellen. Alternativ kann <tt>dmesg -n<var>3</var></tt> benutzt
werden.

Der Warnlevel schlüsselt sich wie folgt auf:
<list compact>
<item>0: KERN_EMERG,   System ist unbenutzbar
<item>1: KERN_ALERT,   Sofortiger Eingriff nötig
<item>2: KERN_CRIT,    Kritischer Zustand
<item>3: KERN_ERR,     Fehler
<item>4: KERN_WARNING, Warnung
<item>5: KERN_NOTICE,  Notiz
<item>6: KERN_INFO,    Information
<item>7: KERN_DEBUG,   Reine debug Nachricht
</list>
<p>
Wenn eine bestimmte, mit Sicherheit unkritische Fehlermeldung oft auftritt,
kann diese auch durch einen trivialen Kernelpatch unterbunden werden. (Siehe
dazu das Beispiel <file>shutup-abit-bp6</file> in 
<url id="&examples;" name="examples subdirectory">)
<p>
Auch ein Blick in <file>/etc/syslog.conf</file> kann hilfreich sein, um zu
verstehen, welche Nachrichten auf der Konsole ausgegeben werden.
</sect1>

<sect1>Setzen des korrekten Konsole-Typs
<p>
Die Konsole wird in Unix-artigen Systemen üblicherweise mit den Routinen
aus der (n)curses-Bibliothek angesteuert. Dies erlaubt eine im wesentlichen
von der Terminal-Art unabhängige Ausgabe mit vernünftiger Update-Strategie.
Siehe <manref name="ncurses" section="3X"> und
<manref name="terminfo" section="5">.
<p>
&debian; unterstützt eine ganze Reihe von Voreinstellungen für die Konsole.
<example>
$ toe | less                  # alle Einträge
$ toe /etc/terminfo/ | less   # Benutzer einstellbar
</example>
Die Auswahl kann durch Export der Umgebungsvariablen <tt>TERM</tt>
aktiviert werden.
<p>
Wenn der terminfo-Eintrag für xterm mit einem xterm, das remote aufgerufen
wird und das nicht auf Debian läuft, nicht funktioniert, kann der
Terminaltyp von "xterm" auch auch eine der primitiveren Varianten, wie
"xterm-r6", umgestellt werden.
Siehe <file>&f-libncurse;</file> für weitere Informationen
Der kleinste gemeinsame Nenner für terminfo ist "dumb".
</sect1>

<sect1>Die Konsole wiederherstellen
<p>
Manchmal führen Ausgaben auf der Konsole, <tt>$cat <var>Binärdatei</var></tt>
ist ein solcher Vertreter, dazu, dass die Aus- und Eingaben unleserlich
werden. Rettung verschafft hier ein blind eingetipptes:
<example>
$ reset
</example>
</sect1>

<sect1>Konvertieren einer Textdatei von DOS nach Unix
<p>
Eine DOS-Textdatei, die man an ihrem Zeilenende <tt>^M^J</tt> erkennt,
kann mit einem einzigen Kommando in eine Unix-Textdatei (Zeilenende =
<tt>^J</tt>) gewandelt werden:
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1>Reguläre Ausdrücke
<p>
Alle Vorkommen des regulären Ausdrucks <var>FROM_REGEX</var> können durch
<var>TO_REGEX</var> in allen Dateien <var>FILES</var> ersetzt werden durch:
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_REGEX</var>/g;' <var>FILES</var> ...
</example>
<tt>-i</tt> zeigt an, dass die Orginaldateien bearbeitet werden, 
<tt>-p</tt> sorgt ausdrücklich für die Iteration über die Dateinamen. Wenn
der reguläre Ausdruck kompliziert ist, kann man sich versichern, indem man
die Originaldateien behält: Durch <tt>-i.bak</tt> anstelle von <tt>-i</tt>
bleiben die Originale erhalten und bekommen die Endung <tt>.bak</tt>.
</sect1>

<sect1>Extract differences and merging updates for the source file
<p>
Following one of the procedures will extract difference of the source
file and create unified diff files <var>file.patch0</var> or
<var>file.patch1</var> depending on the file location:
<example>
$ diff -u <var>file.old</var> <var>file.new1</var> &gt; <var>file.patch0</var>
$ diff -u <var>old/file</var> <var>new1/file</var> &gt; <var>file.patch1</var>
</example>
The diff file (alternatively called patch file) is used to send program
update.  Reciving party will apply this update to another <var>file</var>
by:
<example>
$ patch -p0 <var>file</var> &lt; <var>file.patch0</var>
$ patch -p1 <var>file</var> &lt; <var>file.patch1</var>
</example>
If you have all 3 version of source codes, you can merge them more
effectively using <prgn>diff3</prgn>:
<example>
$ diff3 -m <var>file.mine</var> <var>file.old</var> <var>file.yours</var> &gt; <var>file</var>
</example>
</sect1>

<sect1>Eine große Datei in kleine zerlegen
<p>
<example>
$ split -b 650m <var>datei</var>   # in 650MB große Stücke trennen
$ cat x* ><var>großedatei</var>    # wieder zusammenfügen
</example>
</sect1>

<sect1>Kleine Tricks mit Pipes
<p>
Hier folgen einige kleine lehrreiche Beispiele zur Verwendung von Pipes:
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # Find alle Dateien unterhalb /usr 
                     # exklusive bestimmte Pfade
xargs -n 1 <var>command</var>   # Starte Befehl für alle Zeilen von stdin
xargs -n 1 echo|     # Beliebige Leerzeichen werden zu Zeilenumbrüchen
grep -e <var>pattern</var>|     # Gebe Zeilen aus, die <var>pattern</var> 
                     # enthalten
cut -d: -f3 -|       # gebe das dritte Feld aus, mit : als Trenner  
                     # (z.B. in der Passwortdatei passwd)
col -bx |            # Entferne Backspace und expandiere Tabs zu Leerzeichen
expand -|            # expandiere Tabs zu Leerzeichen
sort -u|             # Sortieren und Duplikate entfernen
tr '\n' ' '|         # mehrere Zeilen zu einer zusammenfügen
tr '\r' ''|          # CR entfernen
tr 'A-Z' 'a-z'|      # Großbuchstaben nach Kleinbuchstaben wandeln
sed 's/^/# /'|       # Aus der Zeile einen Kommentar machen
sed 's/\<var>.ext</var>//g'|    # Entferne <var>.ext</var>
sed  -n -e 2p|       # Zeige die zweite Zeile
head -n 2 -|         # Zeige die ersten beiden Zeilen
tail -n 2 -|         # Zeige die letzten beiden Zeilen
</example>
</sect1>

<sect1>Text oder Mailinglist aus einer Webseite extrahieren
<p>
Der Textbrowser <prgn>lynx</prgn> leistet dieses ohne Interaktion:
So kann man leicht Code-Beispiele aus einer Webseite holen, ohne mühsame
Dialoge.
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>textfile</var>
</example>
<prgn>links</prgn> und <prgn>w3m</prgn> haben eine ähnliche Funktion,
die Ergebnisse können sich aber leicht unterscheiden
<p>
Falls ein Archiv einer Mailing-Liste geladen wird, kann <prgn>munpack</prgn>
benutzt werden, um den MIME-Inhalt zu extrahieren.
</sect1>

<sect1>Formatierte Ausgabe von Webseiten
<p>
Um eine Webseite zu drucken, kann diese in das PostScriptformat gewandelt
werden:
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Siehe auch <ref id="lprlpd">.  Alternativ kann die Textdatei (siehe
vorherigen Absatz) auch mit <prgn>a2ps</prgn> oder <prgn>mpage</prgn> zum
Drucken aufbereitet werden.
</sect1>

<sect1>Pretty print a manual page
<p>
The following will print a manual page into a PostScript file/printer.
<example>
$ man -Tps <var>some-man-page</var> | lpr
$ man -Tps <var>some-man-page</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Merge two Postscript or PDF files
<p>
You can merge two Postscript or PDF files.
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>
    
<sect1>Ausführungsdauer messen
<p>
Um die verschiedenen Zeiten, die mit einem Prozessablauf verbunden sind,
anzuzeigen, kann <prgn>time</prgn> verwendet werden.
<example>
# time <var>some-command</var> &gt;/dev/null
real    0m0.035s       # "Echte" Zeit
user    0m0.000s       # Zeit in Benutzermodus
sys     0m0.020s       # Zeit in Kernelmodus
</example>
</sect1>

<sect1><prgn>nice</prgn>-Befehl
<p>
Der <prgn>nice</prgn>-Befehl dient dazu, die Priorität eines Prozesses zu
setzen. Dessen Verwandter <prgn>renice</prgn> (Paket
<package>bsdutils</package>) ändert die Priorität eines bereits laufenden
Prozesses. Letzteres kann auch aus <prgn>top</prgn> heraus geschehen. Ein
<prgn>nice</prgn>-Wert von 19 bedeutet niedrigste Priorität - der Prozess
ist langsam --, absteigend wird die Priorität erhöht. Kleinere Werte als 0
kann nur der Administrator setzen, -20 ist die höchste Priorität.
<example>
# nice  -19 <var>top</var>                                         # sehr nett
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # sehr schnell
</example>
Manchmal kann ein sehr langsamer Prozess dem System mehr schaden als
nützen, also ist Vorsicht geboten.
</sect1>

<sect1 id="cronjob">Terminplanung für Prozesse (<prgn>cron</prgn>,
                    <prgn>at</prgn>)
<p>
Mit <prgn>cron</prgn> und <prgn>at</prgn> können zu bestimmten Terminen
Befehle ausgeführt werden. Siehe <manref name="at" section="1">,
<manref name="crontab" section="5">, <manref name="crontab" section="8">. 
<p> 
Die Tabelle für wiederkehrende Ausführung kann mit <tt>crontab -e</tt>
bearbeitet werden. (Ein anderer Editor als <prgn>vi</prgn> kann mit der
Umgebungsvariablen <tt>EDITOR</tt> festgelegt werden.) Beispiele einer
crontab-Tabelle:
<example>
# Verwende /bin/sh zur Ausführung, egal was passwd sagt
SHELL=/bin/sh
# Standardausgabe wird an `paul' geschickt.
MAILTO=paul
# Min Stunde TagDesMonats Monat TagDerWoche Befehl (Komma wird 'und')
# starte um 00:05, jeden Tag
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# starte unm 14:15 am Monatsersten -- Ausgabe per Email an Paul
15 14 1  * *   $HOME/bin/monthly
# starte um 22:00 an Werktagen (1-5), schicke Email an Joe. &percnt; für Zeilenumbruch, letztes &percnt; für cc:
0 22 *   * 1-5 mail -s "Es ist 10 Uhr" joe&percnt;Joe,&percnt;&percnt;Gute Nacht?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "Startet 23 Minuten nach 0 Uhr, 2 Uhr, 4 Uhr ..., am 1. Feb."
5  4 *   * sun echo "Startet um 04:05 jeden Sonntag"
# Startet um 03:40 an jedem ersten Montag des Monats
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
Um einen Befehl zur einmaligen Ausführung zu terminieren dient <prgn>at</prgn>
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Konsolenumschaltung mit <prgn>screen</prgn>
<p>
Mit <prgn>screen</prgn> kann man mehrere virtuelle Terminals
auf einer einzigen Konsole starten, jedes mit einer eigenen interaktiven
Shell. Selbst wenn man immer zwischen virtuellen Terminals umschalten kann
oder mehrere xterm-Fenster offen hält, sollte man sich <prgn>screen</prgn>
wegen seiner vielfältigen Möglichkeiten anschauen. Dazu gehören
<list compact>
<item>Kommando-Rückholung,
<item>Kopieren-Einfügen,
<item>protokollieren,
<item>Eingabe von Umlauten und
<item>die Möglichkeit eine komplette Sitzung an einem Terminal anzuhalten
      und später fortzusetzen.
</list>

<sect2>Beispiel für einen Fernzugriff
<p>
Wenn man sich häufig mit einem VT100-Terminal-Programm über ein Netzwerk
auf einem PC einwählt, wird man das Sitzungsmanagement mit
<prgn>screen</prgn> sicherlich nützlich finden.
<p>
<enumlist compact>
<item>Angenommen man ist über eine Telefonverbindung eingeloggt, eine
      <prgn>screen</prgn>-Sitzung ist gestartet und man hat einen längeren
      Text mit einem Editor geschrieben. Aus irgendwelchen Gründen, muss man
      jetzt die Verbindung unterbrechen.
<item>Durch Drücken von <tt>^A d</tt> wird die aktuelle Sitzung gesichert.
      (Noch schneller geht es mit <tt>^A DD</tt>, dann wird sogar gleich der
      Logout für einen vorgenommen.)
<item>Wenn man sich später wieder einwählt kann man mit <tt>screen -r</tt>
      die Sitzung holen, und <prgn>screen</prgn> wird die Sitzung so
      restaurieren, wie sie verlassen wurde.
</enumlist>

<sect2>Typische <prgn>screen</prgn>-Befehle
<p>
Wenn der <prgn>screen</prgn>-Prozess gestartet ist, reicht dieser alle
Tastatureingaben an das aktuelle Fenster, bis auf die Kommandosequenz, die
auf <tt>^A</tt> voreingestellt ist. Alle <prgn>screen</prgn>-Befehle
beginnen mit <tt>^A</tt> und werden dann von einem einzelnen Buchstaben
gefolgt (ggf. folgen dann die Parameter). Beispiele für Befehle:
<example>
^A ?     Hilfe (Tastaturbelegung)
^A c     Neues Fenster und wechsele dorthin
^A n     Gehe zum nächsten Fenster
^A p     Gehe zum vorherigen Fenster
^A <var>0</var>     Gehe zum Fenster Nummer <var>0</var>
^A w     Zeige eine Liste der Fenster
^A a     Gebe das ^A an die Applikation weiter
^A h     Hardcopy des Fensters in Datei
^A H     Starte/Beende Protokoll des aktuellen Fensters in eine Datei
^A ^X    Sichere das Terminal mit einem Passwort
^A d     Aktuelle Sitzung vom Terminal abmelden
^A DD    Vom Terminal abmelden und Logout
</example>
Dies ist nur eine kleine Auswahl der Befehle, die das mächtige
<prgn>screen</prgn> unterstützt. Siehe <manref name="screen" section="1"> für 
weitere Details.

<sect2>Backspace und/oder Ctrl-H in einer <prgn>screen</prgn> Sitzung
<p>
Wenn die Backspace- oder Ctrl-H-Taste während einer
<prgn>screen</prgn>-Sitzung nicht funktionieren, muss die Zeile 
<example compact>
bindkey -k kb stuff "\177"
</example>
in der Datei <file>/etc/screenrc</file> auskommentiert ("#") werden.

<sect2><prgn>screen</prgn>-Äquivalent unter X
<p>
Siehe Paket <prgn>xmove</prgn> und dort <manref name="xmove" section="1">.

</sect1>

<sect1>Grundlagen - Prüfung des Netzwerks
<p>
Installiere um die grundlegenden Funktionen des Netzwerks zu überprüfen
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (für 2.2 Kernel),
<package>iptables</package> (für 2.4 Kernel), und das
<package>net-tools</package> Paket und führe folgende Sequenz aus:
<example>
$ ping <var>yahoo.com</var>            # teste Internetverbindung
$ traceroute <var>yahoo.com</var>      # tracen der IP-Pakete
$ ifconfig                  # testen der host-Konfiguration
$ route -n                  # testen der routing-Konfiguration
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # teste <var>host.dom</var> DNS-Einträge am <var>dns-server.com</var> 
      # und suche dort nach <var>{mx|any}</var> Eintrag
$ ipchains  -L -n |less     # teste packet-Filter (2.2 kernel)
$ iptables -L -n |less      # teste packet-Filter (2.4 kernel)
$ netstat -a                # Finde alle offenen Ports
$ netstat -l --inet         # Finde alle auf Eingabe wartenden Ports
$ netstat -ln --tcp         # Ebenso (TCP, numerisch) Ports
</example>
</sect1>

<sect1>Email aus dem lokalen Spooler leiten (flush)
<p>
Um Email aus dem lokalen Spooler weiterzuleiten:
<example>
# exim -q    # wartende Email anstoßen
# exim -qf   # alle Emails weiterleiten
# exim -qff  # dasselbe, auch Email mit Status 'frozen' wird weitergeleitet
</example>
<tt>-qff</tt> wäre wohl die bessere Wahl in dem Skript
<file>/etc/ppp/ip-up.d/exim</file>.
</sect1>

<sect1>'Frozen' Email aus dem lokalen Spooler entfernen
<p>
Um nicht weiter vermittelbare Email aus dem lokalen Spooler zu entfernen
und eine Fehlermeldung zurückzugeben dient:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Re-deliver mbox contents
<p>
You need to manually deliver mails to the sorted mail boxs in your
home directory from <file>/var/mail/<var>username</var></file>
if your home directory became full and procmail failed.  After making
disk space in the home directory, run:
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>username</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>Dateiinhalte zurücksetzen
<p>
Um eine Datei zurückzusetzen, z.B. ein Log-Datei, sollte nicht <tt>rm</tt>
benutzt werden, da diese Dateien im Sekundenrhythmus geschrieben werden.
Sicherer ist:
<example>
$ :&gt;<var>dateiname</var>
</example>
</sect1>

<sect1>Dummy-Dateien
<p>
Die folgenden Befehle erzeugen leere Dateien beliebiger Größe:
<example>
$ dd if=/dev/zero    of=<var>dateiname</var> bs=1k count=5 # 5KB große, aber leere Datei
$ dd if=/dev/urandom of=<var>dateiname</var> bs=1m count=7 # 7MB mit Zufallsinhalt
$ touch <var>dateiname</var> #erzeuge 0B Datei (wenn sie existiert, setze mtime neu)
</example>
</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<p>
Wenn man neben seiner &debian;-Distribution noch eine andere installiert
hat (dies kann auch jede andere Distribution sein), z.B. auf der Partition
<file><var>/dev/hda1</var></file>, dann kann dieses zweite System mit dem
aktuellen Kernel ohne Warmstart gestartet werden.

<example>
# mount <var>/dev/hda1 /mnt/target</var>
 ... dies nimmt an, dass das zweite System auf <var>/dev/hda1</var> liegt
# chroot /mnt/target
 ... Jetzt wird der Inhalt von <var>/dev/hda1</var> als root-Verzeichnis betrachtet
# mount proc /proc              # reine Vorsicht
 ... Ausgeführte Befehle stammen nun von  <var>/dev/hda1</var>
</example>
So kann man verschiedene Stabilitätszweige (stable/testing/unstable) auf
einer Maschine testen. Eine weitere Möglichkeit wäre, ein fremdes System
per NFS zu mounten und <prgn>chroot</prgn> auf dieses neu gemountete
Verzeichnis anzuwenden.
<p>
Ein auf <prgn>chroot</prgn> basierendes System kann leicht mit 
<prgn>debootstrap</prgn> (in Woody) erzeugt werden.
<example>
# mkdir <var>potatochroot</var>
# debootstrap potato <var>potatochroot</var>
# chroot <var>potatochroot</var>
# apt-setup # set-up /etc/apt/sources.list
</example>
<p>
Es gibt ein ausgefeilteres <prgn>chroot</prgn>-Paket,
<package>pbuilder</package>. Es erzeugt eine <prgn>chroot</prgn>-Umgebung
und stellt ein &debian;-Paket in dieser Sandbox zusammen. So kann man
Paketabhängigkeiten definieren, erkennen und aufzulösen.
<p>
See <url id="&setup-chroot;">
</sect1>

<sect1>How to check hard links
<p>
You can check whether 2 files are the same file with 2 hard links by:
<example>
$ ls -li <var>file1</var> <var>file2</var>
</example>

<sect1>Ein Festplatten-Image <prgn>mount</prgn>en 
<p>
Wenn <file><var>file.img</var></file> ein Festplatten-Image enthält und die
Quellfestplatte eine Konfiguration wie <var>xxxx</var> = (Byte/Sektor) *
(Sektor/Zylinder) hat, dann kann dieses Image mit dem folgenden Befehl nach
<file>/mnt</file> gemountet werden:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
Die meisten Festplatten haben 512 bytes/Sektor

<sect1>Samba
<p>
Grundlagen um auf Windows-Dateien zuzugreifen:
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # freigegebene Windows-Laufwerke mounten
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # Freigaben anzeigen
</example>
<p>
Die Netzwerk-Nachbarschaft kann angezeigt werden mit:
<example>
# smbclient -N -L <var>eigene_IP_Address</var> | less
# nmblookup -T "*"
</example>
</sect1>

</sect>

</chapt>

