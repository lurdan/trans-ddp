<!-- CVS revision of this document "$Revision: 1.13 $"  -->
<!-- CVS revision of original english document "1.54"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->
<!-- DON't TOUCH GROFF SECTION!!! -->


<chapt id="program">Programmierung
<p>
Verwenden Sie nicht "test" als Namen für eine ausführbare Testdatei.
<prgn>test</prgn> ist ein Shell builtin.

<sect>Wo man startet
<p>
Referenzen:
<list compact>
<item>Dokumente und Beispiele unter <file>&dochome;<var>Paket</var></file>
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
Viele lange info Dokumente können als Taschenbuch von
<url id="&gnuhome;" name="GNU"> erhalten werden.
<p>
Die nächsten vier Abschnitte enthalten Beispielskripte in verschiedenen
Sprachen, die eine Textdatei mit Zugangsinformationen erzeugen, welche an
<file>/etc/passwd</file> mittels einer Stapelverarbeitung wie das
<prgn>newusers</prgn> Programm angehangen werden. Jedes Skript erfordert als
Eingabe eine Datei mit Zeilen der Gestalt <tt>Vorname Nachname Passwort</tt>.
(Homeverzeichnisse werden mit diesen Skripten nicht erzeugt.)
</sect>

<sect id="shell">Shell
<p>
Das Lesen von Shellskripten ist der <strong>beste</strong> Weg, um zu
verstehen, wie ein Unix-artiges System arbeitet. Ich gebe hier einige
Hinweise zur Shellprogrammierung an. Lesen Sie <url id="&shell-mistakes;"
name="Shell-Fehler"> um aus Fehlern zu lernen.

<sect1 id="bash">Bash &ndash; interaktive <strong>GNU</strong> Standard Shell
<p>
Referenzen für Bash:
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>das LDP <url id="&bashprogintro-howto;"
      name="BASH Programming - Introduction HOWTO"> als Information für
      Starter.
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
      <p>
      (Installieren Sie das <package>bash-doc</package> Paket für
      Beispieldateien.)
<item><em>Learning the bash Shell</em>, 2. Ausgabe (O'Reilly)
</list>
<p>
Kurzes Programmbeispiel (erzeugt Zugangswerte für <prgn>newusers</prgn> von
der Standardeingabe):
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">POSIX Shells
<p>
Verschiedene Pakete bieten eine POSIX Shell in &debian; an:
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 176
  <item>Kleinste und schnellste &ndash; das Beste zum Booten
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 180
  <item>Kleiner und viel schneller &ndash; gut für Bootprozess
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essential: yes
  <item>Priority: required
  <item>Installed-Size: 580
  <item>Größer und vielfältig &ndash; viele implementierte Erweiterungen
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 408
  <item>Komplett AT&amp;T ksh ähnlich
 </list>
</list>
<p>
Wollen Sie portable Shellskripte schreiben, ist es am besten es als POSIX
Shellskript zu schreiben. Verwenden Sie <file>/bin/sh</file> verlinkt auf
<prgn>ash</prgn> (oder <prgn>dash</prgn>), um dessen POSIX Konformität zu
testen. Vermeiden Sie Skripte mit <strong>bashism</strong> oder
<strong>zshism</strong> zu schreiben, was der <prgn>csh</prgn> Syntax ähnelt.
Vermeiden Sie zum Beispiel:
<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>Datei</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>

<sect1 id="shell-param">Shellparameter
<p>
Verschiedene <strong>spezielle Parameter</strong> zum Einprägen:
<example compact>
$0      = Name der Shell oder des Shellskripts
$1      = erstes Shellargument
 ...
$9      = neuntes Shellargument
$#      = Anzahl der Parameter
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = Exit-Status des zuletzt ausgeführten Kommandos
$$      = Prozessnummer (PID) dieses Shellskripts
$!      = PID des zuletzt ausgeführten Hintergrundkommandos
</example>
<p>
Grundlegende <strong>Parameterauswertungen</strong> zum Einprägen:
<example compact>
Ausdruck        Wenn <var>var</var> gesetzt ist Wenn <var>var</var> nicht gesetzt ist
${<var>var</var>:-<var>string</var>}  $<var>var</var>                 <var>string</var>
${<var>var</var>:+<var>string</var>}  <var>string</var>               null
${<var>var</var>:=<var>string</var>}  $<var>var</var>                 <var>string</var> (und setzt <var>var</var>=<var>string</var>)
${<var>var</var>:?<var>string</var>}  $<var>var</var>                 (<var>string</var> Ausgabe und Abbruch)
</example>
Der Doppelpunkt `:' in all diesen Operatoren ist optional.
<list compact>
<item>Mit `:' = Operatortest für "existiert" und "nicht Null".
<item>Ohne `:' = Operatortest nur für "existiert".
</list>
<p>
Grundlegende <strong>Parametersubstitutionen</strong> zum Einprägen:
<example compact>
Ausdruck        Ergebnis
${<var>var</var>&percnt;<var>suffix</var>}   Entferne kleinstes <var>suffix</var> Muster
${<var>var</var>&percnt;&percnt;<var>suffix</var>}  Entferne größtes <var>suffix</var> Muster
${<var>var</var>#<var>präfix</var>}   Entferne kleinstes <var>präfix</var> Muster
${<var>var</var>##<var>präfix</var>}  Entferne größtes <var>präfix</var> Muster
</example>

<sect1 id="shell-redirect">Shellumleitung
<p>
Grundlegende <strong>Umleitungen</strong> zum Einprägen ([<var>n</var>] ist eine
optionale Nummer):
<example compact>
[<var>n</var>]&gt; <var>Datei</var>     Umleiten der Standardausgabe (oder <var>n</var>) zu <var>Datei</var>.
[<var>n</var>]&gt;&gt; <var>Datei</var>    Anhängen der Standardausgabe (oder <var>n</var>) zu <var>Datei</var>.
[<var>n</var>]&lt; <var>Datei</var>     Umleiten der Standardeingabe (oder <var>n</var>) von <var>Datei</var>.
[<var>n1</var>]&gt;&amp;<var>n2</var>       Umleiten der Standardausgabe (oder <var>n1</var>) zu <var>n2</var>.
2&gt; <var>Datei</var> &gt;&2   Umleiten der Standard- und Fehlerausgabe zu <var>Datei</var>.
| <var>Kommando</var>     Standardausgabe an <var>Kommando</var> weiterreichen.
2&gt;&1| <var>Kommando</var> Standard- und Fehlerausg. an <var>Kommando</var> weiterreichen.
</example>

<sect1 id="shell-cond">Bedingte Ausdrucke in der Shell
<p>
Jedes Kommando gibt einen <strong>Exit-Status</strong> zurück, was für einen
bedingten Ausdruck verwendet werden kann:
<list compact>
<item>Erfolg: 0 (wahr)
<item>Fehler: 1&ndash;255 (falsch)
</list>
Es ist zu beachten, dass die Verwendung des 0 Werts im Sinne von "wahr" sich
von den üblichen Konventionen in anderen Bereichen der Programmierung
unterscheidet. Auch ist `[' das Äquivalent des <prgn>test</prgn> Kommandos,
das sein Argument bis zu `]' als bedingten Ausdruck auswertet.
<p>
Grundlegende <strong>bedingte Ausdrucke</strong> zum Einprägen sind:
<example compact>
<var>Kommando</var> && <var>bei_Erfolg_dies_starten</var> || true
<var>Kommando</var> || <var>bei_Misserfolg_dies_starten</var>

if [ <var>bedingter_Ausdruck</var> ]; then
 <var>bei_Erfolg_dies_starten</var>
else
 <var>bei_Misserfolg_dies_starten</var>
fi
</example>
Es wurde <tt>|| true</tt> verwendet, um sicherzustellen, dass das Shellskript
in dieser Zeile nicht versehentlich abgebrochen wird, wenn die Shell (oder
<prgn>set</prgn>) mit der Option <tt>-e</tt> gestartet wird.
<p>
<strong>Datei</strong>vergleichsoperatoren im bedingten Ausdruck sind:
<example compact>
Ausdruck          Wahr wenn ...
-e <var>Datei</var>          <var>Datei</var> existiert.
-d <var>Datei</var>          <var>Datei</var> existiert und ein Verzeichnis ist.
-f <var>Datei</var>          <var>Datei</var> existiert und eine reguläre Datei ist.
-w <var>Datei</var>          <var>Datei</var> existiert und schreibbar ist.
-x <var>Datei</var>          <var>Datei</var> existiert und ausführbar ist.
<var>Datei1</var> -nt <var>Datei2</var> <var>Datei1</var> neuer als <var>Datei2</var> ist. (Modifizierungszeit)
<var>Datei1</var> -ot <var>Datei2</var> <var>Datei1</var> älter als <var>Datei2</var> ist. (Modifizierungszeit)
<var>Datei1</var> -ef <var>Datei2</var> beide die selbe Device- und Inode-Nummer haben.
</example>
<p>
<strong>String</strong>vergleichsoperatoren im bedingten Ausdruck sind:
<example compact>
Ausdruck       Wahr wenn ...
     -z <var>str</var>    die Länge von <var>str</var> Null ist.
     -n <var>str</var>    die Länge von <var>str</var> nicht Null ist.
<var>str1</var> == <var>str2</var>   <var>str1</var> und <var>str2</var> gleich sind.
<var>str1</var> =  <var>str2</var>   <var>str1</var> und <var>str2</var> gleich sind.
   ("=" sollte statt "==" für POSIX Konformität verwendet werden)
<var>str1</var> != <var>str2</var>   <var>str1</var> und <var>str2</var> ungleich sind.
<var>str1</var> &lt;  <var>str2</var>   <var>str1</var> vor <var>str2</var> einsortiert wird (locale abhängig).
<var>str1</var> &gt;  <var>str2</var>   <var>str1</var> nach <var>str2</var> einsortiert wird (locale abhängig).
</example>
<p>
<strong>Arithmetische</strong> Ganzzahlvergleiche im bedingten Ausdruck
sind <tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>, <tt>-le</tt>, <tt>-gt</tt>
und <tt>-ge</tt>.
</sect1>

<sect1 id="clprocess">Kommandozeilenbearbeitung
<p>
Die Shell führt ein Skript wie folgt aus:
<list compact>
<item>aufsplitten in <strong>Token</strong> durch Metazeichen: LEERZEICHEN,
      TABULATOR, NEUEZEILE, ;, (, ), &lt;, &gt;, |, &amp;
<item>überprüfen auf <strong>Schlüsselworte</strong> außerhalb von "..."
      und '...' (Schleife)
<item>expandieren der <strong>Aliase</strong> außerhalb von "..." und '...'
      (Schleife)
<item>expandieren der <strong>geschweiften Klammern</strong>,
      <tt>a{1,2}</tt> -> <tt>a1 a2</tt> außerhalb von "..." und '...'
<item>expandieren der <strong>Tilde</strong>, ~<var>Nutzer</var> ->
      <var>Nutzer</var>'s Homeverzeichnis außerhalb von "..." und '...'
<item>expandieren der <strong>Parameter</strong>, $<var>PARAMETER</var>
      außerhalb von '...'
<item>expandieren der <strong>Kommandosubstitutionen</strong>,
      $(<var>Kommando</var>) außerhalb von '...'
<item>aufsplitten in <strong>Wörter</strong> mit $IFS außerhalb von "..."
      und '...'
<item>expandieren von *?[] in <strong>Pfadnamen</strong> außerhalb von
      "..." und '...'
<item>schauen nach <strong>Kommando</strong>
<list compact>
<item>Funktion
<item>builtin
<item>Datei in $PATH
</list>
<item>Schleife
</list>
<p>
Einfache Anführungszeichen innerhalb von doppelten Anführungszeichen haben
keinen Effekt.

</sect1>

</sect>

<sect>Awk
<p>
Referenzen für Awk:
<list compact>
<item><em>Effective awk Programming</em>, 3. Ausgabe (O'Reilly)
<item><em>Sed &amp; awk</em>, 2. Ausgabe (O'Reilly)
<item><manref name="mawk" section="1"> und <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
Kurzes Programmbeispiel (erzeugt <prgn>newusers</prgn> Kommandoeintrag):
<example>
#!/usr/bin/awk -f
# Skript zum Erzeugen einer für das 'newusers' Kommando geeigneten
# Datei aus einer Datei bestehend aus Nutzer IDs und Passwörtern
# in der Form:  Vorname Nachname Passwort
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Verteilbar unter GNU GPL v 2 oder (je nach Ihrer Wahl) einer
# späteren Version.
# Dieses Programm wird OHNE JEGLICHE HAFTUNG vertrieben.

BEGIN {
    # zuweisen der anfänglichen UID, GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Verwendung: newusers startUID Datei\n" \
        " wobei:\n" \
        "  startUID die erste Nutzer ID zum Hinzufügen ist und\n"\
        "  Datei eine Eingabedatei der folgenden Gestalt ist:\n" \
        "    Vorname Nachname Passwort\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Erste UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
Zwei Pakete bieten POSIX <package>awk</package> in &debian; an:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priority: required
  <item>Installed-Size: 228
  <item>Kleiner und viel schneller &ndash; gut zur Standardinstallation
  <item>Compilezeit Limitierungen bestehen
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 1708
  <item>Größer und reichhaltig &ndash; viele implementierte Erweiterungen
  <list compact>
   <item>System V Release 4 Version von UNIX
   <item>Bell Labs awk
   <item>GNU spezifisch
  </list>
 </list>
</list>
</sect>

<sect>Perl
<p>
Dies ist <strong>der</strong> Interpreter auf einem Unix-artigen System.
<p>
Referenzen für Perl:
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3. Ausgabe (O'Reilly)
</list>
<p>
Kurzes Programmbeispiel (erzeugt <prgn>newusers</prgn> Kommandoeintrag):
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Installieren eines Perl Moduls <var>Modul</var>:
<example>
# perl -MCPAN -e 'install <var>Modul</var>'
</example>

</sect>

<sect>Python
<p>
Dies ist ein netter objektorientierter Interpreter.
<p>
Referenzen für Python:
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
</list>
<p>
Kurzes Programmbeispiel (erzeugt <prgn>newusers</prgn> Kommandoeintrag):
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Portiert von awk Skript durch KMSelf Sat Aug 25 20:47:38 PDT 2001
# Dieses Programm wird OHNE JEGLICHE HAFTUNG vertrieben.

def usages():
    print \
"Verwendung: ", sys.argv[0], " start_UID [Dateiname]\n" \
"\tstartUID ist die erste Nutzer ID zum Hinzufügen.\n" \
"\tDateiname ist eine Eingabedatei. " \
"Ohne Angabe wird die Standardeingabe verwendet.\n\n" \
"Format der Eingabedatei:\n" \
"\tVorname Nachname Passwort\n"
                return 1

def parsefile(startuid):
    #
    # filtern
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # obiges stürzt bei falscher Parameteranzahl ab :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID Start von: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Lese Datei von: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>Make
<p>
Referenzen für Make:
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2. Ausgabe (O'Reilly)
</list>
<p>
Einfache automatische Variablen:
<p>
Regelsyntax:
<example>
<var>Ziel</var>: [ <var>Voraussetzungen</var> ... ]
 [TAB]  <var>Kommando1</var>
 [TAB]  -<var>Kommando2</var> # ignoriere Fehler
 [TAB]  @<var>Kommando3</var> # unterdrücke Kommandozeilenausgabe
</example>
Hier ist <tt>[TAB]</tt> ein Tabulator.
Jede Zeile wird von der Shell nach einer Variablensubstitution interpretiert.
Verwenden Sie <tt>\</tt> am Ende einer Zeile zur Fortsetzung des Skripts.
Statt <tt>$</tt> ist <tt>$$</tt> für Umgebungsvariablen zu schreiben.
<p>
<strong>Implizite Regeln</strong> für <var>Ziel</var> und
<var>Voraussetzungen</var> können beispielsweise wie folgt geschrieben
werden:
<example>
&percnt;: &percnt;.c header.h
</example>
oder
<example>
&percnt;.o: &percnt;.c header.h
</example>
Hier enthält <var>Ziel</var> das Zeichen <tt>&percnt;</tt> (exakt
einmal). <tt>&percnt;</tt> passt auf jeden nicht leeren Teilstring in den
aktuellen Zieldateinamen. <var>Voraussetzungen</var> verwendet
<tt>&percnt;</tt> ähnlich um auszudrücken, wie sich diese Namen zum
aktuellen Ziel verhalten.
<p>
<strong>Suffixregeln</strong> sind der <strong>veraltete</strong> Weg zur
Definition impliziter Regeln für <prgn>make</prgn>. Sie werden noch in GNU
<prgn>make</prgn> zur Kompatibilität unterstützt, aber man sollte äquivalente
Musterregeln wann immer möglich verwenden:
<example>
alte Suffixregel --&gt; neue Musterregel
.c:              --&gt; &percnt;  : &percnt;.c
.c.o:            --&gt; &percnt;.o: &percnt;.c
</example>
Automatische Variablen für diese Regel:
<example>
foo.o: neu1.c neu2.c alt1.c neu3.c
$@ == foo.o                         (Ziel)
$< == neu1.c                        (erstes der neueren Objekte)
$? == neu1.c neu2.c neu3.c          (alle neueren Objekte)
$^ == neu1.c neu2.c alt1.c neu3.c   (alle)
$* == `&percnt;' aktuelles Ziel ohne Suffix.
</example>
Variablenreferenzen:
<example>
foo1 := bar    # einmalige Expandierung
foo2  = bar    # rekursive Expandierung
foo3 += bar    # anhängen
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o)
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo))
DIRS  = $(dir directory/filename.ext) # Extracts "directory"
 $(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Starten Sie <tt>make -p -f/dev/null</tt>, um alle internen automatischen
Regeln zu sehen.
</sect>

<sect>C
<p>
Vorbereitung:
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
Referenzen für C:
<list compact>
<item><tt>info libc</tt> (Referenz der C Bibliotheksfunktionen)
<item><manref name="gcc" section="1">
<item><manref name="jede_C_Bibliotheksfunktion" section="3">
<item>Kernighan &amp; Ritchie, <em>Die Programmiersprache C</em>,
 2. Ausgabe (Prentice Hall).
</list>
<p>

<sect1>Ein einfaches C Programm (<prgn>gcc</prgn>)
<p>
Ein einfaches Beispiel zum Kompilieren von <file>example.c</file> mit einer
Bibliothek <file>libm</file> in eine ausführbare Datei namens
<prgn>Testbeispiel</prgn>:
<example>
$ cat &gt; example.c &lt;&lt;EOF
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* Pufferüberlauf verhindern */
        y[10] = '\0'; /* füllen, so dass String mit '\0' endet */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF

$ gcc -Wall -g -o Testbeispiel example.c -lm
$ ./Testbeispiel
        1, 2.915, ./Testbeis,     (null)
$ ./Testbeispiel 1234567890qwertz
        2, 3.082, ./Testbeis, 1234567890qwertz
</example>
Hier wird <tt>-l<strong>m</strong></tt> benötigt, um mit der Bibliothek
<file>lib<strong>m</strong></file> für <prgn>sqrt()</prgn> zu linken. Die
eigentliche Bibliothek ist in <file>/lib/</file> mit dem Dateinamen
<file>libm.so.6</file>, was ein symbolischer Link auf
<file>libm-2.1.3.so</file> ist.
<p>
Schauen Sie auf den letzten Parameter im Ausgabetext. Es gibt mehr als 10
Buchstaben, obwohl <tt>&percnt;10s</tt> spezifiziert ist.
<p>
Die Verwendung von Funktionen die Zeiger auf Speicherbereiche ohne
Bereichscheck nutzen, wie <prgn>sprintf</prgn> und <prgn>strcpy</prgn> wird
missbilligt, um das Ausnutzen von Pufferüberläufen zu verhindern, die obige
Überlaufeffekte verwenden. Stattdessen sollte man <prgn>snprintf</prgn> und
<prgn>strncpy</prgn> verwenden.
</sect1>

<sect1>Fehlersuche

<sect2>Fehlersuche (Debugging) mit <prgn>gdb</prgn>
<p>
Vorbereitung:
<example>
# apt-get install gdb
</example>
<p>
Referenzen für <prgn>gdb</prgn>:
<list compact>
<item><tt>info gdb</tt> (Tutorial)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>
<p>
Verwenden Sie <prgn>gdb</prgn>, um ein mit der <tt>-g</tt> Option
kompiliertes Programm zu debuggen. Viele Kommandos können abgekürzt werden.
Vervollständigungen arbeiten wie in der Shell mit der Tabulator Taste.
<example>
$ gdb Programm
(gdb) b 1                # Haltepunkt in Zeile 1 setzen
(gdb) run <var>arg1 arg2 arg3</var> # Programm starten
(gdb) next               # nächste Zeile
...
(gdb) step               # einen Schritt vorwärts
...
(gdb) p parm             # parm ausgeben
...
(gdb) p parm=12          # Wert auf 12 setzen
</example>
<p>
Um aus Emacs heraus zu debuggen, wird auf <ref id="editkey"> verwiesen.
</sect2>

<sect2 id="ss-ldd">Überprüfen der Abhängigkeiten von Bibliotheken
<p>
Verwenden Sie <prgn>ldd</prgn>, um die Abhängigkeiten eines Programms von
Bibliotheken zu bestimmen:
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
Damit <prgn>ls</prgn> in einer <prgn>chroot</prgn> Umgebung funktioniert,
müssen die obigen Bibliotheken in der <prgn>chroot</prgn> Umgebung
vorhanden sein.
<p>
Die folgenden Kommandos sind auch nützlich:
<list compact>
<item><prgn>strace</prgn>: verfolgt Systemaufrufe und Signale
<item><prgn>ltrace</prgn>: verfolgt Bibliotheksaufrufe
</list>
</sect2>

<sect2>Debuggen mit Tools zur Erkennung von Speicherlecks
<p>
Es gibt verschiedene Tools zur Erkennung von Speicherlecks in &debian;.
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (nicht paketiert, verfügbar unter
 <url id="&memwatch-home;" name="GNU memwatch">.)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> von
  <url id="&parasofthome;" name="Parasoft">. (nicht frei, kommerziell)
</list>
<p>
Überprüfen Sie auch <url id="&mallocdebughome;"
  name="Debugging Tools für dynamische Speicherzuordnung und -Management">.

<sect1>Flex &ndash; ein besseres Lex
<p>
<prgn>flex</prgn> ist ein schneller lexikalischer Analysegenerator.
<p>
Referenzen für <prgn>flex</prgn>:
<list compact>
<item><tt>info flex</tt> (Tutorial)
<item><manref name="flex" section="1">
</list>
<p>
Sie müssen Ihre eigenen Funktionen <prgn>main()</prgn> und
<prgn>yywrap()</prgn> implementieren oder Ihr <file>Programm.l</file> sollte
wie folgt aussehen, um ohne eine Bibliothek zu kompilieren
(<prgn>yywrap</prgn> ist ein Makro; <tt>&percnt;option main</tt> aktiviert
<tt>&percnt;option noyywrap</tt> implizit):
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
Alternativ kann mit der -<tt>lfl</tt> Linker Option am Ende Ihrer
<prgn>cc</prgn> Kommandozeile kompiliert werden (wie AT&amp;T-Lex mit
<tt>-ll</tt>). Keine <tt>&percnt;option</tt> wird in diesem Fall benötigt.
</sect1>

<sect1>Bison &ndash; ein besseres Yacc
<p>
Einige Pakete bieten einen Yacc kompatiblen LALR Parser Generator in &debian;
an:
<p>
<list compact>
 <item><package>bison</package>: GNU LALR Parser Generator
 <item><package>byacc</package>: Der Berkeley LALR Parser Generator
 <item><package>byyacc</package>: Rückfolgender Parser Generator basierend
       auf <package>byacc</package>
</list>
<p>
Referenzen für <prgn>bison</prgn>:
<list compact>
<item><tt>info bison</tt> (Tutorial)
<item><manref name="bison" section="1">
</list>
<p>
Sie müssen Ihre eigenen <prgn>main()</prgn> und <prgn>yyerror()</prgn>
Funktionen implementieren. <prgn>main()</prgn> ruft <prgn>yyparse()</prgn>,
was wiederum <prgn>yylex()</prgn> aufruft, das gewöhnlich von FleX erzeugt
wird.
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> ist ein Tool zum Erzeugen von Shellskripten, die
Softwarequellpakete automatisch so konfigurieren, dass sie sich an viele
UNIX-artige Systeme unter Verwendung des vollständigen GNU Build Systems
anpassen.
<p>
<prgn>autoconf</prgn> erzeugt das Konfigurationsskript
<prgn>configure</prgn>. <prgn>configure</prgn> erzeugt automatisch ein
angepasstes <file>Makefile</file> aus <file>Makefile.in</file>.

<sect2>Kompilieren und Installieren eines Programms
<p>
&debian; ändert keine Dateien unter <file>/usr/local</file> (vergleichen Sie
<ref id="diverse">). Kompilieren Sie ein Programm aus den Quellen, so
sollten Sie es in <file>/usr/local</file> installieren, damit es nicht mit
&debian; interferiert.
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # dies kopiert die Dateien ins System
</example>

<sect2>Deinstallation eines Programms
<p>
Wenn Sie noch den Quellcode haben, dieser
<prgn>autoconf</prgn>/<prgn>automake</prgn> nutzt und Sie noch wissen, wie
Sie es konfiguriert haben, verfahren Sie wie folgt:
<example>
$ ./configure <var>alle-verwendeten-Optionen</var>
# make uninstall
</example>
<p>
Sind Sie sich absolut sicher, dass der Installationsprozess Dateien nur
unter <file>/usr/local</file> ablegt und es nichts wichtiges darunter gibt,
können Sie alles wie folgt löschen:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
Sind Sie nicht sicher, wo Dateien installiert sind, sollten Sie einen Blick
auf <package>checkinstall</package> werfen, was einen leeren Pfad bei der
Deinstallation liefert.
</sect1>

</sect>

<sect>Dokument Aufbereitung
<p>

<sect1>Das <tt>roff</tt> Satzsystem
<p>
Traditionell ist <tt>roff</tt> das wichtigste Unix Textbearbeitungssystem.
<p>
Vergleichen Sie <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7"> und
<tt>info groff</tt>.
<p>
Es gibt eine gute Einführung zu <prgn>-me</prgn> Makros. Haben Sie
<package>groff</package> (1.18 oder neuer), suchen Sie <file>&f-meintro;</file>
und führen Sie das folgende aus:
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
Das folgende erzeugt eine einfache Textdatei:
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
Verwenden Sie die PostScript Ausgabe zum Drucken.
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>




<sect1>SGML
<p>
Vorbereitung:
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
Referenzen für <package>debiandoc-sgml</package>:
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em><url name="DocBook: The Definitive Guide"
      id="&f-docbook-defguide;"></em> von Walsh und Muellner (O'Reilly)
      (Paket <package>&p-docbook-defguide;</package>)
</list>
<p>
SGML ermöglicht das Verwalten mehrerer Dokumentformate. Ein einfaches SGML
System ist Debiandoc, was hier verwendet wird. Dies erfordert kleinere
Umwandlungen der Textdateien für die folgenden Buchstaben:
<!-- nbsp bug in PDF ? -->
<list compact>
<item>"&lt;" --&gt; <tt>&amp;lt;</tt>
<item>"&gt;" --&gt; <tt>&amp;gt;</tt>
<item>"&nbsp;" --&gt; <tt>&amp;nbsp;</tt>  (nicht trennbares Leerzeichen)
<item>"&amp;" --&gt; <tt>&amp;amp;</tt>
<item>"&percnt;" --&gt; <tt>&amp;percnt;</tt>
<item>"&copy;" --&gt; <tt>&amp;copy;</tt>
<item>"&ndash;" --&gt; <tt>&amp;ndash;</tt>
<item>"&mdash;" --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
Um einen Abschnitt als nicht ausgebbaren Kommentar zu markieren, wird
folgendes verwendet:
<example>
&lt;!-- Darlegen des Sachverhalts ... --&gt;
</example>
Für einen Abschnitt mit abschaltbarem Kommentar:
<example>
&lt;![ &percnt;FIXME; [ Darlegen des Sachverhalts ... ]]&gt;
</example>
In SGML gewinnt die <em>erste Definition</em> einer Entität. Zum Beispiel:
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Daten 1"&gt; ]]&gt;
&lt;!entity param "Daten 2"&gt;
&amp;param;
</example>
Dies endet mit "Daten 1". Enthält die erste Zeile "IGNORE" anstatt
"INCLUDE", endet es mit "Daten 2" (die zweite Zeile ist eine bedingte
Anweisung). Es ist auch möglich, einzelne wiederholende Textabschnitte
separat vom Inhalt zu definieren.
<example>
&lt;!entity <var>wessen</var> "mein"&gt;
Hallo &amp;<var>wessen</var>; Freund.
Dies ist &amp;<var>wessen</var>; Buch.
</example>
Dies ergibt das folgende:
<example>
Hallo mein Freund.
Dies ist mein Buch.
</example>
Vergleichen Sie mit dem kurzen SGML Beispiel <file>sample.sgml</file> im
<url id="&examples;" name="Beispielverzeichnis">.
<p>
Wenn SGML Dokumente größer werden, hat TeX, das intern zur
Textbearbeitung verwendet wird, manchmal Probleme. Vergleichen Sie
<ref id="texlatex">.

<!-- XXX FIXME XXX: Add XML section-->

<sect1 id=texlatex>TeX/LaTeX
<p>
Vorbereitung:
<example>
# tasksel # wählen Sie Miscellaneous  --&gt; TeX/LaTeX-Umgebung
</example>
Referenzen für LaTeX:
<list compact>
<item><url id="&tetex-howto;" name="The teTeX HOWTO: The Linux-teTeX Local Guide">
<item><manref name="tex" section="1">
<item><manref name="latex" section="1">
<item><em>The TeXbook</em> von Donald E. Knuth (Addison-Wesley)
      <footnote>
        Der TeX-Quellcode dieses Buches ist unter <url id="&texbooksource;">
        erhältlich. <url id="&texbookmacros;"> enthält die meisten der
        benötigten Makros. Das Dokument kann mit <prgn>tex</prgn> bearbeitet
        werden, nachdem die Zeilen 7 bis 10 auskommentiert und
        <tt>\input manmac \proofmodefalse</tt> hinzugefügt wurde.
        <p>
        Es ist sehr empfehlenswert dieses Buch (und alle anderen Bücher von
        Donald E. Knuth) zu kaufen, statt die Online-Version zu verwenden,
        aber der Quellcode ist ein sehr gutes Beispiel für TeX-Code!
      </footnote>
<item><em>Das LaTeX-Handbuch</em> von Leslie Lamport (Addison-Wesley)
<item><em>Der LaTeX-Begleiter</em> von Goossens, Mittelbach, Samarin
      (Addison-Wesley)
</list>
<p>
Dies ist das mächtigste Satztextprogramm. Viele SGML Bearbeitungsprogramme
verwenden dies zur Textbearbeitung im Hintergrund. Lyx, dass mit den
Paketen <package>lyx</package>, <package>lyx-xforms</package> oder 
<package>lyx-qt</package> bereitgestellt wird, bietet eine nette WYSIWYG
Umgebung zum Editieren für LaTeX, zu der viele Emacs und Vim als
Quellcode-Editor wählen.
<p>
Es gibt viele Online-Verweise:
<list compact>
<item><url id="&f-tetex-doc;" name="teTeX - A Documentation Guide">
      (<package>&p-tetex-doc;</package> Paket)
<item><url id="&dochome;texmf/latex/general/l2kurz.dvi.gz"
      name="LaTeX2e-Kurzbeschreibung">
<item><url id="ftp://ftp.dante.de/tex-archive/info/german/"
      name="Viele weitere deutschsprachige Dokumente zu LaTeX">
      (u.a. <em>Das kleine TeX-Buch</em>, eine deutscher Auszug aus
      <em>The TeXbook</em>)
<item><url id="&pfaffbenhome;" name="A Quick Introduction to LaTeX">
<item><url id="&latexlyx;" name="A Simple Guide to Latex/Lyx">
<item><url id="&latexbasic;" name="Word Processing Using LaTeX">
<item><url id="&local-guide;" name="Local User Guide to teTeX/LaTeX">
</list>
Wenn Dokumente größer werden, hat TeX manchmal Probleme.
Um dies zu korrigieren, muss die Pool-Größe in
<file>/etc/texmf/texmf.cnf</file> erhöht werden (oder editieren Sie besser
<file>/etc/texmf/texmf.d/95NonPath</file> und starten Sie
<prgn>update-texmf</prgn>).

<sect1>Literate Programming
<p>
Anstatt Code zu schreiben, der Dokumentationen enthält, schreibt der gebildete
Programmierer (literate programmer) Dokumentation die Code enthält. Dieser
Ansatz sichert eine gute Dokumentation für ein Programm.
<p>
Für weitere Informationen zu literate-programming wird auf
<url id="&literatehome;" name="Literate Programming"> verwiesen.

<sect2>Noweb
<p>
Vorbereitung:
<example>
# apt-get install nowebm
</example>
Referenzen für Noweb:
<list compact>
<item><url id="&nowebhome;" name="Noweb --- A Simple, Extensible Tool for Literate Programming">
<item><manref name="noweb" section="1">
</list>
<p>
Dies ist ein WEB-artiges literate-programming Werkzeug, das einfacher ist,
sowie erweiterbar und sprachunabhängig. 
<footnote>
Dieses WEB hat <strong>nichts</strong> zu tun mit dem World Wide Web.  
WEB (für PASCAL) und CWEB (für C/C++) sind traditionelle literate-programming
Werkzeuge.
</footnote>
Wenn <prgn>noweb</prgn> gestartet wird, schreibt es den Programmquellcode
in Ausgabedateien, die in der noweb Datei angegeben sind, und es erstellt
eine TeX-Datei für die Dokumentation.
<p>
Das &debian; Paket <package>ifupdown</package> ist ein gutes Beispiel.
<example>
$ apt-get source ifupdown
$ cd ifupdown*
$ make ifupdown.pdf ifupdown.ps
</example>

<sect2>Doxygen
<p>
Vorbereitung:
<example>
# apt-get install doxygen doxygen-doc doxygen-gui
</example>
Referenzen für Doxygen (von <prgn>doxygen</prgn> erstellt!):
<list compact>
<item><url id="&doxygenhome;" name="Homepage">
<item><url id="/usr/share/doc/doxygen-doc/html/index.html">
</list>
<p>
Es kann HTML, RTF, Unix Manual-Pages, PostScript und PDF (durch LaTeX)
Dokumentation für C++, C, Java, IDL und zum Teil PHP sowie C# Programme
erstellen. Doxygen ist kompatibel zu JavaDoc (1.1), Qt-Doc, KDOC und wurde
speziell entworfen, um Projekte die Troll Tech's <url id="&qthome;"
name="Qt"> Bibliothek nutzen, zu unterstützen. Es erstellt
Include-Abhängigkeitsdiagramme, Diagramme zu Zusammengehörigkeiten und
grafische Darstellungen der Klassenhierarchien sogar für nicht dokumentierte
Programme. Die Ausgabe ist ähnlich zu Qt's Dokumentation.

<sect id="packaging">Paketerzeugung
<p>
Vorbereitung:
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
                  &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # für Potato
</example>
Referenzen für die Paketerzeugung:
<list compact>
 <item><ref id="pkg-basics"> (Grundlagen)
 <item>Debian New Maintainers' Guide (Tutorial)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (sehr praxisnah)
 <item>Debian Policy Manual (die ultimative Dokumentation)
 <item>Packaging Manual (Potato)
</list>

<sect1 id="pack-binary">Paketerzeugung für ein einzelnes Programm
<p>
Eine schnelle und unsaubere Methode der Paketerzeugung für ein einzelnes
Programm ist nach Joey Hess:
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mypackage
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: my little package
 Don't expect much.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">Paketerzeugung mit Tools
<p>
Verwenden Sie <prgn>dh_make</prgn> aus dem <package>dh-make</package> Paket,
um eine solide Grundlage für ein Paket zu gewinnen. Folgen Sie danach den
Anweisungen in <manref name="dh-make" section="1">. Dies nutzt
<prgn>debhelper</prgn> in <prgn>debian/rules</prgn>.
<p>
Ein älterer Zugang ist das Verwenden von <prgn>deb-make</prgn> aus dem
<package>debmake</package> Paket. Dies nutzt keine <prgn>debhelper</prgn>
Skripte und hängt nur von der Shell ab.
<p>
Für Beispiele von Paketen mit mehreren Quelldateien vergleichen Sie mit "mc"
(<tt>dpkg-source -x mc_4.5.54.dsc</tt>), das "sys-build.mk" von Adam Heath
(<email>doogie@debian.org</email>) nutzt und "glibc" (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>), das ein anderes System von Joel Klecker
(<email>espy@debian.org</email>) nutzt.

</sect>

</chapt>
