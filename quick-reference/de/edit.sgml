<!-- CVS revision of this document "$Revision: 1.1 $"  -->
<!--Line width ruler (ruler uses 78 characters) 34567890123456789012345-->

<chapt id="edit">Editors

<sect id="pop-editor">Popular editors
<p>
Linux offers many alternatives for console text editors. Among them:
<list compact>
<item><prgn>vim</prgn>:    Powerful and light BSD-heritage editor. VI iMproved.
<item><prgn>emacs</prgn>:  Ultimate and heavy GNU-heritage editor. 
 RMS (Richard M. Stallman) original.
<item><prgn>xemacs</prgn>: Emacs: The Next Generation, originally from Lucid.
<item><prgn>mcedit</prgn>: Newbie GNU editor. 
  Identical to <prgn>mc</prgn> internal editor.
<item><prgn>ae</prgn>:     Default small editor (Potato). Avoid this.
<item><prgn>nano</prgn>:   Default small GNU editor (Woody). Emulates
  <prgn>pico</prgn>. 
<item><prgn>joe</prgn>:    For WordStar or TurboPascal old-timers.
<item><prgn>jed</prgn>:    Fast, full-featured menu-driven editor with Emacs key bindings.
<item><prgn>jove</prgn>:   Very small editor with Emacs key bindings.
<item><prgn>nvi</prgn>:    New vi.  Bug-for-bug compatible with
  the original vi.
</list>
<p>
Use <tt>update-alternatives --config editor</tt> to change the default editor.
<p>
Also a few X-based text editors are noteworthy:
<list compact>
<item><prgn>gvim</prgn>: Vim with GUI (<package>vim-gtk</package> package)
<item><prgn>emacs</prgn>:  The One True Emacs (auto-detect X). 
<item><prgn>xemacs</prgn>:  Next generation Emacs (auto detect X). 
</list>
These xclient commands take standard options such as 
<tt>-fn <var>a24</var></tt>, which makes life easy for older folks 
like me :)  See <ref id="xclnt">.
</sect>

<sect id="bin-editor">Rescue editors
<p>
There are a few editors which reside in <file>/bin</file>.  One of these should 
be installed to ease editing files when <file>/usr</file> is not accessible.
<p>
<list compact>
<item><package>elvis-tiny</package>: Minimum vi editor (<prgn>vi</prgn> to start)
<item><package>nano-tiny</package>:  Minimum non-vi editor (<prgn>nano-tiny</prgn> to start)
<item><package>ed</package>:         Minimum editor (always there but tough to use)
</list>
<p>

<sect>Emacs and Vim

<sect1>Vim hints
<p>
Read the "VIM - main help file" document by pressing &lt;F1&gt; while running
the program.

<example>
&lt;F1&gt;           Help
&lt;esc&gt;          Back to normal mode
V              Visual mode
i              Insert mode
:              Command-line commands
:set tw=72     Set text width to 72
&lt;F11&gt;          Insert (paste) mode
:r! date -R    Insert RFC-822 date
q<var>a</var>             Record keystrokes into register <var>a</var>
@<var>a</var>             Execute keystrokes from register <var>a</var>
:edit <var>foo.txt</var>  Edit another file by loading <var>foo.txt</var>
:wnext         Write current file and edit next file
</example>

<tt>q</tt> and <tt>@</tt> can be used for simple macro recording and playback.
For instance, to create a macro to that inserts HTML italics tags around the
word at the cursor, you could enter <tt>qii&lt;i&gt;^[ea&lt;/i&gt;^[q</tt>
(where <tt>^[</tt> is the ESC key). Then typing <tt>@i</tt> at the start of a
word would add the tags &lt;i&gt; and &lt;/i&gt;.

</sect1>

<sect1>Emacs hints
<p>
<example>
&lt;F1&gt;                Help
&lt;F10&gt;               Menu
C-u M-! date -R     Insert RFC-822 date
</example>
</sect1>

<sect1>Starting the editor
<p>
<example>
start editor:                   emacs filename  vim filename
start in vi compatible:                         vim -C
start in vi non-compatible:                     vim -N
start with compile default:     emacs -q        vim -N -u NONE
</example>
</sect1>

<sect1 id="editkey">Editor command summary (Emacs, Vim)
<p>
<example>
exit:                           C-x C-c         :qa /:wq /:xa /:q!
Get back/command mode:          C-g             &lt;esc&gt;
Backward(left):                 C-b             h
Forward(right):                 C-f             l
Next(down):                     C-n             j
Previous(up):                   C-p             k
stArt of line(^):               C-a             0
End of line($):                 C-e             $
mUltiple commands:              C-u nnn cmd     :count cmd
Multiple commands:              M-digitkey cmd
save File:                      C-x C-f         :w file
beginning of buffer:            M-&lt;             1G
end of buffer:                  M-&gt;             G
scroll forward 1 screen:        C-v             ^F
scroll forward 1/2 screen:                      ^D
scroll forward 1 line:                          ^E
scroll backward 1 screen:       M-v             ^B
scroll backward 1/2 screen:                     ^U
scroll backward 1 line:                         ^Y
scroll the other window:        M-C-v
delete under cursor:            C-d             x
delete from cursor to eol:      C-k             D
iSearch forward:                C-s
isearch Reverse:                C-r
Search forward:                 C-s enter       /
search Reverse:                 C-r enter       ?
isearch regexp:                 M-C-s
isearch backward regexp:        M-x isearch-backward-regexp
search regexp:                  M-C-s enter     /
search backward regexp:         M-x isearch-backward-regexp enter
                                                ?
Help:                           C-h C-h         :help
Help Apropos:                   C-h a
Help key Bindings:              C-h b           :help [key]
Help Info:                      C-h i
Help Major mode:                C-h m
Help tutorial:                  C-h t           :help howto
Undo:                           C-_             u
Redo:                           C-f             ^R
Mark cursor position:           C-@             m{a-zA-Z}
eXchange Mark and position:     C-x C-x
goto mark in current file:                      '{a-z}
goto mark in any file:                          '{A-Z}
copy region:                    M-w             {visual}y
kill region:                    C-w             {visual}d
Yank and keep buffer:           C-y             <![%FIXME;[p y ? XXX FIXME XXX]]>
Yank from kill buffer:          M-y             p
convert region to Upper:        C-x C-u         {visual}U
convert region to Lower:        C-x C-l         {visual}u
Insert special char:            C-q octalnum/keystroke  
                                                ^V decimal/keystroke
replace:                        M-x replace-string      :&percnt;s/aaa/bbb/g
replace regexp:                 M-x replace-regexp      :&percnt;s/aaa/bbb/g
query replace:                  M-&percnt;                     :&percnt;s/aaa/bbb/gc
query replace:                  M-x query-replace
query replace regexp:           M-x query-replace-regexp
Open file:                      C-x C-f         :r file
Save file:                      C-x C-s         :w
Save all buffers:               C-x s           :wa
Save as:                        C-x C-w file    :w file
Prompt for buffer:              C-x b
List buffers:                   C-x C-b         :buffers
Toggle read-only:               C-x C-q         :set ro
Prompt and kill buffer:         C-x k
Split vertical:                 C-x 2           :split
Split horizontal:               C-x 3           :vsplit (ver. 6)
Move to other window:           C-x o           ^Wp
Delete this window:             C-x 0           :q
Delete other window(s):         C-x 1           ^Wo
run shell in bg:                M-x compile
kill shell run in bg:           M-x kill-compilation
run make                                        :make Makefile
check error message:            C-x`            :echo errmsg
run shell and record:           M-x shell       :!script -a tmp
...clean BS, ...                                :!col -b &lt;tmp &gt;record
...save/recall shell record:    C-x C-w record  :r record
run shell:                      M-! sh          :sh
run command:                    M-! cmd         :!cmd
run command and insert:         C-u M-! cmd     :r!cmd
run filter:                     M-| file        {visual}:w file
run filter and insert:          C-u M-| filter  {visual}:!filter
show option                                     :se[t] {option}?
reset option to default                         :se[t] {option}&
reset boolean option                            :se[t] no{option}
toggle boolean option                           :se[t] inv{option}
wrap text at column 72                          :se tw=72
do not wrap                                     :se tw=0
autoindent                                      :se ai
expand tab                                      :se et
specify comment (mail)                          :se comments=n:&gt;,n:\|

run GDB                         M-x gdb                        
describe GDB mode               C-h m                          
step one line                   M-s
next line                       M-n
step one instruction (stepi)    M-i                            
finish current stack frame      C-c C-f                        
continue                        M-c                            
up arg frames                   M-u                            
down arg frames                 M-d                            
copy number from point, insert at the end 
                                C-x &                          
set break point                 C-x SPC                        
</example>
</sect1>

<sect1>Vim configuration
<p>
In order to use all Vim features and syntax highlighting, include the
following lines in <file>~/.vimrc</file> or <file>/etc/vimrc</file>:
<example>
set nocompatible
set nopaste
set pastetoggle=&lt;f11&gt;
syn on
</example>
Paste mode enables one to avoid autoindent interfering with cut-and-paste 
operations on a console terminal. It does more than just a simple ":set noai".
<p>
See <ref id="vimgpg"> for GnuPG integration.
</sect1>

<sect1>Ctags
<p>
<tt>apt-get install exuberant-ctags</tt> and run ctags on the source files. Type 
<tt>:tag <var>function_name</var></tt> in Vim to jump to the line where
<var>function_name</var> starts.
The tags work for C, C++, Java, Python, and many other languages.
<p>
Emacs has the same ctags capabilities.
</sect1>

<sect1>Convert a syntax-highlighted screen to HTML source
<p>
<tt>so \$VIMRUNTIME/syntax/2html.vim</tt> from Vim command mode will convert
highlighted text to HTML text.  Save with <tt>:w file.html</tt> and
<tt>:q</tt>.  Useful for C code, etc.
</sect1>

<sect1>Split screen with <prgn>vim</prgn>
<p>
<prgn>vim</prgn> can edit multiple files in a multi-split-screen environment.
Type <tt>:help usr_08.txt</tt> for details.
<p>
To split the screen display between different files, type at the vi command prompt:
<example>
:split <var>another-file</var>
:vsplit <var>another-file</var>
</example>
Or at a shell prompt:
<example>
$ vi -o file1.txt file2.txt   # Horizontal split
$ vi -O file1.txt file2.txt   # Vertical split
</example>
will provide multi-window vi.
<example>
$ vimdiff file.txt~ file.txt         # check recent changes of file.txt
$ vimdiff file.en.sgml file.fr.sgml  # check changes of translation
$ gvimdiff file.txt~ file.txt        # in X
</example>
will provide a nice view of differences between an original and a backup file.
In SGML it matches tags, so comparing translations in this mode works very
well.
<p>
Special cursor movements with CTRL-W commands:
<example>
CTRL-W +      increase the size of a window
CTRL-W -      decrease the size of a window
CTRL-W h      move to the window left
CTRL-W j      move to the window below
CTRL-W k      move to the window above
CTRL-W l      move to the window right
...
</example>
Use the following to control screen scrolling:
<example>
:set scrollbind
:set noscrollbind
</example>
</sect1>

</sect>

</chapt>
