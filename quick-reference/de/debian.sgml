<!-- CVS revision of this document "$Revision: 1.9 $"  -->
<!-- CVS revision of original english document "1.55"  -->

<!--Line width ruler (ruler uses 78 characters) 34567890123456789012345-->

<chapt id="package">Debian Paket Management

<p>
Stellen Sie sicher, dass Sie einen lokalen HTTP Proxy benutzen 
(<prgn>squid</prgn>) wenn Sie Pakete
mit APT herunterladen. Ein Proxy erhöht die Performanz im Netzwerk insbesondere
dann, wenn viele Debian Rechner im LAN vorhanden sind. Dieses Kapitel bezieht
sich auf ein Woody System, jedoch sollten die Informationen hier auch auf ein
Potato System (mit Ausnahme von <manref name="apt_preferences" section="5">
und Themen die Bezug auf die <file>/etc/preferences</file> Datei nehmen).

<sect id="pkg-intro">Einführung
<p>
Wenn dass Lesen der Entwickler Dokumentation zu viel für Sie ist, dann lesen
Sie zuerst dieses Kapitel um dann die ganze Vielfalt von Debian
(<tt>testing</tt>/<tt>unstable</tt>) zu nutzen :-).

<sect1>Grundlegende Tools
<p>
<example>
dselect   &mdash; menü gesteuertes Paket Management Tool (top level)
dpkg      &mdash; installiert Pakete (Zentrale Paket-Dateien)
apt-get   &mdash; installiert Pakete (Zentrales Paket-Archiv, CLI APT)
tasksel   &mdash; installiert Aufgaben-Profile (Verbund von Paketen)
aptitude  &mdash; installiert Pakete (Pakete &amp; Verbund von Paketen, ncurses APT)
deity     &mdash; alternatives ncurses APT
synaptic, gsynaptic &mdash; GUI APT Alternativen
</example>
Diese Tools arbeiten nicht alle auf dem gleichen Level. <prgn>dselect</prgn>
arbeitet ein Level über APT (der Kommandozeilen Befehl ist
<prgn>apt-get</prgn>) und <prgn>dpkg</prgn>.
<p>
Um alle verfügbaren Pakete zu erfassen, nutzt APT
<file>/var/lib/apt/lists/*</file>, <prgn>dpkg</prgn> jedoch nutzt
<file>/var/lib/dpkg/available</file>. Wenn Sie Pakete direkt mit
<prgn>apt-get</prgn> oder mit einem änlichen Programm, wie z.B.
<prgn>aptitude</prgn> installiert haben, dann stellen Sie sicher, dass Sie
die Datei <file>/var/lib/dpkg/available</file> mittels <tt>[U]pdate</tt>
aus dem <prgn>dselect</prgn> Menü oder von der Kommandozeile "<tt>dselect
update</tt>" updaten, bevor Sie <tt>dselect select</tt>, <tt>tasksel</tt> oder
<tt>dpkg -l</tt> ausführen.
<p>
Was die Paket-Abhängikeiten angeht, so berücksichtigt <prgn>apt-get</prgn>
Pakete mit gesetztem <strong>depends</strong>, ignoriert aber Pakete mit
gesetztem <strong>recommends</strong> und <strong>suggests</strong>.
<prgn>dselect</prgn> bietet jedoch eine feinere Kontrolle über die Auswahl von
solchen Paketen und installiert Pakete mit gesetztem <strong>depends</strong>
und <strong>recommends</strong> per Default.
<![%f-ref;[
Siehe <ref id="depends">.
]]>
</sect1>

<sect1> Nützliche Tools
<p>
<example>
apt-cache         - durchsucht den lokalen Pakete Cache
dpkg-reconfigure  - erneutes konfigurieren von bereits installierten Paketen
(sofern sie denn debconf benutzten)
dpkg-source       - packt und entpackt Debian Quell-Archive
dpkg-buildpackage - automatisiert den Prozess der Erstellung von Paketdateien
...
</example>
</sect1>
</sect>

<sect id="survival">Debian überlebens Befehle
<p>
Mit diesem Wissen kann jeder ein Leben des <strong>ewigen</strong> "Upgrades"
leben :-)
<p>
<![%f-ref;[
Siehe auch
<ref id="install">, <ref id="woody"> und <ref id="bin-editor">.
]]>

<sect1 id="tasksel"><var>Aufgaben-Profile</var> mit <prgn>tasksel</prgn>
installieren
<p>
<prgn>tasksel</prgn> ist das <strong>Debian Aufgaben-Profil Installations
Programm</strong>, das auch wärend der Debian Installation als
<tt>einfache</tt> Option angeboten wird.
<p>
Wenn eine Verbund von Paketen z.B. C/C++ Entwicklungs Werkzeuge benötigt
werden, ist der einfachste Weg <prgn>tasksel</prgn> zu verwenden. Stellen Sie
sicher, dass sie folgende Befehle verwenden:
<example>
# dselect update
# tasksel
</example>
</sect1>

<sect1 id="apt-install">Pakete mit APT installieren
<p>
Man kann selektiv Pakete von unterschiedlichen Archiven, unter Verwendung von
neueren Versionen von <prgn>apt-get</prgn> (&gt;Woody) installieren, indem
man zusätzliche Quellen für <tt>unstable</tt> und <tt>testing</tt> der
<file>/etc/apt/sources.list</file> Datei hinzufügt. Dies ermöglichts es einem,
wärend man <tt>stable</tt> weiterhin als haupt Distribution beibehält,
selektive upgrades auf <tt>unstable</tt> und selektive downgrades auf
<tt>stable</tt> zu machen.
<p>
Um selektive upgrades zu machen, wärend man die <tt>testing</tt> Distribution
installiert hat, ist der Datei <file>/etc/apt/preferences</file>, folgendes
hinzu zu fügen:
<example>
Package: *
Pin: release a=stable
Pin-Priority: 500

Package: *
Pin: release a=testing
Pin-Priority: 600

Package: *
Pin: release a=unstable
Pin-Priority: 50
</example>
Der gleiche Effekt lässt sich auch folgendermaßen erzielen:
<example>
# echo 'APT::Default-Release "testing";' &gt;&gt; /etc/apt/apt.conf
</example>

Mit den oben genannten zusätzlichen Einträgen in der Datei
<file>/etc/apt/sources.list</file>, lassen sich folgendermaßen Pakete aus den
einzelen Debian Distributionen installieren:
<list>
<item><tt>apt-get upgrade</tt>
 <p>aktualisiert nur Pakete aus dem Default-Release (testing).
<item><tt>apt-get install <var>Paket</var></tt>
 <p> installiert <var>Paket</var> und dessen Abhängigkeiten aus der
 <tt>testing</tt> Distribution.
<item><tt>apt-get install <var>Paket</var>/unstable</tt>
 <p>installiert <var>Paket</var> aus der <tt>unstable</tt> Distribution,
 wärend dessen Abhängigkeiten aus der <tt>testing</tt> Distribution
 installiert werden.
<item><tt>apt-get install -t unstable <var>Paket</var></tt>
 <p> installiert <var>Paket</var> aus der <tt>unstable</tt> Distribution,
 und dessen Abhängigkeiten ebenfalls aus der <tt>unstable</tt> Distribution.
</list>
<p>
Wenn Sie als Ihr Basis-System die <tt>stable</tt> Distribution verwenden
möchten, dann decrementieren Sie die Pin-Priority von <tt>testing</tt> zu 60
in <file>/etc/apt/preferences</file> für das obige Beispiel. Alternativ können
Sie auch folgenden Befehl ausführen:
<example>
# echo 'APT::Default-Release "stable";' &gt;&gt; /etc/apt/apt.conf
</example>
<p>
Andere Befehle sind:
<example>
# apt-cache policy libc6 libc6-dev locales         # check status
# apt-get install libc6=2.2.4-1 libc6-dev=2.2.4-1 locales=2.2.4-1
# apt-get -u install interesting-new-package remove-package-
# apt-get remove useless-old-package
# apt-get remove --purge really-useless-old-package
</example>
<p>
Um alle Pakete auf die <tt>stable</tt> Distribution zurückzustufen,
editieren sie die Datei <file>/etc/apt/preferences</file> wie folgt: 
<example>
Package: *
Pin: release a=stable
Pin-Priority: 1001
</example>
und führen Sie "<tt>apt-get upgrade</tt>" aus. Dieser Befehl stuft
aufgrund der Pin-Priority &gt; 1000 sämtliche Pakete herunter. Aber seien
Sie gewarnt, es könnte abhänigkeits Probleme geben.
</sect1>

<sect1 id="apt-upgrade">Mittels APT das System upgraden
<p>
Um ein System Upgrade mit APT durchzuführen:
<example>
# apt-get update
... und dann einer der folgenden Befehle:
# apt-get -u upgrade         # pull all depends
# apt-get -u dist-upgrade    # pull all depends and resolve dependency
# apt-get -u dselect-upgrade # follow selections set by dselect
</example>
Möchte man, dass die <tt>-u</tt> Option per Default gelten soll:
<example>
$ cat &gt;&gt; /etc/apt/apt.conf &lt;&lt; .
// Zeige immer die Pakete an, du zum Upgrade gewählt wurden (-u)
APT::Get::Show-Upgraded "true";
.
</example>
<p>
Die <tt>-s</tt> Option kann genutzt werden, um ein Upgrade zu simulieren, ohne
tatsächlich ein Upgrade durchzuführen.
<p>
<prgn>dselect</prgn> Menügesteuerte Schnittstelle zu APT.
<prgn>deity</prgn> und <prgn>aptitude</prgn> sind wiederum Alternativen zu
<prgn>dselect</prgn>.
</sect1>

<sect1 id="bug-check">Überprüfe Bugs in Debian und ersuche Hilfe
<p>
Wenn Sie auf Probleme bezüglich eines bestimmten Paktes stoßen, stellen Sie
sicher, dass sie zuerst diese Seiten konsolidieren, bevor Sie um Hilfe fragen
oder einen Bug Report erstellen.
(<prgn>lynx</prgn>, <prgn>links</prgn> und <prgn>w3m</prgn> sind hier
gleichwertig):
<example>
$ lynx &bugs;
$ lynx &bugs;<var>package-name</var>  # wenn der Name des Paketes bekannt ist
$ lynx &bugs;<var>bugnumber</var>     # wenn die Bugnummer bekannt ist
</example>
Suchen Sie auch bei Google (www.google.de) mit Suchbegriffen wie
"site:debian.org".
<p>
Wenn Sie nicht weiter kommen, lesen Sie die guten Manuals. Setzen Sie
<tt>CDPATH</tt> wie folgt:
<example>
export CDPATH=.:/usr/local:/usr/share/doc
</example>
und dann
<example>
$ cd <var>Paketname</var>
$ mc 
</example>
<![%f-ref;[
Weitere Hilfequellen sind in <ref id="support"> aufgelistet.
]]>
</sect1>

<sect1 id="apt-trouble">APT upgrade troubleshooting
<p>
Package dependency problems may occur when upgrading in 
<tt>unstable</tt>/<tt>testing</tt>.
Most of the time, this is because a package that will be upgraded has a new
dependency that isn't met.  These problems are fixed by using
<example>
# apt-get dist-upgrade
</example>
If this does not work, then repeat one of the following until the problem
resolves itself:
<example>
# apt-get upgrade -f         # continue upgrade even after error
... or
# apt-get dist-upgrade -f    # continue dist-upgrade even after error
</example>
<p>
Some really broken upgrade scripts may cause persistent trouble.
It is usually better to resolve this type of situation by inspecting the
<file>/var/lib/dpkg/info/packagename.<var>{post-,pre-}{install,removal}</var></file>
scripts of the offending package and then running: 
<example>
# dpkg --configure -a    # configures all partially installed packages
</example>
<p>
If a script complains about a missing configuration file, look in
<file>/etc</file> for
the corresponding configuration file.  If one exists with an extension of
<tt>.new</tt>
(or something similar), change (<prgn>mv</prgn>) it to remove the suffix.
<p>
Package dependency problems may occur when installing in unstable/testing.
There are ways to circumvent dependency.
<example>
# apt-get install -f <var>package</var> # override broken dependencies
</example>
<p>
An alternative method to fix these situations is to use the
<package>equivs</package> package. 
See <file>&f-equivs;</file><![%f-ref;[ and <ref id="equivs">]]>.
</sect1>

<sect1 id="rescue-dpkg">Rescue using <prgn>dpkg</prgn>
<p>
Ad hoc recovery of a crashed <prgn>dselect</prgn> (APT) can be done on a really broken
system by just using <prgn>dpkg</prgn> without APT:
<example>
# cd /var/cache/apt/archives
# dpkg -i libc6* libdb2* perl*
# dpkg -i apt* dpkg* debconf*
# dpkg -i *  # until no error occurs
</example>
If a package is missing, get it from <url id="&mirror-site;" name="mirror sites"> by:
<example>
# mc            # use "FTP link" pointing to Debian FTP server
</example>
As of recently, actual packages on the HTTP/FTP server may not be located
under the classic <file>/dist</file> directory but rather under the new
<file>/pool</file> directory. 
<![%f-ref;[
(See <ref id="pools">.)
]]>
<p>
Then install by:
<example>
# dpkg -i /var/cache/apt/archives/<var>packagefile.deb</var>
</example>
For a broken dependency, fix it or use:
<example>
# dpkg --ignore-depends=<var>package1</var>,... -i <var>packagefile.deb</var>
# dpkg --force-depends -i <var>packagefile.deb</var>
# dpkg --force-depends --purge <var>package</var>
# dpkg --force-confmiss -i <var>packagefile.deb</var> # Install missing conffile
</example>
</sect1>

<sect1 id="rescue-var">Rescue system after erasing <file>/var</file>
<p>
If everything under the <file>/var</file> directory is erased, you can
recover control of the system if you have backup copies of 
<file>/var/lib/dpkg/status</file> by:
<example>
# cd /
# install -d /var/cache/apt/archives
# install -d /var/cache/apt/archives/partial
# install -d /var/lib/dpkg/
# cp <var>status-old</var> /var/lib/dpkg/status
# apt-cache gencaches
</example>
Look for the old <file>/var/lib/dpkg/status</file> file
at <file>/var/lib/dpkg/status-old</file> or 
<file>/var/backups/dpkg.status.*</file>.
<p>
Keeping <file>/var/backups/</file> in a separate partition may be a 
good idea since this directory contains lots of important system data.

<sect1 id="un-bootable">Install a package into an unbootable system
<p>
Boot into Linux using a Debian rescue floppy/CD or an alternative
partition in a multi-boot Linux system.  
Mount the unbootable system on <file>/target</file> and use the chroot install mode of
<prgn>dpkg</prgn>.
<example>
# dpkg --root /target -i <var>packagefile.deb</var>
</example>
Then configure and fix problems.
<p>
By the way, if a broken <prgn>lilo</prgn> is all that prevents booting, you can boot using 
a standard Debian rescue disk. At boot prompt, assuming the root partition of 
your Linux installation is in <file>/dev/hda12</file> and you want runlevel 3, enter:
<example>
boot: rescue root=/dev/<var>hda12</var> 3
</example>
Then you are booted into an almost fully functional system with the kernel on
floppy disk. (There may be minor glitches due to lack of kernel features or modules.) 
</sect1>

<sect1>What to do if the <prgn>dpkg</prgn> command is broken
<p>
A broken <prgn>dpkg</prgn> may make it impossible to install any <tt>.deb</tt>
files.  A procedure like the following will help you recover from this
situation. (In the first line, you can replace "links" with your favorite
browser command.)
<example>
$ links http://<var>http.us.debian.org</var>/debian/pool/main/d/dpkg/
  ... download the good dpkg_<var>version</var>_<var>arch</var>.deb
$ ar x dpkg_<var>version</var>_<var>arch</var>.deb
$ su
password: *****
# mv data.tar.gz /data.tar.gz
# cd /
# tar xzfv data.tar.gz
</example>
For <tt>i386</tt>, <tt>http://packages.debian.org/dpkg</tt> may 
also be used as the URL.
</sect1>

</sect>

<sect id="debian-package">Debian nirvana commands
<p>
<strong>Enlightenment</strong> with these commands will save a person from the eternal
karmic struggle of upgrade hell and let him reach Debian <strong>nirvana</strong>. :-)

<sect1 id="info-file">Information on a file
<p>
To find the package to which a particular file belongs:
<example>
$ dpkg {-S|--search} pattern # search for pattern in installed packages
$ zgrep -e pattern <var>/local/copy/of/debian/woody/Contents-i386.gz</var>
             # find filename-pattern of files in the debian archive
</example>
Or use specialized package commands:
<example>
# apt-get install dlocate  
                 # conflicts with slocate (secure version of locate)
$ dlocate <var>filename</var>         # fast alternative to dpkg -L and dpkg -S
...
# apt-get install auto-apt # on-demand package installation tool
# auto-apt update          # create db file for auto-apt
$ auto-apt search <var>pattern</var>  
                # search for pattern in all packages, installed or not
</example>
</sect1>

<sect1 id="info-package">Information on a package
<p>
Search and display information from package archives.  Make sure to
point APT to the proper archive(s) by editing
<file>/etc/apt/sources.list</file>.
If you want to see how packages in testing/unstable do against the currently 
installed one, use <tt>apt-cache policy</tt>&mdash;quite nice.
<example>
# apt-get   check           # update cache and check for broken packages
$ apt-cache search  <var>pattern</var> # search package from text description
$ apt-cache policy  <var>package</var> # package priority/dists information
$ apt-cache show -a <var>package</var> # show description of package in all dists
$ apt-cache showsrc <var>package</var> # show description of matching source package
$ apt-cache showpkg <var>package</var> # package information for debugging
# dpkg  --audit|-C          # search for partially installed packages
$ dpkg {-s|--status} <var>package</var> ... # description of installed package
$ dpkg -l <var>package</var> ...       # status of installed package (1 line each)
$ dpkg -L <var>package</var> ...       # list file names installed by the package
</example>
<!-- Erase this when manual page gets fixed.  FIXME -->
<tt>apt-cache showsrc</tt> is not documented as of the Woody release but
works :) 
<p>
You can also find package information in (I use <tt>mc</tt> to browse these):
<example>
/var/lib/apt/lists/*
/var/lib/dpkg/available
</example>
The comparison of the following files provides information on what 
exactly has happened in the last few install sessions.
<example>
/var/lib/dpkg/status
/var/backups/dpkg.status*
</example>

</sect1>

<sect1 id="apt-get-auto">Unattended installation with APT
<p>
For a unattended installation, add following line in 
<file>/etc/apt/apt.conf</file>:
<example>
Dpkg::Options {"--force-confold";}
</example>
This is an equivalent of running <tt>apt-get -q -y <var>packagename</var></tt>.
This may have serious negative implication.  So use this trick with care. 
See <manref name="apt.conf" section="5"> and <manref name="dpkg" section="1">.
<p>
You can configure any particular packages later by following 
<ref id="reconfigure">.

<sect1 id="reconfigure">Reconfigure installed packages
<p>
Use the following to reconfigure any already-installed package.
<example>
# dpkg-reconfigure --priority=<var>medium</var> <var>package</var> [...]
# dpkg-reconfigure --all   # reconfigure all packages
# dpkg-reconfigure locales # generate any extra locales
# dpkg-reconfigure --p=<var>low</var> xserver-xfree86 # reconfigure X server
</example>
Do this for <prgn>debconf</prgn> if you need to change the
<prgn>debconf</prgn> dialog mode permanently.
<p>
Some programs come with special configuration scripts.
<example>
apt-setup     - create /etc/sources.list
install-mbr   - install a Master Boot Record manager
tzconfig      - set the local timezone
gpmconfig     - set gpm mouse daemon
sambaconfig   - configure Samba in Potato (Woody uses debconf)
eximconfig    - configure Exim (MTA)
texconfig     - configure teTeX
apacheconfig  - configure Apache (httpd)
cvsconfig     - configure CVS
sndconfig     - configure sound system
...
update-alternatives - set default command, e.g., vim as vi
update-rc.d         - System-V init script management
update-menus        - Debian menu system
...
</example>
</sect1>

<sect1 id="remove">Remove and purge packages
<p>
Remove a package while maintaining its configuration:
<example>
# apt-get remove <var>package</var> ...
# dpkg  --remove <var>package</var> ...
</example>
Remove a package and all configuration:
<example>
# apt-get remove --purge <var>package</var> ...
# dpkg    --purge        <var>package</var> ...
</example>
</sect1>

<sect1 id="hold">Holding older packages
<p>
For example, holding of <package>libc6</package> and
<package>libc6-dev</package> for <prgn>dselect</prgn> and 
<tt>apt-get -u upgrade <var>package</var></tt> can be done as follows:
<example>
# echo -e "libc6 hold\nlibc6-dev hold" | dpkg --set-selections
</example>
<tt>apt-get -u install <var>package</var></tt> will not be hindered by this "hold".  To
hold a package through forcing automatic downgrade for <tt>apt-get -u upgrade
<var>package</var></tt> or <tt>apt-get -u dist-upgrade</tt>, add the following to
<file>/etc/apt/preferences</file>:
<example>
Package: libc6
Pin: release a=stable
Pin-Priority: 2000
</example>
Here the "<tt>Package:</tt>" entry cannot use entries such as "<tt>libc6*</tt>".  
If you need to keep all binary packages related to the <package>glibc</package> 
source package in a synchronized version, you need to list them explicitly.
<p>
The following will list packages on hold:
<example>
dpkg --get-selections "*"|grep -e "hold$"
</example>
</sect1>

<sect1 id="mixedsys">Mixed stable/testing/unstable system
<p>
<prgn>apt-show-versions</prgn> can lists available package 
versions with distribution.
<example>
$ apt-show-versions | fgrep /testing | wc
... how many packages you have from testing
$ apt-show-versions -u
... list of upgradeable packages
$ apt-get install `apt-show-versions -u -b | fgrep /unstable`
... upgrade all unstable packages to their newest versions
</example>
</sect1>

<sect1 id="dselect"><prgn>dselect</prgn> &ndash; global configuration
<p>
Add a line containing the option "expert" in
<file>/etc/dpkg/dselect.cfg</file> to reduce noise.
<p>
When started, <prgn>dselect</prgn> automatically selects all "Required",
"Important", and "Standard" packages.  In the Potato system, some large
programs such as teTeX and Emacs used to belong here and were best skipped for
the initial install by manually unselecting them (by typing `_').  In Woody,
these have moved to the "Optional" package category.
<p>
<prgn>dselect</prgn> has a somewhat strange user interface. There are 4 ambiguous commands
(Capital means CAPITAL!):
<example>
Key-stroke  Action
Q           Quit. Confirm current selection and quit anyway. 
            (override dependencies)
R           Revert! I did not mean it.
D           Damn it! I do not care what dselect thinks.  Just Do it!
U           Set all to sUggested state
</example>
With <tt>D</tt> and <tt>Q</tt>, you can select conflicting selections at your own risk.
Handle these commands with care.  For a slower machine, run
<prgn>dselect</prgn> on another
fast machine to find packages and use <tt>apt-get install</tt> to install them.
<tt>apt-get dselect-upgrade</tt> best honors <prgn>dselect</prgn> selections.
</sect1>

<sect1 id="cache">Prune cached package files
<p>
Package installation with APT leaves cached package files in
<file>/var/cache/apt/archives</file> and these need to be cleaned.
<example>
# apt-get autoclean # removes only useless package files
# apt-get clean     # removes all cached package files
</example>
</sect1>


<sect1 id="record">Record/copy system configuration
<p>
To make a local copy of the package selection states:
<example>
$ dpkg --get-selections "*" &gt;<var>myselections</var>   # or use \*
</example>
<tt>"*"</tt> makes <tt><var>myselections</var></tt> include package entries for "purge" too.
<p>
You can transfer this file to another computer, and install it there with:
<example>
# dselect update
# dpkg --set-selections &lt;<var>myselections</var>
# apt-get -u dselect-upgrade    # <var>or</var> dselect install
</example>
</sect1>

<sect1 id="port">Port a package to the <tt>stable</tt> system
<p>
For partial upgrades of the stable system, rebuilding a package within its
environment using the source package is desirable.  This avoids massive
package upgrades due to their dependencies.  First, add the following entries
to <file>/etc/apt/sources.list</file>:
<example>
deb-src &http-us;debian testing \
 main contrib non-free
deb-src &http-non-us;debian-non-US testing/non-US \
 main contrib non-free
deb-src &http-us;debian unstable \
 main contrib non-free
deb-src &http-non-us;debian-non-US unstable/non-US \
 main contrib non-free
</example>
Here each entry for <tt>deb-src</tt> is broken into 2 lines because of
printing constraints, but the actual entry in <file>sources.list</file> should
consist of a single line.
<p>
Then get the source and make a local package:
<example>
$ apt-get source <var>package</var>
$ dpkg-source -x <var>package.dsc</var>
$ cd <var>package-version</var>
  ... inspect required packages (Build-depends in .dsc file) and
      install them too.  You need the "fakeroot" package also.

$ dpkg-buildpackage -rfakeroot 

  ...or (no sig)
$ dpkg-buildpackage -rfakeroot -us -uc # use "debsign" later if needed

  ...Then to install
$ su -c "dpkg -i <var>packagefile.deb</var>"
</example>
Usually, one needs to install a few packages with the "-dev" suffix to satisfy
package dependencies. <prgn>debsign</prgn> is in the
<package>devscripts</package> package.  <prgn>auto-apt</prgn> may
ease satisfying these dependencies. Use of <prgn>fakeroot</prgn>
avoids unnecessary use of the root account.
<p>
In Woody, these dependency issues can be simplified.  
For example, to compile a source-only <package>pine</package> package:
<example>
# apt-get build-dep pine
# apt-get source -b pine
</example>
</sect1>

<sect1 id="local">Local package archive
<p>
In order to create a local package archive which is compatible with
APT and the dselect system, <file>Packages</file> needs to be created
and package files needs to be populated in a particular directory tree.
<p>
Debian official archive like local deb repository can be made:
<example>
# apt-get install dpkg-dev
# cd <var>/usr/local</var>
# install -d <var>pool</var> # physical packages are located here
# install -d dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>
# ls -1 <var>pool</var> | sed 's/_.*$/ extra <var>BOGUS</var>/' | uniq &gt; <var>override</var>
# editor <var>override</var> # adjust <var>BOGUS</var>
# dpkg-scanpackages <var>pool</var> <var>override</var> <var>/usr/local</var>/ \
   &gt; dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>/Packages
# cat &gt; dists/<var>unstable</var>/<var>main</var>/Release &lt;&lt; EOF
Archive: <var>unstable</var>
Version: <var>3.0</var>
Component: <var>main</var>
Origin: <var>Local</var>
Label: <var>Local</var>
Architecture: <var>i386</var>
EOF
# echo "deb file:<var>/usr/local</var> <var>unstable</var> <var>main</var>" \
   &gt;&gt; /etc/apt/sources.list
</example>
<p>
Alternatively, quick-n-dirty local deb repository can be made:
<example>
# apt-get install dpkg-dev
# mkdir <var>/usr/local/debian</var>
# mv <var>/some/where/package.deb</var> <var>/usr/local/debian</var>
# dpkg-scanpackages <var>/usr/local/debian</var> /dev/null | \
  gzip - &gt; <var>/usr/local/debian</var>/Packages.gz
#  echo "deb file:<var>/usr/local/debian</var> ./" &gt;&gt; /etc/apt/sources.list
</example>
<p>
These archives can be remotely accessed by providing access to these 
directories through either HTTP or FTP methods and changing entries in
<file>/etc/apt/sources.list</file> accordingly.

<sect1 id="alien">Convert or install an alien binary package
<p>
<package>alien</package> enables the conversion of binary packages provided in 
Redhat <tt>rpm</tt>, Stampede <tt>slp</tt>, Slackware <tt>tgz</tt>, and
Solaris <tt>pkg</tt> file formats
into a &debian; <tt>deb</tt> package. If you want to use a package from another
Linux distribution than the one you have installed on your
system, you can use <prgn>alien</prgn> to convert it to your preferred
package format and install it. <package>alien</package> also supports LSB packages.
</sect1>						 

<sect1 id="debsums">Verify installed package files
<p>
<prgn>debsums</prgn> enables verification of installed package files against
MD5 checksums.  Some packages do not have available MD5 checksums.  A possible
temporary fix for sysadmins:
<example>
# cat >>/etc/apt/apt.conf.d/90debsums
DPkg::Post-Install-Pkgs {"xargs /usr/bin/debsums -sg";};
^D
</example>
per Joerg Wendland &lt;joergland@debian.org&gt;  (untested).
</sect>

<sect id="pecuriarities">Other Debian peculiarities

<sect1 id="dpkg-divert">The <prgn>dpkg-divert</prgn> command
<p>
<!-- copied from manual page -->
File <strong>diversions</strong> are a way of forcing <prgn>dpkg</prgn> not to
install a file into its default location, but to a <strong>diverted</strong>
location.  <strong>Diversions</strong> can be used through the &debian;
package scripts to move a file away when it causes a conflict.  System
administrators can also use a diversion to override a package's configuration
file, or whenever some files (which aren't marked as
<strong>conffiles</strong>) need to be preserved by <prgn>dpkg</prgn>, when
installing a newer version of a package which contains those files<![%f-ref;[
(see <ref id="conffile">)]]>.
<example>
# dpkg-divert [--add]  <var>filename</var> # add "diversion"
# dpkg-divert --remove <var>filename</var> # remove "diversion"
</example>
It's usually a good idea not to use <prgn>dpkg-divert</prgn> when it is
not absolutely necessary.
</sect1>

<sect1 id="equivs">The <package>equivs</package> package
<p>
If you compile a program from source, it is best to make it into a real
local debianized package (<tt>*.deb</tt>).  
Use <tt>equivs</tt> as a last resort.
<example>
Package: equivs
Priority: extra
Section: admin
Description: Circumventing Debian package dependencies
 This is a dummy package which can be used to create Debian
 packages, which only contain dependency information.
</example>
</sect1>

<sect1 id="alternatives">Alternative commands
<p>
To make the command <prgn>vi</prgn> run <prgn>vim</prgn>, use
<prgn>update-alternatives</prgn>:
<example>
# update-alternatives --display vi
...
# update-alternatives --config vi
  Selection    Command
-----------------------------------------------
      1        /usr/bin/elvis-tiny
      2        /usr/bin/vim
*+    3        /usr/bin/nvi

Enter to keep the default[*], or type selection number: 2
</example>
Items in the Debian alternatives system are kept in
<file>/etc/alternatives</file> as symlinks.
<p>
To set your favorite X window environment, apply 
<prgn>update-alternatives</prgn> to
<file>/usr/bin/x-session-manager</file> and
<file>/usr/bin/x-window-manager</file>.
<![%f-ref;[
For details, see <ref id="custom-x">.
]]>
<p>
<file>/bin/sh</file> is a direct symlink to <file>/bin/bash</file> or
<file>/bin/dash</file>.  It's safer to
use <file>/bin/bash</file> to be compatible with old Bashism-contaminated scripts but 
better discipline to use <file>/bin/dash</file> to enforce POSIX compliance.
Upgrading to a 2.4 Linux kernel tends to set this to <file>/bin/dash</file>.
</sect1>

<sect1 id="sys-v">System-V <prgn>init</prgn> and runlevels
<p>
The default runlevel to boot into can be set in <file>/etc/inittab</file>.
<p>
Unlike other distributions, Debian makes the management of runlevel completely 
the sysadmin's responsibility.  Management of System-V style <prgn>init</prgn> on Debian is
intended to be performed through <prgn>update-rc.d</prgn> scripts.
<p>
Starting <file>/etc/init.d/<var>name</var></file> in runlevel 1,2,3 and stopping in
4,5 with sequencing priority number 20 (normal) can be done by:
<example>
# update-rc.d <var>name</var> start 20 1 2 3 . stop 20 4 5 .
</example>
Removing symbolic links while the script in <prgn>init.d</prgn> still exists can be done by:
<example>
# update-rc.d -f <var>name</var> remove
</example>
For editing runlevels, I cheat.  I edit entries manually using the
<prgn>mv</prgn> command at the shell prompt of <prgn>mc</prgn> while copying
link entries using <tt>Alt-Enter</tt>. For example:
<example>
# mv S99xdm K99xdm # disable xdm (X display manager)
</example>
I even disable a daemon by inserting
<tt>exit 0</tt> at the start of an <prgn>init.d</prgn> script as a quick hack.
These are <tt>conffiles</tt> after all.
</sect1>

<sect1 id="disables">Disabled daemon services
<p>
The &debian; distribution takes system security seriously and expects 
the system administrator to be competent.  Thus, sometimes ease of use 
appears to be a secondary concern and many daemon services come with 
the highest security level, with the fewest services (or none) 
available as their default install state.
<p>
Run <tt>ps aux</tt> or check the contents of <file>/etc/init.d/*</file> and
<file>/etc/inetd.conf</file>, if you have any doubts (about Exim, DHCP, ...).  
Also check <file>/etc/hosts.deny</file><![%f-ref;[ as 
in <ref id="loginctrl">]]>.
The <prgn>pidof</prgn> command is also useful (see
<manref name="pidof" section="8">). 
<p>
X11 doesn't allow TCP/IP (remote) connections by default in recent
versions of &debian;.  
<![%f-ref;[
See <ref id="xtcp">.
]]>
X forwarding in SSH is also disabled.  
<![%f-ref;[
See <ref id="xssh">.
]]>
</sect1>
</sect>

</chapt>

