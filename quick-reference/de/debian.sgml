<!-- CVS revision of this document "$Revision: 1.13 $"  -->
<!-- CVS revision of original english document "1.55"  -->

<!--Line width ruler (ruler uses 78 characters) 34567890123456789012345-->

<chapt id="package">Debian Paket Management

<p>
Stellen Sie sicher, dass Sie einen lokalen HTTP Proxy benutzen 
(<prgn>squid</prgn>) wenn Sie Pakete
mit APT herunterladen. Ein Proxy erhöht die Performance im Netzwerk insbesondere
dann, wenn viele Debian Rechner in einem LAN vorhanden sind. Dieses Kapitel bezieht
sich auf ein Woody System, jedoch sollten die Informationen hier auch auf ein
Potato System (mit Ausnahme von <manref name="apt_preferences" section="5">
und Themen die Bezug auf die <file>/etc/apt/preferences</file> Datei nehmen),
zutreffen.

<sect id="pkg-intro">Einführung
<p>
Wenn das Lesen der Entwicklerdokumentation zu viel für Sie ist, dann lesen
Sie zuerst dieses Kapitel um dann die ganze Vielfalt von Debian
(<tt>testing</tt>/<tt>unstable</tt>) zu nutzen :-).

<sect1>Grundlegende Werkzeuge
<p>
<example>
dselect   &mdash; menügesteuertes Paket Management Werkzeug (top level)
dpkg      &mdash; installiert Pakete (Zentrale Paket-Dateien)
apt-get   &mdash; installiert Pakete (Zentrales Paket-Archiv, CLI APT)
tasksel   &mdash; installiert Aufgaben-Profile (Verbund von Paketen)
aptitude  &mdash; installiert Pakete (Pakete &amp; Verbund von Paketen, ncurses APT)
deity     &mdash; alternatives ncurses APT
synaptic, gsynaptic &mdash; GUI APT Alternativen
</example>
Diese Tools arbeiten nicht alle auf dem gleichen Level. <prgn>dselect</prgn>
arbeitet ein Level über APT (der Kommandozeilen Befehl ist
<prgn>apt-get</prgn>) und <prgn>dpkg</prgn>.
<p>
Um alle verfügbaren Pakete zu erfassen, nutzt APT
<file>/var/lib/apt/lists/*</file>, <prgn>dpkg</prgn> jedoch nutzt
<file>/var/lib/dpkg/available</file>. Wenn Sie Pakete direkt mit
<prgn>apt-get</prgn> oder mit einem ähnlichen Programm, wie z.B.
<prgn>aptitude</prgn> installiert haben, dann stellen Sie sicher, dass Sie
die Datei <file>/var/lib/dpkg/available</file> mittels <tt>[U]pdate</tt>
aus dem <prgn>dselect</prgn> Menü oder von der Kommandozeile "<tt>dselect
update</tt>" updaten, bevor Sie <tt>dselect select</tt>, <tt>tasksel</tt> oder
<tt>dpkg -l</tt> ausführen.
<p>
Was die Paket-Abhängigkeiten angeht, so berücksichtigt <prgn>apt-get</prgn>
Pakete mit gesetztem <strong>depends</strong>, ignoriert aber Pakete mit
gesetztem <strong>recommends</strong> und <strong>suggests</strong>.
<prgn>dselect</prgn> bietet jedoch eine feinere Kontrolle über die Auswahl von
solchen Paketen und installiert Pakete mit gesetztem <strong>depends</strong>
und <strong>recommends</strong> per Default.
<![%f-ref;[
Siehe <ref id="depends">.
]]>
</sect1>

<sect1> Nützliche Tools
<p>
<example>
apt-cache         - durchsucht den lokalen Pakete Cache
dpkg-reconfigure  - erneutes konfigurieren von bereits installierten Paketen
(sofern sie denn debconf benutzten)
dpkg-source       - packt und entpackt Debian Quell-Archive
dpkg-buildpackage - automatisiert den Prozess der Erstellung von Paket-Dateien
...
</example>
</sect1>
</sect>

<sect id="survival">Debian Überlebensbefehle
<p>
Mit diesem Wissen kann jeder ein Leben des <strong>ewigen</strong> "Upgrades"
leben :-)
<p>
<![%f-ref;[
Siehe auch
<ref id="install">, <ref id="woody"> und <ref id="bin-editor">.
]]>

<sect1 id="tasksel"><var>Aufgaben-Profile</var> mit <prgn>tasksel</prgn>
installieren
<p>
<prgn>tasksel</prgn> ist das <strong>Debian Aufgaben-Profil Installations
Programm</strong>, das auch während der Debian Installation als
<tt>einfache</tt> Option angeboten wird.
<p>
Wenn eine Verbund von Paketen z.B. C/C++ Entwicklungs Werkzeuge benötigt
werden, ist der einfachste Weg <prgn>tasksel</prgn> zu verwenden. Stellen Sie
sicher, dass sie folgende Befehle verwenden:
<example>
# dselect update
# tasksel
</example>
</sect1>

<sect1 id="apt-install">Pakete mit APT installieren
<p>
Man kann selektiv Pakete von unterschiedlichen Archiven, unter Verwendung von
neueren Versionen von <prgn>apt-get</prgn> (&gt;Woody) installieren, indem
man zusätzliche Quellen für <tt>unstable</tt> und <tt>testing</tt> der
<file>/etc/apt/sources.list</file> Datei hinzufügt. Dies ermöglicht es einem,
während man <tt>stable</tt> weiterhin als Hauptdistribution beibehält,
selektive Upgrades auf <tt>unstable</tt> und selektive Downgrades auf
<tt>stable</tt> zu machen.
<p>
Um selektive Upgrades zu machen, während man die <tt>testing</tt> Distribution
installiert hat, ist der Datei <file>/etc/apt/preferences</file> folgendes
hinzu zu fügen:
<example>
Package: *
Pin: release a=stable
Pin-Priority: 500

Package: *
Pin: release a=testing
Pin-Priority: 600

Package: *
Pin: release a=unstable
Pin-Priority: 50
</example>
Der gleiche Effekt lässt sich auch folgendermaßen erzielen:
<example>
# echo 'APT::Default-Release "testing";' &gt;&gt; /etc/apt/apt.conf
</example>

Mit den oben genannten zusätzlichen Einträgen in der Datei
<file>/etc/apt/sources.list</file>, lassen sich folgendermaßen Pakete aus den
einzelnen Debian Distributionen installieren:
<list>
<item><tt>apt-get upgrade</tt>
 <p>aktualisiert nur Pakete aus dem Default-Release (testing).
<item><tt>apt-get install <var>Paket</var></tt>
 <p> installiert <var>Paket</var> und dessen Abhängigkeiten aus der
 <tt>testing</tt> Distribution.
<item><tt>apt-get install <var>Paket</var>/unstable</tt>
 <p>installiert <var>Paket</var> aus der <tt>unstable</tt> Distribution,
 während dessen Abhängigkeiten aus der <tt>testing</tt> Distribution
 installiert werden.
<item><tt>apt-get install -t unstable <var>Paket</var></tt>
 <p> installiert <var>Paket</var> aus der <tt>unstable</tt> Distribution,
 und dessen Abhängigkeiten ebenfalls aus der <tt>unstable</tt> Distribution.
</list>
<p>
Wenn Sie als Ihr Basis-System die <tt>stable</tt> Distribution verwenden
möchten, dann decrementieren Sie die Pin-Priority von <tt>testing</tt> zu 60
in <file>/etc/apt/preferences</file> für das obige Beispiel. Alternativ können
Sie auch folgenden Befehl ausführen:
<example>
# echo 'APT::Default-Release "stable";' &gt;&gt; /etc/apt/apt.conf
</example>
<p>
Andere Befehle sind:
<example>
# apt-cache policy libc6 libc6-dev locales         # check status
# apt-get install libc6=2.2.4-1 libc6-dev=2.2.4-1 locales=2.2.4-1
# apt-get -u install interesting-new-package remove-package-
# apt-get remove useless-old-package
# apt-get remove --purge really-useless-old-package
</example>
<p>
Um alle Pakete auf die <tt>stable</tt> Distribution zurückzustufen,
editieren sie die Datei <file>/etc/apt/preferences</file> wie folgt: 
<example>
Package: *
Pin: release a=stable
Pin-Priority: 1001
</example>
und führen Sie "<tt>apt-get upgrade</tt>" aus. Dieser Befehl stuft
aufgrund der Pin-Priority &gt; 1000 sämtliche Pakete herunter. Aber seien
Sie gewarnt, es könnte Abhängigkeitsprobleme geben.
</sect1>

<sect1 id="apt-preferences">Overview of <file>/etc/apt/preferences</file>
FIXME: noch aktualisieren

<sect1 id="apt-upgrade">Mittels APT das System aktualisieren
<p>
Um ein Systemupgrade mit APT durchzuführen:
<example>
# apt-get update
... und dann einer der folgenden Befehle:
# apt-get -u upgrade         # aktualisiert das komplette System
# apt-get -u dist-upgrade    # aktualisiert das komplette System und löst
geänderte Abhängigkeiten auf
# apt-get -u dselect-upgrade # berücksichtigt nur Änderungen von deselect
</example>
Möchte man, dass die <tt>-u</tt> Option per Default gelten soll:
<example>
$ cat &gt;&gt; /etc/apt/apt.conf &lt;&lt; .
// Zeige immer die Pakete an, die zum Upgrade gewählt wurden (-u)
APT::Get::Show-Upgraded "true";
.
</example>
<p>
Die <tt>-s</tt> Option kann genutzt werden um ein Upgrade zu simulieren, ohne
tatsächlich ein Upgrade durchzuführen.
<p>
<prgn>dselect</prgn> Menügesteuerte Schnittstelle zu APT.
<prgn>deity</prgn> und <prgn>aptitude</prgn> sind wiederum Alternativen zu
<prgn>dselect</prgn>.
</sect1>

<sect1 id="bug-check">Überprüfe Bugs in Debian und ersuche Hilfe
<p>
Wenn Sie auf Probleme bezüglich eines bestimmten Pakets stoßen, stellen Sie
sicher, dass sie zuerst diese Seiten konsolidieren, bevor Sie um Hilfe fragen
oder einen Bug Report erstellen.
(<prgn>lynx</prgn>, <prgn>links</prgn> und <prgn>w3m</prgn> sind hier
gleichwertig):
<example>
$ lynx &bugs;
$ lynx &bugs;<var>package-name</var>  # wenn der Name des Paketes bekannt ist
$ lynx &bugs;<var>bugnumber</var>     # wenn die Bugnummer bekannt ist
</example>
Suchen Sie auch bei Google (www.google.de) mit Suchbegriffen wie
"site:debian.org".
<p>
Wenn Sie nicht weiter kommen, lesen Sie die guten Manuals. Setzen Sie
<tt>CDPATH</tt> wie folgt:
<example>
export CDPATH=.:/usr/local:/usr/share/doc
</example>
und dann
<example>
$ cd <var>Paketname</var>
$ mc 
</example>
<![%f-ref;[
Weitere Hilfequellen sind in <ref id="support"> aufgelistet.
]]>
</sect1>

<sect1 id="apt-trouble">APT Upgrade Fehlersuche
<p>
Beim Upgrade in einer der zwei Distributionen <tt>unstable</tt> und
<tt>testing</tt> könnte es unter Umständen zu Problemen kommen. Meistens liegt
das daran, dass APT im Begriff ist, ein Paket zu aktualisieren, welches neue
Abhängigkeiten hat, die nicht aufgelöst werden können. Diese Probleme können
unter Verwendung folgender Befehle gelöst werden:
<example>
# apt-get dist-upgrade
</example>
Wenn dies nicht hilft das Problem zu lösen, dann wiederholen Sie folgende
Befehle solange, bis sich das Problem auflöst:
<example>
# apt-get upgrade -f        # selbst bei Fehlern mit Upgrade fortfahren
... oder
# apt-get dist-upgrade -f   # selbst bei Fehlern mit Dist-Upgrade fortfahren
</example>
<p>
Einige sehr fehlerhafte Upgrade-Scripte könnten permanente Schwierigkeiten
bereiten. In solch einer Situation ist es am besten, wenn man sich die
<file>/var/lib/dpkg/info/packagename.<var>{post-,pre-}{install,removal}</var></file>
Scripte der Fehler verursachenden Pakete ansieht und bei Bedarf korrigiert,
und anschließend
<example>
# dpkg --configure -a    # konfiguriert alle nicht vollständig installierten
Pakete
</example>
ausführt.
<p>
Wenn einer der Scripte sich über eine fehlende Konfigurationsdatei beschwert,
dann schauen Sie in <file>/etc</file> nach der entsprechenden Datei. Wenn sie
existiert und die Dateiendung <tt>.new</tt> (oder änlich) hat, entfernen Sie
diese Dateiendung einfach.
<p>

Paketabhängigkeits Probleme könnten unter Umständen auftreten wenn Pakete aus
unstable/testing installiert werden. Diese können auf unterschiedliche Art und
Weise umgangen werden.
<example>
# apt-get install -f <var>Paket</var> # ignoriere fehlende Abhängigkeiten
</example>
<p>
Eine Alternative dazu wäre, das <package>equivs</package> Paket zu verwenden.
Siehe <file>&f-equivs;</file><![%f-ref;[ und <ref id="equivs">]]>.
</sect1>


<sect1 id="rescue-dpkg">Wiederherstellung mit <prgn>dpkg</prgn>
<p>
Sollte das System einmal wirklich schwer geschädigt worden sein,
beispielsweise wenn <prgn>dselect</prgn> (APT) mit vielen Fehlermeldungen
abstürzt, kann man es auch nur mit Hilfe von <prgn>dpkg</prgn>
wiederherstellen:
<example>
# cd /var/cache/apt/archives
# dpkg -i libc6* libdb2* perl*
# dpkg -i apt* dpkg* debconf*
# dpkg -i *  # solange, bis keine Fehler mehr auftreten
</example>
Sollte einmal ein Paket fehlen, können Sie es von
<url id="&mirror-site;" name="mirror sites"> herunterladen:
<example>
# mc            # benutzen Sie "FTP link" der auf Debian FTP Server verweist
</example>
Kürzlich könnten neue Pakete auf den HTTP/FTP Servern nicht mehr in dem
klassischen <file>/dist</file> Verzeichnis zu finden sein, sondern im neuen
<file>/pool</file> Vezeichnis.
<![%f-ref;[
(Siehe <ref id="pools">.)
]]>
<p>
Installation des Paketes erfolgt dann folgendermaßen:
<example>
# dpkg -i /var/cache/apt/archives/<var>packagefile.deb</var>
</example>
Sollte eine fehlende Abhängigkeit auftreten, kann diese wie folgt aufgelöst
werden:
<example>
# dpkg --ignore-depends=<var>package1</var>,... -i <var>packagefile.deb</var>
# dpkg --force-depends -i <var>packagefile.deb</var>
# dpkg --force-depends --purge <var>package</var>
# dpkg --force-confmiss -i <var>packagefile.deb</var> # installiert fehlende
# Konfigurationsdateien
</example>
</sect1>

<sect1 id="rescue-var">Systemrettung nach Löschen von <file>/var</file>
<p>
Wenn einmal das <file>/var</file> Verzeichnis und die sich darunter
befindlichen Dateien/Verzeichnisse gelöscht wurden, lässt sich das System
unter der Voraussetzung, dass Sie eine Sicherung von
<file>/var/lib/dpkg/status</file> haben, folgendermaßen wiederherstellen:
<example>
# cd /
# install -d /var/cache/apt/archives
# install -d /var/cache/apt/archives/partial
# install -d /var/lib/dpkg/
# cp <var>status-old</var> /var/lib/dpkg/status
# apt-cache gencaches
</example>
Look for the old <file>/var/lib/dpkg/status</file> file
at <file>/var/lib/dpkg/status-old</file> or 
<file>/var/backups/dpkg.status.*</file>.
<p>
Eine eigene Partition für <file>/var/backups/</file> zu erstellen, könnte eine
gute Idee sein, insbesondere da sich dort wichtige System Daten befinden.

<sect1 id="un-bootable">Installation eines Packetes in ein nicht Bootfähiges
System
<p>
Booten Sie von einer der Debian Rescue Disketten/CD's oder von einer
alternativen Linux Partition.
Mounten Sie nun die nicht bootfähige Partition nach <file>/target</file> und
verwenden Sie die chroot Installationsmethode von <prgn>dpkg</prgn>.
<example>
# dpkg --root /target -i <var>packagefile.deb</var>
</example>
Anschließend sollten Sie das/die Problem(e) beheben
<p>
Wenn wir schon dabei sind, wenn LILO beispielsweise, durch einen
Konfigurationsfehler, Sie davon abhällt das System zu booten, können Sie
auch ganz einfach von einer Debian Rescue Diskette/CD booten. An dem
Boot-Prompt, vorausgesetzt Ihre root Partition befindet sich auf
<file>/dev/hda12</file>, und Sie möchten im Run-Level 3 starten, geben Sie
folgendes ein:
<example>
boot: rescue root=/dev/<var>hda12</var> 3
</example>
Daraufhin, startet ein nahezu vollständiges System, mit dem Kernel von der
Boot Diskette/CD. (Möglicherweise werden nicht alle Hardwarekomponenten
erkannt oder Module nicht geladen, dies liegt aber an dem Kernel von der Boot
Diskette/CD.)
</sect1>

<sect1>Der dpkg Befehl funktioniert nicht mehr - Was nun?
<p>
Ein funktionsgestörtes <prgn>dpkg</prgn>, macht es verständlicher Weise
unmöglich, <tt>.deb</tt> Dateien zu installieren. Die unten aufgefürten
Befehle sind eine Möglichkeit, das <tt>dpkg</tt> System wieder zu reparieren.
(Natürlich können Sie "links" mit Ihrem favorisierten Browser Befehl
ersetzen.)
<example>
$ links http://<var>http.us.debian.org</var>/debian/pool/main/d/dpkg/
  ... herunterladen von dpkg_<var>version</var>_<var>arch</var>.deb
$ ar x dpkg_<var>version</var>_<var>arch</var>.deb
$ su
password: *****
# mv data.tar.gz /data.tar.gz
# cd /
# tar xzfv data.tar.gz
</example>
Für die <tt>i386</tt> Architektur, kann auch
<tt>http://packages.debian.org/dpkg</tt> als eine URL genutzt werden.
</sect1>

<sect id="debian-package">Debian Nirvana Befehle
<p>
Das <strong>Verständis</strong> der folgenden Befehle ist eine essentielle
Voraussetzung, um zum einem, eventuellen Upgrade Problemen gewachsen zu
sein, und zum anderen um das Debian <strong>Nirvane</strong> zu erreichen.
:-)

<sect1 id="info-file">Informationen über eine Datei
<p>
Sie möchten den Namen des Paketes in Erfahrung bringen, welchem eine bestimmte
Datei angehört:
<example>
$ dpkg {-S|--search} pattern # suche nach Muster (pattern) in dem
installierten Paket
$ zgrep -e pattern <var>/local/copy/of/debian/woody/Contents-i386.gz</var>
             # finde das Dateinamen-Muster in den Debian Archiv Dateien
</example>
Es existiert aber auch ein für diesen Zweck optimiertes Program:
<example>
# apt-get install dlocate # Inkompatibel zu slocate (sichere Version von
locate)
$ dlocate <var>filename</var>         # schnellere Alternative zu dpkg -L and dpkg -S
...
# apt-get install auto-apt # installiert Pakete automatisch
# auto-apt update          # erzeugt eine db Datei für autp-apt
$ auto-apt search <var>pattern</var> # suche nach einem Muster in allen
Paketen, ob sie installiert sind, oder nicht
</example>
</sect1>

<sect1 id="info-package">Informationen über ein Paket
<p>
Die Debian Paket Archive können durchsucht und angezeigt werden. Stellen Sie
jedoch vorher sicher, dass Sie APT mit den richtigen Archiven in
<file>/etc/apt/sources.list</file> ausgestattet haben.
If you want to see how packages in testing/unstable do against the currently
installed one, use <tt>apt-cache policy</tt>&mdash;quite nice.
<example>
# apt-get check            # aktualisiert den Cache und schaut nach
Fehlerhaften Paketen
$ apt-cache search  <var>Suchmuster</var> # suche Pakete anhand des
Suchmusters
$ apt-cache policy  <var>Paket</var> # Paket Prioritäten/Distributions
Informationen
$ apt-cache show -a <var>Paket</var> # zeigt die Paketbeschreibung in allen
Distributionen
$ apt-cache showsrc <var>Paket</var> # zeigt die Paketbeschreibung des
Quell-Paketes
$ apt-cache showpkg <var>Paket</var> # zeigt Paket Informationen zu Debugging
zwecken
# dpkg --audit|-C       # sucht nach nicht vollständig installierten Paketen
$ dpkg {-s|--status} <var>Paket</var> # Beschreibung eines installierten
Paketes
$ dpkg -l <var>Paket</var> ...       # Status des installierten Paketes
$ dpkg -L <var>Paket</var> ...       # zeigt die Dateien an, die das Paket
installiert hat
</example>

<!-- Erase this when manual page gets fixed.  FIXME -->
<tt>apt-cache showsrc</tt> ist bis zum Woody Release noch nicht dokumentiert,
aber funktioniert. :)
<p>
Sie können ebenfalls anstelle der oben genannte Befehle, Paket Informationen
(ich benutzt <tt>mc</tt> zum suchen) in folgende Dateien finden:
<example>
/var/lib/apt/lists/*
/var/lib/dpkg/available
</example>
Ein Vergleich folgender Dateien, kann Aufschluss darüber geben, was genau bei
der letzten Installation passiert ist.
<example>
/var/lib/dpkg/status
/var/backups/dpkg.status*
</example>
</sect1>

<sect1 id="apt-get auto">Nicht-Interaktive Installation mit APT
<p>
Um nicht-interaktiv Pakete zu installieren, erweitern Sie die Datei
<file>/etc/apt/atp.conf</file>:
<example>
Dpkg::Options {"--force-confold";}
</example>
Der selbe Effekt kann auch mittels <tt>apt-get -q -y <var>Paket</var></tt>
erziehlt werden. Aber nutzen Sie diese Option mit großer Vorsicht, denn Sie
könnte negative Folgen implizieren. Lesen Sie <manref name="apt.conf"
section="5"> und <manref name="dpkg" section="1">.
<p>
Sie können jedes Paket auch später konfigurieren. Lesen Sie dazu <ref
id="reconfigure">.

<sect1 id="reconfigure">Installierte Pakete rekonfigurieren
<p>
Folgende Befehle sind einige Beispiele, wie Sie bereits installierte Paket
erneut konfigurieren können.
<example>
# dpkg-reconfigure --priority=<var>medium</var> <var>package</var> [...]
# dpkg-reconfigure --all   # Rekonfiguration aller Pakete
# dpkg-reconfigure locales # generiere zusätzliche locales
# dpkg-reconfigure --p=<var>low</var> xserver-xfree86 # rekonfiguriere den X
server
</example>

Wenn Sie den Dialog Modus von <prgn>debconf</prgn> permanent ändern möchten,
dann können Sie dies mit folgendem Befehl machen:
<example>
$ dpkg-reconfigure debconf  # rekonfiguriert debconf
</example>
<p>
Viele Programme sind mit speziellen Konfigurationsscripten ausgestattet.
<example>
apt-setup     - erstellt die Datei /etc/apt/sources.list
install-mbr   - installiert einen Master Boot Record Manager (lilo, Grub)
tzconfig      - setzt die lokale Zeitzone
gpmconfig     - konfiguriert den gpm Daemon
sambaconfig   - konfiguriert Sambe in Potato (Woody benutzt schon debconf)
eximconfig    - konfiguriert Exim (MTA)
texconfig     - konfiguriert teTeX
apacheconfig  - konfiguriert Apache (httpd)
cvsconfig     - konfiguriert CVS
sndconfig     - konfiguriert das Audio System
...
update-alternatives - setzt ein Standart Befehl, z.B. vim für vi
update-rc.d         - System-V init Script Management
update-menus        - das Debian Menü System
...
</example>
</sect1>

<sect1 id="remove">Deinstallation von Paketen
<p>
Deinstalliere ein Paket, aber behalte die Konfigurationsdateien:
<example>
# apt-get remove <var>package</var> ...
# dpkg  --remove <var>package</var> ...
</example>
Deinstalliere ein Paket und seine Konfigurationsdateien:
<example>
# apt-get remove --purge <var>package</var> ...
# dpkg    --purge        <var>package</var> ...
</example>
</sect1>

<sect1 id="hold">"Halten" älterer Pakete
<p>
Zunächst ein Beispiel: möchte man, dass die Pakete <package>libc6</package>
und <package>libc6-dev</package> beim einem Systemupgrade nicht durch neuere
Versionen ersetzt werden, wie z.B. beim Ausführen von <prgn>dselect</prgn> und
<tt>apt-get -u upgrade <var>Paket</var></tt>, so kann dies folgendermaßer
erziehlt werden:
<example>
# echo -e "libc6 hold\nlibc6-dev hold" | dpkg --set-selections
</example>
<tt>apt-get -u install <var>Paket</var></tt> bleibt davon jedoch unbeeinflusst. Um
andererseits bei einem automatischen Systemdowngrade mittels <tt>apt-get -u
upgrade <var>Paket</var></tt> oder <tt>apt-get -u dist-upgrade</tt> diese
Pakete zurück zu halten, ist die Datei <file>/etc/apt/preferences</file> wie
folgt zu erweitern:
<example>
Package: libc6
Pin: release a=stable
Pin-Priority: 2000
</example>
An dieser Stelle kann der Eintrag "<tt>Paket</tt>", keine Paketnamen wie z.B.
"<tt>libc6*</tt>" enthalten. Wenn Sie jedoch alle Pakete, die im Zusammenhang
mit dem <package>glibc</package> Paket stehen, auf dem selben Stand halten
möchten, müssen Sie diese alle explizit auflisten.
<p>
Folgender Befehl zeigt alle Pakete die den Status "hold" haben:
<example>
dpkg --get-selections "*"|grep -e "hold$"
</example>
</sect1>

<sect1 id="mixedsys">Gemischtes stable/testing/unstable System
<p>
<prgn>apt-show-versions</prgn> zeigt alle verfügbaren Packetversionen und
deren Zugehörigkeit zu den einzelnen Distributionen.
<example>
$ apt-show-versions | fgrep /testing | wc
... Anzahl der Pakete aus testing
$ apt-show-versions -u
... Liste aller Pakete für die es aktuellere Versionen gibt
$ apt-get install `apt-show-versions -u -b | fgrep /unstable`
... aktualisiert alle Paket aus unstable auf die aktuellste Version
</example>
</sect1>

<sect1 id="dselect"><prgn>dselect</prgn> &ndash; Systemweite Konfiguration
<p>
<prgn>dselect</prgn> zeigt gewisse Info Seiten, die aber ruhigen Gewissens
ignoriert werden können. Dazu ist die Datei <file>/etc/dpkg/dselect.cfg</file>
um eine zusätzliche Zeil, die das Wort "expert" enthällt, zu erweitern.
<p>
Wenn <prgn>dselect</prgn> startet, wählt es automatisch alle Pakete aus, die
in den Kategorien "Required", "Important" und "Standard" enthalten sind. In
der Potato Distribution waren etliche große Pakete wie z.B. teTeX und Emacs in
diesen Kategorien enthalten, und es war immer notwendig diese manuell zu
deselektieren (mittels `_'). In der Woody Distribution sind diese Pakete nun
in der "Optional" Kategorie.
<p>
<prgn>dselect</prgn> hat eine stark gewöhnungsbedürftige
Benutzerschnittstelle. Es gibt gleich vier doppeldeutige Befehle
(wirklich Großbuchstaben!):
<example>
<!-- Soll dieses Bsp. tatsächlich übersetzt werden?.  FIXME -->
Tastaturkürzel  Aktion
Q           Verlassen. Momentane Auswahl bestätigen und trotzdem verlassen.
            (Abhängikeiten vernachlässigen)
R           Rückgängig! Ich hab' es nicht so gemeint.
D           Verdammt! Es interessiert mich nicht was dselect meint. Mach es!
U           Alle auf den Vorgeschlagenen Status setzen.
</example>
Mit <tt>D</tt> und <tt>Q</tt> kann eine konfliktierende Auswahl auf eigenes
Risiko bestätigt werden. Hiermit sollte vorsichtig umgegangen werden. Auf
langsamen Rechnern, sollte <prgn>dselect</prgn> auf einem schnellerem Rechner
ausgeführt werden und dann mittels <tt>apt-get install</tt> installiert
werden. <tt>apt-get dselect-upgrade</tt> berücksichtigt die Auswahl von
<prgn>dselect</prgn> am besten.
</sect1>

<sect1 id="cache">Löschen von zwischengespeicherten Paket Dateien
<p>
APT speichert alle heruntergeladenen Paket Dateien in
<file>/var/cache/apt/archives</file>. Diese können folgendermaßen gelöscht
werden:
<example>
# apt-get autoclean # löscht nur ältere Paket Dateien
# apt-get clean     # löscht alle zwischengespeicherte Paket Dateien
</example>
</sect1>

<sect1 id="record">Speichern/Kopieren der System Konfiguration
<p>
Um eine lokale Kopie der aktuellen Paket Auswahl zu erstellen:
<example>
$ dpkg --get-selections "*" &gt;<var>meineAuswahl</var>   # oder \*
</example>
<tt>"*"</tt> veranlasst das auch Pakete mit einem Status von "purge" in
<tt><var>meineAuswahl</var></tt> gespeichert werden.
<p>
Diese Datei können Sie auf einen anderen Computer kopieren und sie dort
installieren:
<example>
# dselect update
# dpkg --set-selections &lt;<var>meineAuswahl</var>
# apt-get -u dselect-upgrade    # <var>oder</var> dselect install
</example>
</sect1>

<sect1 id="port">Portierung eines Pakets für die <tt>stable</tt> Distribution
<p>
Um selektive Upgrades in der stabilen Distribution zu machen, ist es möglich, ein
Quell-Paket in seiner Umgebung zu kompilieren. Dies verhindert auch viele
Paket Upgrades, die durch ein selektives Upgrade verursacht würden. Zuerst
müssen folgende Zeilen der <file>/etc/apt/sources.list</file> Datei angehängt
werden:
<example>
deb-src &http-us;debian testing \
 main contrib non-free
deb-src &http-non-us;debian-non-US testing/non-US \
 main contrib non-free
deb-src &http-us;debian unstable \
 main contrib non-free
deb-src &http-non-us;debian-non-US unstable/non-US \
 main contrib non-free
</example>
Aus Formatierungsgründen, sind die Zeilen hier in zwei Zeilen unterbrochen.
Natürlich muß aber jede mit "deb-src" beginnende Zeile für sich alleine
stehen.
<p>

Installation des Quell-Pakets und dessen Übersetzung (Kompilierung):
<example>
$ apt-get source <var>Paket</var>/unstable
$ dpkg-source -x <var>Paket.dsc</var>
$ cd <var>paket-version</var>
  ... 
$ dpkg-buildpackage -rfakeroot

  ...oder (kein sig)
$ dpkg-buildpackage -rfakeroot -us -uc # verwenden Sie "debsign" wenn nötig

  ...Anschließend die Installation des Paketes
$ su -c "dpkg -i <var>Paketdatei.deb</var>"
</example>
Hin und wieder kann es nötig sein, Packete mit der "-dev" Erweiterung zu
installieren um Paketabhängigkeiten auflösen zu können. <prgn>debsign</prgn>
ist im Paket <package>devscripts</package> enthalten. <prgn>auto-apt</prgn>
erleichtert die Auflösung von Abhängigkeiten. Mittels <prgn>fakeroot</prgn>
läst sich die Benutzung des root Accounts vermeiden.
<p>
In der Woody Distribution lassen sich Abhängigkeitsprobleme vereinfachen.
Als ein Beispiel, kompilieren wir das Quell-Paket <package>pine</package>.
<example>
# apt-get build-dep pine
# apt-get source -b pine
</example>
</sect1>

<sect1 id="local">Lokale Paket-Archive
<p>
Möchte man ein loakeles Paket-Archiv erzeugen, welches mit APT und dselect
kompatibel ist, so muss die Datei <file>Packages</file> erstellt werden und
die enthaltenen Paket-Dateien in einem bestimmten Verzeichnis bekannt gemacht
werden.
<p>
Offizielle Debian Archive wie das lokale deb Verzeichnis, können
folgendermaßen erstellt werden:
<example>
# apt-get install dpkg-dev
# cd <var>/usr/local</var>
# install -d <var>pool</var> # die Paket-Dateien werden hier gespeichert
# install -d dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>
# ls -1 <var>pool</var> | sed 's/_.*$/ extra <var>BOGUS</var>/' | uniq &gt; <var>override</var>
# editor <var>override</var> # anpassen <var>BOGUS</var>
# dpkg-scanpackages <var>pool</var> <var>override</var> <var>/usr/local</var>/ \
   &gt; dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>/Packages
# cat &gt; dists/<var>unstable</var>/<var>main</var>/Release &lt;&lt; EOF
Archive: <var>unstable</var>
Version: <var>3.0</var>
Component: <var>main</var>
Origin: <var>Local</var>
Label: <var>Local</var>
Architecture: <var>i386</var>
EOF
# echo "deb file:<var>/usr/local</var> <var>unstable</var> <var>main</var>" \
   &gt;&gt; /etc/apt/sources.list
</example>
<p>
Alternativ kann auch folgende, schnellere aber unsaubere, Methode verwendet
werden:
<example>
# apt-get install dpkg-dev
# mkdir <var>/usr/local/debian</var>
# mv <var>/some/where/package.deb</var> <var>/usr/local/debian</var>
# dpkg-scanpackages <var>/usr/local/debian</var> /dev/null | \
  gzip - &gt; <var>/usr/local/debian</var>/Packages.gz
#  echo "deb file:<var>/usr/local/debian</var> ./" &gt;&gt; /etc/apt/sources.list
</example>
<p>
Natürlich kann ein solches Archiv auch entfernten Computern, mittels HTTP
und/oder FTP, zugänglich gemacht werden. Die Datei
<file>/etc/apt/sources.list</file> muß dementsprechend angepasst werden.

<sect1 id="alien">Installation und Konvertierung eines binären Pakets mit
alien
<p>
Mit Hilfe des <package>alien</package> Pakets, lassen sich binäre Pakete, wie
sie in vielen Distributionen wie Redhat <tt>rpm</tt>, Stampede <tt>slp</tt>,
Slackware <tt>tgz</tt> und Solaris <tt>pkg</tt> verwendet werden, in das
&debian; <tt>deb</tt> Paketformat konvertieren. Wenn Sie ein Paket von einer
anderen Distribution verwenden möchten, können Sie es mit <prgn>alien</prgn>
in Ihr bevorzugtes Paketformat konvertieren und anschließend installieren.
<package>alien</package> unterstützt ebenfalls LSB Pakete.
</sect1>

<sect1 id="debsums">Verifizierung installierter Paket-Dateien
<p>
<prgn>debsums</prgn> verifiziert installierte Paket-Dateien anhand deren MD5
Prüfsummen. Jedoch gibt es auch Paket die keine MD5 Prüfsummen enthalten. Eine
mögliche temporäre Lösung ist folgende:
<example>
# cat >>/etc/apt/apt.conf.d/90debsums
DPkg::Post-Install-Pkgs {"xargs /usr/bin/debsums -sg";};
^D
</example>
von Joerg Wendland &lt;joergland@debian.org&gt; (nicht getestet).
</sect>

<sect id="pecuriarities">Weitere Debian Besonderheiten

<sect1 id="dpkg-divert">Der <prgn>dpkg-divert</prgn> Befehl
<p>
<!-- Kopie von der Manual Seite -->
<strong>Dateiumleitungen</strong> sind eine Methode, um <prgn>dpkg</prgn> dazu
zu bringen, Dateien nicht in ihre Standard Verzeichnisse zu installieren,
sondern in <strong>umgeleitete</strong> Verzeichnisse zu installieren. 
<strong>Umleitungen</strong> können durch &debian; Scripte dazu genutzt
werden Dateien zu verschieben, wenn sie einen Konflikt verursachen.
Systemadministratoren können eine Umleitung verwenden, wenn sie einer
Konfigurationsdatei eines Paketes zuvorkommen wollen, oder aber auch wann
immer einige Dateien (welche nicht als <strong>conffiles</strong> markiert
sind) von <prgn>dpkg</prgn> nicht überschrieben werden sollen, wenn eine
neuere Version eines Paketes installiert wird, die solche Dateien
enthällt<![%f-ref;[(siehe <ref id="conffile">)]]>.
<example>
# dpkg-divert [--add]  <var>filename</var> # erstellen der "Umleitung"
# dpkg-divert --remove <var>filename</var> # entfernen der "Umleitung"
</example>
Für gewöhnlich ist es ratsam <prgn>dpkg-divert</prgn> nicht zu verwenden wenn
es nicht absolut notwendig ist.
</sect1>

<sect1 id="equivs">Das <package>equivs</package> Paket
<p>
Wenn Sie ein Quell-Paket kompilieren ist es empfehlenswert, es zu einem echten
lokalen Debian Paket (<tt>*.deb</tt>) zu machen.
Benutzen Sie <tt>equivs</tt> als letzten Ausweg.
<example>
Package: equivs
Priority: extra
Section: admin
Description: Circumventing Debian package dependencies
 This is a dummy package which can be used to create Debian
 packages, which only contain dependency information.
</example>
</sect1>

<sect1 id="alternatives">Alternative Befehle
<p>
Möchte man das der Befehl <prgn>vi</prgn> <prgn>vim</prgn> ausführt, benutzten
Sie <prgn>update-alternatives</prgn>:
<example>
# update-alternatives --display vi
...
# update-alternatives --config vi
  Selection    Command
-----------------------------------------------
      1        /usr/bin/elvis-tiny
      2        /usr/bin/vim
*+    3        /usr/bin/nvi

Enter to keep the default[*], or type selection number: 2
</example>
Einstellungen im Debian Alternativsystem werden in
<file>/etc/alternativesy</file> als symbolische Links gespeichert.
<p>
Um Ihre bevorzugte X Fenster Umgebung zu setzen, führen sie
<prgn>update-alternatives</prgn> für <file>/usr/bin/x-session-manager</file>
und <file>/usr/bin/x-window-manager</file> aus.
<![%f-ref;[
Für weitere Informationen, siehe <ref id="custom-x">.
]]>
<p>
<file>/bin/sh</file> ist ein symbolischer Link auf <file>/bin/bash</file> oder
<file>/bin/dash</file>. Aus kompatibilitätsgründen zu alten Bash 
verschmutzten Scripten ist es sicherer, <file>/bin/bash</file> zu verwenden.
Um die POSIX Konformität einzuhalten sollte jedoch <file>/bin/dash</file>
verwendet werden. Mit dem Upgrade auf den 2.4 Linux Kernel geht die Tendenz
zugunsten zu <file>/bin/dash</file>.
</sect1>

<sect1 id="sys-v">System-V <prgn>init</prgn> und runlevels
<p>
Der Standard runlevel in den gebootet wird, lässt sich in
<file>/etc/inittab</file> einstellen.
<p>
Im Gegensatz zu anderen Distributionen, gibt Debian das Management der
runlevel komplett in die Hände des Systemadministrators. Das Management des
System-V Stils <prgn>init</prgn> in Debian wird von <prgn>update-rc.d</prgn>
Scripten durchgeführt.
<p>
Das Starten von <file>/etc/init/<var>name</var></file> in den runlevel 1,2,3
und das Stoppen in 4,5 mit der sequenziellen Prioritätsnummer 20 (Normal)
lässt sich folgendermaßen einrichten:
<example>
# update-rc.d <var>name</var> start 20 1 2 3 . stop 20 4 5 .
</example>
Das Löschen symbolischer Links funktioniert folgendermaßen:
<example>
# update-rc.d -f <var>name</var> remove
</example>
Dabei bleiben die Scripte in <prgn>init.d</prgn> unangetastet.

Beim editieren der runlevel schumel ich. Ich editiere Einträge manuell mit dem
<prgn>mv</prgn> Befehl an der Shell Eingabeaufforderung von <prgn>mc</prgn>
während ich Link Einträge mit <tt>Alt-Enter</tt> kopiere. Ein Beispiel:
<example>
# mv S99xdm K99xdm # disable xdm (X Display Manager)
</example>
Selbst das Deaktivieren eines Daemons bewerkstellige ich, indem ich ein
<tt>exit 0</tt> an den Anfang eines <prgn>init.d</prgn> Scriptes einfüge. Dies
ist ein schneller Hack. Schließlich sind diese Dateien <tt>conffiles</tt>.
</sect1>

<sect1 id="disable">Deaktivierung von Daemon Diensten
<p>
Die &debian; Distribution nimmt die Systemsicherheit sehr ernst und erwartet,
dass der Systemadministrator kompetent ist. Eine einfache Administration
scheint so, oft nur an zweiter Stelle zu stehen und viele Daemon Dienste sind
mit dem höchsten Sicherheits Level vorkonfiguriert, oder mit den wenigsten
Diensten (oder keine) in der Standard Installation ausgestattet.
<p>
Führen Sie <tt>ps aux</tt> aus oder überprüfen Sie die Inhalte von
<file>/etc/init.d/*</file> und <file>/etc/inetd.conf</file>, wenn Sie Zweifel
daran haben (Exim, DHCP, ...). Überprüfen Sie auch
<file>/etc/hosts.deny</file><![%f-ref;[ wie
in <ref id="loginctrl">]]>.
Der <prgn>pidof</prgn> Befehl ist ebenfalls sehr hilfreich (siehe <manref
name="pidof" section="8">).
<p>
X11 verbietet TCP/IP (entfernte) Verbindungen per Standard in neueren &debian;
Versionen.
<![%f-ref;[
Siehe <ref id="xtcp">.
]]>
X Weiterleitungen per SSH sind ebenfalls deaktiviert.
<![%f-ref;[
Siehe <ref id="xssh">.
]]>
</sect1>
</sect>

</chapt>

