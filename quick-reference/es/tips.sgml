<!-- CVS revision of original english document "1.112"  -->

<chapt id="tips"> Trucos para &debian; 

<sect id="booting">Arrancando el sistema
<p>
Véase el <url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> para
información detallada sobre el indicador de arranque.

<sect1 id="crackroot">"¡Olvidé la contraseña de superusuario!" (1)
<p>
Es posible arrancar el sistema y acceder a la cuenta de superusuario sin
conocer la contraseña siempre y cuando se tenga acceso al teclado de la
consola (esto supone que ni la BIOS ni un cargador de arranque como
<prgn>lilo</prgn> solicitan una contraseña para evitar el arranque del
sistema)
<p>
Este es un procedimiento que no requiere de discos de arranque externos
ni cambios en los parámetros de arranque de la BIOS. Aquí, "Linux" hace
referencia al kernel de Linux de la instalación predeterminada de
Debian.
<p>
En el pantalla de arranque de <prgn>lilo</prgn>, cuando aparece
<tt>boot:</tt> (en algunos sistemas debe presionar la tecla Mayús para
evitar el arranque automático y cuando <prgn>lilo</prgn> utiliza
el framebuffer tiene que pulsar TAB para ver las opciones), escriba:
<example>
boot: Linux init=/bin/sh
</example>
Esto hará que el sistema arranque el kernel y ejecute el
<file>/bin/sh</file> en vez del estándar <prgn>init</prgn>.  Ahora
tenemos privilegios de superusuario y acceso al intérprete de comandos.
Puesto que <file>/</file> generalmente está montado en modo sólo lectura
y aún no han sido montadas las distintas particiones, debe hacer lo
siguiente para tener un sistema que funcione razonablemente.
<example>
init-2.03# mount -n -t remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(si el segundo campo de datos en el <file>/etc/passwd</file> es una "x"
para cada nombre de usuario, su sistema utiliza contraseñas ocultas y
debe editar el archivo <file>/etc/shadow</file>) Para desactivar la
contraseña de root, edite el segundo campo de datos en el archivo de
contraseñas de modo que quede vacío.  Ahora se puede reiniciar el
sistema y entrar como root sin contraseña.  A diferencia de algunas
distribuciones Linux antiguas, la Debian actual (Potato) requiere de
contraseña sólo cuando arranca en el nivel de ejecución 1.
<p>
Resulta una buena idea tener un editor mínimo en <file>/bin</file>
en el caso que <file>/usr</file> no sea accesible (véase <ref id="bin-editor">).
<p>
También considere instalar el paquete <package>sash</package>.
Cuando no pueda arrancar el sistema, haga:
<example>
boot: Linux init=/bin/sash
</example>
<prgn>sash</prgn> sirve como un sustituto interactivo de
<prgn>sh</prgn> incluso cuando <file>/bin/sh</file> no se puede usar.
Está enlazado estáticamente e incluye diversas utilidades estándar
incorporadas (teclee "help" en el indicador de comandos para una lista
de referencia).
</sect1>

<sect1 id="crackroot2">"¡Olvidé la contraseña de superusuario!" (2)
<p>
Arranque desde un disco de emergencia.  Si <file>/dev/hda3</file> es la
partición raíz original, lo siguiente le permitirá editar el archivo de
contraseñas tan fácilmente como antes.
<example>
# mkdir fixit
# mount /dev/hda3 fixit
# cd fixit/etc
# vi shadow
# vi passwd
</example>
<p>
La ventaja de este enfoque sobre el anterior es que no se necesita
conocer la contraseña de <prgn>lilo</prgn> (si existe).  Pero para
usarlo uno debe ser capaz de poder acceder a la configuración de la BIOS
para permitir arrancar el sistema desde un disquete o CD si es que ya no
está configurada como tal.
</sect1>

<sect1 id="dead-lilo">No puedo arrancar el sistema
<p>
Si se tomó la molestia de crear un disco de arranque durante la instalación,
no habrá ningún problema.  Si <prgn>lilo</prgn> se encuentra dañado, grabe el
disco de arranque desde el disco de instalación de debian y arranque el
sistema con él. En el indicador de arranque, suponiendo que la partición raíz
de su instalación Linux es <file><var>/dev/hda12</var></file> y que desea
entrar al nivel de ejecución 3, escriba:
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
De esta manera arrancará con un sistema prácticamente funcional usando el
kernel del disquete (pueden existir pequeños inconvenientes debido a la falta
de algunas características o módulos del kernel). 
<p>
Véase también <ref id="un-bootable"> si su sistema está dañado.
<p>
Si necesita un disquete de arranque personalizado, 
consulte el <file>readme.txt</file> del disco de rescate.
</sect1>

<sect1 id="no-x-start">"¡Permítanme desactivar X al arrancar!"
<p>
Chasing <tt>unstable/sid</tt> is fun, but buggy <prgn>xdm</prgn>, 
<prgn>gdm</prgn>, <prgn>kdm</prgn>, and <prgn>wdm</prgn> started 
during the boot process can bite you bad.
<p>
Primero acceda al shell del superusuario escribiendo lo siguiente en el indicador de 
arranque:
<example>
boot: <var>Linux</var> vga=normal s
</example>
En este caso, <var>Linux</var> es la etiqueta de la imagen del kernel que está
arrancando.  "vga=normal" nos asegurará que <prgn>lilo</prgn> se ejecute en
una pantalla VGA normal y "s" (o "S") es el parámetro que se pasa a
<prgn>init</prgn> para invocar el modo monousuario.  Escriba la contraseña del
superusuario en el símbolo de espera.
<p>
Existen distintas maneras de desactivar todos los demonios 
que arrancan con X:
<list>
<item>ejecute <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6 .</tt>
<item>escriba "exit 0" al comienzo de todos los archivos <file>/etc/init.d/<var>?</var>dm</file>.
<item>renombre todos los archivos <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> como
 <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>elimine todos los archivos <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>.
<item>ejecute <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Aquí, el número en <file>rc<var>2</var>.d</file> se debe corresponder al nivel de ejecución
especificado en el <file>/etc/inittab</file>. Asimismo
<file><var>?</var>dm</file> significa que necesita ejecutar el comando
múltiples veces sustituyéndolo con  <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn> o <prgn>wdm</prgn>.
<p>
La primera de la lista es "la única manera verdadera" en &debian;.  La última
es fácil pero sólo funciona en &debian; y exige que que se configure el
administrador de pantalla nuevamente usando <prgn>dpkg-reconfigure</prgn>.
Los otros son métodos genéricos para deshabilitar demonios.
<p>
Aún puede continuar arrancando X mediante el comando <prgn>startx</prgn>
desde cualquier consola de shell.
</sect1>

<sect1 id="bootprompt">Otros trucos con el indicador de arranque
<p>
El sistema se puede arrancar en un nivel de ejecución particular
y con una configuración determinada usando el indicador de arranque
de <prgn>lilo</prgn>. Para más detalles consulte el
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Si desea arrancar el sistema en el nivel de ejecución cuatro, use la
siguiente entrada para el indicador de arranque de <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Si desea arrancar el sistema en modo monousuario y conoce la contraseña
de superusuario, algunos de los siguientes ejemplos funcionará usando el
indicador de arranque de <prgn>lilo</prgn>.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Si desea arrancar el sistema con menos memoria de la que realmente posee
el sistema (por ejemplo, 48MB en un sistema con 64MB), use la siguiente
entrada para el indicador de arranque de <prgn>lilo</prgn>:
<example>
boot: Linux mem=48M
</example>
Asegúrese de no especificar un valor mayor al tamaño de memoria real ya
que si es así el kernel se colgará.  Los núcleos antiguos y/o las placas
madres con una BIOS antigua no usan la memoria por encima de los 64 MB,
salvo que uno escriba <tt>mem=128M</tt> en el indicador de arranque o
incluya una línea similar en el <file>/etc/lilo.conf</file>.
</sect1>


<sect1 id="bootgrub">Configurando los parámetros de arranque (GRUB)
<p>
GRUB es un nuevo administrador de arranque del projecto Hurd y es mucho
más flexible que lilo pero con un manejo ligeramente diferente de los
parámetros de arranque.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Aquí, debe tener presente los nombres de dispositivos que utiliza
Hurd:
<example>
Hurd/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A: 
 (hd0,0)             /dev/hda1           C: (generalmente)
 (hd0,3)             /dev/hda4           F: (generalmente)
 (hd1,3)             /dev/hdb4           ?
</example>
Véase <file>&f-grub;</file> y <file>&f-grub-doc;</file> para más
detalles.
 </sect>
<sect>Registro de actividades
<sect1 id="script">Registrando las actividades del intérprete de comandos
<p>
La administración del sistema implica tareas mucho más elaboradas en un
entorno Unix que un entorno común de una computadora personal. Asegúrese
de saber lo básico sobre configuración por si acaso necesita recuperar
el sistema de algún problema. Las herramientas gráficas de configuración
basadas en X11 son agradables y convenientes pero a menudo
inapropiadas en situaciones de emergencia.
<p>
En este contexto, el registro de las actividades del intérprete de
comandos resulta ser una buena práctica especialmente como superusuario.
<p>
Emacs: utilice M-x <tt>shell</tt> para empezar a grabar en el búfer y
C-x C-w para escribir el contenido del mismo en un archivo.
<p>
Intérprete de comandos: utilice el comando <prgn>screen</prgn> con "^A H"
como se detalla en <ref id="screen"> o el comando <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 ... hacer cualquier cosa ...
 Ctrl-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
Se puede utilizar lo siguiente en vez del comando <prgn>script</prgn>:
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>
<sect1>Registrando las actividades en X
<p>
Si necesita registrar la imagen de una aplicación X, incluyendo una terminal
<prgn>xterm</prgn>, utilice <prgn>gimp</prgn> (GUI).  Puede capturar cada
ventana o la totalidad de la pantalla. Otras alternativas son <prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>) y <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>
</sect>

<sect id="archiving">Copiar y archivar un subdirectorio entero
<sect1>Comandos básicos para copiar un subdirectorio entero
<p>
Si necesita reordenar la estructura de archivos, mueva el contenido
incluyendo los enlaces a archivos mediante:
<example>
Método estándar:
# cp -a /directorio/fuente /directorio/destino # debe ser GNU
# (cd /directorio/fuente &amp;&amp; tar cf - . ) | \
        (cd /directorio/destino &amp;&amp; tar xvfp - )
Si existen enlaces duros, se necesita un método más elaborado:
# cd /ruta/al/directorio/original
# find . -depth -print0 | afio -p -xv -0a
# /punto/de/montaje/del/nuevo/directorio
En el caso de una conexión remota:
# (cd /directorio/fuente &amp;&amp; tar cf - . ) | \
    ssh usuario@host.dom (cd /directorio/destino &amp;&amp; tar xvfp - )
Si no hay archivos enlazados:
# scp -pr usuario1@host1.dom:/directorio fuente \
          usuario2@host2.dom:/directorio/destino
</example>
En este caso, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> y <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
El método para copiar un subdirectorio entero está basado en la
información proporcionada por Manoj Srivastava
<email>srivasta@debian.org</email> de la lista debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Inicialmente, <prgn>cp</prgn> no resultaba ser el candidato correcto ya que no
desreferenciaba enlaces simbólicos ni tampoco preservaba enlaces duros.  Otra
cosa a considerar eran los archivos de tamaño muy pequeño.
<p>
GNU <prgn>cp</prgn> ha superado estas limitaciones. No obstante en sistemas
que no son GNU cp puede aún tener problemas. Asimismo, no se pueden generar
archivos portables pequeños usando <prgn>cp</prgn>.
<example>
&percnt; cp -a . directorio_nuevo
</example>

<sect1><prgn>tar</prgn>
<p>
Tar soluciona algunos de los problemas que tenía cp con los enlaces
simbólicos. Sin embargo, `cpio' maneja archivos especiales que el `tar'
tradicional no puede manejar.
<p>                                                             
<prgn>tar</prgn> maneja múltiples enlaces duros colocando una única copia de
un enlace en la cinta. El nombre asignado a dicha copia es el <em>único</em>
que se puede usar para recuperar el archivo. En cambio, <prgn>cpio</prgn>
coloca una copia de cada enlace de manera que para recuperar el archivo se
puede utilizar el nombre de cualquiera de ellas.
<p>
El comando <prgn>tar</prgn> ha cambiado sus opciones para los archivos
<file>.bz2</file> al pasar de Potato a Woody, por lo tanto, use
<tt>--bzip2</tt> en los scripts en vez de su forma reducida <tt>-I</tt>
(Potato) o <tt>-j</tt> (Woody).  
</sect1>

<sect1><prgn>pax</prgn>
<p>
Es la nueva utilidad para archivar, portable y compatible POSIX (IEEE Std
1003.2-1992, páginas 380-388 (sección 4.48) y páginas 936-940 (sección
E.4.48)).  <prgn>pax</prgn> lee, escribe y lista los componentes de un
directorio y copia la jerarquía de los mismos.  La operación pax es
independiente del formato específico del archivo y admite una amplia variedad
de formatos.
<p>
Las implementaciones de <prgn>pax</prgn> son aún nuevas y están en pleno
desarrollo.
<example>
# apt-get install pax
$ pax -rw -p e . directorio_nuevo
 o
$ find . -depth  | pax -rw -p e  directorio_nuevo
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn> almacena o extrae archivos en o de un archivo <prgn>tar</prgn> o
<prgn>cpio</prgn>. El archivo puede ser otro archivo del disco, una cinta
magnética o una tubería.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> es una mejor forma de tratar con archivos con formato cpio.
Generalmente es más rápido que <prgn>cpio</prgn>, proporciona más opciones
para utilizar con cintas magnéticas y maneja mejor la corrupción de los datos
de entrada.  Admite archivos multi-volumen durante su operación interactiva.
Afio puede crear archivos empaquetados que son mucho más seguros que los
empaquetados con <prgn>tar</prgn> o <prgn>cpio</prgn>.  En un script, para
realizar una copia de seguridad, afio tiene un comportamiento óptimo como
'motor para archivar'.
<example>
$ find . -depth -print0 | afio -px -0a directorio_nuevo
</example>
Para crear todas mis copias de respaldo en una cinta uso <prgn>afio</prgn>. 
</sect1>

</sect>
<sect id="diff-backup">Respaldos diferenciales y sincronización
de datos
<p>
Los respaldos diferenciales y la sincronización de datos se pueden
implementar mediante diversos métodos:
<list>
<item><package>rcs</package>:  copia de respaldo e historial, sólo texto
<item><package>rdiff-backup</package>:  copia de respaldo e historial. Se
respetan enlaces simbólicos.
<item><package>pdumpfs</package>:  copia de respaldo e historial en un sistema
de archivos. Se respetan los enlaces simbólicos.
<item><package>rsync</package>:  sincronización en un sólo sentido
<item><package>unison</package>:  sincronización en ambos sentidos
<item><package>cvs</package>:  sincronización en múltiples sentidos con un
servidor e historial, sólo texto, maduro. Véase <ref id="cvs">.
<item><package>arch</package>:  sincronización en múltiples sentidos con un
servidor, copias de respaldo e historial, sin "directorio de trabajo".
<item><package>subversion</package>: sincronización en múltiples 
sentidos con un servidor, copias de respaldo e historial, Apache.
</list>
La combinación con uno de los métodos descriptos en 
<ref id="archiving"> y la automatización de tareas descripta en
<ref id="cronjob"> permitirán crear un buen sistema de respaldo.
<p>
Explicaré tres herramientas fáciles de usar.

<sect1 id="rdiff-backup">Respaldos diferenciales con rdiff
<p>
<package>rdiff-backup</package> ofrece respaldos buenos y sencillos
con historial diferencial para cualquier tipo de archivos incluyendo
enlaces simbólicos. Para hacer una copia de respaldo de la
mayor parte de <file>~/</file> en <file>/mnt/respaldo</file>:
<example>
$ rdiff-backup --include ~/tmp/conservar --exclude ~/tmp  ~/ /mnt/respaldo
</example>
Para restaurar los datos de hace tres días de este archivo en
<file>~/antiguo</file>:
<example>
$ rdiff-backup -r 3D /mnt/respaldo ~/antiguo
</example>
Véase <manref name="rdiff-backup" section="1">.
</sect1>

<sect1 id="pdumpfs-backup">Copias de respaldo diarias con <package>pdumpfs</package>
<p>
<package>pdumpfs</package> es un sencillo sistema para realizar copias de
respaldo diarias similar al <prgn>dumpfs</prgn> de Plan9 que preserva cada
réplica diaria del sistema.  Es posible acceder en cualquier momento a
réplicas antiguas para obtener un archivo de un día determinado. ¡ Hagamos una
copia de respaldo de nuestro directorio personal con <prgn>pdumpfs</prgn> y
<prgn>cron</prgn>!
<p>
<prgn>pdumpfs</prgn> crea la réplica <tt>AAAA/MM/DD</tt> en el directorio de
destino. Todos los archivos originales se copian al directorio réplica cuando
<prgn>pdumpfs</prgn> se ejecuta por primera vez. A partir de la segunda vez y
en adelante, <prgn>pdumpfs</prgn> copia sólamente archivos nuevos o
actualizados y almacena los archivos sin modificar como enlaces duros a los
archivos de la réplica del día previo para ahorrar espacio en disco.
<example>
$ pdumpfs <var>dir-orig</var> <var>dir-dest</var> [<var>dest-basename</var>]
</example>
Véase <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">Respaldos diferenciales con RCS
<p>
<package>Changetrack</package> registrará en forma regular
los cambios de los archivos de configuración en archivos RCS.  
Véase <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>Recuperar al sistema de un cuelgue
<sect1 id="kill">Mate el procesoi
<p>
Ejecute <prgn>top</prgn> para ver cuál es el proceso que está actuando de
manera extraña. Pulse `P' para ordenar por tiempo de CPU, `M' para ordenar por
uso de memoria y "k" para matar un proceso. En forma aternativa, se puede usar
el estilo BSD <tt>ps aux | less</tt> o el System V <tt>ps -efH | less</tt>.
La sintaxis del estilo System V muestra los ID de los procesos padres
(<tt>PPID</tt>) que se pueden utilizar para matar un proceso hijo zombie
(malfuncionamiento).
<p>
Utilice <prgn>kill</prgn> junto el ID del proceso para matar (o enviar una
señal a) un proceso, <prgn>killall</prgn> para hacer lo mismo pero usando el
nombre del comando.  Señales de uso habitual:
<example>
 1: HUP,  reiniciar demonio
15: TERM, terminar un proceso en forma normal
 9: KILL, matar un proceso sin contemplaciones
</example>

</sect1>

<sect1>Alt-SysRq
<p>
La opción de compilación del kernel "Magic SysRq key" proporciona una
protección contra el mal funcionamiento del sistema.  Pulsando
Alt-SysRq en una i386 y a continuación una de las teclas <tt>r
0 k e i s u b</tt> se obtiene el pase mágico.
<p>
Un<tt>r</tt>aw restaura el teclado tras el cuelgue de X.  Modifique el nivel
de registro de la consola con <tt>0</tt> para reducir los mensajes de error.
sa<tt>k</tt> (tecla de atención del sistema) mata a todos los procesos en la
consola virtual actual.  t<tt>E</tt>rminate mata a todos los procesos de la
terminal actual salvo <prgn>init</prgn>.  k<tt>i</tt>ll mata a todos los
procesos incluyendo a <prgn>init</prgn>.  <p> <tt>s</tt>ync (sincronizar),
<tt>u</tt>mount (desmontar), y re<tt>b</tt>oot (reiniciar) a menudo se
utilizan en el caso de situaciones realmente complicadas.
<p>
En el momento de escribir este documento, los núcleos que vienen con la
instalación predeterminada de Debian no han sido compilados con esta
opción. Recompile el kernel para activarla. Se puede encontrar
información detallada en:
<file>/usr/share/doc/kernel-doc-<var>version</var>/Documentation/sysrq.txt.gz</file>.
</sect1>
</sect>


<sect id="nifty">Algunos pequeños comandos útiles para tener en cuenta
<sect1>Paginador
<p>
<prgn>less</prgn> es el paginador predeterminado (navegador del contenido de
un archivo).  Pulse `h' para obtener ayuda. Puede hacer muchas más cosas que
<prgn>more</prgn>.  <prgn>less</prgn> puede cargarse ejecutanto <tt>eval
$(lesspipe)</tt> or <tt>eval $(lessfile)</tt> en el script de arranque del
intérprete de comandos.  Véase más en <file>&f-lessopen;</file>. La opción
<tt>-R</tt> permite la salida de caractéres raw y activa las secuencias de
escape en color ANSI.  Véase <manref name="less" section="1">.
<p>
<prgn>w3m</prgn>puede ser un paginador alternativo útil para algunos sistemas
de código (EUC).
<sect1>Memoria disponible
<p>
<prgn>free</prgn> y <prgn>top</prgn> brindan una buena información sobre
los recursos de memoria disponibles. No se preocupe por el tamaño que
figura bajo "used" de la línea "Mem:" sino por el valor que se encuentra
justo debajo de él (38792 en el siguiente ejemplo). 
<example>
$ free -k # para una máquina con 256MB
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
La cantidad de memoria física exacta se puede confirmar haciendo
<tt>grep '^Memory' /var/log/dmesg</tt>. En este caso arroja el siguiente
resultado:
"Memory: 256984k/262144k available (1652k kernel
code, 412k reserved, 2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
El sistema no puede usar cerca de 5MB ya que lo utiliza el propio kernel.
</sect1>

<sect1>Configurar fecha y hora (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
Esto fijará la fecha y hora del sistema y del hardware en MM/DD hh:mm,
CCYY.  La hora se muestra según el huso horario local pero el hardware
utiliza el UTC.
<p>
Si el tiempo por hardware (BIOS) se encuentra en GMT, incluya
<tt>UTC=yes</tt> en <file>/etc/default/rcS</file>.

<sect1>Configurar hora (NTP)
<p>
Referencia: <url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">.
<p>
<sect2>Configurar la fecha y hora con una conexión a Internet permanente
<p>
Configure el reloj del sistema para corregir la fecha y hora en forma
automática mediante un servidor remoto:
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
Si su sistema posee una conexión a Internet permanente, resulta
interesante incluirlo en <file>/etc/cron.daily/</file>.

<sect2>Configurar la hora y fecha con una conexión a Internet no permanente
<p>
Use el paquete <package>chrony</package>.
</sect1>

<sect1 id="setterm">Como controlar características de la consola tales como el
protector de pantalla
<p>
Para descativar el protector de pantalla, utilice los siguientes comandos:
<p>
En la consola de Linux:
<example>
# setterm -powersave off
</example>
<p>
Ejecute la consola kon2 (kanji) con:
<example>
# kon -SaveTime 0
</example>
<p>
Cuando esté ejecutando X:
<example>
# xset s off
 o
# xset -dpms
 o
# xscreensaver-command -prefs
</example>
Consulte las correspondientes páginas del manual para controlar otras
características de la consola. Véase también <manref name="stty" section="1">
for changing and printing
</sect1>

<sect1 id="getent">Búsqueda en la base de datos administrativa
<p>
Glibc ofrece <manref name="getent" section="1"> para buscar entradas
en la base de datos administrativa (passwd, group, hosts, services, 
protocols o networks).
<example compact>
getent database [clave ...]
</example>

<sect1>Desactivar el sonido (bip)
<p>
Uno siempre puede desenchufar el parlante del PC ;-).  Para el
intérprete de comandos:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc:
</example>
</sect1>

<sect1>Mensajes de error por pantalla
<p>
Para hacer desaparecer los mensajes de error por pantalla, el primer lugar a
verificar es <file>/etc/init.d/klogd</file>.  Fije <tt>KLOGD="-c
<var>3</var>"</tt> en este script y ejecute <tt>/etc/init.d/klogd
restart</tt>. Un método alternativo consiste en ejecutar 
<tt>dmesg -n<var>3</var></tt>.  
<p>
Veamos el significado de los niveles de error:
<list compact>
<item>0: KERN_EMERG,   sistema inutilizado
<item>1: KERN_ALERT,   deben tomarse acciones de inmediato
<item>2: KERN_CRIT,    condiciones críticas
<item>3: KERN_ERR,     condiciones de error
<item>4: KERN_WARNING, condiciones de precaución
<item>5: KERN_NOTICE,  condiciones normales pero significativas
<item>6: KERN_INFO,    mensajes informativos
<item>7: KERN_DEBUG,   mensajes a nivel depuración
</list>
<p>
Si un mensaje de error inútil lo molesta continuamente, considere crear un
parche para el kernel sencillo tal como <file>shutup-abit-bp6</file>
(disponible en el <url id="&examples;" name="subdirectorio de ejemplos">).
<p>
Otro lugar que hay que ver es el <file>/etc/syslog.conf</file>; verifique si
los mensajes de error se envían a la consola.
</sect1>

<sect1>Configurar la consola
<p>
En sistemas tipo UNIX se accede a las pantallas de la consola mediantes
rutinas de la biblioteca (n)curses.  Éstas brindadn al usuario un método
independiente del terminal de actualizar las pantallas de caracteres con una
optimización razonable. Véase <manref name="ncurses" section="3X"> y <manref
name="terminfo" section="5">.
<p>
En un sistema &debian;, existe una infinidad de entradas predefinidas:
<example>
$ toe | less                  # todas las entradas
$ toe /etc/terminfo/ | less   # entradas reconfigurables por el usuario
</example>
Exporte su elección mediante la variable de entorno <tt>TERM</tt>.
<p>
Si la entrada terminfo para <prgn>xterm</prgn> no funciona con una
<prgn>xterm</prgn> no-Debian, cuando
acceda a un sistema Debian en forma remota cambie el tipo de su terminal de
"xterm" a una de las versiones con menos características como, por ejemplo,
"xterm-r6". Véase <file>&f-libncurse;</file> para más información.  
</sect1>

<sect1>Volver la consola a su estado normal
<p>
Si la pantalla se enloquece después de hacer 
<tt>cat <var>some-binary-file</var></tt> (quizás no 
pueda ver el comando que ingresa mientras escribe) haga:
<example>
$ reset
</example>
</sect1>

<sect1 id="dos2unix">Convertir un archivo de texto en formato DOS a formato Unix
<p>
Convertir un archivo de texto en formato DOS (fin-de-línea=^M^J) 
en un archivo Unix (^J).
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1 id="recode">Convertir un archivo de texto con <prgn>recode</prgn>
<p>
Lo siguiente convertirá archivos de texto entre DOS, Mac y Unix:
<example>
$ recode /cl../cr &lt;<var>dos.txt</var> &gt;<var>mac.txt</var>
$ recode /cr.. &lt;<var>mac.txt</var> &gt;<var>unix.txt</var>
$ recode ../cl &lt;<var>unix.txt</var> &gt;<var>dos.txt</var>
</example>
<prgn>recode</prgn> convierte archivos entre diversos conjuntos de caracteres
y caracteres de control:
<example>
$ recode <var>conjcaract1</var>/<var>caracontrol1</var>..<var>conjcaract2</var>/<var>caracontrol2</var> \
  &lt;<var>entrada.txt</var> &gt;<var>salida.txt</var>
</example>
<!--Los conjuntos de caracteres más utilizados son (véase también <ref
id="base-locale">)-->
<footnote>
<prgn>recode</prgn> permite alias más convenientes que <prgn>iconv</prgn>.
</footnote>
:
<list compact>
<item><tt>us</tt> &mdash; ASCII (7 bits)
<item><tt>l1</tt> &mdash;  ISO Latin-1 (ISO-8859-1, Europa Occidental, 8 bits)
<item><tt>EUCJP</tt> &mdash; EUC-JP para Japonés (Unix)
<item><tt>SJIS</tt> &mdash; Shift-JIS para Japonés (Microsoft)
<item><tt>ISO2022JP</tt> &mdash; Codificación del correo para Japonés (7 bits)
<item><tt>u2</tt> &mdash; UCS-2 (Conjunto de caracteres universal, 2 bytes)
<item><tt>u8</tt> &mdash; UTF-8 (Formato de transformación universal, 8 bits)
</list>
Los caracteres de control más utilizados son
<footnote>
Fin de líneas:
<list compact>
<item>Retorno de carro significa ASCII 13, ASCII 0xD, ^M o \r .
<item>Avance de línea significa ASCII 10, ASCII 0xA, ^J o \n .
</list>
</footnote>
:
<!--VERIFICAR-VERIFICAR-VERIFICAR-VERIFICAR-->
<list compact>
<item><tt>/cr</tt> &mdash; Retorno de carro como fin de línea (texto Mac)
<item><tt>/cl</tt> &mdash; Retorno de carro y avance de línea como fin de
línea (texto DOS)
<item><tt>/</tt> &mdash; Avance de línea como fin de línea (texto Unix)
<item><tt>/d1</tt> &mdash; Volcado decimal
<item><tt>/x1</tt> &mdash; Volcado hexadecimal
<item><tt>/64</tt> &mdash; Texto codificado en Base64
<item><tt>/QP</tt> &mdash; Texto entrecomillado
</list>
Para más información, consulte la descripción correspondiente
haciendo <tt>info recode</tt>.
<p>
Existe también herramientas de conversión más especializadas:
<list compact>
<item>conversión de conjunto de caracteres:
<list compact>
<item><prgn>iconv</prgn> &mdash; conversiones de codificaciones locale
<item><prgn>konwert</prgn> &mdash; conversiones de codificaciones elaboradas
</list>
<item>conversión de archivos binarios:
<list compact>
<item><prgn>uuencode</prgn> y <prgn>uudecode</prgn> &mdash; para Unix.
<item><prgn>mimencode</prgn> &mdash; para el correo.
</list>
</list>

</sect1>

<sect1 id="perl-i">Sustitución de expresiones regulares
<p>
Para reemplazar todas las instancias <var>FROM_REGEX</var> por
<var>TO_TEXT</var> en todos los archivos <var>FILES</var> ...:
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_TEXT</var>/g;'
<var>FILES</var> ....
</example>
<tt>-i</tt> es para "editar en el lugar", <tt>-p</tt> significa "bucle
implícito sobre los archivos FILES ...".  Si la sustitución es compleja, la
recuperación ante posibles errores resulta más fácil usando el parámetro
<tt>-i.bak</tt> en vez de <tt>-i</tt>. De esta manera se conservará una copia
de los archivos originales a los que se les agregará la extensión
<tt>.bak</tt>.
</sect1>

<sect1>Editar un archivo con un script
<p>
El siguiente script eliminará las líneas de la 5 a la 10 y desde la 16 a la 20.
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>

Aquí, los comandos <prgn>ed</prgn> son los mismos que los del modo comando de
<prgn>vi</prgn>. La edición de archivos de esta manera facilita la creación de
scripts.
</sect1>


<sect1>Extraer diferencias y combinar actualizaciones entre archivos
fuente
<p>
Siguiendo uno de los siguientes procedimientos se extraerán las diferencias
entre dos archivos fuente y se crearán los archivos unificados diff
<var>archivo.parche0</var> o <var>archivo.parche1</var> según la ubicación
del archivo:
<example>
$ diff -u <var>archivo.original</var> <var>archivo.nuevo1</var> &gt;
<var>archivo.parche0</var>
$ diff -u <var>archivo/original</var> <var>archivo/nuevo1</var> &gt;
<var>archivo.parche1</var>
</example>
El archivo diff (llamado también parche) se utiliza para enviar
actualizaciones de programas.  La parte recibida aplicará esta actualización a
otro <var>archivo</var> mediante:
<example>
$ patch -p0 <var>archivo</var> &lt; <var>archivo.parche0</var>
$ patch -p1 <var>archivo</var> &lt; <var>archivo.parche1</var>
</example>
Si tiene tres versiones del código fuente, puede combinarlos efectivamente usando
<prgn>diff3</prgn>:
<example>
$ diff3 -m <var>archivo.mío</var> <var>archivo.original</var>
<var>archivo.tuyo</var> &gt; <var>archivo</var>
</example>
</sect1>

<sect1>Convertir un archivo grande en archivos más pequeños
<p>
<example>
$ split -b 650m <var>archivo</var>   # dividir el archivo en partes de 650 MB
$ cat x* &gt;<var>archivo_grande</var>  # unir los archivos en un archivo grande
</example>
</sect1>

<sect1>Extraer datos de una tabla contenida en un archivo de texto
<p>
Consideremos un archivo de texto llamado <file>DPL</file> en donde todos los nombres
de los líderes del proyecto &debian; y el día de su asunción están listados
separados entre sí mediante espacios.
<example>
Ian     Murdock   Agosto  1993
Bruce   Perens    Abril   1996
Ian     Jackson   Enero   1998
Wichert Akkerman  Enero   1999
Ben     Collins   Abril   2001
Bdale   Garbee    Abril   2002
Martin  Michlmayr Marzo   2003
</example>
A menudo, se utiliza Awk para extraer datos de este tipo de archivos.
<example>
$ awk '{ print $3 }' &lt;DPL                   # mes de asunción
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' &lt;DPL          # DPL llamado Ian
Ian     Murdock   Agosto  1993
Ian     Jackson   Enero   1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # Cuando Perens asumió 
Abril 1996
</example>
<p>
Los intérpretes de comandos como el Bash pueden también utilizarse para
analizar este tipo de archivo:
<example>
$ while read primero último mes año; do 
    echo $mes
  done &lt;DPL
... la misma salida que en el primer ejemplo Awk
</example>
En este caso, el comando incorporado <prgn>read</prgn> utililiza las
caracteres de $IFS (separadores de campo internos, con sus siglas en inglés)
para dividir líneas en palabras.
<p>
Si cambian IFS a ":", puede analizar perfectamente el <file>/etc/passwd</file>
con el shell:
<example>
$ originalIFS="$IFS"   # guarda el valor original
$ IFS=":"
$ while read user password uid gid resto_de_la_línea; do
    if [ "$user" = "osamu" ]; then 
      echo "el ID de $user es $uid"
    fi
  done < /etc/passwd
El ID de osamu es 1001
$ IFS="$originalIFS"   # devuelve valor anterior
</example>
(Si utiliza Awk para hacer lo mismo, utilice <tt>FS=":"</tt> para configurar
el separador de campo)
<p> 
IFS también es utilizado por el intérprete de comandos para dividir 
la espansión de parámetros, la sustitución de comandos y la expansión
aritmética. Esto no sucede con palabras entre comillas simples o dobles. 
El valor predeterminado de IFS es &lt;espacio&gt;, &lt;tab&gt; y
&lt;nueva_línea&gt; combinados.
<p>
Sea cuidadoso al usar estos trucos con el IFS del intérprete de comandos.
Pueden ocurrir cosas extrañas cuando el shell interpreta parte de un script
como si se fuese su <strong>entrada</strong>.
<example>
$ IFS=":,"                        # utiliza ":" y "," como IFS
$ echo IFS=$IFS,   IFS="$IFS"     # echo es un comando del Bash
IFS=  , IFS=:,
$ date -R                         # simplemente la salida de un comando
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # subshell --&gt; entrada al shell principal
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # volver al IFS predeterminado
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200

</example>
</sect1>

<sect1 id="scrp-snip">Pequeños scripts que incluyen tuberías
<p>
Los siguientes scripts realizan tareas útiles utilizando tuberías.
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # encontrar todos los archivos en /usr
                     # excluyendo algunos archivos
xargs -n 1 <var>command</var>   # ejecutar comando para todos los ítems de la stdin
xargs -n 1 echo|     # escribir ítems separados por espacios en blanco
                     # en renglones
grep -e <var>patrón</var>|      # extraer líneas con un determinado
<var>patrón</var>
cut -d: -f3 -|       # extraer el tercer campo separado por :  
                     # (archivo passwd, etc.)
awk '{ print $3 }' | # extraer el tercer campo separado por espacios en blanco
awk -F'\t' '{ print $3 }' |
       # extaer el tercer campo separado por tabulaciones
col -bx |            # eliminar retrocesos y convertir tabulaciones en
                     # espacios
expand -|            # transformar las tabulaciones
sort -u|             # ordenar y eliminar duplicados
tr '\n' ' '|         # concatenar líneas en una sola línea
tr '\r' ''|          # eliminar CR (retornos de carro)
tr 'A-Z' 'a-z'|      # convertir mayúsculas en minúsculas
sed 's/^/# /'|       # transformar cada línea en un comentario
sed 's/\<var>.ext</var>//g'|    # eliminar <var>.ext</var>
sed  -n -e 2p|       # mostrar la segunda línea 
head -n 2 -|         # mostrar las primeras 2 líneas
tail -n 2 -|         # mostrar las últimas 2 líneas
</example>
</sect1>

<sect1>Pequeños scripts para recorrer distintos archivos
<p>
Las siguientes maneras de recorrer distintos archivos que coincidan con
<tt>*.<var>ext</var></tt> asegura un correcto manejo de nombres de archivos
extraños -como los que incluyen espacios- y realizan la misma tarea:
<list>
<item>Bucle del shell (esta es una entrada de múltiples líneas con <tt>PS2="&gt; "</tt>)
<footnote>
Si la escribe en una sóla línea, necesita añadir algunos punto y comas, "<tt>;</tt>",
para marcar el final de los comandos del shell.
</footnote>:
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>comando</var> "$<var>x</var>"
  fi
done
</example>
<item>Combinación de <prgn>find</prgn> y <prgn>xargs</prgn>:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>comando</var>
</example>
<item><prgn>find</prgn> con la opción <tt>-exec</tt> y un comando:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>comando</var> '{}' \;
</example>
<item><prgn>find</prgn> con la opción <tt>-exec</tt> y un script de shell
breve:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>comando</var> '{}' && echo 'exitoso'" \;
</example>
</list>

</sect1>

<sect1 id="perl-mad">La locura de los script cortos en Perl
<p>
Aunque todos los scripts en Awk se pueden reescribir automáticamente en Perl
usando <manref name="a2p" section="1">, los scripts Awk de una sola línea en
Awk se convierten mejor en scripts en perl de una línea en forma manual. Por
ejemplo
<example>
awk '($2=="1957") { print $3 }' |
</example>
es equivalente a cualquiera de las siguientes líneas:
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
Se pueden eliminar todos los espacios en los argumentos de <prgn>perl</prgn> de la línea
anterior y tomar ventaja de la conversión automática entre números y cadena de
caracteres que existe en Perl:
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
Véase <manref name="perlrun" section="1"> para las opciones de la línea de
comandos. Para más scripts delirantes en Perl, puede resultar interesante
<url id="&perlgolf;">.
</sect1>

<sect1>Obtener el texto de una página web o del archivo de una lista de
correos
<p>
Lo siguiente leerá una página web como un archivo de texto.  Resulta muy
útil cuando se desea copiar configuraciones que se obtienen de la red.
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var>
&gt;<var>archivo_de_texto</var>
</example>
Aquí también se pueden usar <prgn>links</prgn> y <prgn>w3m</prgn>, con ligeras
diferencias en el renderizado.
<p>
Si se trata de un archivo de una lista de correo, use <tt>munpack</tt> para
obtener los contenidos mime del texto.
</sect1>

<sect1>Impresión de una página web
<p>
Lo siguiente imprimirá una página web en una impresora/archivo PostScript.  
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Véase <ref id="lprlpd">.  También tenga en cuenta los paquetes <prgn>a2ps</prgn> y
<prgn>mpage</prgn> para crear archivos PostScript.
</sect1>

<sect1>Impresión de la página una página del manual
<p>
Lo siguiente imprimirá una página manual en una impresora/archivo PostScript.  
<example>
$ man -Tps <var>alguna-página-del-manual</var> | lpr
$ man -Tps <var>alguna-página-del-manual</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Combinar dos archivos PostScript o PDF
<p>
Es posible combinar dos archivos PostScript o PDF.
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
-sOutputFile=<var>bla.ps</var> -f \
<var>loquesea1.ps</var> <var>loquesea2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>loquesea1.pdf</var>\
  <var>loquesea2.pdf</var>
</example>
</sect1>

<sect1>El tiempo de un comando
<p>
Mostrar el tiempo empleado por un proceso.
<example>
# time <var>algún-comando</var> &gt;/dev/null
real    0m0.035s       # tiempo de reloj (tiempo real transcurrido)
user    0m0.000s       # tiempo en modo usuario
sys     0m0.020s       # tiempo en modo kernel
</example>
</sect1>

<sect1>El comando <prgn>nice</prgn> 
<p>
Use <prgn>nice</prgn> (del paquete GNU <package>shellutils</package>) para
fijar el valor "nice" de un comando al ejecutarlo. <prgn>renice</prgn>
(<package>bsdutils</package>) y <prgn>top</prgn> puede modificar el valor
"nice" de un proceso. El proceso más lento tiene el valor 19 (prioridad más
baja); los valores negativos son "not-nice". El valor -20 lo tiene el proceso
más veloz (prioridad alta). Sólo el superusuario puede fijar valores "nice"
negativos.
<example>
# nice  -19 top                                         # muy lento
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img # muy rápido
</example>
A veces un valor extremo de nice hace más daño que bien al sistema.
Utilice este comando con cuidado.
</sect1>

<sect1 id="cronjob">Planificar una actividad (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Use <prgn>cron</prgn> y <prgn>at</prgn> para planificar tareas en Linux.
Véase <manref name="at" section="1">, <manref name="crontab"
section="5">, <manref name="crontab" section="8">. 
<p> 
Ejecute el comando <tt>crontab -e</tt> para crear o editar el archivo
crontab para configurar eventos planificados. Ejemplo de un archivo
crontab:
<example>
# utilice /bin/sh para ejecutar los comandos sin importar lo que dice el
# /etc/passwd
SHELL=/bin/sh
# envíe un mensaje a `pablo' sin importar a quien pertenece el crontab
MAILTO=pablo
# Minuto Hora Día_del_mes Mes Día_de_la_semana comando
# ejecutar todos los días a las 00:05
5  0  *  * *   $HOME/bin/tarea.diaria &gt;&gt; $HOME/tmp/salida 2&gt;&amp;1
# ejecutar a las 14:15 el primer día de cada mes -- enviar salida a Pablo
15 14 1  * *   $HOME/bin/mensual
# ejecutar a las 22:00 todos los días hábiles (1-5), molestar a José. 
# &percnt; para nueva línea, el último &percnt; para cc:
0 22 *   * 1-5 mail -s "Son las 10 de la noche" josé&percnt;José:&percnt;&percnt;¿Dónde están
                        los chicos?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "ejecutar el 1 de febrero a los 23 minutos después
                     de 0am, 2am, 4am ..."
5  4 *   * sun echo "ejecutar todos los domingos a las 04:05"
# ejecutar a las 03:40 el primer lunes de cada mes
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && comando -args
</example>
Ejecutar el comando <prgn>at</prgn> para planificar una tarea una sola vez:
<example>
$ echo 'command -args'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Intercambiando consolas con <prgn>screen</prgn>
<p>
El programa <prgn>screen</prgn> permite ejecutar <strong>múltiples</strong>
terminales virtuales, cada una con su intérprete de comandos interactivo, en
una única terminal física o ventana que emule un terminal. Incluso si utiliza
consolas virtuales Linux o múltiples ventanas <prgn>xterm</prgn>, merece la
pena experimentar con <prgn>screen</prgn> por sus amplias funcionalidades que
incluye:
<list compact>
<item>navegación por el histórico de comandos, 
<item>copiar y pegar, 
<item>registro de accesos al sistema, 
<item>entrada de caracteres especiales y 
<item>la capacidad de <strong>separar</strong> una sesión entera de
<prgn>screen</prgn> del terminal para recuperarla posteriormente. 
</list>
<sect2>Acceso remoto
<p>
Si frecuentemente se conecta a una máquina Linux desde un terminal remoto o
usando el terminal VT100, <prgn>screen</prgn> le facilitará muchísimo
las cosas.
<p>
<enumlist compact>
<item>Supongamos que estamos conectado a la red mediante una conexión
telefónica ejecutando una sesión compleja de <prgn>screen</prgn> con editores
y otros programas abiertos en diversas ventanas. 
<item>De repente necesita abandonar su terminal, pero no deseamos perder
nuestro trabajo al colgar la línea. 
<item>Simplemente teclee <tt>^A d</tt> para <strong>separar</strong> las
sesión y desconéctese (o aún más rápido, teclee <tt>^A DD</tt> para que
<prgn>screen</prgn> se separe y se desconecte por sí misma) 
<item>Cuando se conecte nuevamente, escriba el comando <tt>screen -r</tt> y
<prgn>screen</prgn> mágicamente automáticamente <strong>recuperará</strong>
todas las ventanas que había abierto. 
</enumlist>

<sect2>Comandos de <prgn>screen</prgn> típicos 
<p>
Una vez que arranca <prgn>screen</prgn> toda la entrada de datos que se hace a
través del teclado se envía a la ventana actual excepto la combinación de
teclas de comando, por defecto <tt>^A</tt>. Todos los comandos de
<prgn>screen</prgn> se ingresan escribiendo <tt>^A</tt> seguido de una sola
tecla [y eventualmente algunos parámetros]. Algunos comandos útiles:
<example>
^A ?     mostrar ventana de ayuda (muestra las asociaciones de teclas)
^A c     crear una nueva ventana y cambiar a ella
^A n     ir a la siguiente ventana
^A p     ir a la ventana anterior
^A 0     ir a la ventana número 0
^A w     mostrar la lista de ventanas
^A a     enviar un Ctrl-A a la ventana actual como entrada del teclado
^A h     grabar una copia de la ventana actual a un archivo 
^A H     comenzar/finalizar la grabación de ventana actual en un archivo
^A ^X    bloquear la terminal (protegida con contraseña)
^A d     separar una sesión del terminal
^A DD    separar una sesión y salir
</example>
<p>
Éste es sólo una pequeña muestra de los comandos y características de
<prgn>screen</prgn>. Si hay algo que desea que <prgn>screen</prgn> haga,
¡existe una gran posibilidad que pueda hacerlo!.  <manref name="screen"
section="1"> para más detalles.
<sect2>Tecla de retroceso y/o Ctrl-H en un sesión de <prgn>screen</prgn>
<p>
Si comprueba que la tecla de retroceso y/o Ctrl-H no
funciona correctamente cuando ejecuta <prgn>screen</prgn>, edite el
archivo <file>/etc/screenrc,</file> localice la línea
<example>
bindkey -k kb stuff "\177"
</example>
y coméntela (es decir, agréguele el carácter "#" al principio). 

<sect2>Programa para X equivalente a <prgn>screen</prgn>
<p>
Consulte <prgn>xmove</prgn>.  Véase <manref name="xmove" section="1">.

</sect1>


<sect1 id="net-test">Probando la red
<p>
Instale  
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (para el kernel 2.2),
<package>iptables</package> (para el kernel 2.4 ) y el paquete
<package>net-tools</package>:
<example>
$ ping <var>yahoo.com</var> # verificar la conexión a Internet
$ traceroute yahoo.com      # rastrear paquetes IP
$ ifconfig                  # verificar la configuración del 
                            # anfitrión (host)
$ route -n                  # verificar la configuración de la ruta
$ dig [@dns-server.com] host.dom [{a|mx|any}] |less
      # verificar registros host.dom DNS [@ dns-server.com] para  
      # un registro <var>{a|mx|any}</var>
$ ichains  -L -n |less      # verificar filtrado de paquetes (kernel 2.2)
$ iptables -L -n |less      # verificar filtrado de paquetes (kernel 2.4)
$ netstat -a                # mostrar todos los puertos abiertos
$ netstat -l --inet         # mostrar los puertos en escucha
$ netstat -ln --tcp         # mostrar puertos tcp en escucha (numérico)
</example>
</sect1>

<sect1>Eliminar mensajes de la cola local
<p>
Para eliminar los mensajes de la cola local:
<example>
# exim -q    # eliminar mensajes en espera
# exim -qf   # eliminar todos los mensajes
# exim -qff  # eliminar incluso mensajes bloqueados
</example>
"-qff" puede resultar mejor para el script /etc/ppp/ip-up.d/exim.
Para Sarge, reemplace <prgn>exim</prgn> con
<prgn>exim4</prgn>.
</sect1>

<sect1 id="remove-mail">Eliminar mensajes bloqueados de la cola local
<p>
Para eliminar mensajes de correo bloqueados de la cola local
reenviando el mensaje de error:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
Para Sarge, reemplace <prgn>exim</prgn> por <prgn>exim4</prgn>
</sect1>

<sect1>Redistribuir los contenidos de <file>mbox</file> 
<p>
Si se llenó su directorio personal y <prgn>procmail</prgn> falló  necesitará
distribuir en forma manual sus mensajes de
<file>/var/mail/<var>usuario</var></file> a los buzones de correo situados en
su directorio personal. Luego de hacer espacio en el mismo, haga:
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>usuario</var>
# /etc/init.d/exim start
</example>
Para Sarge, reemplace <prgn>exim</prgn> por <prgn>exim4</prgn>.
</sect1>

<sect1>Borrar el contenido de un archivo
<p>
Para borrar el contenido de un archivo (un archivo log, por ej.) no utilice
<tt>rm</tt> para eliminarlo y <tt>mkdir</tt> para crealo nuevamente, ya que el
archivo puede estar siendo consultado en el intervalo comprendido entre la
ejecución de ambos comandos. Lo siguiente es la manera más segura de borrar el
contenido de un archivo. 
<example>
$ :&gt;<var>archivo-a-eliminar</var>
</example>
</sect1>

<sect1 id="dummyfile">Archivos fantasma
<p>
Los siguientes comandos creará archivos fantasmas (archivos vacíos):

<example>
$ dd if=/dev/zero  of=<var>nombre_archivo</var> bs=1k count=5 # 5KB de
                                                              # contenido
                                                              # cero
$ dd if=/dev/urandom of=<var>nombre_archivo</var> bs=1M count=7 # 7MB de
                                                                # contenido
                                                                # al azar
$ touch <var>nombre_archivo</var>  # crear un archivo de 0B (si el archivo
                                   # existe actualizar mtime)
</example>
Por ejemplo, los siguientes comandos ejecutados desde el shell de un disco de
arranque &debian; borrará íntegramente el contenido del disco duro
<file>/dev/hda</file>.
<example>
# dd if=/dev/urandom of=/dev/hda ; dd if=/dev/zero of=/dev/hda
</example>

</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
El programa <prgn>chroot</prgn>, <manref name="chroot" section="8">, nos
permite ejecutar diferentes instancias de un entorno GNU/Linux en un único
sistema, simultáneamente y sin reiniciar.
<p>
Asimismo, uno puede ejecutar un programa que insuma gran cantidad de recursos
(por ejemplo, <prgn>apt-get</prgn> o <prgn>dselect</prgn>) bajo el chroot de
una máquina anfitrión veloz, montando en ella una máquina auxiliar lenta
(máquina satélite) mediante NFS en modo lectura/escritura, siendo el punto de
montaje el directorio chroot.

<sect2 id="chroot-debian">Ejecutar distintas versiones de &debian; mediante
<prgn>chroot</prgn>
<p>
Un entorno chroot &debian; se puede crear en Woody fácilmente mediante el
comando <prgn>debootstrap</prgn>. Por ejemplo, para crear un chroot Sid en
<var>/sid-root</var> con una conexión de Internet rápida:
<example>
main # cd / ; mkdir <var>/sid-root</var>
main # debootstrap sid <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... observe descargar todo el sistema
main # echo "proc-sid <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount proc-sid <var>/sid-root</var>/proc -t proc
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # cd /dev; /sbin/MAKEDEV generic ; cd -
chroot # apt-setup # configurar /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # apuntar a la rama inestable
chroot # dselect  # puede usar aptitude, instalar mc y vim :-)
</example>
<p>
A esta altura, debería tener un sistema &debian; totalmente funcional, donde
podrá jugar sin temor de afectar su instalación &debian; principal.
<p>
Este truco con <prgn>debootstrap</prgn> se puede utilizar para instalar &debian;
en un sistema sin usar &debian; install disk but using one for
another GNU/Linux distribution.  Véase <url id="&setup-chroot;">.

<sect2 id="chroot-console">Configurar el acceso para <prgn>chroot</prgn>
<p>
Escribir <tt>chroot <var>/sid-root</var> /bin/bash</tt> es fácil, pero
conserva toda clase de variables de entorno que quizás no desee y acarrea
otros problemas. Un mejor enfoque consiste en ejecutar otro proceso login en
una terminal virtual aparte donde pueda entrar al sistema chroot directamente.
<p>
Puesto que, en los sistemas &debian; predeterminados, las consolas Linux se 
ejecutan desde <tt>tty1</tt> hasta <tt>tty6</tt> y el sistema X Window se
ejecuta en <tt>tty7</tt>, configuremos, como ejemplo, una consola chroot en 
<tt>tty8</tt>.  Luego de crear un sistema chroot como se explicó en <ref
id="chroot-debian">, escriba desde el shell del superusuario en el sistema
principal:
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8"  >> /etc/inittab
main # init q    # vuelve a cargar init
</example>

<sect2 id="chroot-x">Configurando X para <prgn>chroot</prgn>
<p>
¿Desea ejecutar la última versión de X y Gnome en forma segura en su chroot? 
¡Es perfectamente posible!  El siguiente ejemplo hará que GDM se ejecute en un 
terminal virtual <tt>vt9</tt>.
<p>
Primero instale el sistema chroot usando el método descripto en  
<ref id="chroot-debian">.  Siendo superusuario en el sistema principal, copie
los archivos de configuración claves en el sistema chroot.
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # o utilice la consola chroot
chroot # cd /dev; /sbin/MAKEDEV generic ; cd -
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # haga s/vt7/vt9/ en la sección [servers]
chroot # /etc/init.d/gdm start
</example>
En este caso, se editó <file>/etc/gdm/gdm.conf</file> para que la consola 
virtual inicial sea <tt>vt9</tt> en vez de <tt>vt7</tt>.
<p>
A partir de ahora, puede fácilmente alternar entre el entorno X del chroot
y su sistema principal simplemente cambiando de terminal virtual; por ejemplo,
usando Ctrl-Alt-F7 y Ctrl-Alt-F9. ¡Que se diviertan!
<p>
[FIXME] Añadir un comentario y enlace al script init del <prgn>gdm</prgn> del chroot.

<sect2 id="chroot-dist">Ejecutar otra distribución con <prgn>chroot</prgn>
<p>
Se puede crear fácilmente un entorno chroot para otra distribución Linux.
Instale un sistema en una partición aparte usando el instalador de otra
distribución. Si su partición raíz se encuentra en 
<file><var>/dev/hda9</var></file>: 
<example>
main # cd / ; mkdir <var>/otra-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/otra-dist</var>
main # chroot <var>/otra-dist</var> /bin/bash
</example>
Luego proceda como en <ref id="chroot-debian">, <ref
id="chroot-console"> y <ref id="chroot-x">.

<sect2 id="chroot-build">Compilar un paquete con <prgn>chroot</prgn>
<p>
Existe un paquete chroot más sofisticado, <package>pbuilder</package>,
que crea un sistema chroot y compila un paquete dentro de él. Es un 
sistema ideal para verificar que las dependencias de compilación de un
paquete sean correctas y para estar seguros que no existan dependencias
innecesarias o erróneas en el paquete resultante.
</sect1>
<sect1>Cómo verificar los enlaces duros
<p>
Puede ver si dos archivos son uno solo con dos enlaces duros, haciendo:
<example> 
$ ls -li <var>archivo1</var> <var>archivo2</var>
</example>
 
<sect1>Montar una imagen del disco duro
<p>
Si <file><var>archivo.img</var></file> contiene una imagen de los contenidos
de un disco duro y el disco original tenía una configuración
<var>xxxx</var> = (bytes/sector) * (sectores/cilindro),
entonces lo siguiente la montará en <file>/mnt</file>:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>archivo.img</var> /mnt
</example>
Obsérvese que la mayoría de los discos duros tienen 512 bytes/sector.

<sect1 id="smbmount">Samba
<p>
Lo básico para obtener archivos desde Windows:
<example>
# mount -t smbfs -o <var>username=mi_nombre,uid=mi_uid,gid=mi_gid</var> \
    <var>//server/share /mnt/smb</var>  # monta un directorio Windows en Linux
# smbmount <var>//server/share /mnt/smb</var> \
  -o "<var>username=mi_nombre,uid=mi_uid,gid=mi_gid</var>"
# smbclient -L <var>192.168.1.2</var> # lista los archivos compartidos de una
                                      # máquina
</example>                                    
<p>
Los vecinos de Samba se pueden localizar desde Linux haciendo:
<example>
# smbclient -N -L <var>dirección_ip_de_su_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>Utilidades para otros sistemas de archivos
<p>
El kernel de Linux soporta diversos sistemas de archivos. Por lo
tanto, se puede acceder a ellos montando los dispositivos que los contienen.
Para determinados sistemas de archivos, existen algunas
herramientas especializadas para acceder a ellos sin tener que montar los
correspondientes dispositivos. Estas operaciones se realizan por programas del
espacio del usuario, con lo cual no se necesita el soporte de sistemas de
archivos del kernel. 
<list compact>
<item><package>mtools</package>: para sistemas de archivos MSDOS (MS-DOS, Windows)
<item><package>cpmtools</package>: para sistemas de archivos CP/M
<item><package>hfsutils</package>: para sistemas de archivos HFS (Macintosh
nativo)
<item><package>hfsplus</package>: para sistema de archivos HFS+ (Macintosh
moderno)
</list>
<package>dosfstools</package> resulta útil para crear y verificar sistemas de
archivos FAT MS-DOS..
</sect1>

</sect>
<sect id="oops">Errores típicos a tener presente

<p>
Veamos algunos ejemplos de acciones peligrosas. El impacto negativo será mayor
si utiliza la cuenta con privilegios de <tt>superusuario</tt>.

<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>

<!-- 
I know using quotes here are irregular but it is hard to read without it. 
-->
En "<tt>rm -rf .*</tt>", el "<tt>.*</tt>" se expande para incluir "<tt>.</tt>"
y "<tt>..</tt>", y si por casualidad tiene privilegios para escribir en el
directorio padre, terminará por eliminar todos los directorios
<strong>next</strong> to your current directory as well.
<p>
<list compact>
<item>"<tt>rm -rf .</tt>" : borra todo lo que se encuentra en el directorio
actual incluyendo el propio directorio.
<item>"<tt>rm -rf *</tt>" : borra todos los archivos y directorios del
directorio actual (excluyendo los que comienzan con un punto)
<item>"<tt>rm -rf .[^.]*</tt>" : borra todos los archivos punto y los
directorios normales del directorio actual.
<item>"<tt>rm -rf .*</tt>" : borra todo del directorio padre y al propio
directorio.
</list>

<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
Es difícil la pérdida de algunos archivos importantes como
<file>/etc/passwd</file> por descuido.  El sistema &debian; realiza copias de
seguridad regulares de ellos en <file>/var/backups/</file>.  Al restaurar
estos archivos, tiene que configurar manualmente los permisos adecuados.
<example>
# cp /var/backups/passwd /etc/passwd
# chmod 644 /etc/passwd
</example>
Véase también <ref id="recover-status">.

</chapt>

