<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.22.4.3"  -->

<chapt id="tips"> Trucos para &debian; 

<![%FIXME[<p>===Proof reading: DONE by dsew ===]]>

<sect>Arrancando el sistema
<p>
Véase el BootPrompt-HOWTO (LDP) para información detallada sobre el
indicador de arranque.

<sect1 id="crackroot">"¡Olvidé la contraseña de superusuario!" (1)
<p>
Es posible arrancar el sistema y acceder a la cuenta de superusuario sin
conocer la contraseña siempre y cuando se tenga acceso al teclado de la
consola (esto supone que ni la BIOS ni un cargador de arranque como
<prgn>lilo</prgn> solicitan una contraseña para evitar el arranque del
sistema)
<p>
Este es un procedimiento que no requiere de discos de arranque externos
ni cambios en los parámetros de arranque de la BIOS. Aquí, "Linux" hace
referencia al kernel de Linux de la instalación predeterminada de
Debian.
<p>
En el pantalla de arranque de <prgn>lilo</prgn>, cuando aparece
<tt>boot:</tt> (en algunos sistemas debe presionar la tecla Mayús para
evitar el arranque automático) escriba:
<example>
boot: Linux init=/bin/sh
</example>
Esto hará que el sistema arranque el kernel y ejecute el
<file>/bin/sh</file> en vez del estándar <prgn>init</prgn>.  Ahora
tenemos privilegios de superusuario y acceso al intérprete de comandos.
Puesto que <file>/</file> generalmente está montado en modo sólo lectura
y aún no han sido montadas las distintas particiones, debe hacer lo
siguiente para tener un sistema que funcione razonablemente.
<example>
init-2.03# mount -n -t remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(si el segundo campo de datos en el <file>/etc/passwd</file> es una "x"
para cada nombre de usuario, su sistema utiliza contraseñas ocultas y
debe editar el archivo <file>/etc/shadow</file>) Para desactivar la
contraseña de root, edite el segundo campo de datos en el archivo de
contraseñas de modo que quede vacío.  Ahora se puede reiniciar el
sistema y entrar como root sin contraseña.  A diferencia de algunas
distribuciones Linux antiguas, la Debian actual (Potato) requiere de
contraseña sólo cuando arranca en el nivel de ejecución 1.
</sect1>

<sect1>"¡Olvidé la contraseña de superusuario!" (2)
<p>
Arranque desde un disco de emergencia.  Si <file>/dev/hda3</file> es la
partición raíz original, lo siguiente le permitirá editar el archivo de
contraseñas tan fácilmente como antes.
<example>
# mkdir fixit
# mount /dev/hda3 fixit
# cd fixit/etc
# vi shadow
# vi passwd
</example>
<p>
La ventaja de este enfoque sobre el anterior es que no se necesita
conocer la contraseña de <prgn>lilo</prgn> (si existe).  Pero para
usarlo uno debe ser capaz de poder acceder a la configuración de la BIOS
para permitir arrancar el sistema desde un disquete o CD si es que ya no
está configurada como tal.
</sect1>

<sect1>No puedo arrancar el sistema
<p>
Si se tomó la molestia de crear un disco de arranque durante la
instalación, no habrá ningún problema.  Si <prgn>lilo</prgn> se
encuentra dañado, grabe el disco de arranque desde el disco de
instalación de debian y arranque el sistema con él. En el indicador de
arranque, suponiendo que la partición raíz de su instalación Linux es
<file>/dev/hda12</file> y que desea entrar al nivel de ejecución 3,
escriba:
<example>
boot: rescue root=/dev/hda12 3
</example>
De esta manera arrancará con un sistema prácticamente funcional usando el
kernel del disquete (pueden existir pequeños inconvenientes debido a la
falta de algunas características o módulos del kernel). 
<p>
Si necesita un disquete de arranque personalizado, 
consulte el <prgn>readme.txt</prgn> sobre el disco de rescate.
</sect1>

<sect1 id="bootprompt">Otros trucos con el indicador de arranque
<p>
El sistema se puede arrancar en un nivel de ejecución particular
y con una configuración determinada usando el indicador de arranque
de <prgn>lilo</prgn>. Para más detalles consulte el
BootPrompt-HOWTO (LDP).
<p>
Si desea arrancar el sistema en el nivel de ejecución cuatro, use la
siguiente entrada para el indicador de arranque de <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Si desea arrancar el sistema en modo monousuario y conoce la contraseña
de superusuario, algunos de los siguientes ejemplos funcionará usando el
indicador de arranque de <prgn>lilo</prgn>.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Si desea arrancar el sistema con menos memoria de la que realmente posee
el sistema (por ejemplo, 48MB en un sistema con 64MB), use la siguiente
entrada para el indicador de arranque de <prgn>lilo</prgn>:
<example>
boot: Linux mem=48M
</example>
Asegúrese de no especificar un valor mayor al tamaño de memoria real ya
que si es así el kernel se colgará.  Los núcleos antiguos y/o las placas
madres con una BIOS antigua no usan la memoria por encima de los 64 MB,
salvo que uno escriba <tt>mem=128M</tt> en el indicador de arranque o
incluya una línea similar en el <file>/etc/lilo.conf</file>.
</sect1>
</sect>

<sect>Registro de actividades
<sect1 id="script">Registrando las actividades del intérprete de comandos
<p>
La administración del sistema implica tareas mucho más elaboradas en un
entorno Unix que un entorno común de una computadora personal. Asegúrese
de saber lo básico sobre configuración por si acaso necesita recuperar
el sistema de algún problema. Las herramientas de configuración con GUI
basadas en X-Window son agradables y convenientes pero a menudo
inapropiadas en situaciones de emergencia.
<p>
En este contexto, el registro de las actividades del intérprete de
comandos resulta ser una buena práctica especialmente como superusuario.
<p>
Emacs: utilice <tt>M-x shell</tt> para empezar a grabar en el búfer y
<tt>C-x C-w</tt> para escribir el contenido del mismo en un archivo.
<p>
Intérprete de comandos: utilice el comando <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 ... hacer cualquier cosa ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
Se puede utilizar lo siguiente en vez del comando <prgn>script</prgn>:
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>
<sect1>Registrando las actividades en X
<p>
Si necesita registrar la imagen de una aplicación X, incluyendo una
terminal xterm, utilice <prgn>gimp</prgn> (GUI).  Puede capturar cada
ventana o la totalidad de la pantalla. Otras alternativas son
<prgn>xwd</prgn> (<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>) o <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>
</sect>

<sect>Copiar y archivar un subdirectorio entero
<sect1>Comandos básicos para copiar un subdirectorio entero
<p>
Si necesita reordenar la estructura de archivos, mueva el contenido
incluyendo los enlaces a archivos mediante:
<example>
Método estándar:
# cp -a /directorio/fuente /directorio/destino # debe ser GNU
# (cd /directorio/fuente &amp;&amp; tar cf - . ) | \
        (cd /directorio/destino &amp;&amp; tar xvfp - )
Si existen enlaces duros, se necesita un método más elaborado:
# cd /ruta/al/directorio/original
# find . -depth -print0 | afio -p -xv -0a
# /punto/de/montaje/del/nuevo/directorio
En el caso de una conexión remota:
# (cd /directorio/fuente &amp;&amp; tar cf - . ) | \
    ssh usuario@host.dom (cd /directorio/destino &amp;&amp; tar xvfp - )
Si no hay archivos enlazados:
# scp -pr usuario1@host1.dom:/directorio fuente \
          usuario2@host2.dom:/directorio/destino
</example>
En este caso, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> y <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
El método para copiar un subdirectorio entero está basado en la
información proporcionada por Manoj Srivastava
&lt;srivasta@debian.org&gt; de la lista debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Inicialmente, cp no resultaba ser el candidato correcto ya que no
desreferenciaba enlaces simbólicos ni tampoco preservaba enlaces duros.
Otra cosa a considerar eran los archivos de tamaño muy pequeño.
<p>
GNU cp ha superado estas limitaciones. No obstante en sistemas que no
son GNU cp puede aún tener problemas. Asimismo, no se pueden generar
archivos portables pequeños usando cp.
<example>
% cp -a . directorio_nuevo
</example>

<sect1><prgn>tar</prgn>
<p>
Tar soluciona algunos de los problemas que tenía cp con los enlaces
simbólicos. Sin embargo, `cpio' maneja archivos especiales que el `tar'
tradicional no puede manejar.
<p>								
`tar' maneja múltiples enlaces duros colocando una única copia de un
enlace en la cinta. El nombre asignado a dicha copia es el
<em>único</em> que se puede usar para recuperar el archivo. En cambio,
`cpio' coloca una copia de cada enlace de manera que para recuperar el
archivo se puede utilizar el nombre de cualquiera de ellas.
</sect1>

<sect1><prgn>pax</prgn>
<p>
Es la nueva utilidad para archivar, portable y compatible POSIX (IEEE Std
1003.2-1992, páginas 380-388 (sección 4.48) y páginas 936-940 (sección
E.4.48)).  Pax lee, escribe y lista los componentes de un directorio y
copia la jerarquía de los mismos.  La operación pax es independiente del
formato específico del archivo y admite una amplia variedad de formatos.
<p>
Las implementaciones de pax son aún nuevas y están en pleno desarrollo.
<example>
$ pax -rw -p e . directorio_nuevo
 o
$ find . -depth  | pax -rw -p e  directorio_nuevo
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
Cpio almacena o extrae archivos en o de un archivo tar o cpio. El
archivo puede ser otro archivo del disco, una cinta magnética o una
tubería.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
Afio es una mejor forma de tratar con archivos con formato cpio.
Generalmente es más rápido que cpio, proporciona más opciones para
utilizar con cintas magnéticas y maneja mejor la corrupción de los datos
de entrada.  Admite archivos multi-volumen durante su operación
interactiva.  Afio puede crear archivos empaquetados que son mucho más
seguros que los empaquetados con tar o cpio.  En un script, para
realizar una copia de seguridad, afio tiene un comportamiento óptimo
como 'motor para archivar'.
<example>
$ find . -depth -print0 | afio -px -0a directorio_nuevo
</example>
Para crear todas mis copias de respaldo en una cinta uso afio. 
</sect1>

</sect>

<sect>Modificar archivos con la sustitución de expresiones regulares
<p>
Para reemplazar todas las instancias FROM_REGEX por TO_REGEX en todos
los archivos FILES ...:
<example>
# perl -i -p -e 's/FROM_REGEX/TO_REGEX/g;' FILES ...
</example>
<tt>-i</tt> es para "editar en el lugar", <tt>-p</tt> significa "bucle
implícito sobre los archivos FILES ...".  Si la sustitución es compleja,
la recuperación ante posibles errores resulta más fácil usando el
parámetro <tt>-i.bak</tt> en vez de <tt>-i</tt>. De esta manera se
conservará una copia de los archivos originales a los que se les
agregará la extensión <tt>.bak</tt>.
</sect>
<sect>Recuperar al sistema de un cuelgue
<sect1>Mate el proceso
<p>
Ejecute <prgn>top</prgn> para ver cuál es el proceso que está actuando
de manera extraña. Pulse "P" para ordenar por tiempo de cpu, "M" para
ordenar por uso de memoria y "k" para matar un proceso.
<p>
Utilice <prgn>kill</prgn> junto el ID del proceso para matar (o enviar
una señal a) un proceso, <prgn>killall</prgn> para hacer lo mismo pero
usando el nombre del comando.  Señales de uso habitual:
<example>
 1: HUP,  reiniciar demonio
15: TERM, terminar un proceso en forma normal
 9: KILL, matar un proceso sin contemplaciones
</example>

</sect1>

<sect1>ALT-SysRq
<p>
La opción de compilación del kernel "Magic SysRq key" proporciona una
protección contra el mal funcionamiento del sistema.  Pulsando
<tt>ALT-SysRq</tt> en una i386 y a continuación una de las teclas <tt>r
0 k e i s u b</tt> se obtiene el pase mágico.
<p>
Un<tt>R</tt>aw restaura el teclado tras el cuelgue de X.  Modifique el
nivel de registro de la consola con <tt>0</tt> para reducir los mensajes
de error. sa<tt>K</tt> (tecla de atención del sistema) mata a todos los
procesos en la consola virtual actual.  t<tt>E</tt>rminate mata a todos
los procesos de la terminal actual salvo init.  k<tt>I</tt>ll mata a
todos los procesos incluyendo a init.  <p> <tt>S</tt>ync (sincronizar),
<tt>U</tt>mount (desmontar), y re<tt>B</tt>oot (reiniciar) a menudo se
utilizan en el caso de situaciones realmente complicadas.
<p>
En el momento de escribir este documento, los núcleos que vienen con la
instalación predeterminada de Debian no han sido compilados con esta
opción. Recompile el kernel para activarla. Se puede encontrar
información detallada en:
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>

<sect>Archivos de configuración


<sect>Algunos pequeños comandos útiles para tener en cuenta
<sect1>Memoria disponible
<p>
<prgn>free</prgn> y <prgn>top</prgn> brindan una buena información sobre
los recursos de memoria disponibles. No se preocupe por el tamaño que
figura bajo "used" de la línea "Mem:" sino por el valor que se encuentra
justo debajo de él (38792 en el siguiente ejemplo). 
<example>
$ free -k # para una máquina con 256MB
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
La cantidad de memoria física exacta se puede confirmar haciendo
<tt>grep '^Memory' /var/log/dmesg</tt>. En este caso arroja el siguiente
resultado:
"Memory: 256984k/262144k available (1652k kernel
code, 412k reserved, 2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
El sistema no puede usar cerca de 5MB ya que lo utiliza el propio kernel.
</sect1>

<sect1>Configurar fecha y hora (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Esto fijará la fecha y hora del sistema y del hardware en MM/DD hh:mm,
CCYY.  La hora se muestra según el huso horario local pero el hardware
utiliza el UTC.
<p>
Configure el reloj del sistema para corregir la fecha y hora en forma
automática mediante un servidor remoto:
<example>
# ntpdate &lt;server&gt;
</example>
Si su sistema posee una conexión a Internet permanente, resulta
interesante incluirlo en <file>/etc/cron.daily</file>.
</sect1>

<sect1>Como desactivar el protector de pantalla
<p>
En la consola de Linux:
<example>
# setterm -powersave off
</example>
<p>
Ejecute la consola kon2 (kanji) con:
<example>
# kon -SaveTime 0
</example>
<p>
Cuando esté ejecutando X:
<example>
# xset s off
 o
# xset -dpms
 o
# xscreensaver-command -prefs
</example>
Consulte las correspondientes páginas del manual.
</sect1>

<sect1>Desactivar el sonido (bip)
<p>
Uno siempre puede desenchufar el parlante del PC ;-)  Para el
intérprete de comandos:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc:
</example>
</sect1>

<sect1>Mensajes de error en la pantalla
<p>
El primer lugar que hay que consultar para leer los mensajes de error
que aparecen por pantalla es <file>/etc/init.d/klogd</file>.  En este
script haga la siguiente asignación <tt>KLOGD="-c 4"</tt> y ejecute
<tt>/etc/init.d/klogd restart</tt>.
<p>
Un método alternativo consiste en ejecutar <tt>dmesg -n1</tt>.
<p>
Otro lugar que hay que ver es el <file>/etc/syslog.conf</file>.
<p>
</sect1>

<sect1>Volver la consola a su estado normal
<p>
Si la pantalla se enloquece después de hacer <tt>$ cat
archivo_binario</tt> (quizás no pueda ver el comando que ingresa
mientras escribe) haga:
<example>
$ reset
</example>
</sect1>

<sect1>Convertir un archivo de texto en formato DOS a formato Unix
<p>
Convertir un archivo de texto en formato DOS (fin-de-línea=^M^J) 
en un archivo Unix (^J).
<example>
# apt-get install sysutils
$ dos2unix dosfile
</example>
</sect1>

<sect1>Convertir un archivo grande en archivos más pequeños
<p>
<example>
$ split -b 650m archivo   # dividir el archivo en partes de 650 MB
$ cat x* >archivo_grande  # unir los archivos en un archivo grande
</example>
</sect1>

<sect1>Pequeños scripts que incluyen redireccionamientos
<p>
Los siguientes scripts realizan tareas útiles utilizando tuberías.
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # encontrar todos los archivos en /usr
		     # excluyendo algunos archivos
xargs -n 1 command   # ejecutar comando para tods los ítems de la stdin
xargs -n 1 echo|     # escribir ítems separados por espacios en blanco
                     # en renglones
grep -e patrón|      # extraer líneas con un determinado patrón
cut -d: -f3 -|       # extraer el tercer campo separado por :  
                     # (archivo passwd, etc.)
col -bx |            # eliminar retrocesos y convertir tabulaciones en
                     # espacios
expand -|            # transformar las tabulaciones
sort -u|             # ordenar y eliminar duplicados
tr '\n' ' '|         # concatenar líneas en una sola línea
tr '\r' ''|          # eliminar CR (retornos de carro)
tr 'A-Z' 'a-z'|      # convertir mayúsculas en minúsculas
sed 's/^/# /'|       # transformar cada línea en un comentario
sed 's/\.ext//g'|    # eliminar .ext
sed  -n -e 2p|       # mostrar la segunda línea 
head -n 2 -|         # mostrar las primeras 2 líneas
tail -n 2 -|         # mostrar las últimas 2 líneas
</example>
</sect1>

<sect1>Obtener el texto de una página web o del archivo de una lista de
correos
<p>
Lo siguiente leerá una página web como un archivo de texto.  Resulta muy
útil cuando se desea copiar configuraciones que se obtienen de la red.
<example>
$ lynx -dump http://www.remote-site.com/help-info.html &gt;archivo_de_texto
</example>
<p>
Si se trata de un archivo de una lista de correo, use <tt>munpack</tt>
para obtener los contenidos mime del texto.
</sect1>

<sect1>El tiempo de un comando
<p>
Mostrar el tiempo empleado por un proceso.
<example>
# time df >/dev/null
real    0m0.035s       # tiempo de reloj (tiempo real transcurrido)
user    0m0.000s       # tiempo en modo usuario
sys     0m0.020s       # tiempo en modo kernel
</example>
</sect1>

<sect1>El comando <prgn>nice</prgn> 
<p>
Use <prgn>nice</prgn> (del paquete GNU shellutils) para fijar el valor
"nice" de un comando al ejecutarlo. <prgn>renice</prgn> (bsdutild) o
<prgn>top</prgn> puede modificar el valor "nice" de un proceso. El
proceso más lento tiene el valor 19 (prioridad más baja); los valores
negativos son "not-nice". El valor -20 lo tiene el proceso más veloz
(prioridad alta). Sólo el superusuario puede fijar valores "nice"
negativos.
<example>
# nice  -19 top                                         # muy lento
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img # muy rápido
</example>
</sect1>

<sect1>Planificar una actividad (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Use <prgn>cron</prgn> y <prgn>at</prgn> para planificar tareas en Linux.
Véase <manref name="at" section="1">, <manref name="crontab"
section="5">, <manref name="crontab" section="8">. 
<p> 
Ejecute el comando <tt>crontab -e</tt> para crear o editar el archivo
crontab para configurar eventos planificados. Ejemplo de un archivo
crontab:
<example>
# utilice /bin/sh para ejecutar los comandos sin importar lo que dice el
# /etc/passwd
SHELL=/bin/sh
# envíe un mensaje a `pablo' sin importar a quien pertenece el crontab
MAILTO=pablo
# Minuto Hora Día_del_mes Mes Día_de_la_semana comando
# ejecutar todos los días a las 00:05
5  0  *  * *   $HOME/bin/tarea.diaria &gt;&gt; $HOME/tmp/salida 2&gt;&amp;1
# ejecutar a las 14:15 el primer día de cada mes -- enviar salida a Pablo
15 14 1  * *   $HOME/bin/mensual
# ejecutar a las 22:00 todos los días hábiles (1-5), molestar a José. 
# % para nueva línea, el último % para cc:
0 22 *   * 1-5 mail -s "Son las 10 de la noche" josé%José:%%¿Dónde están
                        los chicos?%.%%
23 */2 1 2 *   echo "ejecutar el 1 de febrero a los 23 minutos después
                     de 0am, 2am, 4am ..."
5  4 *   * sun echo "ejecutar todos los domingos a las 04:05"
# ejecutar a las 03:40 el primer lunes de cada mes
40 3 1-7 * *   [ "$(date +%a)" == "Mon" ] && comando -args
</example>
Ejecutar el comando <prgn>at</prgn> para planificar una tarea una sola vez:
<example>
$ echo 'command -args'| at 3:40 monday
</example>
</sect1>

<sect1>Intercambiando consolas con <prgn>screen</prgn>
<p>
El programa <prgn>screen</prgn> permite ejecutar múltiples terminales
virtuales, cada una con su intérprete de comandos interactivo, en una
única terminal física o ventana que emule un terminal. Incluso si
utiliza consolas virtuales Linux o múltiples ventanas xterm, merece la
pena experimentar con <prgn>screen</prgn> por sus amplias
funcionalidades que incluye navegación por el histórico de comandos,
copiar y pegar, registro de accesos al sistema, entrada de caracteres
especiales y la capacidad de separar una sesión entera de
<prgn>screen</prgn> del terminal para recuperarla posteriormente.  Si
frecuentemente se conecta a una máquina Linux desde un terminal remoto o
usando el terminal VT100, <prgn>screen</prgn> le facilitará muchísimo
las cosas.
<p>
Una vez que arranca <prgn>screen</prgn> toda la entrada de datos que se
hace a través del teclado se envía a la ventana actual excepto la
combinación de teclas de comando, por defecto <tt>^A</tt>. Todos los
comandos de <prgn>screen</prgn> se ingresan escribiendo <tt>^A</tt>
seguido de una sola tecla [y eventualmente algunos parámetros]. Algunos
comandos útiles:
<example>
^A ?     mostrar ventana de ayuda (muestra las asociaciones de teclas)
^A c     crear una nueva ventana y cambiar a ella
^A n     ir a la siguiente ventana
^A p     ir a la ventana anterior
^A 0     ir a la ventana número 0
^A w     mostrar la lista de ventanas
^A a     enviar un Ctrl-A a la ventana actual como entrada del teclado
^A h     grabar una copia de la ventana actual a un archivo 
^A H     comenzar/finalizar la grabación de ventana actual en un archivo
^A ^X    bloquear la terminal (protegida con contraseña)
^A d     separar una sesión del terminal
^A DD    separar una sesión y salir
</example>
La posibilidad de <prgn>screen</prgn> de "separar" una sesión es muy
poderosa. Supongamos que estamos conectados a través de una conexión
telefónica y estamos ejecutando una sesión compleja con
<prgn>screen</prgn> que incluye editores y otros programas abiertos en
diversas ventanas. De repente, necesitamos abandonar el terminal pero no
queremos perder nuestro trabajo al colgar la línea. Simplemente, escriba
<tt>^A d</tt> para separar la sesión y luego desconéctese (o, más rápido
aún, escriba <tt>^A DD</tt> para desprender la sesión de
<prgn>screen</prgn> y simultáneamente desconectarse). Cuando se conecte
nuevamente, escriba el comando <tt>screen -r</tt> y <prgn>screen</prgn>
automáticamente recuperará todas las ventanas que había abierto. 
<p>
Éste es sólo una pequeña muestra de los comandos y características de
<prgn>screen</prgn>. Si hay algo que desea que <prgn>screen</prgn> haga,
¡existe una gran posibilidad que pueda hacerlo!. "man screen" para más
detalles.
<p>
<em>Observación:</em> si ve que la tecla de retroceso y/o Ctrl-H no
funciona correctamente cuando ejecuta <prgn>screen</prgn>, edite el
archivo <file>/etc/screenrc,</file> localice la línea
<example>
bindkey -k kb stuff "\177"
</example>
y coméntela (es decir, agréguele el carácter "#" al principio). 
<![%FIXME[<p>=== Add "xmove" for X if desired ===]]>
</sect1>

<sect1>Probando la red
<p>
Instale  
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (para el kernel 2.2),
<package>iptables</package> (para el kernel 2.4 ) y el paquete
<package>net-tools</package>:
<example>
$ ping yahoo.com            # verificar la conexión a Internet
$ traceroute yahoo.com      # rastrear paquetes IP
$ ifconfig                  # verificar la configuración del 
                            # anfitrión (host)
$ route -n                  # verificar la configuración de la ruta
$ dig [@dns-server.com] host.dom [{a|mx|any}] |less
      # verificar registros host.dom DNS [@ dns-server.com] para  
      # un registro [{mx|any}]
$ ichains  -L -n |less      # verificar filtrado de paquetes (kernel 2.2)
$ iptables -L -n |less      # verificar filtrado de paquetes (kernel 2.4)
$ netstat -a                # mostrar todos los puertos abiertos
$ netstat -l --inet         # mostrar los puertos en escucha
$ netstat -ln --tcp         # mostrar puertos tcp en escucha (numérico)
</example>
</sect1>

<sect1>Eliminar mensajes de la cola local
<p>
Para eliminar los mensajes de la cola local:
<example>
# exim -q    # eliminar mensajes en espera
# exim -qf   # eliminar todos los mensajes
# exim -qff  # eliminar incluso mensajes bloqueados
</example>
"-qff" puede resultar mejor para el script /etc/ppp/ip-up.d/exim.
</sect1>

<sect1>Eliminar mensajes bloqueados de la cola local
<p>
Para eliminar mensajes de correo bloqueados de la cola local
reenviando el mensaje de error:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Borrar el contenido de un archivo
<p>
No utilice <tt>rm</tt> si el archivo es usado por otros usuarios.
<example>
$ :>archivo-a-eliminar
</example>
</sect1>

<sect1>Archivos fantasma
<p>
<example>
$ dd if=/dev/zero  of=nombre_archivo bs=1k count=5 # 5KB de contenido
                                                   # cero
$ dd if=/dev/urandom of=nombre_archivo bs=1m count=7 # 7MB de contenido
                                                     # al azar
$ touch nombre_archivo      #  crear un archivo de 0B o actualizar mtime
                            #  (fecha de la última modificación)
</example>
</sect1>

<sect1>chroot
<p>
Puede crear un sistema independiente que comparta el mismo kernel.
<example>
# mount /dev/hda1 /mnt/target   
 ... suponiendo que /dev/hda1 contiene un sistema entero
# chroot /mnt/target
 ... Ahora los contenidos de /dev/hda1 se ven como el directorio raíz.
# mount proc /proc              # por si acaso 
 ... ejecute el comando dentro de /dev/hda1
</example>
Esto permite cargar las ramas estable/de prueba/inestable en una misma
máquina.  Asimismo, uno puede ejecutar un programa que requiera gran
cantidad de memoria (por ejemplo, <prgn>dselect</prgn>) en una máquina
anfitrión, montando  un máquina auxiliar (máquina satélite) mediante NFS
en modo lectura/escritura y accediendo a ella mediante
<prgn>chroot</prgn>.
<p>
En woody, el sistema chroot puede crearse fácilmente con el comando
<prgn>debootstrap</prgn>.
<example>
# mkdir potatochroot
# debootstrap potato potatochroot
# chroot potatochroot
# apt-setup # configura el /etc/apt/sources.list
</example>
</sect1>

<sect1>Samba
<p>
Lo básico para obtener archivos desde Windows:
<example>
# mount -t smbfs -o username=myname,uid=my_uid,gid=my_gid \
        //server/share /mnt/smb  # monta un directorio Windows en Linux
# smbmount //server/share /mnt/smb \
        -o "username=mi_nombre,uid=mi_uid,gid=mi_gid"
# smbclient -L 192.168.1.2 # lista los archivos compartidos de una
                           # máquina
</example>
</sect1>

</sect>

</chapt>

