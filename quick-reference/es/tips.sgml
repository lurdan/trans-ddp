<!-- CVS revision of original english document "1.46"  -->

<chapt id="tips"> Trucos para &debian; 

<![%FIXME;[<p>===Proof reading: DONE by dsew ===]]>

<sect>Arrancando el sistema
<p>
Véase el BootPrompt-HOWTO (LDP) para información detallada sobre el
indicador de arranque.

<sect1 id="crackroot">"¡Olvidé la contraseña de superusuario!" (1)
<p>
Es posible arrancar el sistema y acceder a la cuenta de superusuario sin
conocer la contraseña siempre y cuando se tenga acceso al teclado de la
consola (esto supone que ni la BIOS ni un cargador de arranque como
<prgn>lilo</prgn> solicitan una contraseña para evitar el arranque del
sistema)
<p>
Este es un procedimiento que no requiere de discos de arranque externos
ni cambios en los parámetros de arranque de la BIOS. Aquí, "Linux" hace
referencia al kernel de Linux de la instalación predeterminada de
Debian.
<p>
En el pantalla de arranque de <prgn>lilo</prgn>, cuando aparece
<tt>boot:</tt> (en algunos sistemas debe presionar la tecla Mayús para
evitar el arranque automático) escriba:
<example>
boot: Linux init=/bin/sh
</example>
Esto hará que el sistema arranque el kernel y ejecute el
<file>/bin/sh</file> en vez del estándar <prgn>init</prgn>.  Ahora
tenemos privilegios de superusuario y acceso al intérprete de comandos.
Puesto que <file>/</file> generalmente está montado en modo sólo lectura
y aún no han sido montadas las distintas particiones, debe hacer lo
siguiente para tener un sistema que funcione razonablemente.
<example>
init-2.03# mount -n -t remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(si el segundo campo de datos en el <file>/etc/passwd</file> es una "x"
para cada nombre de usuario, su sistema utiliza contraseñas ocultas y
debe editar el archivo <file>/etc/shadow</file>) Para desactivar la
contraseña de root, edite el segundo campo de datos en el archivo de
contraseñas de modo que quede vacío.  Ahora se puede reiniciar el
sistema y entrar como root sin contraseña.  A diferencia de algunas
distribuciones Linux antiguas, la Debian actual (Potato) requiere de
contraseña sólo cuando arranca en el nivel de ejecución 1.
<p>
Resulta una buena idea tener un editor mínimo en <file>/bin</file>
en el caso que <file>/usr</file> no sea accesible (véase <ref id="bin-editor">).
<p>
También considere instalar el paquete <package>sash</package>.
Cuando no pueda arrancar el sistema, haga:
<example>
boot: Linux init=/bin/sash
</example>
<prgn>sash</prgn> sirve como un sustituto interactivo de
<prgn>sh</prgn> incluso cuando <file>/bin/sh</file> no se puede usar.
Está enlazado estáticamente e incluye diversas utilidades estándar
incorporadas (teclee "help" en el indicador de comandos para una lista
de referencia).
</sect1>

<sect1 id="crackroot2">"¡Olvidé la contraseña de superusuario!" (2)
<p>
Arranque desde un disco de emergencia.  Si <file>/dev/hda3</file> es la
partición raíz original, lo siguiente le permitirá editar el archivo de
contraseñas tan fácilmente como antes.
<example>
# mkdir fixit
# mount /dev/hda3 fixit
# cd fixit/etc
# vi shadow
# vi passwd
</example>
<p>
La ventaja de este enfoque sobre el anterior es que no se necesita
conocer la contraseña de <prgn>lilo</prgn> (si existe).  Pero para
usarlo uno debe ser capaz de poder acceder a la configuración de la BIOS
para permitir arrancar el sistema desde un disquete o CD si es que ya no
está configurada como tal.
</sect1>

<sect1 id="dead-lilo">No puedo arrancar el sistema
<p>
Si se tomó la molestia de crear un disco de arranque durante la instalación,
no habrá ningún problema.  Si <prgn>lilo</prgn> se encuentra dañado, grabe el
disco de arranque desde el disco de instalación de debian y arranque el
sistema con él. En el indicador de arranque, suponiendo que la partición raíz
de su instalación Linux es <file><var>/dev/hda12</var></file> y que desea
entrar al nivel de ejecución 3, escriba:
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
De esta manera arrancará con un sistema prácticamente funcional usando el
kernel del disquete (pueden existir pequeños inconvenientes debido a la falta
de algunas características o módulos del kernel). 
<p>
Si necesita un disquete de arranque personalizado, 
consulte el <prgn>readme.txt</prgn> sobre el disco de rescate.
</sect1>

<sect1 id="no-x-start">"¡Permítanme desactivar X al arrancar!"
<p>
Chasing <tt>unstable/sid</tt> is fun, but buggy <prgn>xdm</prgn>, 
<prgn>gdm</prgn>, <prgn>kdm</prgn>, and <prgn>wdm</prgn> started 
during the boot process can bite you bad.
<p>
Primero acceda al shell del superusuario escribiendo lo siguiente en el indicador de 
arranque:
<example>
boot: <var>Linux</var> vga=normal s
</example>
En este caso, <var>Linux</var> es la etiqueta de la imagen del kernel
que está arrancando.
"vga=normal" nos asegurará que lilo se ejecute en una pantalla VGA normal y
"s" (o "S") es el parámetro que se pasa a <prgn>init</prgn> 
para invocar el modo monousuario.  Escriba la contraseña del superusuario
en el indicador.
<p>
Existen distintas maneras de desactivar todos los demonios 
que arrancan con X:
<list>
<item>ejecute <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6</tt>
<item>escriba "exit 0" al comienzo de todos los archivos <file>/etc/init.d/<var>?</var>dm</file>.
<item>renombre todos los archivos <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> como
 <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>elimine todos los archivos <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>.
<item>ejecute <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Aquí, <file>rc<var>2</var>.d</file> se debe corresponder al nivel de ejecución
especificado en el <file>/etc/inittab</file>. Asimismo
<file><var>?</var>dm</file> hace referencia a <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn> o <prgn>wdm</prgn>.
<p>
La primera de la lista es "la única manera verdadera" en &debian;.  
La última es fácil pero sólo funciona en &debian; y requiere que se
configure nuevamente usando <prgn>dpkg-reconfigure</prgn>.  
Los otros son métodos genéricos para deshabilitar demonios.
<p>
Aún puede continuar arrancando X mediante el comando <prgn>startx</prgn>
desde cualquier consola de shell.
</sect1>

<sect1 id="bootprompt">Otros trucos con el indicador de arranque
<p>
El sistema se puede arrancar en un nivel de ejecución particular
y con una configuración determinada usando el indicador de arranque
de <prgn>lilo</prgn>. Para más detalles consulte el
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Si desea arrancar el sistema en el nivel de ejecución cuatro, use la
siguiente entrada para el indicador de arranque de <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Si desea arrancar el sistema en modo monousuario y conoce la contraseña
de superusuario, algunos de los siguientes ejemplos funcionará usando el
indicador de arranque de <prgn>lilo</prgn>.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Si desea arrancar el sistema con menos memoria de la que realmente posee
el sistema (por ejemplo, 48MB en un sistema con 64MB), use la siguiente
entrada para el indicador de arranque de <prgn>lilo</prgn>:
<example>
boot: Linux mem=48M
</example>
Asegúrese de no especificar un valor mayor al tamaño de memoria real ya
que si es así el kernel se colgará.  Los núcleos antiguos y/o las placas
madres con una BIOS antigua no usan la memoria por encima de los 64 MB,
salvo que uno escriba <tt>mem=128M</tt> en el indicador de arranque o
incluya una línea similar en el <file>/etc/lilo.conf</file>.
</sect1>


<sect1 id="bootgrub">Cómo configurar los parámetros de arranque (GRUB)
<p>
GRUB es un nuevo administrador de arranque del projecto Hurd y es mucho
más flexible que lilo pero con un manejo ligeramente diferente de los
parámetros de arranque.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Aquí, debe tener presente de los nombres de dispositivos que utiliza el
Hurd:
<example>
HURD/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A: 
 (hd0,1)             /dev/hda1           C: (en general)
 (hd0,4)             /dev/hda4           F: (en general)
 (hd1,4)             /dev/hdb4           ?
</example>
Véase <file>&f-grub;</file> y <file>&f-grub-doc;</file> para más
detalles.
 </sect>
<sect>Registro de actividades
<sect1 id="script">Registrando las actividades del intérprete de comandos
<p>
La administración del sistema implica tareas mucho más elaboradas en un
entorno Unix que un entorno común de una computadora personal. Asegúrese
de saber lo básico sobre configuración por si acaso necesita recuperar
el sistema de algún problema. Las herramientas de configuración con GUI
basadas en X-Window son agradables y convenientes pero a menudo
inapropiadas en situaciones de emergencia.
<p>
En este contexto, el registro de las actividades del intérprete de
comandos resulta ser una buena práctica especialmente como superusuario.
<p>
Emacs: utilice <tt>M-x shell</tt> para empezar a grabar en el búfer y
<tt>C-x C-w</tt> para escribir el contenido del mismo en un archivo.
<p>
Intérprete de comandos: utilice el comando <prgn>screen</prgn> con "^A H"
como se detalla en <ref id="screen"> o el comando <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 ... hacer cualquier cosa ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
Se puede utilizar lo siguiente en vez del comando <prgn>script</prgn>:
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>
<sect1>Registrando las actividades en X
<p>
Si necesita registrar la imagen de una aplicación X, incluyendo una
terminal xterm, utilice <prgn>gimp</prgn> (GUI).  Puede capturar cada
ventana o la totalidad de la pantalla. Otras alternativas son
<prgn>xwd</prgn> (<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>) o <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>
</sect>

<sect id="archiving">Copiar y archivar un subdirectorio entero
<sect1>Comandos básicos para copiar un subdirectorio entero
<p>
Si necesita reordenar la estructura de archivos, mueva el contenido
incluyendo los enlaces a archivos mediante:
<example>
Método estándar:
# cp -a /directorio/fuente /directorio/destino # debe ser GNU
# (cd /directorio/fuente &amp;&amp; tar cf - . ) | \
        (cd /directorio/destino &amp;&amp; tar xvfp - )
Si existen enlaces duros, se necesita un método más elaborado:
# cd /ruta/al/directorio/original
# find . -depth -print0 | afio -p -xv -0a
# /punto/de/montaje/del/nuevo/directorio
En el caso de una conexión remota:
# (cd /directorio/fuente &amp;&amp; tar cf - . ) | \
    ssh usuario@host.dom (cd /directorio/destino &amp;&amp; tar xvfp - )
Si no hay archivos enlazados:
# scp -pr usuario1@host1.dom:/directorio fuente \
          usuario2@host2.dom:/directorio/destino
</example>
En este caso, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> y <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
El método para copiar un subdirectorio entero está basado en la
información proporcionada por Manoj Srivastava
&lt;srivasta@debian.org&gt; de la lista debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Inicialmente, <prgn>cp</prgn> no resultaba ser el candidato correcto ya que no
desreferenciaba enlaces simbólicos ni tampoco preservaba enlaces duros.  Otra
cosa a considerar eran los archivos de tamaño muy pequeño.
<p>
GNU <prgn>cp</prgn> ha superado estas limitaciones. No obstante en sistemas
que no son GNU cp puede aún tener problemas. Asimismo, no se pueden generar
archivos portables pequeños usando <prgn>cp</prgn>.
<example>
&percnt; cp -a . directorio_nuevo
</example>

<sect1><prgn>tar</prgn>
<p>
Tar soluciona algunos de los problemas que tenía cp con los enlaces
simbólicos. Sin embargo, `cpio' maneja archivos especiales que el `tar'
tradicional no puede manejar.
<p>                                                             
<prgn>tar</prgn> maneja múltiples enlaces duros colocando una única copia de
un enlace en la cinta. El nombre asignado a dicha copia es el <em>único</em>
que se puede usar para recuperar el archivo. En cambio, <prgn>cpio</prgn>
coloca una copia de cada enlace de manera que para recuperar el archivo se
puede utilizar el nombre de cualquiera de ellas.
<p>
El comando <prgn>tar</prgn> ha cambiado sus opciones para los archivos
<file>.bz2</file> al pasar de Potato a Woody, por lo tanto, use
<tt>--bzip2</tt> en los scripts en vez de su forma reducida <tt>-I</tt>
(Potato) o <tt>-j</tt> (Woody).  
</sect1>

<sect1><prgn>pax</prgn>
<p>
Es la nueva utilidad para archivar, portable y compatible POSIX (IEEE Std
1003.2-1992, páginas 380-388 (sección 4.48) y páginas 936-940 (sección
E.4.48)).  <prgn>pax</prgn> lee, escribe y lista los componentes de un
directorio y copia la jerarquía de los mismos.  La operación pax es
independiente del formato específico del archivo y admite una amplia variedad
de formatos.
<p>
Las implementaciones de <prgn>pax</prgn> son aún nuevas y están en pleno
desarrollo.
<example>
# apt-get install pax
$ pax -rw -p e . directorio_nuevo
 o
$ find . -depth  | pax -rw -p e  directorio_nuevo
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
Cpio almacena o extrae archivos en o de un archivo <prgn>tar</prgn> o
<prgn>cpio</prgn>. El archivo puede ser otro archivo del disco, una cinta
magnética o una tubería.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> es una mejor forma de tratar con archivos con formato cpio.
Generalmente es más rápido que cpio, proporciona más opciones para utilizar
con cintas magnéticas y maneja mejor la corrupción de los datos de entrada.
Admite archivos multi-volumen durante su operación interactiva.  Afio puede
crear archivos empaquetados que son mucho más seguros que los empaquetados con
<prgn>tar</prgn> o <prgn>cpio</prgn>.  En un script, para realizar una copia
de seguridad, afio tiene un comportamiento óptimo como 'motor para archivar'.
<example>
$ find . -depth -print0 | afio -px -0a directorio_nuevo
</example>
Para crear todas mis copias de respaldo en una cinta uso <prgn>afio</prgn>. 
</sect1>

</sect>
<sect id="diff-backup">Respaldos diferenciales y sincronización
de datos
<p>
Los respaldos diferenciales y la sincronización de datos se pueden
implementar mediante diversos métodos:
<list>
<item><package>rcs</package>:  copia de respaldo e historial, sólo texto
<item><package>rdiff-backup</package>:  copia de respaldo e historial. Enlaces simbólicos OK.
<item><package>rsync</package>:  sincronización en un sólo sentido
<item><package>unison</package>:  sincronización en ambos sentidos
<item><package>cvs</package>:  sincronización en múltiples sentidos con un servidor e
 historial, sólo texto, maduro. Véase <ref id="cvs">.
<item><package>arch</package>:  sincronización en múltiples sentidos con un servidor,
 copias de respaldo e historial, sin "directorio de trabajo".
<item><package>subversion</package>: sincronización en múltiples 
sentidos con un servidor, copias de respaldo e historial, Apache.
</list>
La combinación con uno de los métodos descriptos en 
<ref id="archiving"> y la automatización de tareas descripta en
<ref id="cronjob"> permitirán crear un buen sistema de respado.
<p>
Explicaré dos herramientas fáciles de usar.

<sect1 id="rdiff-backup">Respaldos diferenciales con rdiff
<p>
<package>Rdiff-backup</package> ofrece respaldos buenos y sencillos
con historial diferencial para cualquier tipo de archivos incluyendo
enlaces simbólicos. Para hacer una copia de respaldo de la
mayor parte de <file>~/</file> en <file>/mnt/respaldo</file>:
<example>
$ rdiff-backup --include ~/tmp/conservar --exclude ~/tmp  ~/ /mnt/respaldo
</example>
Para restaurar los datos de hace 3 días de este archivo en
<file>~/antiguo</file>:
<example>
$ rdiff-backup -r 3D /mnt/respaldo ~/antiguo
</example>
Véase <manref name="rdiff-backup" section="1">.
</sect1>

<sect1 id="backup">Respaldos diferenciales con RCS
<p>
<package>Changetrack</package> registrará en forma regular
los cambios de los archivos de configuración en archivos RCS.  
Véase <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>Recuperar al sistema de un cuelgue
<sect1>Mate el proceso
<p>
Ejecute <prgn>top</prgn> para ver cuál es el proceso que está actuando de
manera extraña. Pulse `P' para ordenar por tiempo de cpu, `M' para ordenar por
uso de memoria y "k" para matar un proceso. En forma aternativa, se puede usar
el estilo BSD <tt>ps aux | less</tt> o el System V <tt>ps -efH | less</tt>.
La sintaxis del estilo System V muestra los ID de los procesos padres
<tt>PPID</tt> que se pueden utilizar para matar un proceso hijo zombie
(malfuncionamiento).
<p>
Utilice <prgn>kill</prgn> junto el ID del proceso para matar (o enviar una
señal a) un proceso, <prgn>killall</prgn> para hacer lo mismo pero usando el
nombre del comando.  Señales de uso habitual:
<example>
 1: HUP,  reiniciar demonio
15: TERM, terminar un proceso en forma normal
 9: KILL, matar un proceso sin contemplaciones
</example>

</sect1>

<sect1>ALT-SysRq
<p>
La opción de compilación del kernel "Magic SysRq key" proporciona una
protección contra el mal funcionamiento del sistema.  Pulsando
<tt>ALT-SysRq</tt> en una i386 y a continuación una de las teclas <tt>r
0 k e i s u b</tt> se obtiene el pase mágico.
<p>
Un<tt>r</tt>aw restaura el teclado tras el cuelgue de X.  Modifique el
nivel de registro de la consola con <tt>0</tt> para reducir los mensajes
de error. sa<tt>k</tt> (tecla de atención del sistema) mata a todos los
procesos en la consola virtual actual.  t<tt>E</tt>rminate mata a todos
los procesos de la terminal actual salvo init.  k<tt>i</tt>ll mata a
todos los procesos incluyendo a init.  <p> <tt>s</tt>ync (sincronizar),
<tt>u</tt>mount (desmontar), y re<tt>b</tt>oot (reiniciar) a menudo se
utilizan en el caso de situaciones realmente complicadas.
<p>
En el momento de escribir este documento, los núcleos que vienen con la
instalación predeterminada de Debian no han sido compilados con esta
opción. Recompile el kernel para activarla. Se puede encontrar
información detallada en:
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>.
</sect1>
</sect>
<sect>Algunos pequeños comandos útiles para tener en cuenta
<sect1>Paginador
<p>
<prgn>less</prgn> es un paginador (navegador del contenido de un archivo).
Pulse `h' para obtener ayuda. Puede hacer muchas más cosas que
<prgn>more</prgn>.  <prgn>less</prgn> can be supercharged by executing
<tt>eval $(lesspipe)</tt> or <tt>eval $(lessfile)</tt> in the shell start-up
script.  Véase más en <file>&f-lessopen;</file>. La opción <tt>-R</tt> permite
la salida de caractéres raw y activa las secuencias de escape en color ANSI.
Véase <manref name="less" section="1">.
<p>
<prgn>w3m</prgn>puede ser un paginador alternativo útil para algunos sistemas
de código (EUC).
<sect1>Memoria disponible
<p>
<prgn>free</prgn> y <prgn>top</prgn> brindan una buena información sobre
los recursos de memoria disponibles. No se preocupe por el tamaño que
figura bajo "used" de la línea "Mem:" sino por el valor que se encuentra
justo debajo de él (38792 en el siguiente ejemplo). 
<example>
$ free -k # para una máquina con 256MB
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
La cantidad de memoria física exacta se puede confirmar haciendo
<tt>grep '^Memory' /var/log/dmesg</tt>. En este caso arroja el siguiente
resultado:
"Memory: 256984k/262144k available (1652k kernel
code, 412k reserved, 2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
El sistema no puede usar cerca de 5MB ya que lo utiliza el propio kernel.
</sect1>

<sect1>Configurar fecha y hora (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Esto fijará la fecha y hora del sistema y del hardware en MM/DD hh:mm,
CCYY.  La hora se muestra según el huso horario local pero el hardware
utiliza el UTC..

<sect1>Configurar hora (NTP)
<p>
Referencia: <url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">.
<p>
<sect2>Configurar la fecha y hora con una conexión a Internet permanente
<p>
Configure el reloj del sistema para corregir la fecha y hora en forma
automática mediante un servidor remoto:
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
Si su sistema posee una conexión a Internet permanente, resulta
interesante incluirlo en <file>/etc/cron.daily</file>.

<sect2>Configurar la hora y fecha con una conexión a Internet no permanente
<p>
Use el paquete <package>chrony</package>.
</sect1>

<sect1>Como desactivar el protector de pantalla
<p>
En la consola de Linux:
<example>
# setterm -powersave off
</example>
<p>
Ejecute la consola kon2 (kanji) con:
<example>
# kon -SaveTime 0
</example>
<p>
Cuando esté ejecutando X:
<example>
# xset s off
 o
# xset -dpms
 o
# xscreensaver-command -prefs
</example>
Consulte las correspondientes páginas del manual.
</sect1>

<sect1 id="getent">Búsqueda en la base de datos administrativa
<p>
Glibc ofrece <manref name="getent" section="1"> para buscar entradas
en la base de datos administrativa (passwd, group, hosts, services, 
protocols o networks).
<example compact>
getent database [clave ...]
</example>

<sect1>Desactivar el sonido (bip)
<p>
Uno siempre puede desenchufar el parlante del PC ;-)  Para el
intérprete de comandos:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc:
</example>
</sect1>

<sect1>Mensajes de error por pantalla
<p>
Para hacer desaparecer los mensajes de error por pantalla, el primer lugar a
verificar es <file>/etc/init.d/klogd</file>.  Fije <tt>KLOGD="-c
<var>3</var>"</tt> en este script y ejecute <tt>/etc/init.d/klogd
restart</tt>. Un método alternativo consiste en ejecutar 
<tt>dmesg -n<var>3</var></tt>.  
<p>
Veamos el significado de los niveles de error:
<list compact>
<item>0: KERN_EMERG,   sistema inutilizado
<item>1: KERN_ALERT,   deben tomarse acciones de inmediato
<item>2: KERN_CRIT,    condiciones críticas
<item>3: KERN_ERR,     condiciones de error
<item>4: KERN_WARNING, condiciones de precaución
<item>5: KERN_NOTICE,  condiciones normales pero significativas
<item>6: KERN_INFO,    mensajes informativos
<item>7: KERN_DEBUG,   mensajes a nivel depuración
</list>
<p>
Si un mensaje de error inútil lo molesta continuamente, considere crear un
parche para el kernel sencillo tal como <file>shutup-abit-bp6</file>
(disponible en el <url id="&examples;" name="subdirectorio de ejemplos">).
<p>
Otro lugar que hay que ver es el <file>/etc/syslog.conf</file>; verifique si
los mensajes de error se envían a la consola.
</sect1>

<sect1>Configurar la consola
<p>
En sistemas tipo UNIX se accede a las pantallas de la consola mediantes
rutinas de la biblioteca (n)curses.  Éstas brindadn al usuario un método
independiente del terminal de actualizar las pantallas de caracteres con una
optimización razonable. Véase <manref name="ncurses" section="3X"> y <manref
name="terminfo" section="5">.
<p>
En un sistema &debian;, existe una infinidad de entradas predefinidas:
<example>
$ toe | less                  # todas las entradas
$ toe /etc/terminfo/ | less   # entradas reconfigurables por el usuario
</example>
Exporte su elección mediante la variable de entorno <tt>TERM</tt>.
<p>
Si la entrada terminfo para xterm no funciona con una xterm no-Debian, cuando
acceda a un sistema Debian en forma remota cambie el tipo de su terminal de
"xterm" a una de las versiones con menos características como, por ejemplo,
"xterm-r6". Véase <file>&f-libncurse;</file> para más información.  
</sect1>

<sect1>Volver la consola a su estado normal
<p>
Si la pantalla se enloquece después de hacer 
<tt>$ cat <var>some-binary-file</var></tt> (quizás no 
pueda ver el comando que ingresa mientras escribe) haga:
<example>
$ reset
</example>
</sect1>

<sect1>Convertir un archivo de texto en formato DOS a formato Unix
<p>
Convertir un archivo de texto en formato DOS (fin-de-línea=^M^J) 
en un archivo Unix (^J).
<example>
# apt-get install sysutils
$ dos2unix dosfile
</example>
</sect1>

<sect1>Modificar archivos con la sustitución de expresiones regulares
<p>
Para reemplazar todas las instancias <var>FROM_REGEX</var> por
<var>TO_REGEX</var> en todos los archivos <var>FILES</var> ...:
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_REGEX</var>/g;'
<var>FILES</var> ....
</example>
<tt>-i</tt> es para "editar en el lugar", <tt>-p</tt> significa "bucle
implícito sobre los archivos FILES ...".  Si la sustitución es compleja, la
recuperación ante posibles errores resulta más fácil usando el parámetro
<tt>-i.bak</tt> en vez de <tt>-i</tt>. De esta manera se conservará una copia
de los archivos originales a los que se les agregará la extensión
<tt>.bak</tt>.
</sect1>

<sect1>Extraer diferencias y combinar actualizaciones entre archivos
fuente
<p>
Siguiendo uno de los siguientes procedimientos se extraerá la diferencia
entre los archivos fuente y se crearán los archivos unificados diff
<var>archivo.parche0</var> o <var>archivo.parche1</var> según la ubicación
del archivo:
<example>
$ diff -u <var>archivo.original</var> <var>archivo.nuevo1</var> &gt;
<var>archivo.parche0</var>
$ diff -u <var>archivo/original</var> <var>archivo/nuevo1</var> &gt;
<var>archivo.parche1</var>
</example>
El archivo diff (llamado también parche) se utiliza para enviar
actualizaciones de programas.  Reciving party will apply this update to
another <var>archivo</var> haciendo:
<example>
$ patch -p0 <var>archivo</var> &lt; <var>archivo.parche0</var>
$ patch -p1 <var>archivo</var> &lt; <var>archivo.parche1</var>
</example>
Si tiene 3 versiones del código fuente, puede combinarlos efectivamente usando
<prgn>diff3</prgn>:
<example>
$ diff3 -m <var>archivo.mío</var> <var>archivo.original</var>
<var>archivo.tuyo</var> &gt; <var>archivo</var>
</example>
</sect1>

<sect1>Convertir un archivo grande en archivos más pequeños
<p>
<example>
$ split -b 650m <var>archivo</var>   # dividir el archivo en partes de 650 MB
$ cat x* ><var>archivo_grande</var>  # unir los archivos en un archivo grande
</example>
</sect1>

<sect1>Pequeños scripts que incluyen tuberías
<p>
Los siguientes scripts realizan tareas útiles utilizando tuberías.
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # encontrar todos los archivos en /usr
                     # excluyendo algunos archivos
xargs -n 1 command   # ejecutar comando para tods los ítems de la stdin
xargs -n 1 echo|     # escribir ítems separados por espacios en blanco
                     # en renglones
grep -e patrón|      # extraer líneas con un determinado patrón
cut -d: -f3 -|       # extraer el tercer campo separado por :  
                     # (archivo passwd, etc.)
col -bx |            # eliminar retrocesos y convertir tabulaciones en
                     # espacios
expand -|            # transformar las tabulaciones
sort -u|             # ordenar y eliminar duplicados
tr '\n' ' '|         # concatenar líneas en una sola línea
tr '\r' ''|          # eliminar CR (retornos de carro)
tr 'A-Z' 'a-z'|      # convertir mayúsculas en minúsculas
sed 's/^/# /'|       # transformar cada línea en un comentario
sed 's/\.ext//g'|    # eliminar .ext
sed  -n -e 2p|       # mostrar la segunda línea 
head -n 2 -|         # mostrar las primeras 2 líneas
tail -n 2 -|         # mostrar las últimas 2 líneas
</example>
</sect1>

<sect1>Obtener el texto de una página web o del archivo de una lista de
correos
<p>
Lo siguiente leerá una página web como un archivo de texto.  Resulta muy
útil cuando se desea copiar configuraciones que se obtienen de la red.
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var>
&gt;<var>archivo_de_texto</var>
</example>
Aquí también se pueden usar <prgn>links</prgn> y <prgn>w3m</prgn>, con ligeras
diferencias en el renderizado.
<p>
Si se trata de un archivo de una lista de correo, use <tt>munpack</tt> para
obtener los contenidos mime del texto.
</sect1>

<sect1>Impresión de una página Web
<p>
Lo siguiente imprimirá una página Web en una impresora/archivo PostScript.  
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Véase <ref id="lprlpd">.  También tenga en cuenta los paquetes <prgn>a2ps</prgn> y
<prgn>mpage</prgn> para crear archivos PostScript.
</sect1>

<sect1>Impresión de la página una página del manual
<p>
Lo siguiente imprimirá una página manual en una impresora/archivo PostScript.  
<example>
$ man -Tps <var>alguna-página-del-manual</var> | lpr
$ man -Tps <var>alguna-página-del-manual</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Combinar dos archivos Postscript o PDF
<p>
Es posible combinar dos archivos Postscript o PDF.
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
-sOutputFile=<var>bla.ps</var> -f \
<var>loquesea1.ps</var> <var>loquesea2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>loquesea1.pdf</var>\
  <var>loquesea2.pdf</var>
</example>
</sect1>

<sect1>El tiempo de un comando
<p>
Mostrar el tiempo empleado por un proceso.
<example>
# time <var>algún-comando</var> &gt;/dev/null
real    0m0.035s       # tiempo de reloj (tiempo real transcurrido)
user    0m0.000s       # tiempo en modo usuario
sys     0m0.020s       # tiempo en modo kernel
</example>
</sect1>

<sect1>El comando <prgn>nice</prgn> 
<p>
Use <prgn>nice</prgn> (del paquete GNU <package>shellutils</package>) para
fijar el valor "nice" de un comando al ejecutarlo. <prgn>renice</prgn>
(<package>bsdutils</package>) o <prgn>top</prgn> puede modificar el valor
"nice" de un proceso. El proceso más lento tiene el valor 19 (prioridad más
baja); los valores negativos son "not-nice". El valor -20 lo tiene el proceso
más veloz (prioridad alta). Sólo el superusuario puede fijar valores "nice"
negativos.
<example>
# nice  -19 top                                         # muy lento
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img # muy rápido
</example>
A vecesm un valor extremo de nice hace más daño que bien al sistema.
Utilice este comando con cuidado.
</sect1>

<sect1 id="cronjob">Planificar una actividad (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Use <prgn>cron</prgn> y <prgn>at</prgn> para planificar tareas en Linux.
Véase <manref name="at" section="1">, <manref name="crontab"
section="5">, <manref name="crontab" section="8">. 
<p> 
Ejecute el comando <tt>crontab -e</tt> para crear o editar el archivo
crontab para configurar eventos planificados. Ejemplo de un archivo
crontab:
<example>
# utilice /bin/sh para ejecutar los comandos sin importar lo que dice el
# /etc/passwd
SHELL=/bin/sh
# envíe un mensaje a `pablo' sin importar a quien pertenece el crontab
MAILTO=pablo
# Minuto Hora Día_del_mes Mes Día_de_la_semana comando
# ejecutar todos los días a las 00:05
5  0  *  * *   $HOME/bin/tarea.diaria &gt;&gt; $HOME/tmp/salida 2&gt;&amp;1
# ejecutar a las 14:15 el primer día de cada mes -- enviar salida a Pablo
15 14 1  * *   $HOME/bin/mensual
# ejecutar a las 22:00 todos los días hábiles (1-5), molestar a José. 
# &percnt; para nueva línea, el último &percnt; para cc:
0 22 *   * 1-5 mail -s "Son las 10 de la noche" josé&percnt;José:&percnt;&percnt;¿Dónde están
                        los chicos?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "ejecutar el 1 de febrero a los 23 minutos después
                     de 0am, 2am, 4am ..."
5  4 *   * sun echo "ejecutar todos los domingos a las 04:05"
# ejecutar a las 03:40 el primer lunes de cada mes
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && comando -args
</example>
Ejecutar el comando <prgn>at</prgn> para planificar una tarea una sola vez:
<example>
$ echo 'command -args'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Intercambiando consolas con <prgn>screen</prgn>
<p>
El programa <prgn>screen</prgn> permite ejecutar <strong>múltiples</strong> terminales
virtuales, cada una con su intérprete de comandos interactivo, en una
<strong>única</strong> terminal física o ventana que emule un terminal. Incluso si
utiliza consolas virtuales Linux o múltiples ventanas xterm, merece la
pena experimentar con <prgn>screen</prgn> por sus <strong>amplias
funcionalidades</strong> que incluye:
<list compact>
<item>navegación por el histórico de comandos, 
<item>copiar y pegar, 
<item>registro de accesos al sistema, 
<item>entrada de caracteres especiales y 
<item>la capacidad de <strong>separar</strong> una sesión entera de
<prgn>screen</prgn> del terminal para recuperarla posteriormente. 
</list>
<sect2>Acceso remoto
<p>
Si frecuentemente se conecta a una máquina Linux desde un terminal remoto o
usando el terminal VT100, <prgn>screen</prgn> le facilitará muchísimo
las cosas.
<p>
<enumlist compact>
<item>Supongamos que estamos conectado a la red mediante una conexión
telefónica ejecutando una sesión compleja de <prgn>screen</prgn> con editores
y otros programas abiertos en diversas ventanas. 
<item>De repente necesita abandonar su terminal, pero no deseamos perder
nuestro trabajo al colgar la línea. 
<item>Simplemente teclee <tt>^A d</tt> para <strong>separar</strong> las
sesión y desconéctese (o aún más rápido, teclee <tt>^A DD</tt> para que
<prgn>screen</prgn> se separe y se desconecte por sí misma) 
<item>Cuando se conecte nuevamente, escriba el comando <tt>screen -r</tt> y
<prgn>screen</prgn> mágicamente automáticamente <strong>recuperará</strong>
todas las ventanas que había abierto. 
</enumlist>

<sect2>Comandos de <prgn>screen</prgn> típicos 
<p>
Una vez que arranca <prgn>screen</prgn> toda la entrada de datos que se hace a
través del teclado se envía a la ventana actual excepto la combinación de
teclas de comando, por defecto <tt>^A</tt>. Todos los comandos de
<prgn>screen</prgn> se ingresan escribiendo <tt>^A</tt> seguido de una sola
tecla [y eventualmente algunos parámetros]. Algunos comandos útiles:
<example>
^A ?     mostrar ventana de ayuda (muestra las asociaciones de teclas)
^A c     crear una nueva ventana y cambiar a ella
^A n     ir a la siguiente ventana
^A p     ir a la ventana anterior
^A 0     ir a la ventana número 0
^A w     mostrar la lista de ventanas
^A a     enviar un Ctrl-A a la ventana actual como entrada del teclado
^A h     grabar una copia de la ventana actual a un archivo 
^A H     comenzar/finalizar la grabación de ventana actual en un archivo
^A ^X    bloquear la terminal (protegida con contraseña)
^A d     separar una sesión del terminal
^A DD    separar una sesión y salir
</example>
<p>
Éste es sólo una pequeña muestra de los comandos y características de
<prgn>screen</prgn>. Si hay algo que desea que <prgn>screen</prgn> haga,
¡existe una gran posibilidad que pueda hacerlo!.  <manref name="screen"
section="1"> para más detalles.
<sect2>Tecla de retroceso y/o Ctrl-H en un sesión de <prgn>screen</prgn>
<p>
Si comprueba que la tecla de retroceso y/o Ctrl-H no
funciona correctamente cuando ejecuta <prgn>screen</prgn>, edite el
archivo <file>/etc/screenrc,</file> localice la línea
<example>
bindkey -k kb stuff "\177"
</example>
y coméntela (es decir, agréguele el carácter "#" al principio). 

<sect2>Programa para X equivalente a <prgn>screen</prgn>
<p>
Consulte <prgn>xmove</prgn>.  Véase <manref name="xmove" section="1">.

</sect1>


<sect1>Probando la red
<p>
Instale  
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (para el kernel 2.2),
<package>iptables</package> (para el kernel 2.4 ) y el paquete
<package>net-tools</package>:
<example>
$ ping <var>yahoo.com</var> # verificar la conexión a Internet
$ traceroute yahoo.com      # rastrear paquetes IP
$ ifconfig                  # verificar la configuración del 
                            # anfitrión (host)
$ route -n                  # verificar la configuración de la ruta
$ dig [@dns-server.com] host.dom [{a|mx|any}] |less
      # verificar registros host.dom DNS [@ dns-server.com] para  
      # un registro [{mx|any}]
$ ichains  -L -n |less      # verificar filtrado de paquetes (kernel 2.2)
$ iptables -L -n |less      # verificar filtrado de paquetes (kernel 2.4)
$ netstat -a                # mostrar todos los puertos abiertos
$ netstat -l --inet         # mostrar los puertos en escucha
$ netstat -ln --tcp         # mostrar puertos tcp en escucha (numérico)
</example>
</sect1>

<sect1>Eliminar mensajes de la cola local
<p>
Para eliminar los mensajes de la cola local:
<example>
# exim -q    # eliminar mensajes en espera
# exim -qf   # eliminar todos los mensajes
# exim -qff  # eliminar incluso mensajes bloqueados
</example>
"-qff" puede resultar mejor para el script /etc/ppp/ip-up.d/exim.
</sect1>

<sect1>Eliminar mensajes bloqueados de la cola local
<p>
Para eliminar mensajes de correo bloqueados de la cola local
reenviando el mensaje de error:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Redistribuir los contenidos de mbox 
<p>
Si se llenó su directorio personal y procmail falló  necesitará
distribuir en forma manual sus mensajes de 
<file>/var/mail/<var>usuario</var></file> a los buzones de correo
situados en su directorio personal. Luego de hacer espacio en
el mismo, haga:
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>usuario</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>Borrar el contenido de un archivo
<p>
Para borrar el contenido de un archivo (un archivo log, por ej.) no utilice
<tt>rm</tt> para eliminarlo y <tt>mkdir</tt> para crealo nuevamente, ya que el
archivo puede estar siendo consultado en el intervalo comprendido entre la
ejecución de ambos comandos. Lo siguiente es la manera más segura de borrar el
contenido de un archivo.  $ :&gt;<var>archivo-a-eliminar</var>
</sect1>

<sect1>Archivos fantasma
<p>
Los siguientes comandos creará archivos fantasmas (archivos vacíos):
<p>
<example>
$ dd if=/dev/zero  of=<var>nombre_archivo</var> bs=1k count=5 # 5KB de
                                                              # contenido
                                                              # cero
$ dd if=/dev/urandom of=<var>nombre_archivo</var> bs=1m count=7 # 7MB de
                                                                # contenido
                                                                # al azar
$ touch <var>nombre_archivo</var>  #  crear un archivo de 0B (si el archivo
                                   # existe actualizar mtime)
</example>
</sect1>

<sect1><prgn>chroot</prgn>
<p>
Supongamos que ha instalado una distribución Linux completa (puede ser otra
versión de &debian; o incluso una distribución Red Hat) en
<file><var>/dev/hda1</var></file> y posee otra distribución Linux instalada en
<file><var>/dev/hda2</var></file>. Puede ejecutar el sistema de
<file><var>/dev/hda1</var></file> sin volver a arrancar el sistema
<file><var>/dev/hda2</var></file> compartiendo el mismo kernel.
<example>
# mount /dev/hda1 /mnt/target   
 ... suponiendo que /dev/hda1 contiene un sistema entero
# chroot /mnt/target
 ... Ahora el contenido de /dev/hda1 se ve como el directorio raíz.
# mount proc /proc              # por si acaso 
 ... ejecute el comando dentro de /dev/hda1
</example>
Esto permite cargar las ramas estable/de prueba/inestable en una misma
máquina.  Asimismo, uno puede ejecutar un programa que requiera gran cantidad
de memoria (por ejemplo, <prgn>dselect</prgn>) en una máquina anfitrión,
montando  una máquina auxiliar (máquina satélite) mediante NFS en modo
lectura/escritura y accediendo a ella mediante
<prgn>chroot</prgn>.
<p>
En woody, el sistema chroot puede crearse fácilmente con el comando
<prgn>debootstrap</prgn>.
<example>
# mkdir woodychroot
# debootstrap woody woodychroot
# chroot woodychroot
# apt-setup # configura el /etc/apt/sources.list
</example>
<p>
Existe un paquete chroot más especializado, <package>pbuilder</package>,
que crea un sistema chroot y compila un paquete dentro de chroot. Es un 
sistema ideal para verificar que las dependencias de compilación de un
paquete sean correctas y para estar seguros que no existan dependencias
no necesarias o falsas en el paquete resultante.
<p>
Véase <url id="&setup-chroot;">
</sect1>
<sect1>Cómo verificar los enlaces duros
<p>
Puede ver si dos archivos son uno solo con 2 enlaces duros, haciendo:
<example> 
$ ls -li <var>archivo1</var> <var>archivo2</var>
</example>
 
<sect1>Montar una imagen del disco duro
<p>
Si <file><var>archivo.img</var></file> contiene una imagen de los contenidos
de un disco duro y el disco original tenía una configuración
<var>xxxx</var> = (bytes/sector) * (sectores/cilindro),
entonces lo siguiente la montará en <file>/mnt</file>:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>archivo.img</var> /mnt
</example>
Obsérvese que la mayoría de los discos duros tienen 512 bytes/sector.

<sect1>Samba
<p>
Lo básico para obtener archivos desde Windows:
<example>
# mount -t smbfs -o <var>username=mi_nombre,uid=mi_uid,gid=mi_gid</var> \
    <var>//server/share /mnt/smb</var>  # monta un directorio Windows en Linux
# smbmount <var>//server/share /mnt/smb</var> \
  -o "<var>username=mi_nombre,uid=mi_uid,gid=mi_gid</var>"
# smbclient -L <var>192.168.1.2</var> # lista los archivos compartidos de una
                                      # máquina
</example>                                    
<p>
Los vecinos de Samba se pueden localizar desde Linux haciendo:
<example>
# smbclient -N -L <var>dirección_ip_de_su_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

</sect>

</chapt>

