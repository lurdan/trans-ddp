<!-- CVS revision of this document "$Revision: 1.4 $"  -->
<!-- CVS revision of original english document "1.16.4.2"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="program">Programación

<p>
No use la palabra "test" para designar un archivo ejecutable de prueba.
<prgn>test</prgn> es un comando del shell.
<sect>Dónde empezar
<p>
<em>Linux Programming Bible</em> (John Goerzen/IDG books)
<p>
Documentos y ejemplos de <file>/usr/share/doc/&lt;paquetes&gt;</file>
<p>
Una gran cantidad de extensos documentos con información se puede
obtener del proyecto <url id="&gnuhome;" name="GNU">.
<p>
Las siguientes 4 secciones contienen algunos scripts de ejemplo en
diferentes lenguajes de programación para crear un archivo de texto con
información de las cuentas para agregarse al archivo
<file>/etc/passwd</file> usando un procesador por lotes como lo es el
programa <prgn>newusers</prgn>. Cada script requiere como entrada de un
archivo con una serie de líneas de la forma: <tt>nombre apellido
contraseña</tt> (estos scripts no crearán los directorios 'home' de los
usuarios)
</sect>

<sect>BASH
<p>
<em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
<example>
$ info bash
$ mc   /usr/share/doc/bash/examples/ /usr/share/doc/bash/
</example>
(Instale el paquete <package>bash-doc</package> para ver archivos de
ejemplo)
<p>
Pequeño programa de ejemplo (sirve como entrada para el comando
<prgn>newusers</prgn>):
<example>
#!/bin/bash
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>
</sect>

<sect>AWK
<p>
<em>Effective awk Programming</em>, 3rd edition, and <em>sed &amp;
awk</em>, 2nd edition (O'Reilly)
<example>
$ man awk
$ info awk
</example>
Pequeño programa de ejemplo (sirve como entrada para el comando
<prgn>newusers</prgn>)
<example>
#!/usr/bin/awk -f
# Script para crear un archivo que sirva para usar con el comando
# newusers a partir de un archivo que contiene las IDs y contraseñas de
# los usuarios de la siguiente manera: nombre apellido contraseña
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distribuido bajo GNU GPL v 2 o cualquier versión posterior.
# Este programa se distribuye SIN NINGUNA GARANTÍA.

BEGIN {
    # Asignar UID, GID iniciales
    if ( ARGC &gt; 2 ) {
	startuid = ARGV[1]
	delete ARGV[1]
    }
    else {
        printf( "Uso: newusers UIDinicial archivo\n" \
	  "...donde UIDinicial es el ID del primer usuario " \
	  "a agregar y 'archivo' es \n" \
	  "un archivo de entrada de la forma: \n"\
	  "'nombre apellido contraseña'\n" \
	)
	exit
    }

    infile = ARGV[1]
    printf( "Primer UID: %s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n",  \
	user, passwd, uid, gid, first, last, user \
	)
}
</example>
</sect>

<sect>PERL
<p>
<em>Programming Perl</em>, 3rd edition (O'Reilly)
<example>
$ man perl
</example>
Pequeño programa de ejemplo (sirve como entrada para el comando
<prgn>newusers</prgn>)
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
	if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Instalar el módulo  Perl <var>nombre módulo</var>:
<example>
# perl -MCPAN -e 'install <var>nombre_modulo</var>'
</example>
 
</sect>

<sect>PYTHON
<p>
<em>Learning Python</em> (O'Reilly).
Es un intérprete muy agradable.
<example>
$ man python
</example>
Pequeño programa de ejemplo (sirve como entrada para el comando
<prgn>newusers</prgn>)
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Adaptado del script awk por KMSelf Sat Aug 25 20:47:38 PDT 2001
# Este programa se distribuye SIN NINGUNA GARANTÍA.

def usages():
    print \
"Uso:  ", sys.argv[0], " UID_inicial [nombre_archivo]\n" \
"\tUID_inicial es el ID del primer usuario a agregar.\n" \
"\tnombre_archivo es el nombre del archivo de entrada.\n" \
"Si no se especifica, se toma la entrada estándar.\n\n" \
"Formato del archivo de entrada:\n"\
"\tnombre apellido contraseña\n"
		return 1

def parsefile(startuid):
    #
    # filtrado principal
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # lo anterior falla con un # equivocado de parámetros :-)
        user = first[0] + last
        gid = uid
        lineout = "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n" %  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID empieza desde: %d\n" % uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Leer archivo desde: %s\n\n" % infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>MAKE
<p>
<em>Managing Projects with make</em>, 2nd edition (O'Reilly)
<example>
$ info make
</example>
Variables automáticas sencillas:
<p>
Sintáxis de las reglas:
<example>
Objetivo: [ Prerequisito ... ]
&lt; TAB &gt; comando1
&lt; TAB &gt; -comando2 # ignorar errores
&lt; TAB &gt; @comando3 # evitar repetición
</example>
Cada línea es interpretada por el shell antes de la sustitución de
variables por parte de make.
Utilice la <tt>\</tt> al final de la línea para continuar el script.
Utilice <tt>$$</tt> para escribir el <tt>$</tt> para las variables de
entorno para un script de shell.
<p>
Reglas implícitas equivalentes:
<example>
.c:   header.h == %  : %.c header.h
.o.c: header.h == %.c: %.o header.h
</example>
Variables automáticas para las reglas anteriores:
<example>
foo.o: nuevo1.c nuevo2.c.c original1.c nuevo3.c
$@ == foo.o                                  (objetivo)
$< == nuevo1.c                               (el primero)
$? == nuevo1.c nuevo2.c nuevo3.c             (los nuevos)
$^ == nuevo1.c nuevo2.c original1.c nuevo3.c (todos)
$* == `%' patrón correspondiente al patrón objetivo.
</example>
Referencia de las variables:
<example>
foo1 := bar    # Expansión única
foo2  = bar    # Expansión recursiva
foo3 += bar    # Añade
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:%.c=%.o) 
OBJS := $(patsubst %.c,%.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extrae "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Ejecute <tt>make -p -f/dev/null</tt> para ver las reglas automáticas
internas. 
</sect>

<sect>C
<p>
Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 2nd
edition (Prentice Hall).
Para consultar sobre las funciones de biblioteca de C en GNU:
<example>
# apt-get install glibc6-doc manpages-dev
</example>
Para consultar sobre las funciones de biblioteca de C, escriba
"<prgn>info libc</prgn>".
Cada función C está documentada en la sección 3 del manual del sistema.
Ejemplo: <tt>man 3 printf</tt>.

<sect1>Programa sencillo en C (<prgn>gcc</prgn>)
<p>
Un simple ejemplo <prgn>example.c</prgn> para compilar con la biblioteca
<prgn>libm</prgn> y obtener el ejecutable <prgn>run_example</prgn>:
<example>
$ cat &gt; exemple.c 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
    double x;
    char y[11];
    x=sqrt(argc+7.5);
    strncpy(y, argv[0], 10); /* evita el desbordamiento del búfer */
    y[10] = '\0'; /* para asegurar que la cadena termine con un '\0' */
    printf("%5i, %5.3f, %10s, %10s\n", argc, x, y, argv[1]);
    return 0;
}

$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
    1, 2.915, ./run_exam,     (null)
$ ./run_exam, 1234567890qwerty
    2, 3.082, ./run_exam, 1234567890qwerty
</example>
Aquí, <tt>-l<strong>m</strong></tt> se necesita para enlazar la
biblioteca <tt>lib<strong>m</strong></tt> y poder así usar sqrt().  La
biblioteca actual se encuentra en el directorio <file>/lib</file> con el
nombre <file>libm.so.6</file> que es un enlace lógico a
<file>libm-2.1.3.so</file>.
<p>
Observe el último parámetro del texto de salida. Existen más de 10
caracteres a pesar de haber especificado <tt>%10s</tt>.  
<p>
El uso de funciones que efectuan operaciones con punteros sin verificar
sus limítes, tales como <prgn>sprintf</prgn> y <prgn>strcpy</prgn>, es
censurado pues no evita las vulnerabilidades que surgen por
desbordamiento de búfers.  Utilice, en cambio, <prgn>snprintf</prgn> y
<prgn>strncpy</prgn>.
</sect1>

<sect1>Depurar (<prgn>gdb</prgn>)
<p>
<url id="&gdbtutorial;" name="GDB tutorial">
<p>
Utilice <prgn>gdb</prgn> para depurar un programa compilado con la
opción <tt>-g</tt>. Muchos de los comandos se pueden abreviar.  La
expansión del tabulador funciona de igual manera que en el shell.
<example>
$ info gdb
...
$ gdb programa
(gdb) b 1                # coloca un punto de ruptura en la línea 1
(gdb) run arg1 arg2 arg3 # ejecuta programa
(gdb) next               # va a la siguiente línea
...
(gdb) step               # avanza un paso
...
(gdb) p parm             # imprime parámetro 
...
(gdb) p parm=12          # inicializa el valor del parámetro en 12
</example>
<p>
Pueden también resultar útiles los siguientes comandos.
<list>
<item><prgn>ldd</prgn>:  muestra las dependencias de las bibliotecas
                         compartidas
<item><prgn>strace</prgn>: rastrea las señales y llamadas al sistema
<item><prgn>ltrace</prgn>: rastrea las llamadas a las bibliotecas
</list>
<p>
Para depurar dentro de Emacs, diríjase a <ref id="editkey">.
</sect1>

<sect1>Flex &ndash; un Lex mejorado
<p>
Necesita proporcionar su propia <prgn>main()</prgn> y
<prgn>yywrap()</prgn>, o su <prgn>programa.l</prgn> se vería así al
compilar sin la biblioteca (<prgn>yywrap</prgn> es una macro;
<tt>%option main</tt> activa en forma implícita a <tt>%option
noyywrap</tt>):
<example>
%option main
%%
.|\n	ECHO ;
%%
</example>
Alternativamente, puede compilar con la opción -<tt>lfl</tt> del
enlazador al final de la línea de comando de <prgn>cc</prgn> (como
ATT-Lex con <tt>-ll</tt>). En este caso no se necesita la
<tt>%option</tt>.
</sect1>

<sect1>Bison &ndash; un Yacc mejorado
<p>
Necesita proporcionar su propia <prgn>main()</prgn> y
<prgn>yyerror()</prgn>.  <prgn>main()</prgn> llama a
<prgn>yyparse()</prgn> que llama a <prgn>yylex()</prgn> que ha sido
generalmente creada con FleX.
<example>
%%

%%    *

* ltrace
</example>
</sect1>

<sect1>Autoconf &ndash; desinstalar
<p>
SI cuenta con los fuentes, SI éstos utilizan autoconf/automake y SI
puede recordar cómo lo  configuró:
<example>
$ ./configure todas-las-opciones-de-configuración
# make uninstall
</example>
</sect1>

</sect>

<sect>SGML
<p>
SGML permite la creación de múltiples formatos de un mismo documento. Un
sistema SGML sencillo es Debiandoc que es el que se usó aquí.  Este
requiere de pequeñas adaptaciones en los archivos de texto originales
para los siguientes caracteres:
<example>
&lt;   &amp;lt;
&gt;   &amp;gt;
&amp;   &amp;amp;
&copy;   &amp;copy;
&ndash;   &amp;ndash;
&mdash;   &amp;mdash;
</example>
Para marcar una sección como comentario, escriba:
<example>
&lt;!-- El tema empieza aquí ... --&gt;
</example>
Para marcar una sección que necesita modificarse, escriba:
<example>
&lt;![ %FIXME [ El tema empieza aquí ... ]]&gt;
</example>
En SGML,  la <em>primer definición</em> de una entidad gana.  Por
ejemplo:
<example>
&lt;!entity % qref "INCLUDE"&gt;
&lt;![ %qref [ &lt;!entity param "Datos 1"&gt; ]]&gt;
&lt;!entity param "Datos 2"&gt;
&amp;param;
</example>
Esto finaliza como "Datos 1".  Si en la primer línea figurara "IGNORE"
en vez de "INCLUDE" finalizaría como "Datos 2" (la segunda línea es una
sentencia condicional).
<p>
Para más detalles: <tt>apt-get install debiandoc-sgml-doc</tt>.  
También, consulte a 
<em>DocBook: The Definitive Guide</em>, de Walsh y Muellner (O'Reilly)
</sect>

<sect id="packaging">Creación de paquetes Debian
<p>
Lea la documentación que viene con el paquete
<package>packaging-manual</package> (Potato) o
<package>debian-policy</package> (Woody).
<p>
Use <prgn>dh_make</prgn> del paquete <package>dh-make</package> para
crear un paquete base.  Luego, proceda según las instrucciones de
<manref name="dh-make" section="1"> que utiliza <prgn>debhelper</prgn>
en <prgn>debian/rules</prgn>.
<p>
Un enfoque alternativo consiste en usar <prgn>deb-make</prgn> del
paquete <package>debmake</package>.  No utiliza los scripts de
<prgn>debhelper</prgn> y depende únicamente del shell.
<p>
Para ejemplos de paquetes con múltiples fuentes, véase "mc"
(<tt>dpkg-source -x mc_4.5.54.dsc</tt>) que utiliza "sys-build.mk" de
Adam Heath (<email>doogie@debian.org</email>) y "glibc" (<tt>dpkg-source
-x glibc_2.2.4-1.dsc</tt>) que usa otro sistema creado por Joel Klecker
(<email>espy@debian.org</email>).
</sect>

</chapt>
