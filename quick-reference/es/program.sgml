<!-- CVS revision of original english document "1.73"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->


<chapt id="program">Programación
<p>
No use la palabra "test" para designar un archivo ejecutable de prueba.
<prgn>test</prgn> es un comando del shell.

<sect>Dónde empezar
<p>
Referencias:
<list compact>
<item>Documentos y ejemplos de <file>&dochome;<var>paquetes</var></file>
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
Una gran cantidad de extensos documentos con información se puede
obtener del proyecto <url id="&gnuhome;" name="GNU">.
<p>
Las siguientes 4 secciones contienen algunos scripts de ejemplo en
diferentes lenguajes de programación para crear un archivo de texto con
información de las cuentas para agregarse al archivo
<file>/etc/passwd</file> usando un procesador por lotes como lo es el
programa <prgn>newusers</prgn>. Cada script requiere como entrada de un
archivo con una serie de líneas de la forma: <tt>nombre apellido
contraseña</tt> (estos scripts no crearán los directorios 'home' de los
usuarios)
</sect>

<sect id="shell">Shell
<p>
Leer los scripts de shell es la <strong>mejor</strong> manera de entender cómo
funciona un sistema tipo Unix. Aquí, brindo algunos enlaces y recordatorios
para la programación del shell. Véase <url id="&shell-mistakes;" name="Shell
Mistakes"> para aprender de los errores.

<sect1 id="bash">Bash &ndash el intérprete de comandos interactivo estándar de 
<strong>GNU</strong>
<p>
Referencias para Bash:
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item><url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
del LDP como documento introductorio.
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
(Instale el paquete <package>bash-doc</package> para ver archivos de ejemplo)
<item><em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
</list>
<p>
Pequeño programa de ejemplo (sirve como entrada para el comando
<prgn>newusers</prgn>):
<example>
#!/bin/bash
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">Intérpretes de comandos POSIX
<p>
En &debian; diversos paquetes proporcionan un intérprete de comandos POSIX:
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Prioridad: opcional
  <item>Tamaño de instalación: 176
  <item>Lejos, el más pequeño y el más rápido; el mejor para el arranque inicial
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Prioridad: opcional
  <item>Tamaño de instalación: 180
  <item>Pequeño y muy rápido &ndash; bueno para el arranque inicial
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Esencial: sí
  <item>Prioridad: requerido
  <item>Tamaño de instalación: 580
  <item>El más grande y más completo &ndash; posee diversas extensiones
        implementadas
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Prioridad: opcional
  <item>Tamaño de instalación: 408
  <item>Clon del ksh de AT&amp;T 
 </list>
</list>
<p>
Si desea escribir scripts de shell portables, resulta conveniente
escribirlos como script de shell POSIX .  Use <file>/bin/sh</file> enlazado con
<prgn>ash</prgn> o (<prgn>dash</prgn>) para comprobar su compatibilidad POSIX. 
Evite escribir scripts usando la sintaxis propia del bash  o
del zsh. 
Por ejemplo, evite usar:
<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>archivo</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>
<p>
La descripción de los intérpretes de comandos en el presente documento se
aplica únicamente a aquellos del tipo POSIX y no a <prgn>csh</prgn> incluyendo
a <prgn>tcsh</prgn>.


<sect1 id="shell-param">Parámetros del intérprete de comandos
<p>
Diversos <strong>parámetros especiales</strong> para recordar:
<example compact>
$0      = nombre del shell o del script del shell
$1      = primer argumento
 ...
$9      = noveno argumento
$#      = cantidad de parámetros
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = estado de salida del comando más reciente
$$      = PID del script de shell
$!      = PID del proceso en segundo plano más reciente
</example>
<p>
<strong>Expansiones de parámetros</strong> básicas para recordar:
<example compact>
    Forma       Si <var>var</var> está   Si <var>var</var> 
                inicializada  no está inicializada
${<var>var</var>:-<var>cadena</var>}  $<var>var</var>          <var>cadena</var>
${<var>var</var>:+<var>cadena</var>}  <var>cadena</var>        null
${<var>var</var>:=<var>cadena</var>}  $<var>var</var>          <var>cadena</var> 
                              (y ejecute <var>var</var>=<var>cadena</var>)
${<var>var</var>:?<var>cadena</var>}  $<var>var</var>          (repite <var>cadena</var> y luego sale)
</example>
Aquí, en realidad, los `:' son opcionales para todos los operadores.
<list compact>
<item>Con los `:' = el operador comprueba la existencia y la no nulidad.
<item>Sin los `:' = el operador comprueba únicamente la existencia.
</list>
<p>
<strong>Sustituciones de parámetros</strong> básicas para recordar:
<example compact>
    Forma       Resultado
${<var>var</var>&percnt;<var>sufijo</var>}   Elimina el patrón <var>sufijo</var> más pequeño
${<var>var</var>&percnt;&percnt;<var>sufijo</var>}  Elimina el patrón <var>sufijo</var> más grande
${<var>var</var>#<var>prefijo</var>}  Elimina el patrón <var>prefijo</var> más pequeño
${<var>var</var>##<var>prefijo</var>} Elimina el patrón <var>prefijo</var> más grande
</example>

<sect1 id="shell-redirect">Redireccionamiento del shell
<p>
<strong>Redireccionamiento</strong> básico para recordar
(aquí el [<var>n</var>] es un número opcional para especificar el descriptor de archivo):
<example compact>
[<var>n</var>]&gt; <var>archivo</var>    Redirige stdout (o <var>n</var>) al <var>archivo</var>.
[<var>n</var>]&gt;&gt; <var>archivo</var>   Añade stdout (o <var>n</var>) al <var>archivo</var>.
[<var>n</var>]&lt; <var>archivo</var>    Redirige stdin (o <var>n</var>) desde el <var>archivo</var>.
[<var>n1</var>]&gt;&amp;n2        Redirige stdout (o <var>n1</var>) a
<var>n2</var>.
2&gt; <var>archivo</var> &gt;&2   Redirige stdout y stderr al <var>archivo</var>.
| <var>comando</var>       Desvía stdout al <var>comando</var>.
2&gt;&1 | <var>comando</var>   Desvía stderr y stdout <var>comando</var>.
</example>
Aquí:
<list compact>
<item>stdin: entrada estándar (descriptor de archivo = 0)
<item>stdout: salida estándar (descriptor de archivo = 1)
<item>stderr: error estándar (descriptor de archivo = 2)
</list>

<p>
El intérprete de comandos le permite abrir archivos usando el comando
propio <prgn>exec</prgn> con un descriptor de archivo arbitrario.
<example>
$ echo Hola &gt;loquesea1
$ exec 3&lt;loquesea1 4&gt;loquesea2  # abrir archivos
$ cat &lt;&amp;3 &gt;&amp;4       # redirigir stdin a 3, stdout a 4
$ exec 3&lt;&amp;- 4&gt;&amp;-    # cerrar archivos
$ cat loquesea2
Hola
</example>
Aquí <var>n</var><tt>&lt;&amp;-</tt> y <var>n</var><tt>&gt;&amp;-</tt>
significan cerrar el descriptor de archivo <var>n</var>.

<sect1 id="shell-cond">Operadores condicionales del shell
<p>
Todos los comandos devuelven un <strong>estado de salida</strong> que se
pueden utilizar para expresiones condicionales:
<list compact>
<item>Éxito: 0 (Verdadero)
<item>Error: 1 - 255 (Falso)
</list>
Obsérvese que aquí el valor 0, contrariamente a la convención
habitual en otras áreas de la computación, significa "verdadero".
Asimismo, `[' es equivalente al comando <prgn>test</prgn>,
que evalúa sus argumentos hasta `]' como expresión condicional.
<p>
<strong>Expresiones condicionales</strong> básicas para recordar:
<example compact>
<var>comando</var> && <var>si_éxito_ejecutar_también_este_comando</var> ||
verdadero
<var>comando</var> || <var>si_fracaso_ejecutar_en_cambio_este_comando</var>

if [ <var>expresión_condicional</var> ]; then  
 <var>si_éxito_ejecutar_este_comando</var>
else
 <var>si_fracaso_ejecutar_este_comando</var>
fi
</example>
En este caso <tt>|| verdadero</tt> se necesita para asegurarse
que este script de shell no salga accidentalmente en esta línea
al invocar el intérprete de comandos con la opción <tt>-e</tt>.
<p>
Los operadores de comparación  de <strong>archivos</strong>
en las expresiones regulares son:
<example compact>
-e <var>archivo</var>            Verdadero si <var>archivo</var> existe.
-d <var>archivo</var>            Verdadero si <var>archivo</var> existe y es un directorio.
-f <var>archivo</var>            Verdadero si <var>archivo</var> existe y es un archivo normal.
-w <var>archivo</var>            Verdadero si <var>archivo</var> existe y se puede escribir.
-x <var>archivo</var>            Verdadero si <var>archivo</var> existe y es ejecutable.
<var>archivo1</var> -nt <var>archivo2</var> Verdadero si <var>archivo1</var> es más reciente que <var>archivo2</var> (modificación)
<var>archivo1</var> -ot <var>archivo2</var> Verdadero si <var>archivo1</var> es más antiguo que <var>archivo2</var> (modificación)
<var>archivo1</var> -ef <var>archivo2</var> Verdadero si son el mismo dispositivo o tienen igual ínodo.
</example>
<p>
Los operadores de comparación de <strong>cadenas</strong> en las
expresiones condicionales son:
<example compact>
     -z <var>str</var>    Verdadero si la longitud de <var>str</var> es igual a cero.
     -n <var>str</var>    Verdadero si la longitud de <var>str</var> es distinta de cero.
<var>str1</var> == <var>str2</var>   Verdadero si las <var>str</var> son iguales.
<var>str1</var> = <var>str2</var>    Verdadero si las <var>str</var> son iguales.
     (debería usarse "=" en vez de "==" para una extricta compatibilidad POSIX) 
<var>str1</var> != <var>str2</var>   Verdadero si las <var>str</var> son distintas.
<var>str1</var> &lt;  <var>str2</var>   Verdadero si <var>str1</var> está antes que <var>str2</var> (depende del local).
<var>str1</var> &gt;  <var>str2</var>   Verdadero si <var>str1</var> está después que <var>str2</var> (depende del local).
</example>
<p>
Los operadores de comparación <strong>aritmética</strong> entera en las expresiones
condicionales son <tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>, 
<tt>-le</tt>, <tt>-gt</tt> o <tt>-ge</tt>.
</sect1>

<sect1 id="clprocess">Tratamiento de la línea de comandos
<p>
El intérprete de comandos procesa un script de la siguiente manera:
<list compact>
<item>separación de <strong>símbolos</strong> mediante metacaracteres: ESPACIO, TAB, NEWLINE, ;, (, ), &lt;, &gt;, |, &amp;
<item>búsqueda de <strong>palabras claves</strong> si no están entre "..." o '...' (bucle)
<item>expansión de <strong>alias</strong> si no están entre "..." o '...' (bucle)
<item>expansión de <strong>llaves</strong>, A{b|c} -> Ab Ac, si no están entre "..." o '...'
<item>expansión de <strong>tildes</strong>, ~<var>user</var> -> $HOME/$USER, si no están entre "..." o '...'
<item>expansión de <strong>parámetros</strong>, $<var>PARAMETER</var>, si no están entre '...'
<item>expansión de <strong>sustitución de comandos</strong>, $(<var>comando</var>), si no están entre '...'
<item>separación en <strong>palabras</strong> con $IFS si no están entre "..." o '...'
<item>expansión de <strong>nombres de rutas</strong> *?[] si no están entre "..." o '...'
<item>búsqueda de <strong>comando</strong>
<list compact>
<item>función
<item>comando interno
<item>archivo en el $PATH
</list>
<item>bucle
</list>
<p>
Las comillas simples dentro de las dobles no tienen ningún efecto.
<p>
Al ejecutar <tt>set -x</tt> en el intérprete de comandos o al invocar este
último con la opción <tt>-x</tt> hará que se muestren todos los comandos
ejecutados. Esto resulta bastante práctico para depurar.
</sect1>

</sect>

<sect id="awk">Awk
<p>
Referencias para Awk:
<list compact>
<item><em>Effective awk Programming</em>, 3rd edition (O'Reilly)
<item><em>Sed &amp; awk</em>, 2nd edition (O'Reilly)
<item><manref name="mawk" section="1"> y <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
Pequeño programa de ejemplo (sirve como entrada para el comando
<prgn>newusers</prgn>)
<example>
#!/usr/bin/awk -f
# Script para crear un archivo que sirva para usar con el comando
# newusers a partir de un archivo que contiene las IDs y contraseñas de
# los usuarios de la siguiente manera: nombre apellido contraseña
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distribuido bajo GNU GPL v 2 o cualquier versión posterior.
# Este programa se distribuye SIN NINGUNA GARANTÍA.

BEGIN {
    # Asignar UID, GID iniciales
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Uso: newusers UIDinicial archivo\n" \
          "...donde UIDinicial es el ID del primer usuario " \
          "a agregar y 'archivo' es \n" \
          "un archivo de entrada de la forma: \n"\
          "'nombre apellido contraseña'\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Primer UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
En &debian; dos paquetes proveen <package>awk</package> POSIX:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Prioridad: requerido
  <item>Tamaño de instalación: 228
  <item>Más pequeño y mucho más rápido &ndash; útil para una instalación predeterminada
  <item>Compile-time limits exist
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Prioridad: opcional
  <item>Tamaño de instalación: 1708
  <item>Más grande y completo &ndash; posee diversas extensiones
        implementadas
  <list compact>
   <item>System V Release 4 version of UNIX
   <item>awk de laboratorios Bell
   <item>específicas de GNU
  </list>
 </list>
</list>
</sect>

<sect id="perl">Perl
<p>
Este es <strong>él</strong> intérprete interpreter on a Unix-like system.
<p>
Referencias para Perl:
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3rd edition (O'Reilly)
<item><url id="&perlhome;" name="The Perl Directory">
</list>
<p>
Pequeño programa de ejemplo (sirve como entrada para el comando
<prgn>newusers</prgn>)
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Instalar el módulo  Perl <var>nombre módulo</var>:
<example>
# perl -MCPAN -e 'install <var>nombre_modulo</var>'
</example>
 
</sect>

<sect id="python">Python
<p>
Es un intérprete orientado a objetos  muy agradable.
<p>
Referencias para  Python:
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
<item><url id="&pythonhome;" name="Python Programming Language">
</list>
<p>
Pequeño programa de ejemplo (sirve como entrada para el comando
<prgn>newusers</prgn>)
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Adaptado del script awk por KMSelf Sat Aug 25 20:47:38 PDT 2001
# Este programa se distribuye SIN NINGUNA GARANTÍA.

def usages():
    print \
"Uso:  ", sys.argv[0], " UID_inicial [nombre_archivo]\n" \
"\tUID_inicial es el ID del primer usuario a agregar.\n" \
"\tnombre_archivo es el nombre del archivo de entrada.\n" \
"Si no se especifica, se toma la entrada estándar.\n\n" \
"Formato del archivo de entrada:\n"\
"\tnombre apellido contraseña\n"
                return 1

def parsefile(startuid):
    #
    # filtrado principal
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # lo anterior falla con un # equivocado de parámetros :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID empieza desde: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Leer archivo desde: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect id="make">Make
<p>
Referencias for Make:
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2nd edition (O'Reilly)
</list>

<p>
Variables automáticas sencillas:
<p>
Sintaxis de las reglas:<example>
<var>Objetivo</var>: [<var>Prerequisito</var> ... ]
 [TAB] <var>comando1</var>
 [TAB] -<var>comando2</var>         # ignorar errores
 [TAB] <var>@comando3</var>         # evitar repetición
 </example>

Aquí <tt>[TAB]</tt> es un TAB.
Cada línea es interpretada por el shell antes de la sustitución de
variables por parte de <prgn>make</prgn>.
Utilice la <tt>\</tt> al final de la línea para continuar el script.
Utilice <tt>$$</tt> para escribir el <tt>$</tt> para las variables de
entorno para un script de shell.
<p>
Las <strong>reglas implícitas</strong> para el <var>objetivo</var> y
los <var>prerequisitos</var> se pueden escribir, por ejemplo, así:
<example>
&percnt;: &percnt;.c header.h
</example>
o,
<example>
&percnt;.o: &percnt;.c header.h
</example>
En este caso, el <var>objetivo</var> contiene el carácter <tt>&percnt;</tt>
(exactamente uno de ellos).  El <tt>&percnt;</tt> puede corresponderse 
con cualquier subcadena no vacía en los nombres de los archivos objetivo 
actuales. Asimismo, los <var>prerequisitos</var> usan <tt>&percnt;</tt> 
para mostrar cómo se relaciones sus nombres con el nombre del objetivo
actual.
<p>
Las <strong>reglas de sufijo</strong> son una forma <strong>obsoleta</strong>
de definir reglas implícitas para <prgn>make</prgn>. Por compatibilidad, aún
son admitidas en el <prgn>make</prgn> GNU pero, en lo posible, utilice las
reglas de patrón equivalentes:
<example>
antigua regla de sufijo --&gt; nueva regla de patrón
.c:                     --&gt; &percnt;  : &percnt;.c
.c.o:                   --&gt; &percnt;.o: &percnt;.c
</example>
Variables automáticas para las reglas anteriores:
<example>
foo.o: nuevo1.c nuevo2.c original1.c nuevo3.c
$@ == foo.o                                  (objetivo)
$< == nuevo1.c                               (el primero)
$? == nuevo1.c nuevo2.c nuevo3.c             (los nuevos)
$^ == nuevo1.c nuevo2.c original1.c nuevo3.c (todos)
$* == `&percnt;' patrón correspondiente al patrón objetivo.
</example>
Referencia de las variables:<example>
foo1 := bar    # Expansión única
foo2  = bar    # Expansión recursiva
foo3 += bar    # Añade
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extrae "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Ejecute <tt>make -p -f/dev/null</tt> para ver las reglas automáticas
internas. 
</sect>

<sect id="c">C
<p>
Preparación:
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
Referencias para C:
<list compact>
<item><tt>info libc</tt> (referencia de funciones de biblioteca C)
<item><manref name="gcc" section="1">
<item><manref name="each_C_library_function_name" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 
 2nd edition (Prentice Hall).
</list>
<p>

<sect1>Programa sencillo en C (<prgn>gcc</prgn>)
<p>
Un simple ejemplo <prgn>example.c</prgn> para compilar con la biblioteca
<file>libm</file> y obtener el ejecutable <prgn>run_example</prgn>:
<example>
$ cat &gt; exemple.c &lt;&lt; EOF 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
    double x;
    char y[11];
    x=sqrt(argc+7.5);
    strncpy(y, argv[0], 10); /* evita el desbordamiento del búfer */
    y[10] = '\0'; /* para asegurar que la cadena termine con un '\0' */
    printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
    return 0;
}
EOF
$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
    1, 2.915, ./run_exam,     (null)
$ ./run_example, 1234567890qwerty
    2, 3.082, ./run_exam, 1234567890qwerty
</example>
Aquí, <tt>-l<strong>m</strong></tt> se necesita para enlazar la
biblioteca <tt>lib<strong>m</strong></tt> y poder así usar sqrt().  La
biblioteca actual se encuentra en el directorio <file>/lib</file> con el
nombre <file>libm.so.6</file> que es un enlace lógico a
<file>libm-2.1.3.so</file>.
<p>
Observe el último parámetro del texto de salida. Existen más de 10
caracteres a pesar de haber especificado <tt>&percnt;10s</tt>.  
<p>
El uso de funciones que efectuan operaciones con punteros sin verificar
sus limítes, tales como <prgn>sprintf</prgn> y <prgn>strcpy</prgn>, es
censurado pues no evita las vulnerabilidades que surgen por
desbordamiento de búfer.  Utilice, en cambio, <prgn>snprintf</prgn> y
<prgn>strncpy</prgn>.
</sect1>

<sect1>Depurar 

<sect2>Depurando con <prgn>gdb</prgn>
<p>
Preparación:
<example>
# apt-get install gdb
</example>
<p>
Referencias para <prgn>gdb</prgn>:
<list compact>
<item><tt>info gdb</tt> (tutorial)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>

<p>
Utilice <prgn>gdb</prgn> para depurar un programa compilado con la
opción <tt>-g</tt>. Muchos de los comandos se pueden abreviar.  La
expansión del tabulador funciona de igual manera que en el shell.
<example>
$ gdb programa
(gdb) b 1                # coloca un punto de ruptura en la línea 1
(gdb) run <var>arg1 arg2 arg3</var> # ejecuta programa
(gdb) next               # va a la siguiente línea
...
(gdb) step               # avanza un paso
...
(gdb) p parm             # imprime parámetro 
...
(gdb) p parm=12          # inicializa el valor del parámetro en 12
</example>
<p>
Para depurar dentro de Emacs, diríjase a <ref id="editkey">.

<p>
En un sistema &debian, la mayoría de los símbolos de depuración han
sido eliminados.
Para que <prgn>gdb</prgn> resulte útil para depurar paquetes
&debian;, es necesario volver a construir dichos paquetes
siguiendo los siguientes pasos:
<list compact>
<item>Edite <file>debian/control</file> para volcar el paquete
<url id="&policy-version;" name="version">.
<item>Verifique los scripts de creación y asegúrese usar <tt>CFLAGS=-g
-Wall</tt> para compilar los binarios.
<item>Exporte <tt>DEB_BUILD_OPTIONS=nostrip,noopt</tt> para crear
el paquete &debian;.
</list>
Véase <url name="Policy 10.1" id="&strip-symbols;"> para mayor información.

</sect2>
<sect2 id="ss-ldd">Verificar dependencias con bibliotecas
<p>
Utilice <prgn>ldd</prgn> para averiguar las dependencias de un programa
con respecto a las bibliotecas:
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
Para que <prgn>ls</prgn> funcione en un entorno <prgn>chroot</prgn>,
deben esta disponibles las mencionadas bibliotecas.

<p>
Pueden también resultar útiles los siguientes comandos.
<list compact>
<item><prgn>strace</prgn>: rastrea las señales y llamadas al sistema
<item><prgn>ltrace</prgn>: rastrea las llamadas a las bibliotecas
</list>
</sect2>

<sect2>Depurar con herramientas de detección de fugas de memoria
<p>
Existen diversas herramientas de detección de fugas de memoria
disponibles en &debian;.
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (el paquete no existe, obténgalo de 
 <url id="&memwatch-home;" name="memwatch">.)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> de
  <url id="&parasofthome;" name="Parasoft">. (propietario, commercial for fee)
</list>
<p>
También consulte <url id="&mallocdebughome;" 
  name="Herramientas de depuración para la asignación de almacenamiento
  dinámico y administración de memoria">.


<sect1>Flex &ndash; un Lex mejorado
<p>
<prgn>flex</prgn> es un generador de analizadores sintácticos muy veloz.
<p>
Referencias para <prgn>flex</prgn>:
<list compact>
<item><tt>info flex</tt> (tutorial)
<item><manref name="flex" section="1">
</list>

<p>
Necesita proporcionar su propia <prgn>main()</prgn> y
<prgn>yywrap()</prgn>, o su <file>programa.l</file> se vería así al
compilar sin la biblioteca (<prgn>yywrap</prgn> es una macro;
<tt>&percnt;option main</tt> activa en forma implícita a <tt>&percnt;option
noyywrap</tt>):
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
Alternativamente, puede compilar con la opción <tt>-lfl</tt> del
enlazador al final de la línea de comando de <prgn>cc</prgn> (como
ATT-Lex con <tt>-ll</tt>). En este caso no se necesita la
<tt>&percnt;option</tt>.
</sect1>

<sect1>Bison &ndash; un Yacc mejorado
<p>
En &debian; diversos paquetes proporcionan un generador de analizadores
LALR compatible con Yacc:
<p>
<list compact>
 <item><package>bison</package>: generador de analizador LALR GNU
 <item><package>byacc</package>: el generador de analizador LALR de Berkeley 
 <item><package>btyacc</package>: generador de analizador con backtracking
 basado en byacc
</list>
<p>
Referencias para <prgn>bison</prgn>:
<list compact>
<item><tt>info bison</tt> (tutorial)
<item><manref name="bison" section="1">
</list>

<p>
Necesita proporcionar su propia <prgn>main()</prgn> y
<prgn>yyerror()</prgn>.  <prgn>main()</prgn> llama a
<prgn>yyparse()</prgn> que llama a <prgn>yylex()</prgn> que ha sido
generalmente creada con FleX.
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf 
<p>
<prgn>autoconf</prgn> es una herramienta para crear scripts de shell 
que automáticamente configuran los paquetes con código fuente
para adaptarlos a distintos tipos de sistemas tipo UNIX
que utilizan el sistema de compilación GNU.  
<p>
<prgn>autoconf</prgn> crea el script de configuración 
<prgn>configure</prgn>.  <prgn>configure</prgn> 
crea automáticamente un <file>Makefile</file> y un
<file>Makefile.am</file> personalizados.
 
<sect2>Compilar e instalar un programa
<p>
&debian; no toca los archivos situados en <file>/usr/local/</file> (véase 
<ref id="diverse">). Por lo tanto, si compila un programa a partir
de sus fuentes, instálelo en <file>/usr/local/</file> de modo que no
interfiera con &debian;.
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # esto ubica los archivos en el sistema
</example>

<sect2>Desinstalar un programa
<p>
SI cuenta con los fuentes, SI éstos utilizan
<prgn>autoconf</prgn>/<prgn>automake</prgn> y SI
puede recordar cómo lo  configuró:
<example>
$ ./configure <var>todas-las-opciones-que-eligió</var>
# make uninstall
</example>
<p>
Alternativamente, si está absolutamente sequro que el proceso de instalación
ubicó todos los archivos únicamente en <file>/usr/local/</file> y que
no hay nada importante allí, puede borrar todo su contenido haciendo:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
Si no está seguro dónde fueron instalados los archivos, considere
el uso de <package>checkinstall</package> que permite desinstalaciones
limpias.
</sect1>
</sect>
<sect id="cgi">Web
<p>
Se pueden crear páginas web dinámicas interactivas sencillas de la siguiente
forma:
<list compact>
<item>Las peticiones son mostradas en el navegador del usuario
usando formularios HTML.
<item>Al llenar y pulsar en las entradas del formulario se envia una URL con
parámetros codificados
<footnote>
En este caso <tt>%nn</tt> se utiliza para el carácter codificado hexadecimal
<tt>nn</tt>.
</footnote>
desde el navegador al servidor web. Por ejemplo:
<list compact>
<item><tt>http://www.loquesea.dom/cgi-bin/program.pl?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.loquesea.dom/cgi-bin/program.py?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.loquesea.dom/program.php?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
</list>

<item>El programa CGI (cualquiera de <prgn>program.*</prgn>) en el servidor
web recibirá los parámetros descodificados "<tt>VAR1=VAL1 VAR2=VAL2
VAR3=VAL3</tt>" como contenido de la variable de entorno
"<tt>QUERY_STRING</tt>" y se ejecutará.
<item>La <tt>stdout</tt> del programa CGI se enviará al navegador web y se
presentará como una página web dinámica interactiva.
</list>
Por cuestiones de seguridad no cree artesalmente nuevos artificios para
analizar parámetros CGI.  Existen módulos para ellos en Perl (véase <ref
id="perl">) y Python (véase <ref id="python">).  <url id="&phphome;"
name="PHP"> viene con esta funcionalidad. Cuando se necesita almacenamiento de
datos del lado del cliente se utilizan cookies.  Cuando se necesita procesar
datos del lado del cliente, frecuentemente se utiliza javascript.
<p>
Para más información, véase <url id="http://hoohoo.ncsa.uiuc.edu/cgi/"
name="The Common
Gateway Interface">, <url id="&apachehome;" name="The Apache Software 
Foundation"> y <url id="&javascripthome;" name="JavaScript">.
<p>
Si se busca "CGI tutorial" en Google escribiendo
la URL <tt>&google-eg;</tt>
directamente en el navegador es una buena manera de
ver el script CGI del servidor Google en acción.
<!--
http://www.google.com/search?hl=en&ie=UTF-8&q=CGI+tutorial
http://stein.cshl.org/WWW/CGI/
http://stein.cshl.org/WWW/docs/handout.html
http://stein.cshl.org/WWW/software/mailmerge/
-->


<sect id="doc-prep">Preparación de documentos

<p>
<sect1 id="roff">Tratamiento de texto <tt>roff</tt>
<p>
Tradicionalmente, <tt>roff</tt> es el sistema de tratamiento
de texto principal de Unix.
<p>
Véase <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7"> e
"<tt>info groff</tt>".
<p>
Existe un buen tutorial sobre macros <prgn>-me</prgn>.
Si tiene groff (1.18 o posterior), busque <file>&f-meintro;</file> y
haga lo siguiente:
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
Lo que sigue creará un archivo de texto:
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
Para imprimir use la salida PostScript.
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>

<sect1 id="sgml">SGML
<p>
Preparación:
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
Referencias de <package>debiandoc-sgml</package>:
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em><url name="DocBook: The Definitive Guide"
      id="&f-docbook-defguide;"></em>, de Walsh y Muellner, (O'Reilly)
      (paquete <package>&p-docbook-defguide;</package>)
</list>
<p>
SGML permite la creación de múltiples formatos de un mismo documento. Un
sistema SGML sencillo es Debiandoc que es el que se usó aquí.  Este
requiere de pequeñas adaptaciones en los archivos de texto originales
para los siguientes caracteres:
<!-- nbsp bug in PDF ? -->
<list compact>
<item>"&lt;" --&gt; <tt>&amp;lt;</tt>
<item>"&gt;" --&gt; <tt>&amp;gt;</tt>
<item>"&nbsp;" --&gt; <tt>&amp;nbsp;</tt>  (espacio sin ruptura)
<item>"&amp;" --&gt; <tt>&amp;amp;</tt>
<item>"&percnt;" --&gt; <tt>&amp;percnt;</tt>
<item>"&copy;" --&gt; <tt>&amp;copy;</tt>
<item>"&ndash;" --&gt; <tt>&amp;ndash;</tt>
<item>"&mdash;" --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
Para marcar una sección como comentario, escriba:
<example>
&lt;!-- El tema empieza aquí ... --&gt;
</example>
Para marcar una sección que necesita modificarse, escriba:
<example>
&lt;![ &percnt;FIXME [ El tema empieza aquí ... ]]&gt;
</example>
En SGML,  la <em>primer definición</em> de una entidad gana.  Por
ejemplo:
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref [ &lt;!entity param "Datos 1"&gt; ]]&gt;
&lt;!entity param "Datos 2"&gt;
&amp;param;
</example>
Esto finaliza como "Datos 1".  Si en la primer línea figurara "IGNORE"
en vez de "INCLUDE" finalizaría como "Datos 2" (la segunda línea es una
sentencia condicional).   Asimismo, las frases que se repiten se pueden
definir de antemano separadas del contexto.
<example>
&lt;!entity <var>esto</var> "mi"&gt;
Hola &amp;<var>esto</var>; amigo.
Este es &amp;<var>esto</var>; libro.
</example>
Esto resulta en lo siguiente:
<example>
Hola mi amigo.
Este es mi libro.
</example>
Vea el pequeño ejemplo en SGML <file>sample.sgml</file> en los 
<url id="&examples;" name="ejemplos">.
<p>
Cuando los documentos SGML aumentan de tamaño TeX, que es utilizado como
interfaz del procesador de texto, puede provocar,a veces, errores <ref
id="texlatex">.
<!-- XXX FIXME XXX: Add XML section-->

<sect1 id="texlatex">TeX/LaTeX
<p>
Preparación:
<example>
# tasksel # seleccionar Miscelánea  --&gt; Entorno TeX/LaTeX
</example>
Referencias para LaTeX:
<list compact>
<item><url id="&tetex-howto;" name="The teTeX HOWTO: The Linux-teTeX Local Guide">
<item><manref name="tex" section="1">
<item><manref name="latex" section="1">
<item><em>The TeXbook</em>, de Donald E. Knuth, (Addison-Wesley)
      <footnote>
        Los fuentes TeX para este libro se encuentra disponible en 
        <url id="&texbooksource;">.  <url id="&texbookmacros;"> contiene
	la mayoría de las macros necesarias. Puede procesar este documento
	con <prgn>tex</prgn> luego de comentar las líneas 7 a 10 y añadir
        <tt>\input manmac \proofmodefalse</tt>.
        <p>
        Es altamente recomendable adquirir este libro (y todos los otros
	libros de Donald E. Knuth) en vez de usar la versión en línea. Pero
	los fuentes ¡ son un ejemplo magnífico de TeX !
      </footnote>
<item><em>LaTeX - A Document Preparation System</em>, de Leslie Lamport,
      (Addison-Wesley)
<item><em>The LaTeX Companion</em>, de Goossens, Mittelbach, Samarin,
      (Addison-Wesley)
</list>
<p>
Éste es el entorno más poderoso para la composición de documentos. Muchos
procesadores SGML lo utilizan como su procesador de texto.  Lyx proporcionado
por <package>lyx</package>, <package>lyx-xforms</package> o
<package>lyx-qt</package> y GNU TeXmacs, proporcionado por el paquete
<package>texmacs</package>, ofrecen un entorno de edición WYSIWYG agradable
para LaTeX mientras que muchos utilizan a Emacs y Vim como editores de los
archivos fuente.
<p>
Existen diversos recursos disponibles en Internet:
<list compact>
<item><url id="&f-tetex-doc;" name="teTeX - A Documentation Guide">
      (paquete <package>&p-tetex-doc;</package>)
<!-- translators please add the following documents: 
1) "The Not So Short Introduction to LaTeX2e"
(&f-tetex-doc; links to an English copy on harddisk (slightly outdated))
There exist many translations (and MUCH more documents in ../):
ftp://ftp.dante.de/tex-archive/info/lshort/
2) ftp://ftp.dante.de/tex-archive/info/<your-language>

PS: I (Jens) don't like the following references (too short, external)
-->
<item><url id="&pfaffbenhome;" name="A Quick Introduction to LaTeX">
<item><url id="&latexlyx;" name="A Simple Guide to Latex/Lyx">
<item><url id="&latexbasic;" name="Word Processing Using LaTeX">
<item><url id="&local-guide;" name="Local User Guide to teTeX/LaTeX">
</list>
Cuando los documentos SGML aumentan de tamaño TeX puede, a veces,
provocar errores. Debe incrementar el tamaño del repositorio en 
<file>/etc/texmf/texmf.cnf</file> (o mejor editar 
<file>/etc/texmf/texmf.d/95NonPath</file> y ejecutar 
<prgn>update-texmf</prgn>) para solucionarlo.

<sect1 id="literate">Programación ilustrada
<p>
En vez de escribir código que contenga documentación, el programador ilustrado
escribe documentación que contiene código. Este enfoque asegura una buena
documentación del programa.
<p>
Para más información sobre programación ilustrada, véase
<url id="&literatehome;" name="Literate Programming">.

<sect2 id="noweb">Noweb
<p>
Preparación:
<example>
# apt-get install nowebm
</example>
Referencias para Noweb:
<list compact>
<item><url id="&nowebhome;" name="Noweb --- A Simple, Extensible Tool for Literate Programming">
<item><manref name="noweb" section="1">
</list>
<p>
Esta herramienta de la programación ilustrada del tipo  WEB es mucho más
sencilla ya que provee extensibilidad e independencia de lenguaje. 
<footnote>
Esta WEB no tiene <strong>nada</strong> que ver con la World Wide Web.  
WEB (para PASCAL) y CWEB (para C/C++) son herramientas tradicionales para la
programación ilustrada.
</footnote>
Cuando se invoca <prgn>noweb</prgn>, escribe el código fuente del programa en
los archivos mencionados en el archivo noweb y crea un archivo TeX para la
composición de la documentación.
<p>
El  paquete &debian; <package>ifupdown</package> es un buen ejemplo.
<example>
$ apt-get source ifupdown
$ cd ifupdown*
$ make ifupdown.pdf ifupdown.ps
</example>
<sect2 id="doxygen">Doxygen
<p>
Preparación:
<example>
# apt-get install doxygen doxygen-doc doxygen-gui
</example>
Referencias para Doxygen (¡creado por <prgn>doxygen</prgn>!):
<list compact>
<item><url id="&doxygenhome;" name="Página principal">
<item><url id="/usr/share/doc/doxygen-doc/html/index.html">
</list>
<p>
Puede generar documentación HTML, RTF, páginas de manual Unix, PostScript y
PDF (usando LaTeX) para C++, C, Java, IDL y, con en cierto grado, para
programas en PHP y C#.  Doxygen es compatible con JavaDoc (1.1), Qt-Doc, KDOC
y fue específicamente diseñado para ser usado en proyecto que utilizan el
conjunto de herramientas <url id="&qthome;" name="Qt"> de Troll Tech.  Al
crear incluye gráficos de dependencia, diagramas de colaboración y gráficos
jerárquicos incluso para programas no documentados. La salida es similar a la
de la documentación Qt.

<sect id="packaging">Creación de paquetes Debian
<p>
Preparación:
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
        &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # en el caso de Potato
</example>
Referencias para la creación de paquetes:
<list compact>
 <item>(<ref id="pkg-basics"> fundamentos)
 <item>Guía para Nuevos Encargados de Debian (tutorial)
 <item><manref name="dh-make" section="1">
 <item>Referencia para los Desarrolladores de Debian (práctico)
 <item>Manual de Normativa de Debian (oficial)
 <item>Manual para la creación de paquetes (Potato) 
</list>

<sect1 id="pack-binary">Empaquetar un único binario
<p>
Método rápido para empaquetar un único binario por Joey Hess.
<example>
# mkdir -p mi_pqt/usr/bin mi_pqt/DEBIAN
# cp binario mi_pqt/usr/bin
# cat &gt; mi_pqt/DEBIAN/control
Package: mi_paquete
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;     
Description: mi pequeño paquete
No espere demasiado.
^D
# dpkg-deb -b mi_pqt
</example>

<sect1 id="pack-dh-make">Empaquetando con herramientas
<p>
Utilice <prgn>dh_make</prgn> del paquete <package>dh-make</package>
para crear la arquitectura del paquete.  Luego, proceda de acuerdo
a las instrucciones de <manref name="dh-make" section="1"> que
utiliza <prgn>debhelper</prgn> en <prgn>debian/rules</prgn>.
<p>
Otro enfoque consiste en usar <prgn>deb-make</prgn> del paquete
<package>debmake</package> que no utiliza los scripts de <prgn>debhelper</prgn>
y depende únicamente del intérprete de comandos.
<p>
Para ejemplos de múltiples paquetes fuente, véase "mc" (<tt>dpkg-source -x
mc_4.5.54.dsc</tt>) que utiliza "sys-build.mk" por Adam Heath
(<email>doogie@debian.org</email>) y "glibc" (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>) que utiliza un sistema diferente de Joel Klecker
(<email>espy@debian.org</email>).
</sect>
</chapt>
