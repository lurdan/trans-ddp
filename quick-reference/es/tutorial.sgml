<!-- CVS revision of original english document "1.93"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="tutorial">Tutoriales de &debian;
<!-- new content -->
<p>
Esta sección proporciona una orientación al mundo &debian; para aquellos que
son realmente principiantes. Si ya hace cierto tiempo que utiliza un sistema
tipo Unix, es probable que conozca todo lo que se explica aquí. En este caso,
considérelo un repaso.

<sect id="first">Primeros pasos
<p>
<!-- new content -->
Tras la instalación de &debian; en su PC, necesitará aprender algunos
conceptos para que le resulte útil. Le proporcionaremos un rápido entrenamiento.

<sect1 id="login-root">Ingresar al sistema como superusuario
<p>
<!-- new content -->
Luego de reiniciar el sistema, y dependiendo de los paquetes seleccionados,
accederá a una pantalla de acceso gráfico o bien a otra basada en caracteres.
Por simplicidad, si se le presenta una pantalla de acceso gráfico presione
Ctrl-Alt-F1 
<footnote>
La tecla Ctrl izquierda, la tecla Alt izquierda y la tecla F1 se deben
presionar simultáneamente.
</footnote>
para acceder a la pantalla de acceso basada en caracteres. 
<p>
Supongamos que el nombre de su máquina es <tt><var>loquesea</var></tt>,
entonces el símbolo del sistema será similar a:
<example>
<var>loquesea</var> login:
</example>
Escriba <tt>root</tt> , pulse la tecla Intro e ingrese la contraseña que
eligió durante el proceso de instalación. Siguiendo la tradición Unix, un
sistema &debian; diferencia mayúsculas de minúsculas. A continuación, el
sistema se iniciará con un mensaje de bienvenida y le mostrará el símbolo del
sistema del superusuario a la espera de datos.
<footnote>
Observe que si editó el mensaje de bienvenida situado en <file>/etc/motd</file>,
éste será diferente.
</footnote>
<example>
<var>loquesea</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>loquesea</var>:root#
</example>
<p>
Ahora está listo para realizar la administración del sistema desde la cuenta
de root llamado también superusuario o usuario privilegiado. Desde esta
cuenta, puede hacer todo:
<list compact>
<item>leer, escribir y eliminar cualquier archivo del sistema
independientemente de sus permisos
<item>asignar un propietario y los permisos a cualquier archivo del 
sistema
<item>asignar la contraseña a cualquier usuario no privilegiado
del sistema
<item>acceder a todas las cuentas sin necesitar sus contraseñas
</list>
<p>
Resulta una pésima idea compartir la cuenta de root utilizando la misma
contraseña. La manera correcta de compartir los privilegios del administrador
consiste en usar un programa como <manref name="sudo" section="8">.
<p>
Obsérvese que en Unix se considera un buen hábito entrar al sistema
inicialmente como usuario no privilegiado incluso si planea realizar tareas
administrativas. Utilice los comandos <tt>sudo</tt>, <tt>super</tt> o <tt>su
-c</tt> para obtener privilegios restringidos de superusuario cuando sea
necesario.  Véase <ref id="sudo">.
<footnote>
Debo admitir que acostumbro usar la cuenta de superusuario más a menudo que lo
necesario por sencillez y pereza.
</footnote>

<sect1 id="newbiefix">Configurar un entorno mínimo para principiantes
<p>
<!-- new content -->
Considero que aprender un sistema informático es como aprender un idioma extranjero.
Aunque los libros resultan útiles, se debe practicarlo con herramientas de ayuda.
En este contexto, creo que es una buena idea instalar algunos paquetes
adicionales tales
como <package>mc</package>,
<package>vim</package>, <package>lynx</package>, 
<package>doc-linux-text</package> y
<package>debian-policy</package>.
<footnote>
Puede resultar conveniente instalar <package>gpm</package>,
<package>emacs21</package> y <package>doc-linux-html</package>.  Véase
<ref id="gpm"> y <ref id="edit">.
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
 
</example>
Si ya tiene estos paquetes instalados, no se instalará nada.

<sect1 id="newuser">Añadir una cuenta de usuario
<p>
<!-- new content -->

Durante la instalación, generalmente se crea una cuenta de usuario sin
privilegios que recibe los mensajes de correo que son enviados a la cuenta del
superusuario.  
<footnote>
Habitualmente denomino a esta cuenta 
<tt>admin</tt> pero puede tener un nombre arbitrario. 
</footnote>
Puesto que tampoco querrá usar esta cuenta especial para subsiguientes las
tareas de entrenamiento, deberá crear otra cuenta de usuario nueva.
<p>
Supongamos que desea que este nombre de usuario nuevo sea <tt><var>penguin</var></tt>,
entonces si escribe: 
<example>
root@<var>loquesea</var>:root# adduser <var>penguin</var>
... responda todas las preguntas

</example>
creará dicha cuenta.  
<footnote>
Es probable que desee añadir este usuario <tt><var>penguin</var></tt> al grupo
<tt>adm</tt> para permitirle el acceso de lectura a los diversos archivos de
registros situados en <file>/var/log/</file>.  Véase <manref name="passwd"
section="5">, <manref name="group" section="5">, <manref name="shadow"
section="5">, <manref name="group" section="5">, <manref name="vipw"
section="8"> y <manref name="vigr" section="8">.  Para el significado oficial
de usuarios y grupos, véase una versión actual del documento <url
id="&f-users-and-groups;" name="Usuaris y grupos">.
</footnote>
Antes de proseguir, aprendamos primero algunas cosas más.

<sect1 id="sw-console">Alternar entre consolas virtuales
<p>

<!-- modified old content -->
En un sistema &debian; predeterminado, existen seis seudo terminales
disponibles, es decir, puede utilizar la consola de caracteres VGA del PC como
seis terminales VT-100 intercambiables. Para pasar de una a otra, pulse
simultáneamente la tecla Alt izquierda y una de las teclas F1&ndash;F6. Cada
seudo terminal permite el acceso a cuentas independientes. El entorno
multiusuario es una característica maravillosa en Unix y muy adictiva.
<p>
<!-- new content -->
Si por equivocación pulsa Alt-F7 en un sistema que está ejecutando el sistema
X Windows accederá al sistema de ventanas. Podrá recuperar el acceso a las
consolas de caracteres presionando Ctrl-Alt-F1.  Intente ir a una consola
distinta y volver a la original para acostumbrarse a esta característica.

<sect1 id="shutdown">Cómo apagar el sistema
<p>
<!-- heavily modified content -->
Al igual que cualquier otro sistema operativo moderno en donde la operación
sobre archivos implica obtener datos de la memoria, un sistema &debian;
necesita apagarse correctamente antes de poder cortar sin problemas el
suministro eléctrico y mantener la integridad de sus archivos. Utilice el
siguiente comando desde el indicador de superusario para apagar el sistema
:
<example>
# shutdown -h now
</example>
Esto sirve normalmente para un sistema multiusuario.  Si se encuentra en el
modo monousuario ejecute desde el indicador de root, lo siguiente:
<example>
# poweroff -i -f
</example>
Opcionalmente, puede pulsar Ctrl-Alt-Supr 
<footnote>
La tecla Ctrl izquierda, la Alt izquierda y la tecla Supr deben pulsarse juntas
en la consola.  En un sistema predeterminado esto provocará que el sistema se
reinicie. Necesitará modificar el <file>/etc/inittab</file> para tener el
comando <prgn>shutdown</prgn> con la opción <tt>-h</tt> como se explica en <ref
id="post-inst">.
</footnote>
<p>

Espere hasta que el sistema muestre el mensaje "System halted" para apagar la
máquina. Si la función APM o ACPI han sido debidamente activadas en la BIOS y
en Linux, el sistema se apagará por sí solo.  Véase <ref id="apm"> para más
detalles.

<sect1 id="playtime">Hora de jugar
<p>
<!-- new content -->
Ahora ya está listo para jugar con &debian; sin riesgos
siempre y cuando utilice la cuenta sin privilegios <tt><var>penguin</var></tt>.
<footnote>
Esto es así porque un sistema &debian;, incluso apenas recién instalado, se
encuentra configurado con los permisos de archivo adecuados que evitan que un
usuario sin privilegios dañe al sistema.  . Por supuesto, aún pueden existir
algunos agujeros de seguridad que se pueden aprovechar, pero aquelos que se
preocupan por este tema no deberían estar leyendo esta sección, sino  <url
id="&securing-debian-howto;" name="Securing Debian Manual">.
</footnote>
<p>
Entremos al sistema como <tt><var>penguin</var></tt>.   Si se encuentra en el
indicador del intérprete de comandos del superusrio pulse Ctrl-D 
<footnote>
Las teclas Ctrl izquierda y la tecla d deben presionarse simultáneamente.  .
No es necesario presionar la tecla Mayús aunque estos caracteres de control se
escriban en mayúsculas como en "control D".
</footnote>
para finalizar la sesión del root y volver al indicador de acceso.  Ingrese su
nombre de usuario recientemente creado <tt><var>penguin</var></tt> y su
correspondiente contraseña.
<footnote>
Si aquí escribe <tt>root</tt> en vez de <tt><var>penguin</var></tt> y la
correspondiente contraseña, accederá a la cuenta del <tt>superusuario</tt>.
Este es el procedimiento a seguir para tener acceso a la cuenta de
<tt>root</tt>.
</footnote>
Se le mostrará el siguiente indicador de comandos.
<example>
<var>penguin</var>@<var>loquesea</var>:<var>penguin</var>$ 
</example>
<p>

De ahora en adelante y por simplicidad, en los ejemplos dados
se utilizará un indicador de comandos simplificado:
<list compact>
<item><tt>#</tt> : indicador del intérprete de comandos del superusuario
<item><tt>$</tt> : indicador del usuario no privilegiado
</list>
<p>
Primero, comenzaremos a aprender &debian; de la manera fácil <ref
id="mc"> y luego de la manera adecuada <ref id="unixlike">.
<sect id="mc">Midnight Commander (MC)
<p>
Midnight Commander (MC) es la "navaja suiza" GNU para la consola de Linux y
otros entornos de terminales. Ofrece al principiante un menú desplegable en la
consola que es mucho más fácil de aprender que los comandos Unix estándar. 
<!-- New content -->
<p>
Use este comando para explorar su sistema &debian;.  Esta es la mejor manera
de aprender.  Explore la ubicación de algunas teclas usando las teclas de
desplazamiento y la tecla Intro:
<list compact>
<item><file>/etc</file> y sus subdirectorios.
<item><file>/var/log</file> y sus subdirectorios.
<item><file>/usr/share/doc</file> y sus subdirectorios.
<item><file>/sbin</file> y <file>/bin</file>
</list>

<sect1 id="mc-enhance">Mejorar MC
<p>
<!-- modified old content -->
Para que MC al salir se posicione en el directorio de trabajo, se necesita
modificar el archivo <file>~/.bashrc</file> (o el
<file>/etc/bash.bashrc</file>, que es llamado desde <file>.bashrc</file>),
como se explica en su página de manual <manref name="mc" section="1"> bajo la
opción <tt>-P</tt>.
<footnote>
Si no entiende perfectamente de lo que estoy hablando, puede hacerlo después.
</footnote>

<sect1 id="mc-start">Iniciar MC
<p>
<example>
$ mc
</example>
MC se encarga de todas las operaciones con archivos mediante menús requiriendo
de un mínimo esfuerzo por parte del usuario. Puede jugar con MC simplemente
pulsando las teclas de desplazamiento y las de función.


<footnote>
Si utiliza una terminal como <prgn>kon</prgn> o <prgn>Kterm</prgn> para
el idioma japonés que emplea determinados caracteres gráficos agregando
la  opción <tt>-a</tt> a la línea de comando del MC puede ayudar a
evitar problemas.
</footnote>

<sect1 id="mc-fm">Administrar archivos con MC
<p>
Por defecto, se tienen dos paneles con el listado de archivos de un
directorio.  Otro modo útil consiste en configurar la ventana derecha para que
muestre toda la información referente a los archivos: permisos, tamaño, etc.
Los siguientes son algunas teclas esenciales. Con el demonio <prgn>gpm</prgn>
ejecutándose es posible también usar el ratón.  Asegúrese de presionar la
tecla Mayús para cortar y pegar en el MC.
<list compact>
<item>F1: Menú de ayuda
<item>F3: Visor de archivos interno
<item>F4: Editor interno
<item>F9: Activar menú desplegable
<item>F10: Salir del Midnight Commander
<item>Tab: Moverse entre las dos ventanas
<item>Insert: Marcar archivo para operaciones con múltiples
                       archivos
<item>Supr: Borrar archivo (sea cuidadoso&mdash;configure MC
                    para el modo de borrado seguro)
<item>Teclas de desplazamiento: No necesita explicación alguna
</list>
</sect1>

<sect1 id="mc-cl">Trucos para la línea de comandos:
<p>
<list compact>
<item>Cualquier comando <prgn>cd</prgn> cambiará el directorio mostrado
en los paneles.
<item>Ctrl-Enter o Alt-Intro copiará el nombre de un
archivo en la línea del comandos. Utilice este atajo  con los comandos
<prgn>cp</prgn> o <prgn>mv</prgn>.
<item>Alt-Tab cumple el mismo rol que la tecla TAB en el shell.
<item>Se puede especificar el directorio inicial para ambas ventanas 
ingresándolos como argumentos del MC; por ejemplo, <tt>mc /etc /root</tt>.
<item>Esc + <var>número</var> == F<var>n</var>  (es decir,
  Esc + `1' = F1, etc.;
  Esc + `0' = F10)
<item>Tecla Esc == tecla Alt(= Meta,
  M- ); es decir, escriba Esc + `c' para Alt-c
</list>

<sect1 id="mcedit">Editor
<p>
El editor interno sigue un esquema de cortar-y-pegar muy interesante.  Con F3
se marca el comienzo de una selección, un segundo F3 marca el fin de la misma y
resalta el área elegida. A continuación se puede mover el cursor. Si pulsa F6
el área seleccionada se ubicará donde está el cursor. Presionando F5 el área se
copiará e insertará en dicha posición. F2 grabará el archivo. Con F10 se sale
del editor. La mayoría de las teclas de desplazamiento funcionan en forma
intuitiva.
<p>
Este editor se puede iniciar directamente junto con un archivo:
<example>
$ mc -e nombre_archivo_a_editar
$ mcedit nombre_archivo_a_editar
</example>
<p>
Si bien no se trata de un editor multiventana se pueden usar múltiples
consolas Linux para lograr el mismo efecto. Para copiar entre ventanas,
utilice las teclas Alt-F<var>n</var> para alternar entre las consolas
virtuales y use "Archivo-&gt;Insertar archivo" o "Archivo-&gt;Copiar a
archivo" para mover una porción de un archivo en otro archivo.
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I see .. but for now I do this not to hack LaTeX
-->
<p>
El editor interno se puede reemplazar por cualquier editor externo de su
preferencia.
<p>
Asimismo, muchos programas usan las variables de entorno <tt>EDITOR</tt>
o <tt>VISUAL</tt> para decidir qué editor usar.  Si no se siente cómodo
con vim, iguale estas variables a <tt>mcedit</tt> añadiendo las
siguientes líneas al <file>~/.bashrc</file>:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
En lo posible, es recomendable dejarlas en <tt>vim</tt>.  Acostumbrarse con
los comandos de vi(m) es proceder de forma correcta pués es un editor de uso
habitual en el mundo Linux/Unix.

<footnote>
En realidad, <prgn>vi</prgn> o <prgn>nvi</prgn> son los programas que
encontrará por todos lados. Elegí <prgn>vim</prgn> para los recién iniciados
porque ofrece ayuda mediante la tecla F1 además de ser bastante parecido y
mucho más poderoso.
<p>
Si no se siente cómodo con <prgn>vim</prgn>, puede seguir usando
<prgn>mcedit</prgn> para la mayoría de las tareas de mantenimiento del
sistema. Puesto que <prgn>mcedit</prgn> trabaja con 8 bits y no sabe nada de
codificaciones, a veces resulta ventajoso para editar archivos de
codificaciones desconocidas. <prgn>mcedit</prgn> no muestra correctamente
archivos UTF-8.

</footnote>

<sect1 id="mc-view">Visor
<p>
Es un visor muy sofisticado. Es una excelente herramienta para buscar palabras
en un documento. Siempre lo uso para los archivos del directorio
<file>/usr/share/doc</file>. Esta es la manera más rápida de navegar por la
inmensa cantidad de información de Linux. Este visor se puede arrancar
directamente de la siguiente manera:
<example>
$ mc -v nombre_archivo
</example>
(Obsérvese que algunos paquetes no respetan esta convención y almacenan
sus documentos en
<file>/usr/doc</file>)
</sect1>

<sect1 id="mc-auto">Inicio automático de programas
<p>
Pulse <tt>Enter</tt> sobre un archivo y el programa apropiado manejará
el contenido del archivo. Esta es una característica muy  útil del MC.
<example>
ejecutable:           Ejecuta el programa
man, archivo html:    Deriva el contenido a un visor
tar, gz, archivo rpm: Permite ver su contenido incluyendo subdirectorios
</example>
Para que esto funcione, los archivos no deben ser ejecutables. Cambie su
estado usando el comando chmod mediante el menú 'Archivo' del MC si
fuese necesario.

<sect1 id="mc-ftp">Sistema de archivos virtuales FTP
<p>
Se puede usar el MC para acceder a archivos que se encuentran en Internet via
FTP.  Vaya al menú presionando F9 luego pulse `p' para activar el sistema de
archivos virtual FTP. Ingrese la URL de la siguiente manera
<tt>nombre_usuario:contraseña@nombre_servidor.nombre_dominio</tt> y se verá al
directorio remoto como si fuera local.
<p>
<!-- new content -->
Pruebe con <tt>&ftp-debian;</tt> como URL y navegue por el sistema de archivos
de &debian;.  Consulte <ref id="ftparchives"> para ver cómo se encuentran
organizados.

<sect id="unixlike">Entorno de trabajo tipo Unix
<p>
<!-- new content -->
Aunque MC le permite hacer prácticamente todo, es muy importante que aprenda a
usar las herramientas de la línea de comandos invocadas desde el intérprete de
comandos y familiarse con el entorno de trabajo del tipo Unix.
<footnote>
En esta parte del tutorial, el intérprete de comandos significa
<prgn>bash</prgn>.  Para más información sobre los diferentes intérpretes de
comandos, véase <ref id="shell">.
</footnote>

<sect1 id="sp-keys">Combinaciones de teclas habituales
<p>
En entornos Unix, existen algunas combinaciones de teclas que
tienen un significado especial. 
<footnote>
En una consola de caracteres de Linux, únicamente las teclas Ctrl 
y Alt izquierdas funcionan como es de esperar.
</footnote>
<list compact>
<item>Ctrl-U: Borra la línea donde se encuentra el cursor.
<item>Ctrl-H: Borra el carácter situado antes del cursor.
<item>Ctrl-D: Finaliza la entrada de datos (sale del shell si está usándolo)
<item>Ctrl-C: Finaliza un programa en ejecución.
<item>Ctrl-Z: Detiene momentáneamente un programa (lo ejecuta como tarea
en segundo plano, véase <ref id="cmd-back">)
<item>Ctrl-S: Detiene la salida por pantalla.
<footnote>
Puede desactivar esta característica del terminal usando 
<manref name="stty" section="1">.
</footnote>
<item>Ctrl-Q: Activa nuevamente la salida por pantalla.
</list>
<p>
El intérprete de comandos predeterminado, <prgn>bash</prgn>, permite la
edición del histórico de comandos y el completado con tabulador para un uso
interactivo.
<list compact>
<item>flecha arriba:  Comienza la búsqueda en el histórico de comandos.
<item>Ctrl-R:  Comienza la búsqueda incremental en el histórico de comandos.
<item>TAB: Completa el nombre de archivo en la línea de comandos.
<item>Ctrl-V TAB: TAB sin expansión en la línea de comandos.
</list>
<p>
Otras combinaciones de teclas importantes para recordar:
<list compact>
<item>Ctrl-Alt-Supr:  Reinicia/detiene el sistema, véase <ref id="post-inst">.
<item>Pulsar botón izquierdo del ratón y arrastrar: Selecciona y copia al
portapapeles.
<item>Pulsar botón medio del ratón: Pega el contenido del portapapeles en
donde se encuentra el cursor.
<item>Tecla Meta (terminología de Emacs) generalmente se refiere a la tecla
Alt izquierda. En algunos sistemas se puede configurar la tecla Windows como
tecla Meta.
</list>
Para usar el ratón en la consola de caracteres Linux necesita que
<prgn>gpm</prgn> se ejecute como demonio.
<footnote>
En el entorno X Window, el ratón funciona en el programa Xterm de la misma
manera.
</footnote>
Véase <ref id="gpm">.

<sect1 id="unixcmds">Comandos Unix básicos
<p>
<!-- new content -->
Aprendamos algunos comandos Unix básicos.  
<footnote>
Aquí usaré "Unix" en sentido genérico. Cualquier sistema operativo del tipo
Unix posee comandos equivalente.  El sistema &debian; no es la exepción. Por
el momento, no se preocupe si algunos comandos no funcionan como es de
esperar. No es necesario que respete algún orden al practicar con estos
ejemplos.
</footnote>
Pruebe los siguientes comandos desde la cuenta de usuario no privilegiado
<tt><var>penguin</var></tt> :
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>Muestra el nombre del directorio actual/de trabajo.
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>Muestra el nombre del usuario actual.
 </list>
<item><tt>file <var>loquesea</var></tt>
 <list compact>
 <item>Muestra el tipo de archivo de un archivo <var>loquesea</var>.
 </list>
<item><tt>type -p <var>nombre_comando</var></tt>
 <list compact>
 <item>Muestra la ubicación del comando <tt><var>nombre_comando</var></tt>.
 <item><tt>which <var>nombre_comando</var></tt> hace lo mismo.
 <footnote>
 Si en el intérprete de comando se utiliza <tt>alias</tt>, sus salidas son
 diferentes.
 </footnote>
 </list>
<item><tt>type <var>nombre_comando</var></tt>
 <list compact>
 <item>Muestra información sobre el comando <tt><var>nombre_comando</var></tt>.
 </list>
<item><tt>apropos <var>palabra_clave</var></tt>
 <list compact>
 <item>Busca comandos relacionados con la <tt><var>palabra_clave</var></tt>.
 <item><tt>man -k <var>palabra_clave</var></tt> hace lo mismo.
 </list>
<item><tt>whatis <var>nombre_comando</var></tt>
 <list compact>
 <item>Explica en una línea el comando
  <tt><var>nombre_comando</var></tt>.
 </list>
<item><tt>man -a <var>nombre_comando</var></tt>
 <list compact>
 <item>Explica el comando
  <tt><var>nombre_comando</var></tt>. (estilo Unix)
 </list>
<item><tt>info <var>nombre_comando</var></tt>
 <list compact>
 <item>Muestra información detallada del comando
  <tt><var>nombre_comando</var></tt>.  (GNU style)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>Lista el contenido de un directorio (archivos comunes y directorios)
  <footnote>
Unix oculta los nombres de archivos que comienzan con "<tt>.</tt>".
Generalmente son achivos de configuración o que incluyen preferencias del
usuario.
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>Lista el contenido de un directorio (todos los archivos y directorios)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>Lista el contenido de un directorio (casi todos los archivos y directorios,
 es decir, omite los "<file>..</file>" y "<file>.</file>")
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>Lista todo el contenido de un directorio con información detallada. Véase <ref
  id="file-system">.
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>Lista todos los directorios del directorio actual.
 </list>
<item><tt>lsof <var>loquesea</var></tt>
 <list compact>
 <item>Muestra información sobre el archivo <tt><var>loquesea</var></tt>
 abierto por procesos.
 </list>
<item><tt>mkdir <var>loquesea</var></tt>
 <list compact>
 <item>Crea un directorio nuevo <tt><var>loquesea</var></tt> en el directorio actual.
 </list>
<item><tt>rmdir <var>loquesea</var></tt>
 <list compact>
 <item>Borra el directorio <tt><var>loquesea</var></tt> del directorio actual.
 </list>
<item><tt>cd <var>loquesea</var></tt>
 <list compact>
 <item>Cambia al directorio <file><var>loquesea</var></file> 
   del directorio actual o del directorio que figura en la variable
  <tt>CDPATH</tt>. Véase el comando <prgn>cd</prgn> de 
  <manref name="builtins" section="7">.
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>Cambia al directorio raíz.
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>Cambia al directorio personal del usuario actual.
 </list>
<item><tt>cd /<var>loquesea</var></tt>
 <list compact>
 <item>Cambia al directorio 
 <file>/<var>loquesea</var></file>.
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>Cambia al directorio padre.
 </list>
<item><tt>cd ~<var>loquesea</var></tt>
 <list compact>
 <item>Cambia al directorio <tt><var>loquesea</var></tt> del directorio
 personal del usuario.  
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>Cambia al directorio anterior.
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>Muestra el contenido de <file>/etc/motd</file> usando el paginador
 predeterminado. Véase <ref id="cmd-stdin">.
  <footnote>
El paginador predeterminado del sistema &debian; es <prgn>more</prgn> que no
permite navegar hacia atrás. Instalando el paquete <package>less</package>
mediante la línea de comandos <tt>apt-get install less</tt>, éste se convertirá
en el paginador predeterminado y prodrá navegar hacia atrás usando las teclas
de desplazamiento.
  </footnote>
 </list>
<item><tt>touch <var>loquesea</var></tt>
 <list compact>
 <item>Crea un archivo vacío <file><var>loquesea</var></file>.
 </list>
<item><tt>cp <var>loquesea</var> <var>loquefuera</var></tt>
 <list compact>
 <item>Copia el archivo <file><var>loquesea</var></file> en un
  nuevo archivo <file><var>loquefuera</var></file>.
 </list>
<item><tt>rm <var>loquesea</var></tt>
 <list compact>
 <item>Borra el archivo <file><var>loquesea</var></file>.
 </list>
<item><tt>mv <var>loquesea</var> <var>loquefuera</var></tt>
 <list compact>
 <item>Cambia el nombre un archivo existente <file><var>loquesea</var></file> en
  <file><var>loquefuera</var></file>.
 </list>
<item><tt>mv <var>loquesea</var> <var>loquefuera/cualquiera</var></tt>
 <list compact>
 <item>Mueve el archivo <file><var>loquesea</var></file> a 
  una nueva ubicación con el nombre <file><var>loquefuera/cualquiera</var></file>. El
  directorio <file><var>loquefuera</var></file> debe existir.
 </list>
<item><tt>chmod 600 <var>loquesea</var></tt>
 <list compact>
 <item>Hace que el archivo <file><var>loquesea</var></file> no pueda
 ser leído ni escrito por otros ni ejecutado por nadie.
 </list>
<item><tt>chmod 644 <var>loquesea</var></tt>
 <list compact>
 <item>Hace que el archivo <file><var>loquesea</var></file> pueda ser
 leído pero no escrito por otros ni ejecutado por nadie.
 </list>
<item><tt>chmod 755 <var>loquesea</var></tt>
 <list compact>
 <item>Hace que el archivo <file><var>loquesea</var></file> pueda ser leído
 pero no escrito por otros pero ejecutado por todos.
 </list>
<item><tt>top</tt>
 <list compact>
 <item>Muestra información de los procesos a pantalla completa.  Pulse "q" para
salir.
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>Muestra información de todos los procesos que se están ejecutando
 usando el estilo BSD. Véase <ref id="cmd-pipe">.
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>Muestra la información de todos los procesos que se están 
  ejecutando usando el estilo Unix del system-V.
 </list>
<item><tt>ps aux | grep -e "[e]xim4*"</tt>
 <list compact>
 <item>Muestra todos los procesos que ejecutan <prgn>exim</prgn> o
 <prgn>exim4</prgn>.  Aprenda sobre expresiones regulares de la página del
 manual <manref name="grep" section="1"> escribiendo <tt>man grep</tt>.
 <footnote>
 El <tt>[</tt> y el <tt>]</tt> en la expresión regular, permite evitar que
 <prgn>grep</prgn> coincida consiguo mismo.  El <tt>4*</tt> significa 0 o más
 repeticiones del carácter 4 lo cual permite a <prgn>grep</prgn> capturar tanto
 a <prgn>exim</prgn> como a <prgn>exim4</prgn>.  Aunque <tt>*</tt> se utiliza
 como carácter comodín tanto en el intérprete de comandos como en las
 expresiones regulares, su significado es diferente.
 </footnote>
 </list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item>Muestra la información de todos los procesos ejecutándose usando una
 salida ASCII.
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>Mata un proceso identificado por el ID: <var>1234</var>.
 Véase <ref id="kill">.
 </list>
<item><tt>grep -e "<var>patrón</var>" *.html</tt>
 <list compact>
 <item>Busca un "<var>patrón</var>" en todos los archivos que terminan en
  <tt>.html</tt> situados en el directorio actual y los muestra a todos.
 </list>
<item><tt>gzip <var>loquesea</var></tt>
 <list compact>
 <item>Comprime <file><var>loquesea</var></file> para crear
  <file><var>loquesea</var>.gz</file> usando el algoritmo Lempel-Ziv (LZ77).
 </list>
<item><tt>gunzip <var>loquesea</var>.gz</tt>
 <list compact>
 <item>Descomprime <file><var>loquesea</var>.gz</file> para crear
  <file><var>loquesea</var></file>.
 </list>
<item><tt>bzip2 <var>loquesea</var></tt>
 <list compact>
 <item>Comprime <file><var>loquesea</var></file> para crear
  <file><var>loquesea</var>.bz2</file> usando el algoritmo
  de compresión Burrows-Wheeler y Huffman (mejor compresión que
 <prgn>gzip</prgn>)
 </list>
<item><tt>bunzip2 <var>loquesea</var>.bz2</tt>
 <list compact>
 <item>Descomprime <file><var>loquesea</var>.bz2</file> para crear
  <file><var>loquesea</var></file>.
 </list>
<item><tt>tar -xvvf <var>loquesea.tar</var></tt>
 <list compact>
 <item>Extrae los archivos de <file><var>loquesea</var>.tar</file>.
 </list>
<item><tt>tar -xvvzf <var>loquesea</var>.tar.gz</tt>
 <list compact>
 <item>Extrae los archivos <file><var>loquesea</var>.tar.gz</file>
  .
 </list>
<item><tt>tar -xvvf --bzip2 <var>loquesea.tar.bz2</var></tt>
 <list compact>
 <item>Extrae los archivos de <file><var>loquesea</var>.tar.bz2</file>.
  <footnote>
 aquí se utiliza <tt>--bzip2</tt> en vez de ls opción <tt>-j</tt> 
 para asegurar que funcione con la versión antigua de <prgn>tar</prgn>
 que viene con Potato.
  </footnote>
 </list>
<item><tt>tar -cvvf <var>loquesea</var>.tar <var>loquesea</var>/</tt>
 <list compact>
 <item>Empaqueta el contenido de la carpeta <file><var>loquesea</var>/</file> en
  <file><var>loquesea</var>.tar</file>.
 </list>
<item><tt>tar -cvvzf <var>loquesea</var>.tar.gz <var>loquefuera</var>/</tt>
 <list compact>
 <item>Empaqueta el contenido de la carpeta <file><var>loquesea</var>/</file> en
  el archivo comprimido <file><var>loquefuera</var>.tar.gz</file>.
 </list>
<item><tt>tar -cvvf --bzip2 <var>loquesea</var>.tar.bz2 <var>loquefuera</var>/</tt>
 <list compact>
 <item>Empaqueta el contenido de la carpeta <file><var>loquefuera</var>/</file> en 
  el archivo comprimido <file><var>loquesea</var>.tar.bz2</file>.
  <footnote>
 aquí se utiliza nuevamente <tt>--bzip2</tt> por cuestiones de compatibilidad.
  </footnote>
 </list>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>Muestra el contenido del archivo comprimido
  <file>README.gz</file> usando el paginador predeterminado.
 </list>
<item><tt>zcat README.gz &gt; loquesea</tt>
 <list compact>
 <item>Crea el archivo <file>loquesea</file> con el contenido descomprimido de  
  <file>README.gz</file>.
 </list>
<item><tt>zcat README.gz <tt>&gt;</tt>&gt; loquesea</tt>
 <list compact>
 <item>Agrega el contenido descomprimido de <file>README.gz</file> al
  final del archivo <file>loquesea</file> (si no existe, primero lo crea)
 </list>
<item><tt>find . -name <var>patrón</var></tt>
 <list compact>
 <item>busca los nombres de archivo coincidentes con el <tt><var>patrón</var></tt>. 
  (lento)
 </list>
<item><tt>locate -d . <var>patrón</var></tt>
 <list compact>
 <item>busca los nombre de archivo coincidentes con el <tt><var>patrón</var></tt>.
  (más rápido si se usa la base de datos generada frecuentemente)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
Navegue por los distintos directorios e investige el sistema utilizando los
comandos anteriores a modo de entrenamiento.  Si tiene dudas sobre algún
comando en particular, lea la página del manual. Por ejemplo, los siguientes
comandos son un buen comienzo:
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
Sería también oportuno empezar con <prgn>vim</prgn> y pulsar la tecla F1.
Debería leer por lo menos las primeras 35 líneas. Luego realice el
entrenamiento en línea desplazando el cursor hasta <tt>|tutor|</tt> y
presionando Ctrl-].  Véase <ref id="edit"> para aprender más sobre editores.
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
Obsérvese que muchos comandos Unix incluyendo los de GNU y BSD muestran una
breve información de ayuda si se los invoca de alguna de las siguientes maneras
(o, en algunos casos, sin ningún argumento):
<example>
$ <var>nombre_comando</var> --help
$ <var>nombre_comando</var> -h
</example>
<p>
Pruebe también los ejemplos de <ref id="tips"> como autoaprendizaje.

<sect1 id="cmd-exec">Ejecución de comandos
<p>
<!-- new content -->
Ahora que sabe cómo usar un sistema &debian; analicemos con más profundidad el
mecanismo de ejecución de comandos.
<footnote>
He simplificado la realidad para el principiante. Véase <manref name="bash"
section="1"> para una explicación precisa.
</footnote>

<sect1 id="cmd-simple">Comandos sencillos
<p>
<!-- new content -->
Un comando sencillo es una sucesión de 
<enumlist compact>
<item>asignación de variables (opcional)
<item>nombre del comando
<item>argumentos (opcional)
<item>redirección (opcional: <tt>&gt;</tt> , <tt>&gt;</tt><tt>&gt;</tt> ,
<tt>&lt;</tt> , <tt>&lt;</tt><tt>&lt;</tt> , etc.)
<item>operadores de control (opcional: <tt>&amp;&amp;</tt> , <tt>||</tt> ;
&lt;nuevalinea&gt; , <tt>;</tt> , <tt>&amp;</tt> , <tt>(</tt> , <tt>)</tt>
)
</enumlist>
<p>
Para comandos más complejos con comillas y susbstituciones, véase <ref
id="clprocess">.

<sect1 id="cmd-env">Ejecución de comandos y variables de entorno
<p>
<!-- new content -->
La ejecución de un comando típico es del tipo:
<footnote>
Para obtener la siguiente salida, necesita instalar el locale francés, véase
<ref id="locales">.  No es fundamental para el tutorial. Esto se realiza 
para mostrar sus efectos potenciales.
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
En este caso, el programa <prgn>date</prgn> se ejecuta como tarea en segundo
plano. La variable de entorno <tt>LC_ALL</tt> esta:
<list compact>
<item>sin inicializar en el primer comando (predeterminada del sistema, como
<tt>C</tt>) 
<item>inicializada en <tt>fr_FR</tt> en el segundo comando (locale francés)
</list>
La ejecución de la mayoría de los comandos generalmente no necesitan una 
definición previa de una variable de entorno. Para el ejemplo anterior, 
se puede ejecutar alternativamente:
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
Como puede comprobar en este caso, la salida del comando se ve afectada por la
variable de entorno provocando la salida en francés.  Si desea que la variable
de entorno sea heredada por un subproceso (por ejemplo, cuando se llama a un
script del intérprete de comandos) necesitará, en cambio, "exportarla" de la
siguiente manera:
<example>
$ export LC_ALL
</example>


<sect1 id="cmd-path">Búsqueda en la ruta de comandos
<p>
<!-- new content -->
Cuando escribe un comando en el intérprete de comandos, éste lo busca en la
lista de directorios que se encuentran en la variable de entorno
<tt>PATH</tt>.  El valor de la variable de entorno <tt>PATH</tt> se denomina
ruta de búsqueda del intérprete de comandos.
<p>
En una instalación predeterminada de &debian; la variable de entorno
<tt>PATH</tt> generalmente no incluye a <file>/sbin/</file> en las cuentas de
los usuarios.  Por lo tanto si desea ejecutar comandos tales como
<prgn>ifconfig</prgn> de <file>/sbin/</file>, deberá modificar la variable de
entorno <tt>PATH</tt> para incluirlo.  Generalmente, la variable de entorno
<tt>PATH</tt> se inicializa en el archivo <file>~/.bash_profile</file>, véase
<ref id="bashconf">.

<sect1 id="cmd-opt">Opciones de la línea de comandos
<p>
<!-- new content -->
Algunos comandos usan argumentos. Los argumentos que comienzan con <tt>-</tt> o
<tt>--</tt> se denominan opciones y controlan el comportamiento del comando.
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
En este caso el argumento <tt>-R</tt> modifica el comportamiento del comando
<prgn>date</prgn> para que la salida sea RFC-2822 compatible.

<sect1 id="cmd-wild">Comodines del intérprete de comandos
<p>
<!-- new content -->
A menudo se desea que un comando funcione sobre un grupo de archivos sin tener
que escribir a todos ellos. La expansión de los nombres de archivo que utiliza
los <strong>comodines</strong> del intérprete de comandos facilita esta tarea.
<list compact>
<item><tt>*</tt>
<list compact>
<item>Coincide con cualquier grupo de 0 o más caracteres.
<item>No coincide con un nombre de archivo que comience con "<tt>.</tt>".
</list>
<item><tt>?</tt>
<list compact>
<item>Coincide exactamente con un único carácter.
</list>
<item><tt>[...]</tt>
<list compact>
<item>Coincide exactamente con un único carácter de los encerrados entre corchetes
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>Coincide exactamente con un único carácter comprendido entre <tt>a</tt> y <tt>z</tt>.
</list>
<item><tt>[^...]</tt>
<list compact>
<item>Coincide exactamente con un único carácter diferente a los encerrados entre 
corchetes (excluyendo "^").
</list>
</list>
<p>
Por ejemplo, pruebe y analice los siguientes ejemplos:
<example>
$ mkdir cosa; cd cosa; touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rm -rf cosa
</example>

<sect1 id="cmd-return">Valor devuelto por un comando
<p>
Cada comando devuelve, como valor de retorno, el estado de su salida.
<list compact>
<item>valor devuelto = 0 si el comando se ejecuta con éxito.
<item>valor devuelto = no nulo si el comando se interrumpe con error.
</list>
El valor devuelto se puede conocer mediante la variable 
<tt>$?</tt> del intérprete de comandos justo después de la ejecución.
<example>
$ [ 1 = 1 ] ; echo $?
0
$ [ 1 = 2 ] ; echo $?
1
</example>
Obsérvese que el valor devuelto es utilizado por el intérprete de comandos en
su contexto lógico, a <strong>éxito</strong> se trata como el valor lógico
<strong>TRUE</strong>.  No es muy intuitivo pues <strong>éxito</strong>
corresponde al valor <strong>cero</strong>.
<p>
Véase <ref id="shell-cond">.

<sect1 id="cmd-typical">Secuencia de comandos típica
<p>
<!-- new content in this whole sect1 ind sect2s -->
Intententemos recordar las siguientes secuencias de comandos del intérprete de
comandos.  Véase <ref id="shell-param">, <ref id="shell-redirect">, <ref
id="shell-cond"> y <ref id="clprocess"> tras su lectura.

<sect2 id="cmd-back"><tt>comando &amp;</tt>
<p>
Se ejecuta el <prgn>comando</prgn> en <strong>segundo plano</strong>.
Las tareas en segundo plano permiten a los usuarios ejecutar múltiples
programas en un único intérprete de comandos.
<p>
La administración de los procesos en segundo plano implica el uso de los
comandos incorporados del shell <prgn>jobs</prgn>, <prgn>fg</prgn>,
<prgn>bg</prgn> y <prgn>kill</prgn>. Lea las secciones de la página del manual
de <manref name="bash" section="1"> bajo los títulos "SIGNALS",  "JOB CONTROL"
y "SHELL BUILTIN COMMANDS".
<footnote>
El sistema &debian; es un sistema multitarea.
</footnote>
 
<sect2 id="cmd-pipe"><tt>comando1 | comando2</tt>
<p>
La salida estándar del <prgn>comando1</prgn> es dirigida a la 
entrada del <prgn>comando2</prgn> .  Ambos comandos pueden estar ejecutándose 
en forma <strong>concurrente</strong>.  Esto se llama <strong>tubería</strong>.

<sect2 id="cmd-list"><tt>comando1 ; comando2</tt>
<p>
El <prgn>comando1</prgn> y <prgn>comando2</prgn>
se ejecutan en forma <strong>secuencial</strong>.
 
<sect2 id="cmd-and"><tt>comando1 &amp;&amp; comando2</tt>
<p>
Se ejecuta el <prgn>comando1</prgn>.  Si lo hace correctamente, también se
ejecuta el <prgn>comando2</prgn> en forma <strong>secuencial</strong>.
Devuelve un valor verdadero si ambos comandos <prgn>comando1</prgn>
<strong>y</strong> <prgn>comando2</prgn> se ejecutan correctamente.
 
<sect2 id="cmd-or"><tt>comando1 || comando2</tt>
<p>
Se ejecuta el <prgn>comando1</prgn>. Si no se ejecuta correctamente,
se ejecuta el <prgn>comando2</prgn> en forma <strong>secuencial</strong>.
Devuelve un valor verdadero si el <prgn>comando1</prgn> <strong>o</strong>
el <prgn>comando2</prgn> se ejecuta correctamente.

<sect2 id="cmd-stdout"><tt>comando &gt; <var>loquesea</var></tt>
<p>
Redirige la salida estándar del <prgn>comando</prgn> al archivo
<tt><var>loquesea</var></tt> (se sobreescribe su contenido)

<sect2 id="cmd-stdout2"><tt>comando <tt>&gt;</tt><tt>&gt;</tt> <var>loquesea</var></tt>
<p>
Redirige la salida estándar del <prgn>comando</prgn> al archivo
<tt><var>loquesea</var></tt> (se añade a su contenido)

<sect2 id="cmd-stderr"><tt>comando &gt; <var>loquesea</var> 2&gt;&amp;1</tt>
<p>
Redirige tanto la salida como el error estándar del <prgn>comando</prgn>
al archivo <tt><var>loquesea</var></tt>.

<sect2 id="cmd-stdin"><tt>comando &lt; <var>loquesea</var></tt>
<p>
Redirije la salida estándar del <prgn>comando</prgn> al archivo
<tt><var>loquesea</var></tt>.  Pruebe:
<example>
$ &lt;/etc/motd pager
 ... (el mensaje de bienvenida)
$ pager &lt;/etc/motd
 ... (el mensaje de bienvenida)
$ pager /etc/motd
 ... (the greetings)
$ cat /etc/motd | pager
 ... (el mensaje de bienvenida)
</example>
Aunque las 4 sintaxis muestran lo mismo, el último ejemplo ejecuta
un comando <prgn>cat</prgn> extra y consume recursos sin sentido.

<sect1 id="cmd-alias">Alias de comandos
<p>
<!-- new content -->
Puede asignar un alias a un comando que utiliza a menudo.
Por ejemplo:
<example>
$ alias la='ls -la'
</example>
A partir de ahora, <prgn>la</prgn> funciona como abreviatura de <tt>ls -la</tt>
que lista todos los archivos utilizando el formato detallado.
<p>
Puede averigüar la ruta exacta o identidad de un comando haciendo
<prgn>type</prgn> comando. Por ejemplo:
<example>
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type archivo
archivo is /usr/bin/file
</example>
En este caso <prgn>ls</prgn> ha sido recientemente buscado mientras que
<prgn>file</prgn> no, de esta manera <prgn>ls</prgn> ha sido "indexado", es
decir, el shell tiene un registro interno para acceder rápidamente a la
ubicación del comando <prgn>ls</prgn>.

<sect id="text-process">Procesamiento de texto al estilo Unix
<p>
Existen algunas herramientas de procesamiento estándar de uso habitual
en sistemas tipo Unix.
<list compact>
<item>No utilizan expresiones regulares:
<list compact>
<item><prgn>head</prgn> muestra la primera parte de un archivo.
<item><prgn>tail</prgn> muestra la última parte de un archivo.
<item><prgn>sort</prgn> ordena las líneas de un archivo de texto.
<item><prgn>uniq</prgn> elimina líneas duplicadas de un archivo ordenado.
<item><prgn>tr</prgn> traduce o borra caracteres.
<item><prgn>diff</prgn> compara archivos línea por línea.
</list>
<item>Utilizan expresiones regulares sencillas (BRE):
<list compact>
<item><prgn>grep</prgn> busca texto según un patrón.
<item><prgn>ed</prgn> editor primitivo.
<item><prgn>sed</prgn> editor de flujo.
<item><prgn>vi</prgn> editor.
<item><prgn>emacs</prgn> editor.
</list>
<item>Utilizan expresiones regulares extendidas (ERE):
<list compact>
<item><prgn>egrep</prgn> busca texto según un patrón.
<item><prgn>awk</prgn> realiza procesamientos de texto sencillos.
 Véase <ref id="awk">.
<item><prgn>perl</prgn> realiza todo procesamiento de texto imaginable. 
 Véase <ref id="perl">.
</list>
</list>
Véase <ref id="perl-i">, <ref id="scrp-snip"> y <ref id="perl-mad"> 
para algunos scripts de ejemplo.


<sect1 id="regex">Expresiones regulares
<p>
Las expresiones regulares se utilizan en diversas herramientas de
procesamiento de textos. Son análogas a los comodines del intérprete de
comandos (véase <ref id="cmd-wild">), aunque más complicadas y poderosas.
<p>
Una expresión regular describe un patrón de coincidencia y está formada por
caracteres y <strong>metacaracteres</strong>. Un metacarácter es simplemente
un carácter con un significado especial. Existen dos estilos principales BRE y
ERE, dependiendo de las herramientas de texto como se describe en <ref
id="text-process">.
<p>
Para las EREs, los <strong>metacaracteres</strong> incluyen "<tt> \ . [ ] ^
&dollar; * + ? ( ) { } | </tt>". Significado de algunas expresiones
regulares:
<list compact>
<item><tt>c</tt>
<list compact>
<item>Coincide con "<tt>c</tt>".
</list>
<item><tt>\c</tt>
<list compact>
<item>Coincide con el carácter literal "<tt>c</tt>".
</list>
<item><tt>.</tt>
<list compact>
<item>Coincide con cualquier carácter incluyendo nueva línea.
</list>
<item><tt>^</tt>
<list compact>
<item>Coincide con el comienzo de una cadena.
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>Coincide con el final de una cadena.
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>Coincide con el comienzo de una palabra.
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>Coincide con el final de una palabra.
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>Coincide con cualquiera de los caracteres "<tt>abc...</tt>".
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>Niega la lista de caracteres. Coincide con cualquier carácter salvo 
 "<tt>abc...</tt>".
</list>
<item><tt>r*</tt>
<list compact>
<item>Coincide con ninguna o cualquier número de expresiones regulares representadas por
 "<tt>r</tt>".
</list>
<item><tt>r+</tt>
<list compact>
<item>Coincide con una o más expresiones regulares representadas por
 "<tt>r</tt>".
</list>
<item><tt>r?</tt>
<list compact>
<item>Coincide con ninguna o una expresión regular representada por
 "<tt>r</tt>".
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>Coincide con una de las expresiones regulares representadas por
 "<tt>r1</tt>" o "<tt>r2</tt>".
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>Coincide con una de las expresiones regulares representadas por
 "<tt>r1</tt>" o "<tt>r2</tt>" y la considera como una expresión 
regular <strong>entre paréntesis</strong>.
</list>
</list>
<p>
En las BREs los <strong>metacaracteres</strong> "<tt> + ? ( ) { } | </tt>"
pierden su significado especial si se los antecede con barras invertidas "<tt>
\+ \? \( \) \{ \} \| </tt>".  Por lo tanto, en las BREs el agrupamiento
<tt>(r1|r2)</tt> necesita escribirse <tt>\(r1|r2\)</tt>.
Aunque básicamente BRE, <prgn>emacs</prgn> trata a "<tt> + ?
</tt>" como <strong>metacaracteres</strong> no es necesario
escaparlos.  Véase <ref id="replaceex"> para ver cómo se usan
las agrupaciones.
<p>
Por ejemplo, se puede utilizar <prgn>grep</prgn> para realizar
la búsqueda de un texto usando la expresión regular:
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">Expresiones de reemplazo
<p>
En una expresión de reemplazo, los siguientes caracteres
tienen un significado especial:
<list>
<item><tt>&amp;</tt> 
<list compact>
<item>Representa lo que coincidió con la expresión regular.
(utilice <tt>\&amp;</tt> en <prgn>emacs</prgn>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>Representa lo que coincidió con la <var>enésima</var> expresión
 regular <strong>entre paréntesis</strong>.  
</list>
</list>
En Perl, se utiliza <tt>&dollar;<var>n</var></tt> 
en vez de <tt>\<var>n</var></tt> y <tt>&amp;</tt> no tiene un 
significado especial.
<p>
Por ejemplo:
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
En este caso preste atención al estilo de las expresiones regulares
<strong>entre paréntesis</strong> y cómo se utilizan las cadenas coincidentes
en el proceso de reemplazo de texto en las diferentes herramientas.
<p>
Estas expresiones regulares también se pueden utilizar para reemplazo de texto
y movimientos del cursor en los editores.
<p>
Lea todas las páginas del manual para aprender estos comandos.

<sect id="unixfile">Sistema de archivos tipo Unix
<p>
<!-- 
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
En GNU/Linux y sistemas tipo Unix, los 
<strong>archivos</strong> se organizan en <strong>directorios</strong>.
<footnote>
En algunos sistemas los <strong>directorios</strong> se denominan
<strong>carpetas</strong>. 
</footnote>
Todos los <strong>archivos</strong> y <strong>directorios</strong> se
distribuyen en un gran árbol formando la jerarquía de archivos que
cuelga de <file>/</file>.
<p>
Los archivos y directorios pueden encontrarse en distintos dispositivos. El
comando <manref name="mount" section="8"> permite anexar el sistema de
archivos situado en un determinado dispositivo al árbol de archivos principal.
Por otra parte, el comando <manref name="umount" section="8"> permite
desmontarlo.

<sect1 id="file-basics">Fundamentos sobre los archivos Unix
<p>
<!-- new content -->
Veamos:
<list compact>
<item> Los nombres de archivo diferencian mayúsculas de minúsculas.
Es decir, <file>MIARCHIVO</file> y <file>MiArchivo</file> son 
archivos <strong>diferentes</strong>.

<item>El directorio raíz se refencia simplemente mediante 
<file>/</file>. Véase <ref id="login-root">. 

<item>Cada directorio tiene un nombre que puede incluir cualquier letra o
símbolo <strong>salvo</strong> la diagonal <file>/</file>. 
<footnote>
Si bien <strong>es posible</strong> utilizar prácticamente cualquier letra o
símbolo en el nombre de un archivo, en la práctica resulta ser una mala idea.
Es conveniente evitar cualquier carácter que tiene un significado especial en
la línea de comandos, incluyendo espacios, tabulaciones, nueva líneas y otros
caracteres especiales:
<tt>{ } ( ) [ ] ' ` &quot; \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> .
<p>
Si desea separar palabras dentro de un nombre, el guión, el punto y el guión
bajo son buenas opciones. También puede escribir en mayúsculas cada palabra
integrante <tt>DeEstaManera</tt>.
</footnote>
El directorio raíz constituye una excepción; su nombre es <file>/</file>
("diagonal" o "directorio raíz") y no puede modificarse su nombre.

<item>Cada archivo o directorio se designa por su <strong>nombre de archivo
completo</strong>, <strong>nombre de archivo absoluto</strong> o
<strong>ruta</strong>, dando la secuencia de directorios que deben recorrerse
para localizarlo. Los tres términos son sinónimos. Todos los nombres de
archivo absolutos comienzan con el directorio <file>/</file> y hay una
<file>/</file> entre cada directorio o archivo en el nombre de archivo.  La
primera <file>/</file> es el nombre del directorio pero las restantes son
simplemente separadores para distinguir las partes del nombre de archivo.
<p>
Estos términos pueden ser confusos. Considere el siguiente ejemplo:
<example>
/usr/share/keytables/us.map.gz
</example>
Este es un nombre de archivo completo; algunas personas lo llaman
<strong>ruta</strong>. No obstante, la mayoría consideran como nombre de
archivo sólo a <file>us.map.gz</file>.
<footnote> 
Existe otro uso de la palabra <strong>ruta</strong>.  Véase <ref
id="cmd-path">. El significado implícito generalmente resulta claro según el
contexto.
</footnote>

<item>El directorio raíz tiene un cierto número de ramas, tales como
<file>/etc/</file> y <file>/usr/</file>. Estos subdirectorios a su vez se
ramifican en más subdirectorios tales como <file>/etc/init.d/</file> y
<file>/usr/local/</file>. Todo el conjunto se denomina <strong>árbol de
directorios</strong>.
<p>
Puede pensar en el nombre de archivo absoluto como una ruta desde la raíz del
árbol (<file>/</file>) al final de alguna rama (un archivo). También escuchará
a la gente hablar del árbol de directorios como si fuese un árbol genealógico
<strong>familiar</strong> : de esta manera los subdirectorios tienen
<strong>padres</strong> y la ruta muestra la genealogía completa de un
archivo.
<p>
También existen rutas relativas que comienzan en un lugar diferente al del
directorio raíz. Recuerde que el directorio <file>../</file> hace referencia
al directorio padre. 

<item>No existe un directorio que se corresponda a un dispositivo físico, como
por ejemplo el disco duro. Esto difiere de  CP/M, DOS y Windows donde todas
las rutas comienzan con un nombre de dispositivo tal como <tt>C:\</tt>. Véase
<ref id="file-system">.
</list>

<p>
Las mejores prácticas detalladas sobre la jerarquía de archivos
se describen en el <url id="&f-fhs;" name="Filesystem Hierarchy Standard">.
Tenga presente lo siguiente:
<list compact>
<item><file>/</file>
<list compact>
<item>Una simple <file>/</file> representa el directorio raíz.
<p>
</list>
<item><file>/etc/</file>
<list compact>
<item>Este es el lugar de los archivos de configuración para todo el sistema.
</list>
<item><file>/var/log/</file>
<list compact>
<item>Este el el lugar de los archivos de registro del sistema.
</list>
<item><file>/home/</file>
<list compact>
<item>Este es el directorio que contiene todos
los directorios principales de los usuarios no privilegiados.
</list>
</list>

<sect1 id="file-system">El concepto de sistema de archivos en
&debian;
<p>
<!-- old content modified with fs.h reference -->
Siguiendo la tradición Unix, el sistema &debian; proporciona un sistema de
archivos donde los datos físicos de los discos duros y otros sistemas de
almacenamiento , y la interacción con los dispositivos de hardware tales como
consolas locales y remotas se representan de una manera unificada.
<p>
En un sistema &debian; cada archivo, directorio, tubería con nombre o
dispositivo físico tiene una estructura de datos denominada
<strong>ínodo</strong> que describe sus atributos asociados, tales como el
usuario propietario del mismo, el grupo al cual pertenece, hora y fecha del
último acceso, etc. Véase <url id="&f-inode-def;"> para una definición exacta
de <tt>struct inode</tt> en un sistema &debian; GNU/Linux.
<p>
Esta representación unificada de las entidades físicas es muy poderosa puesto
que nos permite usar el mismo comando para la misma clase de operación en
dispositivos totalmente diferentes.
<p>
Todos los archivos pueden estar en un mismo disco o en veinte algunos de los
cuales pueden estar conectados en diferentes máquinas de una red. No es
posible deducirlo mirando simplemente al árbol de directorios y prácticamente
todos los comandos funcionan de la misma manera independientemente del/de los
dispositivo(s) físicos en los que realmente se encuentran los mismos.

<sect1 id="file-perm">Permisos de acceso de archivos y directorios
<p>
<!-- old content -->
Los permisos de acceso de los archivos y directorios se definen en forma
separada para las siguientes tres categorías de usuario:
<list compact>
<item>el <strong>usuario</strong> propietario del archivo (u), 
<item>los usuarios del <strong>grupo</strong> al que pertenece
archivo (g) y
<item>todos los <strong>otros</strong> usuarios (o).
</list>
<p>
Para un archivo, cada permiso permite:
<list compact>
<item><strong>leer</strong> (r): examinar el contenido del archivo,
<item><strong>escribir</strong> (w): modificar el archivo y
<item><strong>ejecutar</strong> (x): ejecutar el archivo como comando.
</list>
<p>
Para un directorio, cada permiso permite:
<list compact>
<item><strong>leer</strong> (r): listar el contenido del directorio,
<item><strong>escribir</strong> (w): añadir o eliminar archivos del directorio y
<item><strong>ejecutar</strong> (x): acceder a los archivos del directorio.
</list>
El permiso de <strong>ejecución</strong> de un directorio permite no sólo la
lectura de sus archivos sino la posibilidad de ver los atributos de los mismos
tales como tamaño y fecha y hora de modificación.
<p>
Para mostrar la información referente a los permisos de archivos y directorios
se utiliza el comando <prgn>ls</prgn>.  Véase <manref name="ls" section="1">.
Cuando se invoca <prgn>ls</prgn> con la opción <tt>-l</tt>, se muestra la
siguiente información :
<list compact>
<item>el <strong>tipo de archivo</strong> (primer carácter)
 <list compact>
 <item><tt>-</tt>: archivo normal
 <item><tt>d</tt>: directorio
 <item><tt>l</tt>: enlace simbólico
 <item><tt>c</tt>: nodo de dispositivo de carácter
 <item><tt>b</tt>: nodo de dispositivo de bloque
 <item><tt>p</tt>: tubería con nombre
 <item><tt>s</tt>: socket
 </list>
<item>los <strong>permisos</strong> de acceso del archivo
(los nueve caracteres, tres para cada usuario, grupo y otros
 en ese orden)
<item>el <strong>número de enlaces duros</strong> del archivo 
<item>el nombre del <strong>usuario</strong> propietario del archivo
<item>el nombre del <strong>grupo</strong> al que pertenece el archivo
<item>el <strong>tamaño</strong> del archivo en caracteres (en bytes)
<item>la <strong>fecha y hora</strong> del archivo (mtime)
<item>el <strong>nombre</strong> del archivo.
</list>
<p>
Para cambiar el propietario de un archivo se utiliza <prgn>chown</prgn> desde
la cuenta de superusuario. Para cambiar el grupo al que pertenece un archivo
se utiliza <prgn>chgrp</prgn> desde la cuenta del propietario del archivo o
desde la cuenta de superusuario. Para cambiar los permisos de acceso de un
archivo o de un directorio se utiliza <prgn>chmod</prgn> desde la cuenta del
propietario del mismo o desde la cuenta de root. Veamos la sintaxis básica
para manipular el archivo <file>loquesea</file>:
<example>
# chown <var>nuevo_usuario</var> loquesea
# chgrp <var>nuevo_grupo</var> loquesea
# chmod  [ugoa][+-=][rwx][,...] loquesea 
</example>
Véase <manref name="chown" section="1">,
<manref name="chgrp" section="1"> y
<manref name="chmod" section="1"> para más detalles.

<p>
Por ejemplo, para que el usuario <var>quiensea</var> sea propietario de un
determinado directorio que sea compartido por el grupo <var>loquesea</var>,
ejecute los siguientes comandos desde la cuenta de superusuario:
<example>
# cd /determinada/ubicación/
# chown -R <var>quiensea</var>:<var>loquesea</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
Existen tres bits más para permisos especiales:
<list compact>
<item><strong>ID usuario</strong> (s o S en vez de la x del usuario),
<item><strong>ID grupo</strong> (s o S en vez de la x del grupo) y
<item><strong>bit adherente</strong> (t o T en vez de la x de otros).
</list>
<p>
Activando el <strong>ID usuario</strong> de un archivo ejecutable se permite a
un usuario ejecutarlo con el ID del propietario del archivo (por ejemplo, el
<strong>root</strong>). Análogamente, activando el <strong>ID grupo</strong>
de un archivo ejecutable se permite a un usuario ejecutarlo con el ID del
grupo del archivo (por ejemplo, el <strong>root</strong>). Puesto que estas
activaciones pueden implicar riesgos en la seguridad del sistema se requiere
proceder con cautela.
<p>
Activando el <strong>ID grupo</strong> de un directorio se habilita el esquema
de creación de archivos del tipo BSD donde todos los archivos que se crean en
el directorio pertenecen al <strong>grupo</strong> del directorio.  
<p>
Activando el <strong>bit adherente</strong> en un directorio, se evita que un
usuario que no es propietario de un archivo lo pueda eliminar del mismo.  Para
asegurar el contenido de un archivo en directorios donde todo el mundo puede
escribir como en <file>/tmp</file> no sólo se debe desactivar el permiso de
<strong>escritura</strong> del archivo sino también activar el <strong>bit
adherente</strong> del directorio. Caso contrario, el archivo puede ser
borrado por un usuario que tenga permiso de escritura en el directorio, al
crear un nuevo archivo con el mismo nombre.
<p>
Veamos algunos ejemplos interesantes sobre permisos de archivos:
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
Usando el comando <manref name="chmod" section="1"> existe un modo alternativo de
asignar permisos a los archivos Este método utiliza entre 3 y 4 números 
escritos en octal (base 8).
Cada dígito corresponde a:
<list compact>
<item>primer dígito opcional: suma de <strong>ID usuario</strong> (=4), 
 <strong>ID grupo</strong> (=2) y <strong>bit adherente</strong> (=1)
<item>segundo dígito: suma de los permisos de  
 <strong>lectura</strong> (=4), <strong>escritura</strong> (=2) y 
 <strong>ejecución</strong> (=1) del <strong>usuario</strong>
<item>tercer dígito: ídem para <strong>grupo</strong>
<item>cuarto dígito: ídem para <strong>otros</strong>
</list>
<p>
Suena complicado pero en realidad es bastante sencillo.  Si observa las
primeras columnas (2-10) de la salida del comando <tt>ls -l</tt>
y lee sus permisos en representación binaria (base 2) (con "-" igual a
"0" y "rwx" igual a "1") le resultará familiar los permisos de archivo en
representación octal (base 8).
<footnote>
Por supuesto este método funciona únicamente para el modo numérico de tres
dígitos.
</footnote>
Por ejemplo pruebe:
<example>
$ touch <var>loquesea</var> <var>loquefuera</var>
$ chmod u=rw,go=r <var>loquesea</var>
$ chmod 644 <var>loquefuera</var>
$ ls -l <var>loquesea</var> <var>loquefuera</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>loquesea</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>loquefuera</var>
</example>
<p>
Se puede definir la máscara de permisos predeterminada usando el comando
<prgn>umask</prgn> que viene con el shell.  Véase <manref name="builtins"
section="7">.
</sect1>

<sect1 id="timestamp">Marcas de tiempo
<p>
<!-- old content, minor edit -->
En un archivo GNU/Linux existen tres tipos de marcas de tiempo:
<list compact>
<item><strong>mtime</strong>: fecha y hora de modificación (<tt>ls -l</tt>),
<item><strong>ctime</strong>: fecha y hora de cambio de estado (<tt>ls
-lc</tt>) y
<item><strong>atime</strong>: fecha y hora del último acceso  (<tt>ls
-lu</tt>).
</list>
Obsérvese que <strong>ctime</strong> no indica la fecha y hora de creación del
archivo.  
<list compact>
<item>Al sobreescribir un archivo se modifican el <strong>mtime</strong>,
  <strong>ctime</strong> y <strong>atime</strong> del mismo.
<item>Al cambiar los permisos o propietario de un archivo se modifican el
  <strong>ctime</strong> y <strong>atime</strong> del mismo.
<item>Al leer un archivo se modifica el <strong>atime</strong> del mismo.
</list>
Obsérvese que en un sistema &debian; la simple lectura de un archivo provocará
una operación de escritura  para actualizar la información referente a
<strong>atime</strong> en el <strong>ínodo</strong>.  Montando un sistema de
archivos con la opción <tt>noatime</tt> hará que el sistema omita esta
operación lo que resultará en un acceso de lectura más rápido.
Véase <manref name="mount" section="8">.
<p>
<!-- new content -->
Utilice el comando <manref name="touch" section="1"> para modificar
las marcas de tiempo de los archivos existentes.
</sect1>

<sect1 id="links">Enlaces
<p>
<!-- old content -->
Existen dos métodos de asociar un archivo <var>loquesea</var> con un nombre
de archivo diferente <var>loquefuera</var>.
<list compact>
<item>un <strong>enlace duro</strong> es un nombre duplicado de un archivo
existente (<tt>ln <var>loquesea</var> <var>loquefuera</var></tt>),
<item>un <strong>enlace simbólico</strong> es un archivo especial que apunta
al nombre de otro archivo (<tt>ln -s <var>loquesea</var>
<var>loquefuera</var></tt>).
</list>
Veamos en el siguiente ejemplo los cambios en el conteo de enlaces y las
sutiles diferencias en el resultado del comando <prgn>rm</prgn>.
<example>
$ echo "Contenido original" &gt; <var>loquesea</var>
$ ls -l <var>loquesea</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>loquesea</var>
$ ln <var>loquesea</var> <var>loquefuera</var>     # enlace duro
$ ln -s <var>loquesea</var> <var>loquesea3</var>  # enlace simbólico
$ ls -l <var>loquesea</var> <var>loquefuera</var> <var>loquesea3</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>loquefuera</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>loquesea3</var>
-&gt; <var>loquesea</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>loquesea</var>
$ rm <var>loquesea</var>
$ echo "Nuevo contenido" &gt; <var>loquesea</var>
$ cat <var>loquefuera</var>
Contenido original
$ cat <var>loquesea3</var>
Nuevo contenido
</example>
<!-- minor update below -->
Como se muestra en el ejemplo de arriba, un enlace simbólico tiene un permiso
de acceso nominal "rwxrwxrwx" y un permiso de acceso efectivo dictado por los
permisos del archivo al que apunta.

<p>
El directorio <file>.</file> apunta al propio directorio, por lo tanto el
conteo de enlaces en un directorio nuevo comienza en 2.  El directorio
<file>..</file> apunta al directorio padre, por lo tanto el conteo de enlaces
del directorio aumenta al añadir nuevos subdirectorios.

<sect1 id="fifo">Tuberías con nombre (FIFOs)
<p>
<!-- DDP Debian Tutorial content -->
<p>
Una tubería con nombre es un archivo que actúa como una tubería.  Uno añade
algo al archivo y sale por el otro extremo.  Es por eso que se denomina FIFO o
First-In-First-Out: lo primero que dirige a la tubería es lo primero que sale
por el otro extremo.
<p>
Si se escribe a una tubería con nombre, el proceso que escribe a la tubería no
finaliza hasta que la información escrita es leída de la tubería. Si se lee
desde una tubería con nombre, el proceso de lectura espera hasta que exista
algo para leer antes de finalizar.  El tamaño de la tubería es siempre cero
--- no almacena datos, sólo vincula dos procesos al igual que el <tt>|</tt>
del shell. No obstante, puesto que la tubería tiene  nombre, los dos procesos
no tienen que estar en la misma línea de comandos ni tampoco ser ejecutados
por el mismo usuario.
<p>
Puede comprobarlo haciendo lo siguiente:
<example>
$ cd; mkfifo mitubería
$ echo "hola" &gt;mitubería &amp; # poner en segundo plano
[1] <var>5952</var>
$ ls -l mitubería
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mitubería
$ cat mitubería
hola
[1]+  Done                    echo hola &gt;mitubería
$ ls mitubería
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mitubería
$ rm mitubería
</example>

<sect1 id="sockets">Sockets
<p>
<!-- new content -->
Un socket permite a los procesos intercambiar información y es similar a una
tubería con nombre (FIFO).  En el caso de los sockets estos procesos no
necesitan estar ejecutándose simultáneamente ni ser hijos de un mismo proceso
padre.  Es el extremo final de la comunicación entre procesos.  El intercambio
de información puede ocurrir en la red entre diferentes máquinas.

<sect1 id="device">Archivos de dispositivo
<p>
<!-- DDP Debian Tutorial content, modified -->
Los archivos de dispositivo se refieren a dispositivos virtuales o físicos del
sistema, tales como discos duros, tarjetas de video, pantalla o teclado. Un
ejemplo de dispositivo virtual es la consola, representado por
<tt>/dev/console</tt>.
<p>
Existen dos tipos de dispositivos: 
<list compact>
<item><strong>dispositivos de carácter</strong>
<list compact>
<item>Pueden accederse de un carácter por vez, es decir, la unidad de datos
más pequeña que se puede escribir o leer desde el dispositivo es un carácter
(un byte).
</list>
<item><strong>dispositivos de bloque</strong>
<list compact>
<item>Pueden accederse en unidades más grandes denominadas bloques que
contienen cierto número de caracteres. El disco duro es un dispositivo de
bloque.
</list>
</list>
<p>
Es posible leer archivos de dispositivos, aunque puede que contengan datos
binarios que resulten incomprensibles a los humanos. A veces resulta útil
escribir datos directamente en estos archivos para resolver problemas
relacionadas con el hardware.  Por ejemplo, se puede volcar un archivo de
texto al dispositivo de impresión <file>/dev/lp0</file> o enviar comandos al
módem desde el puerto serie <file>/dev/ttyS0</file> . Pero, salvo que se
realice esta tarea con cuidado, puede que se produzca un desastre mayor. Por
lo tanto, sea prudente.

<sect2 id="devnull"><file>/dev/null</file> etc.
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> es un archivo de dispositivo especial que descarta todo
lo que se escribe en él. Si no desea algo, arrójelo a <file>/dev/null</file>.
Básicamente se trata de un agujero negro. Al leer <file>/dev/null</file> se
obtiene inmediatamente un carácter de finalización de archivo (EOF). 
<p>
<file>/dev/zero</file> es similar, salvo que al leerlo se obtiene el
carácter <tt>\0</tt> (no es igual al número ASCII cerp).  Véase <ref
id="dummyfile">.

<sect2 id="node">Número de nodo de dispositivo
<p>
<!-- new content -->
El número de nodo de dispositivo se muestra al ejecutar <prgn>ls</prgn>:
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
Here,
<list compact>
<item>el número de dispositivo principal de <file>/dev/hda</file> es 3 y el
secundario 0. Es accesible en modo lectura/escritura por el usuario
perteneciente al grupo <tt>disk</tt>,
<item>el número de dispositivo principal de <file>/dev/ttyS0</file> es 4 y el
secundario 64. Es accesible en modo lectura/escritura por el usuario
perteneciente al grupo <tt>dialout</tt> y
<item>el número de dispositivo principal de <file>/dev/zero</file> es 1 y el
secundario 5. Es accesible en modo lectura/escritura por cualquier usuario.
</list>
<p>
Anteriormente, el proceso de instalación creaba los nodos de
dispositivos mediante el comando <prgn>/sbin/MAKEDEV</prgn>. Véase <manref
name="MAKEDEV" section="8">.
<p>
Actualmente, el sistema de archivos situado en <file>/dev</file>
se llena automáticamente por el sistema de archivos de dispositivos
similar al sistema de archivos <file>/proc</file>.

<sect1 id="procfs">Sistema de archivos <file>/proc</file>
<p>
<!-- modified heavily, original from Debian Guide -->
El sistema de archivos <file>/proc</file> es un seudo sistema de archivos que
contiene información sobre el sistema y sus procesos en ejecución.
<p>
A menudo hay quienes entran en pánico cuando detectan la presencia de un
archivo  - el <file>/proc/kcore</file> - que, generalmente, es enorme.  Este
archivo es, básicamente, una copia del contenido de la memoria de su máquina.
Se utiliza para depurar el kernel. En realidad, no existe de modo que no hay
que preocuparse por su tamaño.
<p>
Véase <ref id="proc-sys"> y <manref name="proc" section="5">.

<sect id="xtuto">Sistema X Window
<p>
<!-- practically new content -->
Véase <ref id="x">.

<sect1 id="xstart">Iniciar el sistema X Window
<p>
El sistema X Window se puede iniciar en forma automática con el demonio de
acceso gráfico <prgn>xdm</prgn> o desde la consola escribiendo lo siguiente
<example>
$ exec startx
</example>

<sect1 id="xmenu">Menú en el sistema X Window
<p>
Puesto que el entorno X puede utilizar distintos administradores de ventana su
interfaz de usuario puede variar considerablemente.  . Recuerde que al hacer
clic derecho en la ventana principal aparecerá un menú que siempre está
disponible.
<list compact>
<item>Para acceder al indicador del intérprete de comandos, inicie Xterm desde
el menú:
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>Para la navegación gráfica de páginas web, inicie Mozilla desde el menú:
<list compact>
<item>"Aplicaciones" --&gt; "Red" --&gt; "Navegador Mozilla".
</list>
<item>Para la visualización de archivos PDF, ejecute Xpdf desde el menú:
<list compact>
<item>"Aplicaciones" --&gt; "Visores" --&gt; "Xpdf".
</list>
</list>
<p>
Si no encuentra las entradas en el menú, instale los paquetes
correspondientes. Véase <ref id="apt-install">.

<sect1 id="xkeys">Combinaciones de teclas para el sistema X Window
<p>
Las siguientes son combinaciones de teclas 
importantes a tener en cuenta cuando se ejecuta el sistema X
Window.
<list compact>
<item>Ctrl-Alt-F1 a F6:     Cambia a otra seudo terminal (desde X
Window, DOSEMU, etc.)
<item>Alt-F7:               Vuelve al sistema X Window
<item>Ctrl-Alt-menos:       Cambia la resolución de la pantalla en el sistema X Window (menos hace
referencia a la tecla del teclado numérico)
<item>Ctrl-Alt-más:         Cambia la resolución de la pantalla en el sistema X Window
en sentido opuesto (más hace referencia a la tecla del teclado númerico)
<item>Ctrl-Alt-Retroceso:   Finaliza el programa servidor de X
<item>Alt-X, Alt-C, Alt-V:  Las combinaciones de teclas usuales usadas en Windows/Mac 
para Cortar, Copiar, Pegar que utilizan la tecla Ctrl son reemplazadas, en algunos programas
como Netscape Composer, por la tecla Alt.
</list>

<sect id="cmd-study">Para saber más
<p>
Por el momento, recomiendo leer los libros fundamentales de
<url id="&tldp-guide;" name="The Linux Documentation Project: Guides">:
<list compact>
<item>"The Linux System Administrators' Guide",
<list compact>
<item>Abarca todos los aspectos para mantener y configurar el sistema, administrar
las cuentas de usuarios y realizar copias de seguridad.
<item>paquete: <package>&p-sysadmin-guide;</package>
<item>archivo: <url id="&f-sysadmin-guide;">
<item>página web: <url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition",
<list compact>
<item>Es una única guía de referencia para la administración
de redes en entornos Linux.
<item>Paquete: <package>&p-netadmin-guide;</package>
<item>Archivo: <url id="&f-netadmin-guide;">
<item>Página web: <url id="&w-netadmin-guide;">
</list>

 <item>"Linux: Rute User's Tutorial and Exposition"
 <list compact>
 <item>Un buen libro electrónico y en papel que abarca la admistración de un
 sistema GNU/Linux.
 <item>De Paul Sheer
 <item>Publicado por Prentice Hall
 <item>Paquete: <package>&p-rutebook;</package> (desde
 <tt>non-free</tt>)
 <item>Archivo: <file>&f-rutebook;</file>
 <item>Página web: <url id="&rutehome;">
 </list>

</list>

<p>
Véase <ref id="support"> para más recursos de aprendizaje.
</chapt>



