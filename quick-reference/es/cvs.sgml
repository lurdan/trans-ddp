<!-- CVS revision of this document "$Revision: 1.2 $"  -->
<!-- CVS revision of original english document "1.16.4.2"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="cvs">CVS

<![%FIXME[<p>===Proof reading by danielwebb: DONE ===]]>

<p>
Consulte <file>/usr/share/doc/cvs/html-cvsclient</file>,
<file>/usr/share/doc/cvs/html-info</file>,
<file>/usr/share/doc/cvsbook</file> con la ayuda de lynx o ejecute
<tt>info cvs</tt> o <tt>man cvs</tt> para una información más detallada.

<sect id="cvs-inst">Instalar el servidor CVS
<p>
La siguiente configuración permite que sólo un miembro del grupo "src"
pueda hacer envíos al repositorio CVS (mediante el comando 'commit') y
que la administración del CVS pueda llevarse a cabo únicamente por un
miembro del grupo "staff" de modo de reducir las posibilidades de
conflicto. 
<example>
# cd /var/lib; umask 002 ; sudo mkdir cvs # [WOODY] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=/var/lib/cvs
# cd $CVSROOT
# chown root:src .         # "staff": restricción importante para un
                           #  proyecto nuevo
# chmod 3775 .             #  Si usa "staff", escribir 2775
# cvs -d /var/lib/cvs init #  ¡resulta más seguro especificar
                           #  explícitamente -d!
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect>

<sect id="cvs-examples">Sesiones CVS de ejemplo

<sect1>CVS anónimo (únicamente para descargar)
<p>
<example>
$ export CVSROOT=:pserver:anonymous@cvs.qref.sf.net:/cvsroot/qref
$ cvs login
$ cvs -z3 co qref
</example>
</sect1>

<sect1>Uso del servidor CVS local
<p>
<example>
$ export CVSROOT=/var/lib/cvs
</example>
</sect1>

<sect1>Uso del pserver en un CVS remoto
<p>
No resulta seguro pero es conveniente para un CVS anónimo:
<example>
$ export CVSROOT=:pserver:account@cvs.foobar.com:/var/lib/cvs
$ cvs login
</example>
</sect1>

<sect1>Uso de un CVS remoto mediante <prgn>ssh</prgn>
<p>
Puede utilizar la autenticación RSA (<ref id="ssh-rsa">) que evita que
se solicite la contraseña. 
<example>
$ export CVSROOT=:ext:account@cvs.foobar.com:/var/lib/cvs
</example>
o para Sourceforge:
<example>
$ export CVSROOT=:ext:account@cvs.qref.sf.net:/cvsroot/qref
</example>
</sect1>

<sect1>Crear un archivo CVS nuevo
<p>
Para,
<example>
ITEM                  VALOR                SIGNIFICADO
Árbol del proyecto:   ~/proyecto-x         Todos los archivos fuente
Nombre del proyecto:  proyecto-x           Nombre para este proyecto
Nombre del proveedor: Rama-principal       Etiqueta para toda la rama
Etiqueta de versión:  Versión-inicial      Etiqueta para una versión
                                           específica
</example>
Entonces,
<example>
$ cd ~/proyecto-x            # para entrar en el directorio del proyecto
 ... crear un árbol ...
$ cvs import -m "Comienzo del proyecto-x" proyecto-x Rama Versión
$ cd ..; rm -R ~/proyecto-x
</example>
</sect1>

<sect1>Trabajando con CVS
<p>
Para recordar y trabajar con los fuentes locales del proyecto-x en un
archivo CVS:
<example>
$ cd                            # para ubicarse en la zona de trabajo.
$ cvs co proyecto-x             # copia los fuentes del repositorio CVS
                                # a la máquina local
$ cd proyecto-x
 ... efectuar los cambios ...
$ cvs diff -u                   # similar a diff -u repository/ local/
$ cvs ci -m "Describir cambio"  # guarda los fuentes locales en el CVS
$ vi archivo_nuevo
$ cvs add archivo_nuevo
$ cvs ci -m "Se añadió archivo_nuevo"
$ cvs up                  # actualiza a la última versión del CVS
$ cvs tag Release-1       # añade etiqueta de versión
... hacer otras modificaciones ...
$ cvs tag -d Release-1    # elimina etiqueta de versión
$ cvs ci -m "otros comentarios"
$ cvs tag Release-1       # vuelve a añadir la etiqueta de versión
$ cd                      # para volver al área de trabajo.
$ cvs co -r Versión-inicial -d antiguo proyecto-x 
... obtiene la versión original y la ubica en el directorio 'antiguo'
$ cd antiguo
$ cvs tag -b Versión-inicial-modif # crea la etiqueta de la rama (-b)
 ... Ahora puede trabajar sobre la versión original
$ cvs update -r Versión-inicial-modif 
 ... En el árbol del proyecto ahora aparece la rama 
     Versión-inicial-modif
 ... Trabaje en esta rama
$ cvs up              # sicronice los cambios en la rama con el resto
$ cvs ci -m "verificación hecha en la rama"
$ cvs update -r HEAD  # cambia rama al HEAD del tronco principal
$ cvs update -j Versión-inicial-modif
 ... se funde rama con el tronco principal
 ... resolver conflictos con el editor
$ cvs ci -m "Creación Versión-inicial-modif en el tronco principal"
$ cd
$ tar -cvzf antiguo-projecto-x.tar.gz antiguo  # crear archivo, -j para
                                               # bz2
$ cvs release -d antiguo           # eliminar fuentes locales (opcional)
</example>
Algunas opciones útiles para recordar (utilice a continuación del
comando
<prgn>cvs</prgn>):
<example>
-n      no ejecuta ningún comando que cambie el disco
-t      muestra los mensajes de la actividad en el cvs
</example>
</sect1>

<sect1>Exportar archivos desde el CVS
<p>
Para obtener la última versión del CVS use "tomorrow":
<example>
$ cvs ex -D tomorrow <var>nombre_módulo</var>
</example>
</sect1>

<sect1>Administrar el CVS
<p>
Añadir un alias al proyecto (servidor local):
<example>
$ su - admin           # un miembro del equipo
$ export CVSROOT=/var/lib/cvs ; cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "px -a proyecto-x" &gt;&gt;modules
$ cvs ci -m "Ahora px es un alias del proyecto-x"
$ cvs release -d .
$ exit                 # control-D para salir de 'su'
$ cvs co -d proyecto px 
 ... proyecto-x (alias:px) del CVS al directorio proyecto
$ cd proyecto
 ... realizar cambios ...
</example>
</sect1>
</sect>

<sect id="cvs-trouble">Resolución de problemas 

<sect1>Permisos de los archivos en el repositorio
<p>
CVS no sobreescribe el archivo del repositorio actual sino que lo
reemplaza por otro. Por lo tanto el <em>permiso de escritura en el
directorio del repositorio</em> resulta crítico. Cada vez que se cree
un nuevo repositorio ejecute lo siguiente para evitar cualquier
problema.
<example>
# cd /var/lib/cvs
# chown -R root:src repositorio
# chmod -R ug+rwX   repositorio
# chmod    2775     repositorio  # si es necesario para éste y sus
                                 # subdirectorios
</example>
</sect1>

<sect1>El bit de ejecución 
<p>
Cuando se abandona la sesión (check-out) se conserva el bit de
ejecución.  Ante cualquier problema de permisos de ejecución sobre
un archivo puede cambiar sus permisos en el repositorio CVS con el
siguiente comando.
<example>
# chmod ugo-x nombre_archivo
</example>
</sect1>

</sect>

<sect id="cvs-short">Comandos del CVS
<p>
Veamos los comandos del CVS con sus respectivos atajos.
<example>
{add|ad|new} [-k kflag] [-m 'mensaje'] archivos...
{admin|adm|rcs} [opciones-rcs] archivos...
{annotate|ann} [opciones] [archivos...]
{checkout|co|get} [opciones] módulos...
{commit|ci|com}   [-lnR]  [-m  'mensaje_registro'  |  -f  archivo] \
        [-r revision] [archivos...]
{diff|di|dif} [-kl] [opciones_rcsdiff] [[-r rev1 | -D fecha1] \
        [-r rev2 |  -D fecha2]] [archivos...]
{export|ex|exp} [-flNn] -r rev|-D fecha [-d dir] [-k kflag] módulo...
{history|hi|his} [-report] [-flags] [-options args] [archivos...]
{import|im|imp} [-options] repositorio nombre_proveedor etiq_versión...
{login|logon|lgn}
{log|lo|rlog} [-l] opciones-rlog [archivos...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] módulos...
{release|re|rel} [-d] directorios...
{remove|rm|delete} [-lR] [archivos...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  etiqueta  |  -D  fecha] \
         sym_bolic_tag módulos...
{status|st|stat} [-lR] [-v] [archivos...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r etiqueta | -D fecha]  [-f] \
         sym_bolic_tag [archivos...]
{update|up|upd} [-AdflPpR] [-d] [-r tag|-D fecha] archivos...
</example>
</sect>

</chapt>


