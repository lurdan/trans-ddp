<!-- CVS revision of this document "$Revision: 1.8 $"  -->
<!-- CVS revision of original english document "1.77"   -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<!-- Conteúdo retraduzido a partir do zero na versão 1.5  30/01/2004 -->

<chapt id="tutorial">Tutoriais do &debian;
<p>
<!-- new content -->
Essa seção fornece uma orientação básica para o mundo &debian; para o
verdadeiro novato. Se você tiver usado algum sistema semelhante ao Unix por
algum tempo, provavelmente sabe tudo que expliquei aqui. Por favor, use isso
como uma verificação da realidade.

<sect id="first">Começando
<p>
<!-- new content -->
Depois da instalação do sistema &debian; em seu PC, você precisa aprender
algumas coisas para torná-lo útil. Vamos dar-lhe um treinamento expresso.

<sect1 id="login-root">Login em um prompt shell como root
<p>
<!-- new content -->
Após reiniciar o sistema, será apresentado a você uma tela de login gráfica
ou baseada em caracteres dependendo de sua seleção inicial de pacotes. Para
simplificar, se lhe for apresentada uma tela de login gráfica, pressione
Ctrl-Alt-F1
<footnote>
A tecla Ctrl esquerda, a tecla Alt esquerda e a tecla F1 pressionadas
juntas.
</footnote>
para obter a tela de login baseada em caracteres.
<p>
Suponha que o nome de seu sistema é <tt><var>foo</var></tt>, o prompt de
login parece assim:
<example>
<var>foo</var> login:
</example>
Digite <tt>root</tt>, pressione a tecla Enter e digite a senha que você
selecionou durante o processo de instalação. No sistema &debian;, seguindo a
tradição Unix, a senha é sensível a maiúsculas/minúsculas. Então o sistema
começa com uma mensagem de saudação e lhe apresenta o prompt de comando root
aguardando sua entrada. 
<footnote>
Note que se você editou a mensagem de saudação no arquivo
<file>/etc/motd</file>, ela será diferente.
</footnote>
<example>
<var>foo</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
Você está pronto para fazer a administração do sistema a partir desse prompt
de comando root. Essa conta root também é chamada de super-usuário ou
usuário privilegiado. A partir dessa conta, você pode fazer qualquer coisa:
<list compact>
<item>ler, gravar, e remover quaisquer arquivos no sistema independentemente
das permissões de arquivo
<item>ajustar as propriedades e permissões de quaisquer arquivos no sistema
<item>ajustar a senha de qualquer usuário não-privilegiado no sistema
<item>fazer login para quaisquer contas sem suas senhas
</list>
<p>
É uma idéia extremamente ruim compartilhar o acesso para a conta root
compartilhando a senha. O uso de um programa como o <manref name="sudo"
section="8"> é a maneira certa de compartilhar privilégios administrativos. 
<p>
Por favor note que considera-se um bom hábito de Unix fazer login para a
conta de usuário não privilegiado mesmo quando você planeja fazer atividades
administrativas. Use os comandos <tt>sudo</tt>, <tt>super</tt>, ou <tt>su
-c</tt> para obter o privilégio de root limitado quando necessário. Veja
<ref id="sudo">.
<footnote>
Eu tenho que admitir que usei a conta do super-usuário mais freqüentemente
que o necessário apenas porque era mais fácil e eu era descuidado.
</footnote>

<sect1 id="newbiefix">Configurar um ambiente mínimo para novato
<p>
<!-- new content -->
Eu acho que aprender um sistema de computador é como aprender um idioma
estrangeiro novo. Apesar de livros tutoriais ajudarem, você tem que
praticá-lo com ferramentas de ajuda. Nesse contexto, acho que é uma boa
idéia instalar alguns pacotes adicionais tais como <package>mc</package>,
<package>vim</package>, <package>lynx</package>,
<package>doc-linux-text</package> e <package>debian-policy</package>.
<footnote>
Também pode ser uma boa idéia instalar <package>gpm</package>,
<package>emacs21</package> e <package>doc-linux-html</package>. Veja <ref
id="gpm"> e <ref id="edit">.
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
</example>
Se você já tiver esses pacotes instalados, nada será instalado. 

<sect1 id="newuser">Adicionar uma conta de usuário
<p>
<!-- new content -->
Durante a instalação, normalmente se cria uma conta de usuário não
privilegiado que recebe e-mails destinados à conta root.
<footnote>
Eu tendo a nomear essa conta criada durante a instalação como <tt>admin</tt>
mas pode ser qualquer nome arbitrário. 
</footnote>
Já que você não quer usar essa conta de usuário especial para as atividades
de treinamento seguintes, você deve criar outra conta de usuário nova.
<p>
Supondo que você deseje que esse novo nome de usuário seja
<tt><var>pinguim</var></tt>, digitar:
<example>
root@<var>foo</var>:root# adduser <var>pinguim</var>
... responda todas as questões
</example>
irá criá-la.
<footnote>
Você pode querer adicionar esse usuário <tt><var>pinguim</var></tt> ao grupo
<tt>adm</tt> para habilitar acesso de leitura aos muitos arquivos de log em
<file>/var/log/</file>. Veja as páginas de manual <manref name="passwd"
section="5">, <manref name="group" section="5">, <manref name="shadow"
section="5">, <manref name="vipw" section="8">, e <manref name="vigr"
section="8">. Para obter os significados oficiais de usuários de grupos,
veja uma versão recente do documento <url id="&f-users-and-groups;"
name="Usuários e Grupos">. 
</footnote>
Antes de ir adiante, vamos aprender algumas coisas primeiro.

<sect1 id="sw-console">Alternar entre consoles virtuais
<p>
<!-- modified old content -->
No sistema &debian; padrão, há seis pseudo-terminais independentes
disponíveis, isto é, você pode usar a tela de console de caracter VGA do PC
como 6 terminais VT-100 comutáveis. Mude de um para outro pressionando a
telcla Alt esquerdo e uma das teclas F1&ndash;F6 simultaneamente. Cada
pseudo-terminal permite login independente para contas. O ambiente
multi-usuário é uma grande característica do Unix, e muito importante.
<p>
<!-- new content -->
Se você acidentalmente pressionou Alt-F7 em um sistema executando o Sistema
X Window e a tela de console mostrar uma tela gráfica, obtenha o acesso ao
console de caracter novamente pressionando Ctrl-Alt-F1. Tente mudar para um
console diferente e volte ao original para exercitar isso.

<sect1 id="shutdown">Como desligar
<p>
<!-- heavily modified content -->
Como quaisquer outros SOs modernos onde a operação de arquivos envolve cache
de dados na memória, o sistema &debian; precisa de um procedimento de
desligamento apropriado antes que a energia possa ser desligada de forma
segura para manter a integridade dos arquivos. Use o comando seguinte a
partir do prompt root para desligar o sistema:
<example>
# shutdown -h now
</example>
Isso é para o modo multi-usuário normal. Se você estiver no modo usuário
único, use o seguinte a partir do prompt de comando root:
<example>
# poweroff -i -f
</example>
Alternativamente, você pode pressionar Ctrl-Alt-Delete para desligar.
<footnote>
A tecla Ctrl esquerdo, a tecla Alt esquerdo, e a tecla Delete pressionadas
juntas a partir do console. No sistema padrão, isso fará com que o sistema
reinicie. Voc precisa modificar o arquivo <file>/etc/inittab</file> para ter
o comando <prgn>shutdown</prgn> com a opção <tt>-h</tt> como descrito em
<ref id="post-inst">.
</footnote>
<p>
Espere até que o sistema mostre "System halted" e então desligue a energia.
Se a função APM ou ACPI tiver sido ativada pelo Linux e BIOS
apropriadamente, o sistema se desligará sozinho. Veja <ref id="apm"> para
maiores detalhes.

<sect1 id="playtime">Hora do jogo
<p>
<!-- new content -->
Agora você está pronto para brincar com seu sistema &debian; sem riscos
desde que você use essa conta de usuário não privilegiado
<tt><var>pinguim</var></tt>.
<footnote>
Isso é porque o sistema &debian; é, mesmo logo após a instalação padrão,
configurado com as permissões de arquivos apropriadas que impedem que um
usuário não privilegiado danifique o sistema. É claro, podem haver ainda
alguns furos que podem ser explorados mas aqueles que se preocupam com esse
problema não devem estar lendo essa seção mas devem estar lendo o <url
id="&securing-debian-howto;" name="Securing Debian Manual">. 
</footnote>
<p>
Vamos fazer login para o <tt><var>pinguim</var></tt>.
Se você estiver no prompt shell root, pressione Ctrl-D
<footnote>
A tecla Ctrl esquerdo e a tecla d pressionadas juntas. Não há necessidade de
pressionar a tecla Shift mesmo quando esses caracteres de controle são
referidos como "control D" com maiúscula.
</footnote>
no prompt de comando root para fechar a atividade shell root e retornar ao
prompt de login. Entre seu nome de usuário recém criado
<tt><var>pinguim</var></tt> e a senha correspondente.
<footnote>
Se você entrar <tt>root</tt> ao invés de <tt><var>pinguim</var></tt> aqui e
a senha correspondente, você obterá o acesso à conta <tt>root</tt>. Esse
procedimento será necessário para obter novamente o acesso à conta
<tt>root</tt>.
</footnote>
Será apresentado a você o seguinte prompt de comando.
<example>
<var>pinguim</var>@<var>foo</var>:<var>pinguim</var>$ 
</example>
<p>
A partir daqui, o exemplo dado usará o prompt de comando simplificado por
facilidade. Eu usarei:
<list compact>
<item><tt>#</tt> : prompt shell root
<item><tt>$</tt> : prompt shell de usuário não privilegiado
</list>
<p>
Nós começaremos aprendendo o sistema &debian; primeiro da maneira fácil,
<ref id="mc"> e mais tarde da maneira apropriada, <ref id="unixlike">.

<sect id="mc">Midnight Commander (MC)
<p>
<!-- old content -->
O Midnight Commander (MC) é um "canivete suíço" do GNU para o console Linux
e outros ambientes de terminal. Isso dá ao novato uma experiência com o
console baseada em menu que é muito mais fácil de aprender que os comandos
Unix padrões. 
<!-- New content -->
<p>
Use esse comando para explorar o sistema &debian;. Essa é a melhor maneira
de aprender. Por favor, explore alguns locais chave simplesmente usando as
teclas de cursor e a tecla Enter:
<list compact>
<item><file>/etc</file> e seus subdiretórios.
<item><file>/var/log</file> e seus subdiretórios.
<item><file>/usr/share/doc</file> e seus subdiretórios.
<item><file>/sbin</file> e <file>/bin</file>
</list>

<sect1 id="mc-enhance">Melhorar o MC
<p>
<!-- modified old content -->
Para fazer com que o MC mude o diretório de trabalho ao sair, você precisa
modificar seu arquivo <file>~/.bashrc</file> (ou
<file>/etc/bash.bashrc</file>, chamado a partir do <file>.bashrc</file>),
como detalhado em sua página de manual, <manref name="mc" section="1">, sob
a opção <tt>-P</tt>.
<footnote>
Se você não compreender exatamente o que estou dizendo aqui, você pode fazer
isso mais tarde.
</footnote>

<sect1 id="mc-start">Iniciar o MC
<p>
<!-- modified old content -->
<example>
$ mc
</example>
O MC cuida de todas as operações de arquivo através de seu menu, requerendo
esforço mínimo do usuário. Simplesmente pressione a F1 para obter a tela de
ajuda. Você pode brincar com o MC simplesmente pressionando as teclas de
cursor e as teclas de função.
<footnote>
Se estiver em um terminal, tal como <prgn>kon</prgn> e <prgn>kterm</prgn>
para japonês, há alguns problemas com certos caracteres gráficos, e
adicionar um <tt>-a</tt> à linha de comando do MC pode ajudar prevenir
problemas.
</footnote>

<sect1 id="mc-fm">Gerenciador de arquivos no MC
<p>
<!-- old content -->
O padrão são dois painéis de diretórios contendo listas de arquivos. Outro
modo útil é definir a janela direita para "info" para ver a informação de
privilégio de acesso dos arquivos, etc. A seguir estão alguns comandos de
teclado essenciais. Com o daemon <prgn>gpm</prgn> sendo executado, pode-se
usar o mouse também.  (Não esqueça de pressionar a tecla shift para ter o
comportamento normal de cortar e colar no MC.)
<list compact>
<item>F1: Menu de ajuda
<item>F3: Visualizador de arquivos interno
<item>F4: Editor interno
<item>F9:  Ativar o menu
<item>F10: Sair do Midnight Commander
<item>Tab: Mover entre as 2 janelas
<item>Insert: Marcar o arquivo para operação de múltiplos arquivos como
  cópia
<item>Del: Apagar o arquivo (Tenha cuidado &mdash; configure o MC para o
  modo de eliminação segura.)
<item>Teclas de cursor: Auto explicativo
</list>

<sect1 id="mc-cl">Truques de linha de comando no MC
<p>
<!-- old content -->
<list>
<item>Qualquer comando <prgn>cd</prgn> mudará o diretório exibido na janela
  selecionada.
<item>Ctrl-Enter ou Alt-Enter copiará um nome de arquivo para a linha de
  comando. Use isso com os comandos <prgn>cp</prgn> ou <prgn>mv</prgn> junto
  com edição de linha de comando.
<item>Alt-Tab exibirá possibilidades de expansão de um nome de arquivo no
  shell.
<item>Pode-se especificar o diretório inicial para ambas as janelas como
  argumentos para o MC; por exemplo, <tt>mc /etc /root</tt>.
<item>Esc + <var>tecla_numérica</var> == F<var>n</var> (isto é,
      Esc + `1' = F1, etc.;
      Esc + `0' = F10)
<item>Tecla Esc      == tecla Alt (= Meta,
      M-); isto é, tecle Esc + `c' se quiser Alt-c.
<!-- control characters are referred with the upper case. -->
</list>

<sect1 id="mcedit">Editor no MC
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
O editor interno tem um interessante esquema de cortar-e-colar. Pressionando
F3, marca-se o início da seleção, um segundo F3 marca o fim e destaca a
seleção. Você pode então mover seu cursor. Se você pressionar F6, a área
selecionada será movida para o local do cursor. Se pressionar F5, a área
selecionada será copiada e inserida no local do cursor. Para salvar o arquivo,
tecle  F2. Para sair, use o F10. Muitas teclas de cursor funcionam
intuitivamente.
<p>
Esse editor pode ser iniciado diretamente em um arquivo:
<example>
$ mc -e nome_do_arquivo_a_editar
$ mcedit nome_do_arquivo_a_editar
</example>
<p>
Esse editor não é multi janela, mas pode-se usar vários consoles Linux para
obter o mesmo efeito. Para copiar entre janelas, use as teclas
Alt-F<var>n</var> para alternar entre os consoles virtuais e use
"Arquivo-&gt;Inserir arquivo" ou "Arquivo-&gt;copiar para Arquivo" para mover
uma parte de um arquivo para outro.
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I see .. but for now I do this not to hack LaTeX
-->
<p>
Esse editor interno pode ser substituído por qualquer editor externo de sua
escolha.
<p>
Além disso, muitos programas usam as variáveis de ambiente  <tt>EDITOR</tt> ou 
<tt>VISUAL</tt> para decidir qual editor a ser usado.  Se você não se sentir
confortável com o <prgn>vim</prgn>, defina essas variáveis para o
<tt>mcedit</tt> adicionando essas linhas ao arquivo <file>~/.bashrc</file>:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
Eu recomendo que elas sejam definidas para <tt>vim</tt> se possível.  Aprender
os comandos do <prgn>vim</prgn> é a coisa certa a fazer, já que o editor Vi
está sempre lá no mundo Linux/Unix.
<footnote>
Na verdade, o <prgn>vi</prgn> ou o <prgn>nvi</prgn> são os programas que você
encontra em todo lugar. Ao invés disso eu escolhi o <prgn>vim</prgn> para o
novato já que ele lhe oferece ajuda através da tecla F1 ao mesmo tempo que é
similar o bastante e mais poderoso.
</footnote>

<sect1 id="mc-view">Visualizador no MC
<p>
<!-- almost old content -->
Esse é um visualizador muito esperto. É uma grande ferramenta para procurar
palavras em documentos. Eu o uso sempre para os arquivos no diretório
<file>/usr/share/doc</file>.  Essa é a maneira mais rápida de navegar entre as
massas de informação do Linux. Esse visualizador pode ser iniciado diretamente
assim:
<example>
$ mc -v nome_do_arquivo_a_visualizar
</example>

<sect1 id="ma-auto">Recursos de auto início no MC
<p>
<!-- almost old content, tar.gz and deb are new -->
Pressione Enter em um arquivo, e o programa apropriado manipulará seu
conteúdo.  Esse é um recurso muito conveniente do MC.
<example>
arquivo executável:   Executa o comando
arquivo man, html:    Direciona o conteúdo para o programa visualizador
arquivo tar.gz, deb:  Navega em seu conteúdo com se fosse um subdiretório
</example>
Para permitir que esses recursos de visualizador e arquivo virtual funcionem,
os arquivos visualizáveis não devem estar definidos como executáveis. Mude
seus estados usando o comando <prgn>chmod</prgn> através do menu de arquivo do
MC.

<sect1 id="mc-ftp">Sistema de arquivo virtual FTP no MC
<p>
<!-- old content -->
O MC pode ser usado para acessar arquivos na Internet usando FTP. Vá para o
menu pressionando F9, e então tecle `p' para ativar o sistema de arquivos
virtual FTP. Entre uma URL na forma
<tt>nomeusuario:senha@nomemaquina.nomedominio</tt>, e será obtido um diretório
remoto, que parecerá como um local.
<p>
<!-- new content -->
Tente <tt>&ftp-debian;</tt> como URL e navegue o repositório de arquivos do
&debian;. Veja <ref id="ftparchives"> para detalhes sobre como eles são
organizados.

<sect id="unixlike">Ambiente de trabalho semelhante ao Unix
<p>
Apesar de o MC possibilitar que você possa fazer quase tudo, é muito
importante para você que aprenda como usar as ferramentas de linha de comando
invocadas a partir do prompt shell e se torne familiar com o ambiente de
trabalho semelhante ao Unix.
<footnote>
Nesse capítulo de tutorial, o shell significa <prgn>bash</prgn>. Para mais
detalhes sobre os diferentes shells, veja <ref id="shell">.
</footnote>

<sect1 id="sp-keys">Comandos de teclado especiais
<p>
<!-- practically new content -->
No ambiente similar ao Unix, há alguns comandos de teclado que tem
significados especiais.
<footnote>
Em um console de caracter Linux normal, somente a tecla Ctrl e a tecla Alt
esquerdas funcionam como esperado.
</footnote>
<list compact>
<item>Ctrl-U: Apaga uma linha antes do cursor.
<item>Ctrl-H: Apaga um caracter antes do cursor.
<item>Ctrl-D: Finaliza a entrada. (sai do shell se você estiver usando shell)
<item>Ctrl-C: Finaliza o programa sendo executado.
<item>Ctrl-Z: Pára temporariamente o programa. (coloca-o para trabalho de
plano de fundo (background job), veja <ref id="cmd-back">)
<item>Ctrl-S: Trava (Halt) a saída para a tela.
<footnote>
Você pode desabilitar esse recurso de terminal usando <manref name="stty"
section="1">.
</footnote>
<item>Ctrl-Q: Reativa saída para a tela.
</list>
<p>
O shell padrão, <prgn>bash</prgn>, tem capacidades de edição de histórico e
tab-completar para ajudar o uso interativo.
<list compact>
<item>seta-cima: Inicia busca no histórico de comandos.
<item>Ctrl-R:  Inicia busca incremental no histórico de comandos.
<item>TAB: Completa a entrada do nome de arquivo para a linha de comando.
<item>Ctrl-V TAB: Entra TAB sem expansão para a linha de comando.
</list>
<p>
Outros comandos de teclado importantes a lembrar:
<list compact>
<item>Ctrl-Alt-Del:  Reinicia/halt o sistema, veja <ref id="post-inst">.
<item>Click-botão-esquerdo-e-arrasta do mouse: Seleciona e copia para a área
de tranferência (clipboard).
<item>Click botão do meio do mouse: Cola área de transferência no cursor.
<item>A tecla Meta (terminologia do Emacs) é atribuída tradicionalmente à
tecla Alt esquerda. Alguns sistemas podem ser configurados para usar a tecla
Windows como a tecla Meta.
</list>
Aqui, para usar um mouse no console de caracter do Linux, você precisa ter
instalado o <prgn>gpm</prgn> como daemon.
<footnote>
No ambiente X Window, o mouse funciona da mesma forma com o programa Xterm.
</footnote>
Veja <ref id="gpm">.

<sect1 id="unixcmds">Comandos Unix básicos
<p>
<!-- new content -->
Vamos aprender os comandos Unix básicos.
<footnote>
Aqui eu uso "Unix" em seu senso genérico. Quaisquer SOs clones do Unix
geralmente oferecem os comandos equivalentes. O sistema &debian; não é uma
exceção. Não se preocupe se alguns comandos não funcionarem como você deseja
agora. Esses exemplos não precisam ser executados nessa ordem.
</footnote>
Teste todos os comandos seguintes a partir da conta de usuário não
privilegiado <tt><var>pinguim</var></tt>:
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>Mostra o nome do diretório atual/de trabalho.
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>Mostra o nome do usuário atual.
 </list>
<item><tt>file <var>foo</var></tt>
 <list compact>
 <item>Mostra o tipo de arquivo do arquivo <var>foo</var>.
 </list>
<item><tt>type -p <var>nomedecomando</var></tt>
 <list compact>
 <item>Mostra uma localização de arquivo do comando <tt><var>nomedecomando</var></tt>.
 <item><tt>which <var>nomedecomando</var></tt> faz o mesmo.
 </list>
<item><tt>type <var>nomedecomando</var></tt>
 <list compact>
 <item>Mostra informação sobre o comando <tt><var>nomedecomando</var></tt>.
 </list>
<item><tt>apropos <var>palavra-chave</var></tt>
 <list compact>
 <item>Encontra comandos relacionados a <tt><var>palavra-chave</var></tt>.
 <item><tt>man -k <var>palavra-chave</var></tt> faz o mesmo.
 </list>
<item><tt>whatis <var>nomedecomando</var></tt>
 <list compact>
 <item>Mostra uma explicação de uma linha sobre o comando
  <tt><var>nomedecomando</var></tt>.
 </list>
<item><tt>man -a <var>nomedecomando</var></tt>
 <list compact>
 <item>Mostra uma explicação curta sobre o comando
  <tt><var>nomedecomando</var></tt>. (estilo Unix)
 </list>
<item><tt>info <var>nomedecomando</var></tt>
 <list compact>
 <item>Mostra uma explicação longa sobre o comando
  <tt><var>nomedecomando</var></tt>.  (estilo GNU)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>Lista o conteúdo do diretório. (arquivos não-ponto e diretórios)
  <footnote>
O Unix tem uma tradição de ocultar nomes de arquivos que começam com
"<tt>.</tt>". Eles são tradicionalmente arquivos que contêm informação de
configuração e preferências do usuário.
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>Lista o conteúdo do diretório. (toods os arquivos e diretórios)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>Lista o conteúdo do diretório. (quase todos os arquivos e diretórios,
 isto é, pula "<file>..</file>" e "<file>.</file>")
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>Lista todo o conteúdo do diretório com informação de detalhe. Veja <ref
 id="file-system">.
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>Lista todos os diretórios sob o diretório atual.
 </list>
<item><tt>lsof <var>foo</var></tt>
 <list compact>
 <item>Lista o estado de abertura do arquivo <tt><var>foo</var></tt>.
 </list>
<item><tt>mkdir <var>foo</var></tt>
 <list compact>
 <item>Cria um novo diretório <tt><var>foo</var></tt> no diretório atual.
 </list>
<item><tt>rmdir <var>foo</var></tt>
 <list compact>
 <item>Remove um diretório <tt><var>foo</var></tt> no diretório atual.
 </list>
<item><tt>cd <var>foo</var></tt>
 <list compact>
 <item>Muda para o diretório  <file><var>foo</var></file> no diretório atual
  ou no diretório listado na variável <tt>CDPATH</tt>. Veja o comando
  <prgn>cd</prgn> na página de manual <manref name="builtins" section="7">
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>Muda o diretório para o diretório raiz
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>Muda o diretório para o diretório home do usuário.
 </list>
<item><tt>cd /<var>foo</var></tt>
 <list compact>
 <item>Muda o diretório para o caminho de diretório absoluto
 <file>/<var>foo</var></file>.
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>Muda o diretório para o diretório pai.
 </list>
<item><tt>cd ~<var>foo</var></tt>
 <list compact>
 <item>Muda o diretório para o diretório home do usuário 
  <tt><var>foo</var></tt>.
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>Muda o diretório para o diretório anterior.
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>Mostra o conteúdo de <file>/etc/motd</file> usando o paginador padrão.
   Veja <ref id="cmd-stdin">.
  <footnote>
O paginador padrão do sistema &debian; pelado é o <prgn>more</prgn> que não
pode rolar para trás. Instalando o pacote <package>less</package> usando a
linha de comando <tt>apt-get install less</tt>, o <prgn>less</prgn> se torna o
paginador padrão e você pode rolar para trás usando as teclas de cursor.
  </footnote>
 </list>
<item><tt>touch <var>arquivolixo</var></tt>
 <list compact>
 <item>Cria um arquivo <file><var>arquivolixo</var></file> vazio.
 </list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Copia um arquivo <file><var>foo</var></file> existente para um novo
  arquivo <file><var>bar</var></file>.
 </list>
<item><tt>rm <var>arquivolixo</var></tt>
 <list compact>
 <item>Remove um arquivo <file><var>arquivolixo</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Renomeia um arquivo <file><var>foo</var></file> existente para um novo
  nome <file><var>bar</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
 <list compact>
 <item>Move um arquivo <file><var>foo</var></file> existente para um novo
 local com um novo nome <file><var>bar/baz</var></file>. O diretório
 <file><var>bar/</var></file> precisa existir.
 </list>
<item><tt>chmod 600 <var>foo</var></tt>
 <list compact>
 <item>Torna um arquivo <file><var>foo</var></file> existente não-legível e
  não-gravável para outras pessoas. (não-executável para todos)
 </list>
<item><tt>chmod 644 <var>foo</var></tt>
 <list compact>
 <item>Torna um arquivo <file><var>foo</var></file> existente legível mas
 não-gravável por outras pessoas. (não-executável para todos)
 </list>
<item><tt>chmod 755 <var>foo</var></tt>
 <list compact>
 <item>Torna um arquivo <file><var>foo</var></file> existente legível mas
 não-gravável por outras pessoas. (executável para todos)
 </list>
<item><tt>top</tt>
 <list compact>
 <item>Mostra a informação de processos usando tela cheia. Pressione "q" para
 sair
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>Mostra informação sobre todos os processos sendo executados usando
 saída de estilo BSD. Veja <ref id="cmd-pipe">.
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>Mostra informação sobre todos os processos sendo executados usando
 saída estilo Unix system-V.
 </list>
<item><tt>ps aux | grep -e "[e]xim"</tt>
 <list compact>
 <item>Mostra todos os processos executando <prgn>exim</prgn>.  Aprenda a
 expressão regular a partir da página de manual do <manref name="grep"
 section="1"> digitando <tt>man grep</tt>.
 </list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item>Mostra informação sobre todos os processos sendo executados com saída
 com ASCII art.
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>Mata um processo identificado pela ID de processo: <var>1234</var>.
 Veja <ref id="kill">.
 </list>
<item><tt>grep -e "<var>padrão</var>" *.html</tt>
 <list compact>
 <item>Encontra um "<var>padrão</var>" em todos os arquivos terminando com
 <tt>.html</tt> no diretório atual e mostra todos.
 </list>
<item><tt>gzip <var>foo</var></tt>
 <list compact>
 <item>Comprime <file><var>foo</var></file> para criar
  <file><var>foo</var>.gz</file> usando o código Lempel-Ziv (LZ77).
 </list>
<item><tt>gunzip <var>foo</var>.gz</tt>
 <list compact>
 <item>Descompacta <file><var>foo</var>.gz</file> para criar o arquivo
  <file><var>foo</var></file>.
 </list>
<item><tt>bzip2 <var>foo</var></tt>
 <list compact>
 <item>Compacta <file><var>foo</var></file> para criar
  <file><var>foo</var>.bz2</file> usando o algoritmo de compressão de texto
  por ordenação de bloco de Burrows-Wheeler, e código de Huffman. (Melhor
  compressão que o <prgn>gzip</prgn>)
 </list>
<item><tt>bunzip2 <var>foo</var>.bz2</tt>
 <list compact>
 <item>Descompacta <file><var>foo</var>.bz2</file> para criar o arquivo
  <file><var>foo</var></file>.
 </list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
 <list compact>
 <item>Extrai arquivos a partir do arquivo <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
 <list compact>
 <item>Extrai arquivos a partir do arquivo <file><var>foo</var>.tar.gz</file>
  gzipado.
 </list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
 <list compact>
 <item>Extrai arquivos a partir do arquivo <file><var>foo</var>.tar.bz2</file>.
  <footnote>
<tt>--bzip2</tt> é usado aqui ao invés da nova opção curta <tt>-j</tt> para
garantir que isso funcione com a versão antiga do <prgn>tar</prgn> no Potato.
  </footnote>
 </list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
 <list compact>
 <item>Arquiva o conteúdo da pasta <file><var>bar</var>/</file> no arquivo 
  <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
 <list compact>
 <item>Arquiva o conteúdo da pasta  <file><var>bar</var>/</file> no arquivo
  comprimido <file><var>foo</var>.tar.gz</file>.
 </list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
 <list compact>
 <item>Arquiva o conteúdo da pasta <file><var>bar</var>/</file> no arquivo
  <file><var>foo</var>.tar.bz2</file>.
  <footnote>
<tt>--bzip2</tt> é usado aqui novamente para garantir compatibilidade.
  </footnote>
 </list>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>Mostra o conteúdo do
  <file>README.gz</file> comprimido usando o paginador padrão.
 </list>
<item><tt>zcat README.gz &gt; foo</tt>
 <list compact>
 <item>Cria um arquivo <file>foo</file> com o conteúdo descompactado de  
  <file>README.gz</file>.
 </list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
 <list compact>
 <item>Acrescenta o conteúdo descomprimido de <file>README.gz</file> ao final
  do arquivo <file>foo</file>. (Se ele não existir, cria-o primeiro.)
 </list>
<item><tt>find . -name <var>padrão</var></tt>
 <list compact>
 <item>encontra nomes de arquivo que combinem usando o
 <tt><var>padrão</var></tt> shell. 
  (mais lento)
 </list>
<item><tt>locate -d . <var>padrão</var></tt>
 <list compact>
 <item>encontra nomes de arquivo que combinem usando o
 <tt><var>padrão</var></tt> shell.
  (mais rápido usando uma base de dados gerada regularmente)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
Por favor cruze diretórios e mergulhe no sistema usando os comandos acima como
um treinamento. Se você tiver questões sobre qualquer um dos comandos de
console, por favor, certifique-se de ler a página de manual. Por exemplo,
esses comandos são um bom começo:
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
Também é uma boa hora para iniciar o <prgn>vim</prgn> e pressionar a tecla F1.
Você deve ler pelo menos as primeiras 35 linhas. Então faça o curso de
treinamento online movendo o cursor para <tt>|tutor|</tt> e pressionando
Ctrl-]. Veja <ref id="edit"> para aprender mais sobre editores.
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
Por favor note que muitos comandos similares a Unix incluindo os do GNU e BSD
mostrarão uma breve informação de ajuda se você invocá-los em uma das
seguintes maneiras (ou sem nenhum argumento em alguns casos):
<example>
$ <var>nomedecomando</var> --help
$ <var>nomedecomando</var> -h
</example>
Teste também exemplos em <ref id="tips"> como seu auto treinamento.

<sect1 id="cmd-exec">A execução de comando
<p>
<!-- new content -->
Agora você tem alguma idéia de como usar o sistema &debian;. Vamos olhar
com mais profundidade o mecanismo da execução de comando no sistema
&debian;.
<footnote>
Aqui, eu simplifiquei a realidade para o novato. Veja a página de manual
<manref name="bash" section="1"> para ter uma explicação exata.
</footnote>

<sect1 id="cmd-simple">Comando simples
<p>
<!-- new content -->
Um comando simples é uma seqüência de 
<enumlist compact>
<item>atribuições de variáveis (opcional)
<item>nome de comando
<item>argumentos (opcional)
<item>redireções (opcional:<tt>&gt;</tt> , <tt>&gt;&gt;</tt> , <tt>&lt;</tt>
, <tt>&lt;&lt;</tt> , etc.)
<item>operador de controle (opcional: <tt>&amp;&amp;</tt> , <tt>||</tt> ;
&lt;newline&gt; , <tt>;</tt> , <tt>&amp;</tt> , <tt>(</tt> , <tt>)</tt> )
</enumlist>
<p>
Para comandos mais complexos com aspas e substituições, veja <ref
id="clprocess">.

<sect1 id="cmd-env">Execução de comando e variável de ambiente
<p>
<!-- new content -->
A execução de comando típica usa uma seqüência de linha shell como a
seguinte:
<footnote>
Para obter a saída seguinte, você precisa instalar o locale francês, veja
<ref id="locales">. Isso não é essencial para o tutorial. Isso é feito
apenas para indicar seus efeitos potenciais.
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
Aqui, o programa <prgn>date</prgn> é executado como o trabalho em primeiro
plano (foreground). A variável de ambiente <tt>LC_ALL</tt> é:
<list compact>
<item>indefinida (padrão do sistema, o mesmo que <tt>C</tt> para o primeiro
comando
<item>definida para <tt>fr_FR</tt> (locale francês) para o segundo comando
</list>
Muitas execuções de comandos geralmente não têm uma definição de variável de
ambiente precedendo. Para o exemplo acima, você pode executar
alternativamente:
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
Como você pode ver aqui, a saída do comando é afetada pela variável de
ambiente para produzir saída em francês. Se você quiser que a variável de
ambiente seja transmitida aos subprocessos (por exemplo, quando chamando um
script shell), você precisa ao invés "export"á-la usando:
<example>
$ export LC_ALL
</example>


<sect1 id="cmd-path">Caminho de busca de comando
<p>
<!-- new content -->
Quando você digita um comando no shell, o shell procura o comando na lista
de diretórios contida pela variável de ambiente <tt>PATH</tt>. O valor da
variável de ambiente <tt>PATH</tt> também é chamado de caminho de busca do
shell.
<p>
Na instalação &debian; padrão, a variável de ambiente <tt>PATH</tt> de uma
conta de usuário não deve incluir <file>/sbin</file>. Então se você quiser
executar quaisquer comandos como <prgn>ifconfig</prgn> de
<file>/sbin</file>, você precisa mudar a variável de ambiente <tt>PATH</tt>
para incluí-lo. A variável de ambiente <tt>PATH</tt> geralmente é definida
pelo arquivo de inicialização <file>~/.bash_profile</file>, veja <ref
id="bashconf">.

<sect1 id="cmd-opt">Opções de linha de comando
<p>
<!-- new content -->
Alguns comandos levam argumentos. Os argumentos começando com <tt>-</tt> ou
<tt>--</tt> são chamados de opções e controlam o comportamento do comando.
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
Aqui o argumento de linha de comando <tt>-R</tt> muda o comportamento do
comando <prgn>date</prgn> para saída com data em conformidade com a
RFC-2822.

<sect1 id="cmd-wild">Curingas (wildcards) de shell
<p>
<!-- new content -->
Freqüentemente se deseja que um comando funcione com um grupo de arquivos
sem digitar todos eles. O padrão de expansão de nome de arquivo usando os
<strong>curingas</strong> do shell facilitam essas necessidades.
<list compact>
<item><tt>*</tt>
<list compact>
<item>Substitui qualquer grupo de 0 ou mais caracteres.
<item>Não substitui um nome de arquivo que comece com "<tt>.</tt>".
</list>
<item><tt>?</tt>
<list compact>
<item>Substitui exatamente um caracter.
</list>
<item><tt>[...]</tt>
<list compact>
<item>Substitui exatamente um caracter por qualquer caracter colocado entre
os colchetes.
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>Substitui exatamente um caracter por qualquer caracter entre
<tt>a</tt> e <tt>z</tt>.
</list>
<item><tt>[^...]</tt>
<list compact>
<item>Substitui exatamente um caracter por qualquer outro diferente dos
caracteres entre colchetes (excluindo "^").
</list>
</list>
<p>
Por exemplo, teste o seguinte e pense por si mesmo:
<example>
$ mkdir lixo; cd lixo; $ touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rm -rf lixo
</example>

<sect1 id="cmd-return">Valor de retorno do comando
<p>
Cada comando retorna seu estado de saída como o valor de retorno.
<list compact>
<item>valor de retorno = 0 se o comando é executado com sucesso.
<item>valor de retorno = não-zero se o comando finaliza com erro.
</list>
O valor de retorno pode ser acessado pela variável shell <tt>$?</tt>
imediatamente após a execução.
<p>
Por favor note que, quando o valor de retorno é usado no contexto lógico
para o shell, <strong>sucesso</strong> é tratado como o
<strong>TRUE</strong> (VERDADEIRO) lógico. Isso é um pouco não intuitivo já
que <strong>sucesso</strong> produz valor <strong>zero</strong>.
<p>
Veja <ref id="shell-cond">.

<sect1 id="cmd-typical">Seqüências de comando típicas
<p>
<!-- new content in this whole sect1 ind sect2s -->
Vamos tentar lembrar as seguintes expressões de comandos shell. Veja <ref
id="shell-param">, <ref id="shell-redirect">, <ref id="shell-cond">, e <ref
id="clprocess"> depois de ler essas expressões.

<sect2 id="cmd-back"><tt>comando &amp;</tt>
<p>
O <prgn>comando</prgn> é executado na subshell no <strong>plano de
fundo</strong> (background). Tarefas em plano de fundo permitem que usuários
executem vários programas em um único shell.
<p>
O gerenciamento de processos em plano de fundo envolve os comandos embutidos
do shell: <prgn>jobs</prgn>, <prgn>fg</prgn>, <prgn>bg</prgn>, e
<prgn>kill</prgn>. Por favor leia as seções da  página de manual <manref
name="bash" section="1"> em "SIGNALS", "JOB CONTROL", e "SHELL BUILTIN
COMMANDS".
<footnote>
O sistema &debian; é um sistema multi-tarefa.
</footnote>

<sect2 id="cmd-pipe"><tt>comando1 | comando2</tt>
<p>
A saída padrão do <prgn>comando1</prgn> é transmitida à entrada padrão do
<prgn>comando2</prgn>. Ambos os comandos podem estar sendo executados
<strong>ao mesmo tempo</strong>. Isso é chamado de
<strong>pipeline</strong>.

<sect2 id="cmd-list"><tt>comando1 ; comando2</tt>
<p>
O <prgn>comando1</prgn> e o <prgn>comando2</prgn> são executados
<strong>seqüencialmente</strong>.

<sect2 id="cmd-and"><tt>comando1 &amp;&amp; comando2</tt>
<p>
O <prgn>comando1</prgn> é executado. Se tiver sucesso, o
<prgn>comando2</prgn> também é executado <strong>seqüencialmente</strong>.
Retorna sucesso se o <prgn>comando1</prgn> <strong>ou</strong> o
<prgn>comando2</prgn> tiverem sucesso.

<sect2 id="cmd-stdout"><tt>comando &gt; <var>foo</var></tt>
<p>
Redireciona a saída padrão do <prgn>comando</prgn> para um arquivo
<tt><var>foo</var></tt>. (sobrescreve)

<sect2 id="cmd-stdout2"><tt>comando &gt;&gt; <var>foo</var></tt>
<p>
Redireciona a saída padrão do <prgn>comando</prgn> para um arquivo
<tt><var>foo</var></tt> (acrescenta (append))

<sect2 id="cmd-stderr"><tt>comando &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
Redireciona tanto a saída padrão quanto a saída padrão de erro do
<prgn>comando</prgn> para um arquivo <tt><var>foo</var></tt>.

<sect2 id="cmd-stdin"><tt>comando &lt; <var>foo</var></tt>
<p>
Redireciona a entrada padrão do <prgn>comando</prgn> para um arquivo
<tt><var>foo</var></tt>. Teste:
<example>
$ &lt;/etc/motd pager
 ... (as saudações)
$ pager &lt;/etc/motd
 ... (as saudações)
$ pager /etc/motd
 ... (as saudações)
$ cat /etc/motd | pager
 ... (as saudações)
</example>
Apesar de as 4 sintaxes mostrarem a mesma coisa, o último exemplo executa um
comando <prgn>cat</prgn> extra e desperdiça recursos sem motivo.

<sect1 id="cmd-alias">Apelido (alias) de comando
<p>
<!-- new content -->
Você pode definir um apelido (alias) para o comando usado freqüentemente.
Por exemplo:
<example>
$ alias la='ls -la'
</example>
Agora, <prgn>la</prgn> funciona como um atalho para <tt>ls -la</tt> que
lista todos os arquivos em formato de listagem longa.
<p>
Você pode identificar o caminho (path) exato ou identidade do comando usando
o comando <prgn>type</prgn>. Por exemplo:
<example>
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
</example>
Aqui o <prgn>ls</prgn> foi procurado recentemente enquanto <prgn>file</prgn>
não foi, então o <prgn>ls</prgn> está  "hashed", isto é, o shell tem um
registro interno para o acesso rápido da localização do comando
<prgn>ls</prgn>.

<sect id="text-process">Processamento de texto em similares a Unix
<p>
Há algumas ferramentas de processamento de texto que são usadas muito
freqüentemente no sistema similar ao Unix.
<list compact>
<item>Nenhuma expressão regular é usada:
<list compact>
<item><prgn>head</prgn> tem como saída a primeira parte de arquivos.
<item><prgn>tail</prgn> tem como saída a última parte de arquivos.
<item><prgn>sort</prgn> ordena linhas de arquivos texto.
<item><prgn>uniq</prgn> remove linhas duplicadas de um arquivo ordenado.
<item><prgn>tr</prgn> troca ou apaga caracteres.
<item><prgn>diff</prgn> compara aquivos linha por linha.
</list>
<item>É usada Expressão regular básica (ERB):
<list compact>
<item><prgn>grep</prgn> encontra texto com o padrão.
<item><prgn>ed</prgn> é um editor de linha primitivo.
<item><prgn>sed</prgn> é um editor de fluxo.
<item><prgn>vi</prgn> é um editor de tela.
<item><prgn>emacs</prgn> é um editor de tela.
</list>
<item>É usada Expressão regular extendida (ERE):
<list compact>
<item><prgn>egrep</prgn> encontra texto com o padrão.
<item><prgn>awk</prgn> faz processamento de texto simples.
 Veja <ref id="awk">.
<item><prgn>perl</prgn> faz todo tipo de processamento de texto concebível.
 Veja <ref id="perl">.
</list>
</list>
Veja <ref id="perl-i">, <ref id="scrp-snip">, e <ref id="perl-mad"> para ter
alguns exemplos de script.


<sect1 id="regex">Expressões regulares
<p>
Expressões regulares são usadas em muitas ferramentas de processamento de
texto. Elas são análogas aos curingas de shell (veja <ref id="cmd-wild">),
mas são também mais complicadas e mais poderosas.
<p>
A expressão regular descreve um padrão de combinação e é feita de caracteres
de texto e <strong>metacaracteres</strong>. O metacaracter é apenas um
caracter com um significado especial. Há 2 estilos principais, ERB e ERE,
dependendo das ferramentas de texto como descrito em <ref
id="text-process">.
<p>
Para as EREs, os <strong>metacaracteres</strong> incluem "<tt> \ . [ ] ^
&dollar; * + ? ( ) { } | </tt>". A expressão regular significa:
<list compact>
<item><tt>c</tt>
<list compact>
<item>Combina com o não-metacaracter "<tt>c</tt>".
</list>
<item><tt>\c</tt>
<list compact>
<item>Combina com o caracter literal "<tt>c</tt>".
</list>
<item><tt>.</tt>
<list compact>
<item>Combina com qualquer caracter incluindo newline (nova linha).
</list>
<item><tt>^</tt>
<list compact>
<item>Combina com o começo de uma string (cadeia de caracteres).
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>Combina com o final de uma string.
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>Combina com o começo de uma palavra.
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>Combina com o final de uma palavra.
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>Essa lista de caracteres combina com qualquer um dos caracteres  "<tt>abc...</tt>".
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>Essa lista de caracteres negada combina com qualquer caracter exceto  
 "<tt>abc...</tt>".
</list>
<item><tt>r*</tt>
<list compact>
<item>Combina com zero ou mais expressões regulares identificadas por
 "<tt>r</tt>".
</list>
<item><tt>r+</tt>
<list compact>
<item>Combina com uma ou mais expressões regulares identificadas por 
 "<tt>r</tt>".
</list>
<item><tt>r?</tt>
<list compact>
<item>Combina com zero ou uma expressões regulares identificadas por 
 "<tt>r</tt>".
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>Combina com uma das expressões regulares identificadas por
 "<tt>r1</tt>" ou "<tt>r2</tt>".
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>Combina com uma das expressões regulares identificadas por
 "<tt>r1</tt>" ou "<tt>r2</tt>" e a trata como uma expressão regular
 <strong>entre parênteses</strong>.
</list>
</list>
<p>
Em ERBs os <strong>metacaracteres</strong> "<tt> + ? ( ) { } | </tt>" perdem
seu significado especial; ao invés disso use as versões com barra invertida
"<tt> \+ \? \( \) \{ \} \| </tt>". Assim a construção de agrupamento
<tt>(r1|r2)</tt> precisa ser colocada como <tt>\(r1|r2\)</tt> em ERBs. No
<prgn>emacs</prgn>, apesar de ser basicamente ERB, "<tt> + ? </tt>" são
tratados como os <strong>metacaracteres</strong>. 
Então não há necessidade de usar barra invertida para eles. Veja <ref
id="replaceex"> para saber como a construção de agrupamento é usada.
<p>
Por exemplo, o <prgn>grep</prgn> pode ser usado para fazedr a busca de texto
usando a expressão regular:
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">Expressões de substituição
<p>
Para a expressão de substituição, os seguintes caracteres têm significados
especiais:
<list>
<item><tt>&amp;</tt> 
<list compact>
<item>Representa o que a expressão regular casou (matched).
(use <tt>\&amp;</tt> no <prgn>emacs</prgn>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>Representa o que a <var>n</var>-ésima  expressão regular
<strong>entre parênteses</strong> casou.
</list>
</list>
Para string de substituição Perl, usa-se <tt>&dollar;<var>n</var></tt> ao
invés de <tt>\<var>n</var></tt> e <tt>&amp;</tt> não tem significado
especial.
<p>
Por exemplo:
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
Aqui por favor preste uma atenção extra ao estilo da expressão regular
<strong>entre parênteses</strong> e como as strings casadas são usadas no
processo de substituição de texto em ferramentas diferentes.
<p>
Essas expressões regulares podem ser usadas para os movimentos de cursor e
as ações de substituições de texto nos editores também.
<p>
Por favor leia todas as páginas de manual relacionadas para aprender esses
comandos.

<sect id="unixfile">Sistema de arquivos em similares ao Unix
<p>
<!-- 
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
No GNU/Linux e outros SOs similares ao Unix, os <strong>arquivos</strong>
são organizados em <strong>diretórios</strong>.
<footnote>
<strong>Diretórios</strong> são chamados de <strong>pastas</strong> em
alguns outros sistemas.
</footnote>
Todos os <strong>arquivos</strong> e <strong>diretórios</strong> são
arranjados em uma grande árvore, a hierarquia de arquivos, com raiz em
<file>/</file>.
<p>
Esses arquivos e diretórios podem ser distribuídos entre vários
dispositivos. O comando <manref name="mount" section="8"> serve para anexar
o sistema de arquivos encontrado em um dispositivo à grande árvore de
arquivos. Inversamente, o comando <manref name="unmount" section="8">
desconecta o dispositivo novamente.

<sect1 id="file-basics">Básico de arquivos Unix
<p>
<!-- new content -->
Aqui está o básico:
<list compact>
<item>Nomes de arquivos são sensíveis a maiúsculas/minúsculas. Isto é,
<file>MEUARQUIVO</file> e <file>MeuArquivo</file> são arquivos
<strong>diferentes</strong>.

<item>O diretório raiz (root) é referenciado simplesmente como
<file>/</file>. Não confunda essa "raiz"(root) com o usuário root. Veja <ref
id="login-root">.

<item>Todo diretório tem um nome que pode conter quaisquer letras ou
símbolos <strong>exceto</strong> <file>/</file>.
<footnote>
Apesar de você <strong>poder</strong> usar praticamente quaisquer letras ou
símbolos em um nome de arquivo, na prática isso é uma má idéia. É melhor
evitar quaisquer caracteres que têm significados especiais freqüentemente na
linha de comando, incluindo espaços, tabs, newlines e outros caracteres
especiais: <tt>{ } ( ) [ ] ' ` &quot; \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> .
<p>
Se você quiser separar palavras em um nome, o ponto, hífen, e subscrito
(underscore) são boas escolhas. Você também pode colocar maiúsculas nas
letras iniciais de cada palavra, <tt>DesseJeito</tt>.
</footnote>
O diretório raiz é uma exceção; seu nome é <file>/</file> (pronunciado como
"slash" (barra) ou "o diretório raiz") e não pode ser renomeado.

<item>Cada arquivo ou diretório é designado por um <strong>nome de arquivo
totalmente qualificado</strong>, <strong>nome de arquivo absoluto</strong>,
ou um <strong>caminho</strong>, dando a seqüência de diretórios através dos
quais se precisa passar para alcançá-lo. Os três termos são sinônimos. Todos
os nomes de arquivo absolutos começam com o diretório <file>/</file>, e há
uma <file>/</file> entre cada diretório ou arquivo no nome de arquivo. A
primeira <file>/</file> é o nome de um diretório, mas as outras são
simplesmente separadores para distinguir as partes do nome de arquivo.
<p>
As palavras usadas aqui podem ser confusas. Tome o seguinte exemplo:
<example>
/usr/share/keytables/us.map.gz
</example>
Esse é um nome de arquivo totalmente qualificado; algumas pessoas o chamam
de <strong>caminho</strong> (path). Entretanto, as pessoas também se referem
a <file>us.map.gz</file> sozinho como um nome de arquivo.
<footnote>
Há também outro uso para a palavra <strong>caminho</strong>. Veja <ref
id="cmd-path">. O significado desejado geralmente fica claro pelo contexto.
</footnote>

<item>O diretório raiz tem um número de ramos, como <file>/etc</file> e
<file>/usr</file>. Esses subdiretórios também ramificam em ainda mais
subdiretórios, como <file>/etc/init.d</file> e <file>/usr/local</file>. O
conjunto todo junto é chamado de <strong>árvore de diretórios</strong>.
<p>
Você pode pensar em um nome de arquivo absoluto como uma rota a partir da
base da árvore (<file>/</file>) até o fim de algum ramo (um arquivo). Você
também ouvirá as pessoas falarem sobre a árvore de diretórios como se fosse
uma árvore <strong>familiar</strong>: assim os subdiretórios tem
<strong>ancestrais</strong>, e um caminho mostra a ascendência completa de
um arquivo.
<p>
Há também caminhos relativos que começam em algum lugar diferente do
diretório raiz. Você deve se lembrar de que o diretório <file>../</file> se
refere ao diretório pai.

<item>Não há diretório que corresponda a um dispositivo físico, tal como seu
disco rígido. Isso difere do CP/M, DOS, e Windows, onde todos os caminhos
começam com um nome de dispositivo como <tt>C:\</tt>. Veja <ref
id="file-system">.
</list>

<p>
As melhores práticas detalhadas para a hierarquia de arquivos estão
descritas no <url id="&f-fhs;" name="Padrão de Hierarquia de Sistema de
Arquivos">. Você deve se lembrar dos seguintes fatos como iniciante:
<list compact>
<item><file>/</file>
<list compact>
<item>Uma <file>/</file> simples representa o diretório raiz.
<p>
</list>
<item><file>/etc</file>
<list compact>
<item>Esse é o lugar para os arquivos de configuração globais do sistema.
</list>
<item><file>/var/log</file>
<list compact>
<item>Esse é o lugar dos arquivos de log do sistema.
</list>
<item><file>/home</file>
<list compact>
<item>Esse é o diretório que contém todos os diretórios home para todos os
usuários não privilegiados.
</list>
</list>

<sect1 id="file-system">O conceito de sistema de arquivos no &debian;
<p>
<!-- old content modified with fs.h reference -->
Seguindo a tradição Unix, o sistema &debian; fornece o sistema de arquivos
sob o qual os dados físicos em discos rígidos e outros dispositivos de
armazenamento, e a interação com os dispositivos de hardware como telas de
console e consoles seriais remotos são representados em uma forma unificada.
<p>
Cada arquivo, diretório, pipe nomeada, ou dispositivo físico em um sistema
&debian; tem uma estrutura de dado chamada <strong>inode</strong> que
descreve seus atributos associados como o usuário que é seu dono, o grupo ao
qual pertence, a hora do último acesso, etc.. Veja <url id="&f-inode-def;">
para ter a definição exata da <tt>estrutura inode</tt> no sistema &debian;
GNU/Linux.
<p>
Essa representação unificada de entidades físicas é muito poderosa já que
nos permite usar o mesmo comando para o mesmo tipo de operação em muitos
dispositivos totalmente diferentes.
<p>
Todos os seus arquivos poderiam estar em um disco --- ou você poderia ter 20
discos, alguns deles conectados a computadores diferentes em algum lugar na
rede. Você não pode dizer simplesmente olhando pela árvore de diretórios, e
praticamente todos os comandos funcionam da mesma forma independentemente do
tipo de dispositivo(s) físico(s) em que seus arquivos realmente estão.

<sect1 id="file-perm">Permissões de acesso de arquivos e diretórios
<p>
<!-- old content -->
As permissões de acesso a arquivo e diretório são definidas separadamente
para as três seguintes categorias de usuários afetados:
<list compact>
<item>o <strong>usuário</strong> (user) que é dono do arquivo (u),
<item>outros usuários no <strong>grupo</strong> (group) ao qual o arquivo
pertence (g), e
<item>todos os <strong>outros</strong> (other) usuários (o).
</list>
<p>
Para um arquivo, cada permissão correspondente possibilita:
<list compact>
<item><strong>ler</strong> (r) (read): para examinar o conteúdo do arquivo,
<item><strong>escrever</strong> (w) (write): para modificar o arquivo, e
<item><strong>executar</strong> (x): para executar o arquivo como um
comando.
</list>
<p>
Para um diretório, cada permissão correspondente possibilita:
<list compact>
<item><strong>ler</strong> (r): para listar o conteúdo do diretório, 
<item><strong>escrever</strong> (w): para adicionar ou remover arquivos no
diretório, e
<item><strong>executar</strong> (x): para acessar arquivos no diretório.
</list>
Aqui, permissão de <strong>executar</strong> no diretório não significa
apenas permitir a leitura dos arquivos em seu diretório, mas também permitir
a visualização de seus atributos, como o tamanho e o tempo de modificação.
<p>
Para obter as informações de permissão (e outras) de arquivos e
diretórios,
usa-se o <prgn>ls</prgn>. Consulte <manref name="ls" section="1">. Quando o
<prgn>ls</prgn> é invocado com a opção <tt>-l</tt>, exibe essas informações
na seguinte ordem:
<list compact>
<item>o <strong>tipo de arquivo</strong> (primeiro caracter)
<list compact>
 <item><tt>-</tt>: arquivo normal
 <item><tt>d</tt>: diretório
 <item><tt>l</tt>: ligação simbólica (symlink)
 <item><tt>c</tt>: nó de dispositivo caracter
 <item><tt>b</tt>: nó de dispositivo bloco
 <item><tt>p</tt>: pipe nomeada
 <item><tt>s</tt>: soquete
 </list>
<item>as <strong>permissões</strong> de acesso do arquivo (os próximos nove
 caracteres, consistindo de três caracteres cada para usuário (user), grupo
 (group), e outros (other) nessa ordem) 
<item>o <strong>número de ligações diretas</strong> (hard links) para o
arquivo
<item>o nome do <strong>usuário</strong> que é dono do arquivo 
<item>o nome do <strong>grupo</strong> ao qual o arquivo pertence 
<item>o <strong>tamanho</strong> do arquivo em caracteres (bytes)
<item>a <strong>data e hora</strong> do arquivo (mtime)
<item>o <strong>nome</strong> do arquivo.
</list>
<p>
Para mudar o dono do arquivo, usa-se o <prgn>chown</prgn> a partir da conta
root.  Para mudar o grupo do
arquivo, usa-se o <prgn>chgrp</prgn> a partir da conta do dono do arquivo ou
da conta root. Para mudar as
permissões de acesso de arquivo e diretório, usa-se o <prgn>chmod</prgn> a
partir da conta do dono do arquivo ou da conta root. A sintaxe básica para
manipular o arquivo <file>foo</file> é:
<example>
# chown <var>novodono</var> foo
# chgrp <var>novogrupo</var> foo 
# chmod  [ugoa][+-=][rwx][,...] foo 
</example>
Veja <manref name="chown" section="1">, <manref name="chgrp" section="1">, e
<manref name="chmod" section="1"> para os detalhes.

<p>
Por exemplo, para fazer uma árvore de diretórios ser de propriedade de um
usuário <var>foo</var> e compartilhada por um grupo <var>bar</var>, execute
os seguintes comandos a partir da conta root:
<example>
# cd /algum/local/
# chown -R <var>foo</var>:<var>bar</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
Há mais três bits de permissão especiais:
<list compact>
<item><strong>set user ID</strong> (s ou S ao invés do x do usuário),
<item><strong>set group ID</strong> (s ou S ao invés do x do grupo), e 
<item><strong>sticky bit</strong> (t ou T ao invés do x de outros).
</list>
Aqui a saída de <prgn>ls -l</prgn> para esses bits é transformada em
maiúsculas se os bits de execução estiverem ocultos devido a essas saídas
estarem desabilitadas.
<p>
Habilitar <strong>set user ID</strong> para um arquivo executável permite
que um usuário execute o arquivo executável com ID do dono do arquivo (por
exemplo <strong>root</strong>). Similarmente, definir <strong>set group
ID</strong> em um arquivo executável permite que um usuário execute o
arquivo executável com o group ID do arquivo (por exemplo
<strong>root</strong>). Devido a esses ajustes poderem causar sérios riscos
de segurança, suas habilitações requerem cuidado extra.
<p>
Habilitar <strong>set group ID</strong> para um diretório permite o esquema
de criação de arquivo no estilo BSD, onde todos os arquivos criados no
diretório pertencem ao <strong>grupo</strong> do diretório.
<p>
Habilitar <strong>sticky bit</strong> em um diretório impede que um arquivo
no diretório seja removido por um usuário que não é dono do arquivo. Para
assegurar o conteúdo de um arquivo em diretórios globalmente graváveis como
<file>/tmp</file> ou em diretórios graváveis por grupo, é necessário não
apenas que a permissão de <strong>escrita</strong> (write) esteja desativada
para o arquivo, mas também ativar o <strong>sticky bit</strong>  no
diretório. Caso contrário, o arquivo pode ser removido e um novo arquivo
pode ser criado com o mesmo nome por qualquer usuário que tenha permissão de
escrita no diretório.
<p>
Aqui estão alguns exemplos interessantes das permissões de arquivo.
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
Há um modo numérico alternativo para descrever permissões de arquivo em
comandos <manref name="chmod" section="1">. Esse modo numérico usa de 3 a 4
dígitos de números octais (base=8). Cada dígito corresponde a:
<list compact>
<item>primeiro dígito opcional: soma de <strong>set user ID</strong> (=4),
 <strong>set group ID</strong> (=2), e <strong>sticky bit</strong> (=1)
<item>segundo dígito: soma de permissões de <strong>leitura</strong> (=4),
 <strong>escrita</strong> (=2), e <strong>execução</strong> (=1) para o
 <strong>usuário</strong>
<item>terceiro dígito: idem para o <strong>grupo</strong>
<item>quarto dígito: idem para <strong>outros</strong>
</list>
<p>
Isso parece complicado mas na verdade é muito simples. Se você olhar para as
primeiras (2-10) colunas da saída do comando <tt>ls -l</tt> e lê-las como
uma representação binária (base=2) de permissões de arquivo ("-" sendo "0" e
"rwx" sendo "1"), esse valor de modo numérico deve fazer sentido como uma
representação octal (base=8) das permissões de arquivo para você.
<footnote>
É claro que esse método funciona apenas para o modo numérico de 3 dígitos.
</footnote>
Por exemplo, teste:
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 pinguim  pinguim  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 pinguim  pinguim  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
A máscara de permissão de arquivo padrão pode ser definida usando o comando
interno de shell <prgn>umask</prgn>. Consulte <manref name="builtins"
section="7">.
</sect1>

<sect1 id="timestamp">Marcas de tempo
<p>
Há três tipos de marcas de tempo para um arquivo GNU/Linux:
<list compact>
<item><strong>mtime</strong>: a hora da modificação (<tt>ls -l</tt>),
<item><strong>ctime</strong>: a hora da mudança de estado (<tt>ls -lc</tt>),
e
<item><strong>atime</strong>: a hora do último acesso (<tt>ls -lu</tt>).
</list>
Note que <strong>ctime</strong> não é a hora de criação do arquivo.
<list compact>
<item>Sobrescrever um arquivo altera <strong>mtime</strong>,
<strong>ctime</strong>, e <strong>atime</strong> do arquivo.
<item>Mudar a permissão ou o dono de um arquivo altera o
<strong>ctime</strong> e o <strong>atime</strong> do arquivo.
<item>Ler um arquivo altera o <strong>atime</strong> do arquivo.
</list> 
Note que até uma simples leitura de um arquivo no sistema &debian;
normalmente causará uma operação de escrita de arquivo para atualizar a
informação de <strong>atime</strong> no <strong>inode</strong>. Montar um
sistema de arquivos com a opção <tt>noatime</tt> fará com que o sistema pule
essa operação e resultará em acesso para leitura mais rápido. Veja <manref
name="mount" section="8">.
<p>
<!-- new content -->
Use o comando <manref name="touch" section="1"> para mudar as marcas de
tempo de arquivos existentes.
</sect1>

<sect1 id="links">Ligações (links)
<p>
<!-- old content -->
Há dois métodos para associar um arquivo <var>foo</var> a um nome de arquivo
diferente <var>bar</var>.
<list compact>
<item>uma <strong>ligação direta</strong> (hard link) é um nome duplicado
 para um arquivo existente. (<tt>ln <var>foo</var> <var>bar</var></tt>),
<item><strong>ligação simbólica</strong>, ou "symlink", é um arquivo
 especial que aponta para outro arquivo pelo nome (<tt>ln -s <var>foo</var>
 <var>bar</var></tt>).
</list>
Veja no seguinte exemplo as mudanças no contador de ligações e as sutis
diferenças  no resultado do comando <prgn>rm</prgn>.
<example>
$ echo "Conteúdo Original" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # ligação direta (hard link)
$ ln -s <var>foo</var> <var>baz</var>  # ligação simbólica (symlink)
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "Novo Conteúdo" &gt; <var>foo</var>
$ cat <var>bar</var>
Conteúdo Original
$ cat <var>baz</var>
Novo Conteúdo
</example>
<!-- minor update below -->
A ligação simbólica tem as permissões nominais de acesso de arquivo como
"rwxrwxrwx", como mostrado no exemplo acima, com as permissões de acesso 
efetivas ditadas pelas permissões do arquivo apontado por elas.

<p>
O diretório <file>.</file> liga ao diretório em que aparece, então o
contador de ligações de qualquer diretório novo começa com 2. O diretório
<file>..</file> liga ao diretório superior, então o contador de ligações do
diretório aumenta com a adição de novos subdiretórios.

<sect1 id="fifo">Pipes nomeados (FIFOs)
<p>
<!-- DDP Debian Tutorial content -->
<p>
Um pipe nomeado é um arquivo que age como um pipe. Você coloca alguma coisa
no arquivo e isso sai do outro lado. Então é chamado de FIFO, ou
First-In-First-Out (Primeiro-Entra-Primeiro-Sai): a primeira coisa que você
coloca no pipe é a primeira coisa que sai do outro lado.
<p>
Se você escrever em um pipe nomeado, o processo que está escrevendo no
pipe não termina até que a informação que está sendo escrita seja lida pelo
pipe. Se você ler de um pipe nomeado, o processo de leitura espera até que
haja algo para ler antes de terminar. O tamanho do pipe é sempre zero ---
ele não grava dados, apenas liga dois processos como o <tt>|</tt> do shell.
Entretanto, como o pipe tem um nome, os dois processos não precisam estar na
mesma linha de comando ou mesmo serem executados pelo mesmo usuário. 
<p>
Você pode testar isso fazendo o seguinte:
<example>
$ cd; mkfifo meupipe
$ echo "olá" &gt;meupipe &amp; # põe em plano de fundo (background)
[1] <var>5952</var>
$ ls -l meupipe
prw-r--r--    1 pinguim pinguim  0 2003-11-06 23:18 meupipe
$ cat meupipe
hello
[1]+  Done                    echo olá &gt;meupipe
$ ls meupipe
prw-r--r--    1 pinguim pinguim  0 2003-11-06 23:20 meupipe
$ rm mypipe
</example>

<sect1 id="sockets">Soquetes
<p>
<!-- new content -->
O soquete é similar ao pipe nomeado (FIFO) e possibilita que processos
troquem informações. Para o soquete, esses processos não precisam ser
executados ao mesmo tempo nem ser filhos do mesmo processo pai. Esse é o
ponto final para a comunicação entre processos. A troca de informação pode
ocorrer pela rede entre diferentes sistemas.

<sect1 id="device">Arquivos de dispositivos
<p>
<!-- DDP Debian Tutorial content, modified -->
Arquivos de dispositivos se referem a dispositivos físicos ou virtuais em
seu sistema, tais como seu disco rígido, sua placa de vídeo, monitor, ou
teclado. Um exemplo de dispositivo virtual é o teclado, representado pelo
<tt>/dev/console</tt>.
<p>
Há dois tipos de dispositivos:
<list compact>
<item><strong>dispositivo caracter</strong>
<list compact>
<item>Pode ser acessado um caracter por vez, isto é, a menor unidade de dado
que pode ser escrita ou lida do dispositivo é um caracter (byte).
</list>
<item><strong>dispositivo bloco</strong>
<list compact>
<item>Precisa ser acessado em unidades maiores chamadas blocos, que contêm
um número de caracteres. Seu disco rígido é um dispositivo bloco.
</list>
</list>
<p>
Você pode ler ou escrever em arquivos de dispositivos, embora o arquivo
possa conter dados binários que podem ser algo sem nexo, incompreensível
para humanos. Escrever dados diretamente nesses arquivos algumas vezes é
útil para resolução de problemas de conexões de hardware. Por exemplo, você
pode enviar um arquivo texto para o dispositivo de impressora
<file>/dev/lp0</file> ou enviar comandos de modem para a porta serial
apropriada <file>/dev/ttyS0</file>. Mas, a menos que isso seja feito com
cautela, isso pode causar um grande desastre. Então seja cuidadoso.

<sect2 id="devnull"><file>/dev/null</file> etc.
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> é um arquivo de dispositivo especial que descarta
qualquer coisa quq você escrever nele. Se você não quiser alguma coisa,
envie para <file>/dev/null</file>. É essencialmente um poço sem fundo. Se
você ler de <file>/dev/null</file>, obterá um caracter fim-de-arquivo (EOF)
imediatamente.
<p>
<file>/dev/zero</file> é similar, mas se você ler a partir dele obtém o
caracter <tt>\0</tt> (não o mesmo que o número zero ASCII). Veja <ref
id="dummyfile">.

<sect2 id="node">Número de nó de dispositivo
<p>
<!-- new content -->
O número de nó de dispositivo é mostrado executando <prgn>ls</prgn> assim:
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
Aqui, 
<list compact>
<item><file>/dev/hda</file> tem o número maior (major) de dispositivo 3 e
número menor (minor) de dispositivo 0. É acessível para leitura/escrita pelo
usuário que pertence ao grupo <tt>disk</tt>,
<item><file>/dev/ttyS0</file> tem número maior de dispositivo 4 e número
menor de dispositivo 64. É acessível para leitura/escrita pelo usuário que
pertence ao grupo <tt>dialout</tt>, e
<item><file>/dev/zero</file> tem número maior de dispositivo 1 e número
menor de dispositivo 5. É acessível para leitura/escrita por qualquer um.
</list>
<p>
No sistema mais antigo, o processo de instalação cria os nós de dispositivos
usando o comando <prgn>/sbin/MAKEDEV</prgn>. Veja a página de manual <manref
name="MAKEDEV" section="8">.
<p>
No sistema mais novo, o sistema de arquivos sob o <file>/dev</file> é povoado
automaticamente pelo sistema de arquivos de dispositivos de forma similar ao
sistema de arquivos <file>/proc</file>.

<sect1 id="procfs">Sistema de arquivo <file>/proc</file>
<p>
<!-- modified heavily, original from Debian Guide -->
O sistema de arquivos <file>/proc</file> é um pseudo sistema de arquivos e
contém informações sobre o sistema e processos que estão sendo executados.
<p>
As pessoas freqüentemente se apavoram quando notam um arquivo em particular
- <file>/proc/kcore</file> - que é geralmente enorme. Ele é (mais ou menos)
  uma cópia do conteúdo da memória de seu computador. É usado para depurar
(debug) o kernel. Ele não existe realmente em lugar nenhum, então não se
preocupe com seu tamanho.
<p>
Veja <ref id="proc-sys"> e a página de manual <manref name="proc"
section="5">.

<sect id="xtuto">Sistema X Window
<p>
<!-- practically new content -->
Veja <ref id="x">.

<sect1 id="xstart">Iniciar o Sistema X Window
<p>
O Sistema X Window pode ser iniciado automaticamente com um daemon de login
gráfico similar ao <prgn>xdm</prgn> ou digitando o seguinte a partir do
console.
<example>
$ exec startx
</example>

<sect1 id="xmenu">Menu no Sistema X Window
<p>
Como o ambiente X pode acomodar muitos gerenciadores de janelas, suas
interfaces de usuário variam bastante. Por favor, lembre-se de que clicando
com o botão direito no plano de fundo (root window), obtem-se um menu de
seleções. Isso está sempre disponível.
<list compact>
<item>Para obter o prompt de comando shell, inicie o Xterm a partir do menu:
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>Para navegação gráfica de páginas web, inicie o Mozilla a partir do
menu:
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>Para navegação gráfica de arquivos PDF, inicie o Xpdf a partir do
menu:
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
Se você não encontrar a entrada de menu, instale os pacotes pertinentes.
Veja <ref id="apt-install">.

<sect1 id="xkeys">Seqüência de teclado para o Sistema X Window
<p>
A seguir são apresentados os comandos de teclado importantes a lembrar ao
executar o Sistema X Window.
<list compact>
<item>Ctrl-Alt-F1 até F6:  Muda para outros pseudo-terminais (a partir de uma
janela X, DOSEMU, etc.)
<item>Alt-F7:              Volta para o X Window
<item>Ctrl-Alt-menos:      Muda a resolução da tela no X Window (menos
refere-se às teclas no teclado numérico)
<item>Ctrl-Alt-mais:       Muda a resolução da tela da maneira oposta no X
Window (mais refere-se às teclas no teclado numérico)
<item>Ctrl-Alt-Backspace:  Termina o programa do Servidor X
<item>Alt-X, Alt-C, Alt-V: Combinações de teclas comuns do Windows/Mac para
Cortar, Copiar e Colar com teclas Ctrl- são substituídas por essas teclas
Alt- em alguns programas como o Netscape Composer.
</list>

<sect id="cmd-study">Estudos adicionais
<p>
Nesse momento, recomendo que você leia os livros guia chaves a partir de
<url id="&tldp-guide;" name="O Projeto de Documentação Linux: Guias">:
<list compact>
<item>"The Linux System Administrators' Guide" (O Guia dos Administradores
de Sistemas Linux), 
<list compact>
<item>Cobre todos os aspectos de como manter um sistema funcionando,
manipulação de contas de usuários, backups, configuração do sistema.
<item>pacote: <package>&p-sysadmin-guide;</package>
<item>arquivo: <url id="&f-sysadmin-guide;">
<item>web: <url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition" (O Guia dos
Administradores de Rede do Linux, Segunda Edição), 
<list compact>
<item>É uma referência única para administração de rede em um ambiente
Linux.
<item>pacote: <package>&p-netadmin-guide;</package>
<item>arquivo: <url id="&f-netadmin-guide;">
<item>web: <url id="&w-netadmin-guide;">
</list>
 <item>"Linux: Rute User's Tutorial and Exposition"
 <list compact>
  <item>A nice online and hardcover book covering GNU/Linux system 
        administration.
  <item>By Paul Sheer
  <item>Published by Prentice Hall
  <item>Package: <package>&p-rutebook;</package> (from <tt>non-free</tt>)
  <item>File: <file>&f-rutebook;</file>
  <item>Web: <url id="&rutehome;">
 </list>
</list>
<p>
Veja <ref id="support"> para maiores recursos de aprendizado.
</chapt>

