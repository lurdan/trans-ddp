<!-- CVS revision of this document "$Revision: 1.7 $"  -->
<!-- CVS revision of original english document "1.99"   -->

<chapt id="tips"> Dicas &debian;


<sect id="booting">Iniciando o sistema
<p>
Consulte o <url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> do LDP
para obter informações detalhadas sobre o prompt de inicialização.

<sect1 id="crackroot">"Eu esqueci a senha do root !" (1)
<p>
É possível iniciar um sistema e logar com a conta do root sem conhecer a
senha do root se você tiver acessso ao teclado do console. (Isto assume
que não há requerimentos de senhas da BIOS e de um carregador de
inicialização como o <prgn>lilo</prgn> que o impediriam de iniciar o
sistema.)
<p>
Este é um procedimento que não requer  discos de inicialização externos
e nenhuma mudança nas configurações de inicialização. Aqui, "Linux" é o
rótulo para inicializar o kernel Linux na instalação Debian padrão.
<p>
Na tela de inicialização do <prgn>lilo</prgn>, assim que <tt>boot:</tt>
aparecer (você deve pressionar a tecla shift neste momento em alguns
sistemas para prevenir a inicialização automática), digite :
<example>
boot: Linux init=/bin/sh
</example>
Isso faz com que o sistema inicie o kernel e execute <file>/bin/sh</file>
ao invés de seu padrão <prgn>init</prgn>. Agora você ganhou privilégios de
root e um shell de root. Uma vez que o <file>/</file> estará atualmente
montado como somente-leitura e muitas partições de disco ainda não foram
montadas, você deve fazer o seguinte para conseguir um sistema
razoavelmente funcional.
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(Caso o segundo campo de dados em <file>/etc/passwd</file> seja "x" para
cada nome de usuário, seu sistema usa senhas shadow e você deve editar o
arquivo <file>/etc/shadow</file>.) Para desabilitar a senha do root, edite
o segundo campo de dados no arquivo de senhas de maneira a deixá-lo
vazio. Agora o sistema pode ser reiniciado e você pode logar como root
sem uma senha. Quando inicia no nível de execução 1, o Debian (pelo menos
depois do Potato) requer uma senha, o que algumas distribuições mais
antigas não requerem.
<p>
É uma boa idéia ter um editor mínimo em <file>/bin/</file> caso o
<file>/usr/</file> não esteja acessível (consulte <ref id="bin-editor">).
<p>
Considere também instalar o pacote <package>sash</package>. Quando o
sistema ficar em um estado não-inicializável, execute :
<example>
boot: Linux init=/bin/sash
</example>
O <prgn>sash</prgn> funciona como um substituo interativo para o
<prgn>sh</prgn> mesmo quando o <file>/bin/sh</file> está inutilizável.
Ele é estaticamente ligado e inclui muitos utilitários padrões embutidos
(tecle "help" no prompt para uma lista de referência).
</sect1>

<sect1 id="crackroot2">"Eu esqueci a senha do root !" (2)
<p>
Inicie a partir de qualquer conjunto de disco de boot/root. Caso
<file><var>/dev/hda3</var></file> seja a partição raiz original, os
comandos a seguir irão lhe permitir editar o arquivo de senhas tão
facilmente quanto da maneira citada acima.
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
A vantagem deste método em relação ao método anterior é que você não
precisa conhecer a senha do <prgn>lilo</prgn> (caso exista). Mas para usar
este método você deve ser capaz de acessar o setup da BIOS e permitir o
sistema iniciar a partir de um disquete ou de um CD, caso isto já não
esteja configurado.
</sect1>

<sect1 id="dead-lilo">Não posso iniciar o sistema
<p>
Sem problemas, mesmo caso  você não tenha se preocupado em criar um disco
de inicialização durante a instalação. Caso o <prgn>lilo</prgn> esteja
quebrado, pegue o disco de inicialização do conjunto de instalação Debian
e inicie seu sistema a partir do mesmo. No prompt de inicialização,
assumindo que a partição raiz de sua instalação Linux esteja em
<file><var>/dev/hda12</var></file> e você queira o nível de execução 3,
digite :
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
Você irá iniciar então em um sistema quase que complementamente funcional
usando o kernel no disquete. (Podem existir problemas menores devido a
falta de recursos ou módulos do kernel.)
<p>
Veja também <ref id="un-bootable"> se tiver um sistema quebrado.
<p>
Caso você precise de um disquete de inicialização personalizado, siga as
instruções de <file>readme.txt</file> no disco de recuperação.
</sect1>

<sect1 id="no-x-start">"Deixe-me desabilitar o X na inicialização !"
<p>
Acompanhar a <tt>unstable/sid</tt> é divertido, mas uns <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn> e <prgn>wdm</prgn> com bugs iniciados
durante o processo de inicialização podem lhe deixar mal.
<p>
Primeiro obtenha o shell de root informando o seguinte no prompt de
inicialização :
<example>
boot: <var>Linux</var> vga=normal s
</example>
Aqui, <var>Linux</var> é o rótulo para a imagem de kernel através da qual
você está inicializando; "vga=normal" irá certificar-se de que o lilo execute
em vídeo VGA comum e "s" (ou "S") é o parâmetro passado ao
<prgn>init</prgn> para invocar o modo monousuário. Informe a senha de root
no prompt.
<p>
Existem algumas maneiras de desabilitar todos os daemons X que iniciam :
<list>
<item>execute <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6 .</tt>
<item>insira "exit 0" no início de todos os arquivos <file>/etc/init.d/<var>?</var>dm</file>.
<item>renomeie todos os arquivos <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> para <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>remova todos os arquivos <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>.
<item>execute <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Aqui, o número em <file>rc<var>2</var>.d</file> deve corresponder ao nível de execução
especificado em <file>/etc/inittab</file>. Também, 
<file><var>?</var>dm</file> significa que você precisa executar o comando
várias vezes substituindo-o com todos entre <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn> e <prgn>wdm</prgn>.
<p>
Somente o primeiro é "a verdadeira maneira" no &debian;. O último é fácil
mas funciona somente no &debian; e requer que você configure o display
manager novamente depois usando <prgn>dpkg-reconfigure</prgn>.
Os outros são métodos genéricos para desabilitar daemons.
<p>
Você ainda pode iniciar o X através do comando <prgn>startx</prgn> a
partir de qualquer console shell.
</sect1>

<sect1 id="bootprompt">Outros truques de inicialização com o prompt de inicialização
<p>
O sistema pode ser iniciado em um nível de execução e configuração
particulares usando o prompt de inicialização do <prgn>lilo</prgn>.
Detalhes são dados no 
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Caso você queira iniciar o sistema no nível de execução 4, use o
seguinte no prompt de inicialização do <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Caso você queira iniciar o sistema em modo monousuário funcionando
normalmente e você conhece a senha de root, um dos exemplos a seguir no
prompt de inicialização do <prgn>lilo</prgn> funcionará.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Caso você queira iniciar o sistema com uma quantidade de memória inferior
a quantidade de memória que o sistema possui fisicamente (digamos, 48MB
para um sistema com 64MB), use o seguinte no prompt de inicialização do
<prgn>lilo</prgn> :
<example>
boot: Linux mem=48M
</example>
Certifique-se de não especificar mais do que a quantidade de memória que você
possui fisicamente ou o kernel irá travar. Se você possui mais de 64MB de
memória, por exemplo, 128MB, a menos que você execute <tt>mem=128M</tt> ou
inclua uma linha adicional similar em <file>/etc/lilo.conf</file>, kernels
antigos e/ou placas-mãe com uma BIOS antiga não utilizarão a memória acima de
64MB.
</sect1>

<sect1 id="bootgrub">Definindo parâmetros de inicialização do GRUB
<p>
O GRUB é um novo gerenciador de inicialização do projeto Hurd e é muito
mais flexível do que o Lilo, mas possui uma forma diferente de lidar com
os parâmetros de inicialização.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Aqui, você deve conhecer os nomes de dispositivos Hurd :
<example>
o Hurd/GRUB         Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,1)             /dev/hda1           C: (geralmente)
 (hd0,4)             /dev/hda4           F: (geralmente)
 (hd1,4)             /dev/hdb4           ?
</example>
Consulte <file>&f-grub;</file> e <file>&f-grub-doc;</file> para maiores detalhes.
</sect>

<sect>Gravando atividades

<sect1 id="script">Gravando atividades shell
<p>
Administração de sistema envolve tarefas muito mais elaboradas em um
ambiente Unix do que em um computador pessoal comum. Certifique-se de
conhecer os meios mais básicos de configuração caso você precise recuperar
um sistema com problemas. Ferramentas de configuração baseados em X11
possuem uma boa aparência e são convenientes mas geralmente não podem ser
utilizadas nessas situações de emergência.
<p>
Neste contexto, gravar atividades shell é uma boa prática, especialmente
como root.
<p>
Emacs: Use M-x <tt>shell</tt> para iniciar gravando em um buffer, e use
C-x C-w para gravar o conteúdo do buffer para um arquivo.
<p>
Shell: Use o comando <prgn>screen</prgn> com "^A H" como descrito em 
<ref id="screen">; ou use o comando <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 ... faça qualquer coisa ...
 Ctrl-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
O comando a seguir pode ser usado ao invés do <prgn>script</prgn> :
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>Gravando atividades no X
<p>
Caso você precise gravar a imagem gráfica de uma aplicação X, incluindo
um display xterm, use o <prgn>gimp</prgn> (GUI).  Ele pode capturar cada
janela ou a tela toda. Alternativas são o <prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>) e <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>


</sect>

<sect id="archiving">Copiar e arquivar um subdiretório inteiro
<sect1>Comandos básicos para copiar um subdiretório inteiro
<p>
Caso você precise rearranjar a estrutra de arquivos, mova o conteúdo
incluindo ligações de arquivos usando :
<example>
Método padrão :
# cp -a /diretório/fonte /diretório/destino # requer o GNU cp
# (cd /diretório/fonte &amp;&amp; tar cf - . ) | \
        (cd /diretório/destino &amp;&amp; tar xvfp - )
Caso uma ligação direta (hard link) esteja envolvida, um método pedante é necessário :
# cd /caminho/para/diretório/antigo
# find . -depth -print0 | afio -p -xv -0a /ponto/montagem/do/novo/diretório
Caso remoto:
# (cd /diretório/fonte &amp;&amp; tar cf - . ) | \
        ssh usuário@máquina.domínio (cd /diretório/destino &amp;&amp; tar xvfp - )
Caso não existam arquivos ligados :
# scp -pr usuário1@máquina1.domínio:/diretório/fonte \
          usuário2@máquina2.domínio:/diretório/destino
</example>
Aqui, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> e <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
A comparação informativa a seguir sobre copiar um subdiretório inteiro
foi apresentada por Manoj Srivastava <email>srivasta@debian.org</email> na lista
de discussão debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Tradicionalmente, o <prgn>cp</prgn> não era um candidato para esta tarefa
uma vez que ele não desreferenciava ligações simbólicas ou preservava
ligações diretas (hard links). Outra coisa a considerar eram arquivos esparsos
(arquivos com buracos).
<p>
O <prgn>cp</prgn> GNU superou estas limitações; porém, em um sistema
não-GNU, o <prgn>cp</prgn> poderia continuar a ter problemas.
Adicionalmente, você não pode gerar arquivos pequenos e portáveis usando
o <prgn>cp</prgn>.
<example>
&percnt; cp -a . novodiretório
</example>

<sect1><prgn>tar</prgn>
<p>
O Tar superou alguns dos problemas que o <prgn>cp</prgn> tinha com
ligações simbólicas. Porém, apesar do <prgn>cpio</prgn> lidar com arquivos
especiais, o <prgn>tar</prgn> tradicional não o faz.
<p>
A maneira do <prgn>tar</prgn> lidar com mútiplas ligações diretas para
um arquivo é colocar somente uma cópia da ligação na fita, mas o nome anexado
a esta cópia é o <em>único</em> que você pode usar para recuperar o
arquivo; a maneira do <prgn>cpio</prgn> é colocar uma cópia para cada ligação,
mas você pode recuperá-lo usando quaisquer dos nomes.
<p>
O comando <prgn>tar</prgn> mudou sua opção para arquivos <file>.bz2</file>
entre o Potato e o Woody, portanto, use  <tt>--bzip2</tt> em scripts ao
invés de sua forma abreviada <tt>-I</tt> (Potato) ou <tt>-j</tt> (Woody).
</sect1>

<sect1><prgn>pax</prgn>
<p>
O novo, cantante e dançante Utilitário de Troca de Arquivos Portável,
compatível com os padrões POSIX (IEEE Std 1003.2-1992, páginas
380&ndash;388 (seção 4.48) e páginas 936&ndash;940 (seção E.4.48)). O
<prgn>pax</prgn> irá ler, gravar e listar os membros de um arquivo e irá
copiar hierarquias de diretórios. A operação do <prgn>pax</prgn> é
independente do formato específico do arquivo e suporta uma grande
variedade de formatos de arquivo.
<p>
As implementações do <prgn>pax</prgn> ainda são novas.
<example>
# apt-get install pax
$ pax -rw -p e . novodiretório
 ou
$ find . -depth  | pax -rw -p e  novodiretório
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
O <prgn>cpio</prgn> copia arquivos em ou de um arquivo <prgn>cpio</prgn>
ou <prgn>tar</prgn>.
O arquivo pode ser outro arquivo no disco, uma fita magnética ou um pipe.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd novo-diretório
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
O <prgn>afio</prgn> é uma maneira melhor de lidar com arquivo no formato
<prgn>cpio</prgn>. Ele é geralmente mais rápido do que o <prgn>cpio</prgn>, oferece
opções de fita magnética mais diversas e lida de maneira graciosa com
corrupção de dados de entrada. Ele suporta arquivo em múltiplos volumes
durante a operação interativa.
O <prgn>afio</prgn> pode criar arquivos comprimidos que são muito
mais seguros do que arquivo comprimidos <prgn>tar</prgn> ou
<prgn>cpio</prgn>. O <prgn>afio</prgn> é melhor usado como um "mecanismo
de arquivo" em um script de backup.
<example>
$ find . -depth -print0 | afio -px -0a novo-diretório
</example>
Todos os meus backups em fita utilizam o <prgn>afio</prgn>. 
</sect1>
</sect>

<sect id="diff-backup">Backups diferenciais e sincronização de dados
<p>
Backups diferenciais e sincronização de dados podem ser implementados
com diversos métodos :
<list>
<item><package>rcs</package>:  backup e histórico, somente texto
<item><package>rdiff-backup</package>:  backup e histórico. ligação simbólica OK.
<item><package>pdumpfs</package>: backup e histórico dentro de um
 sistema de arquivos. Ligação simbólica OK
<item><package>rsync</package>:  sincronização 1-way
<item><package>unison</package>:  sincronização 2-way
<item><package>cvs</package>:  sincronização multi-way com servidor backup
 e histórico, somente texto, maduro. Consulte <ref id="cvs">.
<item><package>arch</package>: sincronização multi-way com servidor backup
 e histórico, não existe algo como um "diretório de trabalho".
<item><package>subversion</package>: sincronização multi-way com servidor
 backup e histórico, Apache.
</list>
A combinação de um desses com o método descrito em 
<ref id="archiving"> e a atividade regular automatizada descrita em
<ref id="cronjob"> farão um bom sistema de backup.
<p>
Explicarei três utilitários de fácil uso.

<sect1 id="rdiff-backup">Backup diferencial com rdiff
<p>
O <package>rdiff-backup</package> oferece backup legal e simples com histórico
diferencial para quaisquer tipos de arquivos incluindo ligações simbólicas.
Para fazer backup da maioria de <file>~/</file> para
<file>/mnt/backup</file>:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
Para restaurar dados de três dias atrás do arquivo para <file>~/old</file>:
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
Consulte <manref name="rdiff-backup" section="1">.
</sect1>

<sect1 id="pdumpfs-backup">Backup diário com <package>pdumpfs</package>
<p>
O <package>pdumpfs</package> é um sistema de backup diário simples
similar ao <prgn>dumpfs</prgn> do Plan9 que preserva todo estado diário.
Você pode acessar estados (snapshots) antigos a qualquer momento para
obter um arquivo de um certo dia. Vamos fazer um backup de seu diretório
home com o <prgn>pdumpfs</prgn> e o <prgn>cron</prgn>!
<p>
O <prgn>pdumpfs</prgn> constrói o estado (snapshot) <tt>YYYY/MM/DD</tt>
(ano/mês/dia) no diretório destino. Todos os arquivos fontes são
copiados para o diretório do snapshot quando o <prgn>pdumpfs</prgn> é
executado pela primeira vez. Na segunda
vez e depois, o <prgn>pdumpfs</prgn> copia apenas os arquivos recém criados ou
atualizados e grava os arquivos não modificados como ligações diretas
para os arquivos do snapshot do dia anterior para economizar espaço em
disco.
<example>
$ pdumpfs <var>dir-fonte</var> <var>dir-dest</var> [<var>nomebase-dest</var>]
</example>
Consulte <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">Backup diferencial regular com RCS
<p>
O <package>Changetrack</package> irá gravar regularmente as mudanças nos
arquivos de configurações baseados em texto em arquivos RCS. 
Consulte <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>Recuperação de sistema paralizado
<sect1 id="kill">Matar um processo
<p>
Execute o <prgn>top</prgn> para ver qual processo está agindo de forma
engraçada. Pressione `P' para ordenar por uso de CPU, `M' para ordenar
por memória e `k' para matar um processo. Alternativamente, o comando
estilo BSD <tt>ps aux | less</tt> ou estilo System V <tt>ps -efH | less</tt>
podem ser usados. A sintaxe estilo System V exibe o ID (<tt>PPID</tt>) do
processo pai que pode ser usado para matar os filhos zumbis (defunct).
<p>
Use o <prgn>kill</prgn> para matar (ou enviar um sinal para) um processo
pelo ID do processo, <prgn>killall</prgn> para fazer o mesmo por nome de
comando do processo. Sinais freqüentemente usados :
<example>
 1: HUP,  reinicia daemon
15: TERM, kill normal
 9: KILL, kill forçado
</example>

</sect1>

<sect1>Alt-SysRq
<p>
Garantia contra mal funcionamento do sistema é fornecida pela opção de
compilação de kernel "Magic SysRq key".
Pressionar Alt-SysRq em um i386, seguido por uma das teclas
<tt>r 0 k e i s u b</tt>, faz a mágica.
<p>
Un`r'aw restaura o teclado após coisas como X travarem. Mudar o nível de
log do console para `0' reduz mensagens de erros. sa`k' (tecla de
administração de sistema) mata todos os processos no console virtual
atual. t`e'rminate mata todos os processos no terminal atual exceto o
<prgn>init</prgn>. k`i'll mata todos os processos exceto o <prgn>init</prgn>.
<p>
`S'ync, `u'mount e re`b'oot são para se livrar de situações realmente
ruins.
<p>
Os kernels de instalação padrão Debian não são compilados com essa opção
no momento em que este documento é escrito. Recompile o kernel para ativar
esta função. Informações detalhadas podem ser encontradas em
<file>/usr/share/doc/kernel-doc-<var>versão</var>/Documentation/sysrq.txt.gz</file>
ou <file>/usr/src/<var>kernel-versão</var>/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>


<sect id="nifty">Belos pequenos comandos para se lembrar

<sect1>Paginador
<p>
O <prgn>less</prgn> é o paginador padrão (navegador de conteúdo de arquivo).
Pressione `h' para ajuda. Ele pode fazer muito mais do que o
<prgn>more</prgn>. O <prgn>less</prgn>  pode ser supercarregado executando
<tt>eval $(lesspipe)</tt> ou <tt>eval $(lessfile)</tt> no script de
inicialização do shell. Veja mais em <file>&f-lessopen;</file>. A opção
<tt>-R</tt> permite saída de caracteres raw e habilita seqüências de escape
de cores ANSI. Consulte <manref name="less" section="1">.
<p>
O <prgn>w3m</prgn> pode ser um paginador alternativo útil para alguns
sistemas de códigos (EUC).

<sect1>Memória livre
<p>
O <prgn>free</prgn> e o <prgn>top</prgn> oferecem boa informação sobre
recursos de memória. Não se preocupe sobre o tamanho de "used" na linha
"Mem:", e ao invés leia a abaixo dessa (38792 no exemplo abaixo).
<example>
$ free -k # para uma máquina de 256MB
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
A quantidade exata de memória física pode ser confirmada com o comando
<tt>grep '^Memory' /var/log/dmesg</tt>, que nesse caso exibe
"Memory: 256984k/262144k available (1652k kernel code, 412k reserved,
2944k data, 152k init)".
<example>
Total              = 262144k = 256M (1k=1024, 1M=1024k)
Livre para o dmesg = 256984k = Total - kernel - reserved - data - init
Livre para o shell = 257136k = Total - kernel - reserved - data
</example>
Aproximadamente 5MB de memória não pode ser usada pelo sistema devido ao
kernel utilizá-la.
</sect1>

<sect1>Definir a hora (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
Isto irá definir a hora do sistema e de hardware para MM/DD hh:mm, CCYY.
Horas são exibidas em tempo local mas a hora de hardware usa UTC.

<sect1>Definir a hora (NTP)
<p>
Referência : <url id="&time-howto;" name="HOWTO Gerenciando Data e Hora precisos">.
<p>
<sect2>Definir a hora com conexão Internet permanente
<p>
Ajustar o relógio do sistema para a hora correta automaticamente através
de um servidor remoto :
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>servidor</var>
</example>
É bom ter esse comando em <file>/etc/cron.daily/</file> caso seu sistema
possua uma conexão Internet permanente.

<sect2>Definir a hora com uma conexão Internet esporádica
<p>
Use o pacote <package>chrony</package>.
</sect1>

<sect1 id="setterm">Como controlar recursos de console como o protetor de
tela
<p>
Para desabilitar o protetor de tela, use os seguintes comandos.
<p>
No console Linux :
<example>
# setterm -powersave off
</example>
<p>
Inicie o console kon2 (kanji) com :
<example>
# kon -SaveTime 0
</example>
<p>
Executando o X :
<example>
# xset s off
 ou
# xset -dpms
 ou
# xscreensaver-command -prefs
</example>
Leia as páginas de manual correspondentes para controlar outros recursos de
console. Veja também a página de manual <manref name="stty" section="1">
para mudar e mostrar configurações de linha de terminal.
</sect1>

<sect1 id="getent">Procurar na base de dados administrativa
<p>
A Glibc oferece o <manref name="getent" section="1"> para procurar
entradas nas bases de dados administrativas, isto é, passwd, group,
hosts, services, protocols ou networks.
<example compact>
getent base_de_dados [chave ...]
</example>

<sect1>Desabilitar o som (beep)
<p>
Sempre é possível desconectar o alto-falante do PC. ;-) Para o shell Bash:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Mensagens de erro na tela do console
<p>
Para acabar com as mensagens de erro na tela, o primeiro lugar a
checar é <file>/etc/init.d/klogd</file>. Defina
<tt>KLOGD="-c <var>3</var>"</tt> nesse script e execute 
<tt>/etc/init.d/klogd restart</tt>. Um método alternativo é executar 
<tt>dmesg -n<var>3</var></tt>.
<p>
Aqui os níveis de erro significam :
<list compact>
<item>0: KERN_EMERG,   o sistema está inutilizável
<item>1: KERN_ALERT,   uma ação deve ser tomada imediatamente
<item>2: KERN_CRIT,    condições críticas
<item>3: KERN_ERR,     condições de erro
<item>4: KERN_WARNING, condições de aviso
<item>5: KERN_NOTICE,  normal mas em condições significantes
<item>6: KERN_INFO,    informativo
<item>7: KERN_DEBUG,   mensagens em nível de depuração
</list>
<p>
Caso uma mensagem de erro sem utilidade lhe incomode muito, considere
fazer um patch para o kernel trivial como o <file>shutup-abit-bp6</file>
(disponível no <url id="&examples;" name="subdiretório de exemplos">).
<p>
Outro lugar a olhar pode ser o <file>/etc/syslog.conf</file>; cheque-o
para ver se alguma mensagem é logada para um dispositivo console.
</sect1>

<sect1>Definir o console para o tipo correto
<p>
Telas de console em sistemas semelhantes a Unix são normalmente acessadas usando as
rotinas da biblioteca (n)curses. Estas fornecem ao usuário um método
independente de terminal para atualizar caracteres de tela com razoável
otimização. Consule <manref name="ncurses" section="3X"> e
<manref name="terminfo" section="5">.
<p>
Em um sistema &debian;, existem uma porção de entradas pré-definidas :
<example>
$ toe | less                  # todas as entradas
$ toe /etc/terminfo/ | less   # entradas reconfiguráveis pelo usuário
</example>
Exporte sua seleção como a variável de ambiente <tt>TERM</tt>.
<p>
Caso a entrada terminfo para o <prgn>xterm</prgn> não funcione com um
<prgn>xterm</prgn> não-Debian,
mude seu tipo de terminal de "xterm" para uma das versões limitadas em
recursos como "xterm-r6" quando você logar em um sistema Debian
remotamente. Consulte <file>&f-libncurse;</file> para maiores informações.
"dumb" é o menor denominador comum para terminfo.
</sect1>

<sect1>Voltar o console ao estador normal
<p>
Quando a tela fica cheia de caracteres estranhos depois de um comando
<tt>cat <var>algum-arquivo-binário</var></tt> (você pode não ser capaz
de ver o comando digitado enquanto você digita) :
<example>
$ reset
</example>
</sect1>

<sect1>Converter um arquivo texto DOS para o estilo Unix
<p>
Converter um arquivo texto DOS (fim-de-linha = <tt>^M^J</tt>) para um
arquivo texto Unix (fim-de-linha = <tt>^J</tt>).
<example>
# apt-get install sysutils
$ dos2unix <var>arquivo_dos</var>
</example>
</sect1>

<sect1 id="perl-i">Substituição de expressões regulares
<p>
Substituir todas as instâncias de <var>DE_REGEX</var> por
<var>PARA_TEXTO</var> em todos os arquivos <var>ARQUIVOS</var> ...:
<example>
$ perl -i -p -e 's/<var>DE_REGEX</var>/<var>PARA_TEXTO</var>/g;' <var>ARQUIVOS</var> ...
</example>
<tt>-i</tt> é para edição "in-place", <tt>-p</tt> é para "loop implícito
sobre <var>ARQUIVOS</var> ...". Caso a substituição seja complexa, você
pode tornar a recuperação de erros mais fácil usando o parâmetro
<tt>-i.bak</tt> ao invés de <tt>-i</tt>; isso irá manter cada arquivo
original, adicionando <tt>.bak</tt> como uma extensão de arquivo.
</sect1>

<sect1>Editar arquivo no local usando um script
<p>
O script seguinte removerá as linhas 5&ndash;10 e linhas 16&ndash;20 no local.
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
Aqui, os comandos do <prgn>ed</prgn> são os mesmos comandos do 
command-mode do <prgn>vi</prgn>. Editar por trás do arquivo facilita a
criação do script.
</sect1>

<sect1>Extrair diferenças e juntar atualizações para os arquivos fonte
<p>
Seguir um desses procedimentos extrairá as diferenças entre dois arquivos
fontes e criará arquivos diff unificados <var>arquivo.patch0</var> ou
<var>arquivo.patch1</var> dependendo da localização dos arquivos:
<example>
$ diff -u <var>arquivo.antigo</var> <var>arquivo.novo1</var> &gt; <var>arquivo.patch0</var>
$ diff -u <var>antigo/arquivo</var> <var>novo1/arquivo</var> &gt; <var>arquivo.patch1</var>
</example>
O arquivo diff (alternativamente chamado de arquivo patch) é usado para
enviar atualizações de programas. O receptor aplicará esta
atualização em outro <var>arquivo</var> usando :
<example>
$ patch -p0 <var>arquivo</var> &lt; <var>arquivo.patch0</var>
$ patch -p1 <var>arquivo</var> &lt; <var>arquivo.patch1</var>
</example>
Caso você possua três versões do código-fonte, você pode juntá-las
mais efetivamente usando o <prgn>diff3</prgn>:
<example>
$ diff3 -m <var>meu.arquivo</var> <var>arquivo.antigo</var> <var>seu.arquivo</var> &gt; <var>arquivo</var>
</example>
</sect1>

<sect1>Converter um arquivo grande em arquivos pequenos
<p>
<example>
$ split -b 650m <var>arquivo</var>   # divide o arquivo em pedaços de 650MB
$ cat x* &gt;<var>arquivogrande</var>   # junta arquivos em 1 grande arquivo
</example>
</sect1>

<sect1>Extrair dados de uma tabela em arquivo texto
<p>
Vamos considerar um arquivo texto chamado <file>DPL</file> em que os nomes
de todos os líderes anteriores do projeto &debian; e seus dias de iniciação
são listados em um formato separado por espaços.
<example>
Ian     Murdock   Agosto  1993
Bruce   Perens    Abril   1996
Ian     Jackson   Janeiro 1998
Wichert Akkerman  Janeiro 1999
Ben     Collins   Abril   2001
Bdale   Garbee    Abril   2002
Martin  Michlmayr Março   2003
</example>
O Awk é usado freqüentemente para extrair dados desses tipos de arquivo.
<example>
$ awk '{ print $3 }' &lt;DPL                   # mês de início
Agosto
Abril
Janeiro
Janeiro
Abril
Abril
Março
$ awk '($1=="Ian") { print }' &lt;DPL          # DPL chamado Ian
Ian     Murdock   Agosto  1993
Ian     Jackson   Janeiro 1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # Quando Perens começou
Abril 1996
</example>
<p>
Shells como o Bash também podem ser usados para interpretar esse tipo de
arquivo:
<example>
$ while read primeiro ultimo mes ano; do
    echo $mes
  done &lt;DPL
... mesma saída do primeiro exemplo Awk
</example>
Aqui, o comando interno (built-in) <prgn>read</prgn> usa os caracteres em
$IFS (internal field separators) (separadores de campos internos) para
dividir as linhas em palavras.
<p>
Se mudar IFS para ":", você pode interpretar o <file>/etc/passwd</file> com
shell facilmente:
<example>
$ oldIFS="$IFS"   # salva o valor antigo
$ IFS=":"
$ while read usuario senha uid gid resto_da_linha; do
    if [ "$usuario" = "osamu" ]; then
      echo "O ID de $usuario é $uid"
    fi
  done < /etc/passwd
O ID de osamu é 1001
$ IFS="$oldIFS"  # restaura o valor antigo
</example>
(Se o Awk for usado para fazer o mesmo, use <tt>FS=":"</tt> para definir o
separador de campos.)
<p>
IFS também é usado pelo shell para dividir resultados de expansão de
parâmetros, substituição de comandos, e expansão aritmética. Esses não
ocorrem em palavras com aspas duplas ou simples (double or single quoted
words). O valor padrão de IFS é &lt;espaço&gt;, &lt;tab&gt; e
&lt;nova_linha&gt; combinados.
<p>
Tenha cuidado ao usar esses truques do IFS do shell.
Coisas estranhas podem acontecer, quando o shell interpreta algumas partes
do script como sua <strong>entrada</strong>.
<example>
$ IFS=":,"                        # usa ":" e "," como IFS
$ echo IFS=$IFS,   IFS="$IFS"     # echo é um comando interno (built-in) do Bash
IFS=  , IFS=:,
$ date -R                         # apenas uma saída de comando
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # sub shell --&gt; entrada para shell principal
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # redefine IFS para o padrão
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>
</sect1>


<sect1 id="scrp-snip">Pequenos scripts para ligar comandos
<p>
Os scripts a seguir farão coisas legais como parte de um pipe.
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # encontra todos os arquivo em /usr excluindo alguns arquivos
xargs -n 1 <var>comando</var>   # executa o comando para todos os itens de stdin
xargs -n 1 echo |    # divide itens separados-por-espaços-em-branco em linhas
xargs echo      |    # mescla todas as linhas em uma linha
grep -e <var>padrão</var>|      # extrai linhas contendo <var>padrão</var>
cut -d: -f3 -|       
        # extrai o terceiro campo separado por : (arquivo passwd etc.) 
awk '{ print $3 }' | # extrai o terceiro campo separado por espaços
awk -F'\t' '{ print $3 }' |
        # extrai terceiro campo separado por tab
col -bx |            # remove backspace e expande tabs para espaços
expand -|            # expande tabs
sort -u|             # ordena e remove duplicados

tr '\n' ' '|         # concatena linhas em uma linha
tr '\r' ''|          # remove CR
tr 'A-Z' 'a-z'|      # converte maiúsculas em minúsculas
sed 's/^/# /'|       # torna cada linha um comentário
sed 's/\<var>.ext</var>//g'|    # remove <var>.ext</var>
sed  -n -e 2p|       # imprime a segunda linha 
head -n 2 -|         # imprime as primeiras 2 linhas
tail -n 2 -|         # imprime as últimas 2 linhas
</example>
</sect1>

<sect1>Pequenos scripts para fazer loop para cada arquivo
<p>
As seguintes maneiras de fazer loop para cada arquivo do tipo
<tt>*.<var>ext</var></tt> asseguram a manipulação apropriada de nomes de
arquivos engraçados como aqueles com espaços e executam processo
equivalente:
<list>
<item>Loop Shell:
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>comando</var> "$<var>x</var>"
  fi
done
</example>
<item>Combinação de <prgn>find</prgn> e <prgn>xargs</prgn>:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>comando</var>
</example>
<item><prgn>find</prgn> com a opção <tt>-exec</tt> com um comando:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>comando</var> '{}' \;
</example>
<item><prgn>find</prgn> com a opção <tt>-exec</tt> com um script shell curto:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>comando</var> '{}' && echo 'successful'" \;
</example>
</list>
</sect1>

<sect1 id="perl-mad">Loucura de script Perl curto
<p>
Apesar de quaisquer scripts Awk poderem ser reescritos em Perl usando
<manref name="a2p" section="1">, scripts Awk de uma linha são melhor
convertidos para scripts perl de uma linha manualmente. Por exemplo
<example>
awk '($2=="1957") { print $3 }' |
</example>
é equivalente a qualquer uma das seguintes linhas:
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
Como todos os espaços nos argumentos para o <prgn>perl</prgn> na linha acima podem
ser removidos, e tomando vantagem das conversões automáticas entre
números e strings no Perl:
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
Veja <manref name="perlrun" section="1"> para detalhes sobre opções de
linha de comando. Se quiser mais scripts Perl loucos, <url
id="&perlgolf;"> pode ser interessante.
</sect1>

<sect1>Obter texto ou arquivo de lista de discussão de uma página web
<p>
O comando a seguir irá ler uma página web em um arquivo texto.
Muito útil quando copiando configurações da Web.
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>arquivotexto</var>
</example>
O <prgn>links</prgn> e o <prgn>w3m</prgn> podem ser usados aqui também,
com pequenas diferenças na renderização.
<p>
Caso esteja lidando com um arquivo de lista de discussão, use o
<prgn>munpack</prgn> para obter conteúdos mime do texto.
</sect1>

<sect1>Imprimir de forma bonita uma página web
<p>
O comando a seguir irá imprimir uma página Web em um arquivo/impressora
Postscript :
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Consulte <ref id="lprlpd">.  Confira também os pacotes <prgn>a2ps</prgn> e
<prgn>mpage</prgn> para criar arquivos Postscript.
</sect1>

<sect1>Imprimir de forma bonita uma página de manual
<p>
O comando a seguir irá imprimir uma página de manual em um
arquivo/impressora Postscript :
<example>
$ man -Tps <var>alguma-página-de-manual</var> | lpr
$ man -Tps <var>alguma-página-de-manual</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Juntar dois arquivos PostScript ou PDF
<p>
Você pode juntar arquivos PostScript ou PDF.
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>
 
<sect1>Contar o tempo de um comando
<p>
Exibir o tempo usado por um processo.
<example>
# time <var>algum-comando</var> &gt;/dev/null
real    0m0.035s       # tempo no relógio de parede (tempo real decorrido)
user    0m0.000s       # tempo em modo de usuário
sys     0m0.020s       # tempo em modo kernel
</example>
</sect1>

<sect1>Comando <prgn>nice</prgn>
<p>
Use o <prgn>nice</prgn> (do pacote GNU <package>shellutils</package>) para
definir um valor de nice de um comando quando iniciá-lo. O
<prgn>renice</prgn> (<package>bsdutils</package>) ou o <prgn>top</prgn>
podem fazer o renice de um processo. Um valor nice de 19 representa o
processo mais lento (a menor prioridade); valores negativos são
"não-nice", com -20 sendo um processo bem rápido (alta prioridade).
Somente o superusuário pode definir valores de nice negativos.
<example>
# nice  -19 <var>top</var>                                         # muito "nice"
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # muito rápido
</example>
Algumas vezes um valor de nice extremo traz mais problemas do que
melhorias para o sistema. Use esse comando com cuidado.
</sect1>

<sect1 id="cronjob">Agendar atividade (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Use o <prgn>cron</prgn> e o <prgn>at</prgn> para agendar tarefas sob o
Linux. Consulte <manref name="at" section="1">,
<manref name="crontab" section="5"> e <manref name="crontab" section="8">.
<p> 
Execute o comando <tt>crontab -e</tt> para criar ou editar um arquivo
crontab para configurar eventos regularmente agendados. Exemplo de um
arquivo crontab :
<example>
# use /bin/sh para executar comandos, não importando o que o /etc/passwd diga
SHELL=/bin/sh
# envie por mail qualquer saída para `paul', não importando de quem seja esse crontab
MAILTO=paul
# Min Hora DiaDoMês Mês DiaDaSemana comando (Dia... são OU)
# executa às 00:05, todos os dias
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# executa às 14:15 no primeiro dia de cada mês -- saída enviada para paul
15 14 1  * *   $HOME/bin/monthly
# executa às 22:00 em dias de semana(1-5), saída para Joe. &percnt; para nova linha, último &percnt; para cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Onde estão suas crianças?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "executa 23 minutos depois de 0am, 2am, 4am ..., em 1 de Fevereiro"
5  4 *   * sun echo "executa às 04:05 todo domingo"
# executa às 03:40 na primeira Segunda-feira de cada mês
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && comando -argumentos
</example>
Execute o comando <prgn>at</prgn> para agendar uma atividade a ser executada
apenas uma vez :
<example>
$ echo '<var>comando -argumentos</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Mudança de console com <prgn>screen</prgn>
<p>
O programa <prgn>screen</prgn> lhe permite executar
<strong>múltiplos</strong> terminais virtuais, cada um com seu próprio
shell interativo, em um <strong>único</strong> terminal físico ou janela
de emulação de terminal. Mesmo caso você use consoles virtuais Linux ou
múltiplas janelas xterm, vale a pena explorar o <prgn>screen</prgn> devido
a seu abundante <strong>conjunto de recursos</strong>, os quais incluem
<list compact>
<item>histórico scrollback, 
<item>copiar-e-colar, 
<item>logging de saída, 
<item>entrada dígrafo e 
<item>a habilidade de <strong>separar</strong> uma sessão
<prgn>screen</prgn> inteira de seu terminal e anexá-la posteriormente.
</list>

<sect2>Cenários de acesso remoto
<p>
Caso você freqüentemente logue em uma máquina Linux de um terminal remoto
ou usando um programa de terminal VT100, o <prgn>screen</prgn> irá tornar
sua vida mais fácil com o recurso de <strong>detach</strong>.
<p>
<enumlist compact>
<item>Você está
logado através de uma conexão discada e está executando uma sessão 
<prgn>screen</prgn> complexa com editores e outros programas abertos em
diversas janelas.
<item>Em certo momento você precisa deixar seu terminal, mas você não
quer perder seu trabalho desconectando.
<item>Simplesmente digite <tt>^A d</tt> para <strong>separar</strong> a
sessão e então faça o logout. (Ou, ainda mais rápido, digite
<tt>^A DD</tt> para fazer com que o <prgn>screen</prgn> separe e faça o
logout dele mesmo.) 
<item>Quando você logar novamente posteriormente, digite o comando
<tt>screen -r</tt> e o <prgn>screen</prgn> irá magicamente
<strong>anexar</strong> todas as janelas que você deixou abertas. 
</enumlist>

<sect2>Comandos <prgn>screen</prgn> típicos
<p>
Uma vez que você inicia o <prgn>screen</prgn>, toda a entrada de teclado é
enviada para sua janela atual exceto as teclas de comando, por padrão
<tt>^A</tt>. Todos os comandos <prgn>screen</prgn> são informados
digitando <tt>^A</tt> mais uma única tecla [mais quaisquer parâmetros]. 
Comandos úteis :
<example>
^A ?     exibe uma tela de ajuda (exibe os mapeamentos de teclas)
^A c     cria uma nova janela e muda para ela
^A n     vai para a próxima janela
^A p     vai para a janela anterior
^A <var>0</var>     vai para a janela número <var>0</var>
^A w     exibe uma lista de janelas
^A a     envia um Ctrl-A para a janale atual como entrada de teclado
^A h     grava uma cópia "hard" da janela atual para arquivo 
^A H     inicia/finaliza log da janela atual para arquivo
^A ^X    trava o terminal (protegido por senha)
^A d     separa sessão screen do terminal
^A DD    separa a sessão screen e faz um logout
</example>
Isto é somente um pequeno subconjunto dos comandos e recursos do
<prgn>screen</prgn>. Caso exista alguma coisa que você queira que o
<prgn>screen</prgn> seja capaz de fazer, as chances são que que possa
fazê-lo ! Consulte <manref name="screen" section="1"> para maiores
detalhes.

<sect2>Backspace e/ou Ctrl-H em sessão <prgn>screen</prgn>
<p>
Se você achar que o backspace e/ou o Ctrl-H não funcionam corretamente
quando você está executando o <prgn>screen</prgn>, edite
<file>/etc/screenrc</file>, encontre a linha contendo
<example compact>
bindkey -k kb stuff "\177"
</example>
e comente-a (ou seja, adicione "#" como o primeiro caracter). 

<sect2>Programa equivalente ao <prgn>screen</prgn> para X
<p>
Confira o <prgn>xmove</prgn>.  Consulte <manref name="xmove" section="1">.

</sect1>

<sect1 id="net-test">Testes de rede básicos
<p>
Instale os pacotes
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (para kernel 2.2),
<package>iptables</package> (para kernel 2.4) e
<package>net-tools</package> e :
<example>
$ ping <var>yahoo.com</var>            # checa a conexão Internet
$ traceroute <var>yahoo.com</var>      # rastrea pacotes IP
$ ifconfig                  # checa configuração do host
$ route -n                  # checa configuração de roteamento
$ dig <var>[@servidor-dns.com] host.domínio [{a|mx|any}]</var> |less
      # checa os registros DNS de <var>host.domínio</var> usando <var>servidor-dns.com</var> 
      # para um registro a <var>{mx|any}</var>
$ ipchains  -L -n |less     # checa o filtro de pacotes (kernel 2.2)
$ iptables -L -n |less      # checa o filtro de pacotes (kernel 2.4)
$ netstat -a                # encontra todas as portas abertas
$ netstat -l --inet         # encontra as portas em escuta
$ netstat -ln --tcp         # encontra todas as portas TCP em escuta (numérico)
</example>
</sect1>

<sect1 id="flush-mail">Fazer flush em mensagens do spool local
<p>
Para fazer um flush das mensagens do spool local :
<example>
# exim -q    # faz flush em mensagens aguardando
# exim -qf   # faz flush em todas as mensagens
# exim -qff  # faz flush até mesmo em mensagens congeladas
</example>
<tt>-qff</tt> pode ser melhor como uma opção no script
<file>/etc/ppp/ip-up.d/exim</file>.
</sect1>

<sect1 id="remove-mail">Remover mensagens congeladas do spool local
<p>
Para remover mensagens congeladas do spool local com uma mensagem de erro
de entrega :
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Reentregar conteúdo mbox
<p>
Você precisa entregar manualmente mensagens para caixas de mensagens
ordenadas em seu diretório home a partir de
<file>/var/mail/<var>username</var></file> caso seu diretório home fique
lotado e o procmail falhe. Depois de liberar espaço em disco no diretório
home, execute :
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>nomedeusuário</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>Limpar conteúdo de arquivo
<p>
Para limpar o conteúdo de um arquivo como um arquivo de log, não use o
<tt>rm</tt> para apagar o arquivo e então criar um novo arquivo vazio
porque o arquivo pode estar sendo acessado no intervalo entre os comandos.
O comando a seguir é uma maneira mais segura de limpar o conteúdo de um
arquivo :
<example>
$ :&gt;<var>arquivo-a-ser-limpo</var>
</example>
</sect1>

<sect1 id="dummyfile">Arquivos Falsos
<p>
Os comandos a seguir criarão arquivos falsos ou vazios :
<example>
$ dd if=/dev/zero    of=<var>nomedearquivo</var> bs=1k count=5 # 5KB de conteúdo zero
$ dd if=/dev/urandom of=<var>nomedearquivo</var> bs=1m count=7 # 7MB de conteúdo randômico
$ touch <var>nomedearquivo</var> #  cria arquivo de 0B (caso o arquivo exista, atualiza seu mtime)
</example>
Por exemplo, os seguintes comandos executados a partir do shell do disco
de inicialização do &debian; apagarão todo o conteúdo do disco rígido
<file>/dev/hda</file> completamente para muitos usos práticos.
<example>
# dd if=/dev/urandom of=/dev/hda ; dd if=/dev/zero of=/dev/hda
</example>

</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- atualizado usando a idéia de Colin Walters walters@debian.org -->
<p>
O programa <prgn>chroot</prgn>, <manref name="chroot" section="8">, nos
possibilita executar diferentes instâncias do ambiente GNU/Linux em um
único sistema simultaneamente sem reiniciar.
<p>
Pode-se também executar um programa que exija muitos recursos como o
<prgn>apt-get</prgn> ou o <prgn>dselect</prgn> sob o chroot de uma
máquina host rápida enquanto montando por NFS uma máquina satélite lenta
no host como leitura/escrita e o ponto de chroot sendo o ponto de
montagem da máquina satélite.

<sect2 id="chroot-debian">Executar um sabor diferente do &debian; com <prgn>chroot</prgn>
<p>
Um ambiente &debian; chroot pode ser criado facilmente pelo comando
<prgn>debootstrap</prgn> no Woody. Por exemplo, para criar um chroot Sid
em <var>/sid-root</var> tendo acesso rápido à Internet:
<example>
main # cd / ; mkdir <var>/sid-root</var>
main # debootstrap sid <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... assista-o baixar o sistema inteiro
main # echo "proc-sid <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount proc-sid <var>/sid-root</var>/proc -t proc
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # apt-setup # configure /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # aponte a fonte para unstable
chroot # dselect  # você pode usar aptitude, instalar o mc e o vim :-)
</example>
<p>
Nesse ponto você deve ter um sistema &debian; completamente funcional,
onde pode mexer sem medo de afetar sua instalação &debian; principal.
<p>
Esse truque do <prgn>debootstrap</prgn> também pode ser usado para
instalar o &debian; em um sistema sem usar o disco de instalação do
&debian;, mas usando um de outra distribuição GNU/Linux. Veja <url
id="&setup-chroot;">.

<sect2 id="chroot-console">Configurando o login para <prgn>chroot</prgn>
<p>
Digitar <tt>chroot <var>/sid-root</var> /bin/bash</tt> é fácil, mas isso
mantém todos os tipos de variáveis de ambiente atribuídas que você pode
não desejar, e tem outros problemas. Uma maneira muito melhor é executar
outro processo de login em um terminal virtual separado onde você pode
logar no chroot diretamente.
<p>
Como em sistemas &debian; padrões, do <tt>tty1</tt> ao <tt>tty6</tt> são
executados consoles Linux e no <tt>tty7</tt> é executado o Sistema X
Window, vamos definir o <tt>tty8</tt> para um console chroot'ado como um
exemplo. Depois de criar o sistema chroot como descrito em <ref
id="chroot-debian">, digite a partir do shell root do sistema principal:
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8"  >> /etc/inittab
main # init q    # recarrega o init
</example>

<sect2 id="chroot-x">Configurando o X para o <prgn>chroot</prgn>
<p>
Você quer executar o X e o GNOME mais novos seguramente em seu chroot?
Isso é perfeitamente possível! O exemplo seguinte fará o GDM executar em
um terminal virtual <tt>vt9</tt>.
<p>
Primeiro instale um sistema chroot usando o método descrito em <ref
id="chroot-debian">. A partir do root do sistema principal, copie os
arquivos de configuração chaves para o sistema chroot.
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # ou use console chroot
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # faça s/vt7/vt9/ na seção [servers]
chroot # /etc/init.d/gdm start
</example>
Aqui, o arquivo <file>/etc/gdm/gdm.conf</file> foi editado para alterar
o primeiro console virtual do <tt>vt7</tt> para o <tt>vt9</tt>.
<p>
Agora você pode alternar facilmente entre os ambientes X completos no
sistema chroot e em seu sistema principal apenas alternando entre
terminais virtuais Linux; por exemplo usando Ctrl-Alt-F7 e Ctrl-Alt-F9.
Divirta-se!
<p>
[FIXME] Adicionar um comentário e ligar ao script init do ambiente gdm
chroot'ado.

<sect2 id="chroot-dist">Executar outras distribuições com <prgn>chroot</prgn>
<p>
Um ambiente chroot de outra distribuição pode ser criado facilmente.
Você instala um sistema em partições separadas usando o instalador da
outra distribuição. Se a partição raiz dela estiver em
<file><var>/dev/hda9</var></file>.
<example>
main # cd / ; mkdir <var>/outra-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/outra-dist</var>
main # chroot <var>/outra-dist</var> /bin/bash
</example>
Então proceda como em <ref id="chroot-debian">, <ref
id="chroot-console">, e <ref id="chroot-x">.
 
<sect2 id="chroot-build">Construir um pacote com o <prgn>chroot</prgn>
<p>
Existe um pacote chroot mais especializado, o
<package>pbuilder</package>, que constrói um sistema chroot e compila um
pacote dentro do chroot. Esse é um sistema ideal para ser usado para
checar se as dependências de compilação de um pacote estão corretas, e
para se certificar que dependências de compilação desnecessárias ou
incorretas não existirão no pacote gerado.
</sect1>

<sect1>Como checar ligações diretas (hard)
<p>
Você pode checar se dois arquivos são o mesmo arquivo com duas ligações
diretas (hard links) usando :
<example> 
$ ls -li <var>arquivo1</var> <var>arquivo2</var>
</example>
 
<sect1>Usar <prgn>mount</prgn> em um arquivo de uma imagem de disco rígido
<p>
Se <file><var>arquivo.img</var></file> contém uma imagem de um disco
rígido e o disco rígido original possuía uma configuração de disco que
tinha <var>xxxx</var> = (bytes/setor) * (setores/cilindro),
então o comando a seguir irá montá-lo em <file>/mnt</file>:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>arquivo.img</var> /mnt
</example>
Note que a maioria dos discos rígidos possui 512 bytes/setor.

<sect1 id="smbmount">Samba
<p>
O básico para obter arquivos do Windows:
<example>
# mount -t smbfs -o <var>username=meunome,uid=my_uid,gid=my_gid</var> \
        <var>//servidor/compartilhamento /mnt/smb</var>  # monta arquivos Windows para o Linux
# smbmount <var>//servidor/compartilhamento /mnt/smb</var> \
        -o "<var>username=meunome,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # lista os compartilhamentos em um computador
</example>
<p>
Vizinhos Samba podem ser checados a partir do Linux usando:
<example>
# smbclient -N -L <var>endereço_IP_de_seu_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>Utilitários para sistemas de arquivos não nativos
<p>
Muitos sistemas de arquivo não nativos têm suporte no kernel
Linux, então podemos acessá-los simplesmente montando dispositivos que contêm
o sistema de arquivos. Para alguns sistemas de arquivos, há também algumas
ferramentas especializadas para acessar os sistemas de arquivos sem montar
os dispositivos. Isso é feito com programas de espaço de usuário, de
forma que não é necessário suporte para o sistema de arquivos no kernel.
<list compact>
<item><package>mtools</package>: para sistema de arquivo MSDOS (MS-DOS, Windows)
<item><package>cpmtools</package>: para sistema de arquivo CP-M 
<item><package>hfsutils</package>: para sistema de arquivo HFS (Macintosh nativo)
<item><package>hfsplus</package>: para sistema de arquivo HFS+ (Macintosh moderno)
</list>
Para criar e verificar sistema de arquivos MS-DOS FAT, o pacote
<package>dosfstools</package> é útil.
</sect1>

</sect>

<sect id="oops">Erros típicos a serem notados
<p>
Aqui há alguns exemplos de ações perigosas. Os impactos negativos serão
aumentados se você estiver usando a conta privilegiada: <tt>root</tt>.

<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>
<!-- 
I know using quotes here are irregular but it is hard to read without it. 
-->
Em "<tt>rm -rf .*</tt>", "<tt>.*</tt>" expande para incluir "<tt>.</tt>" e
"<tt>..</tt>", e se você tiver privilégios de escrita no diretório pai então
você acabará removendo também todos os diretórios <strong>próximos</strong>
ao seu diretório atual.
<p>
<list compact>
<item>"<tt>rm -rf .</tt>" : remove tudo sob o diretório atual e o próprio
diretório atual.
<item>"<tt>rm -rf *</tt>" : remove todos os arquivos sem ponto e todos os
diretórios sem ponto sob o diretório atual
<item>"<tt>rm -rf .[^.]*</tt>" : remove todos os arquivos com ponto e todos
os diretórios com ponto sob o diretório atual.
<item>"<tt>rm -rf .*</tt>" : remove tudo sob o diretório pai e o próprio
diretório pai.
</list>

<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
A perda de alguns arquivos importantes como <file>/etc/passwd</file> por
estupidez é ruim. O sistema &debian; faz cópias de segurança deles
regularmente em <file>/var/backups</file>. Quando você tiver que restaurar
esses arquivos, você pode ter que ajustar as permissões apropriadas
manualmente.
<example>
# cp /var/backups/passwd /etc/passwd
# chmod 644 /etc/passwd
</example>
Veja também <ref id="recover-status">.

</chapt>

