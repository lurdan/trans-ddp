<!-- CVS revision of this document "$Revision: 1.2 $"  -->
<!-- CVS revision of original english document "1.18"  -->

<chapt id="gnupg">GnuPG

<p>
参考资源：
<list compact>
<item><manref name="gpg" section="1">. 
<item><file>&dochome;gnupg/README.gz</file>
<item><em>GNU privacy handbook</em> in 
 <file>&dochome;gnupg-doc/GNU_Privacy_Handbook/</file> 
 (install <package>gnupg-doc</package> package)
</list>

<sect>安装GnuPG
<p>
<example>
# gpg --gen-key                   # 生成新key
# gpg --gen-revoke <var>my_user_ID</var>     # generate revoke key for <var>my_user_ID</var>
# host -l pgp.net | grep www|less # 查找pgp keyservers
</example>
目前，好的keyservers有：
<example>
keyserver wwwkeys.eu.pgp.net
keyserver wwwkeys.pgp.net
</example>
必须注意<strong>不能创建2个以上的sub-keys</strong>，如果这样做了，pgp.net上的keyservers会<strong>废除</strong>（corrupt）你的key。使用新版的<package>gnupg</package>（>1.2.1-2）来处理这些废subkeys。参阅<url id="&gpg-subkeys;">。
<p>
同样，在<file>$HOME/.gnupg/options</file>中只能指定一个keyserver。
<p>
所以下面的配置将无法工作：
<example>
keyserver search.keyserver.net
keyserver pgp.ai.mit.edu
</example>

</sect>

<sect>使用GnuPG
<p>
文件处理：
<example>
$ gpg  [options]  <var>command  [args]</var>
$ gpg {--armor|-a} {--sign|-s} <var>file</var> # sign file into a text <var>file</var>.asc
$ gpg --clearsign <var>file</var>              # clear-sign message
$ gpg --clearsign --not-dash-escaped <var>patchfile</var>  # clear-sign patchfile
$ gpg --verify <var>file</var>                 # verify clear-signed <var>file</var>
$ gpg -o <var>file.sig</var> {-b|--detach-sig} <var>file</var> # create detached signature
$ gpg --verify <var>file.sig</var> <var>file</var>        # verify <var>file</var> with <var>file.sig</var>
$ gpg -o <var>crypt_file</var> {--recipient|-r} <var>name</var> {--encrypt|-e} <var>file</var> 
        # public-key encryption intended for name
$ gpg -o <var>crypt_file</var> {--symmetric|-c} <var>file</var> # 对称加密
$ gpg -o <var>file</var> --decrypt crypt_file  # 解密
</example>
</sect>

<sect>管理GnuPG
<p>
Key管理：
<example>
$ gpg --edit-key <var>user_ID</var>               # "help"获得帮助，交互式
$ gpg -o <var>file</var> --exports                # 将所有keys导出到<var>file</var> 
$ gpg --imports <var>file</var>                   # 从<var>file</var>导出所有keys
$ gpg --send-keys <var>user_ID</var>              # 将<var>user_ID</var>发送给keyserver
$ gpg --recv-keys <var>user_ID</var>              # 从keyserver接收<var>user_ID</var>的key
$ gpg --list-keys <var>user_ID</var>              # 列出<var>user_ID</var>的key
$ gpg --list-sigs <var>user_ID</var>              # 列出<var>user_ID</var>的sig.
$ gpg --check-sigs <var>user_ID</var>             # 检查<var>user_ID</var>的sig.
$ gpg --fingerprint <var>user_ID</var>            # 检查<var>user_ID</var>的fingerprint
$ gpg --list-sigs | grep '^sig' | grep '[User id not found]' \
  | awk '{print $2}' | sort -u | xargs gpg --recv-keys # get unknown keys
  # 更新所有未知sigs.
</example>
Trust代码：
<example>
-         没指定任何ownertrust/还没进行计算。
e         Trust计算失败。
q         没有足够的信息进行计算。
n         该key不可信。
m         最低限度的可信。
f         完全可信。
u         绝对可信。
</example>
下面的操作将我的key“<var>A8061F32</var>”上载到多路keyserver：
<example>
$ for xx in us es cz de dk uk ch net.uk earth.net.uk; \
$ do gpg --keyserver wwwkeys.$xx.pgp.net  --send-keys <var>A8061F32</var>; done
</example>
</sect>

<sect>在应用程序中使用GnuPG
<p>
<sect1>在Mutt中使用GnuPG
<p>
在<file>~/.muttrc</file>中加入下列内容，将会自动启动一个低速的GnuPG，在index菜单输入`<tt>S</tt>'即可使用它。
<example>
macro index S ":toggle pgp_verify_sig\n"
set pgp_verify_sig=no
</example>

<sect1 id="vimgpg">在Vim中使用GnuPG
<p>
将<url id="&examples;"
name="examples subdirectory">下的<file>vimgpg</file>文件的内容加入到<file>~/.vimrc</file>就可以运行GnuPG了。

</chapt>
