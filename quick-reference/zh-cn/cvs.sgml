<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.41"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="vcs">系统版本控制

<sect id="cvs">并行版本系统 (CVS)
<p>
有关的详细信息可使用 <prgn>lynx</prgn> 查阅
<file>/usr/share/doc/cvs/html-cvsclient</file>、<file>/usr/share/doc/cvs/html-info</file>、<file>/usr/share/doc/cvsbook</file>
或执行
<tt>info cvs</tt> 及 <tt>man cvs</tt>。

<sect1 id="cvs-inst">安装 CVS 服务器
<p>
以下步骤配置的服务器，仅允许“src”用户组的成员访问 CVS 仓库，并且仅“staff”用户组的成员才可管理 CVS，这样做可以降低管理者不小心犯错的机率。
<example>
# cd <var>/var/lib</var>; umask 002 ; sudo mkdir <var>cvs</var> # [Woody] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=<var>/var/lib/cvs</var>
# cd $CVSROOT
# chown root:src .  # 设置为"staff"可加强对新建项目行为的限制
# chmod 3775 .             # 如果上面的赋值为"staff"，则使用 2775
# cvs -d <var>/var/lib/cvs</var> init # 在此明确地指定 -d 更安全
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect1>

<sect1 id="cvs-examples">CVS 会话例子
<p>
下面我们来设置 shell 环境以便访问 CVS 仓库。

<sect2>匿名 CVS（仅用于下载）
<p>
只读远程访问：
<example>
$ export CVSROOT=:pserver:<var>anonymous@cvs.sf.net:/cvsroot/qref</var>
$ cvs login
$ cvs -z3 co <var>qref</var>
</example>
</sect2>

<sect2>使用本地 CVS 服务器
<p>
通过同一台机器上的 shell 进行本地访问：
<example>
$ export CVSROOT=<var>/var/lib/cvs</var>
</example>
</sect2>

<sect2>使用远程 CVS pserver
<p>
非 SSH（在 <prgn>cvs</prgn> 中使用 RSH 协议）远程访问：
<example>
$ export CVSROOT=:pserver:<var>account@cvs.foobar.com:/var/lib/cvs</var>
$ cvs login
</example>
易受窍听攻击。
</sect2>

<sect2>通过 <prgn>ssh</prgn> 使用远程 CVS
<p>
通过 SSH 进行远程访问：
<example>
$ export CVSROOT=:ext:<var>account@cvs.foobar.com:/var/lib/cvs</var>
</example>
或连接 SourceForge：
<example>
$ export CVSROOT=:ext:<var>account@cvs.sf.net:/cvsroot/qref</var>
</example>
亦可使用 RSA 认证（<ref id="ssh-rsa">），它不需要密码提示。
</sect2>

<sect2>新建 CVS 档案
<p>
要建立如下的档案，
<example>
ITEM              VALUE                    MEANING
source tree:      ~/<var>project-x</var>              All source codes
Project name:     <var>project-x</var>                Name for this project
Vendor Tag:       <var>Main-branch</var>              Tag for the entire branch
Release Tag:      <var>Release-original</var>         Tag for a specific release
</example>
则，
<example>
$ cd ~/<var>project-x</var>                 # 进源码目录
 ... 创建源码树 ...
$ cvs import -m <var>"Start project-x" project-x Main-branch Release-initial</var>
$ cd ..; rm -R ~/<var>project-x</var>
</example>
</sect2>

<sect2>使用 CVS
<p>
使用本地 CVS 仓库来为 <var>project-x</var> 工作：
<example>
$ cd                            # 转到工作域
$ cvs co <var>project-x</var>              # 从 CVS 下载源码到本地
$ cd <var>project-x</var>
 ... 修改源码内容 ...
$ cvs diff -u                   # 相当于 diff -u repository/ local/
$ cvs up -C <var>modified_file</var>       # 撤消对文件的修改
$ cvs ci -m "<var>Describe change</var>"   # 保存本地源码到 CVS
$ vi <var>newfile_added</var>
$ cvs add <var>newfile_added</var>
$ cvs ci -m "<var>Added newfile_added</var>"
$ cvs up                        # 从 CVS 合并最新版本
 ... 生成所有在 CVS 里新创建的子目录，使用
 ... "cvs up -d -P" 代替 "cvs up"
 ... 注意以 "C <var>filename</var>" 开头的行，这表示在更新过程中，产生了冲突
 ... 未修改的本地代码文件被重命名为 `.#<var>filename</var>.version'.
 ... 在 <var>filename</var> 里面查找 "&lt;&lt;&lt;&lt;&lt;&lt;&lt;" 和 "&gt;&gt;&gt;&gt;&gt;&gt;&gt;"，可以找到发生冲突的地方
$ cvs tag <var>Release-1</var>             # 添加 release tag
 ... 进一步修改 ...
$ cvs tag -d <var>Release-1</var>          # 移除 release tag
$ cvs ci -m "<var>more comments</var>"
$ cvs tag <var>Release-1</var>             # 重新添加 release tag
$ cd                            # 返回工作域
$ cvs co -r <var>Release-initial</var> -d <var>old</var> <var>project-x</var>
 ... 得到原始版本到 <var>old</var> 目录
$ cd old
$ cvs tag -b <var>Release-initial-bugfixes</var> # 创建分支 (-b) 标签
 ... 现在可以在老版本工作 （Tag=sticky）
$ cvs update -d -P
 ... 源代码树现在有粘滞标签 "Release-initial-bugfixes"
 ... 在这个分支下工作
$ cvs up -d -P # 同步这个分支下其它人修改的文件
$ cvs ci -m "<var>check into this branch</var>"
$ cvs update -kk -A -d -P
 ... 删除粘滞标签，忽略从主干的更新，
 ... 不扩展关键字
$ cvs update -kk -j <var>Release-initial-bugfixes</var>
 ... 从 <var>Release-initial-bugfixes</var> 分支移植到主干，不扩展关键字 
 ... 使用编辑器修改冲突
$ cvs ci -m "<var>merge Release-initial-bugfixes</var>"
$ cd
$ tar -cvzf <var>old-project-x.tar.gz</var> <var>old</var>     # 产生文档， -j 选项生成 bz2 格式的压缩包
$ cvs release -d <var>old</var>               # 删除本地源码（可选）
</example>
应该记住的几个选项（用作 <prgn>cvs</prgn> 命令行的第一个参数）：
<example>
-n      虚拟运行，无实际效果
-t      显示 cvs 活动步骤的信息
</example>
</sect2>

<sect2>从 CVS 取文件
<p>
要从 CVS 获得最新版本，用“tomorrow”：
<example>
$ cvs ex -D tomorrow <var>module_name</var>
</example>
</sect2>

<sect2>管理 CVS
<p>
为项目添加别名（本地服务器）：
<example>
$ su - admin           # staff 用户组成员
$ export CVSROOT=<var>/var/lib/cvs</var>
$ cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "<var>px</var> -a <var>project-x</var>" &gt;&gt;modules
$ cvs ci -m "<var>Now px is an alias for project-x</var>"
$ cvs release -d .
$ exit                 # 按 Ctrl-D 从 su 返回
$ cvs co -d <var>project</var> <var>px</var> 
 ... 从 CVS 检出 <var>project-x</var> （别名：<var>px</var>） 到目录 project
$ cd project
 ... 修改内容 ...
</example>
</sect2>

<sect1 id="cvs-trouble">CVS 常见问题及解决方法

<sect2>仓库中的文件权限
<p>
CVS 不会覆盖当前仓库中的文件，而是用另一个文件替换它。因此，<em>对仓库目录的写权限</em>是很危险的权限。所以在新建仓库时，请运行下面的命令，确保权限合适。
<example>
# cd <var>/var/lib/cvs</var>
# chown -R root:src <var>repository</var>
# chmod -R ug+rwX   <var>repository</var>
# chmod    2775     <var>repository</var>  # 如果需要，当前目录和子目录
</example>
</sect2>

<sect2>执行标记（execution bit）
<p>
当文件被别人取走后会保留执行标记，任何时候你遇到外出文件存在执行权限问题，可用下面的命令在 CVS 仓库中修改文件权限。
<example>
# chmod ugo-x <var>filename</var>
</example>
</sect2>

</sect1>

<sect1 id="cvs-short">CVS 命令
<p>
这儿是一些 CVS 命令的用法简介。
<example>
{add|ad|new} [-k kflag] [-m 'message'] files...
{admin|adm|rcs} [rcs-options] files...
{annotate|ann} [options] [files...]
{checkout|co|get} [options] modules...
{commit|ci|com}   [-lnR]  [-m  'log_message'  |  -f  file] \
        [-r revision] [files...]
{diff|di|dif} [-kl] [rcsdiff_options] [[-r rev1 | -D date1] \
        [-r rev2 |  -D date2]] [files...]
{export|ex|exp} [-flNn] -r rev|-D date [-d dir] [-k kflag] module...
{history|hi|his} [-report] [-flags] [-options args] [files...]
{import|im|imp} [-options] repository vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] rlog-options [files...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...
{release|re|rel} [-d] directories...
{remove|rm|delete} [-lR] [files...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  tag  |  -D  date] \
         symbolic_tag modules...
{status|st|stat} [-lR] [-v] [files...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r tag | -D date]  [-f] \
         symbolic_tag [files...]
{update|up|upd} [-AdflPpR] [-d] [-r tag|-D date] files...
</example>
</sect1>

<sect id="svn">Subversion
<p>
Subversion 是下一代版本控制系统，它将替代 CVS。当前开发者称它还处于“alpha”阶段，但对大多数用户而言它已足够稳定了。到本文档写作之时，Subversion 仅在 Debian <tt>unstable</tt> 版中可用。
<sect1 id="svn-inst">安装 Subversion 服务器
<p>
<package>subversion</package> meta-package 依赖一些关联包（<package>libapache2-svn</package> 和 <package>subversion-tools</package>）来配置服务器。
<sect2>创建仓库
<p>
当前，<package>subversion</package> 软件包无法创建仓库，所以用户需要手工创建它们。通常可在 <file>/var/local/repos</file> 下创建仓库。
<p>
创建目录：
<example>
# mkdir -p /var/local/repos
</example>
创建仓库数据库：
<example>
# svnadmin create /var/local/repos
</example>
将仓库的写权限赋给 WWW server：
<example>
# chown -R www-data:www-data /var/local/repos
</example>
</sect2>
<sect2>配置 Apache2
<p>
通过用户认证授权访问仓库，添加（或去掉注释符）下列内容到 <file>/etc/apache2/mods-available/dav_svn.conf</file>：
<example>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/local/repos
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt/Location&gt
</example>
接着，使用下面的命令创建用户认证文件：
<example>
htpasswd2 -c /etc/subversion/passwd some-username
</example>
重启 Apache2，就可以使用 URLhttp://<var>hostname</var>/repos 来访问新的 Subversion 仓库了。
</sect2>
</sect1>
<sect1 id="svn-cvs">将 CVS 仓库迁移到 Subversion
</sect1>
<sect1 id="svn-usage">Subversion 用法样例
<p>
下面的小节将教你如何在 Subversion 下使用各种命令。

<sect2>创建新的 Subversion 档案
<p>
创建新的 subversion 档案，输入下面的命令：
<example>
$ cd ~/<var>your-project</var>      # 进入源码目录
$ cd ..        
$ svn import <var>your-project</var> http://localhost/repos/<var>project-name</var>  -m "initial project import"
</example>
<p>
这将在你的 Subversion 仓库下创建一个名为 <var>project-name</var> 的目录，用来存放你的项目文件。查看 http://localhost/repos/ 它是否在那儿？
</sect2>

<sect2>使用 subversion
<p>
用 subversion 来管理 <var>project-y</var>：
<example>
$ cd                            # 转到工作域
$ svn co http://localhost/repos/<var>project-y</var>  # 提取源码
$ cd <var>project-y</var>
 ... 完成一些工作 ...
$ svn diff                      # 相当于 diff -u repository/ local/  
$ svn revert <var>modified_file</var>      # 撤消对文件所做的修改
$ svn ci -m "<var>Describe changes</var>"  # 将你做的修改保存到仓库中
$ vi <var>newfile_added</var>
$ svn add <var>newfile_added</var>
$ svn add <var>new_dir</var>               # 将所有的文件嵌套式地加到 new_dir
$ svn add -N <var>new_dir2</var>           # 非嵌套式地添加目录
$ svn ci -m "Added <var>newfile_added</var>, <var>new_dir</var>, <var>new_dir2</var>"
$ svn up                        # 从仓库中合并最新的版本
$ svn log                       # 显示所有修改记录
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>project-y-branch</var> \
      -m "creating my branch of <var>project-y</var>"  # 对 <var>project-y</var> 进行分支
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>proj-y_release1.0</var> \
      -m "<var>project-y</var> 1.0 release"    # 增加 release 标签
…… 注意分支和标签是一样。唯一的不同是 
…… 分支可以提交，而标签不可以。

…… 对分支进行修改 ……

$ # merge branched copy back to main copy
$ svn merge http://localhost/repos/<var>project-y</var> \
   http://localhost/repos/<var>project-y-branch</var>
$ svn co -r 4 http://localhost/repos/<var>project-y</var> # 得到版本 4
</example>

</sect2>

</sect1>
</sect>
</chapt>

