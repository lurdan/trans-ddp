<!-- CVS revision of this document "$Revision: 1.4 $"  -->
<!-- CVS revision of original english document "1.43"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->
<!-- DON't TOUCH GROFF SECTION!!! -->

<chapt id="program">编程
<p>
不要用“test”命名可执行的测试文件。<prgn>test</prgn>是一个shell的内建命令。

<sect>从哪儿开始
<p>
参考资源：
<list compact>
<item><file>&dochome;<var>package</var></file>下的文档和样例
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
更详细的文档可以从<url id="&gnuhome;" name="GNU">获得打印版本。
<p>
接下来的四个小节中包含了用不同的编程语言编写的脚本样例，该脚本创建一个包含用户帐户信息的文本文件，调用一组进程如newusers程序，将这些信息加入到<file>/etc/passwd</file>。每个脚本均需要一个输入文件，该文件应包含格式如<tt>first_name last_name password</tt>的行。（这些脚本并不创建真正的用户目录。）
</sect>

<sect id="shell">Shell
<p>
理解类Unix系统如何工作的<strong>最好</strong>方法就是阅读shell脚本。在此，我们就shell编程做个简单的介绍。

<sect1 id="bash">Bash &ndash; <strong>GNU</strong>标准交互式shell
<p>
Bash参考资源：
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>the LDP <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
as starter information.
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 （安装<package>bash-doc</package>软件包阅读样例文件。）
<item><em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
</list>
<p>
一个简短的程序样例（从标准输入端创建帐户信息供<prgn>newusers</prgn>使用）：
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">POSIX shells
<p>
&debian;中有几个软件包提供了POSIX shell：
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 176
  <item>Smallest and much fastest &mdash; best for initial boot
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 180
  <item>Smaller and much faster &mdash; good for initial boot
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essential: yes
  <item>Priority: required
  <item>Installed-Size: 580
  <item>Larger and featureful &mdash; many extensions implemented
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 408
  <item>Complete AT&amp;T ksh look-alike
 </list>
</list>
<p>
如果你想编写具有通用性的shell脚本，最好写POSIX shell脚本。可将<file>/bin/sh</file>链接到<prgn>ash</prgn>或(<prgn>dash</prgn>)来测试脚本的POSIX兼容性。避免用<strong>bash化</strong>或<strong>zsh化</strong>（它看起来与csh语法很相似）的思维去编写脚本。例如，应避免：
<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>file</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>

<sect1 id="shell-param">Shell参数
<p>
Several <strong>special parameters</strong> to remember:
<example compact>
$0      = shell名称或shel脚本名称
$1      = 第一个(1)shell参数
 ...
$9      = 第九个(9)shell参数
$#      = 位置参数的个数
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = 最近执行的命令的退出状态
$$      = 当前shell脚本的PID
$!      = 最近启动的后台作业的PID
</example>
<p>
需要记住的基本<strong>扩展参数</strong>：
<example compact>
    Form        If <var>var</var> is set       If <var>var</var> is not set
${<var>var</var>:-<var>string</var>}  $<var>var</var>                <var>string</var>
${<var>var</var>:+<var>string</var>}  <var>string</var>              null
${<var>var</var>:=<var>string</var>}  $<var>var</var>                <var>string</var> 
                                    (并且执行<var>var</var>=<var>string</var>)
${<var>var</var>:?<var>string</var>}  $<var>var</var>                (返回<var>string</var>然后退出)
</example>
在此，冒号“:”在所有运算表达式中事实上均是可选的。
<list compact>
<item>有“:” = 运算表达式测试“存在”和“非空”。
<item>没有“:” = 运算表达式仅测试“存在”。
</list>
<p>
需要记住的<strong>替换参数</strong>：
<example compact>
    Form        Result
${<var>var</var>&percnt;<var>suffix</var>}   删除位于var结尾的<var>suffix</var>最小匹配模式
${<var>var</var>&percnt;&percnt;<var>suffix</var>}  删除位于var结尾的<var>suffix</var>最大匹配模式
${<var>var</var>#<var>prefix</var>}   删除位于var开头的<var>prefix</var>最小匹配模式
${<var>var</var>##<var>prefix</var>}  删除位于var开头的<var>prefix</var>最大匹配模式
</example>

<sect1 id="shell-redirect">Shell重定向
<p>
需要记住的基本<strong>重定向</strong>（redirection）运算符（在此[<var>n</var>]表示可选参数）：
<example compact>
[<var>n</var>]&gt; <var>file</var>     重定向标准输出(或 <var>n</var>)到<var>file</var>。
[<var>n</var>]&gt;&gt; <var>file</var>    重定向标准输出(或 <var>n</var>)到<var>file</var>。
[<var>n</var>]&lt; <var>file</var>     将<var>file</var>重定向到标准输入（或 <var>n</var>）。
[<var>n1</var>]&gt;&amp;<var>n2</var>      重定向标准输出(或 <var>n1</var>)到<var>n2</var>。
&gt; <var>file</var> &gt;&2    重定向标准输出和错误输出到<var>file</var>。
| <var>command</var>     将标准输出通过管道传递给<var>command</var>。
&gt;&2 | <var>command</var> 将标准输出或错误输出通过管道传递给<var>command</var>。
</example>

<sect1 id="shell-cond">Shell条件表达式
<p>
每条命令均可返回一个<strong>退出状态</strong>，这个状态值可用于条件表达式：
<list compact>
<item>成功：0 (True)
<item>错误：1&ndash;255 (False)
</list>
注意该用法，返回值0用来表示“true”与计算机其它领域中常见的转换是不同的。另外`['等阶于使用<prgn>test</prgn>命令进行参数赋值`]'相当于一个条件表达式。
<p>
需要记住的常用基本<strong>条件表达式</strong>：
<example compact>
<var>command</var> && <var>if_success_run_this_command_too</var>
<var>command</var> || <var>if_not_success_run_this_command_too</var>

if [ <var>conditional_expression</var> ]; then  
 <var>if_success_run_this_command</var>
else
 <var>if_not_success_run_this_command</var>
fi
</example>
<p>
在条件表达式中使用的<strong>文件</strong>比较运算符有：
<example compact>
-e <var>file</var>         <var>file</var>存在则返回True。
-d <var>file</var>         <var>file</var>存在且是一个目录则返回True。
-f <var>file</var>         如果<var>file</var>存在且是一个普通文件则返回True。
-w <var>file</var>         如果<var>file</var>存在且可写则返回True。
-x <var>file</var>         如果<var>file</var>存在且可执行则返回True。
<var>file1</var> -nt <var>file2</var> 如果<var>file1</var>比<var>file2</var>新则返回True。（指修改日期）
<var>file1</var> -ot <var>file2</var> 如果<var>file1</var>比<var>file2</var>旧则返回True。（指修改日期）
<var>file1</var> -ef <var>file2</var> 如果两者是相同的设备和具有相同的结点（inode）数则返回True。
</example>
<p>
条件表达式中使用的<strong>字符串</strong>比较运算符有：
<example compact>
     -z <var>str</var>    如果<var>str</var>长度为零则返回True。
     -n <var>str</var>    如果<var>str</var>长度为非零则返回True。
<var>str1</var> == <var>str2</var>   如果字符串相等则返回True。
<var>str1</var> =  <var>str2</var>   如果字符串相等则返回True。
    (使用"=="代替"="符合严格意义上的POSIX兼容) 
<var>str1</var> != <var>str2</var>   如果字符串不相等则返回True。
<var>str1</var> &lt;  <var>str2</var>   如果<var>str1</var>排在<var>str2</var>之前则返回True（与当前位置有关）。
<var>str1</var> &gt;  <var>str2</var>   如果<var>str1</var>排在<var>str2</var>之后则返回True（与当前位置有关）。
</example>
<p>条件表达式中的<strong>算术</strong>整数比较运算符有<tt>-eq</tt>、<tt>-ne</tt>、<tt>-lt</tt>、<tt>-le</tt>、<tt>-gt</tt>和<tt>-ge</tt>。
</sect1>

<sect1 id="clprocess">命令行处理
<p>
shell按如下的方式处理脚本：
<list compact>
<item>用这些字符将其分割成<strong>tokens</strong>：SPACE, TAB, NEWLINE, ;, (, ), &lt;, &gt;, |, &amp;
<item>如果不在"..."或'...'内就检查<strong>keyword</strong>（循环检查）
<item>如果不在"..."或'...'内就扩展<strong>alias</strong>（循环检查） 
<item>如果不在"..."或'...'内就扩展<strong>brace</strong>，<tt>a{1,2}</tt> -> <tt>a1 a2</tt>
<item>如果不在"..."或'...'内就扩展<strong>tilde</strong>, ~<var>user</var> -> <var>user</var>'s home 
directory
<item>如果不在'...'内就扩展<strong>parameter</strong>, $<var>PARAMETER</var>
<item>如果不在'...'内就扩展<strong>command substitution</strong>, $(<var>command</var>)
<item>如果不在"..."或'...'内就用$IFS分割成<strong>words</strong>
<item>如果不在"..."或'...'内就扩展<strong>pathname</strong> *?[]
<item>查找<strong>command</strong>
<list compact>
<item>function
<item>built-in
<item>file in $PATH
</list>
<item>循环
</list>
<p>
在双单号内单引号将失效。

</sect1>

</sect>

<sect>Awk
<p>
Awk的参考资源：
<list compact>
<item><em>Effective awk Programming</em>, 3rd edition (O'Reilly)
<item><em>Sed &amp; awk</em>, 2nd edition (O'Reilly)
<item><manref name="mawk" section="1"> and <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
简短的程序样例（创建<prgn>newusers</prgn>命令输入）：
<example>
#!/usr/bin/awk -f
# Script to create a file suitable for use in the 'newusers' command,
# from a file consisting of user IDs and passwords in the form:
# first_name last_name password
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
          "  where:\n" \ 
          "    startUID is the starting userid to add, and\n" \
          "    file is an input file in form:\n" \
          "      first_name last_name password\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Starting UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
&debian;中有两个软件包提供了POSIX <package>awk</package>：
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priority: required
  <item>Installed-Size: 228
  <item>Smaller and much faster &mdash; good for default install
  <item>Compile-time limits exist
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 1708
  <item>Larger and featureful &mdash; many extensions implemented
  <list compact>
   <item>System V Release 4 version of UNIX
   <item>Bell Labs awk
   <item>GNU-specific
  </list>
 </list>
</list>
</sect>

<sect>Perl
<p>
运行于类Unix系统上的<strong>解释器</strong>。
<p>
Perl参考资源：
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3rd edition (O'Reilly)
</list>
<p>
简短的程序样例（创建<prgn>newusers</prgn>命令输入）：
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
安装Perl模块<var>module_name</var>：
<example>
# perl -MCPAN -e 'install <var>module_name</var>'
</example>
 
</sect>

<sect>Python
<p>
一个不错的面向对象的解释器。
<p>
Python参考资源：
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
</list>
<p>
简短的程序样例（创建<prgn>newusers</prgn>命令输入）：
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input file name. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirst_name last_name password\n"
                return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crashes with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>Make
<p>
Make参考资源：
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2nd edition (O'Reilly)
</list>
<p>
简单自动变量：
<p>
语法规则：
<example>
<var>target</var>: [ <var>prerequisites</var> ... ]
 [TAB]  <var>command1</var>
 [TAB]  -<var>command2</var> # ignore errors
 [TAB]  @<var>command3</var> # suppress echoing
</example>
在此<tt>[TAB]</tt>代表一个TAB符。完成变量代换后shell将逐行进行解释。在行尾使用<tt>\</tt>可以续行。使用<tt>$$</tt>可将<tt>$</tt>加入到shell脚本的环境变量中。
<p>
适用于<var>target</var>和<var>prerequisites</var>的隐含的等价规则：
<example>
&percnt;: &percnt;.c header.h
</example>
or,
<example>
&percnt;.o: &percnt;.c header.h
</example>
在此，<var>target</var>包含了<tt>&percnt;</tt>字符（确切地说是其中之一），<tt>&percnt;</tt>可匹配实际的target文件名中任何非空子串。<var>prerequisites</var>同样也使用<tt>&percnt;</tt>来显示它们的名字是如何关联到实际的target文件名的。
<p>
用<strong>Suffix rules</strong>方法来定义<prgn>make</prgn>的隐含规则(implicit rules)已经<strong>过时</strong>。GNU <prgn>make</prgn>因为兼容性的考虑仍支持它，但只要有可能就应该使用与之等价的模版规则(pattern
rules)：
<example>
old suffix rule --&gt; new pattern rule
.c:             --&gt; &percnt;  : &percnt;.c
.c.o:           --&gt; &percnt;.o: &percnt;.c
</example>
上述规则所使用的自动变量：
<example>
foo.o: new1.c new2.c old1.c new3.c
$@ == foo.o                         (target)
$< == new1.c                        (first one)
$? == new1.c new2.c new3.c          (newer ones)
$^ == new1.c new2.c old1.c new3.c   (all)
$* == `&percnt;' matched stem in the target pattern.
</example>
变量参考：
<example>
foo1 := bar    # One-time expansion
foo2  = bar    # Recursive expansion
foo3 += bar    # Append
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extracts "directory"
 $(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
执行<tt>make -p -f/dev/null</tt>可查看内部自动规则。
</sect>

<sect>C
<p>
准备工作：
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
C参考资源：
<list compact>
<item><tt>info libc</tt> (C library function reference)
<item><manref name="gcc" section="1">
<item><manref name="each_C_library_function_name" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 
 2nd edition (Prentice Hall).
</list>
<p>

<sect1>简单C编程(<prgn>gcc</prgn>)
<p>
一个简单的例子，将<prgn>example.c</prgn>和库函数<prgn>libm</prgn>编译成可执行文件<prgn>run_example</prgn>：
A simple example to compile <prgn>example.c</prgn> with a library
<prgn>libm</prgn> into an executable <prgn>run_example</prgn>:
<example>
$ cat &gt; example.c &lt;&lt; EOF
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* prevent buffer overflow */
        y[10] = '\0'; /* fill to make sure string ends with '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
        1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
        2, 3.082, ./run_exam, 1234567890qwerty
</example>
在此，sqrt()链接库函数<tt>lib<strong>m</strong></tt>需要<tt>-l<strong>m</strong></tt>选项。真正的库函数是位于<file>/lib</file>下的<file>libm.so.6</file>，它是<file>libm-2.1.3.so</file>的一个符号链接。
<p>
看看输出文本中最后的参数，尽管指定了<tt>&percnt;10s</tt>，它还是多于10个字符。
<p>
使用不带边界检查的指针内存操作函数如<prgn>sprintf</prgn>和<prgn>strcpy</prgn>会妨碍缓冲区溢出侦测，故使用<prgn>snprintf</prgn>和<prgn>strncpy</prgn>。
</sect1>

<sect1>调试

<sect2>使用<prgn>gdb</prgn>进行调试
<p>
准备工作：
<example>
# apt-get install gdb
</example>
<p>
<prgn>gdb</prgn>参考资源：
<list compact>
<item><tt>info gdb</tt> (tutorial)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>
<p>
使用<tt>-g</tt>选项编译程序就可使用<prgn>gdb</prgn>进行调试。许多命令都可以缩写。Tab扩展功能和在shell中的一样。
<example>
$ gdb program
(gdb) b 1                # 在line 1设置断点
(gdb) run <var>arg1 arg2 arg3</var> # 运行程序
(gdb) next               # 下一行
...
(gdb) step               # 前进一步
...
(gdb) p parm             # 打印parm  
...
(gdb) p parm=12          # 设置其值为12
</example>
<p>
在Emacs环境下调试程序，参阅<ref id="editkey">。
</sect2>

<sect2 id="ss-ldd">检查库函数关联关系
<p>
使用<prgn>ldd</prgn>可查看程序与库函数的关联关系：
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
可在chrooted环境下使用<prgn>ls</prgn>检查上述库函数在你的<prgn>chroot</prgn>环境中是否可见。
<p>
下面的命令也很有用：
<list compact>
<item><prgn>strace</prgn>: 跟踪系统调用和消息
<item><prgn>ltrace</prgn>: 跟踪库函数调用
</list>
</sect2>
 
<sect2>使用内存查漏工具进行调试
<p>
&debian;中有几个内存查漏工具。
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (not packaged, get this from 
 <url id="&memwatch-home;" name="GNU memwatch">.)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> from 
  <url id="&parasofthome;" name="Parasoft">. (non-free, commercial for fee)
</list>
<p>
亦可查阅<url id="&mallocdebughome;" 
  name="Debugging Tools for Dynamic Storage Allocation and Memory Management">.

<sect1>Flex &ndash; 更好的Lex
<p>
<prgn>flex</prgn>是一个快速的词法分析机生成器。
<p>
<prgn>flex</prgn>参考资源：
<list compact>
<item><tt>info flex</tt> (tutorial)
<item><manref name="flex" section="1">
</list>
<p>
需要提供你自己的<prgn>main()</prgn>或<prgn>yywrap()</prgn>，或者你的<prgn>program.l</prgn>象这样不带library编译（<prgn>yywrap</prgn>是一个宏；<tt>&percnt;option main</tt>隐含地打开了<tt>&percnt;option
noyywrap</tt>）：
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
另外，还可以在<prgn>cc</prgn>命令行末尾加上-<tt>lfl</tt>链接选项进行编译（象AT&amp;T-Lex使用<tt>-ll</tt>一样），此时就不需要<tt>&percnt;option</tt>了。
</sect1>

<sect1>Bison &ndash; 更好的Yacc
<p>
&debian;中有几个软件包提供了与Yacc兼容的LALR词法生成器：
<p>
<list compact>
 <item><package>bison</package>: GNU LALR parser generator
 <item><package>byacc</package>: The Berkeley LALR parser generator
 <item><package>byyacc</package>: Backtracking parser generator based on <package>byacc</package>
</list>
<p>
<prgn>bison</prgn>参考资源：
<list compact>
<item><tt>info bison</tt> (tutorial)
<item><manref name="bison" section="1">
</list>
<p>
需要提供自己的<prgn>main()</prgn>和<prgn>yyerror()</prgn>。<prgn>main()</prgn>调用<prgn>yyparse()</prgn>，而<prgn>yyparse()</prgn>调用<prgn>yylex()</prgn>，通常由FleX创建。
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn>一个shell脚本生成工具，由它生成的脚本能自动配置软件源码包，以适用于各种使用全套GNU build系统的类UNIX系统。
<p>
<prgn>autoconf</prgn>会生成配置脚本<prgn>configure</prgn>。<prgn>configure</prgn>使用<prgn>Makefile.in</prgn>模版自动创建自定义<prgn>Makefile</prgn>。
 
<sect2>编译并安装程序
<p>
&debian;不会改动<file>/usr/local</file>下的文件（参阅<ref id="diverse">）。所以如果是从源码编译程序，并将其安装到<file>/usr/local</file>下，是不会影响到&debian;的。
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # this puts the files in the system
</example>

<sect2>卸载程序
<p>
如果仍保存有源码，对其使用了<prgn>autoconf</prgn>/<prgn>automake</prgn>，并且记得是如何进行配置的：
<example>
$ ./configure <var>all-of-the-options-you-gave-it</var>
# make uninstall
</example>
<p>
另一种方法是，如果可以确定安装过程将文件都放在了<file>/usr/local</file>，并且该目录下没有什么别的重要文件，可用下面的命令将其全部删除：
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
如果不能确定文件安装到什么位置，最好使用<package>checkinstall</package>，该命令可提供明确的卸载路径。
</sect1>

</sect>

<sect>准备文档
<p>

<sect1><tt>roff</tt>排版
<p>
传统上，<tt>roff</tt>是主要的Unix文字处理系统。
<p>
参阅<manref name="roff" section="7">、<manref name="groff" section="7">、<manref name="groff" section="1">、<manref name="grotty" section="1">、<manref name="troff" section="1">、<manref name="groff_mdoc" section="7">、<manref name="groff_man" section="7">、<manref name="groff_ms" section="7">、<manref name="groff_me" section="7">、<manref name="groff_mm" section="7">以及<tt>info groff</tt>。
<p>
<prgn>-me</prgn>宏提供了一个不错了说明文档。如果使用的是groff（1.18或更新的版本），找到<file>&f-meintro;</file>并执行下面的命令：
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
下面的命令将生成一个完整的纯文本文件：
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
如果想打印出来，可使用PostScript输出：
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>




<sect1>SGML
<p>
准备工作：
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
<prgn>debiandoc-sgml</prgn>参考资源：
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em>DocBook: The Definitive Guide</em>, by Walsh and Muellner (O'Reilly)
</list>
<p>
SGML能管理多重格式的文档。更简单的SGML系统是Debiandoc，本文档就使用到它完成的。只需对原始的文本文件的下列字符进行少许转换：
<!-- nbsp bug in PDF ? -->
<list compact>
<item>"&lt;" --&gt; <tt>&amp;lt;</tt>
<item>"&gt;" --&gt; <tt>&amp;gt;</tt>
<item>"&nbsp;" --&gt; <tt>&amp;nbsp;</tt>  (non-breakable space)
<item>"&amp;" --&gt; <tt>&amp;amp;</tt>
<item>"&percnt;" --&gt; <tt>&amp;percnt;</tt>
<item>"&copy;" --&gt; <tt>&amp;copy;</tt>
<item>"&ndash;" --&gt; <tt>&amp;ndash;</tt>
<item>"&mdash;" --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
设置章节为非打印注释，输入：
<example>
&lt;!-- State issue here ... --&gt;
</example>
设置章节为可控注释，输入：
<example>
&lt;![ &percnt;FIXME; [ State issue here ... ]]&gt;
</example>
在SGML中，仅条目的<em>首次声明</em>（first definition）有效。例如：
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
最终结果是“Data 1”。如果第一行使用“IGNORE”而非“INCLUDE”，则最终结果为“Data 2”（第二行是一个候选声明）。同样，重复出现的短语可分别提前在文档中定义。
<example>
&lt;!entity <var>whoisthis</var> "my"&gt;
Hello &amp;<var>whoisthis</var>; friend.
This is &amp;<var>whoisthis</var>; book.
</example>
该定义的结果如下：
<example>
Hello my friend.
This is my book.
</example>
可参阅<url id="&examples;" name="examples">目录中简短的SGML样例文件<file>sample.sgml</file>。
<p>
当SGML文档不断增大后，TeX偶尔会出错。可通过修改<file>/etc/texmf/texmf.cnf</file>，增加缓冲池的容量来解决这个问题（更好的方法是编辑<file>/etc/texmf/texmf.d/95NonPath</file>然后运行<prgn>update-texmf</prgn>）。
</sect>

<sect id="packaging">打包
<p>
准备工作：
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
                  &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # if Potato
</example>
有关打包的参考资源：
<list compact>
 <item><ref id="pkg-basics"> (basics)
 <item>Debian New Maintainers' Guide (tutorial)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (best practice)
 <item>Debian Policy Manual (authoritative)
 <item>Packaging Manual (Potato) 
</list>

<sect1 id="pack-binary">单个二进制文件打包
<p>
Joey Hess的快速粗糙的打包法：生成一个单独的二进制包
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mypackage
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: my little package
 Don't expect much.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">使用工具打包
<p>
使用<prgn>dh_make</prgn>软件包中的<package>dh-make</package>工具创建一个基线包，接着按照<manref
name="dh-make" section="1">中描述的方法打包。会用到<prgn>debian/rules</prgn>中的<prgn>debhelper</prgn>。
<p>
一个较老的方法是使用<package>debmake</package>软件包中的<prgn>deb-make</prgn>。不需要<prgn>debhelper</prgn>脚本，仅需要shell环境。
<p>
有关多重源码包的例子，参阅“mc”（<tt>dpkg-source -x
mc_4.5.54.dsc</tt>），其中用到Adam Heath(<email>doogie@debian.org</email>)的“sys-build.mk”以及“glibc”（<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>）它由已故的Joel Klecker(<email>espy@debian.org</email>)所写的另一个系统打包。

</sect>

</chapt>
