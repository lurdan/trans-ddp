<!-- CVS revision of this document "$Revision: 1.1 $"  -->
<!-- CVS revision of original english document "1.47"  -->

<chapt id="system">Debian基础

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for potato and woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
本章讲述非开发人员需要掌握的Debian系统基础知识。有关知识的权威参考，请参阅：
<p>
<list compact>
<item>Debian Policy Manual
<item>Debian Packaging Manual (Potato)
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
<p>
</list>
列表见<ref id="references">。

<p>
如果你想查阅简要的“how-to”解释文档，可直接跳到<ref id="package">或其它相关章节。
<p>
本章的内容取自“Debian FAQ”，经过较大的改编，以适于普通Debian系统管理者上手。

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">Debian文件

<sect1 id="dirtree">目录结构

<p>&debian;软件包位于<url id="&mirror-site;" name="Debian镜像站点">的目录树中，可通过FTP或HTTP访问它们。

<p>下列目录存在于任何Debian镜像站点的<tt>/debian/</tt>目录下：
<taglist>
  <tag><file>/dists/</file>:
    <item>本目录包含“发行版”（distributions），此处是获得Debian发布版本（releases）和已发布版本（pre-releases）的软件包的正规途径。有些旧软件包及<tt>Packages.gz</tt>文件仍在其中。
  <tag><file>/pool/</file>:
    <item>所有Debian发布版及已发布版的软件包的新的物理地址。
  <tag><file>/tools/</file>:
    <item>一些DOS下的小工具，用于创建启动盘、硬盘分区、压缩/解压缩和启动Linux。
  <tag><file>/doc/</file>:
    <item>Debian的基本文档，如FAQ、错误报告系统使用说明等。
  <tag><file>/indices/</file>:
    <item>维护人员文件和重载文件。
  <tag><file>/project/</file>:
    <item>大部分为开发人员的资源，如：
    <taglist>
      <tag><file>project/experimental/</file>:        <item>本目录包含了处于开发中的软件包和工具，它们均处于alpha测试阶段。用户不应使用这些软件，因为即使是经验丰富的用户也会被搞得一团糟。
      <tag><file>project/orphaned/</file>:
        <item>已不再有人维护的软件包，它们已从发行版中孤立出来。
    </taglist>
</taglist>

<sect1 id="dists">Debian发行版

<p>通常在<tt>dists</tt>目录下有三个Debian发行版。它们是“stable”发行版，“testing”发行版，和“unstable”发行版。有时还有一个“frozen”发行版。每个发行版均定义成一个符号链接指向该目录相应的代号目录。

<sect1 id="stable"><tt>stable</tt>发行版

<p><tt>stable</tt>发行版软件包入口，&stabledebian;被登记到<tt>stable</tt>目录（符号链接指向<tt>&stablecodename;</tt>目录）：
<list>
  <item><file>stable/main/</file>：本目录包含的软件包均是最新&debian;系统发布版的正式组成部分。

  <p>这些软件包均遵循<url name="Debian Free Software
  Guidelines" id="&social-contract;#guidelines">（它位于<file>&f-social-contract;</file>，须安装<package>&p-social-contract;</package>），它们均可以自由使用和再发行。

  <item><file>stable/non-free/</file>：本目录包含的软件包受到一定限制，发行者需遵循特殊版权要求。

  <p>例如，有些软件包的许可证禁止其用于商业发行的。有些虽可以再发行，但本身是共享软件而非自由软件。以任何方式再发行这些软件包时（例如写入光盘）必须认真阅读有关的许可证或与所有者协商。

  <item><file>stable/contrib/</file>：本目录包含的软件包均遵循DFSG-free原则，本身也是<strong>自由发布</strong>的，但这些软件包的关联包<strong>不具有</strong>自由发行的属性，它们位于non-free目录。
</list>
除了上述的目录，新上载的软件包的物理存储位置为<tt>pool</tt>目录（<ref id="pools">）。 

<p>现阶段<tt>stable</tt>发行版错误报告位于<url id="&stable-problems;" name="Stable Problems">页面。


<sect1 id="testing"><tt>testing</tt>发行版

<p><tt>testing</tt>发行版软件包入口，处于<tt>unstable</tt>版本的&testingdebian;通过级别测试后登记到<tt>testing</tt>目录（符号链接指向<tt>&testingcodename;</tt>目录）。现在，除了上述目录，新上载的软件包的物理存储位置为<tt>pool</tt>目录（<ref id="pools">）。在testing下同样有<tt>main</tt>、<tt>contrib</tt>和<tt>non-free</tt>子目录，它们的作用与<tt>stable</tt>中的一样。

<p>这些软件包必须可同时运行于所有架构，并且没有关联性问题影响到其安装。比起在<tt>unstable</tt>中的相应版本，它们有更少的release-critical错误。我们将<tt>testing</tt>作为更佳发布候选版本。有关testing版本的更多信息见于<url id="&testing-notes;">。

<p><tt>testing</tt>发行版的最新消息发布在下列站点：
<list compact>
<item><url id="&update-excuses;" 
         name="更新理由">
<item><url id="&testing-problems;" 
         name="问题测试">
<item><url id="&release-critical;" 
         name="阻碍发布的错误">
<item><url id="&qa-base-bugs;" 
         name="基本系统错误">
<item><url id="&qa-standard-bugs;" 
         name="标准软件包和任务包错误">
<item><url id="&qa-bugs;" 
         name="其它错误记录">
</list>

<sect1 id="unstable"><tt>unstable</tt>发行版

<p><tt>unstable</tt>发行版软件包入口，sid被登记到<tt>unstable</tt>目录（符号链接指向<tt>sid</tt>），上载的软件包在被移至<tt>testing</tt>目录前一直呆在这儿。新上载的软件包的物理存储位置为<tt>pool</tt>目录（<ref id="pools">）。在testing下同样有<tt>main</tt>、<tt>contrib</tt>和<tt>non-free</tt>子目录，它们的作用与<tt>stable</tt>中的一样。

<p><tt>unstable</tt>发行版反映了系统的最新开发进展。欢迎广大用户使用并测试这些软件包，同时也提醒你们这些软件包还不完善。使用<tt>unstable</tt>发行版的好处就是你可以获得&debian;项目的最新更新&mdash;不过新东西也会出新问题，你得好坏兼收:-)

<p><tt>unstable</tt>发行版的最新错误报告见于<url id="&unstable-problems;" name="Unstable Problems">页面。

<!-- Above was enough
<sect1 id="sid">The "sid" distribution

<p><strong>sid</strong> or <strong>unstable</strong> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <strong>testing</strong>,
in order to be released in <strong>stable</strong> later on. sid contains packages
for both released and unreleased architectures.

<p>The name "sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen"><tt>frozen</tt>发行版

<p>当<tt>testing</tt>发行版足够成熟了，它成为frozen发行版，表示这个版本不再加入新代码，只进行除错工作。同时，<tt>dists</tt>目录中会建立新的testing发行版目录树，并命名新的版本代号。frozen发行版再经过几个月的测试、更新、再冻结也称之为“循环测试”。（新近的<tt>woody</tt>发布进程没有创建<tt>frozen</tt>符号链接，所以<tt>frozen</tt>并不算发行版，仅仅是<tt>testing</tt>发行版的一个开发阶段。）

<p>我们将frozen发行版中可能延迟软件包或整个版本发布的错误都记录在案，一但错误总数低于可接受的最大值，frozen发行版就晋升成stable，新版本发布了，先前发布的版本成为过期版（obsolete）（并被移于相应的目录）。

<sect1 id="codenames">Debian发布版代号

<p>存在于<tt>dists</tt>目录下的物理目录名，例如<tt>&stablecodename;</tt>和<tt>&testingcodename;</tt>，就是“版本代号（codenames）”。当某个&debian;发行版处于开发阶段，它并没有版本号，取而代之的是版本代号。使用版本代号的目的在于简化建立&debian;发行版镜像的工作（如果真实目录例如<tt>unstable</tt>突然改名为<tt>stable</tt>，许多文件都没必要再次下载）。

<p>当前，<tt>stable</tt>是一个指向<tt>&stablecodename;</tt>的符号链接，<tt>testing</tt>是指向<tt>&testingcodename;</tt>的符号链接。也就是说<tt>&stablecodename;</tt>是当前的stable发行版，<tt>&testingcodename;</tt>是当前的testing发行版。

<p><tt>unstable</tt>发行版是指向<tt>sid</tt>的永久符号链接，即unstable发行版总称为<tt>sid</tt>。<!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">已用过的发布版代号

<p>已使用过的发行版代号有：<tt>buzz</tt> for
release 1.1，<tt>rex</tt> for release 1.2，<tt>bo</tt> for releases 1.3.x，<tt>hamm</tt> for release 2.0，<tt>slink</tt> for release 2.1和<tt>potato</tt> for release 2.2。


<sect1 id="sourceforcodenames">发布版代号来源

<p>到目前为止它们均出自Pixar的电影“<em>Toy Story</em>（Toy Story）”
<list compact>
  <item><strong>Buzz</strong>（Buzz Lightyear）是个宇航员，
  <item><strong>Rex</strong>是只暴龙，
  <item><strong>Bo</strong>（Bo Peep）是个放羊的女孩，
  <item><strong>Hamm</strong>是个小猪攒钱罐，
  <item><strong>Slink</strong>（Slinky Dog）是只玩具狗，
  <item><strong>Sarge</strong>是位绿色塑料玩具士兵首领，
  <item><strong>Potato</strong>当然就是Potato Head先生，
  <item><strong>Woody</strong>是个牛仔，
  <item><strong>Sid</strong>是隔壁的男孩，那个玩具终结者。
</list>
<!--
  more info in http://www.pixar.com/feature/toystory/toystory.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Sarge and The Green Plastic Army Men
    - Andy (the kid)
    - Etch (Etch-a-Sketch) (the blackboard)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools"><tt>pool</tt>目录

<p>过去，软件包均放在<tt>dists</tt>目录下相应发行版的子目录中。这种做法产生了许多问题，当镜像站点进行新版本发布时大量带宽被消耗。

<p>现在软件包均放进一个巨大的“池子（pool）”，按照源码包名称分类存放。为了方便管理，pool目录下按属性再分类（<tt>main</tt>、<tt>contrib</tt>和<tt>non-free</tt>），分类下面再按源码包名称的首字母归档。这些目录包含的文件有：运行于各种系统架构的二进制软件包，生成这些二进制软件包的源码包。

<p>你可以执行命令<tt>apt-cache showsrc <var>mypackagename</var></tt>，查看“Directory:”行获知每个软件包的存放位置。例如：<package>apache</package>软件包存放在<file>pool/main/a/apache/</file>软件包存放在<tt>lib*</tt>软件包数量巨大，它们以特殊的方式归档：例如，<package>libpaper</package>软件包存放在<file>pool/main/libp/libpaper/</file>。

<p>诸如<tt>apt</tt>等命令访问的索引文件仍位于<tt>dists</tt>目录中，直到本文写作之时，旧发行版的软件包还没转到pool目录，所以你将看到路径的“Filename”域中包含有发行版名称如<tt>potato</tt>或<tt>woody</tt>。

<p>通常，你大可不必注意这些，新版的<tt>apt</tt>和旧版<tt>dpkg-ftp</tt>（参阅<ref id="howtocurrent">）会自动处理它们。想了解更多信息，参阅<url id="&pool-faq;" name="Debian Package Pools FAQ">。

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history"><tt>sid</tt>诞生记

<p>过去<tt>sid</tt>并不存在，Debian文件组织只有一个主要的工作流程：假设当前<tt>unstable</tt>发行版中创建了某个软件开发项目，当它成为新的<tt>stable</tt>版之时，便是它的发布之日。由于软件包一但发布就需要移动到新的stable目录，当众多软件开发项目移动目录时大量带宽会被吞噬掉，这个流程就显得很不切实际，因而许多软件开发项目并没有按这个方法行事。

<p>经过几年的研究摸索，文档管理员提出一个方案，将未获准发布的二进制文档存入名为<tt>sid</tt>的特定目录。由于这些软件尚未发布，从那时起，它们就被加入到<tt>unstable</tt>目录树。当它们首次发布时，将会建立一个从当前<tt>stable</tt>指向<tt>sid</tt>的链接。这个方案用户听起来的确有些晕头。

<p>有了软件包储藏池的帮助（参阅<ref id="pools">），在<tt>woody</tt>发行版开发过程中，二进制软件包均按一定规范存放于pool目录，而与发行版无直接关系，当发布新版本时，就不会再出现大量带宽被消耗的问题。（不过，大量带宽还是被开发进程消耗了）。

<sect1 id="incoming">上载到<file>incoming</file>中的软件包
<p>
上载的软件包首先存放于<url id="&incoming;">经过检收，确定它们是由Debian开发者上载的（对于那些属于无维护者上载（Non-Maintainer Upload 缩写 NMU）的软件包则放入<file>DELAYED</file>子目录）。会有一天，它们将从<tt>incoming</tt>移入<tt>unstable</tt>。
<p>
在紧急情况下，你可能会等不及它们移入<tt>unstable</tt>而直接从<tt>incoming</tt>中下载安装。
</sect1>

<sect1 id="snapshot">找回旧软件包
<p>
最新的Debian发行版存放在任何一个<url id="&mirror-site;" name="Debian镜像站点">的<tt>debian</tt>目录下。旧版本的Debian如Slink存放在<url id="&archivehome;">或Debian镜像站点的<tt>debian-archive</tt>目录下。
<p>
旧的<tt>testing</tt>和<tt>unstable</tt>软件包存放在<url id="&snapshothome;">。

</sect1>

<sect1 id="archsections">发布源目录结构
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>在每个主目录树下（<file>dists/stable/main</file>、<file>dists/stable/contrib</file>、<file>dists/stable/non-free</file>、<file>dists/unstable/main/</file>，等）按芯片架构又分了子目录，每个子目录中存放着在该芯片架构下编译的二进制软件包。

<list>
  <item><file>binary-all/</file>，存放与芯片架构无关的软件包，如Perl脚本、纯文档等。
  <item><file>binary-<var>platform</var>/</file>，存放运行于该平台的二进制软件包。
  <!-- Yes I simplified this -->
</list>

<p>请注意，<tt>testing</tt>和<tt>unstable</tt>发行版的二进制软件包不再存放在这些目录中，它们存放在上一级<tt>pool</tt>目录中。目录中仍保留有索引文件（<file>Packages</file>和<file>Packages.gz</file>）是为了向下兼容。

<p>要获得有关二进制架构技术支持，参阅各发行版的发布手记（Release Notes），可以访问发布手记站点<url id="&stable-release;" name="stable">和<url id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">源代码

<p>Debian系统中的一切程序都有源代码，不仅如此，许可证条款<strong>规定</strong>系统中所有的程序必须和其源代码一起发行，或提供源代码出售。

<p>通常源代码发布在<tt>source</tt>目录，该目录同时处于所有架构目录中，更新的源码则在<tt>pool</tt>目录中（参阅<ref id="pools">）。对于不太熟悉Debian归档目录结构的用户想获得源代码可以试试<tt>apt-get source 
<var>mypackagename</var></tt>命令。

<p>有些软件包，如著名的<package>pine</package>，由于许可证限制，只提供源码包。（最近，<package>pine-tracker</package>软件包提供了一个简易的安装版）安装源码包的方法可参阅<ref id="port">，<ref
id="packaging">教你如何手工创建一个软件包。

<p><file>contrib</file>和<file>non-free</file>目录中的软件包可能不提供源代码，因为它们没有正式加入Debian系统。

<sect id="pkg-basics">Debian软件包管理系统

<sect1 id="package-basics">Debian软件包概述

<p>软件包通常包含了实现一系列相关命令或特性所必须的所有的文件。有两种类型的Debian软件包：
<list>
  <item><strong>Binary packages</strong>（二进制软件包），它包含可执行文件、配置文件、man/info页面、版权声明和其它文档。这些软件包以Debian特定的格式发布（参阅<ref id="deb-format">）；它们通常使用<tt>.deb</tt>的扩展名以示区别。这种二进制软件包可使用Debian工具<tt>dpkg</tt>解包，详情见有关帮助页面。
  
  <item><strong>Source packages</strong>（源码包），包含一个<tt>.dsc</tt>文件它用于描述源码包（包括下列文件的名称），一个<tt>.orig.tar.gz</tt>文件它是未经修改的原始源代码压缩文件，以及一个<tt>.diff.gz</tt>文件它包含了该软件包Debian化时所做的修改。<tt>dpkg-source</tt>工具可用于打包/解包Debian源码包，详情可参阅有关帮助页面。
</list>

<p>软件包管理系统安装的软件包时需要读取那些由软件包维护者精心设计的关联信息，这些关联信息记录在每个软件包的<tt>control</tt>文件中。例如，包含GNU C编译器（gcc）的软件包依赖于包含链接器和汇编器的<package/binutils/软件包。如果用户试图在没有安装<package/binutils/的情况下安装<package/gcc/，软件包管理系统（dpkg）就会发送一条错误信息，告诉你需要安装<package/binutils/，并停止安装<package/gcc/。（不过，倔强的用户可以对这个信息视而不见，参阅<manref name="dpkg" section="8">)。）更多信息，参阅下面的章节<ref id="depends">。

<p>Debian软件包管理工具可用于：
<list>
  <item>操作和管理软件包或软件包的局部内容，
  <item>帮助那些使用有限容量载体如软盘传输的用户分割软件包，
  <item>帮助开发者将开发文件打包成软件包，
  <item>帮助用户从远程Debian文档站点安装软件包。
    <!--FTP-->Debian archive site.
</list>

<sect1 id="deb-format">Debian<!--binary-->软件包格式

<p>Debian“软件包”，或称之为Debian包文件（Debian archive file），包含了可执行文件、库文件、和相关程序的文档。通常Debian文件的文件名以<tt>.deb</tt>结尾。

<p>Debian二进制软件包内部格式描述见<manref name="deb" section="5">帮助页面。由于这种内部格式会改变的（特别对于&debian;的新旧发布版），所以要操作<tt>.deb</tt>文件请参阅<manref name="dpkg-deb" section="8">。

<!-- Below added by Osamu Not sure but should be right -->

<p>即便在Woody发行版中，如果有Debian文件使用dpkg命令操作无效，还可用标准的Unix命令<prgn>ar</prgn>和<prgn>tar</prgn>来操作。

<sect1 id="pkgname">Debian软件包命名约定
<!--
Why are Debian package file names so long? 
-->
<p>Debian<!--binary-->软件包命名遵循下列约定：
<example>
<var>foo</var>_<var>VersionNumber</var>-<var>DebianRevisionNumber</var>.deb
</example>
其中<var>foo</var>代表软件包名称。确定某个特定Debian包文件（<tt>.deb</tt> file）的软件包名称有两种方法：
<list>

<item>在Debian包文件站点的软件包存放目录下查看“Packages”文件。该文件有一个段落包含了各个软件包的描述内容；其中第一个域列出了软件包正式名称。

<item>使用命令<tt>dpkg --info <var>foo_VVV-RRR</var>.deb</tt>（其中<var>VVV</var> and <var>RRR</var>分别表示该软件包的版本号和修订版号）。屏幕上会显示该软件包解包后的软件包名称。
</list>

<p><var>VVV</var>字段代表该软件开发者制定的版本号。由于没有统一的版本号标准，所以它们的格式会各不相同例如“19990531”和“1.3.8pre1”。

<p><var>RRR</var>字段代表Debian修订版本号，它是由Debian开发者（或个人用户，假如他选择自己创建软件包的话）制定的。该版本号按照Debian软件包修订标准来制定；一个新的修订版通常表示对下列文件做了修改：Debian makefile（<tt>debian/rules</tt>s），Debian管理文件（<tt>debian/control</tt>），安装或卸载脚本（<tt>debian/p*</tt>），或软件包配置文件。


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">保存本地设置
<!--
What is a Debian conffile
-->
<p>&debian;的“conffiles”机制，可保存用户配置文件。用户的配置文件（通常位于<file>/etc</file>）由Debian软件包管理系统登记到<tt>conffiles</tt>。当软件包升级后，软件包管理系统确保这些文件不被覆盖。
<p>
如果不需修改各种软件包配置文件就能完成系统配置，那就别去修改它们，即使它们已登记到conffiles。这样做能保证快速平滑的升级操作。
<!--
<p>Conffiles is a list of configuration files (usually placed in <tt>/etc</tt>)
that the package management system will not overwrite when the package is
upgraded. This ensures that local values for the contents of these files
will be preserved, and is a critical feature enabling the in-place upgrade
of packages on a running system.
-->
<p>想准确了解哪些文件在升级过程中受到保护，运行：
<example>
dpkg --status <var>package</var>
</example>
看看“Conffiles”下的文件名列表。

<p>
有关Debian <tt>conffiles</tt>文件的详细内容，可参阅Debian Policy Manual的11.7节（参阅see <ref id="references">）。

<sect1 id="maintscripts">Debian维护脚本
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian维护脚本是一种可执行脚本，它在软件包安装之前或之后自动运行。它和一个名叫<tt>control</tt>的文件一起组成Debian包文件的“管理”部分。

<p>这些文件是：
<taglist>
<tag/preinst/
 <item>在Debian包文件解包之前，运行这个脚本。许多“preinst”脚本的任务是停止作用于待升级软件包的服务，直到软件包安装或升级完成。

<tag/postinst/
 <item>该脚本的任务是完成Debian包文件解包文件的配置工作。通常，“postinst”脚本等待用户输入，或提醒用户，如果他接受当前默认值，要记得软件包安装完后返回重新配置。许多“postinst”脚本负责执行有关命令为新安装或升级的软件重启服务。

<tag/prerm/
  <item>该脚本负责停止与软件包关联的daemon服务。它在删除软件包关联文件之前执行。

<tag/postrm/
  <item>该脚本负责修改软件包链接或文件关联，或删除由它创建的文件。（参阅<ref id="virtual">）。
</taglist>

<p>当前，所有的管理文件都存放在<file>/var/lib/dpkg/info</file>目录。与<tt>foo</tt>软件包相关的文件，名字以“foo”打头，以“preinst”、“postinst”等为扩展名。目录中的<tt>foo.list</tt>文件列出了<tt>foo</tt>软件包安装的所有文件。（注意这些文件的位置在由dpkg来确定，可能会因Debina版本而异）

<sect1 id="priority">软件包优先级
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>每个Debian软件包均被发布者指点了一个<strong>优先级</strong>，作为软件包管理系统
的一个辅助参数，优先级的值有：

<list>
  <item><strong>Required</strong> 该级别软件包是保证系统正常运行必须的。    <p>包含所有必要的系统修补工具。不要删除这些软件包，否则整个系统将受到损坏，甚至无法使用<prgn>dpkg</prgn>恢复。只安装Required级软件包的系统不可能满足所有的用途，但它可以启动起来，让系统管理员安装想要的软件。
  <item><strong>Important</strong> 在任何类Unix系统上均安装有该级别软件包。
   <p>系统若缺少这类软件，会运行困难或不好操作。该级别软件包并<strong>不</strong>包括Emacs或X11或TeX或其它大型应用程序，它们只是一些实现系统底层功能的程序。
  <item><strong>Standard</strong> 该级别软件包是任何Linux系统的标准件，它们组成一个小而精的字符模式的系统。
    <p>系统的默认安装就包括了它们。“Standard”级软件包不包括许多大型应用程序，但它包括Emacs（它比其它应用程序更底层）和Tex及LaTeX的精巧版（不支持X）。
  <item><strong>Optional</strong> 该级别软件包包括那些你可能想安装的软件，即使对它们并不熟悉。and if
    you don't have specialized requirements.
    <p>它们包括X11，TeX完整发布版和许多应用程序。
  <item><strong>Extra</strong> 该级别软件包可能与其它高级别软件包冲突，仅当你知道其用途时才会使用它们，或者有运行它们有专门要求，这些都使它们不适合定为“Optional”级。
</list>

<sect1 id="virtual">虚拟软件包

<p>虚拟软件包是一个统称，用来指一组具有相近功能的软件包。举个例子，<tt>tin</tt>和<tt>trn</tt>都是新闻组阅读软件，当系统中某个程序需要调用新闻阅读器工作时就会产会一个关联关系，它们必须满足这个关联，我们也称之为它们提供了一个叫做<tt>news-reader</tt>的“虚拟软件包”。

<p>又如，<tt>exim</tt>和<tt>sendmail</tt>都提供邮件传输代理的功能。也可称之为提供“邮件传输代理”虚拟包，如果安装了两者之一，那么任何与<tt>mail-transport-agent</tt>有关联关系的程序发出调用命令时，都会通过这个虚拟包实现调用。

<p>Debian有个机制，如果系统中提供同种虚拟包的软件包安装了多个，系统管理员可以指定一个为首选软件。相关的命令是<tt>update-alternatives</tt>，更详细的描述参阅<ref id="alternatives">。

<sect1 id="depends">软件包关联性
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>Debian软件包管理系统有一套软件包“依赖性”定义（用一个标志）用来描述独立运行程序A与现存系统中程序B的存在之间的关系疏密程度：
<list>
 <item>软件包A<strong>依赖</strong>（depends）软件包B：要运行A必须安装B。在有些情况下，A不仅依赖B，还要求B的特定版本。版本依赖通常有最低版限制，A更依赖于B的最新版而非某个特定版本。
 <item>软件包A<strong>推荐</strong>（recommends）软件包B：软件包维护者认为所有用户都不会喜欢缺少某些功能的A，而这些功能需要B来提供。
 <item>软件包A<strong>建议</strong>（suggests）软件包B：B中某些文件与A的功能相关（通常能增强其功能）。
 <item>软件包A与软件包B<strong>冲突</strong>（conflicts）：如果系统中安装了B那么A无法运行。多数情况下，冲突是由于A中包含了B中文件的改进版。“Conflicts”常和“replaces”同时出现。
 <item>软件包A<strong>替换</strong>（replaces）软件包B：B安装的文件被A中的文件移除和覆盖了。
 <item>软件包A<strong>提供</strong>（provides）软件包B：A中包含了B中的所有文件和功能。这种机制为那些受限于磁盘空间的用户提供了一个途径，只安装A中他们直正需要的部分。
</list>

<p>上述术语使用方法的更详细的信息参阅Packaging Manual和the Policy Manual。

<p>注意，<prgn>dselect</prgn>可以对<strong>recommends</strong>和<strong>suggests</strong>类软件包进行细操作，<file>apt-get</file>只会简单的下载安装<strong>depends</strong>类软件包而不管<strong>recommends</strong>和<strong>suggests</strong>类软件包。这两个程序均正式使用APT作为其后台。

<sect1 id="pre-depends">何为“pre-depends”

<p>“pre-depends”是一种特殊关联关系。对于一个普通软件包，不管系统中是否存在它的关联文件，<prgn>dpkg</prgn>都会将它解包。解包主要指<prgn>dpkg</prgn>从软件包中取出安装文件。如果系统中不存在这些软件包<strong>依赖</strong>的软件包，<prgn>dpkg</prgn>会拒绝完成安装（通过执行它的“configure”动作）直至安装完所需的软件包。

<p>然而，对有些软件包，<prgn>dpkg</prgn>会拒绝解包，除非关联问题被解决。这种软件包就称为“pre-depend”于其它软件包。Debina提供这种机制是为了支持系统从<tt>a.out</tt>格式向ELF格式安全升级，在该过程中软件包的解包<strong>顺序</strong>至关重要。对于某些重大升级这种机制也很有用，例如对那些“required”级并有libc关联的软件包。

<p>再次，更多详细信息参阅Packaging Manual。

<sect1 id="pkgstatus">软件包状态
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p>软件包有各种状态：“unknown”，“install”，“remove”，“purge”和“hold”。这些“希望”标记描述了用户打算如何操作这些软件包（既可以使用<prgn>dselect</prgn>的“Select”菜单，也可以直接调用<prgn>dpkg</prgn>）。

<p>它们的意思是：
<list compact>
  <item><strong>unknown</strong>  - 用户并没描述他想对软件包进行什么操作。
  <item><strong>install</strong>  - 用户希望对软件包进行安装或升级。
  <item><strong>remove</strong>   - 用户希望删除软件包，但不想删除任何配置文件。
  <item><strong>purge</strong>    - 用户希望完全删除软件包，包括配置文件。
  <item><strong>hold</strong>     - 用户希望软件包保持现状，例如，用户希望保持当前的版本，当前的状态，当前的一切。
</list>

<sect1 id="puttingonhold">阻止软件包升级
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>有两种方法阻止软件包升级，使用<prgn>dpkg</prgn>，或者在Woody中使用APT。

<p>使用<prgn>dpkg</prgn>，首先导出软件包选择列表：
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
接着编辑文件<file><var>selections.txt</var></file>，修改想要恢复的软件所在的行，例如<package/libc6/，则将：
<example>
libc6                       install
</example>
改为：
<example>
libc6                       hold
</example>
保存文件，将它装入<prgn>dpkg</prgn>数据库：
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
或者，如果你知道要恢复的软件包名称，执行：
<example>
echo libc6 hold | dpkg --set-selections
</example>
这个命令将在每个软件包安装过程中保持该软件包不变。

<p>使用<prgn>dselect</prgn>也可以达到同样的效果。进入[S]elect屏幕，找到想阻止其升级的软件包，按“=”键（或者“H”）。更改在你退出[S]elect屏幕后立即生效。

<p>Woody中的APT系统有一个新机制来阻止软件包升级，在下载升级档进程中使用<tt>Pin-Priority</tt>。参阅帮助页面<manref name="apt_preferences"
section="5">，或阅读<url id="&apt-howto;">或<package>&p-apt-howto;</package>软件包。

<sect1 id="sourcepkgs">源码包

<p>
源码包发布在<tt>source</tt>目录中，既可以手工下载可以使用
<example>
apt-get source <var>foo</var>
</example>
获取它们（参阅<manref name="apt-get" section="8">帮助页面）。


<sect1 id="sourcebuild">编译源码包

<p>对于<tt><var>foo</var></tt>软件包，从源码编译需要<file><var>foo_*</var>.dsc</file>、<file><var>foo_*</var>.tar.gz</file>和<file><var>foo_*.diff</var>.gz</file>文件（注意，对于由Debian开发的软件包，没有<tt>.diff.gz</tt>文件）。

<p>当你得全了这些文件，如果你这安装了<package/dpkg-dev/软件包，运行：
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
它将软件包解压到一个名为<tt><var>foo-version</var></tt>的目录。

<p>使用下列命令创建二进制软件包：
<example>
$ cd foo-version
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
然后，
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
安装新编译的软件包。参阅<ref id="port">。

<!-- woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">新建Debian软件包

<p>创建新软件包的详细信息，参阅New
Maintainers' Guide，该文档在<package/maint-guide/包中，或浏览<url id="&maint-guide;" name="&urlname;">。
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Debian系统升级

<p>Debian的设计目标之一就是提供一个一致的升级途径和安全的升级过程，我们致力于旧版本的平滑升级，软件包在升级过程中会将重要信息反馈给用户，并提供一个可能的解决方案。

<p>你也应该阅读发布手记（Release Notes），该文档描述了升级的详细情况，它存在于所有的Debian光盘中，也可以通过互联网访问<url id="&stable-release;">或<url id="&testing-release;">。

<p><ref id="package">提供了升级的实用指南，本节只作基础细节的介绍。

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">系统升级方法

<p>你可以简单的执行匿名FTP或用<prgn>wget</prgn>查找想安装的Debian包文件，然后下载，用<prgn>dpkg</prgn>装上。（注意<prgn>dpkg</prgn>随时随地都能安装升级文件，甚至是正在运行的系统上）然而，有时安装修订包需要先安装其它软件包的新版本，这时安装就会停止，直到所需的软件包被安装好。

<p>许多人觉得这种手工安装太费时，加上Debian软件包升级是那样频繁&mdash;通常，每周会上载十几个新软件包。在新版本发布前期更新量更是加倍。为了跟上更新速度，许多用户更乐意使用自动化升级工具。基于此目的出现了几种专门的软件包管理工具。

<sect1 id="pkgtools">软件包管理工具概述

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>Debian软件包管理系统有两个设计目标：实现对软件包文件和包中文件的操作。APT和<prgn>dselect</prgn>完成前者，<prgn>dpkg</prgn>完成后者。

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>它是操作软件包文件的主要工具；参阅<manref name="dpkg" section="8">获得完整信息。
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn>由几个原始的辅助程序演化而来。

<list>
<item>dpkg-deb：操作<tt>.deb</tt>文件。<manref name="dpkg-deb" section="1">
<item>dpkg-ftp：一个旧的软件包获取命令。<manref name="dpkg-ftp" section="1">
<item>dpkg-mountable：一个旧的软件包获取命令。<manref name="dpkg-mountable" section="1">
<item>dpkg-split：将大软件包分割成小包。<manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn>和<prgn>dpkg-mountable</prgn>已被新的APT系统取代。

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT（the Advanced Packaging Tool）是Debian软件包管理系统的高级界面，由几个名字以“apt-”打头的程序组成。<prgn>apt-get</prgn>、<prgn>apt-cache</prgn>和<prgn>apt-cdrom</prgn>是处理软件包的命令行工具，它们也是其它用户前台程序的后端，如<prgn/dselect/和<prgn/aptitude/。

<p>更多信息，可安装<package/apt/软件包后阅读<manref name="apt-get" section="8">、<manref name="apt-cache" section="8">、<manref name="apt-cdrom" section="8">、<manref name="apt.conf" section="5">、<manref name="sources.list" section="5">、<manref name="apt_preferences" section="5">(woody)以及<file>/usr/share/doc/apt/guide.html/index.html</file>。

<p>另一个资源是<url id="&apt-howto;" name="APT HOWTO">，如果安装了<package/apt-howto/包，可在<file>&f-apt-howto;</file>中找到它。

<p><tt>apt-get upgrade</tt>和<tt>apt-get dist-upgrade</tt>只获取“Depends”类软件包，它忽略“Recommend”和“Suggests”类软件包，不想这样的话，可使用<prgn>dselect</prgn>。

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>这个程序是Debian软件包管理系统中菜单驱动的用户界面。特别适用于首次安装和大面积升级。参阅<ref id="dselect">。

<p>更多信息，可安装<package/install-doc/包后阅读<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file>或<url id="&dselect-beginner;" name="dselect Documentation for Beginners">。

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <tt>start-stop-daemon</tt> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">不停机系统升级

<p>&debian;系统的内核（文件系统）支持替换使用中文件。

<p>我们还提供了一个程序<prgn/start-stop-daemon/用来在系统启动时开启daemons或内核运行级别（runlevel）改变时停止daemons（例如：从multi-user级转到single-user级或关机）。当安装新软件包时如果该软件包中包含daemon安装，安装脚本会调用这个程序，停止运行中的daemons，然后在合适的时候重启它们。

<p>注意，Debian系统不要求用户在single-user模式下进行不停机升级。

<sect1 id="savedebs">下载和缓存<tt>.deb</tt>文件

<p>如果你手工下载包文件到硬盘（这完全没有必要，请阅读上面有关<prgn>dpkg-ftp</prgn>或APT的内容），当你完成软件包安装工作后，可以从系统中删除<tt>.deb</tt>文件。

<p>如果是使用APT，这些文件会缓存在<file>/var/cache/apt/archives/</file>目录中。你可以在完成安装后删除它们（<tt>apt-get clean</tt>）或者将它们拷贝到另一个机器的<file>/var/cache/apt/archives/</file>目录中以备以后的安装。

<sect1 id="keepingalog">升级记录

<p><prgn/dpkg/会对软件包的解包、配置、删除、完全删除进行记录，但不能（目前是这样）记录在包操作的过程中活跃终端的行为。

<p>最简单的解决方法是在运行<prgn>dpkg</prgn>、<prgn>dselect</prgn>、<prgn>apt-get</prgn>等工具的会话中加入<manref name="script" section="1">程序。

<sect id="boot">Debian系统引导进程

<sect1 id="init"><tt>init</tt>程序

<p>同所有的Unix一样，Debian启动要执行init程序。<tt>init</tt>的配置文件（<tt>/etc/inittab</tt>）中指定的第一个执行脚本应该是<tt>/etc/init.d/rcS</tt>。该脚本跟据<tt>/etc/rcS.d/</tt>目录中各脚本的扩展名回溯或分流子进程完成诸如检查并挂载文件系统、装载内核模块、启动网络服务、设定时钟等系统初始化工作。接着，为了兼容性考虑，它运行<tt>/etc/rc.boot/</tt>目录下的文件（除了那些文件名中包含“.”的文件），目录中的脚本通常是供系统管理员使用的，用于有兼容性问题的软件包。更多信息参见<ref id="init-hints">。

<sect1 id="runlevels">运行级别

<p>完成系统启动进程后，<tt>init</tt>执行默认运行级别（该运行级别由<tt>/etc/inittab</tt>中的<tt>id</tt>给出）指定的所有的启动脚本。同所有System V兼容Unix一样，Linux有7个运行级别：
<list compact>
  <item>0（关闭系统），
  <item>1（单用户模式 single-user mode），
  <item>2（各种多用户模式 multi-user modes），
  <item>6（重启系统）。
</list>
<p>
Debian系统运行<tt>id=2</tt>，它表示进入多用户模式时默认运行级别为2，所以将运行<tt>/etc/rc2.d/</tt>中的脚本。

<p>实际上，任意目录<file>/etc/rc<var>N</var>.d/</file>中的脚本都是指向<file>/etc/init.d/</file>的符号链接。然而，每个<file>/etc/rc<var>N</var>.d/</file>目录中文件的<strong>名称</strong>用来指定<file>/etc/init.d/</file>相应脚本的运行<strong>方式</strong>。特别是，在进入任何运行级别之前，所有名称以“K”打头的脚本均被运行，这些脚本的工作是中止进程。然后，所有名称以“S”打头的脚本被运行，这些脚本的工作是启动进程。名称中跟在“K”或“S”后的两位数规定了脚本运行的先后次序，数字小的脚本先运行。

<p>采用这种工作方式是因为<tt>/etc/init.d/</tt>中的脚本均有一个参数规定脚本“start”、“stop”、“reload”、“restart”或“force-reload”，脚本按各自参数的赋值执行任务。这些脚本甚至可以在系统启动后用来控制多进程。

<p>例如，使用带“reload”参数的命令
<example>
# /etc/init.d/sendmail reload
</example>
发给sendmail daemon进程一个信号，要它重读配置文件。

<sect1 id="custombootscripts">自定义系统引导进程
<p>
Debian没有使用BSD风格的BSD-style
<tt>rc.local</tt>目录来自定义系统引导进程；它提供自己的自定义机制。

<p>假设系统要在启动时运行foo脚本，或进入指定的（System V）运行级别。那系统管理员可以这样：
<enumlist>
  <item>将<tt>foo</tt>脚本加入<file>/etc/init.d/</file>目录。
  <item>使用合适的参数运行Debian命令<prgn>update-rc.d</prgn>，这样就在（命令行指定的）<tt>rc<var>?</var>.d</tt>目录和<file>/etc/init.d/foo</file>之间建立了链接，这里<var>?</var>是0到6中的一个数字，对应于System V的各个运行级别。
  <item>重启系统。
</enumlist>

<p><tt>update-rc.d</tt>命令会在<tt>rc<var>?</var>.d</tt>目录中文件与<file>/etc/init.d/</file>目录中的脚本之间目录建立链接，每个链接名会以“S”或“K”打头，接下来是一个数字，再就是脚本名。当系统进入某个运行级别<var>N</var>时，<file>/etc/rc<var>N</var>.d/</file>中以“K”打头的脚本执行<tt>停止</tt>（stop）指令，接下来以“S”打头的脚本执行<tt>开始</tt>（start）指令。

<p>还可以这样来做，将脚本放在<file>/etc/init.d/</file>下然后使用<tt>update-rc.d foo defaults 19</tt>建立链接，让<tt>foo</tt>脚本在系统启动期间执行。参数<tt>defaults</tt>指默认运行级别，它可以是2到5中某个值。参数<tt>19</tt>确保<tt>foo</tt>在其它参数大于20的脚本之前执行。

<sect id="diverse">多样性支持
<p>
Debian提供几种途径，在不破坏系统的前提下满足系统管理员各种要求。
<list>
<item><prgn>dpkg-divert</prgn>，参阅<ref id="dpkg-divert">。
<item><prgn>equivs</prgn>，参阅<ref id="equivs">。
<item><prgn>update-alternative</prgn>，参阅<ref id="alternatives">。
<item><prgn>make-kpkg</prgn>可以支持多启动引导。参阅<manref name="make-kpkg" section="1">和<ref id="kernel-debian">。
</list>
Any files under <file>/usr/local/</file>目录下的所有文件均属于系统管理员，&debian;不会改动它们。<file>/etc</file>下的大部分（或全部）文件属于<tt>conffiles</tt>，&debian;不会在升级后覆盖它们，除非系统管理员明确要求覆盖。

<sect id="i18n">国际化
<p>
&debian;系统是国际化产品，不论是在控制台下还是在X下，它都提供多种语言的字符显示和输入支持。许多文档、帮助页面以及系统消息都被翻译成各种语言。在安装过程中，Debian提示用户选择安装语言（有时是当地语言变量）。
<p>
如果你安装的系统提供的语言特性支持不能满足你的需要，或者你要改变当前语言或安装别的键盘方案以适应你的语言，参阅<ref id="l10n">。

<sect id="kernel-details">Debian和系统内核
<p>
See <ref id="kernel">.

<sect1 id="non-debian-kernel">编译非Debian源码包内核代码

<p><!--Yes.  But you have-->
首先你必须了解Debian policy有关头文件的规定。

<p>Debian C libraries是依据<strong>内核</strong>头文件最新<strong>stable</strong>发布版创建的。

<p>例如，Debian 1.2发布版使用版本号为5.4.13的头文件。它基于所有Linux FTP文件站点发布的Linux内核源码包，这些源码包使用了最新的头文件。跟随内核源码发布的内核头文件位于<file>/usr/include/linux/include/</file>。

<p>如果你编译某个程序所用的内核头文件比<package/libc6-dev/提供的头文件还新，在编译时你必须在命令行中加上<tt>-I/usr/src/linux/include/</tt>。这些情况是存在的，例如，对于automounter daemon（<package/amd/）软件包而言，当新内核改变了对NFS的内部操作方式，<prgn>amd</prgn>需要知道这些改变。这时就需要引用新的内核头文件。

<sect1 id="customkernel">自定义内核创建工具

<p>对于希望（或必须）使用自定义内核的用户，推荐下载<package/kernel-package/软件包。该软件包包含了创建内核包的脚本。有了它，新建Debian内核镜像包只需在内核源码目录的一级目录运行
<example>
# make-kpkg kernel_image
</example>
在内核源码所在目录的顶层，执行下述命令可获得有关帮助
<example>
# make-kpkg --help
</example>
或阅读<manref name="make-kpkg" section="8">帮助页面以及<ref id="kernel">。

<p>如果所需的kernel-source-<var>version</var>（version代表内核版本号）包不存在，用户就得从Linux文件站点分别下载最新的（或需要的）内核源码。Debian的<file>initrd</file>启动脚本需要一个专门的内核路径调用<prgn>initrd</prgn>；参阅<url id="&bug-initrd;">。

<p>有关<package/kernel-package/包的用法详述见于<tt>/usr/doc/kernel-package/README</tt>。 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">多系统引导器
<p>
要使用多系统引导器如<package/grub/或<package/loadlin/，请将编译好的Linux内核<file>bzimage</file>拷贝到相应的地方（例如<file>/boot/grub</file>或MS-DOS分区）。
</sect1>

<sect1 id="custombootdisk">制做引导软盘

<p>Debian的<package/boot-floppies/软件包可以帮你制作一张自定义启动软盘，该软件包通常位于Debian FTP包文件站点的<tt>admin</tt>分类。软件包中的Shell脚本按<prgn>syslinux</prgn>格式制作启动软盘。对于那些使用MS-DOS格式化的软盘，其主引导扇区的记录将被修改为直接引导Linux（或是其它在盘中<tt>syslinux.cfg</tt>文件里的操作系统）。该软件包中的其它脚本可制作急救盘甚至重建基本系统。

<p>安装该软件包后，阅读<file>/usr/doc/boot-floppies/README</file>文件可获得更多信息。

<sect1 id="modules">模块加载规定

<p>Debian的<package/modconf/软件包提供了一个shell脚本（<file>/usr/sbin/modconf</file>），它可以用来自定义内核模块配置。该脚本使用菜单界面，用户通过它给出系统中可挂载设备驱动的有关细节，它再将这些细节信息生成<file>/etc/modules.conf</file>文件（其中列出了别名aliases和其它参数，用于连接各种模块），该配置文件用来加载<file>/etc/modutils/</file>目录下和<file>/etc/modules</file>（其中列出了需要在系统启动时加载的模块）目录的相关模块。

<p>新版的配置帮助文件可为构造自定义内核提供帮助，同样，<package/modconf/软件包中也有一系列帮助文件（位于<file>/usr/lib/modules_help/</file>目录下），告诉你如何对模块设定合适的参数。参阅<ref id="kernel-modules">中的例子。

<sect1 id="removeoldkernel">卸载旧内核

<p><tt>kernel-image-<var>NNN</var>.prerm</tt>脚本可用来检查当前运行的内核版本，以确定是否与你打算卸载的内核版本相同。因此你可以使用如下命令删除不想要的内核镜像包：

<example>
dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

（当然，要将<var>NNN</var>替换成你的内核版本号和修订版号。）
</sect>
