<!-- CVS revision of this document "$Revision: 1.15 $"  -->
<!-- CVS revision of original english document "1.100"  -->

<chapt id="system">Debian 基础

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for potato and woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
本章讲述非开发人员需要掌握的 Debian 系统基础知识。有关知识的权威参考，请参阅：
<p>
<list compact>
<item>Debian Policy Manual
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
<p>
</list>
列表见 <ref id="references">。

<p>
如果你想查阅简要的“how-to”解释文档，可直接跳到 <ref id="package"> 或其它相关章节。
<p>
本章的内容取自“Debian FAQ”，经过较大的改编，以适于普通 Debian 系统管理者上手。

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives"> Debian  文件

<sect1 id="dirtree">目录结构

<p>&debian; 软件包位于 <url id="&mirror-site;" name=" Debian 镜像站点"> 的目录树中，可通过 FTP 或 HTTP 访问它们。

<p>下列目录存在于任何 Debian 镜像站点的 <tt>debian</tt> 目录下：
<taglist>
  <tag><file>dists/</file>:
    <item>本目录包含“发行版”(distributions)，此处是获得 Debian 发布版本(releases)和已发布版本(pre-releases)的软件包的正规途径。有些旧软件包及 <tt>Contens-*.gz</tt> <tt>Packages.gz</tt> 等文件仍在其中。
  <tag><file>pool/</file>:
    <item>所有 Debian 发布版及已发布版的软件包的新的物理地址。
  <tag><file>tools/</file>:
    <item>一些 DOS 下的小工具，用于创建启动盘、硬盘分区、压缩/解压缩和启动 Linux。
  <tag><file>doc/</file>:
    <item> Debian 的基本文档，如 FAQ、错误报告系统使用说明等。
  <tag><file>indices/</file>:
    <item>维护人员文件和重载文件。
  <tag><file>project/</file>:
    <item>大部分为开发人员的资源，如：
    <taglist>
      <tag><file>project/experimental/</file>:        <item>本目录包含了处于开发中的软件包和工具，它们均处于 alpha 测试阶段。用户不应使用这些软件，因为即使是经验丰富的用户也会被搞得一团糟。
      <tag><file>project/orphaned/</file>:
        <item>已不再有人维护的软件包，它们已从发行版中孤立出来。
    </taglist>
</taglist>

<sect1 id="dists"> Debian 发行版

<p>通常在 <tt>dists</tt> 目录下有三个 Debian 发行版。它们是“stable”发行版，“testing”发行版，和“unstable”发行版。有时还有一个“frozen”发行版（目前它仅仅是“testing”发行版的一个开发状态）。每个发行版均定义成一个符号链接指向该目录相应的代号目录。

<sect1 id="stable"><tt>stable</tt> 发行版

<p><tt>stable</tt> 发行版软件包入口，&stabledebian; 被登记到 <tt>stable</tt> 目录(符号链接指向 <tt>&stablecodename;</tt> 目录)：
<list>
  <item><file>stable/main/</file>：本目录包含的软件包均属于最新 &debian; 系统官方发布版。

  <p>这些软件包均是“自由软件”－－即遵循 <url name=" Debian  自由软件准则" id="&social-contract;#guidelines">(缩写为 DFSG，安装 <package>&p-social-contract;</package> 之后，可以在 <file>&f-social-contract;</file> 找到该文档)。

  <item><file>stable/non-free/</file>：本目录包含不能依照 DFSG 来自由使用的软件包。

  <p>例如，有些软件包的许可证禁止其用于商业发行的。其它的可以再发行，但属于共享软件。

  <item><file>stable/contrib/</file>：本目录包含的软件包均遵循 DFSG 自由使用原则，但它们倚赖于<strong>不遵循</strong> DFSG 自由使用原则的软件包。
</list>
目前，在以上提到的目录之外，实际的软件包都存储在 <tt>pool</tt> 目录中(<ref id="pools">)。 

<p>现阶段 <tt>stable</tt> 发行版错误报告位于 <url id="&stable-problems;" name="Stable Problems"> 页面。


<sect1 id="testing"><tt>testing</tt> 发行版

<p><tt>testing</tt> 发行版软件包入口，处于 <tt>unstable</tt> 版本的 &testingdebian; 通过级别测试后登记到 <tt>testing</tt> 目录(符号链接指向 <tt>&testingcodename;</tt> 目录)。目前实际的软件包存储位置为 <tt>pool</tt> 目录(<ref id="pools">)。在 <file>testing</file> 下同样有 <file>main</file>、<file>contrib</file> 和 <file>non-free</file> 子目录，它们的作用与 <file>stable</file> 中的一样。

<p>这些软件包必须在构建时在所有架构中保持同步，而且保证是可以安装的；相比 <tt>unstable</tt> 中的对应版本，它们应该有更少的影响发行的(RC)错误。我们希望按照这种方式 <tt>testing</tt> 能始终保持为一个发布的候选版本。有关 testing 版本的更多信息见于 <url id="&testing-notes;">。

<p><tt>testing</tt> 发行版的最新消息发布在下列站点：
<list compact>
<item><url id="&update-excuses;" 
         name="更新理由">
<item><url id="&testing-problems;" 
         name="问题测试">
<item><url id="&release-critical;" 
         name="阻碍发布的错误">
<item><url id="&qa-base-bugs;" 
         name="基本系统错误">
<item><url id="&qa-standard-bugs;" 
         name="标准软件包和任务包错误">
<item><url id="&qa-bugs;" 
         name="其它错误记录">
</list>

<sect1 id="unstable"><tt>unstable</tt> 发行版

<p><tt>unstable</tt> 发行版软件包入口，sid 被登记到 <file>unstable</file> 目录(符号链接指向 <file>sid</file>)，上载的软件包在被移至 <file>testing</file> 目录前一直呆在这儿。当前实际的软件包存储位置为 <file>pool</file> 目录(<ref id="pools">)。在 testing 下同样有 <file>main</file>、<file>contrib</file> 和 <file>non-free</file> 子目录，它们的作用与 <file>stable</file> 中的一样。

<p><tt>unstable</tt> 发行版反映了系统的最新开发进展。欢迎广大用户使用并测试这些软件包，同时也提醒你们这些软件包还不完善。使用 <tt>unstable</tt> 发行版的好处就是你可以获得 &debian; 项目的最新更新 &mdash; 不过新东西也会出新问题，你得好坏兼收:-)

<p><tt>unstable</tt> 发行版的最新错误报告见于 <url id="&unstable-problems;" name="Unstable Problems"> 页面。

<!-- Above was enough
<sect1 id="sid">The "sid" distribution

<p><strong>sid</strong> or <strong>unstable</strong> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <strong>testing</strong>,
in order to be released in <strong>stable</strong> later on. sid contains packages
for both released and unreleased architectures.

<p>The name "sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen"><tt>frozen</tt> 发行版

<p>当 <tt>testing</tt> 发行版足够成熟了，它成为 frozen 发行版，表示这个版本不再加入新代码，只进行除错工作。同时，<file>dists</file> 目录中会建立新的 testing 发行版目录树，并命名新的版本代号。frozen 发行版再经过几个月的测试、更新、再冻结也称之为“循环测试”。

<p>我们将 frozen 发行版中可能延迟软件包或整个版本发布的错误都记录在案，一但错误总数低于可接受的最大值，frozen 发行版就晋升成 <tt>stable</tt>，新版本发布了，先前发布的版本成为过期版(obsolete)(并被移于相应的目录)。

<sect1 id="codenames"> Debian 发布版代号

<p>存在于<tt>dists</tt>目录下的物理目录名，例如<tt>&stablecodename;</tt>和<tt>&testingcodename;</tt>，就是“版本代号(codenames)”。当某个&debian;发行版处于开发阶段，它并没有版本号，取而代之的是版本代号。使用版本代号的目的在于简化建立&debian;发行版镜像的工作(如果 <tt>unstable</tt> 是一个真实目录，它的名字突然改变成 <tt>stable</tt>，许多文件不得不再次进行没必要的下载)。

<p>当前，<tt>stable</tt> 是一个指向 <tt>&stablecodename;</tt> 的符号链接，<tt>testing</tt> 是指向 <tt>&testingcodename;</tt> 的符号链接。也就是说 <tt>&stablecodename;</tt> 是当前的 stable 发行版，<tt>&testingcodename;</tt> 是当前的 testing 发行版。

<p><tt>unstable</tt> 发行版是指向 <tt>sid</tt> 的永久符号链接，即 unstable 发行版总称为 <tt>sid</tt>。<!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">已用过的发布版代号

<p>已使用过的发行版代号有：
<tt>buzz</tt> for release 1.1，
<tt>rex</tt> for release 1.2，
<tt>bo</tt> for releases 1.3.x，
<tt>hamm</tt> for release 2.0，
<tt>slink</tt> for release 2.1，
<tt>potato</tt> for release 2.2，
<tt>woody</tt> for release 3.0，和
<tt>sarge</tt> for release 3.1。


<sect1 id="sourceforcodenames">发布版代号来源

<p>到目前为止它们均出自 Pixar 的电影“<em>Toy Story</em>(Toy Story)”
<list compact>
  <item><strong>Buzz</strong>(Buzz Lightyear)是个宇航员，
  <item><strong>Rex</strong> 是只暴龙，
  <item><strong>Bo</strong>(Bo Peep)是个放羊的女孩，
  <item><strong>Hamm</strong> 是个小猪攒钱罐，
  <item><strong>Slink</strong>(Slinky Dog)是只玩具狗，
  <item><strong>Potato</strong> 当然就是 Potato Head 先生，
  <item><strong>Woody</strong> 是个牛仔，
  <item><strong>Sarge</strong> 是位绿色塑料玩具士兵首领，
  <item><strong>Etch</strong>(Etch-a-Sketch)是玩具黑板，
  <item><strong>Sid</strong> 是隔壁的男孩，那个玩具终结者。
</list>
<!--
  more info in http://www.pixar.com/feature/toystory/toystory.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools"><tt>pool</tt>目录

<p>过去，软件包均放在 <tt>dists</tt> 目录下相应发行版的子目录中。这种做法产生了许多问题，当镜像站点进行新版本发布时大量带宽被消耗。

<p>现在软件包均放进一个巨大的“池子(pool)”，按照源码包名称分类存放。为了方便管理，pool 目录下按属性再分类(<tt>main</tt>、<tt>contrib</tt>和<tt>non-free</tt>)，分类下面再按源码包名称的首字母归档。这些目录包含的文件有：运行于各种系统架构的二进制软件包，生成这些二进制软件包的源码包。

<p>你可以执行命令 <tt>apt-cache showsrc <var>mypackagename</var></tt>，查看“Directory:”行获知每个软件包的存放位置。例如：<package>apache</package> 软件包存放在 <file>pool/main/a/apache/</file> 软件包存放在 <tt>lib*</tt> 软件包数量巨大，它们以特殊的方式归档：例如，<package>libpaper</package> 软件包存放在 <file>pool/main/libp/libpaper/</file>。

<p>诸如 <tt>apt</tt> 等命令访问的索引文件仍位于 <tt>dists</tt> 目录中。

<p>通常，你大可不必注意这些，新版的 <prgn>apt</prgn> 和旧版 <prgn>dpkg-ftp</prgn> 会自动处理它们。想了解更多信息，参阅 <url id="&pool-faq;" name="RFC: 软件包仓库的实现">。

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history"><tt>sid</tt> 诞生记

<p>过去 <tt>sid</tt> 并不存在， Debian 文件组织有一个严重的缺点：假设在当前 <tt>unstable</tt> 发行版中创建了某个新的软件开发项目，当该发行版变成新的 <tt>stable</tt> 时，该软件开发项目将被发布。由于许多软件开发项目并不是这种情况，这样结果导致那些目录不得不在发布时移动。这是不切实际的，因为当移动目录时，大量带宽会被吞噬掉。

<p>经过几年的研究摸索，文档管理员提出一个方案，将未获准发布的新软件开发项目的二进制文档存入名为
<tt>sid</tt> 的特定目录。当它们首次发布时，将会建立一个从当前
<tt>stable</tt> 指向 <tt>sid</tt> 的链接。并从那时起，它们就会像通常的软件开发项目一样，在
<tt>unstable</tt> 目录树中创建。这个方案用户听起来的确有些晕头。

<p>有了软件包储藏池的帮助(参阅<ref id="pools">)，在 <tt>woody</tt> 发行版开发过程中，二进制软件包均按一定规范存放于 pool 目录，而与发行版无直接关系，当发布新版本时，就不会再出现大量带宽被消耗的问题。(不过，大量带宽还是被开发进程消耗了)。

<sect1 id="incoming"> 上载到 <file>incoming</file> 中的软件包
<p>
上载的软件包首先存放于 <url id="&incoming;"> 经过检收，确定它们是由 Debian 开发者上载的(对于那些属于无维护者上载(Non-Maintainer Upload 缩写 NMU)的软件包则放入 <file>DELAYED</file> 子目录)。会有一天，它们将从 <tt>incoming</tt> 移入 <tt>unstable</tt>。
<p>
在紧急情况下，你可能会等不及它们移入 <tt>unstable</tt> 而直接从 <tt>incoming</tt> 中下载安装。
</sect1>

<sect1 id="snapshot">找回旧软件包
<p>
最新的 Debian 发行版存放在任何一个 <url id="&mirror-site;" name=" Debian 镜像站点"> 的 <tt>debian</tt> 目录下。旧版本的 Debian 如 Slink 存放在 <url id="&archivehome;">或 Debian 镜像站点的 <tt>debian-archive</tt> 目录下。
<p>
旧的 <tt>testing</tt> 和 <tt>unstable</tt> 软件包存放在 <url id="&snapshothome;">。

</sect1>

<sect1 id="archsections">发布源目录结构
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>在每个主目录树下(<file>dists/stable/main</file>、<file>dists/stable/contrib</file>、<file>dists/stable/non-free</file>、<file>dists/unstable/main/</file>，等)按芯片架构又分了子目录，每个子目录中存放着在该芯片架构下编译的二进制软件包。

<list>
  <item><file>binary-all/</file>，存放与芯片架构无关的软件包，如 Perl 脚本、纯文档等。
  <item><file>binary-<var>platform</var>/</file>，存放运行于该平台的二进制软件包。
  <!-- Yes I simplified this -->
</list>

<p>请注意，发行版的二进制软件包不再存放在这些目录中，它们存放在上一级 <tt>pool</tt> 目录中。目录中仍保留有索引文件(<file>Packages</file>和<file>Packages.gz</file>)是为了向下兼容。

<p>要获得有关二进制架构技术支持，参阅各发行版的发布手记(Release Notes)，可以访问发布手记站点 <url id="&stable-release;" name="stable"> 和 <url id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">源代码

<p> Debian 系统中的一切程序都有源代码，不仅如此，许可证条款<strong>规定</strong>系统中所有的程序必须和其源代码一起发行，或提供源代码出售。

<p>通常源代码发布在 <tt>source</tt> 目录，该目录同时处于所有架构目录中，更新的源码则在 <tt>pool</tt> 目录中(参阅<ref id="pools">)。对于不太熟悉 Debian 归档目录结构的用户想获得源代码可以试试 <tt>apt-get source 
<var>mypackagename</var></tt> 命令。

<p>有些软件包，如著名的<package>pine</package>，由于许可证限制，只提供源码包。(最近，<package>pine-tracker</package> 软件包提供了一个简易的安装版)安装源码包的方法可参阅<ref id="port">，<ref
id="packaging">教你如何手工创建一个软件包。

<p><file>contrib</file> 和 <file>non-free</file> 目录中的软件包可能不提供源代码，因为它们没有正式加入 Debian 系统。

<sect id="pkg-basics"> Debian 软件包管理系统

<sect1 id="package-basics"> Debian 软件包概述

<p>软件包通常包含了实现一系列相关命令或特性所必须的所有的文件。有两种类型的 Debian 软件包：
<list>
  <item><strong>Binary packages</strong>(二进制软件包)，它包含可执行文件、配置文件、man/info 页面、版权声明和其它文档。这些软件包以 Debian 特定的格式发布(参阅<ref id="deb-format">)；它们通常使用 <tt>.deb</tt> 的扩展名以示区别。这种二进制软件包可使用 Debian 工具 <tt>dpkg</tt> 解包，详情见有关帮助页面。
  
  <item><strong>Source packages</strong>(源码包)，包含一个 <tt>.dsc</tt> 文件它用于描述源码包(包括下列文件的名称)，一个 <tt>.orig.tar.gz</tt> 文件它是未经修改的原始源代码压缩文件，以及一个 <tt>.diff.gz</tt> 文件它包含了该软件包 Debian 化时所做的修改。<tt>dpkg-source</tt> 工具可用于打包/解包 Debian 源码包，详情可参阅有关帮助页面。
</list>

<p>软件包管理系统安装的软件包时需要使用“倚赖关系”，它由软件包维护者声明。这些信息记录在与每个软件包关联的 <file>control</file> 文件中。例如，包含 GNU C 编译器(gcc)的软件包依赖于包含链接器和汇编器的 <package>binutils</package> 软件包。如果用户试图在没有安装 <package>binutils</package> 的情况下安装 <package>gcc</package>，软件包管理系统(dpkg)将会显示一条错误信息，告诉你需要安装 <package>binutils</package>，并停止安装 <package>gcc</package>。(不过，倔强的用户可以对这个信息视而不见，参阅<manref name="dpkg" section="8">)。)更多信息，参阅下面的章节<ref id="depends">。

<p> Debian 软件包管理工具可用于：
<list>
  <item>操作和管理软件包或软件包的局部内容，
  <item>帮助那些使用有限容量载体如软盘传输的用户分割软件包，
  <item>帮助开发者将开发文件打包成软件包，
  <item>帮助用户从远程<!--FTP--> Debian 文档站点安装软件包。
</list>

<sect1 id="deb-format"> Debian <!--binary-->软件包格式

<p> Debian “软件包”，或称之为 Debian 包文件( Debian  archive file)，包含了可执行文件、库文件、和相关程序的文档。通常 Debian 文件的文件名以 <tt>.deb</tt> 结尾。
<footnote>
<!-- Below added by Osamu based on a message posted by Colin Watson -->
<prgn>debian-installer</prgn> 项目引入了文件名以 <tt>.udeb</tt> 结尾的软件包。
简而言之，这是一种不需要完全遵循 Debian 策略的 <tt>.deb</tt> 宏格式。它缺少一些应有的内容，比如文档；这是因为它只供给 <prgn>debian-installer</prgn>--最开始为 Sarge 发布版开发的 Debian 安装程序－－使用。
<tt>.deb</tt> 和 <tt>.udeb</tt> 文件格式是完全相同的。使用 <tt>.udeb</tt> 软件包的 <prgn>udpkg</prgn> 程序是标准 <prgn>dpkg</prgn> 的精简版，它的功能更有限，只支持部分软件包的倚赖关系。
之所以有不同的命名，是因为 Debian 的档案库维护者不喜欢库里出现不遵循政策的 <tt>.deb</tt>；通过不同的命名，可以强调出这两者的差异；而且也可以减少不知情的人把它安装到实际系统中的情况。<tt>.udeb</tt> 文件位于最初的内存磁盘(ramdisk)中，用来在基本系统安装时创建一个非常有限的 Debian 系统。
</footnote>

<p> Debian 二进制软件包内部格式描述见 <manref name="deb" section="5">帮助页面。由于这种内部格式会改变的(特别对于 &debian; 的新旧发布版)，所以要操作 <tt>.deb</tt> 文件请参阅 <manref name="dpkg-deb" section="1">。

<!-- Below added by Osamu Not sure but should be right -->

<p>即便在 Sarge 发行版中，当 <prgn>dpkg</prgn> 命令不可用时，所有的 Debian 软件包文件依然可以用标准的 Unix 命令 <prgn>ar</prgn> 和 <prgn>tar</prgn> 来操作。


<sect1 id="pkgname"> Debian 软件包命名约定
<!--
Why are  Debian  package file names so long? 
-->
<p> Debian <!--binary-->软件包命名遵循下列约定：
<example>
<var>foo</var>_<var>ver</var>-<var>rev</var>_<var>arch</var>.deb
</example>
一般这里的 <var>foo</var> 是软件包的名称，<var>ver</var> 是软件本身的版本号，<var>rev</var> 是 Debian 修订版本号，<var>arch</var> 是目标架构名称。当然，文件很容易被改名；不过，你也可以通过运行下面的命令来找出文件 <var>filename</var> 实际是那个软件包：
<example>dpkg --info <var>filename</var></example>

<p> Debian 修订版本号由 Debian 开发者或创建这个软件包的人指定。通常，包被修改过之后，会把修改版本号加一。

<!-- This get too detailed
<sect1 id="controlfile">The  Debian  control file
-->

<sect1 id="conffile">保存本地配置
<!--
What is a  Debian  conffile
-->
<p>有可能被本机管理员修改的文件保存在 <file>/etc/</file> 目录中。
&debian; 策略中规定所有对本地配置文件的修改都可以在软件包升级过程中被保留下来。
<p>
在软件包的发布中，如果包含默认的本地配置文件，这个文件就被称为“conffile”(默认配置)。如果不得到管理员的允许，软件包管理系统不会对上次安装之后被修改过的默认配置进行升级；不过，如果管理员没有改动过默认配置，那么它就会被升级成最新软件包中的版本。这种策略几乎总是合理的，它有益于把默认配置的改动减到最小。

<p>下面的命令可以列出一个软件包中包含那些默认配置文件：
<example>
dpkg --status <var>package</var>
</example>
文件列表位于“Conffiles”的后面。

<p>
在《 Debian 策略手册》的“配置文件”一节，可以获得有关 conffile (默认配置)文件的更多信息(参见<ref id="references">)。

<sect1 id="maintscripts"> Debian 维护脚本
<!--
What is a  Debian  preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
 Debian 维护脚本是一种可执行脚本，它在软件包安装之前或之后自动运行。它和一个名叫 <tt>control</tt> 的文件一起组成 Debian 包文件的“管理”部分。

<p>这些文件是：
<taglist>
<tag>preinst
 <item>在 Debian 包（<tt>.deb</tt>）文件解包之前，运行这个脚本。许多“preinst”脚本的任务是停止作用于待升级软件包的服务，直到软件包安装或升级完成。

<tag>postinst
 <item>该脚本的任务是完成 Debian 包（<tt>.deb</tt>）文件解包文件的配置工作。通常，“postinst”脚本等待用户输入，或提醒用户，如果他接受当前默认值，要记得软件包安装完后返回重新配置。许多“postinst”脚本负责执行有关命令为新安装或升级的软件重启服务。

<tag>prerm
  <item>该脚本负责停止与软件包关联的 daemon 服务。它在删除软件包关联文件之前执行。

<tag>postrm
  <item>该脚本负责修改软件包链接或文件关联，或删除由它创建的文件。(参阅<ref id="virtual">)。
</taglist>

<p>当前，所有的管理文件都存放在 <file>/var/lib/dpkg/info</file> 目录。与 <tt>foo</tt> 软件包相关的文件，名字以“foo”打头，以“preinst”、“postinst”等为扩展名。目录中的 <tt>foo.list</tt> 文件列出了 <tt>foo</tt> 软件包安装的所有文件。(注意这些文件的位置在由dpkg来确定，可能会因 Debian 版本而异)

<sect1 id="priority">软件包优先级
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>每个 Debian 软件包均被发布者指定了一个<strong>优先级</strong>，作为软件包管理系统
的一个辅助参数，优先级的值有：

<list>
  <item><strong>Required</strong>(必须) 该级别软件包是保证系统正常运行必须的。    <p>包含所有必要的系统修补工具。不要删除这些软件包，否则整个系统将受到损坏，甚至无法使用<prgn>dpkg</prgn>恢复。只安装 Required 级软件包的系统不可能满足所有的用途，但它可以启动起来，让系统管理员安装想要的软件。
  <item><strong>Important</strong>(重要) 在任何类 Unix 系统上均安装有该级别软件包。
   <p>系统若缺少这类软件，会运行困难或不能使用。该级别软件包并<strong>不</strong>包括 Emacs 或 X11 或 TeX 或其它大型应用程序。它们只是一些实现系统底层功能的程序。
  <item><strong>Standard</strong>(基本) 该级别软件包是任何 Linux 系统的标准件，它们组成一个小而精的字符模式的系统。
    <p>系统的默认安装就包括了它们。“Standard”级软件包不包括许多大型应用程序，但它包括Emacs(它比其它应用程序更底层)和 Tex 及 LaTeX 的精巧版(不支持 X)。
  <item><strong>Optional</strong>(推荐) 该级别软件包包括那些你可能想安装的软件，即使对它们并不熟悉,但对它们没有特殊的要求。
    <p>它们包括 X11，TeX 完整发布版和许多应用程序。
  <item><strong>Extra</strong>(额外) 该级别软件包可能与其它高级别软件包冲突，仅当你知道其用途时才会使用它们，或者有运行它们有专门要求，这些都使它们不适合定为“Optional”级。
</list>
<p>请注意软件包描述中“Priority: required”(优先级：必须)、“Section: base”(组件：基本)、“Essential: yes”(必要：是)的区别。“Section: base”(组件：基本)意味着在安装新系统时这个软件包要先于其它所有软件安装。大多数在“Section: base”中的软件包都被打上了“Priority: required”(优先级：必须)标签，或者至少是“Priority: important”(优先级：重要)；并且其中的很多也同时具有“Essential: yes”(必要：是)标签。“Essential: yes”意味着要用软件包管理系统的 <prgn>dpkg</prgn> 等程序删除它时，必须给出额外的强制选项才行。比如，<package>libc6</package>、<package>mawk</package> 和 <package>makedev</package> 软件包属于“Priority: required”和“Section: base”，但不是“Essential: yes”。

<sect1 id="virtual">虚拟软件包

<p>虚拟软件包是一个统称，它代指一组具有相近功能的软件包中的任何一个。例如，<prgn>tin</prgn> 和 <prgn>trn</prgn> 都是新闻组阅读软件，当系统中某个程序需要使用新闻阅读器时，它们中的任何一个都可以满足要求。因此，这两个软件包一起提供了一个叫做 <package>news-reader</package>(新闻阅读器)的“虚拟软件包”。

<p>类似的，许多 <package>exim</package>、<package>exim4</package>、<package>sendmail</package>、<package>postfix</package> 这样的软件包都提供邮件传输代理的功能。因此，它们在一起提供了一个称为 <package>mail-transport-agent</package>(邮件传输代理)的虚拟包。安装了它们中的任何一个，都会满足其它倚赖于邮件传输代理功能的程序的需要。

<p> Debian 有个机制，如果系统中提供同种虚拟包的软件包安装了多个，系统管理员可以指定一个为首选软件。相关的命令是 <prgn>update-alternatives</prgn>，更详细的描述参阅<ref id="alternatives">。

<sect1 id="depends">软件包依赖关系
<p> Debian 软件包管理系统依赖声明，它描述了这一事实：一些软件包需要其它软件包被安装才能正常运行或运行得更好。
<list>
 <item>软件包 A <strong>依赖</strong>(depends)软件包 B：要运行A必须安装 B。在有些情况下，A 不仅依赖 B，还要求 B 的特定版本。版本依赖通常有最低版本限制，A 更依赖于B的最新版而非某个特定版本。
 
 <item>软件包 A <strong>推荐</strong>(recommends)软件包 B：软件包维护者认为所有用户都不会喜欢缺少某些功能的 A，而这些功能需要 B 来提供。
 
 <item>软件包 A <strong>建议</strong>(suggests)软件包 B：B 中某些文件与 A 的功能相关，并能够增强 A
 的功能。这种关系通过声明软件包 B <strong>增强 Enhances</strong> 软件包 A 来表示。
 
 <item>软件包 A 与软件包 B <strong>冲突</strong>(conflicts)：如果系统中安装了 B 那么 A 无法运行。“Conflicts”常和“replaces”同时出现。
 
 <item>软件包 A <strong>替换</strong>(replaces)软件包 B：B 安装的文件被 A 中的文件移除和覆盖了。
 
 <item>软件包 A <strong>提供</strong>(provides)软件包 B：A 中包含了 B 中的所有文件和功能。
</list>

<p>上述术语使用方法的更详细的信息参阅 <em>Packaging Manual</em> 和 <em>the Policy Manual</em>。

<p>注意，<prgn>aptitude</prgn> 和 <prgn>dselect</prgn> 可以对 <strong>recommends</strong> 和 <strong>suggests</strong> 类软件包进行更细粒度的操作，<file>apt-get</file> 只会简单的下载安装 <strong>depends</strong> 类软件包而不管 <strong>recommends</strong> 和 <strong>suggests</strong> 类软件包。这两个程序均正式使用 APT 作为其后端。

<sect1 id="pre-depends">何为“Pre-depends”

<p><prgn>dpkg</prgn> 总是在配置一个有依赖关系的包之前，先对被依赖的包进行配置。
然而，<prgn>dpkg</prgn> 通常将归档文件随意解包，不顾依赖性。
(从归档文件中解包并提取文件，将他们放置到正确的位置。)
如果是 <strong>Pre-Depends</strong> 包，则在所依赖的其它包被解包和配置之前，
Pre-Depends 包不会被解包。

<footnote>
Debina 提供这种机制是为了支持系统 从<tt>a.out</tt> 格式向 ELF 格式安全升级，在该过程中软件包的解包<strong>顺序</strong>至关重要。
</footnote>

使用这种依赖的目的是为了将依赖复杂性降至最低。

<sect1 id="pkgstatus">软件包状态
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p>软件包有各种状态：“unknown”，“install”，“remove”，“purge”和“hold”。这些“希望”标记描述了用户打算如何操作这些软件包(既可以使用 <prgn>dselect</prgn> 的“Select”菜单，也可以直接调用 <prgn>dpkg</prgn>)。

<p>它们的意思是：
<list compact>
  <item><strong>unknown</strong>  - 用户并没描述他想对软件包进行什么操作。
  <item><strong>install</strong>  - 用户希望对软件包进行安装或升级。
  <item><strong>remove</strong>   - 用户希望删除软件包，但不想删除任何已有的配置文件。
  <item><strong>purge</strong>    - 用户希望完全删除软件包，包括配置文件。
  <item><strong>hold</strong>     - 用户希望软件包保持现状，例如，用户希望保持当前的版本，当前的状态，当前的一切。
</list>

<sect1 id="puttingonhold">阻止软件包升级
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>有两种方法阻止软件包升级，使用 <prgn>dpkg</prgn>，或者在 Woody 中使用 APT。

<p>使用 <prgn>dpkg</prgn>，首先导出软件包选择列表：
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
接着编辑文件 <file><var>selections.txt</var></file>，修改想要恢复的软件所在的行，例如 <package>libc6</package>，则将：
<example>
libc6                       install
</example>
改为：
<example>
libc6                       hold
</example>
保存文件，将它装入 <prgn>dpkg</prgn> 数据库：
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
或者，如果你知道要恢复的软件包名称，执行：
<example>
echo libc6 hold | dpkg --set-selections
</example>
这个命令将在每个软件包安装过程中保持该软件包不变。

<p>使用 <prgn>dselect</prgn> 也可以达到同样的效果。进入 [S]elect 屏幕，找到想阻止其升级的软件包，按“=”键(或者“H”)。更改在你退出 [S]elect 屏幕后立即生效。

<p>Woody 中的 APT 系统有一个新机制来阻止软件包升级，在下载升级档进程中使用 <tt>Pin-Priority</tt>。参阅帮助页面 <manref name="apt_preferences"
section="5">，或阅读 <url id="&apt-howto;"> 或 <package>&p-apt-howto;</package>软件包。

<sect1 id="sourcepkgs">源码包

<p>
源码包发布在 <tt>source</tt> 目录中，既可以手工下载可以使用
<example>
apt-get source <var>foo</var>
</example>
获取它们(参阅<manref name="apt-get" section="8">帮助页面)。


<sect1 id="sourcebuild">编译源码包

<p>对于 <tt><var>foo</var></tt> 软件包，从源码编译需要 <file><var>foo_*</var>.dsc</file>、<file><var>foo_*</var>.tar.gz</file> 和 <file><var>foo_*.diff</var>.gz</file> 文件(注意，对于由 Debian 开发的软件包，没有 <tt>.diff.gz</tt> 文件)。

<p>当你得全了这些文件，如果你这安装了 <package>dpkg-dev</package> 软件包，运行：
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
它将软件包解压到一个名为 <tt><var>foo-version</var></tt> 的目录。

<p>使用下列命令创建二进制软件包：
<example>
$ cd foo-version
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
然后，
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
安装新编译的软件包。参阅 <ref id="port">。

<!-- woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">新建 Debian 软件包

<p>创建新软件包的详细信息，参阅
<em>New Maintainers' Guide</em>，
该文档在 <package>maint-guide</package> 包中，或浏览 <url id="&maint-guide;" name="&urlname;">。
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
 Debian  claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a  Debian  system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate"> Debian 系统升级

<p> Debian 的设计目标之一就是提供一个平滑、安全和可靠的升级过程。软件包系统在升级过程中会将重要改变警告系统管理员，在某些情况下，会要系统管理员来做决定。

<p>你也应该阅读发布手记（Release Notes），它存在于所有的 Debian 光盘中，也可以通过互联网访问 <url id="&stable-release;"> 或 <url id="&testing-release;">。

<p><ref id="package">提供了升级的实用指南，本节只提供一个大纲，由包工具开始。

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>它是操作软件包文件的主要工具；参阅 <manref name="dpkg" section="8">
获得完整信息。
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> 由几个原始的辅助程序演化而来。

<list>
<item><prgn>dpkg-deb</prgn>：操作 <tt>.deb</tt> 文件。<manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>：一个旧的软件包获取命令。<manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>：一个旧的软件包获取命令。<manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>：将大软件包分割成小包。<manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> 和 <prgn>dpkg-mountable</prgn> 已被新的 APT 系统取代。

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT(the Advanced Packaging Tool)
是 Debian 软件包管理系统的高级界面，由几个名字以“apt-”打头的程序组成。<prgn>apt-get</prgn>、<prgn>apt-cache</prgn> 和 <prgn>apt-cdrom</prgn> 是处理软件包的命令行工具，它们也是其它用户前台程序的后端， 如<prgn>dselect</prgn> 和 <prgn>aptitude</prgn>。

当前，推荐使用 <prgn>aptitude</prgn> 作为系统维护的工具。

<p>更多信息，可安装 <package>apt</package> 和 <package>aptitude</package>
软件包后阅读 
<manref name="aptitude" section="8">、
<manref name="apt-get" section="8">、<manref name="apt-cache" section="8">、<manref name="apt-cdrom" section="8">、<manref name="apt.conf" section="5">、<manref name="sources.list" section="5"> 和
<manref name="apt_preferences" section="5">。

<p>另一个资源是 <url id="&apt-howto;" name="APT HOWTO">，如果安装了 <package>apt-howto</package> 包，可在 <file>&f-apt-howto;</file> 中找到它。

<p><tt>apt-get upgrade</tt> 和 <tt>apt-get dist-upgrade</tt> 只获取“Depends”类软件包，它忽略“Recommend”和“Suggests”类软件包，不想这样的话，可使用 <prgn>dselect</prgn>。

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>这个程序是 Debian 软件包管理系统中菜单驱动的用户界面。特别适用于首次安装和大面积升级。参阅 <ref id="dselect">。

<p>更多信息，可安装 <package/install-doc/ 包后阅读 <file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> 或 <url id="&dselect-beginner;" name="dselect Documentation for Beginners">。

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
 Debian  has a <tt>start-stop-daemon</tt> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">不停机系统升级

<p>&debian; 系统的内核(文件系统)支持替换使用中的文件。
当一个软件包升级时，如果由该软件包提供的服务在当前运行级下正在运行，则该服务将被重新启动。
Debian 系统不要求用户在 single-user 模式下进行不停机升级。

<sect1 id="savedebs">下载和缓存 <tt>.deb</tt> 文件

<p>如果你手工下载包文件到硬盘(这完全没有必要，请阅读上面有关 <prgn>dpkg-ftp</prgn> 或 APT 的内容)，当你完成软件包安装工作后，可以从系统中删除 <tt>.deb</tt> 文件。

<p>如果是使用 APT，这些文件会缓存在 <file>/var/cache/apt/archives/</file> 目录中。你可以在完成安装后删除它们(<tt>apt-get clean</tt>)或者将它们拷贝到另一个机器的 <file>/var/cache/apt/archives/</file> 目录中以备以后的安装。

<sect1 id="keepingalog">升级记录

<p><prgn/dpkg/ 会对软件包的解包、配置、删除、完全删除进行记录，但不能(目前是这样)记录在包操作的过程中活跃终端的行为。

<p>最简单的解决方法是在运行 <prgn>dpkg</prgn>、<prgn>dselect</prgn>、<prgn>apt-get</prgn> 等工具的会话中加入 <manref name="script" section="1"> 程序。

<sect id="boot"> Debian 系统引导进程

<sect1 id="init"><tt>init</tt> 程序

<p>同所有的类 Unix 一样， Debian 通过执行 init 程序，来完成启动过程。<tt>init</tt> 的配置文件(<tt>/etc/inittab</tt>)中指定的第一个执行脚本应该是 <file>/etc/init.d/rcS</file>。
<p>
接下来将要发生要看是否安装了 <package>sysv-rc</package> 软件包或 <package>file-rc</package>
软件包。下面假设安装了 <package>sysv-rc</package> 软件包。
(<package>file-rc</package> 含有它自己的
<file>/etc/init.d/rcS</file> 脚本，在 rc 
目录里使用文件代替符号链接来控制哪个服务在哪个运行级别启动。)
<p>
<package>sysv-rc</package> 软件包里面的 <file>/etc/init.d/rcS</file>
运行 <file>/etc/rcS.d/</file> 目录下的所有脚本来执行初始化，如：
检查并挂载文件系统、装载内核模块、启动网络服务、设定时钟等。
接着，为了兼容性考虑，它运行 <file>/etc/rc.boot/</file> 目录下的文件(除了那些文件名中包含“.”的文件)，该目录中的脚本是保留给系统管理员使用，不赞成使用该目录。
更多信息参见 <ref id="init-hints"> 和 Debian Policy Manual 中的
<url id="&sysvinit;" name="System run levels and init.d scripts">
<p>
Debian 没有使用 BSD 风格的 <tt>rc.local</tt> 文件。

<sect1 id="runlevels">运行级别

<p>完成系统启动进程后，<tt>init</tt> 启动所有在默认运行级别配置为启动的服务。
默认运行级别由 <file>/etc/inittab</file> 中的 <tt>id</tt> 给出。
Debian 使用 <tt>id=2</tt>。
<p>
Debian 使用下列的运行级别：
<list compact>
  <item>1(单用户模式 single-user mode)，
  <item>2 到 5(多用户模式 multi-user modes)，
  <item>0(关闭系统)，
  <item>6(重启系统)。
</list>
运行级 7、8 和 9 也能够使用，但是它们的 rc 目录在软件包安装的时候没有。
<p>
使用 <prgn>telinit</prgn> 命令来转换运行级别。
<p>
当进入一个运行级别时，所有在 <file>/etc/rc<var>runlevel</var>.d/</file> 
目录下的脚本将被执行。
脚本名的第一个字母决定了该脚本的运行<strong>方式</strong>：
使用 <tt>K</tt> 开头的脚本，使用 <tt>stop</tt> 参数来运行。
使用 <tt>S</tt> 开头的脚本，使用 <tt>start</tt> 参数来运行。
这些脚本按照它们名字的字母顺序运行；因此，“stop”脚本比“start”脚本先运行。
在 <tt>K</tt> 或 <tt>S</tt> 之后的两个数字决定了脚本运行的先后次序，数字小的脚本先运行。

<p>
实际上，目录 <file>/etc/rc<var>runlevel</var>.d/</file> 中的脚本都是指向 <file>/etc/init.d/</file> 的符号链接。这些脚本接受 
“restart”和“force-reload”作为参数：“force-reload”的方式可以用来在系统启动后，重新启动服务或者强迫它们重新装载它们的配置文件。

<p>例如:
<example>
# /etc/init.d/exim4 reload
</example>

<sect1 id="custombootscripts">自定义运行级别
<p>
自定义运行级别是一个高级的系统管理任务。
下面的提示适用于大部分服务。
<p>
在运行级 <var>R</var> 启动 <var>service</var> 服务，创建一个符号链接
<file>/etc/rc<var>R</var>.d/S<var>xy</var><var>service</var></file> 
到目标文件
<file>../init.d/<var>service</var></file>。
<var>xy</var> 是序列号，是由软件包在安装的时候分配给服务的。 
<p>
停止服务，重命名符号链接，将它的名字用 <tt>K</tt> 开头来代替 <tt>S</tt>，
它的序列号是100减 <var>xy</var>。
可以使用象 
<prgn>sysv-rc-conf</prgn> 或 <prgn>ksysv</prgn>
这样的运行级别编辑器来方便的修改服务。
<p>
在一个特定的运行级别目录，可以将某个服务的 <tt>S</tt>
符号链接删除来代替重新命名它。
这种作法不停止该服务，但将把该服务留在一种
<package>sysv-rc</package> 初始化系统认为的“漂浮”状态：
当运行级别改变时，该服务即不会启动，也不会停止，
它将保留它原有的状态，不管它是在运行或者没有运行。
注意，处于这种漂浮状态的服务，如果它所属的软件包升级了，
这个服务将启动，不管它在升级前是否运行。
这是当前 Debian 系统一个已知的缺点。
注意：还需要在运行级 0 和 6 之间保留服务的 <tt>K</tt> 符号链接。
如果删除了一个服务的所有符号链接，在升级该服务的软件包时，
所有的符号链接将恢复到它们的出厂默认模式。
<p>
<strong>不</strong>建议对 <file>/etc/rcS.d/</file> 目录里的符号链接做任何改变。

<sect id="diverse">多样性支持
<p>
 Debian 提供几种途径，在不破坏系统的前提下满足系统管理员各种要求。
<list>
<item><prgn>dpkg-divert</prgn>，参阅<ref id="dpkg-divert">。
<item><prgn>equivs</prgn>，参阅<ref id="equivs">。
<item><prgn>update-alternative</prgn>，参阅<ref id="alternatives">。
<item><prgn>make-kpkg</prgn> 可以支持多启动引导。参阅 <manref name="make-kpkg" section="1"> 和
<ref id="kernel-compile">。
</list>
<file>/usr/local/</file> 目录下的所有文件均属于系统管理员，&debian; 不会改动它们。<file>/etc</file> 下的大部分文件属于 <tt>conffiles</tt>，&debian; 不会在升级后覆盖它们，除非系统管理员明确要求覆盖。

<sect id="i18n">国际化
<p>
&debian; 系统是国际化产品，不论是在控制台下还是在 X 下，它都提供多种语言的字符显示和输入支持。许多文档、帮助页面以及系统消息都被翻译成各种语言。在安装过程中， Debian 提示用户选择安装语言(有时是当地语言变量)。
<p>
如果你安装的系统提供的语言特性支持不能满足你的需要，或者你要改变当前语言或安装别的键盘方案以适应你的语言，参阅<ref id="l10n">。

<sect id="kernel-details"> Debian 和系统内核
<p>
参见 <ref id="kernel">。

<sect1 id="non-debian-kernel">编译非 Debian 源码包内核代码

<p><!--Yes.  But you have-->
首先你必须了解 Debian  policy 有关头文件的规定。

<p> Debian  C libraries 是依据<strong>内核</strong>头文件最新 <strong>stable</strong> 发布版创建的。

<p>例如， Debian  1.2 发布版使用版本号为 5.4.13 的头文件。它基于所有 Linux FTP 文件站点发布的 Linux 内核源码包，这些源码包使用了最新的头文件。跟随内核源码发布的内核头文件位于 <file>/usr/include/linux/include/</file>。

<p>如果你编译某个程序所用的内核头文件比 <package>libc6-dev</package> 提供的头文件还新，在编译时你必须在命令行中加上 <tt>-I/usr/src/linux/include/</tt>。这些情况是存在的，例如，对于 automounter daemon(<package>amd</package>)软件包而言，当新内核改变了对NFS的内部操作方式，<prgn>amd</prgn> 需要知道这些改变。这时就需要引用新的内核头文件。

<sect1 id="customkernel">自定义内核创建工具

<p>对于希望(或必须)使用自定义内核的用户，推荐下载 <package>kernel-package</package> 软件包。该软件包包含了创建内核包的脚本。有了它，新建 Debian 内核镜像包只需在内核源码目录的一级目录运行
<example>
# make-kpkg kernel_image
</example>
在内核源码所在目录的顶层，执行下述命令可获得有关帮助
<example>
# make-kpkg --help
</example>
或阅读 <manref name="make-kpkg" section="1">帮助页面以及<ref id="kernel">。

<p>如果所需的 kernel-source-<var>version</var>(version 代表内核版本号)包不存在，用户就得从 Linux 文件站点分别下载最新的(或需要的)内核源码。 Debian 的<file>initrd</file> 启动脚本需要一个专门的内核路径调用 <prgn>initrd</prgn>；参阅 <url id="&bug-initrd;">。

<p>有关<package>kernel-package</package> 包的用法详述见于 <tt>/usr/doc/kernel-package/README</tt>。 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="modules">模块加载规定

<p> Debian 的 <package>modconf</package> 软件包提供了一个 shell 脚本(<file>/usr/sbin/modconf</file>)，它可以用来自定义内核模块配置。该脚本使用菜单界面，用户通过它给出系统中可挂载设备驱动的有关细节，它再将这些细节信息生成 <file>/etc/modules.conf</file> 文件(其中列出了别名 aliases 和其它参数，用于连接各种模块)，该配置文件用来加载 <file>/etc/modutils/</file> 目录下和 <file>/etc/modules</file> (其中列出了需要在系统启动时加载的模块)目录的相关模块。

<p>新版的配置帮助文件 <file>Configure.help</file> 可为构造自定义内核提供帮助，同样，<package>modconf</package> 软件包中也有一系列帮助文件(位于 <file>/usr/share/modconf/</file> 目录下)，告诉你如何对模块设定合适的参数。

<sect1 id="removeoldkernel">卸载旧内核

<p><prgn>kernel-image-<var>NNN</var>.prerm</prgn> 脚本可用来检查当前运行的内核版本，以确定是否与你打算卸载的内核版本相同。因此你可以使用如下命令删除不想要的内核镜像包：

<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(当然，要将 <var>NNN</var> 替换成你的内核版本号和修订版号。)
</sect>
