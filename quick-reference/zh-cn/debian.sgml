<!-- CVS revision of this document "$Revision: 1.1 $"  -->
<!-- CVS revision of original english document "1.83"  -->
<!--Line width ruler (ruler uses 78 characters) 34567890123456789012345-->

<chapt id="package">Debian软件包管理

<p>
使用ATP下载软件包时，请确保使用了<prgn>squid</prgn>设置本地HTTP代理，如果有可能，请设置<tt>http_proxy</tt>环境变量或在<file>/etc/apt/apt.conf</file><tt>http</tt>值，这样可极大的改善网络升级的性能，特别是在局域网中多台Debian机器同时升级时。
<p>
尽管<manref name="apt_preferences" section="5">的pin功能十分强大，但它并不能解决所有关联问题，因为关联需求总倾向于更新其它基础程序包。
<p>
<![%f-ref;[
<ref id="chroot">中所描述的使用方法非常适于
]]>
<![%q-ref;[
chroot的使用方法非常适于
]]>
将系统的稳定性和可使用大量新版软件两个优点结合在一起。
<p>
本章基于Woody系统撰写的，但大部分信息均适用于Potato系统（除了<manref name="apt_preferences"
section="5">和<file>/etc/apt/preferences</file>的相关主题）。

<sect id="pkg-intro">概述
<p>
如果你没精力阅读所有的开发文档，那么先看看本章的内容，开始体验Debian <tt>testing</tt>/<tt>unstable</tt>的威力吧 :-)

<sect1>主要工具
<p>
<example>
dselect   &mdash; 使用菜单界面的软件包管理工具（最上层的包管理工具）
dpkg      &mdash; 安装软件包（管理软件包中的文件）
apt-get   &mdash; 安装软件包（管理软件包，CLI APT）
tasksel   &mdash; 安装任务套件（管理面向某方面任务的一套软件包）
aptitude  &mdash; 安装软件包（管理软件包和任务套件，ncurses APT）
deity     &mdash; 另一种ncurses APT
synaptic, gsynaptic &mdash; 另一种GUI APT
</example>
它们不是同级的工具。<prgn>dselect</prgn>运行于APT（命令行命令是<prgn>apt-get</prgn>）和<prgn>dpkg</prgn>之上。
<p>
APT使用<file>/var/lib/apt/lists/*</file>来跟踪可用的软件包，而<prgn>dpkg</prgn>使用的是<file>/var/lib/dpkg/available</file>。如果直接用<prgn>apt-get</prgn>或同类工具如<prgn>aptitude</prgn>等来安装软件包，千万别忘了更新<file>/var/lib/dpkg/available</file>文件，可以使用dselect的<tt>[U]pdate</tt>选项或在运行<tt>dselect update</tt>、<tt>tasksel</tt>或<tt>dpkg -l</tt>前执行shell命令行“<tt>dselect update</tt>”。
<p>
在处理关联软件包的方式上，<prgn>apt-get</prgn>会自动搜索下载<strong>depends</strong>类软件包，但不会理睬<strong>recommends</strong>和<strong>suggests</strong>类软件包，而<prgn>dselect</prgn>在软件包的选择方面采用菜单方式操作，对<strong>depends</strong>、<strong>recommends</strong>和<strong>suggests</strong>三类相关软件包均给出提示。<prgn>aptitude</prgn>则提供了选项下载安装所有<strong>depends</strong>、<strong>recommends</strong>和<strong>suggests</strong>类软件包。
<![%f-ref;[
参阅<ref id="depends">。
]]>
</sect1>

<sect1>方便的工具
<p>
<example>
apt-cache         - 在本地缓冲区检查包文件
dpkg-reconfigure  - 重新配置已安装的软件包（如果它是使用debconf进行配置的）
dpkg-source       - 管理源码包
dpkg-buildpackage - 自动生成包文件
...
</example>
</sect1>
</sect>

<sect id="apt-install">&debian;软件包管理基础
<p>
成套地安装软件包称之为<em>task</em>，还可以使用软件包管理工具逐个地安装软件包或升级系统。
<![%f-ref;[
亦可参阅<ref id="install">、<ref id="woody">和<ref id="bin-editor">。
]]>

<sect1 id="tasksel">使用<prgn>tasksel</prgn>或<prgn>aptitude</prgn>进行<em>task</em>安装

<p>
<prgn>tasksel</prgn>是<strong>Debian的任务安装器</strong>，系统安装过程中它为用户提供了一种<tt>简易</tt>软件包选择方式。
<p>
如果你希望完装的某项常规功能包含了许多软件包，最好的办法就是使用它来安装。运行如下命令：
<example>
# dselect update
# tasksel
</example>
<p>
<prgn>aptitude</prgn>亦可访问<em>task</em>。用它不仅可以选择<em>tasks</em>还可以对<em>task</em>选项菜单中的软件包进行逐个取舍。
</sect1>

<sect1 id="setup-apt">设置APT系统
<p>
使用<tt>testing</tt>发布版的用户，有时需要对系统进行有选择性地升级，这时可按<ref id="woody-transition">中描述的方法设置APT系统(&gt;Woody)，使用其<manref name="apt_preferences" section="5">功能。
<p>
首先，在<file>/etc/apt/sources.list</file>中添加<tt>stable</tt>、<tt>testing</tt>和<tt>unstable</tt>镜像源，接着编辑<file>/etc/apt/preferences</file>，设置合适的Pin-Priority。
<example>
Package: *
Pin: release a=stable
Pin-Priority: 500

Package: *
Pin: release a=testing
Pin-Priority: 600

Package: *
Pin: release a=unstable
Pin-Priority: 50
</example>

<sect1 id="dselect"><prgn>dselect</prgn>
<p>
启动程序，<prgn>dselect</prgn>会自动选上所有“Required”、“Important”和“Standard”类软件包，在Potato系统中，某些大型应用程序如TeX和Emacs处于这些分类中，在初次安装系统时最好手工取消对它们的选择（输入“_”）。在Woody中，这些大型应用程序被移入“Optional”类软件包。
<p>
<prgn>dselect</prgn>的用户界面有点怪。有4个相似命令（注意是大写字母！）：
<example>
Key-stroke  Action
Q           退出。确认当前的选择然后退出。
            (override dependencies)
R           恢复！我放弃我做出的选择
D           不管它！我不管dselect有什么建议，照我说的做！
U           照系统的建议做
</example>
使用<tt>D</tt>和<tt>Q</tt>可以选择有冲突的选项，你要自负风险，所以使用这些命令要小心。当前<prgn>dselect</prgn>是一款成熟的菜单驱动式工具，在对<strong>suggests</strong>和<strong>recommends</strong>类软件包的选择控制方面，它提供相当棒的微操作能力。
<p>
在<file>/etc/dpkg/dselect.cfg</file>中加上一行包含“expert”选项以减少干扰。对于速度慢的机器，请在其它速度快的机器上运行<prgn>dselect</prgn>选好软件包，然后用<tt>apt-get install</tt>安装它们。
<p>
对于没有定义Pin-Priority的软件包，<prgn>dselect</prgn>不会访问它们。
</sect1>

<sect1 id="aptitude"><prgn>aptitude</prgn>
<p>
<prgn>aptitude</prgn>是一款新的菜单驱动式软件包安装工具，与<prgn>dselect</prgn>很相似。它亦可作为命令行工具<prgn>apt-get</prgn>的替代品。参阅<manref name="aptitude"
section="1">。
<p>
<prgn>aptitude</prgn>可接受单字符命令，通常是小写字母。
<example>
Key-stroke  Action
F10         菜单
?           键盘命令帮助
u           更新软件包信息
g           下载并安装选定的软件包
q           保存修改并退出当前屏幕
x           放弃修改并退出当前屏幕
Enter       浏览某软件包的相关信息
</example>
<prgn>aptitude</prgn>提供了选项可自动选取所有<strong>depends</strong>、<strong>recommends</strong>和<strong>suggests</strong>类软件包。可在<tt>F10 -> Options -> Dependency handling</tt>菜单中设置它。
<p>
通过<prgn>aptitude</prgn>可访问某软件包的所有版本。
</sect1>

<sect1 id="apt-commands"><prgn>apt-cache</prgn>和<prgn>apt-get</prgn>命令
<p>
还是以上面使用<tt>testing</tt>发布版的用户为例，可使用下列命令管理系统：
<list>
<item><tt>apt-get -u upgrade</tt>
<p>跟踪<tt>testing</tt>发布版的更新情况，对系统上所有软件包进行升级并从<tt>testing</tt>处安装关联软件包。
<item><tt>apt-get -u dist-upgrade</tt>
<p>跟踪<tt>testing</tt>发布版的更新情况，对系统上所有软件包进行升级并从<tt>testing</tt>处重新分析关联关系并安装关联包。
<item><tt>apt-get -u dselect-upgrade</tt>
<p>跟踪<tt>testing</tt>发布版的更新情况，对系统上所有在<prgn>dselect</prgn>中选定了的软件包进行升级。
<item><tt>apt-get -u install <var>package</var></tt>
 <p>从<tt>testing</tt>处安装<var>package</var>及其关联包。
<item><tt>apt-get -u install <var>package</var>/unstable</tt>
 <p>从<tt>unstable</tt>处安装<var>package</var>并从<tt>testing</tt>处安装关联包。
<item><tt>apt-get -u install -t unstable <var>package</var></tt>
<p>从<tt>unstable</tt>处安装<var>package</var>及其关联包。注意须设置<tt>unstable</tt>的Pin-Priority为990。
<item><tt>apt-cache policy <var>foo bar ...</var></tt>
 <p>检查<var>foo bar ...</var>软件包的状态。
<item><tt>apt-cache show <var>foo bar ...</var> | less</tt>
 <p>查看<var>foo bar ...</var>软件包的有关信息。
<item><tt>apt-get install <var>foo=2.2.4-1</var></tt>
 <p>安装<var>foo</var>软件包的特定版本<var>2.2.4-1</var>。
<item><tt>apt-get -u install <var>foo bar-</var></tt>
 <p>安装<var>foo</var>软件包并删除<var>bar</var>软件包。
<item><tt>apt-get remove <var>bar</var></tt>
 <p>删除<var>bar</var>软件包，但保留其配置文件。
<item><tt>apt-get remove --purge <var>bar</var></tt>
 <p>删除<var>bar</var>软件包及其配置文件。
</list>
在上面的例子中使用<tt>-u</tt>选项的作用是在实际升级之前将所有将要升级的软件包列出，并提示用户确认。下面的操作可将<tt>-u</tt>设置为默认行为：
<example>
$ cat &gt;&gt; /etc/apt/apt.conf &lt;&lt; .
// Always show packages to be upgraded (-u)
APT::Get::Show-Upgraded "true";
.
</example>
<p>
使用<tt>-s</tt>可进行模拟升级，并不进行真正的升级行为。

<sect1 id="apt-tracking">跟踪某&debian;发行版
<p>
根据个人的喜好，选择要跟踪的&debian;发行版，然后修改<ref id="setup-apt">的样例文件<file>/etc/apt/preferences</file>：
<example>
track stable:            将testing的Pin-Priority改为50
track testing:           保持上面的设置不变
track testing(unstable): 将unstable的Pin-Priority改为500
track unstable(testing): 将unstable的Pin-Priority改为800
</example>
有关如何选定Pin-Priority的说明：在上表中，从上而下代表了某个版本 从上个版本刚刚发布之后到下一版进入冻结期之前这段时间经历的各个阶段。
<p>
请注意，跟踪<tt>testing</tt>发行版的&debian;有一个负面影响，安全补丁的更新很慢。
<p>
请注意，如果将&debian;各版本混合，例如将<tt>testing</tt>混入<tt>stable</tt>或将<tt>unstable</tt>混入<tt>stable</tt>，这会造成众多关键软件包不自觉地从<tt>testing</tt>处或<tt>unstable</tt>处获得，结果引起许多麻烦。
<p>
如何对<file>/etc/apt/preferences</file>进行设置，将某些关键包锁定在成熟版本，而让其它非关键包跟踪不太成熟的新版本，可参考<url id="&examples;" name="样例目录">中的<file>preferences.testing</file>和<file>preferences.unstable</file>文件。另一方面，<file>preferences.stable</file>强制所有软件包降级到“stable”。

<sect1 id="apt-stable">将所有软件包降级到<tt>stable</tt>
<p>
要将所有软件包降级到<tt>stable</tt>，可按下面的方法编辑<file>/etc/apt/preferences</file>：
<example>
Package: *
Pin: release a=stable
Pin-Priority: 1001
</example>
然后运行“<tt>apt-get upgrade</tt>”，由于Pin-priority &gt; 1000而引起强制降级。注意，该操作可能会在关联性方面发生一点问题。

<sect1 id="apt-preferences"><file>/etc/apt/preferences</file>概述
<p>
<ref id="setup-apt">中展示的<file>/etc/apt/preferences</file>样例文件里，首行<tt>Package: *</tt>表示该段落指令作用于所有软件包。可以通过指定软件包名称来为某个特定的软件包设置指定的Pin-Priority。
<p>
接下来的一行是<tt>Pin: release a=stable</tt>表示<prgn>apt-get</prgn>从包含<tt>Archive: stable</tt>节的<file>Release</file>文件所在的目录获得<file>Packages.gz</file>文件。
<p>
最后一行<tt>Pin-Priority: 500</tt>指定Pin-Priority为500。
<p>
如果多个软件包同名，系统通常会安装拥有最高Pin-Priority的软件包。  
<p>
在此，Pin-Priority表示：
<list>
<item>1001及以上：可降级优先级。
 <p>Pin-Priority处于该范围的软件包允许降级操作。
<item>100到1000：标准优先级。
 <p>不允许降级。几个key Pin-Priority的值：
<list>
<item>990：由<tt>--target-release</tt>或<manref name="apt-get" section="8"><tt>-t</tt>选项设置的优先级。
<item>500：所有默认软件包文件的优先级。
<item>100：当前安装软件包文件的优先级。
</list>
<item>0到99：非自动优先级。（仅用于软件包没有安装或没有别的可用版本时。）
<item>小于0：决不选择该版本。
</list>
按下面的方法设置<file>/etc/apt/apt.conf</file>可获得与<tt>--target-release</tt>一样的效果：
<example>
# echo 'APT::Default-Release "testing";' &gt;&gt; /etc/apt/apt.conf
</example>
命令行选项<tt>--target-release</tt>和<file>/etc/apt/apt.conf</file>中的设置会顶替<file>/etc/apt/preferences</file>的设置。在玩<file>/etc/apt/preferences</file>的时候小心两者冲突。

<sect id="survival">Debian生存工具
<p>
掌握了这些知识，就能让你的系统“<strong>青春永驻</strong>”了:-)

<sect1 id="bug-check">检测程序错误寻求帮助
<P>
如你使用某个软件包出现问题，在寻求帮助或发送错误报告之前请确认查看过下列站点（<prgn>lynx</prgn>、<prgn>links</prgn>和<prgn>w3m</prgn>同样好用）：
<example>
$ lynx &bugs;
$ lynx &bugs;<var>package-name</var>  # 如果你知道软件包名称
$ lynx &bugs;<var>bugnumber</var>     # 如果你知道错误序号
</example>
在Google(www.google.com)中使用关键字“site:debian.org”搜索。
<p>
如有疑问，可阅读帮助文件。设置<tt>CDPATH</tt>如下：
<example>
export CDPATH=.:/usr/local:/usr/share/doc
</example>
然后输入
<example>
$ cd <var>packagename</var>
$ pager README.Debian # if this exists
$ mc 
</example>
<![%f-ref;[
更多技术支持资源列在<ref id="support">。
]]>
</sect1>

<sect1 id="apt-trouble">APT升级错误及解决方法
<p>
从<tt>unstable</tt>/<tt>testing</tt>进行升级时可能出现<ref id="upgrade-system">中提到的软件包关联问题。多数情况下，是因为升级的软件包所需的新增的关联包没有安装。可使用如下方法解决：
<example>
# apt-get dist-upgrade
</example>
如果这招无效，可以重复下面的方法至到问题解决：
<example>
# apt-get upgrade -f         # continue upgrade even after error
... 或
# apt-get dist-upgrade -f    # continue dist-upgrade even after error
</example>
<p>
一些的确存在问题的升级脚本会引起持续出错。最好的解决方法是检查该软件包的安装脚本<file>/var/lib/dpkg/info/packagename.<var>{post-,pre-}{install,removal}</var></file>然后运行：
<example>
# dpkg --configure -a    # 配置所有未完成安装的软件包
</example>
<p>
如果脚本报告缺少配置文件，查看一下<file>/etc</file>中相关的配置文件。如果配置文件有<tt>.new</tt>扩展名（或其它类似的扩展名），去掉（<prgn>mv</prgn>）它的扩展名。
<p>
从unstable/testing进行升级时可能出现软件包关联问题。可用这个方法智取：
<example>
# apt-get install -f <var>package</var> # 重载坏关联
</example>
<p>
还可以用<package>equivs</package>包来解决此类问题。参阅<file>&f-equivs;</file><![%f-ref;[ and <ref id="equivs">]]>。
</sect1>

<sect1 id="rescue-dpkg">使用<prgn>dpkg</prgn>救助
<p>
如果系统的<prgn>dselect</prgn>（APT）受损无法完成安装，可使用<prgn>dpkg</prgn>来恢复：
<example>
# cd /var/cache/apt/archives
# dpkg -i libc6* libdb2* perl*
# dpkg -i apt* dpkg* debconf*
# dpkg -i *  # 直至不再出错
</example>
如果软件包丢失，用下述方法从<url id="&mirror-site;" name="镜像源">下载：
<example>
# mc            # use "FTP link" pointing to Debian FTP server
</example>
现在，在HTTP/FTP服务器上，软件包的真正位置不再是传统的<file>/dist</file>目录而是新的<file>/pool</file>目录。<![%f-ref;[（参阅<ref id="pools">）]]>
<p>
然后开始安装：
<example>
# dpkg -i /var/cache/apt/archives/<var>packagefile.deb</var>
</example>
对于坏关联，可这样解决：
<example>
# dpkg --ignore-depends=<var>package1</var>,... -i <var>packagefile.deb</var>
# dpkg --force-depends -i <var>packagefile.deb</var>
# dpkg --force-depends --purge <var>package</var>
# dpkg --force-confmiss -i <var>packagefile.deb</var> # Install missing conffile
</example>
</sect1>

<sect1 id="recover-status">恢复软件包选择状态的数据
<p>
如果<file>/var/lib/dpkg/status</file>因为某种原因坏掉了，&debian;系统将会完全丢失软件包选择状态的数据。赶快到<file>/var/lib/dpkg/status-old</file>或<file>/var/backups/dpkg.status.*</file>下找找旧的<file>/var/lib/dpkg/status</file>文件。
<p>
将<file>/var/backups/</file>放在其它的分区是个好习惯，因为该目录包含了许多非常重要的系统数据。
<p>
如果旧的<file>/var/lib/dpkg/status</file>文件也坏了，仍可以从<file>/usr/share/doc/</file>下的目录进行恢复这些信息。
<example>
# ls /usr/share/doc | \
  grep -v [A-Z] | \
  grep -v '^texmf$' | \
  grep -v '^debian$' | \
  awk '{print $1 " install"}' | \
  dpkg --set-selections
# dselect --expert # reinstall system, de-select as needed
</example>

<sect1 id="rescue-var"><file>/var</file>被删除后如何恢复系统
<p>
<file>/var</file>目录包含着定时更新的数据如mail，它们很容易遭破坏。将目录放到别的分区可降低风险，如果最坏的事情发生了，可以通过重建<file>/var</file>目录来挽救&debian;系统。
<p>
从相同或旧版本的最简&debian;系统中取得<file>/var</file>目录的内容框架，例如<url id="&var-tar-gz;" name="var.tar.gz">，然后它放入受损系统的root目录，接着
<example>
# cd /
# mv var var-old      # 如果剩有有用内容
# tar xvzf var.tar.gz # 使用Woody框架文件
# aptitude            # 或用dselect
</example>

上述步骤可使系统恢复工作。使用<ref id="recover-status">中描述的技术加速软件包选择数据的恢复。
（[FIXME]：该过程需要更多的实践来检验）
</sect1>

<sect1 id="un-bootable">为无法启动的系统安装软件包
<p>
使用Debian急救软盘/CD或从多启动Linux系统其它分区启动。
<![%f-ref;[
See <ref id="booting">. 
]]>
将无法启动的系统挂载到<file>/target</file>并使用<prgn>dpkg</prgn>的chroot安装模式。
<example>
# dpkg --root /target -i <var>packagefile.deb</var>
</example>
接下来就可以着手配置并解决问题。
<p>
如是只是由于<prgn>lilo</prgn>损坏而造系统无法启动，可使用标准Debian急救盘启动。假设你的root分区位于<file>/dev/hda12</file>且想使用runlevel 3，在启动提示符输入：
<example>
boot: rescue root=/dev/<var>hda12</var> 3
</example>
这样，你就可以使用软盘中内核启动系统，新系统的功能基本齐全。（可能丢失某些内核特性或模块）
</sect1>

<sect1>如果<prgn>dpkg</prgn>命令出错该怎么办
<p>
如果<prgn>dpkg</prgn>损坏就不能安装任何<tt>.deb</tt>文件。下面的操作可帮助你修复这种状况。（在第一行，你可将“links”替换成你喜欢的浏览器。）
<example>
$ links http://<var>http.us.debian.org</var>/debian/pool/main/d/dpkg/
  ... 下载完好的dpkg_<var>version</var>_<var>arch</var>.deb
$ su
password: *****
# ar x dpkg_<var>version</var>_<var>arch</var>.deb
# mv data.tar.gz /data.tar.gz
# cd /
# tar xzfv data.tar.gz
</example>
对<tt>i386</tt>，亦可用<tt>http://packages.debian.org/dpkg</tt>作为URL。
</sect1>

</sect>

<sect id="debian-package">Debian必杀技
<p>
有了这些命令的<strong>启迪</strong>，你将会从无休止的升级冲突的地狱中解放出来，达到Debian<strong>天堂</strong>。 :-)

<sect1 id="info-file">文件信息
<p>
查找特定文件所属的软件包：
<example>
$ dpkg {-S|--search} pattern # search for pattern in installed packages
$ zgrep -e pattern <var>/local/copy/of/debian/woody/Contents-i386.gz</var>
             # find filename-pattern of files in the debian archive
</example>
或使用专门的软件包命令：
<example>
# apt-get install dlocate  
                 # conflicts with slocate (secure version of locate)
$ dlocate <var>filename</var>         # fast alternative to dpkg -L and dpkg -S
...
# apt-get install auto-apt # on-demand package installation tool
# auto-apt update          # create db file for auto-apt
$ auto-apt search <var>pattern</var>  
                # search for pattern in all packages, installed or not
</example>
</sect1>

<sect1 id="info-package">软件包信息
<p>
搜索并显示包文件的信息。编辑<file>/etc/apt/sources.list</file>，让APT指向正确的包文件。如果想了解testing/unstable中的相应软件包与当前系统安装的软件包有何差别，使用<tt>apt-cache policy</tt>&mdash;更好。
<example>
# apt-get   check           # 更新缓冲区并检查损坏的软件包
$ apt-cache search  <var>pattern</var> # 按文本描述搜索软件包
$ apt-cache policy  <var>package</var> # 软件包的priority/dists信息
$ apt-cache show -a <var>package</var> # 显示所有dists中软件包描述信息
$ apt-cache showsrc <var>package</var> # 显示相应源码包的信息
$ apt-cache showpkg <var>package</var> # 软件包调试信息
# dpkg  --audit|-C          # 搜索未完成安装的软件包
$ dpkg {-s|--status} <var>package</var> ... # 已安装软件包描述
$ dpkg -l <var>package</var> ...       # 已安装软件包的状态（每个占一行）
$ dpkg -L <var>package</var> ...       # 列出软件包安装的文件的名称
</example>
<!-- Erase this when manual page gets fixed.  FIXME -->
Woody发布版没有为<tt>apt-cache showsrc</tt>建档，但该命令可用:)
<p>
你也这可这样查看软件包信息（我用<tt>mc</tt>浏览）：
<example>
/var/lib/apt/lists/*
/var/lib/dpkg/available
</example>
比较下面的文件可以确切了解最近的安装过程对系统造成了那些改变。
<example>
/var/lib/dpkg/status
/var/backups/dpkg.status*
</example>

</sect1>

<sect1 id="apt-get-auto">使用APT进行全自动系统安装
<p>
进行全自动安装，要在<file>/etc/apt/apt.conf</file>中加上一行：
<example>
Dpkg::Options {"--force-confold";}
</example>
另一种等阶的方法是运行<tt>apt-get -q -y <var>packagename</var></tt>。这种方法可能产生严重的负作用，所以使用起来要小心。参阅<manref name="apt.conf" section="5">和<manref name="dpkg" section="1">。
<p>
安装完毕以后，可以用<ref id="reconfigure">中的方法配置特定的软件包。

<sect1 id="reconfigure">重新配置已安装软件包
<p>
使用下列方法重新配置已安装软件包。
<example>
# dpkg-reconfigure --priority=<var>medium</var> <var>package</var> [...]
# dpkg-reconfigure --all   # 重新配置所有的软件包
# dpkg-reconfigure locales # 生成别的locales
# dpkg-reconfigure --p=<var>low</var> xserver-xfree86 # 重新配置X服务器
</example>
如果你想永久改变<prgn>debconf</prgn>对话框模式，可这么做。
<p>
某些程序用于生成特殊的配置脚本。
<example>
apt-setup     - 创建/etc/apt/sources.list
install-mbr   - 安装主引导（Master Boot Record）管理器
tzconfig      - 设定本地时间
gpmconfig     - 设置gpm鼠标daemon
sambaconfig   - 在Potato中配置Samba（Woody使用debconf来配置）
eximconfig    - 配置Exim (MTA)
texconfig     - 配置teTeX
apacheconfig  - 配置Apache (httpd)
cvsconfig     - 配置CVS
sndconfig     - 配置声音系统
...
update-alternatives - 设定默认启动命令，例如设定vi启动vim
update-rc.d         - System-V init脚本管理工具
update-menus        - Debian菜单系统
...
</example>
</sect1>

<sect1 id="remove">删除软件包
<p>
删除软件包但保留其配置文件：
<example>
# apt-get remove <var>package</var> ...
# dpkg  --remove <var>package</var> ...
</example>
删除软件包并删除配置文件：
<example>
# apt-get remove --purge <var>package</var> ...
# dpkg    --purge        <var>package</var> ...
</example>
</sect1>

<sect1 id="hold">阻止旧软件包升级
<p>
举个例子，要阻止<package>libc6</package>和<package>libc6-dev</package>通过<prgn>dselect</prgn>或使用<tt>apt-get -u upgrade <var>package</var></tt>命令升级，可执行：
<example>
# echo -e "libc6 hold\nlibc6-dev hold" | dpkg --set-selections
</example>
这种方法不影响<tt>apt-get -u install <var>package</var></tt>命令操作。要阻止<tt>apt-get -u upgrade
<var>package</var></tt>或<tt>apt-get -u dist-upgrade</tt>命令对软件包执行的强制自动降级行为，可在<file>/etc/apt/preferences</file>中加上：
<example>
Package: libc6
Pin: release a=stable
Pin-Priority: 2000
</example>
这里“<tt>Package:</tt>”后不能使用通配符如“<tt>libc6*</tt>”，如果要保持所有与<package>glibc</package>源码包相关的二进制包的版本同步，可以明确的列出它们。
<p>
该命令可以显示处于“阻止”状态的软件包：
<example>
dpkg --get-selections "*"|grep -e "hold$"
</example>
</sect1>

<sect1 id="mixedsys">stable/testing/unstable混合系统
<p>
<prgn>apt-show-versions</prgn>可以列出发行版中可用软件包的版本。
<example>
$ apt-show-versions | fgrep /testing | wc
... 你有多少testing软件包
$ apt-show-versions -u
... 列出可升级的软件包
$ apt-get install `apt-show-versions -u -b | fgrep /unstable`
... 将所有unstable软件包升级到最新版本
</example>
</sect1>

<sect1 id="cache">删除缓存包文件
<p>
使用APT安装软件包会在<file>/var/cache/apt/archives</file>目录留下缓存文件，要清除这些文件可使用：
<example>
# apt-get autoclean # removes only useless package files
# apt-get clean     # removes all cached package files
</example>
</sect1>


<sect1 id="record">记录/拷贝系统配置
<p>
对软件包选择情况进行本地备份：
<example>
$ dpkg --get-selections "*" &gt;<var>myselections</var>   # or use \*
</example>
<tt>“*”</tt>使<tt><var>myselections</var></tt>包含那些被指定“完全删除（purge）”的文件。
<p>
你可将这个文件发送到另一台电脑并在那儿按文件中的选择进行软件包安装。
<example>
# dselect update
# dpkg --set-selections &lt;<var>myselections</var>
# apt-get -u dselect-upgrade    # <var>or</var> dselect install
</example>
</sect1>

<sect1 id="port">向<tt>stable</tt>系统引入软件包
<p>
对stable系统进行部分升级，在软件运行环境中重新编译源码的确是个诱人的想法，这样可以避免由于关联关系不得不对大量软件包升级。首先，将下列镜像源加入<file>/etc/apt/sources.list</file>：
<example>
deb-src &http-us;debian testing \
 main contrib non-free
deb-src &http-non-us;debian-non-US testing/non-US \
 main contrib non-free
deb-src &http-us;debian unstable \
 main contrib non-free
deb-src &http-non-us;debian-non-US unstable/non-US \
 main contrib non-free
</example>
由于屏幕输出的限制，上述每条<tt>deb-src</tt>命令均分成了2行，实际上在<file>sources.list</file>中它们均为单行。
<p>
然后下载源码并在本地生成软件包：
<example>
$ apt-get source <var>package</var>
$ dpkg-source -x <var>package.dsc</var>
$ cd <var>package-version</var>
  ... 查找需要的软件包（编译所需的关联包列在.dsc文件中）并安装它们，
      你还需要“fakerroot”软件包。

$ dpkg-buildpackage -rfakeroot 

  ...or (no sig)
$ dpkg-buildpackage -rfakeroot -us -uc # use "debsign" later if needed

  ...Then to install
$ su -c "dpkg -i <var>packagefile.deb</var>"
</example>
通常，需要安装一些带“-dev”后缀的软件包以满足关联关系。<prgn>debsign</prgn>在<package>devscripts</package>软件包中。<prgn>auto-apt</prgn>可以轻松解决这些关联问题。请使用<prgn>fakeroot</prgn>，如是没有必要，就别使用root帐号。
<p>
在Woody中，这些关联问题已被简化。例如，编译<package>pine</package>源码包：
<example>
# apt-get build-dep pine
# apt-get source -b pine
</example>
</sect1>

<sect1 id="local">本地软件包文件
<p>
为了创建与APT和dselect系统兼容的本地软件包文件，需要创建<file>Packages</file>（Packages），包中文件要放在特定的目录树中。
<p>
Debian官方包文件喜欢存放于本地deb仓库，下面就来创建仓库：
<example>
# apt-get install dpkg-dev
# cd <var>/usr/local</var>
# install -d <var>pool</var> # 软件包存放的物理地址
# install -d dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>
# ls -1 <var>pool</var> | sed 's/_.*$/ <var>priority</var> <var>section</var>/' | uniq &gt; <var>override</var>
# editor <var>override</var> # adjust <var>priority</var> and <var>section</var>
# dpkg-scanpackages <var>pool</var> <var>override</var> <var>/usr/local</var>/ \
   &gt; dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>/Packages
# cat &gt; dists/<var>unstable</var>/<var>main</var>/Release &lt;&lt; EOF
Archive: <var>unstable</var>
Version: <var>3.0</var>
Component: <var>main</var>
Origin: <var>Local</var>
Label: <var>Local</var>
Architecture: <var>i386</var>
EOF
# echo "deb file:<var>/usr/local</var> <var>unstable</var> <var>main</var>" \
   &gt;&gt; /etc/apt/sources.list
</example>
<p>
还可以这样快速创建一个本地deb仓库：
<example>
# apt-get install dpkg-dev
# mkdir <var>/usr/local/debian</var>
# mv <var>/some/where/package.deb</var> <var>/usr/local/debian</var>
# dpkg-scanpackages <var>/usr/local/debian</var> /dev/null | \
  gzip - &gt; <var>/usr/local/debian</var>/Packages.gz
#  echo "deb file:<var>/usr/local/debian</var> ./" &gt;&gt; /etc/apt/sources.list
</example>
<p>
在<file>/etc/apt/sources.list</file>中设置相应镜像源入口地址，就可以通过HTTP或FTP方式远程访问存放在其中的包文件了。

<sect1 id="alien">转化或安装外来二进制软件包
<p>
<package>alien</package>可将其它格式的二进制软件包如Redhat的<tt>rpm</tt>、Stampede的<tt>slp</tt>、Slackware的<tt>tgz</tt>和Solaris的<tt>pkg</tt>等转化成&debian;的<tt>deb</tt>格式软件包，如果你想在自己的系统上使用别的Linux发行版中的软件包，可使用<prgn>alien</prgn>将它转化成系统首选的软件包格式后安装。<package>alien</package>还支持LSB的软件包。
</sect1>

<sect1 id="debsums">校验已安装软件包
<p>
<prgn>debsums</prgn>可以校验已安装软件包的MD5编码，对某些软件包没有可用的MD5编码，系统管理员可使用一个临时的解决办法：
<example>
# cat >>/etc/apt/apt.conf.d/90debsums
DPkg::Post-Install-Pkgs {"xargs /usr/bin/debsums -sg";};
^D
</example>
per Joerg Wendland &lt;joergland@debian.org&gt;  (untested).

<![%f-ref;[
<sect1 id="spy">优化<file>sources.list</file>
<p>
简而言之，我尝试过用各种优化方法来创建<file>sources.list</file>，但任何一种方法对我这个住在美国的人来说都没有明显的改善。最后我还是用<prgn>apt-setup</prgn>手工选择近一点的站点。
<p>
<prgn>apt-spy</prgn>会根据站点回应时间和带宽自动创建<file>sources.list</file>。<prgn>netselect-apt</prgn>会创建一个更完整的<file>sources.list</file>文件，但它使用更落后的方法来选择镜像站点（比较ping time）。
<example>
# apt-get install apt-spy
# cd /etc/apt ; mv sources.list sources.list.org
# apt-spy -d testing -l sources.apt
</example>
</sect1>

]]>


</sect>

<sect id="pecuriarities">其它Debian特性

<sect1 id="dpkg-divert"><prgn>dpkg-divert</prgn>命令
<p>
<!-- copied from manual page -->
使用文件<strong>转移</strong>（diversions）的方法可以强令<prgn>dpkg</prgn>将文件安装到<strong>转移</strong>目录而非默认目录。对于某个引起冲突的文件，可以在&debian;软件包脚本中使用<strong>Diversions</strong>将它安装到别的目录。系统管理员还可以使用diversion来重载软件包配置文件，或者用来保留某些旧配置文件（这些文件没有在<strong>conffiles</strong>中登记）当安装新版软件时这些文件会被覆盖。<![%f-ref;[（参阅<ref id="conffile">）]]>。
<example>
# dpkg-divert [--add]  <var>filename</var> # add "diversion"
# dpkg-divert --remove <var>filename</var> # remove "diversion"
</example>
记住，不到万不得已不要使用<prgn>dpkg-divert</prgn>。
</sect1>

<sect1 id="equivs"><package>equivs</package>软件包
<p>
如果你从源码编译程序，最好将它做成本地Debian化软件包（<tt>*.deb</tt>）。最新的方法是使用<tt>equivs</tt>。
<example>
Package: equivs
Priority: extra
Section: admin
Description: Circumventing Debian package dependencies
 This is a dummy package which can be used to create Debian
 packages, which only contain dependency information.
</example>
</sect1>

<sect1 id="alternatives">自选命令
<p>
想用<prgn>vi</prgn>命令启动<prgn>vim</prgn>，可使用<prgn>update-alternatives</prgn>来定义：
<example>
# update-alternatives --display vi
...
# update-alternatives --config vi
  Selection    Command
-----------------------------------------------
      1        /usr/bin/elvis-tiny
      2        /usr/bin/vim
*+    3        /usr/bin/nvi

Enter to keep the default[*], or type selection number: 2
</example>
Debian自选命令设定系统中的这些项目，都是<file>/etc/alternatives</file>下的链接文件。
<p>
想设置你喜爱的X window环境，执行<prgn>update-alternatives</prgn>来指定<file>/usr/bin/x-session-manager</file>和<file>/usr/bin/x-window-manager</file>。<![%f-ref;[详情参阅<ref id="custom-x">。]]>
<p>
<file>/bin/sh</file>是指向<file>/bin/bash</file>或<file>/bin/dash</file>的链接。想兼容旧的Bash脚本，使用<file>/bin/bash</file>比较保险，但更好还是使用<file>/bin/dash</file>，因为它更符合POSIX标准。升级到2.4版Linux内核，系统一般将它设置为<file>/bin/dash</file>。
</sect1>

<sect1 id="sys-v">System-V <prgn>init</prgn>文件和运行级别
<p>
可在<file>/etc/inittab</file>中设定系统启动的默认运行级别（runlevel）。
<p>
不同于其它的发行版，Debian将运行级别的管理职责完全赋予系统管理员。Debian更倾向于使用<prgn>update-rc.d</prgn>脚本来管理它那System-V风格的<prgn>init</prgn>。
<p>
下面的命令表示，按优先级数字20（normal）所指定的次序，分别在runlevel 1、2、3中启动<file>/etc/init.d/<var>name</var></file>，在runlevel 4、5中停止它们：
<example>
# update-rc.d <var>name</var> start 20 1 2 3 . stop 20 4 5 .
</example>
要删除<prgn>init.d</prgn>脚本中存在的符号链接可执行：
<example>
# update-rc.d -f <var>name</var> remove
</example>
要编辑运行级别，我通常在<prgn>mc</prgn>中用<tt>Alt-Enter</tt>拷贝链接名，然后在shell提示符下使用<prgn>mv</prgn>命令手工编辑，例如：
<example>
# mv S99xdm K99xdm # 禁用xdm (X display manager)
</example>
有时为了进行临时调试，我甚至在<prgn>init.d</prgn>脚本的开头加入<tt>exit 0</tt>来禁用一个daemon，反正它们都在<tt>conffiles</tt>登记过。
</sect1>

<sect1 id="disables">停止daemon服务
<p>
&debian;发行版非常注重系统安全，并期望系统管理员能担此重任。它将系统的易用性放在了第二位，许多daemon服务都定位在最高安全级别，因而，默认安装状态下系统只启动最少的（甚至没有）可用的服务。
<p>
如果拿不定把握（有关Exim、DHCP...），可执行<tt>ps aux</tt>或检查<file>/etc/init.d/*</file>和<file>/etc/inetd.conf</file>下的内容，还可以<![%f-ref;[使用<ref id="loginctrl">中提到的方法]]>检查<file>/etc/hosts.deny</file>。<prgn>pidof</prgn>命令也很有用（参阅<manref name="pidof" section="8">）
<p>
在新版的&debian;中，默认状态下X11不允许TCP/IP（远程）连接。<![%f-ref;[参阅<ref id="xtcp">，]]>使用SSH进行X传送也是禁用的，<![%f-ref;[参阅<ref id="xssh">。]]>
</sect1>
</sect>

</chapt>

