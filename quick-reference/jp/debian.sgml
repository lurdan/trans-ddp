<!-- CVS revision of this document "$Revision: 1.2 $"  -->
<!-- CVS revision of original english document "1.91"  -->

<!--Line width ruler (ruler uses 78 characters) 34567890123456789012345-->

<chapt id="package">&debian; パッケージ管理

<p>
&debian; のレポジトリーへのネットワーク負荷を低減するために、
APT を通してパッケージをダウンロードする際には、必要に応じて 
<tt>http_proxy</tt> 環境変数を設定するか、<file>/etc/apt/apt.conf</file> 
の中の <tt>http</tt> の値を設定し、<prgn>squid</prgn>を使ったローカルの
http プロキシをセットアップするようにしたい。
これはネットワークアップグレードのパフォーマンスを非常に向上させる。
この効果は LAN上に複数の &debian; ボックスがある際に更に顕著である。
<p>
<manref name="apt_preferences" section="5"> に記載された pin 
機能は非常に強力であるが、依存性のために他の基本的なプログラムパッケージの新しいバージョン引き込みやすいと言うことがあるので全ての依存性の問題を解決するわけではない。
<p>
<![%f-ref;[
<ref id="chroot">に記載された手法は、
]]>
<![%q-ref;[
chroot 手法は、
]]>
システムの安定性と最新ソフトウエアバージョンアクセスの両方を確保できるので望ましい手法である。
<p>
本章は Woody システムに準拠しているが、(<manref name="apt_preferences"
section="5"> と <file>/etc/apt/preferences</file> 
に関連したトピックスを除くと)ほとんどの情報は Potato システムにも当てはまる。

<sect id="pkg-intro">イントロダクション
<p>
もし全てのデベロッパー向けのドキュメンテーションを読むのが辛いなら、本章をまず読み
&debian; の <tt>testing</tt> や <tt>unstable</tt> を含めた全パワーを楽しんでください:-)

<sect1>主要ツール
<p>
<example>
dselect   &ndash; メニュー式パッケージ管理ツール (トップレベル)
dpkg      &ndash; パッケージをインストール (パッケージファイル中心)
apt-get   &ndash; パッケージをインストール (パッケージアーカイブ中心、CLI APT)
tasksel   &ndash; タスクをインストール (一連のパッケージ)
aptitude  &ndash; パッケージをインストール (パッケージとタスク, ncurses APT)
deity     &ndash; また別の ncurses APT ツール
synaptic, gsynaptic &ndash; また別の GUI APT ツール
</example>
これらは同レベルのツールではありません。 <prgn>dselect</prgn> は
APT (そのコマンドラインコマンドは <prgn>apt-get</prgn>) や <prgn>dpkg</prgn> 
の上で走っています。
<p>
APT は 取得可能なパッケージを追跡するために <file>/var/lib/apt/lists/*</file>
を使いますが、 <prgn>dpkg</prgn> は <file>/var/lib/dpkg/available</file> 
を使います。
<prgn>apt-get</prgn> 又は <prgn>aptitude</prgn> などの同様のプログラムを
使って直接パッケージをインストールした場合、<tt>dselect select</tt>,
<tt>tasksel</tt> や <tt>dpkg -l</tt> を起動する前に
<prgn>dselect</prgn> の <tt>[U]pdate</tt> 選択メニュから
<file>/var/lib/dpkg/available</file> を更新するか、シェルコマンド
"<tt>dselect update</tt>" を確実に実行してください。
<p>
パッケージの依存性に従い、<prgn>apt-get</prgn> は自動的に <strong>depends</strong> するパッケージを引っ張ってきますが、<strong>recommends</strong> や
<strong>suggests</strong> するパッケージはそのままにします。一方、
<prgn>dselect</prgn> はこれらのパッケージの選択に対するメニュドリブンな制御
を提供し、<strong>depends</strong>、 <strong>recommends</strong> および
<strong>suggests</strong> に基づくパッケージ選択を促します。
<prgn>aptitude</prgn> は <strong>depends</strong>,
<strong>recommends</strong> および <strong>suggests</strong> に基づいて
自動的に全パッケージを引っ張って来るオプションを提供します。
<![%f-ref;[
<ref id="depends"> 参照
]]>
</sect1>

<sect1>変換ツール
<p>
<example>
apt-cache         - ローカルキャッシュにあるパッケージアーカイブをチェックする
dpkg-reconfigure  - 既にインストールしたパッケージを再設定する
                    (debconf を使っている場合)
dpkg-source       - source パッケージファイルを管理
dpkg-buildpackage - パッケージファイルの構築の自動化
...
</example>
</sect1>
</sect>

<sect id="apt-install">&debian; パッケージ管理の基礎
<p>
<em>task</em> と呼ばれるパッケージ群をインストールすることが可能ですし、
パッケージそれぞれをインストールしたり、下で述べるパッケージ管理ツール
を用いてシステムを更新することもできます。
<![%f-ref;[
<ref id="install">, <ref id="woody"> や <ref id="bin-editor">
でも言及しています。
]]>

<sect1 id="tasksel"><prgn>tasksel</prgn> 又は <prgn>aptitude</prgn>
を用いて <em>task</em> をインストール
<p>
<prgn>tasksel</prgn> は <strong>Debian Task インストーラ</strong> であり、
システムのインストール中に "<tt>シンプル</tt>" なオプションとして
提供されます。
<p>
複数のパッケージが要求する共通の機能をインストールする必要が
ある場合、これが最良の方法です。コマンドを次のように確実に実行してください:
<example>
# dselect update
# tasksel
</example>
<p>
<prgn>aptitude</prgn> も <em>task</em> へのアクセス手段を提供します。
<em>task</em> の選択ができるだけでなく、メニューを通じて <em>task</em>
内のパッケージをそれぞれ選択/除外できます。
</sect1>

<sect1 id="setup-apt">APT システムのセットアップ
<p>
ここに挙げる混在環境を追いかけようとする場合、パッケージの依存性の
衝突に出くわすかもしれません。flavor を混在させるのは良い考えでは
ありません。次に挙げる方法はいくらかのリスクを喜んで許容する人の
ための方法です。
<!--
そうです。これはいい加減な修正ですが、なにもしないよりは良いでしょう。
多くの初心者が混乱しているのを知っています。
-->
<p>
<tt>testing</tt> を追いかけている間にパッケージを選択して更新する場合、
(Woody 以降の) APT システムを  <manref name="apt_preferences" section="5"> 
機能を用いるために <ref id="woody-transition"> としてセットアップする
必要があります。
<p>
まず、 <tt>stable</tt>, <tt>testing</tt> ならびに <tt>unstable</tt>
用のソースを <file>/etc/apt/sources.list</file> に追加します。
そして、<file>/etc/apt/preferences</file> を編集して、適切な Pin-Priority
を設定します。
<footnote>
他のパートとの整合性を保つため、このあたりの記述をそのままにして置きます。
本当に <tt>testing</tt> や <tt>unstable</tt> を追いかけているなら、
<file>/etc/apt/sources.list</file> 内の <tt>stable</tt> への参照を
実際に削除すべきです。これは <tt>testing</tt> が <tt>stable</tt> の
コピーとして始まるからです。
</footnote>
<example>
Package: *
Pin: release a=stable
Pin-Priority: 500

Package: *
Pin: release a=testing
Pin-Priority: 600

Package: *
Pin: release a=unstable
Pin-Priority: 50
</example>


<sect1 id="dselect"><prgn>dselect</prgn>
<p>
<prgn>dselect</prgn> を起動すると、自動的に "Required", "Important" および
"Standard" パッケージの全てを選択します。 Potato システムでは、
teTeX や Emacs のような巨大なプログラムもこれらのカテゴリに所属
していたため、最初のインストールではこれらのインストールを
('_' をタイプすることにより) 手動で解除するのがベストでした。
Woody では、これらは "Optional" パッケージカテゴリに移動しました。
<p>
<prgn>dselect</prgn> はいくらか奇妙なユーザインターフェースを持ちます。
4個のあいまいなコマンドがあります。 (Capital means CAPITAL!):
<example>
キーストローク   アクション
Q           終了。現在の選択を認め、とにかく終了する。
            (依存性を上書きする)
R           戻る! 悪気はありません。
D           しまった! dselect が考えていることは分かりません。
U           全てを推奨される状態にセットする。
</example>
<tt>D</tt> や <tt>Q</tt> により、リスクを負って衝突した選択を
選ぶことができます。これらのコマンドを注意深く扱ってください。
現在は、<prgn>dselect</prgn> は <strong>suggests</strong> や
<strong>recommends</strong> の選択を通じたきめの細かい依存性制御を
提供する、熟成したメニュドリブンなツールです。
<p>
雑音を減らすために、 "expert" オプションを含む行を 
<file>/etc/dpkg/dselect.cfg</file> に追加してください。
低速なマシンでは、パッケージを検索するためには他の高速なマシンで
<prgn>dselect</prgn> を走らせたり、パッケージのインストールのために
<tt>apt-get install</tt>を使うと良いかもしれません。
<p>
<prgn>dselect</prgn> は Pin-Priority により選択されないパッケージへの
アクセス手段は提供しません。
</sect1>

<sect1 id="aptitude"><prgn>aptitude</prgn>
<p>
<prgn>aptitude</prgn> は <prgn>dselect</prgn> に似たメニュドリブンな新しい
パッケージインストーラです。<prgn>apt-get</prgn> の代わりのコマンドライン
コマンドとしても使えます。 
<manref name="aptitude"section="1"> をご覧ください。
<p>
<prgn>aptitude</prgn> は通常小文字の一文字のキーコマンドを受け付けます。
<example>
キーストローク  アクション
F10             メニュ
?               キーストロークヘルプを表示
u               パッケージアーカイブ情報を更新
g               選択パッケージのダウンロードおよびインストール
q               現在のスクリーンを終了し、変更点を保存する
x               現在のスクリーンを終了し、変更点を無視する
Enter           パッケージの情報を閲覧
</example>
<prgn>aptitude</prgn> は <strong>depends</strong>, <strong>recommends</strong>
および <strong>suggests</strong> に基づいて必要な全パッケージを自動的に
引っ張ってくるオプションを提供します。
メニュの <tt>F10 -> Options -> Dependency handling</tt> を選択
することにより、この挙動を変更できます。
<p>
<prgn>aptitude</prgn> はパッケージの全バージョンへのアクセス手段を提供します。
</sect1>

<sect1 id="apt-commands"><prgn>apt-cache</prgn> および<prgn>apt-get</prgn> コマンド
<p>
上の例で記述しているように <tt>testing</tt> を追いかけていると、
次のようなコマンドを用いてシステムを管理できます:
<list>
<item><tt>apt-get -u upgrade</tt>
 <p>これは <tt>testing</tt> ディストリビューションを追いかけ、システムの
 全パッケージを更新し、<tt>testing</tt> から依存する物をインストール
 します。
<item><tt>apt-get -u dist-upgrade</tt>
 <p>これは <tt>testing</tt> ディストリビューションを追いかけ、
 システムの全パッケージを更新しますが、<tt>testing</tt> からインストール 
 し、依存性を解決します。
<item><tt>apt-get -u dselect-upgrade</tt>
 <p>これは <tt>testing</tt> ディストリビューションを追いかけ、システムの
 全パッケージを <prgn>dselect</prgn> の選択に従って更新します。
<item><tt>apt-get -u install <var>package</var></tt>
 <p> これは <var>package</var> とこのパッケージに依存するものを 
 <tt>testing</tt> ディストリビューションからインストールします。
<item><tt>apt-get -u install <var>package</var>/unstable</tt>
 <p>これは <tt>unstable</tt> ディストリビューションから <var>package</var>
 をインストールしますが、<tt>testing</tt> ディストリビューションから
 、このパッケージに依存するパッケージをインストールします。
<item><tt>apt-get -u install -t unstable <var>package</var></tt>
 <p>これは <tt>unstable</tt> ディストリビューションから <var>package</var> 
 をインストールしますが、<tt>unstable</tt> の Pin-Priority を 990 に
 設定することにより、<tt>unstable</tt> ディストリビューションから
 このパッケージに依存するパッケージもインストールします。
<item><tt>apt-cache policy <var>foo bar ...</var></tt>
 <p>これは <var>foo bar ...</var> パッケージのステータスをチェックします。
<item><tt>apt-cache show <var>foo bar ...</var> | less</tt>
 <p>これは <var>foo bar ...</var> パッケージの情報をチェックします。
<item><tt>apt-get install <var>foo=2.2.4-1</var></tt>
 <p>これは <var>foo</var> パッケージの特定のバージョン <var>2.2.4-1</var>
 をインストールします。
<item><tt>apt-get -u install <var>foo bar-</var></tt>
 <p>これは <var>foo</var> パッケージをインストールし、<var>bar</var> 
 パッケージを削除します。
<item><tt>apt-get remove <var>bar</var></tt>
 <p>これは <var>bar</var> パッケージを削除しますが、カスタマイズした
 設定ファイルをそのままに保ちます。
<item><tt>apt-get remove --purge <var>bar</var></tt>
 <p>これは <var>bar</var> パッケージと共に、カスタマイズした設定ファイルも
 削除します。
</list>
上の例では、<tt>-u</tt> オプションにより、<prgn>apt-get</prgn> が
アップグレードする予定のパッケージを表示し、実行に移る前にユーザに通知します。
次のコマンドは <tt>-u</tt> オプションを標準の動作に設定します:
<example>
$ cat &gt;&gt; /etc/apt/apt.conf &lt;&lt; .
// 更新するパッケージを常に表示する (-u)
APT::Get::Show-Upgraded "true";
.
</example>
<p>
実際に更新せずに更新をシミュレートするためには、 <tt>-s</tt> オプションを
使ってください。


<sect1 id="apt-tracking">&debian; ディストリビューションの特定 flavor を追いかける
<p>
&debian; のどの flavor を追いかけるかによって、要求に合うように
<ref id="setup-apt"> の <file>/etc/apt/preference</file> を変更できます:
<example>
stable を追いかける: testing の Pin-Priority を 50 に変更
testing を追いかける: 上記設定を保持
testing(unstable) を追いかける: unstable の Pin-Priority を 500 に変更
unstable(testing) を追いかける: unstable の Pin-Priority を 800 に変更
</example>
A guideline for the choice of Pin-Priority is to move from the top to bottom
in the above table as the time moves from a time immediately after a
distribution release to a time of freeze for the next release.
<p>
注意: &debian; の <tt>testing</tt> flavor を追いかけることには、
セキュリティ修正が非常に遅いという副作用があります。
<p>
&debian; の flavor を混在させている場合、<tt>stable</tt> に
<tt>testing</tt> または <tt>unstable</tt> を混ぜると、
<tt>testing</tt> または <tt>unstable</tt>
から意図せずに主要なパッケージを 
バグを持っている可能性があるにもかかわらず引っ張ってくることが良くあります。
ですから警告しておきます。
<p>
必須ではないパッケージは熟成されていないバージョンを追いかけるけれど、
いくつかの主要なパッケージは熟成されたバージョンを保持するための
<file>/etc/apt/preferences</file> の例は
<url id="&examples;" name="examples subdirectory"> に
<file>preferences.testing</file> や <file>preferences.unstable</file>
として得られます。
一方、<file>preferences.stable</file> は全パッケージを <tt>stable</tt>
にダウングレードさせます。

<sect1 id="apt-stable">全パッケージを <tt>stable</tt> にダウングレードする
<p>
全パッケージを <tt>stable</tt> にダウングレードするには、
<file>/etc/apt/preferences</file> を次のように編集します:
<example>
Package: *
Pin: release a=stable
Pin-Priority: 1001
</example>
そして "<tt>apt-get upgrade</tt>" を実行し、Pin-Priority &gt; 1000
に従いダウングレードを強行します。ささいな依存性に関する異常が生じる
かもしれないことを警告しておきます。

<sect1 id="apt-preferences"><file>/etc/apt/preferences</file> の概観
<p>
<ref id="setup-apt"> に示した <file>/etc/apt/preferences</file> の例では、
最初の行の "Package: *" は本セクションが全パッケージに適用されることを
意味しています。あるパッケージに Pin-Priority を指定するため、
"*" の代わりにパッケージ名を使いたいかもしれません。
<p>
次の行の "Pin: release a=stable" は <prgn>apt-get</prgn> が
"Archive: stable" 行を持つ <file>Release</file> ファイルを含む
アーカイブから <file>Packages.gz</file> を取得することを意味しています。
<p>
最後の行の "Pin-Priority: 500" は Pin-Priority を 500 に指定しています。
<p>
同じ名前のパッケージが複数ある場合は、通常最大の Pin-Priority 値を持つ
パッケージがインストールされます。
<p>
ここに、Pin-Priority の意味を示します:
<list>
<item>1001 以上: ダウングレード可能な優先度
 <p>この範囲の Pin-Priority ではパッケージのダウンロードが許されます。
<item>100 から 1000: 標準優先度
 <p>パッケージのダウングレードが許されません。いくつかの主要な Pin-Priority 値
を示します:
<list>
<item>990: <tt>--target-release</tt> 又は <manref name="apt-get" section="8">
オプションの <tt>-t</tt> によりセットされる優先度。
<item>500: 全ての標準のパッケージファイルに対する優先度。
<item>100: 現在インストールされているパッケージファイルに対する優先度。
</list>
<item>0 から 99: 手動の優先度。(これらはパッケージがインストールされておらず、他のバージョンが得られない場合に使われます。)
<item>0 以下: そのバージョンは決して選択されません。
</list>
<tt>--target-release</tt> と同じ効果が <file>/etc/apt/apt.conf</file>
に次のような設定を行うことにより得られます:
<example>
# echo 'APT::Default-Release "testing";' &gt;&gt; /etc/apt/apt.conf
</example>
コマンドラインオプション <tt>--target-release</tt> と
<file>/etc/apt/apt.conf</file> の設定は <file>/etc/apt/preferences</file>
の設定に優先します。<file>/etc/apt/preferences</file> で遊ぶ場合は
この干渉に注意してください。

<sect id="survival">Debian で生き残るためのコマンド
<p>
本章の知識により、<strong>永遠の</strong> upgrade 生活をすごせます。 :)

<sect1 id="bug-check">Debian のバグをチェックし、助けを求める
<P>
特定のパッケージに関する問題に直面している場合、助けを求めたり、
バグレポートを出す前にこれらのサイトをチェックしましょう。
(<prgn>lynx</prgn>、 <prgn>links</prgn> および <prgn>w3m</prgn> は
同じように機能します):

<example>
$ lynx &bugs;
$ lynx &bugs;<var>package-name</var>  # パッケージ名を知っている場合
$ lynx &bugs;<var>bugnumber</var>     # バグ番号を知っている場合
</example>
"site:debian.org" を含む検索語により Google (www.google.com) を検索して
みてください。
<p>
疑問がある場合は、良質のマニュアルを読んでください。<tt>CDPATH</tt> を
次のように設定してください:
<example>
export CDPATH=.:/usr/local:/usr/share/doc
</example>
そして次を実行してください。
<example>
$ cd <var>packagename</var>
$ pager README.Debian # 存在する場合
$ mc 
</example>
<![%f-ref;[
さらなるサポートリソースを <ref id="support"> に挙げます。
]]>
</sect1>

<sect1 id="apt-trouble">APT アップグレードのトラブルシュート
<p>
パッケージの依存性問題は <ref id="upgrade-system"> に記述したように
<tt>unstable</tt> 又は <tt>testing</tt> にアップグレードする場合に
発生する可能性があります。
ほとんどの場合、これはアップグレードされるパッケージが新たに解決されない
依存性の問題を持つためです。
<example>
# apt-get dist-upgrade
</example>
これが動かない場合、もんだ意が解決するまで次のコマンドを繰り返し実行してください:
<example>
# apt-get upgrade -f         # エラーが起きても upgradeを続ける
... 又は
# apt-get dist-upgrade -f    # エラーが起きても dist-upgrade を続ける
</example>
<p>
時々本当に壊れたアップグレードスクリプトにより持続的な問題を起こすことがあります。この種の状況を解決するには、<file>/var/lib/dpkg/info/<var>packagename</var>.{post,pre}{inst,rm}</file> スクリプトを調べ、次を実行するのがよいでしょう:
<example>
# dpkg --configure -a    # 部分的にインストールされたパッケージを全て設定
</example>
<p>
スクリプトに設定ファイルが無いと言っている場合、対応する設定ファイルに対して
<file>/etc/</file> を調べてください。<tt>.new</tt> (又は同種の) 拡張子
を持つファイルが存在する場合、名前を変更して拡張子を削除してください。
<p>
パッケージの依存性問題は <tt>unstable</tt> 又は <tt>testing</tt> に
インストールする場合に発生する場合があります。依存性を迂回する手段があります。
<example>
# apt-get install -f <var>package</var> # 壊れた依存性を上書きする
</example>
<p>
これらの状況を修正するための代替手段として、<package>equivs</package>
パッケージを使えます。 
<file>&f-equivs;</file><![%f-ref;[ and <ref id="equivs">]]> をご覧ください。
</sect1>

<sect1 id="rescue-dpkg"><prgn>dpkg</prgn> を用いたレスキュー
<p>
<prgn>dselect</prgn> (APT) のクラッシュから、本当に壊れたシステム上で
APT を用いずに <prgn>dpkg</prgn> だけを用いてアドホックに回復できます:
<example>
# cd /var/cache/apt/archives
# dpkg -i libc6* libdb2* perl*
# dpkg -i apt* dpkg* debconf*
# dpkg -i *  # エラーが起きなくなるまで実行
</example>
パッケージが無い場合、次のコマンドを用いて <url id="&mirror-site;" name="mirror sites"> から取得してください:
<example>
# mc            # "FTP link" を Debian FTP サーバに向けて使用
</example>
最近、HTTP/FTP サーバ上の実際のパッケージは古典的な <file>/dist</file>
に置かれず、<file>/pool/</file> ディレクトリに置かれています。
<![%f-ref;[
(<ref id="pools"> 参照.)
]]>
<p>
そして、次のようにインストールしてください:
<example>
# dpkg -i /var/cache/apt/archives/<var>packagefile.deb</var>
</example>
依存性が壊れている場合、修正するか、次のコマンドを使用してください:
<example>
# dpkg --ignore-depends=<var>package1</var>,... -i <var>packagefile.deb</var>
# dpkg --force-depends -i <var>packagefile.deb</var>
# dpkg --force-depends --purge <var>package</var>
# dpkg --force-confmiss -i <var>packagefile.deb</var> # 失った conffile をインストールする
</example>
</sect1>

<sect1 id="recover-status">パッケージ選択データの回復
<p>
<file>/var/lib/dpkg/status</file> がなんらかの理由で壊れた場合、
&debian; システムはパッケージ選択データを失い、ひどく苦しみます。
<file>/var/lib/dpkg/status-old</file> や<file>/var/backups/dpkg.status.*</file> にある古い <file>/var/lib/dpkg/status</file> ファイルを探してください。
<p>
別のパーティションに <file>/var/backups/</file> を保持するのは、
このディレクトリが多くの重要なシステムデータを含んでいるので、良い考えです。
<p>
古い <file>/var/lib/dpkg/status</file> ファイルが得られない場合、まだ
<file>/usr/share/doc/</file> にあるディレクトリからの情報で回復できます。
<example>
# ls /usr/share/doc | \
  grep -v [A-Z] | \
  grep -v '^texmf$' | \
  grep -v '^debian$' | \
  awk '{print $1 " install"}' | \
  dpkg --set-selections
# dselect --expert # システムを再インストールし、必要ない物を除外する
</example>

<sect1 id="rescue-var"><file>/var</file> のクラッシュ後のシステム回復
<p>
<file>/var</file> ディレクトリはメールなどの定期的に更新されるデータを
含むので、汚染されやすくなっています。このディレクトリを別のパーティションに
分けることにより、リスクを限定できます。故障が発生した場合、
<file>/var</file> ディレクトリを再構築して &debian; システムを回復
する必要があるかもしれません。
<p>
最小限 &debian; が機能する <file>/var</file> ディレクトリの基幹部分を同一又は古い &debian; バージョンから、例えば  <file><url id="&var-tar-gz;" name="var.tar.gz"></file> などを取得し、壊れたシステムの root ディレクトリに置きます。そして
<example>
# cd /
# mv var var-old      # 役に立つ内容が残っている場合
# tar xvzf var.tar.gz # Woody の基幹ファイルを使用
# aptitude            # 又は dselect
</example>
を実行します。これによりシステムが機能するようになるはずです。
<ref id="recover-status"> に記述している技術を用いてパッケージ選択データ
の回復をはかどらせることができます。
([FIXME]: 本手順はさらなる検証が必要。)
</sect1>

<sect1 id="un-bootable">ブート不能なシステムにパッケージをインストール
<p>
Debian レスキューフロッピ/CD 又は マルチブート Linux システム上の別の
パーティションを用いて Linux をブートしてください。
<![%f-ref;[
<ref id="booting"> 参照。 
]]>
ブート不可能なシステムを <file>/target</file> にマウントし、<prgn>dpkg</prgn>
の chroot install mode を使用します。
<example>
# dpkg --root /target -i <var>packagefile.deb</var>
</example>
そして設定を行い、問題を修正します。
<p>
ところで、<prgn>lilo</prgn> が壊れてブート不能になった場合、標準の
Debian レスキューディスクを用いてブートできます。
Linux をインストールしてある root パーティションを <file>/dev/hda12</file>
と仮定し、ランレベル 3 で起動したいとすると、lilo のプロンプトで次を
入力してください:
<example>
boot: rescue root=/dev/<var>hda12</var> 3
</example>
そしてフロッピディスク上の kernel を用いてほぼ完全に機能するシステムに
ブートできました。(kernel の機能やモジュールがないことによる些細な不都合が
存在するかもしれません。)
</sect1>

<sect1><prgn>dpkg</prgn> コマンドが壊れた場合どうするか
<p>
<prgn>dpkg</prgn> が壊れると <tt>.deb</tt> ファイルがインストール不能になります。次の手順によりこのような状況からの回復の助けになります。(第1行の
"links" を好みのブラウザコマンドに置き換えてください。)
<example>
$ links http://<var>http.us.debian.org</var>/debian/pool/main/d/dpkg/
  ... 良好な dpkg_<var>version</var>_<var>arch</var>.deb をダウンロード
$ su
password: *****
# ar x dpkg_<var>version</var>_<var>arch</var>.deb
# mv data.tar.gz /data.tar.gz
# cd /
# tar xzfv data.tar.gz
</example>
<tt>i386</tt> に対しては、 <tt>http://packages.debian.org/dpkg</tt> が
URL としても使われます。
</sect1>

</sect>

<sect id="debian-package">Debian 涅槃コマンド
<p>
これらのコマンドを <strong>愉しむ</strong> と、永遠のアップグレード地獄から救い出し、Debian の <strong>涅槃</strong> に導くことができます。:)

<sect1 id="info-file">ファイルに関する情報
<p>
あるファイルがどのパッケージに所属するかを見つけるには:
<example>
$ dpkg {-S|--search} pattern # インストール済みパッケージにパターン検索
$ zgrep -e pattern <var>/local/copy/of/debian/woody/Contents-i386.gz</var>
             # debian アーカイブでファイル名パターン検索
</example>
又は特別なパッケージコマンドを使います:
<example>
# apt-get install dlocate  
                 # slocate (locate の安全版と衝突する)
$ dlocate <var>filename</var>         # dpkg -L と dpkg -S の高速な代替品
...
# apt-get install auto-apt # オンデマンドのパッケージインストールツール
# auto-apt update          # autp-apt 用の db ファイルを作成
$ auto-apt search <var>pattern</var>  
# インストールされているかに係わらず、全パッケージをパターン検索
</example>
</sect1>

<sect1 id="info-package">パッケージ情報
<p>
パッケージアーカイブから情報を検索し、表示します。<file>/etc/apt/sources.list</file> を編集して APT が適切なアーカイブを指すようにしてください。
<tt>testing</tt> 又は <tt>unstable</tt> にあるパッケージが現在インストール
しているパッケージに対してどうなっているかを知るには、 
<tt>apt-cache policy</tt> を使うのが良いでしょう。
<example>
# apt-get   check      # キャッシュを更新し、壊れたパッケージをチェック
$ apt-cache search  <var>pattern</var> # テキストの説明からパッケージ検索
$ apt-cache policy  <var>package</var> # パッケージの priority/dist 情報を表示
$ apt-cache show -a <var>package</var> # 全 dists のパッケージ説明を表示
$ apt-cache showsrc <var>package</var> 
# マッチした source パッケージの説明を表示
$ apt-cache showpkg <var>package</var> # パッケージのデバッグ情報を表示
# dpkg  --audit|-C          # 部分的にインストールされたパッケージを検索
$ dpkg {-s|--status} <var>package</var> ... 
# インストール済みのパッケージの説明を表示
$ dpkg -l <var>package</var> ...       
# インストール済みパッケージのステータスを表示 (1行毎)
$ dpkg -L <var>package</var> ...       
# 指定したパッケージに含まれるファイル名リストを表示
</example>
<!-- Erase this when manual page gets fixed.  FIXME -->
<tt>apt-cache showrc</tt> は Woody リリースではドキュメント化されていませんが、使えます :)
<p>
また、次に挙げるファイルからもパッケージ情報を検索できます(これらを見るのに
<tt>mc</tt> を使っています):
<example>
/var/lib/apt/lists/*
/var/lib/dpkg/available
</example>
次のファイルを比較すると、最後のインストールセッションで何が起きたかが
正確に分かります。
<example>
/var/lib/dpkg/status
/var/backups/dpkg.status*
</example>

</sect1>

<sect1 id="apt-get-auto">APT によりキーボードに触らずにインストール
<p>
キーボードに触らずにインストールするには、次の行を <file>/etc/apt/apt.conf</file> に追加してください:
<example>
Dpkg::Options {"--force-confold";}
</example>
これは <tt>apt-get -q -y <var>packagename</var></tt> を起動するのと同じことです。これは全プロンプトについて自動的に "yes" で答えるので、問題が発生するかもしれません。ゆえに慎重にこのトリックを使ってください。
<manref name="apt.conf" section="5"> および <manref name="dpkg" section="1">
をご覧ください。
<p>
<ref id="reconfigure"> に従い、特定のパッケージを後で設定することもできます。

<sect1 id="reconfigure">インストール済みパッケージの再設定
<p>
Use the following to reconfigure any already-installed package.
次のコマンドを使ってインストール済みパッケージの再設定を行います。
<example>
# dpkg-reconfigure --priority=<var>medium</var> <var>package</var> [...]
# dpkg-reconfigure --all   # 全パッケージの再設定
# dpkg-reconfigure locales # 特別な locale の生成
# dpkg-reconfigure --p=<var>low</var> xserver-xfree86 # X サーバの再設定
</example>
<prgn>debconf</prgn> ダイアログモードが永続的に必要な場合は、
<prgn>debconf</prgn> を再設定してください。
<p>
特別な設定スクリプトを持つプログラムがいくつかあります。
<footnote>
いくつかの <prgn>*config</prgn> スクリプトは新しい Sarge リリースでは
消えており、パッケージの設定機能は <prgn>debconf</prgn> に移動しています。
</footnote>
<example>
apt-setup     - /etc/apt/sources.list の生成
install-mbr   - Master Boot Record manager のインストール
tzconfig      - ローカル time zone の設定
gpmconfig     - gpm マウスデーモンの設定
sambaconfig   - Potato で Samba の設定を行う (Woody は debconf を使用)
eximconfig    - Exim (MTA) の設定
texconfig     - teTeX の設定
apacheconfig  - Apache (httpd) の設定
cvsconfig     - CVS の設定
sndconfig     - サウンドシステムの設定
...
update-alternatives - 標準のコマンドの設定、例えば vim を vi に設定
update-rc.d         - System-V init スクリプトマネージャ
update-menus        - Debian menu システム
...
</example>
</sect1>

<sect1 id="remove">パッケージの削除及びパージ
<p>
設定ファイルを維持したままパッケージを削除:
<example>
# apt-get remove <var>package</var> ...
# dpkg  --remove <var>package</var> ...
</example>
設定ファイルを含め、パッケージを削除:
<example>
# apt-get remove --purge <var>package</var> ...
# dpkg    --purge        <var>package</var> ...
</example>
</sect1>

<sect1 id="hold">古いパッケージをホールド
<p>
例えば、<package>libc6</package> と <package>libc6-dev</package> を
<prgn>dselect</prgn> および <tt>apt-get -u upgrade <var>package</var></tt>
に対してホールドするには、次を実行します:
<example>
# echo -e "libc6 hold\nlibc6-dev hold" | dpkg --set-selections
</example>
<tt>apt-get -u install <var>package</var></tt> はこの "hold" により隠されません。 <tt>apt-get -u upgrade <var>package</var></tt> 又は  <tt>apt-get -u dist-upgrade</tt> に対する自動ダウングレードの強行からパッケージをホールドするには、
<file>/etc/apt/preferences</file> に次の行を追加してください:
<example>
Package: libc6
Pin: release a=stable
Pin-Priority: 2000
</example>
ここで、 "<tt>Package:</tt>" エントリは "<tt>libc6*</tt>" のようなエントリを使えません。<package>glibc</package> source パッケージに同期したバージョンの全バイナリパッケージを保持する必要がある場合、それらのパッケージを明示的に挙げる必要があります。
<p>
次のコマンドによりホールドされたパッケージをリストできます:
<example>
dpkg --get-selections "*"|grep -e "hold$"
</example>
</sect1>

<sect1 id="mixedsys"><tt>stable</tt>/<tt>testing</tt>/<tt>unstable</tt> システムの混在
<p>
<prgn>apt-show-versions</prgn> により、インストール済みパッケージのバージョン/flavor をリスト化できます。
<example>
$ apt-show-versions | fgrep /testing | wc
... testing からのパッケージ数をカウント
$ apt-show-versions -u
... アップグレード可能なパッケージ数
$ apt-get install `apt-show-versions -u -b | fgrep /unstable`
... 全ての unstable パッケージを最新バージョンにアップグレード
</example>
</sect1>

<sect1 id="cache">キャッシュされたパッケージファイルを取り除く
<p>
APT でパッケージをインストールすると、キャッシュされたパッケージファイルが
<file>/var/cache/apt/archives</file> に残されるので、これらを消す必要が
あります。
<example>
# apt-get autoclean # 必要ないパッケージファイルのみ削除
# apt-get clean     # キャッシュされたパッケージファイル全てを削除
</example>
</sect1>


<sect1 id="record">システム設定の記録/コピー
<p>
パッケージ選択ステータスのローカルコピーを取るには、次を実行します:
<example>
$ dpkg --get-selections "*" &gt;<var>myselections</var>   # 又は \* を使用
</example>
<tt>"*"</tt> により、<tt><var>myselections</var></tt> が "purge" 用の
パッケージエントリにも含まれるようになります。
<p>
このファイルを他のコンピュータに転送し、これを使ってインストールできます:
<example>
# dselect update
# dpkg --set-selections &lt;<var>myselections</var>
# apt-get -u dselect-upgrade    # <var>又は</var> dselect install
</example>
</sect1>

<sect1 id="port"><tt>stable</tt> システムへのパッケージ移植
<p>
<tt>stable</tt> システムの部分的なアップグレードのためには、ソースパッケージを
用いて <tt>stable</tt> 環境でパッケージを再構築するのが望ましいです。パッケージ再構築により、依存性による強引なパッケージアップグレードを避けることができます。まず、次のエントリを <file>/etc/apt/sources.list</file> に追加します:
<example>
deb-src &http-us;debian testing \
 main contrib non-free
deb-src &http-non-us;debian-non-US testing/non-US \
 main contrib non-free
deb-src &http-us;debian unstable \
 main contrib non-free
deb-src &http-non-us;debian-non-US unstable/non-US \
 main contrib non-free
</example>
ここで、<tt>deb-src</tt> に対する各エントリは印刷時の制限のために2行に分割されていますが、実際の <file>sources.list</file> は一行としてください。
<p>
そしてソースを取得し、ローカルパッケージを作成します:
<example>
$ apt-get update  # ソースパッケージの検索リストを更新
$ apt-get source <var>package</var>
$ dpkg-source -x <var>package.dsc</var>
$ cd <var>package-version</var>
  ... 要求されたパッケージを検査 (.dsc ファイル中の Build-depends) し、
      それらもインストールする。"fakeroot" パッケージも必要。

$ dpkg-buildpackage -rfakeroot 

  ...又は (サイン無し)
$ dpkg-buildpackage -rfakeroot -us -uc #必要ならば後で "debsign" を使用

  ...そしてインストール
$ su -c "dpkg -i <var>packagefile.deb</var>"
</example>
普通、"-dev" サフィックスが付く2、3個のパッケージは、パッケージの依存性を
満たすためにインストールする必要があります。<prgn>debsign</prgn> は
<package>devscripts</package> パッケージにあります。<prgn>auto-apt</prgn>
を使うと、依存性を簡単に満足させられるかもしれません。<prgn>fakeroot</prgn>
を使うと、root アカウントの不必要な使用を避けられます。
<p>
Woody では、依存性の問題は単純にできます。例えば、
ソースのみの <package>pine</package> パッケージをコンパイルするには、
<example>
# apt-get build-dep pine
# apt-get source -b pine
</example>
だけです。
</sect1>

<sect1 id="local">ローカルパッケージのアーカイブ
<p>
APT 並びに <prgn>dselect</prgn> システムとの互換性を持つローカルパッケージの
アーカイブを作成するには、<file>Packages</file> を作成し、
特定のディレクトリツリーに置く必要があります。
<p>
公式の Debian アーカイブと同様のローカル <tt>deb</tt> リポジトリは次のように
作成できます:
<example>
# apt-get install dpkg-dev
# cd <var>/usr/local</var>
# install -d <var>pool</var> # 真のパッケージはここに置きます
# install -d dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>
# ls -1 <var>pool</var> | sed 's/_.*$/ <var>priority</var> <var>section</var>/' | uniq &gt; <var>override</var>
# editor <var>override</var> # <var>priority</var> と <var>section</var> を調整
# dpkg-scanpackages <var>pool</var> <var>override</var> <var>/usr/local</var>/ \
   &gt; dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>/Packages
# cat &gt; dists/<var>unstable</var>/<var>main</var>/Release &lt;&lt; EOF
Archive: <var>unstable</var>
Version: <var>3.0</var>
Component: <var>main</var>
Origin: <var>Local</var>
Label: <var>Local</var>
Architecture: <var>i386</var>
EOF
# echo "deb file:<var>/usr/local</var> <var>unstable</var> <var>main</var>" \
   &gt;&gt; /etc/apt/sources.list
</example>
<p>
代わりに、手早いけど汚いローカル <tt>deb</tt> リポジトリは次のように作れます:
<example>
# apt-get install dpkg-dev
# mkdir <var>/usr/local/debian</var>
# mv <var>/some/where/package.deb</var> <var>/usr/local/debian</var>
# dpkg-scanpackages <var>/usr/local/debian</var> /dev/null | \
  gzip - &gt; <var>/usr/local/debian</var>/Packages.gz
#  echo "deb file:<var>/usr/local/debian</var> ./" &gt;&gt; /etc/apt/sources.list
</example>
<p>
HTTP や FTP メソッドによりディレクトリへのアクセス手段を供給し、
<file>/etc/apt/sources.list</file> にエントリを追加することにより、
これらのアーカイブへのリモートからのアクセスを可能にします。

<sect1 id="alien">alien バイナリパッケージへの変換又はインストール
<p>
<package>alien</package> はRed Hat <tt>rpm</tt> 形式、Stampede <tt>slp</tt> 形式、Slackware <tt>tgz</tt> 形式、そして Solaris <tt>pkg</tt> 形式で供給される
バイナリパッケージを &debian; <tt>deb</tt> パッケージ形式に変換することを
可能とします。他の Linux ディストリビューションからのパッケージを
システムにインストールしているディストリビューションで使いたい場合、
<prgn>alien</prgn> を使って使用中のディストリビューションのパッケージフォーマットに変換し、インストールできます。<package>alien</package> は
LSB パッケージもサポートします。
</sect1>

<sect1 id="debsums">インストールされたパッケージファイルを検証する
<p>
<prgn>debsums</prgn> は MD5 チェックサムを用いてインストールされたパッケージファイルの検証ができます。いくつかのパッケージは MD5 チェックサムを得られません。
システム管理者が可能な一時的な修正はこのようなものです:
<example>
# cat >>/etc/apt/apt.conf.d/90debsums
DPkg::Post-Install-Pkgs {"xargs /usr/bin/debsums -sg";};
^D
</example>
Joerg Wendland <email>joergland@debian.org</email> からのメールによる。
(未検証).

<![%f-ref;[
<sect1 id="spy">最適化された <file>sources.list</file>
<p>
簡単に言うと、最適化された <file>sources.list</file> を作成するための手の込んだ努力は USA に住んでいる私にとってはあまり効果を生みませんでした。
私は <prgn>apt-setup</prgn> を使って近くのサイトを手動で選びました。
<p>
<prgn>apt-spy</prgn> はレイテンシとバンド幅に基づいて自動で 
<file>sources.list</file> を作成します。 <prgn>netselect-apt</prgn> 
はより完全な <file>sources.list</file> を作成しますが、最適なミラーサイト
を選択する、より優れた方法 (ping 時間の比較) を使用しています。
<example>
# apt-get install apt-spy
# cd /etc/apt ; mv sources.list sources.list.org
# apt-spy -d testing -l sources.apt
</example>
</sect1>

]]>


</sect>

<sect id="pecuriarities">他の Debian 独特な点

<sect1 id="dpkg-divert"><prgn>dpkg-divert</prgn> コマンド
<p>
<!-- copied from manual page -->
<strong>Diversions</strong> というファイルにより、<prgn>dpkg</prgn> は
ファイルをインストールする時に本来意図していた場所ではなく、
<strong>退避した</strong> 場所にインストールするようになる。
<strong>Diversions</strong> は &debian; パッケージスクリプトで衝突がおこりうる
ファイルを移動させるために使うことができる。システム管理者はパッケー ジ
の設定ファイルや他のファイルを (<strong>conffiles</strong> としてマーク
されていなければ) <prgn>dpkg</prgn> が新しいバージョンのパッケージを
インストールする時にそれらのファイルを上書きしてしまわないようにするために
diversion を使うことができる。
<![%f-ref;[
(<ref id="conffile">) 参照]]>.
<example>
# dpkg-divert [--add]  <var>filename</var> # "diversion" を追加
# dpkg-divert --remove <var>filename</var> # "diversion" を削除
</example>
本当に必要でない限り、<prgn>dpkg-divert</prgn> を使わない方が
通常は良いでしょう。
</sect1>

<sect1 id="equivs"><package>equivs</package> パッケージ
<p>
ソースからプログラムをコンパイルした場合、最も良いのは本当のローカルな
debian 化したパッケージ (<tt>.deb</tt>) にすることです。
<tt>equivs</tt> を最後の手段として使います。
<example>
Package: equivs
Priority: extra
Section: admin
Description: Debian パッケージの依存関係を偽るためのパッケージ
 これはダミーパッケージで、依存情報だけを含んだ Debian パッケージの
 作成に使用することができます。
</example>
</sect1>

<sect1 id="alternatives">Alternative コマンド
<p>
<prgn>vi</prgn> コマンドが <prgn>vim</prgn> を起動するようにするには、
<prgn>update-alternatives</prgn> を使います:
<example>
# update-alternatives --display vi
...
# update-alternatives --config vi
  Selection    Command
-----------------------------------------------
      1        /usr/bin/elvis-tiny
      2        /usr/bin/vim
*+    3        /usr/bin/nvi

default[*] を保つために Enter を打つか、selection 番号 2 をタイプしましょう。
</example>
Debian alternatives システムのアイテムは <file>/etc/alternatives/</file> に
シンボリックリンクとして保持されています。
<p>
好みの X Window 環境を設定するには、<prgn>update-alternatives</prgn> を
<file>/usr/bin/x-session-manager</file> と 
<file>/usr/bin/x-window-manager</file> に適用します。
<![%f-ref;[
詳細は、<ref id="custom-x"> を参照。
]]>
<p>
<file>/bin/sh</file> は <file>/bin/bash</file> 又は <file>/bin/dash</file>
の直接のシンボリックリンクです。  
古い Bashism で汚染されたスクリプトとの互換性のため、 <file>/bin/bash</file>
を使う方が安全ですが、POSIX 互換性を強制するには、<file>/bin/dash</file>
を使うのがより良い訓練となります。
2.4 Linux kernel にアップグレードすると、<file>/bin/sh</file> を
<file>/bin/dash</file> にセットしがちです。
</sect1>

<sect1 id="sys-v">System-V <prgn>init</prgn> およびランレベル
<p>
ブートする標準のランレベルは <file>/etc/inittab</file> で設定できます。
<p>
他のディストリビューションと違い、Debian はランレベル管理を完全にシステム管理者の責任にしています。System-V スタイルの <prgn>init</prgn> の Debian 上での
管理は <prgn>update-rc.d</prgn> スクリプトにより行われることを意図しています。
<p>
ランレベル 1,2,3 で  <file>/etc/init.d/<var>name</var></file> を起動し、
ランレベル 4,5 で停止し、優先度番号 20 (通常) を振るには、次のようにします:
<example>
# update-rc.d <var>name</var> start 20 1 2 3 . stop 20 4 5 .
</example>
<prgn>init.d</prgn> にまだあるスクリプトのシンボリックリンクを削除するには、
次のようにします:
<example>
# update-rc.d -f <var>name</var> remove
</example>
ランレベルの編集には、私はずるをします。<prgn>mc</prgn> のシェルプロンプトで
Alt-Enter を使ってリンクエントリをコピーしながら、<prgn>mv</prgn> コマンドを
使って手動でエントリを編集します。例えば:
<example>
# mv S99xdm K99xdm # xdm (X display manager) を無効にする
</example>
クイックハックとして、<prgn>init.d</prgn> スクリプトの先頭に <tt>exit 0</tt>
を挿入することによりデーモンを無効にさえします。
これらは結局のところ <tt>conffile</tt> です。
</sect1>

<sect1 id="disables">デーモンサービスを無効にする
<p>
&debian; ディストリビューションはシステムのセキュリティを厳しくし、
システム管理者が有能であることを期待しています。それゆえ、
時々、使いかたを簡単にするとは二次的的な問題とみなされ、多くのデーモン
サービスは最高のセキュリティレベルとされ、標準のインストール状態として
使用可能なサービスが少ない (又は全く無い) 状態となっています。
<p>
デーモンサービス (Exim, DHCP など) に疑いを持った場合、
<tt>ps aux</tt> を起動するか、<file>/etc/init.d/*</file> や
<file>/etc/inetd.conf</file> の内容を調べましょう。
また、<file>/etc/hosts.deny</file>
<![%f-ref;[ 
<ref id="loginctrl"> 参照
]]>
も調べましょう。
<prgn>pidof</prgn> コマンドも役立ちます。
(<manref name="pidof" section="8"> 参照)

<p>
最近の &debian; において、標準では X11 は TCP/IP 経由の遠隔接続を
許可していません。
<![%f-ref;[
<ref id="xtcp"> 参照
]]>

SSH での X フォワードも無効にされています。
<![%f-ref;[
<ref id="xssh"> 参照
]]>
</sect1>
</sect>

</chapt>

