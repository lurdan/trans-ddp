<!-- CVS revision of this document "$Revision: 1.1 $"  -->
<!-- CVS revision of original english document "1.61"  -->
<chapt id="system">Debian の基礎知識

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p> 
本章は非開発者のために Debian システムの基礎的な情報を供給します。
信頼できる情報が欲しい場合は、次を参照してください:

<list compact>
<item>Debian ポリシーマニュアル
<item>Debian パッケージングマニュアル (Potato)
<item>Debian デベロッパーリファレンス
<item>Debian ニューメンテナーズガイド
</list>
<ref id="references"> にリストされています。

<p>
あまり詳しくない "how-to" 的な説明を探している場合、
<ref id="package"> や他の該当する章にすぐ飛んでください。
<p>
本章は "Debian FAQ" から取られた文書に基づき、通常の Debian 
システム管理者が始められるように大規模な再構成を行いました。

<!-- 
HTTP や他の方法でも取得できるので、"FTP archives" は現在シンプルな 
"archives" に変更されました。
-->

<sect id="ftparchives">Debian アーカイブ

<sect1 id="dirtree">ディレクトリ構造

<p>&debian; 用にパッケージングされているソフトウェアは
<url id="&mirror-site; "name="Debian mirror site"> のそれぞれのいくつかの
ディレクトリツリーの一つから FTP 並びに HTTP 経由で取得できます。

<p>次のディレクトリは 各 Debian ミラーサイトの <file>debian</file> 
ディレクトリの下で見つかります:
<taglist>
  <tag><file>dists/</file>:
    <item>このディレクトリには "distributions" が含まれており、これは
    現在 Debian relaese および pre-release で得られるパッケージへの
    標準的なアクセス手段として使用されます。いくつかの古いパッケージや
    <file>Packages.gz</file> もまだここにあります。
  <tag><file>pool/</file>:
    <item>ここは Debian release および pre-release の全パッケージ
    の物理的に存在する場所です。
  <tag><file>tools/</file>:
    <item>ブートディスク作成、ハードディスクのパーティショニング、
    ファイル圧縮/解凍、そして Linux のブート用の DOS ユーティリティが
    ここにあります。
  <tag><file>doc/</file>:
    <item>FAQ, バグ報告システム指示書などの基本的な Debian に関する
    文書がここにあります。
  <tag><file>indices/</file>:
    <item>Maintainers ファイルや override ファイルがここにあります。
  <tag><file>project/</file>:
    <item>主に開発者のみ必要なものです。例えば:
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>本ディレクトリにはまだ開発中であり、まだ α テスト段階の
        パッケージやツールが含まれます。ユーザはここにあるパッケージを
        使用するべきではありません。なぜなら最も経験を積んだひとでさえも
        危険で害を及ぼす可能性があるからです。
      <tag><file>project/orphaned/</file>:
        <item>古いメンテナにより「みなしご化」され、ディストリビューションから
        なくなったパッケージです。
    </taglist>
</taglist>

<sect1 id="dists">Debian ディストリビューション

<p>通常 <file>dists</file> ディレクトリには 3種類の Debian 
ディストリビューションが存在します。これらは <tt>stable</tt> 、 
<tt>testing</tt> そして <tt>unstable</tt> と呼ばれます。
時々 <tt>frozen</tt> も存在します。各ディストリビューションは 
<file>dists</file> ディレクトリにある、コードネームが付いた
実際のディレクトリのシンボリックリンクとして定義されています。

<sect1 id="stable"><tt>stable</tt> ディストリビューション

<p><tt>stable</tt> ディストリビューション, &stabledebian; 用のパッケージ
エントリは <tt>stable</tt> (<file>&stablecodenamedir;/</file> への
シンボリックリンク) ディレクトリに記録されています:
<list>
  <item><file>stable/main/</file>:
  このディレクトリには &debian; システムの最新のリリースを正式に構成する
  パッケージが含まれます。

  <p>これらのパッケージは全て  <url name="Debian Free Software
  Guidelines (DFSG)" id="&social-contract;#guidelines">
  (<package>&p-social-contract;</package>)  によりインストールされる
   <file>&f-social-contract;</file> としても取得可能) を全て準拠しており、
  全て自由な使用と再配布が可能です。

  <item><file>stable/non-free/</file>:  このディレクトリには、
  特別な著作権要求に配布者が細心の注意を払う必要があるような、
  配布制限されたパッケージが含まれます。

  <p>例えば、いくつかのパッケージは商用配布を禁止するライセンスを持っています。
  また、再配布可能ですが、実はシェアウェアでフリーソフトでは
  ないパッケージもあります。どのような再配布物 (CD-ROM など )に含めるのであれ、   それぞれのパッケージの使用許諾を事前に調べておき、できるだけ交渉して
  おかなければなりません。

  <item><file>stable/contrib/</file>: このディレクトリには
  DFSG-free でそれら自体は <strong>自由に再配布可能</strong> ですが、
  フリーに再配布 <strong>できない</strong> ため、non-free セクションでしか
  得られないパッケージにどういうわけか依存しているパッケージが含まれます。
</list>
現在は、上に挙げた場所に加えて、<file>pool</file> ディレクトリに新しい
物理的なパッケージがあります。 (<ref id="pools"> 参照)

<p><tt>stable</tt> ディストリビューションの最新バグステータスは
<url id="&stable-problems;" name="Stable Problems"> web ページに
報告されています。


<sect1 id="testing"><tt>testing</tt> ディストリビューション

<p><tt>testing</tt> ディストリビューション、&testingdebian; のパッケージ
エントリは <tt>unstable</tt> でしばらくテストを受けた後に
<file>testing</file> (<file>&testingcodenamedir;/</file> への
シンボリックリンク) ディレクトリに記録されます。
上に挙げた場所に加え、<file>pool</file> ディレクトリに新しい
物理的なパッケージがあります。 (<ref id="pools"> 参照)
<file>testing/</file> に <file>stable/</file> と同じ機能を提供する 
<file>main</file>、<file>contrib</file> そして <file>non-free</file>
サブディレクトリもあります。

<p>これらのパッケージはビルドされ、インストール不能なパッケージに依存しない
全アーキテクチャで同期しなくてはなりません。また、<tt>unstable</tt>
にあるバージョンよりも release-critical bug が少なくてはなりません。
このように、<tt>testing</tt> は常に release candidate 間近であることを
希望しています。testing のメカニズムの詳細については
<url id="&testing-notes;"> にあります。

<p><tt>testing</tt> ディストリビューションの最新バグステータスはこれらのサイト
で報告されています:
<list compact>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="other bugs and bug-squashing party notes">
</list>

<sect1 id="unstable"><tt>unstable</tt> ディストリビューション

<p><tt>unstable</tt> ディストリビューションは、常に "Sid" というコードネームであり、パッケージエントリは Debian archive にアップロードされた後に 
<file>unstable</file> (<file>sid/</file> へのシンボリックリンク) ディレクトリに
記録され、<file>testing/</file> に移動されるまでここにあります。
上に挙げた場所に加え、<file>pool</file> ディレクトリに新しい
物理的なパッケージがあります。 (<ref id="pools"> 参照)
<file>testing/</file> に <file>stable/</file> と同じ機能を提供する 
<file>main</file>、<file>contrib</file> そして <file>non-free</file>
サブディレクトリもあります。

<p><tt>unstable</tt> ディストリビューションには最新の開発版システムの
スナップショットが含まれます。ユーザがパッケージを使ってテストするのは
歓迎されますが、これらのパッケージが準備段階にあることは警告されます。
<tt>unstable</tt> ディストリビューションを使う利点としては、
常に最新の &debian; ソフトウェアプロジェクトを使えます。
&mdash; たとえシステムを壊すようなことがあったとしても、
壊れたシステムをそのままキープできます。

<p><tt>unstable</tt> ディストリビューションの最新バグステータスは
<url id="&unstable-problems;" name="Unstable Problems"> web ページで
報告されています。

<!-- Above was enough
<sect1 id="sid">The Sid distribution

<p>Sid or <tt>unstable</tt> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <tt>testing</tt>,
in order to be released in <tt>stable</tt> later on. Sid contains packages
for both released and unreleased architectures.

<p>The name "Sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen"><tt>frozen</tt> ディストリビューション

<p><tt>testing</tt> ディストリビューションが充分成熟すると、frozen されます。
そして、新しいコードはもはや受け付けず、必要ならばバグフィックスのみ
受け付けられます。さらに、新しい testing ツリーが <file>dists</file>
ディレクトリに作成され、新しいコードネームを割り当てられます。
frozen ディストリビューションは数ヵ月テストされ、"テストサイクル"
と呼ばれる deep freeze に入ります。
(最近の Woody リリースは <file>froze</file> シンボリックリンクを作成
しません。それゆえ、<tt>frozen</tt> はディストリビューションではなく、
<tt>testing</tt> ディストリビューションの開発段階です。)

<p>パッケージのリリースを遅らせたり、リリース全体を止めてしまう
frozen ディストリビューションのバグを記録し続けています。
バグ総数が最大許容数を下回ったら、frozen ディストリビューション
は stable になり、リリースされます。そして以前の stable ディストリビューション
は obsolete になります。(そして archive に移動します)

<sect1 id="codenames">Debian ディストリビューションのコードネーム

<p><file>&stablecodenamedir;/</file> や <file>&testingcodenamedir;/</file>
などの、<file>dists</file> ディレクトリにある物理的に存在するディレクトリ名は、
単なる "コードネーム" です。&debian; ディストリビューションが開発段階に
あるとき、バージョン番号を持ちませんが、その代わりコードネームを持ちます。
これらのコードネームの目的は、&debian; ディストリビューションのミラーリングを
より簡単に行うためです。(<file>unstable</file> のような真のディレクトリ名が
<file>stable</file> に突然変わると、多くの努力が無駄になり、再び
ダウンロードを行わなくてはならなくなります)

<p>現在、<file>stable</file> は <file>&stablecodenamedir;/</file> の、
<file>testing</file> は <file>&testingcodenamedir;/</file> のシンボリック
リンクです。これは <tt>&stablecodename;</tt> が現在の stable 
ディストリビューションであり、<tt>&testingcodename;</tt> が現在の
testing ディストリビューションであることを意味しています。

<p>Sid は常に unstable ディストリビューションですので、<file>usstable/</file>
は <file>sid/</file> の永続的なシンボリックリンクです。 
<!-- (<ref id="sid">参照)。-->

<sect1 id="oldcodenames">過去に使用されたコードネーム

<p>過去に使われたコードネームは次の通り:
release 1.1 では "Buzz", release 1.2 では "Rex", release 1.3.x では
"Bo", release 2.0 では "Hamm", release 2.1 では "Slink", release 2.2
では "Potato"。

<sect1 id="sourceforcodenames">コードネームの由来

<p>いままではコードネームは Pixar 作の映画 <em>トイストーリー</em> の
キャラクター名から取られていました。
<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) は宇宙飛行士です。
  <item><strong>Rex</strong> はチラノザウルスです。
  <item><strong>Bo</strong> (Bo Peep) は羊飼いの娘です。
  <item><strong>Hamm</strong> は子供銀行です。
  <item><strong>Slink</strong> (Slinky Dog) おもちゃの犬です。
  <item><strong>Sarge</strong> はグリーンプラスティックアーミーのリーダーです。
  <item><strong>Potato</strong> はもちろん、ミスターポテトです。
  <item><strong>Woody</strong> はカウボーイです。
  <item><strong>Sid</strong> は次のドアで人形を破壊する人形です。
</list>
<!--
  more info in http://www.pixar.com/featurefilms/ts/index.html
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Etch (Etch-a-Sketch) (the blackboard)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools"><file>pool</file> ディレクトリ

<p>歴史的に、パッケージはパッケージを含むディストリビューションに対応した
<file>dists</file> サブディレクトリに保持されました。これは大きな変更が
発生した場合、ミラーするのに大きなバンド幅を消費するなどのさまざまな
問題を引き起こしました。

<p>パッケージは現在大きな "pool" に保存され、source パッケージの名前に
従って構造化されます。この "pool" を管理可能にするため、pool は
セクション (<tt>main</tt>, <tt>contrib</tt> そして <tt>non-free</tt>)
および source パッケージの先頭の文字により分割されます。これらのディレクトリ
にはいくつかのファイル: 各アーキテクチャ用のバイナリパッケージ、そして
バイナリパッケージの生成元である source パッケージが含まれます。

<p><tt>apt-cache showrc <var>mypackagename</var></tt> のようなコマンドを
実行し、"Directory:" 行を見ることにより、パッケージの場所を見つけられます。
例えば、<package>apache</package> パッケージは  
<file>pool/main/a/apache/</file> にあります。非常に多くの <tt>lib*</tt> 
パッケージが存在するため、これらのパッケージは特別扱いされています:
例えば、<package>libpaper</package> パッケージは 
<file>pool/main/libp/libpaper/</file> に保存されています。

<p><file>dists</file> ディレクトリは依然 <prgn>apt</prgn> のような
プログラムにより使用される索引ファイルのために使われています。また、
本文書を書いている時点では、以前のディストリビューションは pool を
使うように変換されていませんので、"Directory" ヘッダフィールドの
<tt>potato</tt> や <tt>woody</tt> のようなディストリビューション名を
含むパスを見掛けるでしょう。

<p>新しい <prgn>apt</prgn> や多分古い <prgn>dpkg-ftp</prgn> (<ref id="howtocurrent"> 参照) はシームレスな処理を行うので、通常はこれらのことを心配する
必要はありません。詳細を知りたい場合は、<url id="&pool-faq;" name="RFC: implementation of package pools"> をご覧ください。

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Sid に関するヒストリカルノート

<p>昔 Sid は存在していませんでした。Debian archive サイトは大きな欠陥を一つ持っていました: アーキテクチャが最新の <file>unstable</file> に作られた時、
ディストリビューションが新しい <tt>stable</tt> になった時にそれがリリースされるという前提がありました。このケースにあてはまらない多くのアーキテクチャにとって、リリース時にこれらのディレクトリが移動しなければならないという結果となりました。この移動が膨大なバンド幅を消費するため、これは実際的ではありません。

<p>アーキテクチャ管理者はこの問題に数年間取り掛かり、<file>sid</file> と
呼ばれる特別なディレクトリに未リリースのアーキテクチャのためのバイナリを置く
ことにより問題を解決しました。未リリースのアーキテクチャが最初にリリースされる
場合、最新の <file>stable/</file> に対し <file>sid/</file> がリンク
されました。そして、それ以降は通常どおり <file>unstable</file> 内に
バイナリが作成されました。

<p>Woody ディストリビューションの開発中にパッケージプールを
(<ref id="pools"> 参照) 発明したことにより、バイナリパッケージは
ディストリビューションに依らずにプール内の標準的な場所に保存され始めました。
それゆえ、ディストリビューションのリリースを行っても、もはやミラー時に
大きなバンド幅を消費しません。(しかし、開発過程を通し、緩やかなバンド幅
消費が発生します。)

<sect1 id="incoming"><file>incoming/</file> にパッケージをアップロードする
<p>パッケージのアップロードはそれらが本当に Debian 開発者からのものかを
検査した後に <url id="&incoming;"> にまず置かれます。
(そしてそれがノンメンテナアップロード (NMU) の場合は、<file>DELAYED</file>
サブディレクトリに置かれます。)
一日に一度、それらは <file>incoming/</file> から <file>unstable/</file> 
に移されます。
<p>
緊急時には、<file>incoming/</file> が <file>unstable/</file> に移る前に
パッケージをインストールしたい場合があるかもしれません。
</sect1>

<sect1 id="snapshot">古いパッケージを取得する
<p>
最新の Debian ディストリビューションは <url id="&mirror-site;" name="Debian mirror site"> の <file>debian</file> ディレクトリ下に保持されますが、Slink 
などの古い Debian ディストリビューションのアーカイブは 
<url id="&archivehome;"> や Debian の各ミラーサイトの 
<file>debian-archive</file> ディレクトリに保存されています。
<p>
<tt>testing</tt> や <tt>unstable</tt> の昔のパッケージは
<url id="&snapshothome;"> にあります。

</sect1>

<sect1 id="archsections">アーキテクチャセクション
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>主要なディレクトリツリーそれぞれ (<file>dists/stable/main</file>,
<file>dists/stable/contrib</file>, <file>dists/stable/non-free</file>, 
<file>dists/unstable/main/</file> など) の中に、バイナリパッケージエントリが
パッケージがコンパイルされたアーキテクチャを示す名前を持つサブディレクトリ
内に存在します。

<list>
  <item><file>binary-all/</file> 、アーキテクチャに依存しないパッケージ用。
  これらには例えば、Perl スクリプトや、純粋なドキュメントが含まれます。
  <item><file>binary-<var>platform</var>/</file> 、特定のバイナリ
  プラットフォームで実行するパッケージ用。
  <!-- Yes I simplified this -->
</list>

<p><tt>testing</tt> と <tt>unstable</tt> 用の実際のバイナリパッケージは
もはやこれらのディレクトリに無く、<file>pool</file> ディレクトリに
あることに注意してください。しかし、索引ファイル (<file>Packages</file> と
<file>Packages.gz</file>) は下位互換性のために保持されています。

<p>実際にサポートされているバイナリパッケージについては、
各ディストリビューションのリリースノートをご覧ください。
これらは <url id="&stable-release;" name="stable"> および
<url id="&testing-release;" name="testing"> のためのリリースノート
サイトにあります。

<!-- 上のリリースノートが充分になったら削除してください。
<p>詳細は <ref id="arches"> をご覧ください。
-->

<sect1 id="source">ソースコード

<p>ソースコードは Debian システムにおける全てに対して含まれます。さらに、
システムのほとんどのプログラムのライセンス事項は、ソースコードが
プログラムと共に配布されるか、プログラムに添付するソースコードを
提供することを <strong>要求</strong>します。

<p>通常ソースコードは <file>source</file> ディレクトリで配布され、
アーキテクチャ特有のバイナリディレクトリ全てと並列になっているか、
より最近では <file>pool</file> ディレクトリにあります。
(<ref id="pools"> 参照)
Debian アーカイブの構造を熟知せずにソースコードを取得するには、
<tt>apt-get source <var>mypackagename</var></tt> のようなコマンドを
試してみてください。

<p>いくつかのパッケージ、とりわけ <package>pine</package> は
そのライセンスの制限により、ソースパッケージでしか得られません。
(最近、<package>pine-tracker</package> パッケージが Pine のインストールを
容易にするために導入されました。<ref id="port"> および <ref id="packaging">
に記述された手順により、パッケージを手動で構築する方法を習得できます。

<p>公式には Debian システムの一部では無い <file>contrib</file> や 
<file>non-free</file> ディレクトリにあるパッケージのソースコードは
入手できるかもしれませんし、できないかもしれません。

<sect id="pkg-basics">Debian パッケージ管理システム

<sect1 id="package-basics">Debian パッケージの概観

<p>一般にパッケージには関連するコマンドや機能を実装するのに必要な
ファイルすべてが含まれています。Debian パッケージには二つのタイプがあります:
<list>
  <item><strong>バイナリパッケージ</strong>。これには実行ファイル、
  設定ファイル、 man ページと info ページ、著作権情報やその他の文書が
  含まれます。これら のパッケージは Debian 固有のアーカイブ形式で
  配布されています。(<ref id="deb-format">参照) また .deb という
  ファイル拡張子を持っています。バイナリパッケージは Debian ユーティリティ 
  <prgn>dpkg</prgn> を用いて展開できます。詳細は <prgn>dpkg</prgn> の
  マニュアルページに記載されてあります。
  
  <item><strong>ソースパッケージ</strong>。ソースパッケージの解説が書かれた 
  <tt>.dsc</tt> ファイル (このファイルには以下のファイルの名前も書かれています)
  や、修正されていないオリジナルのプログラムソースが gzip で圧縮された 
  tar フォーマット形式で含まれている <tt>.orig.tar.gz</tt> ファイ ル、
  通常 Debian 固有の変更を記した <tt>.diff.gz</tt>ファイルから構成されています。  <prgn>dpkg-source</prgn> ユーティリティは Debian ソースアーカイブを
  パックしたりアンパックしたりします。詳細は<prgn>dpkg-source</prgn> の
  マニュアルページに記載されています。
</list>

<p>このパッケージシステムでは、ソフトウェアをインストールするとき、
パッケージ保守担当者が注意深く設計した "依存情報" を使います。
この依存情報はそれぞれのパッケージに関連する<file>制御 (control)</file>
ファイルに記載されています。例えば、GNU C コンパイラ (<package/gcc/) 
を含むパッケージは、リンカやアセンブラを含む <package/binutils/ パッケージに
"依存"しています。もしユーザがあらかじめ <package/binutils/ をインストール
していないの に <package/gcc/ をインストールしようとしたなら、Debian の
パッケージシステムは <package/binutils/ も必要であるというエラーメッセージを
出力し、ユーザがまず <package/binutils/ をインストールするのに同意するまで 
<package/gcc/ をインストールしません (とは言うものの、頑固なユーザは
この機能を上書きできます。<manref name="dpkg" section="8"> 参照)
さらに詳しい情報は、<ref id="depends"> 下をご覧ください。


<p>Debian のパッケージングツールは以下の用途に使えます:
<list>
  <item>パッケージやパッケージの一部を操作したり管理したりする。
  <item>フロッピーディスクなどの限られたサイズの媒体を通じて
  伝送しなければならないパッケージをユーザが分解するのを助ける。
  <item>パッケージアーカイブを開発者が構築するのを助ける。
  <item>遠隔の Debian アーカイブサイトに置かれたパッケージをユーザが
  インストールす るのを助ける。
</list>

<sect1 id="deb-format">Debian パッケージのフォーマット
<p>
Debian の "パッケージ" つまり Debian アーカイブファイルには、
実行プログラム一式や関連するプログラムのセットに関係する実行ファイルや、
ライブラリ、ドキュメントが含まれています。通常、Debian アーカイブファイルは
ファイル名の最後に <tt>.deb</tt> が付いています。
<footnote>

<!-- Colin Watson により投稿されたメッセージに基づき、 Osamu が下文書を追加 -->
<p><prgn>debian-installer</prgn> プロジェクトは <tt>.udeb</tt> で終わる
ファイル名のパッケージを導入しました。要するに、マイクロ <tt>.deb</tt>
フォーマットは ポリシーに正しくは従う必要はなく、ドキュメントなどの
内容を欠いており、<prgn>debian-installer</prgn> だけに用いられることを
意味しています。新しい Debian インストーラは Sarge のリリースのために
開発されています。<tt>.deb</tt> と <tt>.udeb</tt> のファイルフォーマット
は同じ物です。<prgn>udpkg</prgn> プログラムは 標準の <prgn>dpkg</prgn>
より制限された能力を持つ <tt>.udeb</tt> パッケージを操作するために使われ、
より少ないパッケージの関係をサポートします。名前に違いがあるのは、
Debian アーカイブのメンテナはポリシーに従わないアーカイブに <tt>.deb</tt>
という名前を持つのを好まなかったからです。それゆえ、二つのフォーマットの違い
を目立たせ、本当のシステムに <tt>.udeb</tt> ファイルを無意識にインストール
しないように名前を変更しました。<tt>.udeb</tt> は本当に制限された Debian 
システムを作成するため、base システムをインストールする間に最初のラムディスク
上で使用されます。
</footnote>

<p>Debian バイナリパッケージフォーマットの内部仕様は <manref name="deb" section="5"> マニュアルページに解説されています。このフォーマットは 
(&debian; のメジャーリリースの間で) 変更されることがあるので、
<tt>.deb</tt> ファイルを操作する時は必ず <manref name="dpkg-deb" section="8">
を使って下さい。

<!-- 下の文書は Osamu により追加された。確信していませんが、正しいはず -->
<p>少なくても Sarge ディストリビューションを通じ、全ての Debian アーカイブ
ファイルは、<prgn>dpkg</prgn> コマンドが使えない場合であっても、
標準的な Unix コマンドである <prgn>ar</prgn> や <prgn>tar</prgn>
により操作できます。


<sect1 id="pkgname">Debian パッケージ名の命名規則
<!--
どうして Debian パッケージのファイル名はこんなに長いのですか?
-->
<p> Debian パッケージのファイル名は次のような規則に従います:
<example>
 <var>foo</var>_<var>バージョン番号</var>-<var>Debian リビジョン番号</var>.deb。
</example>
ここで、<var>foo</var> はパッケージ名の代わりであることに注意して下さい。
照会するためには、以下の方法で特定の Debian アーカイブファイル 
(<tt>.deb</tt> ファイル ) に関係のあるパッケージ名を調べることができます:
<list>
  <item>Debian アーカイブサイトの中の、そのパッケージが置かれていた
  ディレクトリにある "Packages"ファイルを調べる。このファイルには
  それぞれのパッケージの解説が数行づつ書かれています。
  解説行の最初のフィールドは正式なパッケージ名です。
  
  <item>コマンド <tt>dpkg --info <var>foo_VVV-RRR</var>.deb</tt> を使う。
  (<var>VVV</var> と <var>RRR</var> はそれぞれ、問い合わせたいパッケージの
  バージョンとリビジョン) このコマンドは、アンパックされるアーカイブファイル
  に対応するパッケージ名を他の情報と一緒に表示します。
</list>

<p><var>VVV</var> の部分はバージョン番号を示し、上流の開発者により指定されます。 この部分には標準がありません。バージョン番号は "19960513"や "1.3.8pre1" 
 のようにフォーマットが異なっているかもしれません。

<p><var>RRR</var> の部分は Debian のリビジョン番号で、Debian の開発者 
(か自分自身のためにパッケージをビルドすることにした個人ユーザ) が決定します。
この番号は Debian パッケージのリビジョンレベルに対応します。
したがって、リビジョンレベルが新しくなると、普通、Debian の Makefile 
(<file>debian/rules</file>) や Debian 制御ファイル (<file>debian/control</file>) 、インストールまたは削除スクリプト (<file>debian/p*</file>)、
 パッケージが利用する設定ファイルなどに変更があったことを意味します。 

<!-- 
<sect1 id="controlfile"> Debian 制御ファイルにはさらに詳しく記述している。
-->

<sect1 id="conffile">ローカル設定の保存
<!--
Debian 制御ファイルとは何ですか?
-->
<p>ユーザが設定可能なファイルの保存は &debian; の "conffile" 機構を通して
行えます。ユーザ設定ファイルは (通常 <file>/etc/</file> に置かれる) 
Debian パッケージシステム内の <file>conffile</file> に指定されます。
パッケージ管理システムはパッケージのアップグレード時にこれらのファイルを
上書きしないことを保証します。

<p>さまざまな &debian; パッケージに所属するファイルを修正せずにシステムの
設定を行うことが可能です。通常それらが "conffile" な場合でさえも修正
しないのは良い考えです。これにより高速でスムーズな更新作業が保証されます。

<!--
<p>Conffile は設定ファイルのリスト (通常 <file>/etc</file> に置かれる)
であり、パッケージ管理システムはパッケージのアップグレード時に上書きしません。
これによりこれらのファイルの内容に対するローカルの値が保持され、
起動中のシステム上でパッケージをきちんとアップグレードすることを可能とする
重要な機能を保証します。
-->
<p>アップグレード中に保持するファイルを正確に決めるには、次のコマンドを
起動します:
<example>
dpkg --status <var>package</var>
</example>
そして "Conffiles:" の下を見ます。

<p>Debian <file>conffile</file> ファイルの内容の特徴は
Debian ポリシーマニュアル section 11.7 (<ref id="references"> 参照)
に記述されています。

<sect1 id="maintscripts">Debian メンテナンススクリプト
<!--
Debian preinst、postinst、prerm、postrm スクリプ トとは何ですか?
-->
<p><!--These files--> 
Debian メンテナンススクリプトはパッケージがインストールされる前か後で
自動的に実行される実行可能なスクリプトです。これらのファイルは 
<file>control</file> という名前のファイルと一緒にすべて 
Debian アーカイブファイルの "制御 (control)" セクションの一部となっています。

<p>個々のファイルは以下の通り:
<taglist>
<tag/preinst/
  <item>このスクリプトは、パッケージが Debian アーカイブ (<tt/.deb/) 
  ファイルからアンパックされる前に実行されます。パッケージがインストールか
   アップグレードし終わる ("postinst" スクリプトが正常に実行された後) 
  まで、多くの"preinst" スクリプトの中で、更新されるパッケージのために
  サービスが停止されるようになっています。

<tag/postinst/
  <item>このスクリプトの典型的な仕事は、Debian アーカイブファイル (<tt/.deb/)    からアンパックされたら、それに必要な設定をすべて完了させることです。
  "postinst" スクリプトのよくある動作として、ユーザに入力を求め、
  既定値を受け入れるなら後戻りしてこのパッケージを環境に沿うように
  再設定することを忘れないように警告を表示します。
  新しいパッケージがインストールされるかアップグレードされると、
  多くの "postinst" スクリプトはサービスを開始または再開するのに
  必要なコマンドをすべて実行します。

<tag/prerm/
  <item>このスクリプトは典型的には、パッケージに関連したあらゆる
  デーモンを停止します。これはパッケージに関連したファイルを
  削除する前に実行されます。 

<tag/postrm/
  <item>このスクリプトは典型的にはパッケージに関連したリンクや
  他のファイルを修整したりパッケージが作成したファイルを削除したりします。
  (<ref id="virtual"> も参照。)
</taglist>

<p>現在、制御ファイルはすべて <file>/var/lib/dpkg/info/</file>
に置かれています。パッケージ <tt>foo</tt> に関係するファイルは "foo" で始まる
名前を持ち、"preinst" や "postinst" などの適当なファイル拡張子を持ちます。
このディレクトリにある <file>foo.list</file> というファイルは、
パッケージ <tt>foo</tt> によってインストールされたファイルがすべて
リストされています (これらのファイルの存在場所は <prgn>dpkg</prgn> が
内部に持っていることに注意して下さい。存在場所を頼りにしないほうが
いいでしょう)。

<sect1 id="priority">パッケージ優先度
<!--
Required/Important/Standard/Optional/Extra パッケー ジとはなんですか ?
-->
<p>それぞれの Debian パッケージには、パッケージ管理システムの助けとして、ディストリビューション保守担当者が <strong>優先度</strong> を割りあてています。
優先度には以下のものがあります:

<list>
  <item><strong>Required (要求)</strong> パッケージはシステムを正しく
  動作させるために必要なパッケージです。
    <p>システムの欠陥を修復するのに必要なツールをすべて含みます。
    これらのパッケージを消去してはいけません。システムがすっかり破壊され、
   復旧 するために <prgn>dpkg</prgn> を使うことすら恐らくできなくなります。
   Required パッケージだけのシステムは恐らく使いものになりませんが、
   システム管理者が起動したり他のソフトウェアをインストールするだけの
   機能はあります。
 
  <item><strong>Important (重要)</strong> パッケージはどのような Unix 
  ライクなシステムにもあるべきパッケージです。

    <p>Required 以外のパッケージで、無いとシステムがうまく動かなかったり
    不便だったりするものにこの優先度がつけられています。これには Emacs や 
    X11、TeX 他の巨大なアプリケーションは含まれて<strong>いません</strong>。
    ここのパッケージは、素のインフラストラクチャを構成するだけです。

  <item><strong>Standard (標準)</strong> パッケージはどんな Linux システム
  にも標準的なパッケージで、手頃な小ささですが機能が限定されすぎていない
  キャラクタモードシステムを含んでいます。

    <p>これはユーザが何も指示しなかったらデフォルトでインストールされます。
    多くの巨大なアプリケーションは含まれませんが、Emacs はあります 
    (これはアプリケーションというよりも多くのプログラムのための
    インフラストラクチャの一部です) し、TeX と LaTeX の手頃なサブセットが 
    (X なしで稼動可能な部分なら) 含まれています。

  <item><strong>Optional (任意)</strong> パッケージにはそのパッケージが
  何なのかを知らなかったり、そのパッケージを使わなければならない特別な
  要求がなかったりしてもインストールしてかまわないパッケージが含まれています。

    <p>これには X11 や TeX 配布物全体、多くのアプリケーションが含まれています。

  <item><strong>Extra (付録)</strong> パッケージはより高い優先度を持つ
  パッケージと衝突するか、そのパッケージがどういうものか知っているか、
  あるいは "任意" というには相応しくない特殊な要求を持っているパッケージです。
</list>
<p>パッケージの説明にある "Priority: required", "Section: base" および
"Essential: yes" の違いについて注意してください。"Section: base" は
新しいシステムには他の全てをインストールする前にこのパッケージが
インストールされることを意味しています。"Section: base" なパッケージの
ほとんどは "Priority: required" または少なくても "Priority: important" 
であり、それらの多くは "Essential: yes" にタグづけられています。
"Essential: yes" はこのパッケージをシステムから削除するには、
<prgn>dpkg</prgn> のようなパッケージ管理システムに特別な強制オプションを
指示する必要があることを意味しています。例えば、
<package>libc6</package>、 <package>mawk</package> や
<package>makedev</package> は  "Priority: required" かつ  "Section: base"
ですが、"Essential: yes" ではありません。

<sect1 id="virtual">仮想パッケージ

<p>仮想パッケージとは、すべて同じ基本機能を提供するパッケージの集まりの
どれか一つに供される一般的な名前のことです。
たとえば <prgn>tin</prgn> と <prgn>trn</prgn> プログラムはどちらも
ニュースリーダであり、それゆえ、動作するか利用するためににニュースリーダを
要求するプログラムの依存性を満たします。したがって両プログラムは 
<package>news-reader</package> と呼ばれる "仮想パッケージ" を供給します。

<p>同様に、<prgn>exim</prgn> と <prgn>sendmail</prgn> には両方とも
メール配送エージェント (mail transport agent) の機能が備わっています。
それゆえ仮想パッケージ <package>mail-transport-agent</package> を
提供するといわれます。どちらかがインストールされていれば、
mail transport agent がインストールされていることに依存する
プログラムはどれでもこの仮想パッケージが存在しているために
条件を満足しています。

<p>Debian はこのようなしくみを提供するので、同じ仮想パッケージを持つ
パッケージが一つ以上システムにインストールされると、システム管理者は
優先パッケージを設定できます。関連するコマンドは 
<prgn>update-alternatives</prgn> で、 <ref id="alternatives"> で
さらに詳しく述べられています。

<sect1 id="depends">パッケージの依存性
<!--
他のパッケージに Depends/Recommends/Suggests/Conflicts/Replaces/Provides しているとはどういう意味ですか?
-->
<p>Debian パッケージシステムはパッケージ "依存性" に幅を持っています。
あるシステム上でプログラム A がプログラム B の存在からどれくらい独立して
動作させられるかを (フラグ一つで) 表示するよう設計されています:

<list>
  <item>もし A を実行するためには B が必ずインストールされていなければ
  ならないなら、パッケージ A はパッケージ B に <strong>依存 (Depend)</strong>
  しています。A は B の存在だけではなく B のバージョンにも依存していることが
  あります。この場合、バージョン依存性は通常下限を設定します。つまり、 A は
  あるバージョンより新しいバージョンの B に依存しているということ です。

  <item>パッケージ A の保守担当者が、たいていのユーザはパッケージ B の
  機能を使うことなく A を使いたくはないだろうと判断したら、パッケージ A は
  パッケージ B を <strong>推奨 (Recommends)</strong> しているといいます。

  <item>もしパッケージ B に含まれているファイルがパッケージ A の機能に
  関係している (通常は機能を拡張する) なら、パッケージ A はパッケージ B を
  <strong>提案 (Suggest)</strong> すると言います。

  <item>システムにパッケージ B がインストールされているとパッケージ A が
  動作しないというとき、パッケージ A はパッケージ B と
  <strong>衝突 (conflicts)</strong> していると言います。ほとんどの場合、
  衝突はパッケージ B に含まれているファイルをパッケージ A が書き換えるのが
  原因で起こります。"衝突 (Conflicts)" はしばしば "置換 (Replaces)" と
  組みあわされます。

  <item>パッケージ B がインストールしたファイルが削除され、 (ある場合には) 
  パッケージ A のファイルで上書きされるとき、パッケージ A はパッケージ B を
  <strong>置換 (Replace)</strong> するといいます。

  <item>パッケージ B のすべてのファイルと機能がパッケージ A の中に
  組み込まれているとき、パッケージ A はパッケージ B を 
  <strong>提供 (Provide)</strong> するといいます。この機構は、
  ディスクの空き容量に余裕がないユーザに、パッケージ A の中で本当に
  必要な部分を取得する方法を用意します。
</list>

<p>これらの用語の使用法についてのより詳しい情報は <em>Debian パッケージング
マニュアル</em> と <em>Debian ポリシーマニュアル</em> にあります。

<p>単に <strong>depends</strong> と指定されたパッケージ全てを取得しますが、
<strong>recommends</strong> や <strong>suggests</strong> と指定された
パッケージを全て無視する <prgn>apt-get</prgn> に比べ、<prgn>dselect</prgn> 
はより洗練した <strong>recommends</strong> や <strong>suggests</strong>
により指定されるパッケージ制御機能を有します。これらのプログラムは共に
現代的な形で APT をバックエンドとして使用します。

<sect1 id="pre-depends">"pre-depends" の意味

<p>"Pre-depends" は特別な依存関係です。通常のパッケージの場合、
<prgn>dpkg</prgn> はアーカイブファイル (すなわち <tt>.deb</tt> ファイル)を
依存するファイルがシステム上にあるかにどうかに係わらず独立に展開します。
展開は基本的に <prgn>dpkg</prgn> がファイルシステム上にインストールされる
アーカイブファイルからファイルを取り出し、ある場所に置くことを意味します。
それらのパッケージがシステム上にある他のパッケージの存在に <strong>依存</strong>している場合、<prgn>dpkg</prgn> は他のパッケージがインストールされるまで、
(その "configure" 動作を実行せずに) インストールの完了を拒絶します。

<p>しかしながら、あるパッケージは依存性が解決されるまで、<prgn>dpkg</prgn> が
パッケージファイルの展開さえ拒否します。
そのようなパッケージは他のパッケージの存在に "pre-depends" する
と言われます。Debian プロジェクトは、パッケージを展開する <strong>順番</strong>が非常に重要であった <tt>a.out</tt> フォーマットから ELF フォーマットへの
システムの安全な更新をサポートするためにこの機構を導入しました。
この方法が有効な大規模なアップグレード状況もあります。例えば、"required"
優先度を持ち、libc に依存するパッケージを更新する場合などです。

<p>先の項目と同様に、本機構に関するより詳しい情報は 
<em>パッケージマニュアル</em> にあります。

<sect1 id="pkgstatus">パッケージステータス
<!--
パッケージ状態の unknown/install/remove/purge/hold とはどういう意味ですか?
-->
<p>パッケージステータスには "unknown", "install", "remove", "purge" "hold"
があります。
これらの "want" フラグは利用者がそのパッケージをどう扱いたいかを示しています。
利用者は <prgn>dselect</prgn> の "Select" セクションでのアクション や 
<prgn>dpkg</prgn> の直接起動によってこれを示すことができます。

<p>それぞれの意味は以下の通り:
<list compact>
  <item><strong>unknown</strong>  - インストールするかどうかユーザが
  表明していないパッケージ
  <item><strong>install</strong>  - ユーザがインストールまたはアップグレード
  したいパッケージ
  <item><strong>remove</strong>   - 削除はしたいが、既存の設定ファイルは
  一つも削除したくな いパッケージ
  <item><strong>purge</strong>    - 設定ファイルを含め、完全に削除してしまう
  パッケージ
  <item><strong>hold</strong>     - 処理はしない、つまりどのような状態
  であれ現在の状態で現在のバージョンを維持するパッケージ
</list>

<sect1 id="puttingonhold">更新からパッケージをホールドする
<!--
どうしたらパッケージを hold にできますか?
進行中の /etc/apt/preferences に対応して大規模な書き直しを行った
-->
<p> パッケージを hold するには二つの方法があります。<prgn>dpkg</prgn>
 を使う方法と、Woody から始まった APT を使う方法です。

<p><prgn>dpkg</prgn> では、パッケージ選択の一覧を
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
で書き出すだけです。それから書き出されたファイル <file><var>selections.txt </var></file> を編集して hold したいパッケージの行を変更します。例えば:
<example>
libc6                       install
</example>
を
<example>
libc6                       hold
</example>
にします。ファイルを保存して、
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
でdpkg データベースに再ロードしてください。又、ホールドしたいパッケージ名
を知っている場合は、単に
<example>
echo libc6 hold | dpkg --set-selections
</example>
を実行するだけです。この手順は各パッケージファイルのインストール処理で
パッケージをホールドします。

<p>同様の効果が <prgn>dselect</prgn> を通しても得られます。[S]elect 画面に
入って hold したいパッケージの現在の状態を確認し、「=」キー (もしくは「H」キー) を押下するだけです。変更は [S]elect 画面を終了するとすぐに反映します

<p>Woody ディストリビューションにおける APT システムは <tt>Pin-Priority</tt>
を用いてアーカイブ取得処理中にパッケージをホールドする新しいもう一つの機構
を持ちます。  <url id="&apt-howto;"> と共に、マニュアルページ 
<manref name="apt_preferences" section="5"> をご覧ください。
<package>&p-apt-howto;</package> パッケージの <ref id="apt-preferences">
にも簡潔な説明があります。

<sect1 id="sourcepkgs">ソースパッケージ

<p>
ソースパッケージは <file>source</file> と呼ばれるディレクトリで配布されています。手動でダウンロードできますし、
<example>
apt-get source <var>foo</var>
</example>
を使ってダウンロードもできます。
(このための APT の設定法については apt-get(8) マニュアルページを参照してください)。
     apt-get source foo

を使って取得することもできます (このための APT の設定法については 
<manref name="apt-get" section="8"> を参照願います。)

<sect1 id="sourcebuild">ソースパッケージからバイナリパッケージを作る

<p>パッケージ <tt><var>foo</var></tt> をソースからコンパイルするには、
<file><var>foo_*</var>.dsc</file>、<file><var>foo_*</var>.tar.gz</file> および
<file><var>foo_*.diff</var>.gz</file> の全てが必要となります
(注意:Debian 固有のパッケージに は <tt>.diff.gz</tt> はありません)。

<p>これらを入手し、<package/dpkg-dev/ パッケージをインストールしている場合、
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
というコマンドを実行すれば <tt><var>foo-version</var></tt> というディレクトリ
にパッケージが取り出されます。

<p>バイナリパッケージをコンパイルしたいならば、
<example>
$ cd foo-version
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
を実行し、
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
で新たに構築したパッケージをインストールします。<ref id="port"> をご覧ください。

<!-- Woody にはより簡単なコマンドと build-depends があります -->

<sect1 id="creatingdebs">新しい Debian パッケージを作る

<p>新しいパッケージを作ることに関する詳細な情報は、
<package/maint-guide/ パッケージで得られる <em>Debian メンテナ入門</em> 
 又は <url id="&maint-guide;" name="&urlname;"> をご覧ください。
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Debian システムのアップグレード

<p>Debian の目標の一つは首尾一貫したアップグレード方針と安全な
アップグレード手順を提供することであり、前のリリースから新リリースに
スムーズにアップグレードできるよう我々は常に最善を尽しています。
アップグレード手順に加えるべき何か重要な注記事項がある場合には、
パッケージはユーザに注意を促し、ありうる問題への解決法を提供します。

<p>アップグレードの詳細を具体的に解説したリリースノートも読んでおくべきです。
これはすべての Debian CD と一緒に出荷されており、WWW でも 
<url id="&stable-release;"> や <url id="&testing-release;"> で利用可能です。

<p>
アップグレードを行う実際的なガイドは <ref id="package"> で供給されます。
本章では基本的な手順を記述します。

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Debian システムのアップグレード手順

<p>単純に Debian アーカイブに匿名 ftp または <prgn>wget</prgn> をかけ、次に
ディレクトリをよく調べて、欲しいファイルを見つけ、それを取ってきます。
最後に <prgn>dpkg</prgn> を使ってそのファイルをインストールします。
(たとえシステムが稼動していても、 <prgn>dpkg</prgn> はアップグレードする
必要のあるファイルをきちんとインストールしてくれることに注意してください。)
しかし、あるパッケージをアップグレードしようとした時、他のパッケージも
アップグレードするように要求される場合があります。この場合、
指示されたアップグレードを行うまで、あるいは行わなければ、
希望するパッケージのアップグレードは失敗してしまいます。

<p>この方法はあまりにも時間がかかり過ぎると多くの人が感じるでしょう。
というのも Debian は急速に進化しているからです。通常、一週間に 1 ダース
以上もの新しいパッケージがアップロードされています。
新しいメジャーリリースの直前にはもっと増えます。このような大変な
アップグレード作業を自動化してくれるプログラムを使いたいという人が
多くいます。このためにいくつかの専用のパッケージが利用できます

<sect1 id="pkgtools">パッケージ管理ツールの概要

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>Debian パッケージ管理システムには二つの目的があります:パッケージファイル自身の操作と Debian アーカイブからのパッケージファイルの取得です。<prgn>dpkg</prgn>
は前者の作業を行い、APT や <prgn>dselect</prgn> は後者です。

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>これはパッケージファイルの操作のための主要なプログラムです。
完全な説明は <manref name="dpkg" section="8"> を読んでください。
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> にはいくつかの原始的な補助部プログラムが付随します。

<list>
<item><prgn>dpkg-deb</prgn>: <tt>.deb</tt> ファイルを操作します。
 <manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>: 旧型のパッケージファイル取得コマンドです。
 <manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>: 旧型のパッケージファイル取得用コマンドです。
 <manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>: 大規模なパッケージを小さなファイルに分割します。
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> と <prgn>dpkg-mountable</prgn> は APT システムに
取って代わられました。

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT (the Advanced Packaging Tool) は Debian パッケージングシステムの先進的なインターフェースであり、"apt-" で始まる名前を持ついくつかのプログラムから
構成されています。
<prgn>apt-get</prgn>、 <prgn>apt-cache</prgn> および <prgn>apt-cdrom</prgn> 
はパッケージ操作用のコマンドラインツールです。これらには <prgn/dselect/ や
<prgn/aptitude/ のような他のツールへのユーザ "バックエンド" としても働きます。

<p>
より詳しい情報は、<package/apt/ パッケージをインストールし、
<manref name="apt-get" section="8">、
<manref name="apt-cache" section="8">、
<manref name="apt-cdrom" section="8">、
<manref name="apt.conf" section="5">
<manref name="sources.list" section="5">,
<manref name="apt_preferences" section="5"> (Woody)、そして
<file>/usr/share/doc/apt/guide.html/index.html</file> を読んでください。

<p>もう一つの情報源としては、
<url id="&apt-howto;" name="APT HOWTO"> があります。
<file>&f-apt-howto;</file> の <package/apt-howto/ によりインストールできます。

<p><tt>apt-get upgrade</tt> と <tt>apt-get dist-upgrade</tt>
は "Depends:" にリストされたパッケージのみを引っ張ってきますが、
"Recommends:" や "Suggests:" にリストされたパッケージは無視します。
これを避けるには、<prgn>dselect</prgn> を御使用ください。

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>このプログラムは Debian パッケージ管理システムへのメニュドリブンな
ユーザインターフェースです。最初のインストール時や大規模なアップグレード時
に特に役立ちます。<ref id="dselect"> をご覧ください。

<p>より詳しい情報は、<package/install-doc/ パッケージをインストールし、
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> や
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">
を読んでください。

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">パッケージをアップグレードするのにシングルユーザモードに入る必要はありますか?

<p>いいえ。システムが起動中でもパッケージをその場でアップグレードできます。
Debian にはパッケージのアップグレード中に必要な場合は起動中のプロセスの
停止と再開のために呼び出される <prgn>start-stop-daemon</prgn> があります。
-->

<sect1 id="updaterunning">起動中のシステムをアップグレードする

<p>&debian; システムにおける kernel (ファイルシステム) はファイルを使用中で
な場合でさえも、そのファイルの置き換えをサポートしてます。

<p>ブート時にデーモンを起動したり、kernel のランレベルが変更された時
(例えば、マルチユーザからシングルユーザにとか、"halt" などに変更した時)
にデーモンを停止したりするために用いる <prgn/start-stop-daemon/ と呼ばれる
プログラムも提供しています。同じプログラムは、デーモンを含む新パッケージを
インストールした時に、起動中のデーモンを停止したり必要な場合に
デーモンを再起動するため、インストールスクリプトにより使用されます。

<p>Debian システムは起動中のシステムをアップグレードするのに
シングルユーザモードを必要としないことに注意してください。

<sect1 id="savedebs"><tt>.deb</tt> アーカイブファイルのダウンロードとキャッシュ

<p>手動でパッケージファイルをディスクにダウンロードした場合、(これは必ずしも必要ではありません。上に記述した <prgn>dpkg-ftp</prgn> または APT の説明をご覧ください) パッケージをインストールした後、システムから <tt>.deb</tt> ファイルを削除できます。

<p>APT を使っている場合、これらのファイルは <file>/var/cache/apt/archives</file> ディレクトリにキャッシュされます。これらをインストール後に削除 (<tt>apt-get clean</tt>) できますし、その後のインストール中のダウンロード時間を節約するため、
他のマシーンの <file>/var/cache/apt/archives</file> ディレクトリにコピー
してもかまいません。

<sect1 id="keepingalog">アップグレードの記録を取る

<p><prgn/dpkg/ は展開、設定、削除またはパージされたパッケージの記録を取ります
が、 (現在) パッケージにそのような操作が行われている間に起こったターミナル上の
コマンドログを取っていません。

<p>コマンドログを取る最もシンプルな方法は、<prgn>dpkg</prgn>、 <prgn>dselect</prgn>、 <prgn>apt-get</prgn> などのセッションを <manref name="script" section="1">プログラム内で起動することです。

<sect id="boot">Debian ブートプロセス

<sect1 id="init"><prgn>init</prgn> プログラム

<p>他の Unix ライク OS と同様に、Debian は <prgn>init</prgn> プログラムを
実行することによりブートを始めます。<prgn>init</prgn> 用の設定ファイル
(<file>/etc/inittab</file>) は、実行されるべき最初のスクリプトが
 <file>/etc/init.d/rcS</file> であることを指定しています。
このスクリプトは <file>/etc/rcS.d/</file> 下にあるスクリプトをそのファイル
拡張子に応じて、読み込むか、サブプロセスを fork することにより
初期化処理を実行します。その初期化処理には、ファイルシステムのチェックやマウント、モジュールの読み込み、ネットワークサービスの開始、時計の設定などが含まれます。そして、互換性のために、<file>/etc/rc.boot/</file> 下にあるファイル (ファイル名に  `.' が付くファイルを除く) も実行します。後者のディレクトリ内のスクリプトは通常システム管理者が使用するために予約されており、パッケージがこのディレクトリにスクリプトを置くのは時代遅れです。詳細は Debian ポリシーマニュアルの
<ref id="init-hints"> や <url id="&sysvinit;" name="System run levels and init.d scripts"> をご覧ください。

<sect1 id="runlevels">Runlevels

<p>ブートプロセス完了後、<prgn>init</prgn> は (<file>/etc/inittab</file> の <tt>id</tt> 用のエントリにより与えられる) 標準のランレベルにより指定された
ディレクトリ内の全ての起動スクリプトを実行します。
全ての <!-- all? SGK --> System V 互換 Unix と同様に、Linux は7個のランレベルを持ちます:
<list compact>
  <item>0 (システムを停止)、
  <item>1 (シングルユーザモード)、
  <item>2 から 5 (さまざまなマルチユーザモード)、そして
  <item>6 (システムをリブート)。
</list>

<p>
Debian システムの id は <tt>2</tt> であり、これは標準のランレベルが
ランレベル 2 のマルチユーザ状態であり、<file>/etc/rc2.d/</file> 下のスクリプトを実行することを示しています。

<p>実は、<file>/etc/rc<var>N</var>.d/</file> ディレクトリにあるスクリプトはいずれも <file>/etc/rc<var>N</var>.d/</file> にあるスクリプトの単なるシンボリックリンクです。しかし、<file>/etc/rc<var>N</var>.d/</file> ディレクトリにあるそれぞれのファイルの <strong>名前</strong> は <file>/etc/init.d/</file> にある
スクリプトが起動される <strong>方法</strong> を示すように選ばれています。
特に、ランレベルに入る前に、 `K' で始まる全てのスクリプトが起動されます。
これらのスクリプトは全てのサービスを殺します。そして `S' で始まるスクリプト
が全て起動されます。これらのスクリプトはサービスを開始します。`K' や `S' に続く 2桁の番号はスクリプトの起動される順番を示します。小さい番号が付いたスクリプトは
早く実行されます。

<p><file>/etc/init.d/</file> にあるスクリプトは全て "start"、 "stop"、 "reload"、 "force-reload" の四個の引数を取り、引数により指定された仕事を行うため、この手法は機能します。これらのスクリプトはさまざまなプロセスを制御するために、
システムがブートした後でも使えます。

<p>例えば、"reload" 引数をコマンドに持たせると、
<example>
# /etc/init.d/sendmail reload
</example>
設定ファイルを再読み込みするように sendmail デーモンにシグナルを送ります。

<sect1 id="custombootscripts">ブートプロセスのカスタマイズ
<p>Debian はブートプロセスをカスタマイズするのに BSD スタイルの 
<tt>rc.local</tt> ディレクトリを使用しません。その代わり、カスタマイズのために
次に述べる機構を供給します。

<p>システムが起動時又は特定の (System V) ランレベルにおいて <tt>foo</tt> 
というスクリプトを実行する必要があると想定します。そのとき、システム管理者が
すべきなのは次の通り:
<enumlist>
  <item>スクリプト <tt>foo</tt> を <file>/etc/init.d/</file> ディレクトリに
  入れる。
  <item>Debian コマンド <prgn>update-rc.d</prgn> を適切な引数を使って
  起動し、(コマンドラインで指定した) <tt>rc<var>?</var>.d</tt> ディレクトリ
  と <file>/etc/init.d/foo</file> のリンクを設定する。
  ここで、<var>?</var> は System V ランレベルのうちのどれかに対応する
  0 から 6 までの番号。
  <item>システムをリブートする。
</enumlist>

<p><prgn>update-rc.d</prgn> コマンドは <tt>rc<var>?</var>.d</tt> ディレクトリと
<file>/etc/init.d/</file> にあるスクリプトの間のリンクを設定します。各リンクは
`S' 又は  `K' で始まり、その後ろに番号、そしてスクリプトの名前が続きます。
システムがランレベル <var>N</var> に入ると、<file>/etc/rc<var>N</var>.d/</file>
内の `K' で始まるスクリプトが引数 <tt>stop</tt> により実行され、次に
<file>/etc/rc<var>N</var>.d/</file> 内の `S' で始まるスクリプトが
引数 <tt>start</tt> により実行されます。

<p>例えば、スクリプト <tt>foo</tt> をブート時に実行させたい場合、そのスクリプトを <file>/etc/init.d/</file> に置いて、<tt>update-rc.d foo defaults 19</tt>
を実行してリンクを張ります。引数 <tt>defaults</tt> は 2 から 5 の標準ランレベルを参照します。引数 <tt>19</tt> は <tt>foo</tt> が番号 20 以上を持つスクリプト
よりも前に実行されることを保証します。

<sect id="diverse">多様性のサポート
<p>
Debian はシステムを壊さずにシステム管理者の希望を満たすためのいくつかの手段
を提供します。
<list>
<item><prgn>dpkg-divert</prgn>、<ref id="dpkg-divert"> 参照。
<item><prgn>equivs</prgn>、<ref id="equivs"> 参照。
<item><prgn>update-alternative</prgn>、<ref id="alternatives"> 参照。
<item><prgn>make-kpkg</prgn> は多くののブートローダに対応します。
<manref name="make-kpkg" section="1"> および <ref id="kernel-debian"> 参照。
</list>
<file>/usr/local/</file> 以下のファイルはシステム管理者のものであり、
&debian; は一切触りません。 <file>/etc</file> 以下のほとんど (又は全ての)
ファイルは <tt>conffiles</tt> であり、&debian; はシステム管理者が明示的に
要求しない限りアップグレード時に上書きしません。

<sect id="i18n">国際化
<p>
&debian; システムは国際化されており、コンソール上ならびに X 上で
多種の言語の文字を表示し、入力するためのサポートを供給します。
たくさんのドキュメント、マニュアルページ、そしてシステムメッセージが翻訳されており、翻訳されている言語は増加し続けています。インストール中、Debian は
ユーザにインストール言語 (そして時々はローカル言語変数 )の選択を促します。
<p>
あなたが必要な言語の機能全てをインストールしたシステムがサポートしていない場合、又はあなたの言語をサポートするために言語の変更や、異なるキーボードのインストールが必要な場合、<ref id="l10n"> をご覧ください。

<sect id="kernel-details">Debian と kernel
<p>
<ref id="kernel"> をご覧ください。

<sect1 id="non-debian-kernel">非 Debian なソースから kernel をコンパイルする

<p><!--Yes.  But you have-->
header に関する Debian ポリシーを理解する必要があります。

<p>Debian C ライブラリは <strong>kernel</strong> header の最新の <strong>stable</strong> リリースを用いて構築されています。

<p>例えば、Debian-1.2 リリースは version 5.4.13 のヘッダを用いていました。
この慣習は全ての Linux FTP アーカイブサイトにおいて配布される Linux kernel
ソースパッケージに対照しており、Linux kernel ソースパッケージはより最新
の header を使ってさえいます。kernel source により配布される kernel header
は <file>/usr/include/linux/include/</file> にあります。

<p><package/libc6-dev/ により供給されるものより新しい kernel header を用いて
プログラムをコンパイルする必要がある場合には、コンパイル時、コマンドラインに
<tt>-I/usr/src/linux/include/</tt> を付け加える必要があります。
これは、例えば automounter daemon (<package/amd/) のパッケージングをする
場合に使われます。新しい kernel が NFS を扱うための内部処理を変更した場合、
<prgn>amd</prgn> はそれを知る必要があるため、最新の kernel header を
含める必要性が発生します。

<sect1 id="customkernel">カスタム kernel 構築ツール
<p>カスタム kernel を構築したい (する必要がある) 人は <package/kernel-package/
パッケージのダウンロードが推奨されます。本パッケージには kernel パッケージ
の構築用スクリプトが副まれ、次のようなコマンドを kernel ソースディレクトリの
最上段で実行するだけで Debian kernel-image パッケージを構築する機能を供給します。
<example>
# make-kpkg kernel_image
</example>
ヘルプは次のコマンドを実行すると得られます。
<example>
# make-kpkg --help
</example>
また、マニュアルページ  <manref name="make-kpkg" section="8"> 全体と
<ref id="kernel"> も参照願います。

<p>kernel-source-<var>version</var> (<var>version</var> は kernel バージョンを
表す) パッケージが得られない場合、好みの Linux アーカイブサイトから最新の
kernel (又は選んだ kernel) のソースコードを別途ダウンロードする必要があります。
Debian の <file>initrd</file> ブートスクリプトは <prgn>initrd</prgn> と呼ばれる
特別な kernel patch を要求します。<url id="&bug-initrd;"> をご覧ください。

<p><package/kernel-package/ パッケージの詳細な使用方法は
<file>/usr/share/doc/kernel-package/README.gz</file> にあります。

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">代替ブートローダ
<p><package/grub/ や <package/loadlin/ のような代替ブートローダを使いたい場合、
コンパイルした Linux kernel <file>bzimage</file> を他の場所 (例えば、<file>/boot/grub</file> や MS-DOS パーティション) にコピーしましょう。
</sect1>

<sect1 id="custombootdisk">カスタムブートフロッピ

<p>カスタムブートフロッピを作成する作業は、通常 Debian FTP アーカイブの <tt>admin</tt> セクションにある Debian パッケージ <package/boot-floppies/ により、大きな手助けが得られます。本パッケージにあるシェルスクリプトはブートフロッピを
<prgn>syslinux</prgn> フォーマットで作成します。これらは MS-DOS フォーマット
され、直接 Linux (又は<file>syslinux.cfg</file> で定義された他のオペレーションシステム) をブートするようにマスターブートレコードが変更されたフロッピです。
本パッケージの他のスクリプトは緊急 root ディスクを作成し、base ディスクの再製作さえできます。

<p>詳細は <package/boot-floppies/ パッケージをインストールした後、
<file>/usr/doc/boot-floppies/README</file> ファイルをご覧ください。

<sect1 id="modules">モジュールを扱うための特別な準備

<p>Debian の <package/modconf/ パッケージはモジュールの設定をカスタマイズする
ために使用できるシェルスクリプト (<file>/usr/sbin/modconf</file>) を供給
します。このスクリプトはメニュベースのインターフェースを表示し、システムの
ローダブルデバイスドライバに関する詳細に対してユーザを促します。
その応答は <file>/etc/modules.conf</file> や <file>/etc/modules</file> 
をカスタマイズするのに使用されます (これらにはブート時にロードされる
モジュールがリストされています)。

<p>カスタム kernel の構築をサポートするために得られる (新しい) 
<file>Configure.help</file> ファイルと同様に、<package/modconf/ パッケージには
モジュールそれぞれに対して適切な引数についての詳細な情報を供給する (<file>/usr/share/modconf/</file> にある) ヘルプファイルが付属します。用例は
<ref id="kernel-modules"> をご覧ください。

<sect1 id="removeoldkernel">古い kernel パッケージを削除する

<p><prgn>kernel-image-<var>NNN</var>.prerm</prgn> スクリプトは現在起動している kernel が削除しようとしている kernel と同じかどうかチェックします。それゆえ、
使わない kernel image パッケージを安全に次のコマンドを用いて削除できます:

<example>
dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(もちろん、<var>NNN</var> を削除したい kernel のバージョンとリビジョンに置き換えます。)
</sect>
