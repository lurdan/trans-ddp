<!-- CVS revision of this document "$Revision: 1.6 $"  -->
<!-- CVS revision of original english document "1.48"   -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->
<!-- DON't TOUCH GROFF SECTION!!! -->


<chapt id="program">Programowanie
<p>
Pamiêtaj, by nie u¿ywaæ nazwy &ldquor;test&rdquor; do oznaczania pliku wynikowego,
poniewa¿ <prgn>test</prgn> jest wbudowanym poleceniem pow³oki.

<sect>Gdzie zacz±æ?
<p>
Odno¶niki:
<list compact>
<item>Dokumentacja i przyk³ady w katalogu <file>&dochome;<var>pakiet</var></file>
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
Wiele d³ugich dokumentów info mo¿na otrzymaæ w postaci wydrukowanej z
<url id="&gnuhome;" name="GNU">.
<p>
W nastêpnych czterech rozdzia³ach znajdziesz przyk³adowe skrypty, ka¿dy
napisany w innym jêzyku, które tworz± plik tekstowy zawieraj±cy informacje
o koncie, które z kolei mog± byæ wstawione do pliku <file>/etc/passwd</file>
za pomoc± przetwarzania wsadowego np. programem <prgn>newusers</prgn>.
Ka¿dy ze skryptów oczekuje na wej¶ciu pliku, którego linie s± nastêpuj±cego
formatu <tt>imiê nazwisko has³o</tt>. (Katalogi domowe u¿ytkowników nie
bêd± tworzone przez te skrypty.)

</sect>

<sect id="shell">Pow³oka
<p>
<strong>Najlepszym</strong> sposobem na zrozumienie dzia³ania systemów
uniksowych jest przegl±danie i czytanie skryptów pow³oki.
Poni¿ej podam pewne wskazówki i materia³y przypominaj±ce programowanie
w pow³oce. Zobacz <url id="&shell-mistakes;" name="Pomy³ki pow³oki">
by uczyæ siê na b³êdach.

<sect1 id="bash">Bash &ndash; interaktywna pow³oka zgodna z <strong>GNU</strong>

<p>
Odno¶niki do informacji na temat Bash-a:
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>LDP <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
(Programowanie w BASH-u - Wprowadzenie JTZ)
- informacje dla pocz±tkuj±cych
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (Zainstaluj najpierw pakiet <package>bash-doc</package>, aby zobaczyæ
 przyk³ady.)
<item><em>Learning the bash Shell</em>, 2nd edition (O'Reilly) - (Nauka
pow³oki bash - drugie wydanie)
</list>
<p>
Oto krótki, przyk³adowy program (tworzy on wpisy dt. kont na podstawie
danych ze standardowego wej¶cia dla programu <prgn>newusers</prgn>):
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:&ldquor;,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">Pow³oki zgodne z POSIX
<p>
W systemie &debian; pow³oki zgodne z POSIX znajduj± siê w kilku pakietach:
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 176
  <item>Najmniejszy i jak dot±d najszybszy. &ndash; najlepszy dla pocz±tkowego
       rozruchu.
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 180
  <item>Mniejszy i o wiele szybszy &ndash; dobry dla pocz±tkowego rozruchu.
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essential: yes
  <item>Priority: required
  <item>Installed-Size: 580
  <item>Wiêkszy i z wiêkszymi mo¿liwo¶ciami &ndash; napisanych zosta³o ju¿
       wiele rozszerzeñ.
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 408
  <item>Kompletny klon pow³oki AT&amp;T ksh.
 </list>
</list>
<p>
Je¶li piszesz skrypty pow³oki, które maj± byæ przenoszone na inne
pow³oki/systemy to
najlepiej pisaæ je jako skrypty pow³oki POSIX. U¿yj <file>/bin/sh</file>
dowi±zanego do <prgn>ash</prgn> lub (<prgn>dash</prgn>) aby sprawdziæ zgodno¶æ
z POSIX. Unikaj pisania skryptów z nalecia³o¶ciami
<strong>bashowymi</strong> lub <strong>zshsowymi</strong>, które przypominaj±
sk³adniê <prgn>csh</prgn>. Na przyk³ad, staraj siê unikaæ:

<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>file</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>

<sect1 id="shell-param">Parametry pow³oki
<p>
Kilka <strong>parametrów specjalnych</strong> do zapamiêtania:
<example compact>
$0      = nazwa pow³oki lub skryptu
$1      = pierwszy(1) argument pow³oki
 ...
$9      = dziewi±ty(9) argument pow³oki
$#      = ilo¶æ parametrów pozycyjnych
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = kod zakoñczenia ostatnio wykonywanego polecenia
$$      = PID aktualnie wykonywanego skryptu pow³oki
$!      = PID ostatnio rozpoczêtego zadania w tle
</example>
<p>
Podstawowe <strong>rozwiniêcia parametrów</strong>(parameter expansion)
do zapamiêtania:
<example compact>
       Forma       Je¶li <var>parametr</var>    Je¶li <var>parametr</var> nie
                   jest ustawiony               jest ustawiony
${<var>parametr</var>:-<var>s³owo</var>}   $<var>parametr</var>            <var>s³owo</var>
${<var>parametr</var>:+<var>s³owo</var>}   <var>s³owo</var>                null
${<var>parametr</var>:=<var>s³owo</var>}   $<var>parametr</var>            <var>s³owo</var> 
                                 (i wykonuje <var>parametr</var>=<var>s³owo</var>)
${<var>parametr</var>:?<var>s³owo</var>}   $<var>parametr</var> (wy¶wietla <var>s³owo</var> i koñczy dzia³anie)
</example>
Dwukropek (`:') we wszystkich powy¿szych operatorach nie jest tak naprawdê
potrzebny.
<list compact>
<item>Z `:' = operator sprawdza czy zmienna &ldquor;istnieje&rdquor; i &ldquor;nie jest pusta&rdquor;.
<item>Bez `:' = operator sprawdza tylko czy zmienna &ldquor;istnieje&rdquor;.
</list>
<p>
Podstawowe <strong>podstawienia parametrów</strong>(parameter substitutions)
do zapamiêtania:
<example compact>
    Forma                Wynik <!-- FIXME: Sprawdziæ to wszystko w bash(1) -->
${<var>parametr</var>&percnt;<var>koñcówka</var>}     Usuniêcie najmniejszego wzorca <var>koñcówka</var>
${<var>parametr</var>&percnt;&percnt;<var>koñcówka</var>}    Usuniêcie najwiêkszego wzorca <var>koñcówka</var>
${<var>parametr</var>#<var>przedrostek</var>}  Usuniêcie najmniejszego wzorca <var>przedrostek</var>
${<var>parametr</var>##<var>przedrostek</var>} Usuniêcie najwiêkszego wzorca <var>przedrostek</var>
</example>

<sect1 id="shell-redirect">Przekierowywanie pow³oki
<p>
Podstawowe operatory <strong>przekierowywania</strong> do zapamiêtania ([n]
jest opcjonaln± liczb±):
<example compact>
[<var>n</var>]&gt; <var>plik</var>     Przekieruj standardowe wyj¶cie (lub <var>n</var>) do <var>pliku</var>.
[<var>n</var>]&gt;&gt; <var>plik</var>    Do³±cz standardowe wyj¶cie (lub <var>n</var>) do <var>pliku</var>.
[<var>n</var>]&lt; <var>plik</var>     Przekieruj standardowe wej¶cie (lub <var>n</var>) z <var>pliku</var>.
[<var>n1</var>]&gt;&amp;<var>n2</var>      Przekieruj standardowe wyj¶cie (lub <var>n1</var>) do <var>n2</var>.
&gt; <var>plik</var> &gt;&2    Przekieruj standardowe wyj¶cie i strumieñ b³êdów do <var>pliku</var>.
| <var>polecenie</var>     Przekieruj standardowe wyj¶cie na wej¶cie
<var>polecenia</var>. 
&gt;&2 | <var>polecenie</var> Przekieruj standardowe wyj¶cie i strumieñ b³êdów
na wej¶cie <var>polecenia</var>.
</example>

<sect1 id="shell-cond">Polecenia warunkowe pow³oki
<p>
Ka¿de polecenie zwraca <strong>kod wyj¶cia</strong> (exit status), który
mo¿e zostaæ u¿yty w wyra¿eniu warunkowym:
<list compact>
<item>Sukces: 0 (Prawda)
<item>B³±d: 1&ndash;255 (Fa³sz)
</list>
Zauwa¿, ¿e u¿ycie warto¶ci 0 w celu wyra¿enia &ldquor;prawdy&rdquor; ró¿ni siê od zwyk³ej
konwencji w innych obszarach przetwarzania.
Poza tym `[' jest odpowiednikiem polecenia <prgn>test</prgn>, które traktuje
argumenty a¿ do `]' jako wyra¿enie warunkowe.
<p>
Podstawowe <strong>idiomy warunkowe</strong> (conditional idioms) do 
zapamiêtania to:
<example compact>
<var>polecenie</var> && <var>je¶li_sukces_uruchom_równie¿_to_polecenie</var> || true
<var>polecenie</var> || <var>je¶li_nie_sukces_uruchom_w_zamian_to_polecenie</var>

if [ <var>wyra¿enie_warunkowe</var> ]; then  
 <var>je¶li_sukces_uruchom_to_polecenie</var>
else
 <var>je¶li_nie_sukces_uruchom_to_polecenie</var>
fi
</example>

<tt>|| true</tt> by³o potrzebne by upewniæ siê, ¿e ten skrypt przypadkowo 
nie zakoñczy siê w tej linii je¶li pow³oka by³a by wywo³ana z flag±
<tt>-e</tt>.

<p>
Operatory porównywania <strong>plików</strong> w wyra¿eniach warunkowych to:
<example compact>
-e <var>plik</var>         Prawda, je¶li <var>plik</var> istnieje.
-d <var>plik</var>         Prawda, je¶li <var>plik</var> istnieje i jest katalogiem.
-f <var>plik</var>         Prawda, je¶li <var>plik</var> istnieje i jest normalnym plikiem.
-w <var>plik</var>         Prawda, je¶li <var>plik</var> istnieje i jest zapisywalny.
-x <var>plik</var>         Prawda, je¶li <var>plik</var> istnieje i jest wykonywalny.
<var>plik1</var> -nt <var>plik2</var> Prawda, je¶li <var>plik1</var> jest nowszy ni¿ <var>plik2</var>. (modyfikacja)
<var>plik1</var> -ot <var>plik2</var> Prawda, je¶li <var>plik1</var> jest starszy ni¿ <var>plik2</var>. (modyfikacja)
<var>plik1</var> -ef <var>plik2</var> Prawda, je¶li maj± takie same numery urz±dzeñ i iwêz³ów.
</example>
<p>
Operatory porównywania <strong>³añcuchów znaków</strong> w wyra¿eniach
warunkowych:
<example compact>
     -z <var>s³owo</var>    Prawda, je¶li d³ugo¶æ <var>s³owo</var> wynosi zero.
     -n <var>s³owo</var>    Prawda, je¶li d³ugo¶æ <var>s³owo</var> jest ró¿na od zera.
<var>s³owo1</var> == <var>s³owo2</var>   Prawda, je¶li s³owa s± równe.
<var>s³owo1</var> = <var>s³owo2</var>    Prawda, je¶li s³owa s± równe.
    (dla ¶cis³ej zgodno¶ci z POSIX, zamiast &ldquor;==&rdquor; nale¿y u¿ywaæ &ldquor;=&rdquor;) 
<var>s³owo1</var> != <var>s³owo2</var>   Prawda, je¶li s³owa nie s± równe.
<var>s³owo1</var> &lt;  <var>s³owo2</var>   Prawda, je¶li <var>s³owo1</var> sortuje siê przed <var>s³owo2</var> (zle¿ne od lokalizacji (locale)).
<var>s³owo1</var> &gt;  <var>s³owo2</var>   Prawda, je¶li <var>s³owo1</var>
sortuje siê po <var>s³owo2</var> (zale¿ne od lokalizacji (locale) ).
</example>
<p>
Operatory <strong>arytmetycznego</strong> porównywania liczb ca³kowitych
<p>
Wyra¿enia warunkowe to: <tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>, 
<tt>-le</tt>, <tt>-gt</tt>, i <tt>-ge</tt>.
</sect1>

<sect1 id="clprocess">Przetwarzanie linii poleceñ
<p>
Pow³oka przetwarza skrypt tak:
<list compact> <!-- FIXME: metacharacters, expand, alias ?? -->
<item>rozbicie na <strong>¿etony</strong> (tokens) przez meta-znaki: SPACJA, TAB, NOWA_LINIA, ;, (, ), &lt;, &gt;, |, &amp;
<item>sprawdzenie <strong>s³ów kluczowych</strong> (keyword), je¶li nie s± pomiêdzy "..." lub '...' (pêtla)
<item>rozwiniêcie <strong>aliasów</strong>, je¶li nie s± pomiêdzy "..." lub '...' (pêtla)
<item>rozwiniêcie <strong>nawiasów</strong>, <tt>a{1,2}</tt> -> <tt>a1 a2</tt>, je¶li nie s± pomiêdzy "..." lub '...'
<item>rozwiniêcie <strong>tyld</strong>, ~<var>u¿ytkownik</var> -> katalog domowy <var>u¿ytkownika</var>, je¶li nie jest pomiêdzy "..." lub '...'
<item>rozwiniêcie <strong>parametrów</strong>, $<var>PARAMETRÓW</var>, je¶li nie s± pomiêdzy "..."
<item>rozwiniêcie <strong>podstawienia polecenia</strong>,
$(<var>polecenie</var>), je¶li nie jest pomiêdzy '...'
<item>podzia³ na <strong>s³owa</strong> wg. $IFS, je¶li nie s± pomiêdzy "..." lub '...'
<item>rozszerzenie *?[] na <strong>¶ciezki</strong>, je¶li nie jest pomiêdzy "..." lub '...'
<item>znalezienie <strong>polecenia</strong>
<list compact>
<item>funkcji
<item>wbudowanego
<item>pliku w $PATH
</list>
<item>pêtla
</list>
<p>
Pojedyncze cudzys³owy pomiêdzy podwójnymi cudzys³owami nie daj± ¿adnego
efektu.

</sect1>

</sect>

<sect>Awk
<p>
Miejsca, w których mo¿na znale¼æ informacje o Awk:
<list compact>
<item><em>Effective awk Programming</em>, 3rd edition (O'Reilly) - (Efektywne
programowanie w awk, trzecie wydanie)
<item><em>Sed &amp; awk</em>, 2nd edition (O'Reilly) - (Sed i awk, drugie
wydanie)
<item><manref name="mawk" section="1"> i <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
Krótki przyk³ad programu (tworz±cego wpisy dla <prgn>newusers</prgn>):
<example>
#!/usr/bin/awk -f
# Skrypt tworz±cy plik przystosowany do u¿ycia z poleceniem 'newusers'
# z pliku zawieraj±cego ID u¿ytkowników i has³a w formie:
# Imiê Nazwisko has³o
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Przydzielenie pocz±tkowych UID i GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Wywo³anie: newusers PoczatkoweUID plik\n" \
          "  gdzie:\n"
          "    Pocz±tkoweUID jest pocz±tkowym identyfikatorem dodawanego u¿ytkownika,\n" \
          "    plik jest plikiem wej¶cia w postaci:\n" \
          "      imiê nazwisko has³o\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Pocz±tkowe UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s&ldquor;/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
Dwa pakiety w systemie &debian; dostarczaj± <package>awk</package> zgodnego z
POSIX:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priority: required
  <item>Installed-Size: 228
  <item>Mniejszy i znacznie szybszy&mdash;dobry dla domy¶lnej instalacji
  <item>Zawiera ograniczenia ustalane podczas kompilacji
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 1708
  <item>Wiêkszy i potê¿niejszy&mdash;posiada wiele rozszerzeñ
  <list compact>
   <item>System V Release 4 version of UNIX
   <item>Bell Labs awk
   <item>GNU-specific
  </list>
 </list>
</list>
</sect>

<sect>Perl
<p>
To jest <strong>prawdziwy</strong> interpreter w systemach uniksowych.
<p>
Miejsca, w których mo¿na znale¼æ informacje o Perl'u:
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3rd edition (O'Reilly)
</list>
<p>
Krótki, przyk³adowy program (tworzy wpisy dla polecenia <prgn>newusers</prgn>)
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,"&ldquor;,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Instalacja modu³u Perla <var>nazwa_modu³u</var>:
<example>
# perl -MCPAN -e 'install <var>nazwa_modu³u</var>'
</example>
 
</sect>

<sect>Python
<p>
Jest to mi³y, zorientowany obiektowo interpreter.
<p>
Miejsca, w których mo¿na znale¼æ informacje o Pythonie:
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
</list>
<p>
Krótki, przyk³adowy program (tworzy wpisy dla polecenia <prgn>newusers</prgn>):
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Sposób u¿ycia:  ", sys.argv[0], " Pocz±tkoweUID [plik]\n" \
"\tPocz±tkoweUID jest pocz±tkowym identyfikatorem dodawanego u¿ytkownika.\n" \
"\tplik jest plikiem wej¶cia. Je¶li nie okre¶lony to standardowe wej¶cie.\n\n" \
"Format pliku wej¶ciowego:\n"\
"\timiê nazwisko has³o\n"
                return 1

def parsefile(startuid):
    #
    # g³ówne filtrowanie
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # powy¿sze rozsypuje siê przy z³ej liczbie parametrów :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s&ldquor;/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID zaczyna siê od: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Czytaj plik z: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>Make
<p>
Miejsca, w których mo¿na znale¼æ informacje o Make:
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2nd edition (O'Reilly)
</list>
<p>
Proste zmienne automatyczne:
<p>
Sk³adnia regu³:
<example>
<var>Cel</var>: [ <var>warunek wstêpny</var> ... ]
 [TAB]  <var>polecenie1</var>
 [TAB]  -<var>polecenie2</var> # ignoruj b³êdy
 [TAB]  @<var>polecenie3</var> # wstrzymaj echo
</example>
Gdzie <tt>[TAB]</tt> jest kodem TAB.
Ka¿da linia jest intrepretowana przez pow³okê po podmianie zmiennych przez
<prgn>make</prgn>.
U¿yj <tt>\</tt> na koñcu linii, by kontynuowaæ skrypt.
U¿yj <tt>$$</tt>, by wprowadziæ <tt>$</tt> dla zmiennych
¶rodowiskowych w skrypcie pow³oki. 
<p>
<strong>Uwik³ane regu³y</strong> dla <var>celu</var> oraz
<var>warunki wstêpne</var> mog± byæ, na przyk³ad, zapisane jako:
<example>
&percnt;: &percnt;.c header.h 
</example>
lub
<example>
&percnt;.o: &percnt;.c header.h
</example>
Tutaj <var>cel</var> zawiera znak <tt>&percnt;</tt> (dok³adnie jeden
z nich). Znak <tt>&percnt;</tt> mo¿e zastêpowaæ jakikolwiek niepusty
podci±g aktualnych nazw plików danego celu. W <var>warunkach wstêpnych</var>
równie¿ mo¿na u¿yæ znaku <tt>&percnt;</tt> by pokazaæ jak ich nazwy maj±
siê do aktualnej nazwy celu.
<p>
<strong>Regu³y przyrostkowe</strong> s± <strong>przestarza³ym</strong>
sposobem definiowania regu³ uwik³anych dla <prgn>make</prgn>. 
S± nadal obs³ugiwane w GNU <prgn>make</prgn> dla zgodno¶ci, ale u¿ywaj
odpowiednich regu³ wzorców, kiedykolwiek to mo¿liwe:
<example>
stara regu³a przyrostkowa --&gt; nowa regu³a wzorcowa
.c:                       --&gt; &percnt;  : &percnt;.c
.c.o:                     --&gt; &percnt;.o: &percnt;.c
</example>
Automatyczne zmienne dla regu³:
<example>
foo.o: new1.c new2.c old1.c new3.c
$@ == foo.o                         (cel)
$< == new1.c                        (pierwszy)
$? == new1.c new2.c new3.c          (nowsze)
$^ == new1.c new2.c old1.c new3.c   (wszystkie)
$* == `&percnt;' dopasowany rdzeñ we wzorcu celu
</example>
Opis zmiennych:
<example>
foo1 := bar    # Jednorazowe rozszerzenie
foo2  = bar    # Rekursywne rozszerzenie
foo3 += bar    # Dopisanie
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir katalog/plik.rozszerzenie) # Wydobywa &ldquor;katalog&rdquor;
$(notdir NAZWY...), $(basename NAZWY...), $(suffix NAZWY...) ...
</example>
Wprowad¼ <tt>make -p -f/dev/null</tt>,by zobaczyæ automatyczne regu³y
wewnêtrzne. 
</sect>

<sect>C
<p>
Przygotowanie:
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
Miejsca, w których mo¿na znale¼æ informacje o C:
<list compact>
<item><tt>info libc</tt> (opis funkcji biblioteki C)
<item><manref name="gcc" section="1">
<item><manref name="each_C_library_function_name" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 
 2nd edition (Prentice Hall).
</list>
<p>

<sect1>Prosty program w C (<prgn>gcc</prgn>)
<p>
Prosty przyk³ad kompilowania <file>przyklad.c</file> z bibliotek±
<file>libm</file> do pliku wykonywalnego <prgn>uruchom_przyklad</prgn>:
<example>
$ cat &gt; przyklad.c &lt;&lt; EOF
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* zapobiega przepe³nieniu bufora */
        y[10] = '\0'; /* wype³niamy, by upewniæ siê, ¿e ci±g koñczy siê '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o uruchom_przyklad przyklad.c -lm
$ ./uruchom_przyklad
        1, 2.915, ./uruchom_,     (null)
$ ./uruchom_przyklad 1234567890qwerty
        2, 3.082, ./uruchom_, 1234567890qwerty
</example>
W przyk³adzie <tt>-l<strong>m</strong></tt> jest potrzebne, by zlinkowaæ
bibliotekê <tt>lib<strong>m</strong></tt> dla <prgn>sqrt()</prgn>. 
Faktycznie biblioteka
znajduje siê w <file>/lib</file> pod nazw± <file>libm.so.6</file>, która
jest dowi±zaniem symbolicznym do <file>libm-2.1.3.so</file>.
<p>
Spójrz na ostatni parametr w wyj¶ciowym tek¶cie. Jest tam wiêcej ni¿
dziesiêæ znaków mimo, ¿e u¿yli¶my <tt>&percnt;10s</tt>.
<p>
U¿ywanie funkcji ze wska¼nikami do operacji na pamiêci bez sprawdzania
obszarów granicznych, zw³aszcza takich jak <prgn>sprintf</prgn> lub
<prgn>strcpy</prgn>, jest uznawane za przestarza³e, co ma zapobiegaæ b³êdom
przepe³nienia buforu. Zamiast nich nale¿y u¿ywaæ <prgn>sprintf</prgn> oraz
<prgn>strncpy</prgn>.
</sect1>

<sect1>Odpluskwianie

<sect2>Uruchamianie i testowanie programów przy pomocy <prgn>gdb</prgn>
<p>
Przygotowanie:
<example>
# apt-get install gdb
</example>
<p>
Miejsca, w których mo¿na znale¼æ informacje o <prgn>gdb</prgn>:
<list compact>
<item><tt>info gdb</tt> (samouczek)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>
<p>
Do prze¶ledzenia dzia³ania programu skompilowanego z opcj± <tt>-g</tt>
u¿yj programu <prgn>gdb</prgn>. Wiele poleceñ ma swoje kilkuznakowe skróty.
Dope³nianie tabulatorem dzia³a tak samo jak w pow³oce.
<example>
$ gdb program
(gdb) b 1                # ustaw punkt wstrzymania w linii 1
(gdb) run <var>arg1 arg2 arg3</var> # uruchom program
(gdb) next               # nastêpna linia
...
(gdb) step               # krok do przodu
...
(gdb) p parm             # wy¶wietl parm 
...
(gdb) p parm=12          # ustaw warto¶æ na 12
</example>
<p>
Je¶li chcesz siê dowiedzieæ, jak przeprowadziæ odpluskwianie przy pomocy 
Emacsa, zerknij do <ref id="editkey">.
</sect2>

<sect2 id="ss-ldd">Sprawdzanie zale¿no¶ci od bibliotek
<p>
Aby znale¼æ wymagane przez program biblioteki skorzystaj z <prgn>ldd</prgn>:
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
By <prgn>ls</prgn> mog³o pracowaæ w ¶rodowisku <prgn>chroot</prgn>, musz±
siê w nim znale¼æ powy¿sze biblioteki.
<p>
Nastêpuj±ce polecenia mog± byæ równie¿ u¿yteczne:
<list compact>
<item><prgn>strace</prgn>: ¶ledzi wywo³ania systemowe oraz sygna³y
<item><prgn>ltrace</prgn>: ¶ledzi wywo³ania biblioteczne
</list>
</sect2>
 
<sect2>Odpluskwianie z u¿yciem narzêdzi do wykrywania wycieków pamiêci

<p>
Istnieje wiele narzêdzi do wykrywania wycieków pamiêci w Debianie.
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (niedostêpny w pakiecie, pobierz z  
 <url id="&memwatch-home;" name="memwatch">.)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> z
  <url id="&parasofthome;" name="Parasoft">. (non-free, komercyjnie za op³at±)
</list>
<p>
Sprawd¼ równie¿ <url id="&mallocdebughome;" 
  name="Debugging Tools for Dynamic Storage Allocation and Memory Management">.

<sect1>Flex &ndash; lepszy Lex
<p>
<prgn>flex</prgn> jest szybkim generatorem analizatorów leksykalnych.
<p>
Miejsca, w których mo¿na znale¼æ informacje o <prgn>flex</prgn>:
<list compact>
<item><tt>info flex</tt> (samouczek)
<item><manref name="flex" section="1">
</list>
<p>
Musisz utworzyæ w³asn± funkcjê <prgn>main()</prgn> i <prgn>yywrap()</prgn>,
lub <file>program.l</file> powinien wygl±daæ tak, jak poni¿ej, by kompilowa³
siê bez biblioteki (<prgn>yywrap</prgn> jest makrem; <tt>&percnt;option
main</tt> uaktywnia bezwarunkowo <tt>&percnt;option noyywrap</tt>):
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
Zamiast tego mo¿esz skompilowaæ program podaj±c na koñcu polecenia 
<prgn>cc</prgn> opcjê -<tt>lfl</tt> (tak jak przy AT&amp;T-Lex opcjê
<tt>-ll</tt>).
Nie potrzeba wtedy u¿ywaæ<tt>&percnt;option</tt>.
</sect1>

<sect1>Bison &ndash; lepszy Yacc
<p>
Kilka pakietów w Debianie dostarcza zgodny z Yacc generator analizatorów
sk³adniowych:
<p>
<list compact>
 <item><package>bison</package>: GNU LALR parser generator
 <item><package>byacc</package>: The Berkeley LALR parser generator
 <item><package>byyacc</package>: Backtracking parser generator oparty na <package>byacc</package>
</list>
<p>
Miejsca, w których mo¿na znale¼æ informacje o <prgn>bison</prgn>:
<list compact>
<item><tt>info bison</tt> (samouczek)
<item><manref name="bison" section="1">
</list>
<p>
Musisz utworzyæ w³asne funkcje <prgn>main()</prgn>
i <prgn>yyerror()</prgn>. <prgn>main()</prgn> wywo³uje
<prgn>yyparse()</prgn>, która z kolei wywo³uje <prgn>yylex()</prgn>,
zazwyczaj stworzon± przez FleX.
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> jest narzêdziem tworz±cym skrypty pow³oki, które
automatycznie konfiguruj± ¼ród³a oprogramowania by dostosowaæ je do wielu
systemów uniksopodobnych u¿ywaj±c systemu budowania GNU.
<p>
<prgn>autoconf</prgn> tworzy skrypt konfiguruj±cy 
<prgn>configure</prgn>, a <prgn>configure</prgn> 
automatycznie dostosowany <file>Makefile</file> u¿ywaj±c wzorca
<file>Makefile.in</file>.
 
<sect2>Kompilacja i instalacja programu
<p>
&debian; nie dotyka plików znajduj±cych siê w <file>/usr/local</file>
(zobacz <ref id="diverse">). W zwi±zku z tym, je¶li skompilujesz program ze
¼róde³ oraz zainstalujesz go w <file>/usr/local</file> nie bêdzie on
kolidowa³ z Debianem.
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # to polecenie przekopiuje pliki do systemu
</example>

<sect2>Odinstalowywanie programu
<p>
Je¶li nadal posiadasz ¼ród³a i u¿ywaj± one
<prgn>autoconf</prgn>/<prgn>automake</prgn> oraz pamiêtasz parametry
z jakimi je konfigurowa³e¶ spróbuj:
<example>
$ ./configure <var>wszelkie-opcje-jakie-poda³e¶-przy-konfiguracji</var>
# make uninstall
</example>
<p>
Zamiast tego, je¶li jeste¶ absolutnie pewien, ¿e podczas instalacji pliki
kopiowane s± tylko do <file>/usr/local</file> i nie ma tam niczego wa¿nego,
mo¿esz usun±æ jego zawarto¶æ wprowadzaj±c:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
Je¶li natomiast nie jeste¶ pewien gdzie zosta³y przekopiowane pliki podczas
instalacji, rozwa¿ zastosowanie <package>checkinstall</package>, który
pozwala w ³atwy sposób odinstalowaæ programy.
</sect1>

</sect>

<sect>Przygotowanie dokumentu
<p>

<sect1>Sk³ad tekstu <tt>roff</tt>
<p>
Tradycyjnie ju¿, <tt>roff</tt> jest g³ównym systemem procesu tekstu
w systemach Unix.
<p>
Zobacz <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7"> oraz
<tt>info groff</tt>.
<p>
Istnieje dobre wprowadzenie do makr <prgn>-me</prgn>.
Je¶li posiadasz <package>groff</package> (w wersji 1.18 lub nowszej), znajd¼
<file>&f-meintro;</file> i wprowad¼ poni¿sze polecenie:
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
Kolejne polecenie utworzy zwyk³y plik tekstowy:
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
Dla drukowania skorzystaj z wyj¶cia PostScript.
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>

<sect1>SGML
<p>
Przygotowanie:
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>

Miejsca, w których mo¿na znale¼æ informacje o <package>debiandoc-sgml</package>:
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em>DocBook: The Definitive Guide</em>, by Walsh and Muellner (O'Reilly)
</list>
<p>
SGML umo¿liwia zarz±dzanie wieloma formatami dokumentu. Jednym z prostszych
systemów SGML jest Debiandoc, który jest tutaj u¿ywany. Wymaga on pewnych
konwersji plików tekstowych dla nastêpuj±cych znaków:
<!-- nbsp bug in PDF ? -->
<list compact>
<item>&ldquor;&lt;&rdquor; --&gt; <tt>&amp;lt;</tt>
<item>&ldquor;&gt;&rdquor; --&gt; <tt>&amp;gt;</tt>
<item>&ldquor;&nbsp;&rdquor; --&gt; <tt>&amp;nbsp;</tt>  (nie³amana spacja)
<item>&ldquor;&amp;&rdquor; --&gt; <tt>&amp;amp;</tt>
<item>&ldquor;&percnt;&rdquor; --&gt; <tt>&amp;percnt;</tt>
<item>&ldquor;&copy;&rdquor; --&gt; <tt>&amp;copy;</tt>
<item>&ldquor;&ndash;&rdquor; --&gt; <tt>&amp;ndash;</tt>
<item>&ldquor;&mdash;&rdquor; --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
W celu oznaczenia czê¶ci jako niedrukowalny komentarz wprowad¼:
<example>
&lt;!-- A tu jest w³a¶nie komentarz ... --&gt;
</example>
Do oznaczenia miejsca, z którym mamy problemy (brak wiedzy, do¶wiadczenia
z danego zakresu) u¿yj poni¿szej formy:
<example>
&lt;![ &percnt;FIXME; [ Nie wiem, co tu powinno byæ ... ]]&gt;
</example>
W SGMLu <em>pierwsza definicja</em> entitki wygrywa. Przyk³ad:
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
W dokumencie wynikowym bêdzie "Data 1". Je¶li w pierwszej linii by³oby
"IGNORE" zamiast "INCLUDE", pojawi³oby siê "Data 2" (druga linia jest
wyra¿eniem warunkowym). Równie¿ powtórzone zwroty, wyra¿enia mog± byæ
z góry oddzielone od kontekstu.
<example>
&lt;!entity <var>czyjtojest</var> "mój"&gt;
Witaj  &amp;<var>czyjtojest</var>; przyjacielu.
To jest &amp;<var>czyjtojest</var>; podrêcznik.
</example>
Efektem bêdzie:
<example>
Witaj mój przyjacielu.
To jest mój podrêcznik.
</example>
Przyjrzyj siê prostemu przyk³adowi SGML <file>sample.sgml</file>,
znajduj±cego siê w <url id="&examples;" name="examples">.
<p>
Niekiedy, gdy dokument SGML rozrasta siê, TeX mo¿e zacz±æ generowaæ b³êdy.
¯eby uporaæ siê z tym problemem, musisz zwiêkszyæ parametr pool size w 
<file>/etc/texmf/texmf.cnf</file> (lub, co bardziej zalecane, zmodyfikowaæ
<file>/etc/texmf/texfm.d/95NonPath</file> i uruchomiæ
<prgn>update-texmf</prgn>).
</sect>

<sect id="packaging">Pakietowanie
<p>
Przygotowanie:
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
                  &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # dla Potato
</example>
Miejsca, w których mo¿na znale¼æ informacje o pakietowaniu:
<list compact>
 <item><ref id="pkg-basics"> (podstawy)
 <item>Debian New Maintainers' Guide (samouczek)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (najlepsza praktyka)
 <item>Debian Policy Manual (autorytatywny)
 <item>Packaging Manual (Potato) 
</list>

<sect1 id="pack-binary">Pakietowanie pojedyñczego pliku binarnego
<p>
Szybka i brzydka metoda pakietowania podes³ana przez Joey Hessa.
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mojpakiet
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: mój ma³y pakiecik
 Nie spodziewaj siê zbyt wiele.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">Pakietowanie z u¿yciem narzêdzi
<p>
W celu utworzenia podstawowego pakietu mo¿esz skorzystaæ
z <prgn>dh_make</prgn> dostêpnego w pakiecie <package>dh-make</package>.
Nastêpnie postêpuj wed³ug instrukcji z <manref name="dh-make" section="1">.
Ten sposób wykorzystuje <prgn>debhelper</prgn> w <prgn>debian/rules</prgn>.
<p>
Starszym sposobem jest u¿ycie <prgn>deb-make</prgn> z pakietu
<package>debmake</package>. Wtedy korzysta siê jedynie z pow³oki, zamiast
z <prgn>debhelper</prgn>.
<p>
Przyk³adem wielo¼ród³owego pakietu mo¿e byæ &ldquor;mc&rdquor; (<tt>dpkg-source -x
mc_4.5.54.dsc</tt>), korzystaj±cy z &ldquor;sys-build.mk&rdquor; Adama Heatha
(<email>doogie@debian.org</email>), oraz &ldquor;glibc&rdquor; (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>), który korzysta z innego systemu Joela Kleckera
(<email>espy@debian.org</email>).
</sect>

</chapt>
