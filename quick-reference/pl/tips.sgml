<!-- CVS revision of this document "$Revision: 1.7 $"  -->
<!-- CVS revision of original english document "1.81"  -->

<chapt id="tips">Debianowe porady


<sect id="booting">Uruchamianie systemu
<p>
Zajrzyj do LDP <url id="&bootprompt-howto;" name="BootPrompt-HOWTO">
w celu uzyskania szczegó³owych informacji na temat boot prompt.

<sect1 id="crackroot">&ldquor;Zapomnia³em has³a roota!&rdquor; (1)
<p> 
Mo¿liwe jest uruchomienie systemu i zalogowanie siê na konto
administratora (root) bez znajomo¶ci has³a, je¿eli tylko posiadamy
dostêp do lokalnej konsoli (zak³adaj±c, ¿e nie zosta³o za³o¿one
has³o na BIOS lub program ³aduj±cy system taki jak <prgn>lilo</prgn>).
<p>
Poni¿ej przedstawiono procedurê postêpowania w takim przypadku,
która nie wymaga posiadania dodatkowych narzêdzi, jak choæby dyskietek
czy p³yt z systemem, ani modyfikacji ustawieñ BIOSu. Zak³adamy, ¿e
&ldquor;Linux&rdquor; to etykieta podstawowego j±dra systemu w domy¶lnej instalacji
Debiana.
<p>
Gdy tylko pojawi siê ekran startowy <prgn>lilo</prgn> oraz napis
<tt>boot:</tt> (byæ mo¿e musisz przytrzymaæ klawisz shift podczas
uruchamiania <prgn>lilo</prgn> aby zapobiec automatycznemu startowi
systemu) wpisz:

<example>
boot: Linux init=/bin/sh
</example>

To wymusza za³adowanie j±dra oraz uruchomienie <file>/bin/sh</file>
w miejsce standardowego programu <prgn>init</prgn>.
Dziêki temu uzyskujesz przywileje administratora oraz dostêp do konta root.

Poniewa¿ system plików <file>/</file> jest zamontowany w trybie &ldquor;tylko do
odczytu&rdquor;, a inne nie s± zamontowane w ogóle, trzeba wykonaæ kilka
operacji, aby uzyskaæ w pe³ni funkcjonuj±cy system.

<example>init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>

(Je¿eli drugie pole danych zapisanych w <file>/etc/passwd</file> zawiera
tylko literkê &ldquor;x&rdquor; dla ka¿dego u¿ytkownika, oznacza to, ¿e Twój system
u¿ywa osobnego pliku do przechowywania hase³ i musisz edytowaæ
<file>/etc/shadow</file>.)

Aby wy³±czyæ has³o dla konta root, wykasuj ca³± zawarto¶æ pola
odpowiedzialnego za has³o (jest to drugie pole w pliku
<file>/etc/passwd</file> lub <file>/etc/shadow</file>, je¿eli system go
u¿ywa). Teraz mo¿esz prze³adowaæ system i zalogowaæ siê na konto root bez
has³a. Podczas inicjowania na poziomie startu równym 1 (&ldquor;runlevel 1&rdquor;),
Debian (od wersji Potato) wymaga has³a, czego niektóre starsze dystrybucje
nie czyni±.
<p>

Dobrym pomys³em jest mieæ jaki¶ prosty edytor w <file>/bin</file> na
wypadek, gdyby <file>/usr</file> by³o niedostêpne (zobacz tak¿e
<ref id="bin-editor">).


<p>
Mo¿esz tak¿e rozwa¿yæ instalacjê pakietu <package>sash</package>. Je¶li
system przestanie siê uruchamiaæ, wykonaj:

<example>
boot: Linux init=/bin/sash
</example>

<prgn>sash</prgn> jest interaktywnym zamiennikiem dla <prgn>sh</prgn>,
nawet gdy <file>/bin/sh</file> jest niezdatny do u¿ytku. <prgn>sash</prgn>
jest ³±czony statycznie i zawiera wbudowane wiele typowych 
funkcji (wpisz &ldquor;help&rdquor; w linii poleceñ, aby poznaæ jego mo¿liwo¶ci).
</sect1>

<sect1 id="crackroot2">&ldquor;Zapomnia³em has³a roota!&rdquor; (2)
<p>
Uruchom system z zestawu dyskietek ratunkowych lub z p³yty CD.
Za³ó¿my, ¿e <file><var>/dev/hda3</var></file> to oryginalna, g³ówna
partycja (root). Poni¿sze polecenia pozwol± na równie ³atwe, jak w poprzednim
punkcie, wyedytowanie plików z u¿ytkownikami i has³ami.

<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
Przewag± tej metody nad poprzedni± jest to, ¿e nie trzeba znaæ has³a do
<prgn>lilo</prgn> (je¿eli jest takowe uaktywnione). Aczkolwiek wymaga to
ingerencji w ustawienia BIOSu i w³±czenie mo¿liwo¶ci startu systemu z CD
czy te¿ dyskietek.

</sect1>

<sect1 id="dead-lilo">System siê nie uruchamia
<p>
To ¿aden problem, nawet je¶li zaniedbano przygotowawania
dystkietki startowej. Je¶li <prgn>lilo</prgn> jest uszkodzone, u¿yj 
p³yty startowej z zestawu p³yt instalacyjnych Debiana (lub utwórz 
dyskietkê startow± z obrazów zawartych na tej¿e p³ycie)
i uruchom system przy jej pomocy. 

<p>
Zak³adamy, ¿e g³ówna partycja Twojej instalacji Linuksa to 
<file><var>/dev/hda12</var></file> oraz ¿e chcesz ustawiæ 3 poziom startu. 
<p>
Gdy pojawi siê komunikat startowy, wpisz:

<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>

Po chwili otrzymujesz prawie w pe³ni funkcjonalny system wykorzystuj±cy
j±dro z p³ytki/dyskietki startowej. Mog± jednak wyst±piæ pewne problemy 
wynikaj±ce z braku pewnych mo¿liwo¶ci lub modu³ów w dystrybucyjnym j±drze.

<p>
Je¶li masz uszkodzony system zainteresuj siê te¿ rozdzia³em
<ref id="un-bootable">.

<p>
Je¿eli potrzebujesz specjalnie dostosowanej dyskietki startowej, przejrzyj
plik <prgn>readme.txt</prgn> umieszczony na dysku ratunkowym.

</sect1>

<sect1 id="no-x-start">Jak wy³±czyæ automatyczne uruchamianie Xów przy starcie?!

<p>
Ujarzmianie wersji <tt>unstable/sid</tt> mo¿e byæ zabawne, ale 
zawieraj±cy b³êdy <prgn>xdm</prgn>, <prgn>gdm</prgn>,
<prgn>kdm</prgn> oraz <prgn>wdm</prgn> staruj±cy przy uruchamianiu
systemu mo¿e Ci dopiec.
<p>
Na pocz±tek zdob±d¼ dostêp do konta administratora (root) wpisuj±c 
poni¿sze polecenie podczas startu <prgn>lilo</prgn>:
<example>
boot: <var>Linux</var> vga=normal s
</example>
Zak³adamy, ¿e <var>Linux</var> to etykieta j±dra, które
zazwyczaj uruchamiasz. Natomiast &ldquor;vga=normal&rdquor; sprawi, ¿e 
<prgn>lilo</prgn> wystartuje w normalnym trybie VGA. Ostatni 
parametr -- &ldquor;s&rdquor; (lub &ldquor;S&rdquor;) sprawia, ¿e <prgn>init</prgn> 
uruchamia system w trybie pojedynczego u¿ytkownika. 
Teraz wystarczy wpisaæ has³o administratora (konto root).
<p>
Istnieje kilka sposobów na wy³±czenie wszystkich demonów systemu X:
<list>
<item>uruchom <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6</tt>
<item>wstaw &ldquor;exit 0&rdquor; na pocz±tek wszystkich plików
     <file>/etc/init.d/<var>?</var>dm</file>.

<item>zmieñ nazwê wszystkich plików
     <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> na
     <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>usuñ wszystkie pliki
     <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>.
<item>uruchom 
     <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
W przyk³adach <file>rc<var>2</var>.d</file> oznacza aktualny 
poziom startu (runlevel) ustalony w <file>/etc/inittab</file>, 
za¶ <file><var>?</var>dm</file> ka¿dy z <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn> czy te¿ <prgn>wdm</prgn>
<p>
Tylko pierwsze z rozwi±zañ wymienionych na li¶cie, jest 
&ldquor;jedynie s³uszn± drog±&rdquor; w systemie &debian;. 
Ostatni ze sposobów jest ³atwy, ale wymaga ponownego ustawienia mened¿era
ekranu u¿ywaj±c pó¼niej <prgn>dpkg-reconfigure</prgn>. 
Pozosta³e to ró¿ne metody na 
wy³±czenie demonów.
<p>
Po tych czynno¶ciach nadal mo¿esz uruchomiæ ¶rodowisko graficzne
poleceniem <prgn>startx</prgn> wydanym na dowolnej konsoli tekstowej. 
</sect1>

<sect1 id="bootprompt">Inne triki stosowane podczas startu systemu
<p>
System mo¿e byæ uruchamiany w wybranym poziomie startu (runlevel) oraz 
z okre¶lon± przez u¿ytkownika konfiguracj±. Wystarczy wykorzystaæ 
udostêpnian± przez <prgn>lilo</prgn> mo¿liwo¶æ podania parametrów
przy uruchamianiu systemu.

Szczegó³y znajdziesz w 
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).

<p>
Je¿eli chcesz uzyskaæ 4 poziom startu, spróbuj poni¿szego:

<example>
boot: Linux 4
</example>

<p>
Je¶li natomiast chcesz uzyskaæ tryb pojedynczego u¿ytkownika (single-user), 
a znasz has³o administratora, mo¿esz u¿yæ:

<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>

<p>
W przypadku, gdy chcesz uruchomiæ system tak, aby wykorzystywa³ 
mniej pamiêci, ni¿ jest w rzeczywisto¶ci w komputerze (powiedzmy 48MB, 
podczas gdy komputer ma 64MB), u¿yj:

<example>
boot: Linux mem=48M
</example>
Upewnij siê, ¿e nie podajesz warto¶ci przewy¿szaj±cej dostêpn± pamiêæ, 
gdy¿ wtedy j±dro mo¿e ulec katastrofie! Je¿eli posiadamy wiêcej ni¿ 64MB 
(przyk³adowo 128MB), do czasu a¿ podamy <tt>mem=128M</tt> podczas startu 
lub w <file>/etc/lilo.conf</file>, starsze j±dra i/lub p³yty g³ówne ze 
starszym BIOSem mog± nie u¿ywaæ pamiêci powy¿ej 64MB.
</sect1>

<sect1 id="bootgrub">Ustawianie parametrów uruchomieniowych GRUB
<p>

<prgn>GRUB</prgn> jest to nowy zarz±dca startu systemu wywodz±cy siê z
projektu GNU Hurd. Jest on bardziej elastyczny ni¿ <prgn>lilo</prgn>, jednak¿e
wystêpuj± tu drobne ró¿nice w zakresie manipulowania parametrami startu 
systemu.

<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Musisz byæ ¶wiadom nazw urz±dzeñ pochodz±cych z Hurda:
<example>
HURD/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,1)             /dev/hda1           C: (zazwyczaj)
 (hd0,4)             /dev/hda4           F: (zazwyczaj)
 (hd1,4)             /dev/hdb4           ?
</example>
Zajrzyj do <file>&f-grub;</file> oraz <file>&f-grub-doc;</file> po 
dok³adniejsze informacje.
</sect1>

</sect>

<sect>Rejestrowanie dzia³añ

<sect1 id="script">Rejestrowanie poleceñ pow³oki
<p>
Administracja systemem poci±ga za sob± o wiele wiêcej drobiazgowych zadañ 
w Uniksie ni¿ w zwyk³ych ¶rodowiskach komputerów osobistych. Upewnij siê, ¿e 
znasz przynajmniej podstawowe sposoby konfiguracji, na wypadek gdyby zasz³a 
potrzeba odratowania systemu z problemów. 
Bazuj±ce na graficznym interfejsie narzêdzia 
konfiguracyjne wygl±daj± przyjemnie i wygodnie, jednak¿e zazwyczaj nie nadaj±
siê do u¿ycia w stanie zagro¿enia. 

<p>
Tak wiêc, rejestrowanie dzia³añ poleceniami pow³oki jest dobrym zwyczajem, 
szczególnie podczas pracy jako administrator (root).

<p>
Emacs: U¿yj M-x <tt>shell</tt> aby rozpocz±æ nagrywanie do bufora oraz
C-x C-w aby zapisaæ bufor na dysk. 

<p>
Pow³oka: U¿yj polecenia <prgn>screen</prgn> oraz &ldquor;^A H&rdquor; jak opisano w
<ref id="screen"> lub skorzystaj z <prgn>script</prgn>.

<example>
$ script nagranie
Script started, file is nagranie
$ ...
  ... Rób cokolwiek ...
  ... Na zakoñczenie naci¶nij Ctrl+D ...
Script done, file is nagranie
$ col -bx &lt;nagranie &gt;raport
$ vi raport
</example>
Poni¿sze polecenie mo¿e byæ u¿yte zamiast polecenia <prgn>script</prgn>:
<example>
$ bash -i 2&gt;&amp;1 | tee nagranie
</example>
</sect1>

<sect1>Rejestrowanie obrazu w Xach.

<p>
Je¿eli chcesz zarejestrowaæ graficzny obraz aplikacji w ¶rodowisku X-Window, 
mo¿esz u¿yæ programu <prgn>gimp</prgn> (GUI). Potrafi on przechwytywaæ 
okre¶lone okna z osobna lub ca³y ekran. Innym rozwi±zaniem jest zastosowanie 
programów takich jak: <prgn>xwd</prgn> (z pakietu <package>xbase-clients</package>), 
<prgn>import</prgn> (z pakietu <package>imagemagick</package>) oraz <prgn>scrot</prgn>
(z pakietu <package>scrot</package>).

</sect1>


</sect>

<sect id="archiving">Kopiowanie oraz archiwizacja ca³ych katalogów
<sect1>Podstawowe polecenia do kopiowania ca³ych podkatalogów
<p>
Je¿eli chcesz przearan¿owaæ strukturê po³o¿enia plików, skorzystaj na 
przyk³ad z:
<example>
Typowa metoda:
# cp -a /pocz±tkowy/katalog /docelowy/katalog # wymaga narzêdzia GNU cp
# (cd /pocz±tkowy/katalog &amp;&amp; tar cf - . ) | \
        (cd /docelowy/katalog &amp;&amp; tar xvfp - )
Je¿eli twarde dowi±zania s± wymagane, przydatna oka¿e siê metoda:
# cd /¶cie¿ka/do/starego/katalogu
# find . -depth -print0 | afio -p -xv -0a /punkt/montowania/nowego/katalogu
Je¶li cel jest na odleg³ej maszynie:
# (cd /pocz±tkowy/katalog &amp;&amp; tar cf - . ) | \
        ssh u¿ytkownik@komputer.odleg³y (cd /docelowy/katalog &amp;&amp; tar xvfp - )
Je¿eli nie ma dowi±zañ do plików, wystarczy:
# scp -pr u¿ytkownik1@jeden.komputer:/pocz±tkowy/katalog \
          u¿ytkownik2@drugi.komputer:/docelowy/katalog
</example>
W przyk³adach <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> oraz <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
Powy¿sze sposoby kopiowania ca³ych katalogów zosta³y 
zaprezentowane przez Manoja Srivastavê <email>srivasta@debian.org</email> na 
li¶cie dyskusyjnej debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Tradycyjne narzêdzie <prgn>cp</prgn> nie by³o dobrym 
kandydatem do takich zadañ, gdy¿ nie wy³uskiwa³o symbolicznych
dowi±zañ ani nie chroni³o dowi±zañ twardych. Kolejn± rzecz± wymagaj±c±
rozwa¿enia by³y tzw. rzadkie (sparse) pliki (pliki z dziurami).
<p>
GNU <prgn>cp</prgn> przezwyciê¿y³o te ograniczenia, 
jednak¿e na systemach niezgodnych z GNU, <prgn>cp</prgn> mo¿e 
wci±¿ sprawiaæ problemy. Mo¿esz równie¿ nie móc tworzyæ ma³ych, 
przeno¶nych archiwów u¿ywaj±c <prgn>cp</prgn>.
<example>
&percnt; cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
Tar przezwyciê¿a kilka z problemów, które <prgn>cp</prgn> 
ma z symbolicznymi dowi±zaniami. Jednak¿e, jakkolwiek <prgn>cpio</prgn> 
obs³uguje specjalne pliki, to konwencjonalny <prgn>tar</prgn> nie.
<p>
W przypadku wielu dowi±zañ (hardlink) do jednego pliku, 
<prgn>tar</prgn> umieszcza na ta¶mie tylko jedn± kopiê;
<prgn>cpio</prgn> umieszcza jedn± kopiê dla ka¿dego dowi±zania.
<p>
Polecenie <prgn>tar</prgn> zmieni³o swoj± opcjê u¿ywan± dla plików
<file>.bz2</file> pomiêdzy Potato a Woody, wiêc u¿ywaj w skryptach 
<tt>--bzip2</tt> zamiast ich krótkiej formy <tt>-I</tt> (Potato) 
czy te¿ <tt>-j</tt> (Woody).
</sect1>

<sect1><prgn>pax</prgn>
<p>
Nowe, wypasione narzêdzie POSIX (IEEE Std 1003.2-1992, strony 380&ndash;388
(rozdzia³ 4.48) oraz strony 936&ndash;940 (rozdzia³ E.4.48)) o nazwie
Portable ArchiveInterchange. <prgn>pax</prgn> potrafi czytaæ, zapisywaæ
i wy¶wietlaæ zawarto¶æ pliku archiwum, jak równie¿ kopiowaæ hierarchie
katalogów. Operacje narzêdzi <prgn>pax</prgn> s± niezale¿ne od okre¶lonego
rodzaju archiwum i obs³uguj± szerok± gamê ró¿norodnych formatów.
<p>
Implementacje programu <prgn>pax</prgn> s±  ci±gle nowe i siermiê¿ne.
<example>
# apt-get install pax
$ pax -rw -p e . nowy_katalog
 lub
$ find . -depth  | pax -rw -p e  nowy_katalog
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn> kopiuje pliki do lub z archiwum programu <prgn>cpio</prgn> 
albo programu <prgn>tar</prgn>.
Archiwum mo¿e byæ plikiem na dysku, ta¶m± magnetyczn± czy te¿ potokiem.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> jest lepszym wyborem w zakresie obs³ugi archiwów
w formacie <prgn>cpio</prgn>. Jest zdecydowanie szybszy ni¿ 
<prgn>cpio</prgn>, udostêpnia wiêcej opcji obs³ugi ta¶my 
magnetycznej oraz zachowuje siê o wiele wdziêczniej w przypadku 
uszkodzenia danych wej¶ciowych. Obs³uguje wieloczê¶ciowe archiwa podczas 
interaktywnych operacji. <prgn>afio</prgn> mo¿e tworzyæ kompresowane 
archiwa, które s± o wiele bezpieczniejsze ni¿ kompresowane produkty 
<prgn>tar</prgn>a lub <prgn>cpio</prgn>. 
<prgn>afio</prgn> jest u¿ywane jako &ldquor;archiwizuj±cy silnik&rdquor; w skryptach
do tworzenia kopii zapasowych.
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
</sect1>
</sect>

<sect id="diff-backup">Kopia ró¿nicowa oraz synchronizacja danych
<p>
Kopie ró¿nicowe oraz synchronizacja danych mog± byæ wykonane ró¿nymi
metodami:
<list>
<item><package>rcs</package>:  kopia oraz historia, tylko tekst
<item><package>rdiff-backup</package>:  kopia oraz historia. symboliczne dowi±zania .
<item><package>pdumpfs</package>:  kopia oraz historia w granicach systemu plików.
symlink OK<item><package>rsync</package>:  jednokierunkowa synchronizacja
<item><package>unison</package>: dwukierunkowa synchronizacja
<item><package>cvs</package>:  wielotorowa synchronizacja z serwerem, kopia oraz 
historia, tylko tekst, dojrza³e rozwi±zanie. Zobacz te¿ tutaj: <ref id="cvs">.
<item><package>arch</package>:  wielotorowa synchronizacja z serwerem, kopia oraz 
historia, brak takich rzeczy jak &ldquor;roboczy katalog&rdquor;.
<item><package>subversion</package>:  wielotorowa synchronizacja z serwerem, kopia 
oraz historia, Apache.
</list>
Po³±czenie jednej z tych metod z archiwizacj± opisan± tutaj:
<ref id="archiving"> oraz automatycznym wykonywaniem zadañ o okre¶lonym czasie 
(<ref id="cronjob">) pozwoli stworzyæ mi³y system kopii bezpieczeñstwa.
<p>
Poni¿ej opiszê trzy ³atwe w u¿yciu narzêdzia.

<sect1 id="rdiff-backup">Kopia ró¿nicowa z u¿yciem rdiff
<p>
<package>rdiff-backup</package> pozwala przyjemnie i prosto utworzyæ 
kopiê bezpieczeñstwa wraz z histori± zmian, obs³uguj±c 
dowolne typy plików, w³±czaj±c w to dowi±zania symboliczne.
Aby zarchiwizowaæ <file>~/</file> do <file>/mnt/kopia</file>, 
zastosuj:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/kopia
</example>
Aby przywróciæ dane sprzed trzech dni do <file>~/stare</file>, u¿yj:
<example>
$ rdiff-backup -r 3D /mnt/kopia ~/stare
</example>
Poczytaj te¿ podrêcznik systemowy: <manref name="rdiff-backup" section="1">.

<sect1 id="pdumpfs-backup">Codzienna kopia z u¿yciem <package>pdumpfs</package>
<p>
<package>pdumpfs</package> to prosty system tworzenia codziennych
kopii zapasowych, zbliony do <prgn>dumpfs</prgn>. Mo¿esz korzystaæ z 
dostêpu do wcze¶niejszych kopii w dowolnym momencie.
Spróbuj uruchomiæ kopiê bezpieczeñstwa swojego katalogu domowego
z wykorzystaniem <prgn>pdumpfs</prgn> oraz <prgn>cron</prgn>a!
<p>
<prgn>pdumpfs</prgn> tworzy archiwum <tt>YYYY/MM/DD</tt> w docelowym
katalogu. Przy pierwszym uruchomieniu <prgn>pdumpfs</prgn> 
wszystkie ¼ród³owe pliki s± kopiowane do 
docelowego katalogu. Za kolejnymi uruchomieniami kopiowane
s± jedynie te pliki, które zosta³y zmodyfikowane lub utworzone od ostatniego 
uruchomienia programu <prgn>pdumpfs</prgn>, natomiast pozostaj±ce bez zmian 
s± przedstawiane w postaci dowi±zania do ich odpowiedników we wcze¶niejszych
kopiach celem zaoszczêdzenia miejsca na dysku.
<example>
$ pdumpfs <var>kat_¼ród³owy</var> <var>kat_docelowy</var> [<var>nazwa docelowa</var>]
</example>
Zobacz tak¿e: <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">Regularne kopie ró¿nicowe wykonywane z u¿yciem RCS
<p>
<package>Changetrack</package> regularnie rejestruje zmiany w tekstowych 
plikach konfiguracyjnych. 
Zobacz tak¿e: <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>

<sect>Przywracanie po zawieszeniu systemu
<sect1>Usuwanie procesów
<p>
Uruchom <prgn>top</prgn> aby zobaczyæ, które procesy zu¿ywaj± 
najwiêksz± ilo¶æ zasobów. Naci¶nij &ldquor;P&rdquor; aby posortowaæ wg zu¿ycia 
mocy procesora, &ldquor;M&rdquor; wg zu¿ycia pamiêci oraz &ldquor;k&rdquor; aby usun±æ proces.
Alternatywnie, mo¿esz u¿yæ <tt>ps aux | less</tt> (sposób BSD) lub 
<tt>ps -efH | less</tt> (sposób System-V).
Ta druga sk³adnia pokazuje identyfikatory procesów nadrzêdnych. 
(<tt>PPID</tt>), co pozwala na ubicie zombie (niefunkcjonuj±cych 
procesów potomnych).
<p>
U¿yj polecenia <prgn>kill</prgn> aby usun±æ proces (lub wys³aæ do niego sygna³) 
wed³ug ID procesu. <prgn>killall</prgn> dzia³a analogicznie, ale mo¿liwe jest 
podanie nazwy procesu. Najczê¶ciej u¿ywane sygna³y:
<example>
 1: HUP,  uruchom ponownie demona
15: TERM, normalne zakoñczenie pracy
 9: KILL, bezkompromisowe usuniêcie
</example>

</sect1>

<sect1>Alt-SysRq
<p>
J±dro pozwala siê zabezpieczyæ przed wadliwym dzia³aniem systemu za pomoc±
opcji &ldquor;Magic SysRq key&rdquor; podawanej przy jego kompilacji.
Wci¶niêcie na architekturze i386 Alt-SysRq, a za nim jeden
z klawiszy <tt>r 0 k e i s u b</tt> czyni cuda.
<p>
Klawisz `r' przywróci stan klawiatury po takich niespodziankach jak
zawieszenie siê serwera X. Zmiana poziomu logowania na konsoli na `0' 
zmniejsza ilo¶æ wy¶wietlanych komunikatów o b³êdach. sa'k' (z ang. system 
attention key) zabija wszystkie procesy na danej konsoli wirtualnej.
`e' zabija wszystkie procesy na danym terminalu poza procesem init.
`i' zabija wszystkie procesy poza procesem init.
<p>
`S'ync, `u'mount i re`b'oot s³u¿± do wychodzenia z najciê¿szych k³opotów.
<p>
W momencie powstawania tego dokumentu, domy¶lne j±dro dystrybucyjne
Debiana nie by³o kompilowane z t± opcj±, musisz wiêc skompilowaæ je 
samodzielnie, je¿eli chcesz j± aktywowaæ.
Szczegó³owe instrukcje znajdziesz w pliku:
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>
lub
<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.
</sect1>
</sect>


<sect>Warte zapamiêtania polecenia

<sect1>Przegl±darka tre¶ci tekstowych
<p>
<prgn>less</prgn> jest domy¶ln± przegl±dark± zawarto¶ci plików.  Klawisz &ldquor;h&rdquor; 
przywo³uje pomoc. Program potrafi o wiele wiêcej ni¿ <prgn>more</prgn>.  
<prgn>less</prgn> mo¿e byæ &ldquor;podrasowany&rdquor; przez wykonanie polecenia <tt>eval 
$(lesspipe)</tt> lub <tt>eval $(lessfile)</tt> w skryptach startowych pow³oki.  
Zobacz wiêcej: <file>&f-lessopen;</file>. Opcja <tt>-R</tt> umo¿liwia 
wykorzystywanie nieobrobionego wyj¶cia oraz w³±cza sekwencje ANSI steruj±ce 
kolorami. Zobacz tak¿e: <manref name="less" section="1">.
<p>
<prgn>w3m</prgn> mo¿e byæ u¿yteczny jako alternatywna przegl±darka w 
przypadku niektórych systemów kodowania (np. EUC).

<sect1>Wolna pamiêæ
<p>
<prgn>free</prgn> oraz <prgn>top</prgn> stanowi± dobry sposób uzyskania 
informacji na temat pamiêci. Nie zwracaj uwagi na warto¶æ &ldquor;used&rdquor; w linii
&ldquor;Mem:&rdquor;, ale skorzystaj z liczby umieszczonej poni¿ej (w przyk³adzie 
jest to 38792).
<example>
$ free -k # dla komputera z pamiêci± o rozmiarze 256MB 
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
¦cis³y rozmiar fizycznej pamiêci mo¿e byæ sprawdzony poleceniem
<tt>grep '^Memory' /var/log/dmesg</tt>, które w przypadku z przyk³adu 
powy¿ej daje komunikat: &ldquor;Memory: 256984k/262144k available (1652k kernel
code, 412k reserved, 2944k data, 152k init)&rdquor;.
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Oko³o 5MB jest nieu¿yteczne dla systemu, poniewa¿ j±dro tego u¿ywa.
</sect1>

<sect1>Ustawianie czasu (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
Powy¿sze polecenia ustawiaj± sprzêtowy zegar na warto¶æ: <tt>MM/DD hh:mm, 
CCYY</tt>. Czas jest pokazywany zgodnie z lokaln± stref± czasow±, jednak
sprzêtowy zegar jest ustawiany wed³ug czasu uniwersalnego (UTC).

<sect1>Ustawianie czasu (NTP)
<p>
Zagl±dnij te¿ do: <url id="&time-howto;" name="Managing Accurate Date and Time
HOWTO">.
<p>

<sect2>Ustawianie czasu w przypadku sta³ego ³±cza z Internetem
<p>
Ustaw czas systemu automatycznie wed³ug odleg³ego serwera:
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>serwer</var>
</example>
Dobrym rozwi±zanie jest umieszczenie tego w pliku <file>/etc/cron.daily</file> 
je¿eli Twój system ma sta³e ³±cze z Internetem, a dok³adniej, z wskazanym serwerem.

<sect2>Ustawianie czasu przy czasowych po³±czeniach z sieci±
<p>
U¿yj pakietu <package>chrony</package>.
</sect1>

<sect1>Jak wy³±czyæ wygaszacz ekranu
<p>
W konsoli tekstowej:
<example>
# setterm -powersave off
</example>
<p>
Mo¿esz uruchomiæ konsolê kon2(kanji) u¿ywaj±c:
<example>
# kon -SaveTime 0
</example>
<p>
Maj±c uruchomieny X Window System:
<example>
# xset s off
 lub
# xset -dpms
 lub
# xscreensaver-command -prefs
</example>
Przeczytaj odpowiednie strony podrêcznika systemowego.
</sect1>

<sect1 id="getent">Przeszukiwanie administracyjnych baz danych
<p>
Glibc umo¿liwia wykorzystanie: <manref name="getent" section="1"> 
do wyszukiwania wpisów w administracyjnych bazach danych, takich jak
passwd, group, hosts, services, protocols czy networks.
<example compact>
getent baza_danych [klucz ...]
</example>

<sect1>Wy³±czenia d¼wiêków (brzêczyk)
<p>
Najpro¶ciej od³±czyæ g³o¶niczek  ;-). Albo, dla basha:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Komunikaty o b³êdach na ekranie konsoli
<p>
Aby wy³±czyæ komunikaty o b³êdach wysy³ane na konsolê tekstow±, 
zagl±dnij do <file>/etc/init.d/klogd</file>.
Ustaw <tt>KLOGD="-c <var>3</var>"</tt> w tym skrypcie oraz uruchom 
<tt>/etc/init.d/klogd restart</tt>. Inna metoda, to 
uruchomienie <tt>dmesg -n<var>3</var></tt>.
<p>
Poziomy raportowania b³êdów s± nastêpuj±ce:
<list compact>
<item>0: KERN_EMERG,   system jest bezu¿yteczny
<item>1: KERN_ALERT,   reakcja musi byæ natychmiastowa
<item>2: KERN_CRIT,    krytyczna sytuacja (critical conditions)
<item>3: KERN_ERR,     b³êdna sytuacja (error conditions)
<item>4: KERN_WARNING, ostrze¿enie (warning conditions)
<item>5: KERN_NOTICE,  normalna, choæ wa¿na sytuacja (significant condition)
<item>6: KERN_INFO,    informacyjne
<item>7: KERN_DEBUG,   komunikaty odpluskwiania
</list>
<p>
Je¶li denerwuje Ciê jeden, specyficzny, bezu¿yteczny komunikat o b³êdzie,
zastanów siê nad zastosowaniem trywialnej ³atki na j±dro, takiej jak 
<file>shutup-abit-bp6</file> (dostêpna w <url id="&examples;"
name="podkatalogu z przyk³adami">).
<p>
Mo¿esz tak¿e zagl±dn±æ do <file>/etc/syslog.conf</file>; sprawd¼ czy
jakie¶ komunikaty nie s± wysy³ane do urz±dzenia powi±zanego z konsol±.
</sect1>

<sect1>Ustawienie w³a¶ciwego typu konsoli
<p>
Ekran konsoli w systemach uniksowych jest zazwyczaj obs³ugiwany 
przez bilioteki (n)curses.  Zapewniaj± one niezale¿ne od rodzaju 
terminala metody obs³ugi ekranu.
Sprawd¼: <manref name="ncurses" section="3X"> oraz
<manref name="terminfo" section="5">.
<p>
W systemie &debian;, jest nieco wstêpnie zdefiniowanych warto¶ci:
<example>
$ toe | less                  # wszystkie warto¶ci
$ toe /etc/terminfo/ | less   # warto¶ci daj±ce siê modyfikowaæ przez u¿ytkowników
</example>
Wyeksportuj Twój wybór jako zmienn± ¶rodowiskow± <tt>TERM</tt>.
<p>
Je¿eli warto¶æ terminfo dla xterm nie dzia³a w³a¶ciwie z xtermami 
nie pochodz±cymi z Debiana, zmieñ rodzaj terminala z &ldquor;xterm&rdquor; na jedn±
z wersji posiadaj±cych ograniczenia funkcjonalno¶ci, jak np.&ldquor;xterm-r6&rdquor; 
podczas zdalnego logowania do Debiana.
Zobacz tak¿e: <file>&f-libncurse;</file>.
&ldquor;dumb&rdquor; jest najni¿sz± wspóln± definicj± dla terminfo.
</sect1>

<sect1>Przywracanie konsoli do rozs±dnego stanu
<p>
Je¶li ekran stanie siê nieczytelny po wykonaniu polecenia
<tt>cat <var>jaki¶-plik-binarny</var></tt> 
(mo¿esz nie widzieæ poleceñ, jakie wpisujesz), zastosuj:
<example>
$ reset
</example>
</sect1>

<sect1>Konwersja plików ze stylu dosowego na uniksowy
<p>
Przekszta³canie dosowego pliku tekstowego (koniec-linii = <tt>^M^J</tt>) 
na format uniksowy (koniec-linii = <tt>^J</tt>):
<example>
# apt-get install sysutils
$ dos2unix <var>plik_dosowy</var>
</example>
</sect1>

<sect1>Zastêpowanie przy pomocy wyra¿eñ regularnych
<p>
Zamiana wszystkich wyst±pieñ <var>WYRA¯ENIE_POCZ¡TKOWE</var> na 
<var>WYRA¯ENIE_KOÑCOWE</var> 
we wszystkich plikach <var>PLIKI</var> ...:
<example>
$ perl -i -p -e 's/<var>WYRA¯ENIE_POCZ¡TKOWE</var>/<var>WYRA¯ENIE_KOÑCOWE</var>/g;' <var>PLIKI</var> ...
</example>
<tt>-i</tt> s³u¿y do &ldquor;in-place editing&rdquor;, <tt>-p</tt> wymusza przetwarzanie 
w pêtli, ka¿dy plik z podanych jako <var>PLIKI</var> ...  Je¶li zastêpowanie 
jest z³o¿one, mo¿esz zabezpieczyæ siê przed b³êdami u¿ywaj±c parametru 
<tt>-i.bak</tt> zamiast <tt>-i</tt>; to zachowa oryginalne pliki dodaj±c do ich 
nazwy <tt>.bak</tt>.
</sect1>

<sect1>Edytowanie plików przez skrypt
<p>
Poni¿szy skrypt usunie linie 5&ndash;10 oraz 16&ndash;20.
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
Polecenia <prgn>ed</prgn> s± takie same jak polecenia <prgn>vi</prgn>
w trybie wydawania poleceñ. Modyfikacja pliku od ty³u u³atwia jego edycjê
w skryptach.
</sect1>

<sect1>Odnajdywanie ró¿nic i scalanie uaktualnieñ w pliku ¼ród³owym
<p>
Poni¿sza procedura odnajduje ró¿nice pomiêdzy dwoma plikami i 
tworzy zunifikowane pliki &ldquor;diff&rdquor;: <var>plik.³atka0</var> lub
<var>plik.³atka1</var>:
<example>
$ diff -u <var>plik.stary</var> <var>plik.nowy1</var> &gt; <var>plik.³atka0</var>
$ diff -u <var>stary/plik</var> <var>nowy1/plik</var> &gt; <var>plik.³atka1</var></example>
Pliki &ldquor;diff&rdquor;, nazywane tak¿e ³atkami (patch) s± u¿ywane do przesy³ania
uaktualnieñ kodów ¼ród³owych programów. Po odebraniu takiego pliku, 
mo¿na go zaaplikowaæ na posiadany stary plik u¿ywaj±c poleceñ:
<example>
$ patch -p0 <var>plik.stary</var> &lt; <var>plik.³atka0</var>
$ patch -p1 <var>plik.stary</var> &lt; <var>plik.³atka1</var>
</example>
Je¶li masz wszystkie trzy wersje kodów ¼ród³owych, mo¿esz je 
po³±czyæ u¿ywaj±c narzêdzia <prgn>diff3</prgn>:
<example>
$ diff3 -m <var>plik.mój</var> <var>plik.stary</var> <var>plik.twój</var> &gt; <var>plik</var></example>
</sect1>

<sect1>Przekszta³canie du¿ego pliku w kilka ma³ych
<p>
<example>
$ split -b 650m <var>plik</var>   # podzia³ pliku na kawa³ki 650 MB 
$ cat x* &gt; <var>du¿yplik</var>     # ³±czenie plików w jeden du¿y
</example>
</sect1>

<sect1>Wy³uskiwanie danych z tekstowych tabel
<p>
Rozpatrzymy plik nazwany <file>DPL</file> 
w którym zachowywane s± wszystkie nazwiska przywódców projektu 
&debian; oraz daty rozpoczêcia ich dzia³alno¶ci. Dane oddzielone s±
przerwami.
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   January 1998
Wichert Akkerman  January 1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr March   2003
</example>
Najczêsciej u¿ywanym narzêdziem do takich zadañ jest Awk.
<example>
$ awk '{ print $3 }' &lt;DPL                   # Miesi±ce
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' &lt;DPL          # przywódca zwany Ian
Ian     Murdock   August  1993
Ian     Jackson   January 1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # Kiedy rozpocz±³ Perens 
April 1996
</example>

<p>
Pow³oka taka jak Bash równie¿ mo¿e zostaæ u¿yta do obrabiania tego typu
plików:
<example>
$ while read first last month year; do 
    echo $month
  done &lt;DPL
... taki sam efekt jak w pierwszym przyk³adzie z Awk
</example>
W tym przypadku wbudowane polecenie <prgn>read</prgn> u¿ywa znaków z $IFS
(wewnêtrzne separatory pól) by podzieliæ linie na s³owa.
<p>
Je¶li zmienisz IFS na ":" bêdziesz móg³ bezproblemowo z pow³ok± obrabiaæ plik 
<file>/etc/passwd</file>:
<example>
$ oldIFS="$IFS"   # zapisuje star± warto¶æ
$ IFS=":"
$ while read user password uid gid rest_of_line; do
    if [ "$user" = "osamu" ]; then
      echo "$user's ID is $uid"
    fi
  done < /etc/passwd
osamu's ID is 1001
$ IFS="$oldIFS"   # przywraca star± warto¶æ
</example>
(Je¶li chcesz u¿yæ Awk do tego samego skorzystaj z <tt>FS=":"</tt> by
ustawiæ separator pól.)
<p>
IFS jest równie¿ u¿ywane przez pow³okê do rozdzielania wyników dope³niania 
parametrów, podmian poleceñ i dope³niania arytmetycznego. To nie dotyczy
wyrazów w podwójnym lub pojedynczym cudzys³owiu. Domy¶ln± warto¶ci± IFS
jest kombinacja nastêpuj±cych znaków
&lt;spacja&gt;, &lt;tabulator&gt; i &lt;znak nowej linii&gt;.
<p>
Uwa¿aj u¿ywaj±c trików z IFS w pow³oce.
Dziwne rzeczy siê mog± dziaæ kiedy pow³oka zinterpretuje czê¶æ skryptu jako
swoje <strong>wej¶cie</strong>.
<example>
$ IFS=":,"                        # u¿yj ":" i "," jako IFS
$ echo IFS=$IFS,   IFS="$IFS"     # echo jest wbudowane w Basha 
IFS=  , IFS=:,
$ date -R                         # zwyk³e wyj¶cie polecenia
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # pod-pow³oka --&gt; wej¶cie do g³ównej pow³oki
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # przywrócenie domy¶lnej warto¶ci IFS
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>


</sect1>

<sect1>Kawa³ki kodu przekierowywania poleceñ
<p>
Poni¿sze skrypty wspólnie tworz± piêkn± ca³o¶æ je¶li s± po³±czone potokiem
(ang. pipe).
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # znajduje wszystkie pliki w /usr z wy³±czeniem pewnych
plików
xargs -n 1 <var>polecenie</var>  # uruchamia polecenia dla ka¿dego z elementu ze standardowego wej¶cia
xargs -n 1 echo |    # dzieli elementy oddzielone bia³ymi znakami na linie
xargs echo      |    # ³±czy wszystkie linie w jedn±
grep -e <var>wzorzec</var>|     # wyci±ga linie zawieraj±ce dany <var>wzorzec</var>
cut -d: -f3 -|       # wyci±ga trzecie pole oddzielone znakiem : (np. plik passwd)
awk '{ print $3 }' | # wyci±ga trzecie pole oddzielone bia³ymi znakami
awk -F'\t' '{ print $3 }' |        # wyci±ga trzecie pole oddzielone tabulatorem
col -bx |            # usuwa backspace i rozwija tabulacje na spacje
expand -|            # rozwija tabulacje
sort -u|             # sortuje i usuwa powtórzenia

tr '\n' ' '|         # usuwa znaki LF (wysuñ wiersz)
tr '\r' &apos;&apos;|          # usuwa znaki CR (powrót karetki)
tr 'A-Z' 'a-z'|      # przekszta³ca wielkie litery w ma³e
sed 's/^/# /'|       # zmienia ka¿d± liniê na komentarz (zaczyna siê od #)
sed 's/\<var>.ext</var>//g'|     # usuwa <var>.ext</var>
sed  -n -e 2p|       # wypisuje drug± liniê
head -n 2 -|         # wypiuje pierwsze 2 linie
tail -n 2 -|         # wypiuje ostatnie 2 linie
</example>
</sect1>

<sect1>Skrypty dzia³aj±ce w pêtli na ka¿dym pliku
<p>
Poni¿sze sposoby pêtli dzia³aj±cej na plikach z rozszerzeniem 
<tt>*.<var>ext</var></tt> zapewniaj± prawid³ow± obs³ugê dziwnych nazw
plików na przyk³ad ze spacjami:
<list>
<item>Pêtla w pow³oce:
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>command</var> "$<var>x</var>"
  fi
done
</example>
<item><prgn>find</prgn> w kombinacji z <prgn>xargs</prgn>:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>command</var>
</example>
<item><prgn>find</prgn> z opcj± <tt>-exec</tt> w poleceniu:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>command</var> '{}' \;
</example>
<item><prgn>find</prgn> z opcj± <tt>-exec</tt> i krótkim skryptem pow³oki:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>command</var> '{}' && echo 'successful'" \;
</example>
</list>
</sect1>


<sect1>Szaleñstwo krótkich skryptów Perla
<p>
Kazdy skprypt Awk mo¿e byæ napisany w Perlu. Przyk³adowo:
<example>
awk '($2=="1957") { print $3 }' |
</example>
moze byæ zapisany jak poni¿ej:
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
Teraz usuwamy wszystkie bia³e znaki oraz wykorzystujemy przewagê 
automatycznej konwersji pomiêdzy liczbami a ci±gami tekstowymi:
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
Zobacz te¿ do: <manref name="perlrun" section="1">.
Wiele równie, lub bardziej szalonych skrytów Perla znajdziesz tutaj: 
<url id="&perlgolf;">.
</sect1>

<sect1>Pobieranie tekstu oraz archiwów list dyskusyjnych ze stron WWW
<p>
Poni¿sze polecenia zczytaj± stronê WWW do pliku tekstowego.
Przydatne na przyk³ad do skopiowania konfiguracji ze strony WWW.
<example>
$ lynx -dump http://<var>www.odleg³a-strona.pl/plik.html</var> &gt;<var>plik.txt</var></example>
<prgn>links</prgn> i <prgn>w3m</prgn> mog± byæ równie¿ analogicznie 
u¿yte, z dok³adno¶ci± do niewielkich ró¿nic.
<p>
Je¶li to jest archiwum listy dyskusyjnej, u¿yj <prgn>munpack</prgn> 
aby uzyskaæ zawarto¶æ mime.</sect1>

<sect1>Estetyczne wydruki stron WWW
<p>
Poni¿sze polecenia wydrukuj± stronê WWW do drukarki/pliku PostScript:
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Zobacz tak¿e <ref id="lprlpd"> oraz sprawd¼ pakiety: <prgn>a2ps</prgn> 
oraz <prgn>mpage</prgn> s³u¿±ce do tworzenia PostScriptu.
</sect1>

<sect1>Estetyczne wydruki stron podrêcznika systemowego
<p>
Poni¿sze polecenia wydrukuj± stronê podrêcznika systemowego do 
drukarki/pliku PostScript:
<example>
$ man -Tps <var>jaka¶-strona-podrêcznika</var> | lpr
$ man -Tps <var>jaka¶-strona-podrêcznika</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>£±czenie dwóch plików w formacie PostScript lub PDF 
<p>
Mo¿esz po³±czyæ pliki w formacie PostScript lub PDF:
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var><var>foo2.pdf</var>
</example>
</sect1>

<sect1>Czas trwania
<p>
Wy¶wietlanie czasu trwania danego polecenia.
<example>
# time <var>jakie¶-polecenie</var> &gt;/dev/null
real    0m0.035s       # czas, jaki up³yn±³ na zegarku ¶ciennym (czas rzeczywisty)
user    0m0.000s       # czas spêdzony w trybie u¿ytkownika
sys     0m0.020s       # czas spêdzony w trybie j±dra
</example>
</sect1>

<sect1>Polecenie <prgn>nice</prgn>
<p>
U¿yj polecenia <prgn>nice</prgn> (z pakietu GNU 
<package>shellutils</package>) by ustawiæ podczas startu &ldquor;przyjazno¶æ&rdquor; 
programu w stosunku do innych. <prgn>renice</prgn>
(z <package>bsdutils</package>) lub <prgn>top</prgn> mo¿e zmieniæ t± warto¶æ.
Warto¶æ równa 19 oznacza najni¿szy priorytet procesu. Warto¶æ ujemna jest
uwa¿ana za &ldquor;nieprzyjazn±&rdquor; - warto¶æ -20 oznacza wysoki priorytet procesu.
Tylko superu¿ytkownik mo¿e ustawiaæ ujemne warto¶ci nice.
<example>
# nice  -19 <var>top</var> # bardzo &ldquor;mi³y&rdquor; dla innych procesów
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> #bardzo szybki</example>
Czasami ekstremalne warto¶ci nice sprawiaj± wiêcej k³opotu ni¿ po¿ytku, dlatego
u¿ywaj tego polecenia bardzo uwa¿nie.
</sect1>

<sect1 id="cronjob">Harmonogram dzia³añ (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
U¿yj pakietu <prgn>cron</prgn> lub <prgn>at</prgn> aby zaplanowaæ zadania
w systemie GNU/Linux.
Zobacz: <manref name="at" section="1">, <manref name="crontab" section="5">,
<manref name="crontab" section="8">.
<p>
Wykonaj polecenie <tt>crontab -e</tt> edytuj±ce zawarto¶æ
spisu zadañ (&ldquor;crontab&rdquor;). Przyk³adowa zawarto¶æ takiego pliku:
<example>
# u¿yj /bin/sh do wykonywania poleceñ, niezale¿nie od zapisu w /etc/passwd 
SHELL=/bin/sh
# prze¶lij standardowe wyj¶cie poleceñ do `pawel', niezale¿nie od tego, czyj zestaw poleceñ jest wykonywany
MAILTO=pawel
# Min Godzina DzieñMiesi±ca Miesi±c DzieñTygodnia polecenie 
#(DzieñTygodnia i DzieñMiesi±ca s± po³±czone spójnikiem LUB)
# wykonaj o 00:05 ka¿dego dnia
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# wykonaj o 14:15 pierwszego dnia ka¿dego miesi±ca -- wynik wysylany do Paw³a
15 14 1  * *   $HOME/bin/monthly
# wykonaj o 22:00 ka¿dego dnia tygodnia (1-5), wkurzamy Joe. 
# &percnt; to nowa linia, ostatni &percnt; to cc:
0 22 *   * 1-5 mail -s "Jest 10 wieczór" joe&percnt;Joe,&percnt;&percnt;Czy wiesz, gdzie s± twoje dzieciaki?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "wykonane 23 minuty po godzinie 0, 2, 4 ..., dnia 1 lutego"
5  4 *   * sun echo "wykonane 04:05 ka¿dej niedzieli"
# Wykonaj o 03:40 w pierwszy poniedzia³ek miesi±ca
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>

Uruchom polecenie <prgn>at</prgn> aby wykonaæ jednorazowe zadanie:
<example>
$ echo '<var>polecenie -argumenty</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Zmiana konsoli przy pomocy <prgn>screen</prgn>a
<p>
Program <prgn>screen</prgn> umo¿liwia uruchomienie 
<strong>wielu</strong> pozornych terminali, ka¿dy ze swoj±
w³asn± pow³ok±, <strong>na pojedynczym</strong> fizycznym terminalu 
lub emulatorze terminala. Nawet je¶li u¿ywasz wirtualnych konsoli 
Linuksa lub wielu x-terminali, program <prgn>screen</prgn> jest 
wart zainteresowania z uwagi na bogaty zbiór mo¿liwo¶ci, takich jak np.:
<list compact>
<item>przewijany dostêp do historii poleceñ,
<item>kopiowanie i wklejanie,
<item>zapisywanie stanu wyj¶cia (logowanie),
<item>digraph entry oraz
<item>mo¿liwo¶æ <strong>od³±czenia</strong> sesji ca³ego 
programu <prgn>screen</prgn> od terminala i ponowne jej przy³±czenie 
pó¼niej. Pozwala to na zdalne uruchomienie czasoch³onnego zadania, 
roz³aczenie i powrócenie do niego, gdy ju¿ siê wykona. 
</list>

<sect2>Scenariusz zdalnego dostêpu
<p>
Je¶li czêsto pod³±czasz siê do systemu ze zdalnego terminala lub
korzystaj±c z programu emuluj±cego terminal w trybie VT100,
<prgn>screen</prgn> uczyni Twoje ¿ycie ³atwiejszym :-) dziêki 
opcji <strong>detach</strong>.<p>
<enumlist compact>
<item>jeste¶ po³±czony przez ³±cze wdzwaniane i masz uruchomiony 
program <prgn>screen</prgn> ze spor± ilo¶ci± sesji zawieraj±cych
ró¿ne programy
<item>nagle musisz porzuciæ terminal, ale nie chcesz straciæ swojej 
dotychczasowej pracy po roz³±czeniu 
<item>wpisujesz wiêc <tt>Ctrl+A d</tt> aby <strong>od³±czyæ</strong> 
sesje od terminala, a nastêpnie przerywasz pod³±czenie do systemu. 
(lub szybciej: wpisuj±c <tt>Ctrl+A DD</tt> zmuszaj±c program
<prgn>screen</prgn> jednocze¶nie do od³±czenia sesji i zakoñczenia 
po³±czenia)
<item>gdy ponownie przy³±czysz siê do systemu, wpisz polecenie
<tt>screen -r</tt>, a <prgn>screen</prgn> magicznie 
<strong>przy³±czy siê ponownie</strong> i wszystkie sesje zostan± 
przywrócone.
</enumlist>

<sect2>Podstawowe polecenia <prgn>screen</prgn>a
<p>
Gdy uruchomisz program <prgn>screen</prgn>, wszystkie naciskane klawisze
s± wysy³ane do aktualnej sesji, za wyj±tkiem kombinacji wywo³uj±cej system 
poleceñ <prgn>screen</prgn>a. Domy¶lnie jest to <tt>Ctrl+A</tt>. Wszystkie
polecenia programu <prgn>screen</prgn> s± wpisywane przy u¿yciu <tt>Ctrl+A</tt>
a nastêpnie pojedynczych klawiszy.
U¿yteczne polecenia:
<example>
^A ?     pomoc do programu 
^A c     utwórz now± sesjê i prze³±cz siê do niej
^A n     nastêpna sesja
^A p     poprzednia sesja
^A <var>0</var>     id¼ do sesji numer <var>0</var>
^A w     wy¶wietl listê sesji
^A a     Wy¶lij Ctrl+A do aktualnej sesji (normalne Ctrl+A jest przechwytywane)
^A h     zapisz kopiê aktualnej sesji do pliku
^A H     rozpocznij/zakoñcz przechwytywanie aktualnej sesji do pliku
^A ^X    zabezpiecz terminal (ochrona has³em)
^A d     od³±cz sesje od terminala 
^A DD    od³±cz sesje od terminala, a terminal od systemu 
</example>
To tylko niewielki podzbiór poleceñ programu <prgn>screen</prgn>.
Je¶li istnieje co¶, co chcia³(a)by¶ wykonaæ przy u¿yciu <prgn>screen</prgn>a 
zapewne jest to mo¿liwe! 
<p>
Zobacz tak¿e: <manref name="screen" section="1">.

<sect2>Backspace i/lub Ctrl+H w sesji <prgn>screen</prgn>a
<p>
Je¶li zauwa¿ysz, ¿e backspace i/lib Ctrl+H nie dzia³aj± dobrze
podczas dzia³ania programu <prgn>screen</prgn>, 
wyedytuj plik <file>/etc/screenrc</file>,
znajd¼ liniê:
<example compact>
bindkey -k kb stuff "\177"
</example>
i zakomentuj j± (np. dodaj &ldquor;#&rdquor; jako pierwszy znak tej linii).

<sect2>Zastêpca <prgn>screen</prgn>a w X Window System
<p>
Sprawd¼ <prgn>xmove</prgn>.  Poczytaj <manref name="xmove" section="1">.

</sect1>

<sect1>Podstawy testowania sieci
<p>
Zainstaluj pakiety:
<package>netkit-ping</package>,
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (dla j±dra 2.2),
<package>iptables</package> (dla j±dra 2.4), oraz
<package>net-tools</package> i wykonaj:
<example>
$ ping <var>www.google.com</var>       # sprawd¼ po³±czenie z www.google.com
$ traceroute <var>www.google.com</var> # sprawd¼ trasê pakietów
$ ifconfig                  # sprawd¼ ustawienia komputera
$ route -n                  # sprawd¼ ustawienia tras pakietów
$ dig <var>[@serwer-dns.pl] host.dom [{a|mx|any}]</var> |less
      # sprawd¼ wpisy DNS dla <var>host.dom</var> zapisane w <var>dns-server.com</var>
      # typy rekorów to: <var>{a|mx|dowolne}</var>
$ ipchains  -L -n |less     # sprawd¼ filtry pakietów (j±dro 2.2)
$ iptables -L -n |less      # check packet filter (j±dro 2.4)
$ netstat -a                # znajd¼ wszystkie otwarte porty
$ netstat -l --inet         # znajd¼ nas³uchuj±ce porty
$ netstat -ln --tcp         # znajd¼ nas³uchuj±ce porty TCP (numerycznie)
</example>
</sect1>

<sect1>Wypychanie przesy³ek z lokalnej kolejki
<p>
Aby wypchn±æ listy z lokalnej kolejki, mo¿esz u¿yæ:
<example>
# exim -q    # wypchnij czekaj±ce listy
# exim -qf   # wypchnij wszystkie listy
# exim -qff  # wypchnij nawet zamro¿one przesy³ki
</example>
<tt>-qff</tt> mo¿e byæ u¿yteczn± opcj± w skrypcie
<file>/etc/ppp/ip-up.d/exim</file>.
</sect1>

<sect1>Usuwanie zamro¿onych przesy³ek z lokalnej kolejki
<p>
Aby usun±æ zamro¿one przesy³ki z lokalnej kolejki, 
wysy³aj±c jednocze¶nie komunikat o b³êdzie, wykonaj:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Ponownie dostarczanie zawarto¶ci mboksa
<p>
Je¶li Twój katalog domowy zosta³ zape³niony i procmailowi nie uda³o siê
dokonaæ swego dzie³a, musisz rêcznie przenie¶æ pocztê do posortowanych
skrzynek w Twoim katalogu domowym z pliku
<file>/var/mail/<var>nazwa_u¿ytkownika</var></file>. Po zwolnieniu miejsca
w katalogu domowym wykonaj poni¿sze czynno¶ci:
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>nazwa_u¿ytkownika</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>Usuwanie zawarto¶ci plików
<p>
W celu usuniêcia zawarto¶ci plików takich jak dzienniki systemowe, 
nie u¿ywaj polecenia <tt>rm</tt> do usuniêcia pliku i nie twórz pustego
od nowa, poniewa¿ pomiêdzy tymi operacjami, jaka¶ czê¶æ systemu mo¿e chcieæ 
dokonaæ zapisków do takiego pliku. Poni¿ej pokazano sposób na bezpieczne 
usuwanie zawarto¶ci pliku:
<example>
$ :&gt;<var>plik-do-wyczyszczenia</var>
</example>
</sect1>

<sect1>Sztuczne pliki
<p>
Poni¿sze polecenia utworz± sztuczne lub puste pliki:
<example>
$ dd if=/dev/zero    of=<var>nazwa_pliku</var> bs=1k count=5 # 5KB samych zer
$ dd if=/dev/urandom of=<var>nazwa_pliku</var> bs=1m count=7 # 7MB losowej zawarto¶ci
$ touch <var>nazwa_pliku</var> #  pusty plik, je¶li nie istnieje
</example>
Przyk³adowo, poni¿sze polecenie, wykonane z pow³oki dyskietki startowej 
systemu &debian; usunie ca³kowicie zawarto¶æ dysku twardego 
<file>/dev/hda</file>:
<example>
# dd if=/dev/urandom of=/dev/hda ; dd if=/dev/zero of=/dev/hda
</example>
</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
Program <prgn>chroot</prgn>, <manref name="chroot" section="8">, 
pozwala na uruchomienie ró¿nych instancji ¶rodowiska GNU/Linux 
na jednym systemie bez ponownego uruchomiania go.
<p>
Mo¿na te¿ uruchamiaæ zasobo¿erne programy takie jak <prgn>apt-get</prgn>
czy <prgn>dselect</prgn> w ¶rodowisku chroot na szybkim komputerze
maj±c zamontowane na wolniejszym komputerze zasób NFS na prawach r/w, który
to zasób jest g³ównym punktem montowania na wolniejszym komputerze.

<sect2 id="chroot-debian">Uruchamianie innej dystrybucji Debiana przy u¿yciu
<prgn>chroot</prgn><p>
Debianowe ¶rodowisko chroot mo¿na ³atwo stworzyæ przy pomocy
<prgn>debootstrap</prgn> w Woodym. Na przyk³ad je¶li chcesz utworzyæ
chroota z Sidem w katalogu <var>/sid-root</var> maj±c szybki dostêp
do Internetu:
<example>
main # cd / ; mkdir <var>/sid-root</var>
main # debootstrap woody <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... obserwuj jak program ¶ci±ga ca³± podstawê systemu
main # echo "proc-sid <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount proc-sid <var>/sid-root</var>/proc -t proc
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # apt-setup # ustawianie /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # wska¼ ¼ród³a na unstable
chroot # dselect  # mo¿esz te¿ u¿yæ aptitude, zainstaluj mc i vima :-)
</example>
<p>
W tej chwili powiniene¶ posiadaæ w pe³ni funkcjonalny system &debian;, w którym
mo¿esz mieszaæ bez strachu, ¿e co¶ popsujesz w Twojej g³ównej dystrybucji.
<p>
Ta sztuczka z <prgn>debootstrap</prgn> mo¿e te¿ byæ u¿yta do instalcji
Debiana bez u¿ycia dysku instalacyjnego Debiana lecz przy wykorzystaniu
innej dystrybucji GNU/Linux. Zobacz te¿ <url id="&setup-chroot;">.

<sect2 id="chroot-console">Ustawianie loginu dla <prgn>chroot</prgn>
<p>
Wpisanie <tt>chroot <var>/sid-root</var> /bin/bash</tt> jest proste, ale
zostawia to wiele zmiennych ¶rodowiskowych walaj±cych siê po pamiêci, a które
nie s± potrzebne lub nawet s± niepo¿±dane. Du¿o lepszym sposobem jest
uruchomienie kolejnego procesu login na oddzielnym terminalu wirtualnym,
z którego mo¿esz siê bezpo¶rednio logowaæ do systemu chroot.
<p>
Poniewa¿ domy¶lnie w systemie &debian; terminale <tt>tty1</tt> do <tt>tty6</tt>
s± przeznaczone na konsole Linuksa, a <tt>tty7</tt> na sesjê
X Window System, u¿yjemy konsoli <tt>tty8</tt> jako konsoi chroot. Po
utworzeniu ¶rodowiska chroot tak jak to zosta³o opisane w <ref
id="chroot-debian">, wpisz bêd±c rootem w g³ównym systemie:
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8"  >> /etc/inittab
main # init q    # prze³adowanie init
</example>

<sect2 id="chroot-x">Ustawianie Xów do dzia³ania w <prgn>chroot</prgn>
<p>
Chcesz bezpiecznie uruchamiaæ najnowesze Xy i GNOME w ¶rodowisku chroot?
Jest to mo¿liwe! Poni¿szy przyk³ad uruchomi GDM na wirtualnym terminalu
<tt>vt9</tt>.
<p>
Najpierw zainstaluj system chroot wg. opisu w <ref id="chroot-debian">.
Z g³ównego systemu skopiuj kluczowe pliki konfiguracyjne do systemu chroot.
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # lub u¿yj konsoli chroot
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # wykonaj s/vt7/vt9/ w sekcji [servers]
chroot # /etc/init.d/gdm start
</example>
Plik <file>/etc/gdm/gdm.conf</file> zosta³ tak zmieniony, by pierwsz± konsol± 
by³a konsola <tt>vt9</tt>, a nie <tt>vt7</tt>.
<p>
Teraz mo¿esz bez problemu prze³±czaæ siê miêdzy funkcjonalnymi ¶rodowiskami
X systemu g³ównego i systemu chroot przez proste prze³±czanie wirtualnych
terminali Linuksa, np. za pomoc± kombinacji klawiszy Ctrl-Alt-F7
i Ctrl-Alt-F9. Mi³ej zabawy!
<p>
[FIXME] Dodaj komentarz i dowi±zanie do skryptu init z chrootowanego gdm.

<sect2 id="chroot-dist">Uruchamianie innych dystrybucji w ¶rodowisku <prgn>chroot</prgn>
<p>
¦rodowisko chroot dla innej dystrybucji mo¿na utworzyæ ca³kiem prosto.
Instalujesz system na oddzielnej partycji korzystaj±c z instalatora danej
dystrybucji, i wykonujesz poni¿sze polecenia (przy za³o¿eniu, ¿e g³ówna
partycja innej dystrybucji to <file><var>/dev/hda9</var></file>):
<example>
main # cd / ; mkdir <var>/other-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/other-dist</var>
main # chroot <var>/other-dist</var> /bin/bash
</example>
Nastêpnie postêpuj tak jak opisano to w <ref id="chroot-debian">, <ref
id="chroot-console"> oraz <ref id="chroot-x">.

<sect2 id="chroot-build">Budowanie pakietu w ¶rodowisku <prgn>chroot</prgn>
<p>
<package>pbuilder</package> jest bardziej wyspecjalizowanym narzêdziem
przygotowuj±cycm ¶rodowisko chroot i buduj±cym w nim pakiet. Jest to idealny
system sprawdzaj±cy, czy zale¿no¶ci budowania s± poprawne oraz do upewnienia
siê, ¿e niepotrzebne i niepoprawne zale¿no¶ci budowania nie znajd± siê
w pakiecie wynikowym.

</sect1>

<sect1>Jak weryfikowaæ dowi±zania (hardlink)
<p>
Mo¿esz sprawdziæ czy dwa pliki s± tym samym plikiem z dwoma 
dowi±zaniami:
<example>
$ ls -li <var>plik_1</var> <var>plik_2</var>
</example>

<sect1>Montowanie obrazów systemów plików
<p>
Je¿eli <file><var>plik.img</var></file> zawiera obraz zawarto¶ci
twardego dysku, za¶ oryginalny twardy dysk ma konfiguracjê daj±c±:
<var>xxxx</var> = (bajtów/sektor) * (sektorów/cylinder), wtedy mo¿esz 
taki obraz zamontowaæ do katalogu <file>/mnt</file> poleceniem:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>plik.img</var> /mnt
</example>
Zauwa¿, ¿e wiêkszo¶æ twardych dysków ma 512 bajtów/sektor.

<sect1>Samba
<p>
Przyk³adowy dostêp do plików serwowanych przez Windows:

<list compact>
<item> montowanie zasobów Windows do Linuksa
     <example>
     # mount -t smbfs -o <var>username=moja_nazwa,uid=mój_uid,gid=mój_gid</var> \
             <var>//serwer/dzielony_zasób /mnt/smb</var>  
     </example>
<item> inny sposób na montowanie zasobów Windows do Linuksa:
     <example>
     # smbmount <var>//serwer/dzielony_zasób /mnt/smb</var> \
             -o "<var>username=moja_nazwa,uid=mój_uid,gid=mój_gid</var>"
     </example>
<item> lista udostêpnianych zasobów na wskazanym serwerze
     <example>
     # smbclient -L <var>192.168.1.2</var> 
     </example>
</list>

<p>
Otoczenie sieciowe Samby mo¿e byæ sprawdzane spod GNU/Linuksa:
<example>
# smbclient -N -L <var>adres_ip_twojego_komputera</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>Narzêdzia do obs³ugi obcych systemów plików
<p>
Obs³uga wielu obcych systemów plików jest wspierana obecnie 
przez linuksowe j±dro, a wiêc mog± byæ one dostêpne w prosty 
sposób, poprzez zamontowanie urz±dzeñ je zawieraj±cych.
Dla niektórych systemów plików s± dostêpne tak¿e specjalne narzêdzia
umo¿liwiaj±ce dostêp do nich bez montowania urz±dzeñ.
S± one dostêpne jako programy pracuj±ce w przestrzeni u¿ytkownika, a zatem
wsparcie ze strony j±dra nie jest potrzebne.
<list compact>
<item><package>mtools</package>: system plików MSDOS (MS-DOS, Windows)
<item><package>cpmtools</package>: system plików CP-M
<item><package>hfsutils</package>: system plików HFS (native Macintosh)
<item><package>hfsplus</package>: system plików HFS+ (modern Macintosh)
</list>
Do tworzenia i weryfikacji systemu plików MS-DOS FAT
u¿yteczne mo¿e byæ narzêdzie: <package>dosfstools</package>.
</sect1>

</sect>

</chapt>
