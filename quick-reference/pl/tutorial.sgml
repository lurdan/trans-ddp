<!-- CVS revision of this document "$Revision: 1.9 $"  -->
<!-- CVS revision of original english document "1.38"  -->

<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<!-- INFORMACJE TYMCZASOWE -->
<!-- UWAGA, dokument w aktualizacji do wersji angielskiej 1.75! -->
<!-- T³umacz: rozie (Pawe³ 'Ró¿a' Ró¿añski) -->
<!-- Poni¿ej znaczniki dla korektora -->
<!-- T³um. zrobione 1.75 -->

<chapt id="tutorial">&debian; - samouczek

<p>
<!-- new content -->
Ten rozdzia³ przedstawia podstawowe informacje na temat systemu &debian;
i jest przeznaczony dla zupe³nie pocz±tkuj±cych u¿ytkowników (newbies).
Je¶li kiedykolwiek korzysta³e¶ ju¿ z systemu uniksopodobnego, prawdopodobnie
znasz wszystkie omówione w tym rozdziale informacje, ale mo¿esz przeczytaæ go
dla od¶wie¿enia swojej wiedzy.  

<sect id="first">Zaczynamy
<p>
<!-- new content -->
Po zainstalowaniu systemu &debian; na swoim komputerze, musisz nauczyæ siê
kilku rzeczy, aby go u¿ywaæ.  Pozwól, ¿e damy ci szybki kurs.

<sect1 id="login-root">Logowanie do pow³oki jako root
<p>
<!-- new content -->

Po uruchomieniu systemu (reboot), zostanie przedstawiony Tobie graficzny lub
tekstowy ekran logowania (zale¿nie od tego, który wybra³e¶ podczas wstêpnego
wyboru pakietów).  Dla uproszczenia, je¶li pojawi³ siê graficzny ekran
logowania, naci¶nij Ctrl-Alt-F1,
<footnote>
Klawisze lewy-Ctrl, lewy-Alt i klawisz F1 nale¿y przycisn±æ jednocze¶nie.  
</footnote>
aby uzyskaæ tekstowy ekran logowania.
<p>
Przypu¶æmy, ¿e nazwa twojego hosta to <tt><var>foo</var></tt>.  Wówczas twój
znak zachêty wygl±da tak:
<example>
<var>foo</var> login:
</example>
Wpisz <tt>root</tt>, naci¶nij klawisz Enter, a nastêpnie wpisz has³o, które
wybra³e¶ podczas procesu instalacji.  W systemie &debian;, zgodnie z tradycj±
systemów Unix, wielko¶æ liter w ha¶le ma znaczenie.  Po podaniu has³a system
uruchomi siê z informacj± powitaln± i przedstawi ci znak zachêty linii poleceñ
u¿ytkownika root, czekaj±c na wprowadzenie poleceñ.  
<footnote>
Zauwa¿, ¿e je¶li edytowa³e¶ informacjê powitaln± w <file>/etc/motd</file>,
poni¿sze komunikaty mog± wygl±daæ inaczej.  
</footnote>
<example>
<var>foo</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
Od tej chwili masz mo¿liwo¶æ administracji systemem z linii poleceñ
u¿ytkownika root.  Konto root jest tak¿e nazywane kontem superu¿ytkownika
(superuser) lub uprzywilejowanego u¿ytkownika.  Z tego konta masz mo¿liwo¶æ
robienia w systemie wszystkiego:
<list compact>
<item>odczytu, zapisu oraz usuwania ka¿dego pliku w systemie, niezale¿nie od
praw dostêpu do tego pliku
<item>zmiany w³a¶ciciela pliku oraz praw dostêpu do ka¿dego pliku w systemie
<item>ustawiania hase³ dla nieuprzywilejowanych u¿ytkowników w systemie
<item>logowania siê na dowolne konto w systemie bez znajomo¶ci jego has³a
</list>
<p>
Wspó³dzielenie dostêpu do konta roota przez posiadanie wspólnego has³a jest
fatalnym pomys³em.  U¿ycie programów takich jak <manref name="sudo"
section="8"> jest w³a¶ciwym sposobem na wspó³dzielenie przywilejów
administratora.
<p>
Zauwa¿ te¿, ¿e logowanie siê najpierw na konto nieuprzywilejowanego
u¿ytkownika, a dopiero z niego na konto z przywilejami administracyjnymi jest
uwa¿ane za dobry zwyczaj uniksowy.  Je¶li zajdzie potrzeba, u¿ywaj komend
<tt>sudo</tt>, <tt>super</tt> lub <tt>su -c</tt>, aby uzyskaæ ograniczone
przywileje roota. Zobacz <ref id="sudo">.
<footnote>
Muszê przyznaæ, ¿e kiedy¶ u¿ywa³em konta superu¿ytkownika
(konto root) czê¶ciej, ni¿ potrzebowa³em, g³ównie z powodu wygody i mojego
niechlujstwa.
</footnote>

<sect1 id="newbiefix">Tworzenie minimlnego ¶rodowiska dla pocz±tkuj±cego
<p>
<!-- new content -->
Uwa¿am, ¿e nauka systemu operacyjnego komputera przypomina nieco naukê jêzyka
obcego.  Mimo, ¿e ksi±¿ki s± pomocne, to nic nie zast±pi samodzielnej
praktyki. Musisz zacz±æ dzia³aæ samodzielnie, przy pomocy u³atwiaj±cych to
narzêdzi.  W zwi±zku z tym, dobrym pomys³em jest zainstalowanie kilku
dodatkowych pakietów, takich jak <package>mc</package>, <package>vim</package>,
<package>linx</package>, <package>doc-linux-text</package> oraz
<package>debian-policy</package>.
<footnote>
Dobrym pomys³em mo¿e byæ tak¿e instalacja <package>gpm</package>,
<package>emacs21</package> oraz <package>doc-linux-html</package>.  Zobacz
<ref id="gpm"> i <ref id="edit">.
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
</example>
Je¶li pakiety s± ju¿ zainstalowane w systemie, zostan± dodane.

<sect1 id="newuser"> Dodawanie konta u¿ytkownika
<p>
<!-- new content -->
Podczas instalacji, zwykle tworzy siê konto u¿ytkownika nieuprzywilejowanego,
s³u¿±ce do odbioru poczty elektronicznej wysy³anej do u¿ytkownika root.  
<footnote>
Zwykle nazywam te konto <tt>admin</tt>, ale mo¿e ono mieæ dowoln± nazwê.  
</footnote>
Poniewa¿ nie chcesz u¿ywaæ tego specjalnego konta do dzia³alno¶ci treningowej,
powieniene¶ utworzyæ kolejne konto u¿ytkownika.
<p>
Zak³adaj±c, ¿e chcesz, aby nazwa nowego u¿ytkownika by³a <tt><var>penguin</var></tt>, wpisanie:
<example>
root@<var>foo</var>:root# adduser <var>penguin</var>
... odpowiedz na wszystkie pytania
</example>
utworzy to konto.  

<footnote>
Mo¿esz zechcieæ dodaæ u¿ytkownika <tt><var>penguin</var></tt> do grupy
<tt>adm</tt>, aby umo¿liwiæ mu odczyt plików z logami w 
<file>/var/log/</file>.  Zobacz <manref name="passwd" section="5">, <manref
name="group" section="5">, <manref name="shadow" section="5">, <manref
name="group" section="5">, <manref name="vipw" section="8"> oraz <manref
name="vigr" section="8">.  W celu otrzymania informacji o oficjalnym znaczeniu
u¿ytkowników i grup, zobacz bie¿±c± wersjê dokumentu <url id="&f-users-and-groups;"
name="Users and Groups">.  
</footnote>
Zanim przejdziemy dalej, nauczmy siê paru rzeczy.

<sect1 id="sw-console">Prze³±czanie miêdzy konsolami wirtualnymi
<p>
<!-- modified old content -->
W domy¶lnej instalacji systemu &debian;, dostêpnych jest sze¶æ niezale¿nych
pseudo-terminali, czyli mo¿na u¿ywaæ konsoli tekstowej na sze¶ciu
prze³±czalnych terminalach VT-100.  Prze³±czaæ siê miêdzy nimi mo¿na przez
jednoczesne naci¶niêcie klawisza Lewy-Alt i jednego z klawiszy F1&ndash;F6.  
Ka¿dy pseudo-terminal pozwala na niezale¿ne logowanie siê na konto systemowe.  
¦rodowisko wielou¿ytkownikowe to wspania³a cecha Uniksa, po poznaniu której
ciê¿ko pracowaæ inaczej.  

<p>
<!-- new content -->
Je¶li przypadkowo naci¶niesz Alt-F7 podczas pracy na systemie z uruchomionym
¶rodowiskiem graficznym X Window i konsola prze³±czy siê w tryb graficzny,
naci¶niêcie Ctrl-Alt-F1 pozwoli na przywrócenie dostêpu do konsoli tekstowej.  
Po prostu spróbuj prze³±czaæ siê na ró¿ne konsole i powracaæ do wyj¶ciowej, aby
przywykn±æ do ¶rodowiska z wieloma pseudo-terminalami.  

<sect1 id="shutdown">Zamykanie systemu
<p>
<!-- heavily modified content -->
Tak jak ka¿dy wspó³czesny OS, który cache'uje operacje na plikach w pamiêci,
tak¿e &debian; wymaga w³a¶ciwej procedury zamykania systemu w celu zachowania
integralno¶ci plików, zanim zasilanie mo¿e zostaæ bezpiecznie wy³±czone.  
U¿ywaj nastêpuj±cej komendy z konta root do zamkniêcia systemu:
<example>
# shutdown -h now
</example>
Tak postêpuje siê w przypadku trybu wieluu¿ytkownikowego.  Je¶li pracujesz w
trybie pojedynczego u¿ytkownika (single-user), u¿ywaj komendy:
<example>
# poweroff -i -f
</example>
Mo¿esz tak¿e nacisn±æ Ctrl-Alt-Delete aby zamkn±æ system.  
<footnote>
Klawisz lewy-Ctrl, klawisz lewy-Alt oraz klawisz Delete naci¶niête jednocze¶nie
w konsoli.  Przy domy¶lnych ustawieniach powoduje to reboot systemu.  Aby
wykonywane by³o zamkniêcie systemu (<prgn>shutdown</prgn>) z opcj± <tt>-h</tt>,
nale¿y zmodyfikowaæ <file>/etc/inittab</file> zgodnie z wytycznymi z <ref id="post-inst">.
</footnote>
<p>
Zaczekaj na pojawienie siê napisu "System halted" i dopiero wówczas wy³±cz
zasilanie.  Je¶li funkcje APM lub ACPI zosta³y poprawnie w³±czone w BIOSie i
Linuksie, system wy³±czy siê samodzielnie.  Doczytaj szczegó³y w <ref id="apm">.  
<sect1 id="playtime">Do rzeczy
<p>
<!-- new content -->
Teraz jeste¶ gotów rozpocz±æ zabawê z systemem &debian;, przy czym dopóki
u¿ywasz nieuprzywilejowanego konta <tt><var>penguin</var></tt>, nie musisz obawiaæ
siê, ¿e co¶ zepsujesz w systemie.
<footnote>
Dzieje siê tak za spraw± faktu, ¿e system &debian; jest skonfigurowany z
w³a¶ciwymi prawami dostêpu od razu po domy¶lnej instalacji. Uniemo¿liwia to
nieuprzywijelowanym u¿ytkownikom uszkodzenie systemu.  Oczywi¶cie, nadal mog±
istnieæ dziury, które mog± zostaæ wykorzystane do dokonania nadu¿yæ, ale ci, którzy
maj± powody martwiæ siê o nie, nie powinni czytaæ tego dokumentu, a
<url id="&securing-debian-howto;" name="Securing Debian Manual">.
</footnote>
<p>
Zaloguj siê na konto <tt><var>penguin</var></tt>.   
Je¶li jeste¶ zalogowany jako root, naci¶nij Ctrl-D
<footnote>
Lewy klawisz Ctrl i klawisz d s± naciskane jednocze¶nie.  Nie ma potrzeby
naciskania klawisza Shift pomimo, ¿e te znaki kontrolne s± oznaczone w
odniesieniach wielk± liter±, jako "control D".  
</footnote>
aby zamkn±æ pow³okê root i powróciæ do znaku zachêty logowania.  Wprowad¼
nowoutworzon± nazwê u¿ytkownika <tt><var>penguin</var></tt> i przynale¿ne jej has³o.
<footnote>
Je¶li wpiszesz tutaj <tt>root</tt> zamiast <tt><var>penguin</var></tt> oraz
podasz przynale¿ne has³o u¿ytkownika <tt>root</tt>, ponownie otrzymasz dostêp
do konta <tt>root</tt>.  Ta procedura bêdzie konieczna do odzyskania dostêpu do
konta <tt>root</tt>.
</footnote>
Zostanie ci przedstawiony nastêpuj±cy znak zachêty.
<example>
<var>penguin</var>@<var>foo</var>:<var>penguin</var>$ 
</example>
<p>
Od teraz, poni¿szy przyk³adowy zapis bêdzie u¿ywany dla uproszczenia:
<list compact>
<item><tt>#</tt> : znak zachêty w koncie root
<item><tt>$</tt> : znak zachêty nieuprzywilejowanego u¿ytkownika
</list>
<p>
Teraz rozpoczniesz naukê systemu &debian;, najpierw sposobu prostego <ref
id="mc">, a nastêpnie sposobu w³a¶ciwego <ref id="unixlike">.  

<!-- /T³um. zrobione 1.75  -->

<sect id="mc">Midnight Commander (MC)
<p>
<!-- old content -->
Midnight Commander (MC) jest uniwersalnym narzêdziem konsoli Linuksa oraz
innych ¶rodowisk terminalowych. Umo¿liwia ono u¿ytkownikowi zdobycie 
do¶wiadczenia w wykonywania poleceñ systemowych przy u¿yciu menu, które s± 
porêczniejsze i ³atwiejsze w nauce od standardowych poleceñ systemu Unix.
<!-- New content -->
<p>
U¿yj tego narzêdzia by przejrzeæ strukturê systemu &debian;. To najlepszy sposóbnauki. Przy pomocy klwiszy kursorów oraz klasiwsza Enter zajrzyj w kilka
kluczowych miejsc:
<list compact>
<item><file>/etc</file> oraz podkatalogi.
<item><file>/var/log</file> oraz podkatalogi.
<item><file>/usr/share/doc</file> oraz podkatalogi.
<item><file>/sbin</file> and <file>/bin</file>
</list>

<sect1 id="mc-enhance">Konfigurowanie MC
<p>
<!-- modified old content -->
Je¶li chcesz aby przy opuszczaniu programu MC zmienia³ on aktualny katalog,
musisz zmodyfikowaæ plik <file>~/.bashrc</file> 
(lub <file>/etc/bash.bashrc</file>,
wywo³ywany z <file>.bashrc</file>), tak jak dok³adnie opisano to w jego 
podrêczniku, <manref name="mc" section="1">, przy opcji <tt>-P</tt>.
<footnote>
Je¶li nie rozumiesz o czym tutaj mówiê, mo¿esz tych zmian dokonaæ pó¼niej.
</footnote>

<sect1 id="mc-start">Uruchamianie MC
<p>
<!-- modified old content -->
<example>
$ mc
</example>
MC zajmuje siê wszystkimi operacjami na plikach, wykonywanymi z jego
menu, wymagaj±c minimalnego wysi³ku od u¿ytkownika. Naci¶nij po prostu klawisz
F1 aby uzyskaæ ekran pomocy. Mo¿esz poruszaæ siê po ca³ym programie u¿ywaj±c
klawiszy kursorów oraz klawiszy funkcyjnych.
<footnote>
W terminalach takich jak <prgn>kon</prgn> lub <prgn>kterm</prgn> wystêpuj± 
pewne problemy ze znakami graficznymi jêzyka japoñskiego.
Dodanie <tt>-a</tt> do wywo³ania MC mo¿e je rozwi±zaæ.
</footnote>

<sect1 id="mc-fm">Mened¿er plików w MC
<p>
<!-- old content -->
Domy¶lne ustawienie to dwa okna zawieraj±ce listy plików. Kolejnym u¿ytecznym
trybem jest ustawienie prawego okna w tryb &ldquor;informacja&rdquor;, co 
pozwala zobaczyæ
prawa dostêpu itp. Poni¿ej s± niektóre wa¿niejsze skróty klawiszowe.
Z u¿yciem uruchomionego demona <prgn>gpm</prgn> mo¿na te¿ u¿ywaæ myszy.
(Upewnij siê, ¿e naciskasz klawisz Shift w celu uzyskania normalnego dzia³ania
Kopiuj i Wklej w MC.)
<list compact>
<item>F1: Menu pomocy
<item>F3: Wewnêtrzny podgl±d pliku
<item>F4: Wewnêtrzny edytor
<item>F9: Uaktywnienie rozwijanego menu
<item>F10: Wyj¶cie z Midnight Commander
<item>Tab: Prze³±czanie pomiêdzy dwoma oknami
<item>Insert: Wybranie pliku do operacji na wielu plikach, np. dla kopiowania
<item><tt>Del</tt>: Usuniêcie pliku (B±d¼ ostro¿ny&mdash;ustaw MC w tryb bezpiecznego usuwania.)
<item>Klawisze kursora: Oczywiste
</list>

<sect1 id="mc-cl">Triki linii poleceñ w MC
<p>
<!-- old content -->
<list compact>
<item>Ka¿de polecenie <prgn>cd</prgn> zmienia katalog pokazany na wybranym 
ekranie.
<item>Ctrl-Enter lub Alt-Enter wkleja nazwê pliku do linii poleceñ.
U¿ywaj tego ³±cznie z poleceniem <prgn>cp</prgn> lub <prgn>mv</prgn>
z edycj± w pow³oce.
<item>Alt-Tab poka¿e dostêpne polecenia z linii poleceñ.
<item>Mo¿esz okre¶liæ katalogi startowe dla obu okien podaj±c je jako parametry przy
wywo³ywaniu MC; na przyk³ad <tt>mc /etc /root</tt>.
<item><tt>Esc</tt> + <var>klawisz numeryczny</var> == <tt>F<var>n</var></tt> 
(np.
  Esc + 1 = F1, itd.; Esc + 0
  = F10)
<item> Klawisz Esc == klawisz Alt (= Meta,
  M-); np. wpisz Esc + c by otrzymaæ Alt-C
<!-- control characters are referred with the upper case. -->
</list>

<sect1 id="mcedit">Edytor w MC
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
Wewnêtrzny edytor ma interesuj±cy schemat kopiuj-i-wklej. Naci¶niêcie
F3 oznacza pocz±tek wyboru, kolejne wci¶niêcie F3 oznacza
koniec wyboru i pod¶wietla zaznaczony obszar. Wtedy mo¿esz ruszaæ kursorem.
Gdy naci¶niesz F6, zaznaczony obszar zostanie przeniesiony do miejsca,
w którym jest kursor. Gdy przyci¶niesz F5, zaznaczony obszar zostanie
skopiowany i wklejony w miejsce, w którym jest kursor. F2 zapisuje
plik. F10 powoduje zakoñczenie MC. Klawisze kursora zwykle dzia³aj±
intuicyjnie.
<p>
Edytor mo¿e byæ wywo³any dla pliku:
<example>
$ mc -e plik_do_edycji
$ mcedit plik_do_edycji
</example>
<p>
Nie jest to edytor wielo-okienkowy, ale mo¿esz osi±gn±æ podobny efekt u¿ywaj±c
wielu konsoli linuksowych. Aby kopiowaæ pomiêdzy oknami, u¿yj klawiszy 
Alt-F<var>n</var>
do prze³±czania konsol wirtualnych, a do wklejania fragmentu pliku do innego
pliku, u¿yj &ldquor;Plik-&gt;Wstaw plik&rdquor; lub &ldquor;Plik-&gt;Kopiuj do pliku&rdquor;.
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it.
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I see .. but for now I do this not to hack LaTeX
-->
<p>
Wewnêtrzny edytor mo¿e byæ zast±piony przez dowolnie wybrany zewnêtrzny.
<p>
Wiele programów u¿ywa tak¿e zmiennej ¶rodowiskowej <tt>EDITOR</tt> lub 
<tt>VISUAL</tt> by okre¶liæ, którego edytora u¿yæ. Je¶li nie odpowiada Ci
<prgn>vim</prgn>, ustaw go na <tt>mcedit</tt> przez dodanie poni¿szych linii 
do <file>~/.bashrc</file>:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
Zalecam jednak ustawienie ich na <tt>vim</tt>, je¶li to mo¿liwe. Przywykniêcie
do poleceñ  <prgn>vim</prgn> jest dobr± rzecz±, od kiedy edytor Vi jest 
nieod³±czn± cech± ¶wiata Linuksa/Uniksa.
<footnote>
Aktualnie, <prgn>vi</prgn> oazr <prgn>nvi</prgn> to programy, które
znajdziesz wszêdzie. Wybra³em <prgn>vim</prgn> dla pocz±tkuj±cych gdy¿
oferuje on pomoc pod klawiszem F1 bêd±c zarazem podobnym i potê¿niejszym
narzêdziem od samego <prgn>vi</prgn>.
</footnote>

<sect1 id="mc-view">Podgl±d w MC
<p>
<!-- almost old content -->
Bardzo sprytne narzêdzie. Jest ¶wietny do wyszukiwania s³ów w dokumentach.
Zawsze u¿ywam go do przegl±dania plików w katalogu <file>/usr/share/doc</file>.
To najszybszy sposób na przegl±danie mas informacji o Linuksie. Podgl±d mo¿na
uruchomiæ bezpo¶rednio w taki sposób:
<example>
$ mc -v nazwa_pliku_do_podgl±du
</example>

<sect1 id="ma-auto">W³asno¶ci auto-startu programu MC
<p>
<!-- almost old content, tar.gz and deb are new -->
Wci¶nij Enter na pliku i w³a¶ciwy program zajmie siê jego zawarto¶ci±. Jest to bardzo wygodna cecha MC.
<example>
plik wykonywalny:  Wykonanie pliku wykonywalnego
plik man, html:    Przes³anie zawarto¶ci pliku przez przegl±darkê
plik tar.gz, plik deb: Przegl±danie zawarto¶ci pliku jako podkatalogu
</example>
By te przegl±darki/wirtualne pliki poprawnie dzia³a³y, przegl±dane pliki
nie mog± mieæ atrybutu wykonywalno¶ci. Zmieñ ich status u¿ywaj±c
polecenia <prgn>chmod</prgn> lub przez menu plików w MC.
</sect1>

<sect1 id="mc-ftp">Wirtualny system plików FTP w programie MC
<p>
<!-- old content -->
MC mo¿e s³u¿yæ do dostêpu do plików przez Internet przy u¿yciu FTP. Wejd¼ do
menu wciskaj±c F9, nastêpnie wpisz `p', by aktywowaæ wirtualny
system plików FTP. Wpisz URL w formie:
<tt>nazwa_u¿ytkownika:has³o@nazwa_hosta.nazwa_domeny</tt>, co spowoduje
pojawienie siê katalogu zdalnego, wygl±daj±cego jak lokalny.

<p>
<!-- new content -->
Wypróbuj <tt>&ftp-debian;</tt> jak adres URL i przejrzyj archiwum
plików systemu &debian;. Przeczytaj <ref id="ftparchives"> by dowiedzieæ
siê wiêcej o strukturze katalogów.

<sect id="unixlike">Praca w ¶rodowisku uniksopodobnym
<p>
<!-- new content -->
Chocia¿ MC pozwala Ci zrobiæ niemal wszystko, jest bardzo wa¿n± rzecz± aby
nauczyæ siê u¿ywaæ narzêdzi linii poleceñ uruchamianych z pow³oki aby zaznajomiæ
siê ze ¶rodowiskiem uniksopodobnym. 
<footnote>
W tym rozdzialem, pow³ok± idomy¶ln± jest <prgn>bash</prgn>. Po wiêcej informacji
o ró¿nych pow³okach zajrzyj do <ref id="shell">.
</footnote>

<sect1 id="sp-keys">Specjalne sekwencje klawiszy
<p>
<!-- practically new content -->
W ¶rodowisku uniksopodobnym, istnieje kilka sekwencji klawiszy które maj± 
znaczenie specjalne.
<footnote>
W normalnej znakowej konsoli systemu Linux, tylko klawisze Lewy-Ctrl i Lewy-Alt
maj± oczekiwane funkcje.
</footnote>
<list compact>
<item>Ctrl-U: Usuwa liniê przed kursorem.
<item>Ctrl-H: Usuwa znak przed kursorem.
<item>Ctrl-D: Koñczy standardowe wej¶cie (zamyke pow³okê je¶li u¿ywasz pow³oki)
<item>Ctrl-C: Koñczy dzia³aj±cy program.
<item>Ctrl-Z: Tymczasowo zatrzymuje program (przenosi program w t³o, zobacz <ref id="cmd-back">)
<item>Ctrl-S: Wstrzymuje wyj¶cie na ekran.
<footnote>
Mo¿esz wy³±czyæ tê opcjê terminala u¿ywaj±c
<manref name="stty" section="1">.
</footnote>
<item>Ctrl-Q: Przywraca wyj¶cie na ekran.
</list>
<p>
Domy¶lna pow³oka <prgn>bash</prgn>,
posiada zdolno¶æ edycji-historii oraz oraz mo¿liwo¶æ dope³niania poleceñ
przy pomocy klawisza tab, by wspomóc interaktywne u¿ywanie.
<list compact>
<item>strza³ka w górê:  Zaczyna przeszukiwaæ historiê poleceñ.
<item>Ctrl-R: Uruchamia przeszukiwanie historii poleceñ.
<item>TAB: Dope³nia wprowadzon± nazwê pliku w linii poleceñ.
<item>Ctrl-V TAB: Wprowadza TAB bez próby rozwiniêcia go do dopasowania.
</list>
<p>
Inne wa¿ne sekwencje klawiszy do zapamiêtania:
<list compact>
<item>Ctrl-Alt-Del:  Ponownie uruchom/zatrzymaj system, 
      zobacz <ref id="post-inst">.
<item>Przeci±gniêcie-lewym-klawiszem myszy: Zaznacza i kopiuje do schowka.
<item>Klikniêcie ¶rodkowym klawiszem myszy: Wkleja ze schowka w miejsce
      kursora.
<item>Meta-klawisz (terminologia Emacs) jest tradycyjnie powi±zany
z klawiszem lewy Alt. Niektóre systemy mog± byæ skonfigurowane tak, ¿e
Meta-klawisz odpowiada klawiszowi Windows.
</list>
Aby móc u¿ywaæ myszki w znakowej konsoli systemu Linux, musisz mieæ 
uruchomionego demona <prgn>gpm</prgn>.
<footnote>
W¶rodowisku X Window, myszka funkcjonuje w ten sam sposób w programie Xterm.
</footnote>
Zajrzyj do <ref id="gpm">.

<sect1 id="unixcmds">Podstawowe komendy uniksowe
<p>
<!-- new content -->
Nauczymy siê teraz podstawowych komend uniksowych.
<footnote>
U¿ywam tutaj s³owa "Unix" w jego ogólnym znaczeniu. Ka¿dy system operacyjny
bêd±cy klonem systemu Unix oferuje zestaw narzêdzi bêd±cych odpowiednikami
tych uniksowych. System &debian; nie jest wyj±tkiem.
Nie martw siê, je¶li jakie¶ polecenia nie dzia³±j± zgodnie z Twoimi 
oczekiwaniami. Poni¿sze przyk³ady nie zale¿± od kolejno¶ci ich wykonywania.
</footnote>
Wypróbuj dzia³anie wszystkich poni¿szych poleceñ u¿ywaj±c do tego konta
zwyk³ego u¿ytkownika <tt><var>penguin</var></tt> :
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>Wy¶wietla nazwê katalogu, w którym siê aktualnie znajdujesz.
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>Wy¶wietla Twoj± nazwê u¿ytkownika.
 </list>
<item><tt>file <var>foo</var></tt>
 <list compact>
 <item>Wy¶wietla typ pliku <var>foo</var>.
 </list>
<item><tt>type -p <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wy¶wietla po³o¿enie pliku polecenia <tt><var>nazwa_polecenia</var></tt>.
 <item><tt>which <var>nazwa_polecenia</var></tt> robi to samo.
 </list>
<item><tt>type <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wy¶wietla informacje o poleceniu <tt><var>nazwa_polecenia</var></tt>.
 </list>
<item><tt>apropos <var>s³owo-klucz</var></tt>
 <list compact>
 <item>Wyszukuje polecenia zwi±zazane ze <tt><var>s³owem-kluczowym</var></tt>.
 <item><tt>man -k <var>s³owo-klucz</var></tt> robi to samo.
 </list>
<item><tt>whatis <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wy¶wietla jednolinijkowe wyja¶nienie o dzia³aniu polecenia
  <tt><var>nazwa_polecenia</var></tt>.
 </list>
<item><tt>man -a <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wy¶wietla krótkie wyja¶nienie o dzia³aniu poleceniu
  <tt><var>nazwa_polecenia</var></tt>. (styl uniksowy)
 </list>
<item><tt>info <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wy¶wietla raczej obszerne wyja¶nienie o dzia³aniu polecenia
  <tt><var>nazwa_polecenia</var></tt>.  (styl GNU)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>Listuje zawarto¶æ katalogu. (nie wy¶wietla plików oraz katalogów rozpoczynaj±cych siê od kropki)
  <footnote>
system Unix tradycyjnie ukryw pliki, których nazwy rozpoczynaj± siê od 
"<tt>.</tt>". S± to zazwyczaj pliki konfiguracyjne oraz zawieraj±ce 
ustawienia preferencji uzytkownika.
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>Listuje zawarto¶æ katalogu (wszystkie pliki i katalogi)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>Listuje zawarto¶æ katalogu. (wszystkie pliki i katalogi, za wyj±tkiem
 "<file>..</file>" oraz "<file>.</file>")
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>Listuje ca³± zawarto¶æ wraz ze szczegó³owymi informacjami. Przeczytaj 
 <ref id="file-system">.
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>Listuje podkatalogi znajduj±ce siê w bie¿±cym katalogu.
 </list>
<item><tt>lsof <var>foo</var></tt>
 <list compact>
 <item>Wy¶wietla programy korzystaj±ce z pliku <tt><var>foo</var></tt>.
 </list>
<item><tt>mkdir <var>foo</var></tt>
 <list compact>
 <item>Tworzy nowy katalog o nazwie <tt><var>foo</var></tt>, w aktualnym 
 katalogu.
 </list>
<item><tt>rmdir <var>foo</var></tt>
 <list compact>
 <item>Usuwa katalog <tt><var>foo</var></tt> znajduj±cy siê w aktualnym
 katalogu.
 </list>
<item><tt>cd <var>foo</var></tt>
 <list compact>
 <item>Zmienia aktualny katalog na katalog <file><var>foo</var></file>
 w bie¿±cym katalogu lub w katalogu wymienionym w zmiennej  
  <tt>CDPATH</tt>. Przeczytaj o poleceniu <prgn>cd</prgn> w
  <manref name="builtins" section="7">.
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>Zmienia bie¿±cy katalog na katalog g³ówny.
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>Zmienia katalog bie¿acy na katalog domowy uzytkownika.
 </list>
<item><tt>cd /<var>foo</var></tt>
 <list compact>
 <item>Zmienia katalog bie¿±cy na ¶cie¿ke bezwzglêdna
 <file>/<var>foo</var></file>.
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>Zmienia katalog na nadrzêdny.
 </list>
<item><tt>cd ~<var>foo</var></tt>
 <list compact>
 <item>Zmienia katalog na katalog domowy u¿ytkownika
  <tt><var>foo</var></tt>.
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>Zmienia katalog na poprzedni.
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>Wy¶wietla zawarto¶æ pliku <file>/etc/motd</file> u¿ywaj±c domy¶lnego
 pager'a. Przeczytaj <ref id="cmd-stdin">.
  <footnote>
Domy¶lnym pager'em systemu &debian; jest <prgn>more</prgn>, który nie
posiada opcji przewijania. Po zainstalowaniu pakietu <package>less</package> 
u¿ywaj±c polecenia <tt>apt-get install less</tt>, program <prgn>less</prgn> 
staje siê domy¶lnym pager'em posiadaj±cym opcjê przewijania przy pomocy
klawiszy kursorów.
  </footnote>
 </list>
<item><tt>touch <var>junkfile</var></tt>
 <list compact>
 <item>Tworzy pusty plik o nazwie <file><var>junkfile</var></file>.
 </list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Kopiuje istniej±cy plik <file><var>foo</var></file> do nowego pliku
 <file><var>bar</var></file>.
 </list>
<item><tt>rm <var>junkfile</var></tt>
 <list compact>
 <item>Usuwa plik <file><var>junkfile</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Zmienia nazwê istniej±cego pliku <file><var>foo</var></file> na
  <file><var>bar</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
 <list compact>
 <item>Przenosi istniej±cy plik <file><var>foo</var></file> do nowego miejsca
 o nazwie <file><var>bar/baz</var></file>. Katalog <file><var>bar/</var></file>
 musi istnieæ.
 </list>
<item><tt>chmod 600 <var>foo</var></tt>
 <list compact>
 <item>Usuwa z listy praw dostêpu do istniej±cego pliku 
 <file><var>foo</var></file> prawa odczytu oraz zapisu dla innych u¿ytkowników. 
 (brak praw wykonywania dla wszystkich)
 </list>
<item><tt>chmod 644 <var>foo</var></tt>
 <list compact>
 <item>Zmienia prawa dostêpu do istniej±cego pliku <file><var>foo</var></file> 
 na umo¿liwiaj±ce odczyt ale zabranij±ce zapisu do pliku dla innych 
 u¿ytkowników. (brak prawa wykonywania dla wszystkich)
 </list>
<item><tt>chmod 755 <var>foo</var></tt>
 <list compact>
 <item>Zmienia prawa dostêpu do istniej±cego pliku <file><var>foo</var></file> 
 na prawo oidczytu lecz brak prawa zapisu. (prawo wykonywania dla wszystkich)
 </list>
<item><tt>top</tt>
 <list compact>
 <item>Wy¶wietla informacje o procesach na pe³nym ekranie. Wci¶nij "q"
 by zakoñczyæ.
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>Wy¶wietla informacje o wszystkich dzia³aj±cych procesach u¿ywaj±c
 na wyj¶ciu stylu BSD. Zobacz <ref id="cmd-pipe">.
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>Wy¶wietla informacje o wszystkich dzia³aj±cyh procesach u¿ywaj±c
 na wyj¶ciu uniksowego stylu system-V.
 </list>
<item><tt>ps aux | grep -e "[e]xim"</tt>
 <list compact>
 <item>Wy¶wietla wszystkie procesy <prgn>exim</prgn>. Wiêcej na temat
 wyra¿eñ regularnych mo¿esz dowiedzieæ siê ze strony podrêcznika 
 <manref name="grep" section="1"> wprowadzaj±c <tt>man grep</tt>.
 </list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item>Wy¶wietla informacje o wszystkich dzia³aj±cyh procesach u¿ywaj±c na
 wyj¶ciu stylu tworzenia grafiki przy pomocy znaków ASCII.
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>Ubija proces identifikowany poprzez jego numer ID: <var>1234</var>.
 Przeczytaj <ref id="kill">.
 </list>
<item><tt>grep -e "<var>pattern</var>" *.html</tt>
 <list compact>
 <item>Wyszukuje i wy¶wietla wszystkie wyst±pienia "<var>wzorca</var>" 
 w plikach <tt>.html</tt> znajduj±cych siê w bie¿±cym katalogu.
 </list>
<item><tt>gzip <var>foo</var></tt>
 <list compact>
 <item>Kompresuje plik <file><var>foo</var></file> i tworzy 
 <file><var>foo</var>.gz</file> u¿ywaj±c kodowania Lempel-Ziv (LZ77).
 </list>
<item><tt>gunzip <var>foo</var>.gz</tt>
 <list compact>
 <item>Dekompresuje plik <file><var>foo</var>.gz</file> i tworzy 
  <file><var>foo</var></file>.
 </list>
<item><tt>bzip2 <var>foo</var></tt>
 <list compact>
 <item>Kompresuje plik <file><var>foo</var></file> i tworzy
  <file><var>foo</var>.bz2</file> u¿ywaj±c algorytmu kompresji tekstu poprzez
  sortowanie blokowe Burrows-Wheeler i kodowanie metod± Huffman'a. (lepsza
  kompresja ni¿ przy u¿yciu <prgn>gzip</prgn>)
 </list>
<item><tt>bunzip2 <var>foo</var>.bz2</tt>
 <list compact>
 <item>Dekompresuje plik <file><var>foo</var>.bz2</file> i tworzy
  <file><var>foo</var></file>.
 </list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
 <list compact>
 <item>Wydobywa pliki z archiwum <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
 <list compact>
 <item>Wydobywa pliki z archiwum <file><var>foo</var>.tar.gz</file>
 </list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
 <list compact>
 <item>Wydobywa pliki z archiwum <file><var>foo</var>.tar.bz2</file>.
  <footnote>
Opcja <tt>--bzip2</tt> jest tutaj u¿ywana zamiast nowej krótszej <tt>-j</tt> 
by zapewniæ poprawn± pracê ze starsz± wersj± <prgn>tar</prgn> w Potato.
  </footnote>
 </list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
 <list compact>
 <item>Archiwizuje zawarto¶æ folderu <file><var>bar</var>/</file> w pliku
 archiwum <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
 <list compact>
 <item> Archiwizuje zawarto¶æ folderu <file><var>bar</var>/</file> w
 skompresowanym archiwum <file><var>foo</var>.tar.gz</file>.
 </list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
 <list compact>
 <item>Archiwizuje zawarto¶æ folderu <file><var>bar</var>/</file> w
 archiwum <file><var>foo</var>.tar.bz2</file>.
  <footnote>
 Opcja <tt>--bzip2</tt> u¿ywana jest tutaj dla zachowania kompatybilno¶ci.
  </footnote>
 </list>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>Wy¶wietla zawarto¶æ skompresowanego pliku 
  <file>README.gz</file> u¿ywaj±c domy¶lnego pager'a.
 </list>
<item><tt>zcat README.gz &gt; foo</tt>
 <list compact>
 <item>Tworzy plik o zdekompresowanej <file>foo</file> zawarto¶ci pliku 
  <file>README.gz</file>.
 </list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
 <list compact>
 <item>Do³±cza zdekompresowan± zawarto¶æ pliku <file>README.gz</file> na koniec
 pliku <file>foo</file>. (Je¶li ten plik nie istnieje, zostanie najpierw 
 utworzony)
 </list>
<item><tt>find . -name <var>pattern</var></tt>
 <list compact>
 <item>Wyszukuje nazwy plików pasuj±ce do <tt><var>wzorca</var></tt>. 
 (wolniejsz)
 </list>
<item><tt>locate -d . <var>pattern</var></tt>
 <list compact>
 <item>Wyszukuje nazwy plików pasuj±ce do <tt><var>wzorca</var></tt> pow³oki.
  (szybsze, przy u¿yciu regularnie aktualizowanej bazy plików)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
W ramach treningu przejrzyj dostêpne katalogi by zaznajomiæ siê z systemem.
Je¶li masz jakiekolwiek pytania, przeczytaj obowi±zkowo stronê podrêcznika
systemowego. Dla przyk³adu zacznij od poni¿szych poleceñ:
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
Jest ju¿ tak¿e odpowiednia pora by uruchomiæ <prgn>vim</prgn> i wcisn±æ
klawisz F1. Powiniene¶ przeczytaæ przynajmniej pierwsze 35 linijek. 
Nastêpnie przesuñ kursor nad <tt>|tutor|</tt> i naci¶nij Ctrl-] by
rozpocz±æ kurs. Przeczytaj <ref id="edit"> by nauczyæ siê wiêcej o edytorach.
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
Zauwa¿, ¿e wiele polecen uniksopodobnych w³±czaj±c w to niektóre GNU oraz
BSD bêd± wy¶wietla³y zwiêz³± informacjê je¶li wywo³asz je w jeden z poni¿szych
sposobów:

<example>
$ <var>commandname</var> --help
$ <var>commandname</var> -h
</example>
<p>
Jako æwiczenie, wypróbuj równie¿ przyk³ady znajduj±ce siê w <ref id="tips">.

<sect1 id="cmd-exec">Wykonywanie poleceñ
<p>
<!-- new content -->
Teraz masz ju¿ jakie¶ pojêcie jak u¿ywaæ systemu &debian;. Zajrzyjmy wiêæ
g³êbiej by poznaæ mechanizm wykonywania poleceñ w systemie &debian;.
<footnote>
W tym miejscu opis zosta³ przygotowany dla zupe³nie pocz±tkuj±cych. Po
dok³adniejsze wyja¶nienia zajrzyj do <manref name="bash" section="1">.
</footnote>

<sect1 id="cmd-simple">Proste polecenie
<p>
<!-- new content -->
Proste polecenie jest sekwencj±: 
<enumlist compact>
<item>przypisañ zmiennych (opcjonalne)
<item>nazwy polecenia
<item>argumentów (opcjonalne)
<item>przekierowañ (opcjonalne: <tt>&gt;</tt> , <tt>&gt;&gt;</tt> ,
<tt>&lt;</tt> , <tt>&lt;&lt;</tt> , etc.)
<item>operatorów kontroluj±cych (opcjonalnie: <tt>&amp;&amp;</tt> , 
<tt>||</tt> ; &lt;newline&gt; , <tt>;</tt> , <tt>&amp;</tt> , <tt>(</tt> , 
<tt>)</tt>)
</enumlist>
<p>
Bardziej skomplikowane polecenia wraz ze znakami cytowania i podmian±
wyra¿eñ mo¿esz obejrzeæ w <ref id="clprocess">.

<sect1 id="cmd-env">Wykonywanie polecenia oraz zmienna ¶rodowiskowa
<p>
<!-- new content -->
Typowe wywo³anie polecenia u¿ywa sekwencji pow³oki tak jak poni¿ej:
<footnote>
By otrzymaæ poni¿sze wyj¶cie, musisz mieæ zainstalowane francuskie locale,
zobacz <ref id="locales">. To nie jest zbyt istotne dla tego przewodnika
i zosta³o pokazane tylko by u¶wiadomiæ Ci ewentualne efekty.
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
Powy¿ej, program <prgn>date</prgn> jest wykonywany jako zadanie w tle.
Zmienna ¶rodowiskowa <tt>LC_ALL</tt> jest:
<list compact>
<item>nieustawiona (domy¶lne zachowanie systemu, tak jak i w przypadku 
<tt>C</tt>) dla pierwszego polecenia
<item>ustawiona na <tt>fr_FR</tt> (locale francuskie) dla drugiego 
polecenia
</list>
Wiêkszo¶æ wykonywanych poleceñ nie posiada poprzedzaj±cych definicji
zmiennej ¶rodowiskowej. Dla przyk³adu powy¿szego, alternatywnym przyk³±dem 
jest:
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
Jak pewnie zd±¿y³e¶ zauwa¿yæ, na dane wyj¶ciowe polecenia oddzia³ywuje
zmienna ¶rodowiskowa w taki sposób, by otrzymaæ je po francusku. Je¶li
chcesz aby zmienna ¶rodowiskowa by³a dziedziczona przez podprocesy (na
przyk³ad podczas dzia³ania skryptu pow³oki), musisz "wyeksportowaæ" tê
zmienn± w taki oto sposób:
<example>
$ export LC_ALL
</example>

<sect1 id="cmd-path">¦cie¿ka przeszukiwañ poleceñ
<p>
<!-- new content -->
Kiedy wpisujesz polecenie w pow³oce, wyszukuje ona odpowiedniego programu
zagl±daj±c do katalogów, które umieszczone s± w zmiennej ¶rodowiskowej 
<tt>PATH</tt>. Warto¶æ zmiennej ¶rodowiskowej <tt>PATH</tt> zwana jest równie¿
¶cie¿k± przeszukiwañ pow³oki.
<p>
W domy¶lnej instalacji systemu &debian;, zmienna ¶rodowiskowa <tt>PATH</tt>
konta u¿ytkownika mo¿e nie zawieraæ ¶cie¿ki <file>/sbin</file>. Wiêc, je¶li
chcesz uruchamiaæ takie polecenia jak  <prgn>ifconfig</prgn> z katalogu
<file>/sbin</file>, musisz zmieniæ zmienn± ¶rodowiskow± <tt>PATH</tt> 
tak by zawiera³a tê ¶cie¿kê. Zmienna ¶rodowiskowa <tt>PATH</tt> jest zazwyczaj
inicjalizowana przez plik <file>~/.bash_profile</file>, przeczytaj 
<ref id="bashconf">.

<sect1 id="cmd-opt">Opcje linii poleceñ
<p>
<!-- new content -->
Niektóre polecenia przyjmuj± argumenty. Te zaczynaj±ce siê od <tt>-</tt> oraz
od <tt>--</tt> zwane s± opcjami i kontroluj± one zachowanie siê polecenia.
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
Tutaj, argument linii poleceñ <tt>-R</tt> zmienia zachowanie polecenia 
<prgn>date</prgn> tak, by wyj¶ciowiy ci±g znaków zgodny by³ z dokumentem 
RFC-2822.

<sect1 id="cmd-wild">Wzorce pow³oki
<p>
<!-- new content -->
Bardzo czêsto zdarza siê, ¿e potrzebujemy by polecenie dzia³a³o z grup±
plików, a nie chcemy podawaæ ich wszystkich rêcznie. Dope³nianie nazw
plików przez <strong>wzorce pow³oki</strong> jest do tego celu w 
zupe³no¶ci wystarczaj±ce.
<list compact>
<item><tt>*</tt>
<list compact>
<item>Zastêpuje grupê z³o¿on± z zera lub wiêcej znaków.
<item>Wyj±tkiem od tej regu³y s± pliki zaczynaj±ce siê od "<tt>.</tt>".
</list>
<item><tt>?</tt>
<list compact>
<item>Zastêpuje dok³adnie jeden znak.
</list>
<item><tt>[...]</tt>
<list compact>
<item>Zastêpuje dok³adnie jeden znak z grupy znajduj±cej siê w nawiasach kwadratowych.
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>Zastêpuje dok³adnie jeden znak z grupy znaków od <tt>a</tt> do <tt>z</tt>.
</list>
<item><tt>[^...]</tt>
<list compact>
<item>Zastêpuje dok³adnie jeden znak inny ni¿ te znajduj±ce siê w nawiasach
(za wyj±tkiem "^").
</list>
</list>
<p>
Dla przyk³adu, wykonaj poni¿sze przyk³ady i przemy¶l wyniki jakie daj±:
<example>
$ mkdir junk; cd junk; $ touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rmdir junk
</example>

<sect1 id="cmd-return">Warto¶æ zwracana przez polecenia
<p>
Ka¿de polecenie koñcz±c swoje wykonywanie zwraca warto¶æ zwan± statusem 
zakoñczenia.
<list compact>
<item>zwracana warto¶æ = 0 je¶li zakoñczy³o siê pomy¶lnie.
<item>zwracana warto¶æ = ró¿na od zera, je¶li polecenie zakoñczy³o siê z b³êdem.
</list>
Warto¶æ zwrócona przez polecenie jest dostêpna zaraz po wykonaniu polecenia
w zmiennej ¶rodowiskowej <tt>$?</tt>.
<p>
Zauwa¿, ¿e je¶li status zakoñczenia u¿ywany jest w kontek¶cie logicznym
pow³oki, <strong>powodzenie</strong> jest traktowane jako logiczna 
<strong>PRAWDA</strong>. Jest to czasem myl±ce gdy¿ <strong>powodzenie</strong>
dotyczy warto¶ci <strong>zero</strong>.
<p>
Przeczytaj <ref id="shell-cond">.

<sect1 id="cmd-typical">W³a¶ciwa sekwencja poleceñ
<p>
<!-- new content in this whole sect1 ind sect2s -->
Spróbuj zapamiêtaæ nastêpuj±ce idiomy poleceñ. Zajrzyj do 
<ref id="shell-param">, <ref id="shell-redirect">,
<ref id="shell-cond">, oraz <ref id="clprocess"> po przeczytaniu 
tych¿e idiomów.

<sect2 id="cmd-back"><tt>polecenie &amp;</tt>
<p>
<prgn>Polecenie</prgn> zostanie wykonane w <strong>tle</strong>. Zadania
w tle pozwalaj± u¿ytkownikowi uruchamiaæ wiele programów w pojedynczej pow³oce.
<p>
Zarz±dzanie procesami znajduj±cymi siê w tle dokonywane jest przy pomocy
poleceñ wbudowanych pow³oki:
<prgn>jobs</prgn>, <prgn>fg</prgn>, <prgn>bg</prgn> i
<prgn>stop</prgn>. Przeczytaj czê¶ci "SIGNALS", "JOB CONTROL" i "SHELL
BUILTIN COMMAND" w podrêczniku systemowym  
<manref name="bash" section="1">.
<footnote>
System &debian; jest systemem wielozadaniowym.
</footnote>

<sect2 id="cmd-pipe"><tt>polecenie1 | polecenie2</tt>
<p>
Tutaj, na standardowe wej¶cie <prgn>polecenia2</prgn> zostaje przekierowane
standardowe wyj¶cie <prgn>polecenia1</prgn>. Oba polecenia mog± dzia³aæ
<strong>równolegle</strong>. Zwane jest to <strong>potokiem</strong>.

<sect2 id="cmd-list"><tt>polecenie1 ; polecenie2</tt>
<p>
Tutaj, <prgn>polecenie1</prgn> oraz <prgn>polecenie2</prgn> wykonywane s±
<strong>sekwencyjnie</strong>.

<sect2 id="cmd-and"><tt>polecenie1 &amp;&amp; polecenie2</tt>
<p>
Wykonywane jest <prgn>polecenie1</prgn>. Je¶li zakoñczy siê pomy¶lnie
to wykonywane jest <prgn>polecenie2</prgn>. Wykonywanie poleceñ ma tu charakter
<strong>sekwencyjny</strong>. Na koñcu zwracany jest status pomy¶lnego
zakoñczenia, je¶li oba: <prgn>polecenie1</prgn> <strong>i</strong>
<prgn>polecenie2</prgn> zakoñczy³y siê pomy¶lnie.

<sect2 id="cmd-or"><tt>polecenie1 || polecenie2</tt>
<p>
Wykonywane jest <prgn>polecenie1</prgn>. Je¶li nie wykona siê ono pomy¶lnie,
wykonywane jest <prgn>polecenie2</prgn>. Tu tak¿e charakter wykonywania poleceñ 
jest <strong>sekwencyjny</strong>. Status zakoñczenia jest zwracany pomy¶lny
je¶li <prgn>polecenie1</prgn> <strong>lub</strong> <prgn>polecenie2</prgn> 
zakoñczy³o siê pomy¶lnie.

<sect2 id="cmd-stdout"><tt>polecenie &gt; <var>foo</var></tt>
<p>
Przekierowuje standardowe wyj¶cie z <prgn>polecenia</prgn> do pliku
<tt><var>foo</var></tt>. (powoduje nadpisanie pliku)

<sect2 id="cmd-stdout2"><tt>polecenie &gt;&gt; <var>foo</var></tt>
<p>
Przekierowuje standardowe wyj¶cie <prgn>polecenia</prgn> do pliku
<tt><var>foo</var></tt>. (powoduje dopisanie do pliku)

<sect2 id="cmd-stderr"><tt>polecenie &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
Przekierowuje standardowe wyj¶cie oraz wyj¶cie b³êdów <prgn>polecenia</prgn>
do pliku <tt><var>foo</var></tt>.

<sect2 id="cmd-stdin"><tt>polecenie &lt; <var>foo</var></tt>
<p>
Przekierowuje standardowe wej¶cie <prgn>polecenia</prgn> do pliku
<tt><var>foo</var></tt>.  Sprawd¼:
<example>
$ &lt;/etc/motd pager
 ... (the greetings)
$ pager &lt;/etc/motd
 ... (the greetings)
$ pager /etc/motd
 ... (the greetings)
$ cat /etc/motd | pager
 ... (the greetings)
</example>
Pomimo, ¿e wszystkie powy¿sze sk³adnie robi± dok³adnie to samo, ostatni
przyk³ad uruchamia dodatkowe polecenie <prgn>cat</prgn> i przez to marnuje
zasoby systemowe bez powodu.

<sect1 id="cmd-alias">Aliasy poleceñ
<p>
<!-- new content -->
Mo¿esz ustawiæ sobie alias do czêsto wykonywanych poleceñ. Na przyk³ad:
<example>
$ alias la='ls -la'
</example>
Teraz, <prgn>la</prgn> dzia³a jak <tt>ls -la</tt> lecz zapisywane jest krócej.
Polecenie to powoduje wylistowanie wszystkich plików w katalogu w d³ugim (szczegó³owym) formacie.
<p>
Mo¿esz okre¶liæ dok³adn± ¶cie¿kê lub zidentifikowaæ polecenie u¿ywaj±c 
<prgn>type</prgn>. Przyk³adowo:
<example>
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
</example>
W powy¿szym pow³oka ostatnio poszukiwa³a <prgn>ls</prgn> podczas gdy nie
robi³a tego w przypadku <prgn>file</prgn>, st±d wniosek, ¿e pow³oka posiada
wewnêtrzny bufor w którym przetrzymywana jest lokalizacja najczê¶ciej
u¿ywanych poleceñ (<prgn>ls</prgn>).

<sect id="text-process">Uniksopodobne przetwarzanie tekstów
<p>
Istnieje kilka standardowych narzêdzi do przetwarzania tekstów, które s± bardzo
czêsto u¿ywane w systemach uniksopodobnych.
<list compact>
<item>Bez u¿ycia wyra¿enia regularnego :
<list compact>
<item><prgn>head</prgn> wy¶wietla pocz¶tek pliku.
<item><prgn>tail</prgn> wy¶wietla koñcowa czê¶æ pliku.
<item><prgn>sort</prgn> sortuje linie pliku tekstowego.
<item><prgn>uniq</prgn> usuwa zduplikowane linie z posortowanego pliku.
<item><prgn>tr</prgn> zamienia lub kasuje znaki.
<item><prgn>diff</prgn> porównuje pliki linia po linii.
</list>
<item>Z u¿yciem podstawowych wyra¿eñ regularnych (BRE):
<list compact>
<item><prgn>grep</prgn> dopasowuje tekst do wzorca.
<item><prgn>ed</prgn> jest prymitywnym edytorem linii poleceñ.
<item><prgn>sed</prgn> jest edytorem strumieni.
<item><prgn>vi</prgn> jest edytorem ekranowym.
<item><prgn>emacs</prgn> jest edytorem ekranowym.
</list>
<item>Z u¿yciem rozszerzonych wyra¿eñ regularnych (ERE):
<list compact>
<item><prgn>egrep</prgn> dopasowuje tekst do wzorca.
<item><prgn>awk</prgn> narzêdzie do prostego przetwarzania tekstów.
 Zajrzyj do <ref id="awk">.
<item><prgn>perl</prgn> potê¿ne narzêdzie do przetwarzania tekstów.
 Zajrzyj do <ref id="perl">.
</list>
</list>
Zajrzyj do<ref id="perl-i">, <ref id="scrp-snip">, oraz <ref id="perl-mad">
Po kilka przyk³adowych skryptów.

<sect1 id="regex">Wyra¿enia regularne
<p>
Wyra¿enia regularne u¿ywane s± w wielu narzêdziach do przetwarzania tekstu. 
S± one analogi± do wzorców pow³oki (patrz <ref id="cmd-wild">) lecz s±
zarówno bardziej skomplikowane jak i daj± o wiele wiêksze mo¿liwo¶ci.
<p>
Wyra¿enie regularne opisuje pasuj±cy wzorzec i jest zbudowane ze znaków
tekstowych oraz <strong>metaznaków</strong>. Metaznak jest znakiem ale
traktowanym w specjalny sposób. Dwa g³ówne style, BRE oraz ERE, zale¿ne
od u¿ywanych narzêdzi, opisane s± w <ref id="text-process">.
<p>
W stylu ERE, <strong>metaznaki</strong> zawieraj± "<tt> \ . [ ] ^
&dollar; * + ? ( ) { } | </tt>". Wyra¿enie regularne oznacza:
<list compact>
<item><tt>c</tt>
<list compact>
<item>Dopasowuje nie-metaznaki "<tt>c</tt>".
</list>
<item><tt>\c</tt>
<list compact>
<item>Dopasowuje znaki liter "<tt>c</tt>".
</list>
<item><tt>.</tt>
<list compact>
<item>Zastêpuje ka¿dy znak w³±czaj±c w to znak nowej linii.
</list>
<item><tt>^</tt>
<list compact>
<item>Zastêpuje "pocz±tek" ci±gu znaków.
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>Zastêpuje "koniec" ci±gu znaków.
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>Zastêpuje "pocz±tek" s³owa.
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>Zastêpuje "koniec" s³owa.
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>Ta lista zastêpuje ka¿dy ze znaków "<tt>abc...</tt>".
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>Ta zanegowana lista zastêpuje ka¿dy ze znaków inny ni¿ "<tt>abc...</tt>".
</list>
<item><tt>r*</tt>
<list compact>
<item>Zastêpuje zero lub wiêcej wyra¿eñ regularnych identyfikowanych przez 
 "<tt>r</tt>".
</list>
<item><tt>r+</tt>
<list compact>
<item>Zastêpuje jeden lub wiêcej wyra¿eñ regularnych identyfikowanych przez
 "<tt>r</tt>".
</list>
<item><tt>r?</tt>
<list compact>
<item>Zastêpuje zero lub jedno wyra¿enie regularne identyfikowane przez
"<tt>r</tt>".
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>Zastêpuje jedno wyra¿enie regularne identyfikowane przez
 "<tt>r1</tt>" lub "<tt>r2</tt>".
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>Zastêpuje jedno z wyra¿eñ regularnych identyfikowaych przez
 "<tt>r1</tt>" lub "<tt>r2</tt>" i traktuje je jako wyra¿enie regularne
 objête <strong>nawiasami kwadratowymi</strong>.
</list>
</list>
<p>
W stylu BRE <strong>metaznaki</strong> "<tt> + ? ( ) { } | </tt>"
trac± swoje specjalne znaczenie; w zamian nale¿y poprzedziæ je znakiem
backslash "<tt>\+ \? \( \) \{ \} \| </tt>".  
Wiêc konstrukcja grupuj±ca <tt>(r1|r2)</tt> musi byæ zapisana jako 
<tt>\(r1|r2\)</tt> w BRE.
<prgn>Emacs</prgn>, wykorzystuj±cy g³ównie BRE, traktuje "<tt> + ?
-</tt>" jako <strong>metaznaki</strong>. Z tego powodu nie ma potrzeby ich
poprzedzania. Sprawd¼ rozdzia³ <ref id="replaceex"> by dowiedzieæ siê jak
zosta³a u¿yta konstrukcja grupuj±ca.
<p>
Dla przyk³adu, <prgn>grep</prgn> mo¿e zostaæ u¿yty do przeszukiwania tekstu
z u¿yciem wyra¿eñ regularnych:
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">Wyra¿enia zastêpuj±ce
<p>
W wyra¿eniach zastêpuj±cych nastêpuj±ce znaki maj± specjalne znaczenie:
<list>
<item><tt>&amp;</tt>
<list compact>
<item>Reprezentuje dopasowanie wyra¿enia regularnego.
(w programie <prgn>emacs</prgn> u¿ywaj <tt>\&amp;</tt>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>Reprezentuje <var>n</var>-te dopasowanie wyra¿enia regularnego
(<strong>ujêtego w nawias</strong>).
</list>
</list>
W Perlu dla ci±gu zastêpuj±cego u¿ywany jest <tt>&dollar;<var>n</var></tt> 
zamiast <tt>\<var>n</var></tt>, a tak¿e <tt>&amp;</tt> nie ma specjalnego
znaczenia.
<p>
Przyk³adowo:
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
Zwróæ tutaj szczególn± uwagê na styl wyra¿enia regularnego objêtego
<strong>nawiasami kwadratowymi</strong> i w jaki sposób ci±gi znaków pasuj±ce
do wzorca w procesie zastêpowania ich wyst±pieñ w tek¶cie, przez ró¿ne
narzêdzia.
<p>
Te wyra¿enia regularne mog± byæ tak¿ê u¿yte do poruszania kursorem oraz do
zastêpowania tekstu w edytorach.
<p>
Przeczytaj prosze wszystkie zwi±zane z tym strony podrêcznika systemowego,
by lepiej zapoznaæ siê z tymi poleceniami.

<sect id="unixfile">Uniksopodobny system plików
<p>
<!--
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
W GNU/Linux oraz innych uniksopodobnych systemach operacyjnych
<strong>pliki</strong> zorganizowane s± w <strong>katalogi</strong>.
<footnote>
W niektórych systemach <strong>katalogi</strong> zwane s± 
<strong>folderami</strong>.
</footnote>
Wszystkie <strong>pliki</strong> i <strong>katalogi</strong> s± zgrupowane
w jednym wielkim drzewie, hierarchii plików, której korzeniem (root) jest 
<file>/</file>.
<p>
Te pliki i katalogi mog± byæ rozmieszczone na wielu urz±dzeniach. Polecenie 
<manref name="mount" section="8"> pozwala do³±czyæ pewne systemy plików z 
pod³±czonych urz±dzeñ do tego wielkiego drzewa plików. Odwrotnynm z kolei
dzia³aniem zajmuje siê polecenie <manref name="unmount" section="8">, które
pozwala z powrotem od³±czyæ dany system plików.

<sect1 id="file-basics">Podstawy uniksowego systemu plików
<p>
<!-- new content -->
Oto podstawy:
<list compact>
<item>Wielko¶æ liter w nazwach plików ma znaczenie. To znaczy, ¿e 
<file>MOJPLIK</file> oraz <file>MOjPlik</file> s± <strong>ca³kiem</strong>
innymi plikami.
<item>Katalog g³ówny zwany jest krótko <file>/</file>. Nie myl jednak
katalogu g³ównego (root) z u¿ytkownikiem "root" . Zobacz 
<ref id="login-root">.
<item>Ka¿dy katalog ma swoj± nazwê, która mo¿e zawieraæ wszystkie litery i 
i symbole <strong>za wyj±tkiem</strong> <file>/</file>.
<footnote>
Mimo tego, ¿e <strong>mo¿esz</strong> u¿ywaæ prawie wszystkich liter i symboli
w nazwie pliku, w praktyce jest to z³y pomys³. Lepiej unikaæ wszelkich znaków,
które czêsto maj± specjalne znaczenie w linii poleceñ, w³±czaj±c w to spacje,
znak tabulacji, znak nowej linii oraz inne: 
<tt>{ } ( ) [ ] ' ` " \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> .
<p>
Je¶li potrzebujesz rozdzieliæ s³owa w nazwie pliku, dobrym wyborem jest u¿ycie
kropki, my¶lnika lub znaku podkre¶lenia. Mo¿esz tak¿e napisaæ ka¿de s³owo z
du¿ej litery.
<tt>NaPrzyk³adTak</tt>.
</footnote>
Katalog g³ówny (root) jest wyj±tkiem; jego nazwa to <file>/</file>
(wymawiane "slesz" lub "katalog g³ówny") i nie mo¿e ona zostaæ
zmieniona.
<item>Ka¿dy plik lub katalog oznaczony jest poprzez <strong>w pe³ni
okre¶laj±c± nazwê pliku</strong>, <strong>absolutn± nazwê pliku</strong>
lub <strong>¶cie¿kê</strong>, podaj±c sekwencjê katalogów, przez które
nale¿y przej¶æ by dotrzeæ do pliku. Te trzy terminy s± synonimami.
Wszystkie absolutne nazwy plików rozpoczynaj± siê od katalogu <file>/</file> 
i pomiêdzy ka¿dym katalogiem lub nazw± pliku znajduje siê 
<file>/</file>. Pierwszy <file>/</file> jest nazw± katalogu, ale kolejne s±
po prostu separatorami by rozró¿niæ czê¶ci nazwy pliku.
<p>
S³owa tutaj u¿ywane mog± byæ myl±ce. We¿my nastêpuj±cy przyk³±d:
<example>
/usr/share/keytables/us.map.gz
</example>
To jest w pe³ni okre¶laj±ca nazwa pliku; niektórzy nazywaj± j± 
<strong>¶cie¿k±</strong>. Ludzie czasem nazywaj± nazw± pliku samo 
<file>us.map.gz</file>.
<footnote>
S³owo <strong>¶cie¿ka</strong> jest równie¿ u¿ywane w ca³kiem innym znaczeniu.
Patrz <ref id="cmd-path">. Odpowiednie znaczenie jest przewa¿nie zawarte w 
kontek¶cie wypowiedzi.
</footnote>
<item>Katalog g³ówny (root) ma kilka ga³êzi, takich jak <file>/etc</file>
ii <file>/usr</file>. Te podkatalogi tak¿e posiadaj± swoje ga³êzie 
(podkatalogi), na przyk³ad <file>/etc/init.d</file> i <file>/usr/local</file>. 
Ca³a ta struktura zwana jest <strong>drzewem katalogów</strong>.
<p>
Mo¿esz my¶leæ o w pe³ni okre¶laj±cej nazwie pliku jak o drodze od podstawy 
drzewa
(<file>/</file>), a¿ do konkretnej ga³êzi (pliku). Nie raz te¿ us³yszysz
jak inni mówi± o drzewie katalogów jakby to by³o drzewo 
<strong>rodzinne</strong>, gdzie podkatalogi maj± swoich 
<strong>rodziców</strong>, a ¶cie¿ka to dok³adne pochodzenie pliku.
<p>
Istniej± tak¿e ¶cie¿ki wzglêdne, które rozpoczynaj± siê ca³kiem gdzie indziej
ni¿ katalog g³ówny (root). Powiniene¶ zapamiêtaæ, ¿e <file>../</file> odnosi
siê do katalogu nadrzêdnego. 

<item>Nie ma tutaj katalogu, który odnosi³by siê do fizycznego urz±dzenia
takiego jak dysk twardy. Jest to zasadnicza ró¿nica w kontek¶cie takich
systemó jak CP/M, DOS oraz Windows, gdzie wszystkie ¶cie¿ki rozpoczynaj± siê
od nazwy urz±dzenia; na przyk³ad <tt>C:\</tt>. Patrz <ref id="file-system">.
</list>

<p>
Najlepsze rady dotycz±ce hierarchii plików zebrane sosta³y pod adresem
<url id="&f-fhs;" name="Filesystem Hierarchy Standard">. Jako pocz±tkuj±cy
powinieneæ pamiêtaæ nastêpuj±ce fakty:
<list compact>
<item><file>/</file>
<list compact>
<item>Znak <file>/</file> reprezentuje katalog g³ówny (root).
<p>
</list>
<item><file>/etc</file>
<list compact>
<item>To miejsce gdzie przechowywane s± pliki konfiguracyjne systemu.
</list>
<item><file>/var/log</file>
<list compact>
<item>To miejsce przechowywania logów systemowych.
</list>
<item><file>/home</file>
<list compact>
<item>To katalog zawieraj±cy katalogi domowe zwyk³ych u¿ytkowników.
</list>
</list>

<sect1 id="file-system">Koncepcja systemu plików w systemie &debian;
<p>
<!-- old content modified with fs.h reference -->
Zgodnie z tradycj± uniksow±, system &debian; udostêpnia system plików, w którym
fizyczne dane na dyskach twardych i innych no¶nikach, oraz interakcja pomiêdzy
sprzêtem takim jak ekran konsoli i zdalnymi konsolami szeregowymi, zosta³y 
ujednolicone.
<p>
Ka¿dy plik, katalog, nazwany potok lub urz±dzenie fizyczne w systemie &debian;
posiada strukturê danych zwan± <strong>wêz³em</strong>, która opisuje zwi±zane
z nim atrybuty takie jak: w³a¶ciciel, grupa do której nale¿y, ostatni czas
dostêpu, itd. Dok³adna definicja <tt>struktury iwêz³a</tt> w systemie
&debian; GNU/Linux znajduje siê w <url id="&f-inode-def;">.
<p>
Ta ujednolicona reprezentacja jednostek fizycznych to potê¿ne narzêdzie,
gdy¿ pozwala na stosowanie tych samych poleceñ do tych samych operacji
na ca³kowicie ró¿nych od siebie urz±dzeniach.
<p>
Wszystkie Twoje pliki mog± znajdowaæ siê na jednym dysku --- lub mo¿esz mieæ
20 dysków, niektóre z nich pod³±czone do innych komputerów gdzie¶ w sieci.
Nie bêdziesz móg³ tego rozpoznaæ po samym wygl±dzie drzewa katalogów, a niemal
wszystkie polecenia dzia³aj± tak samo i bez znaczenia jest na jakim urz±dzeniu
fizycznym tak na prawdê, znajduj± siê Twoje pliki.

<sect1 id="file-perm">Prawa dostêpu do plików i katalogów
<p>
<!-- old content -->
Prawa dostêpu do plików i katalogów s± definiowane oddzielnie dla
nastêpuj±cych trzech kategorii u¿ytkowników, których dotycz±:
<list compact>
<item><strong>W³a¶ciciel</strong> pliku (u), 
<item>inni u¿ytkownicy w <strong>grupie</strong>, do której nale¿y plik (g),
oraz dla <item>wszystkich <strong>pozosta³ych</strong> u¿ytkowników (o).
</list>
<p>
Dla pliku ka¿de prawo pozwala odpowiednio na:
<list compact>
<item><strong>odczyt</strong> (r): odczyt zawarto¶ci pliku,
<item><strong>zapis</strong> (w): modyfikacjê zawarto¶ci pliku, oraz
<item><strong>wykonanie</strong> (x): uruchomienie pliku jako polecenia.
</list>
<p>
Dla katalogu ka¿de prawo pozwala odpowiednio na:
<list compact>
<item><strong>odczyt</strong> (r): wy¶wietlenie zawarto¶ci katalogu,
<item><strong>zapis</strong> (w): dodawanie i usuwanie plików w katalogu, oraz
<item><strong>wykonanie</strong> (x): dostêp do plików w katalogu.
</list>
Tutaj prawo <strong>wykonania</strong> dla katalogu oznacza nie tylko prawo do
odczytu plików w nim zawartych, ale tak¿e na przegl±danie atrybutów takich jak
rozmiar i czas modyfikacji.
<p>
Aby otrzymaæ informacje o uprawnieniach (oraz inne) plików i katalogów,
u¿ywa siê polecenia <prgn>ls</prgn>. Zobacz <manref name="ls" section="1">.  
Gdy <prgn>ls</prgn> jest wywo³ane z parametrem <tt>-l</tt>, wy¶wietla
nastêpuj±ce informacje w nastêpuj±cej kolejno¶ci:
<list compact>
<item><strong>Typ pliku</strong> (pierwsza litera)
 <list compact>
 <item><tt>-</tt>: zwyk³y plik
 <item><tt>d:</tt> katalog
 <item><tt>l:</tt> dowi±zanie symboliczne (symlink)
 <item><tt>c:</tt> urz±dzenie znakowe
 <item><tt>b:</tt> urz±dzenie blokowe
 <item><tt>p:</tt> nazwany potok
 <item><tt>s:</tt> gniazdo
 </list>
<item><strong>prawa</strong> dostêpu do pliku (kolejnych dziewiêæ znaków,
po trzy kolejno dla: w³a¶ciciela, grupy, oraz pozosta³ych)
<item><strong>liczba dowi±zañ</strong> (hardlink) do pliku
<item>nazwa <strong>u¿ytkownika</strong> bêd±cego w³a¶cicielem pliku
<item>nazwa <strong>grupy</strong>, do której nale¿y plik
<item><strong>rozmiar</strong> pliku w znakach (bajtach)
<item><strong>data i czas</strong> modyfikacji pliku (mtime)
<item><strong>nazwa</strong> pliku.
</list>
<p>

Aby zmieniæ w³a¶ciciela pliku, u¿ywa siê z konta root polecenia 
<prgn>chown</prgn>. Aby zmieniæ grupê pliku, u¿ywa siê polecenia 
<prgn>chgrp</prgn> z konta w³a¶ciciela pliku lub konta root. 
Aby zmieniæ prawa dostêpu do plików czy katalogów, u¿ywa siê polecenia 
<prgn>chmod</prgn>, tak¿e z konta u¿ytkownika lub konta root.
Podstawowa sk³adnia pozwalaj±ca na manipulowanie plikiem <file>foo</file> to:
<example>
# chown <var>nowy_wlasciciel</var> foo
# chgrp <var>nowa_grupa</var> foo
# chmod  [ugoa][+-=][rwx][,...] foo
</example>
Zobacz <manref name="chown" section="1">,
<manref name="chgrp" section="1">, oraz
<manref name="chmod" section="1"> po wiêcej szczegó³ów.
<p>
Na przyk³ad w celu uczynienia u¿ytkownika <var>foo</var> w³a¶cicielem drzewa
katalogów, a grupy <var>bar</var> wspó³w³a¶cicielem, wykonaj nastêpuj±ce
polecenia z konta root:
<example>
# cd /some/location/
# chown -R <var>foo</var>:<var>bar</var>
# chmod -R ug+rwX,o=rX 
</example>
<p>
Istniej± jeszcze trzy specjalne bity uprawnieñ:
<list compact>
<item><strong>ustawia ID u¿ytkownika</strong> (s lub S zamiast x u¿ytkownika), 
<item><strong>ustawia ID grupy</strong> (s lub S zamiast x grupy), oraz
<item><strong>bit lepko¶ci</strong> (sticky bit) (t lub T zamiast x 
pozosta³ych).
</list>
Na wyj¶ciu polecenia <prgn>ls -l</prgn> du¿ymi literami oznaczane s± bity,
na których miejscu bit wykonywalno¶ci nie by³ ustawiony.
<p>
Ustawienie <strong>ID u¿ytkownika</strong> dla pliku wykonywalnego
pozwala u¿ytkownikowi na wykonanie tego pliku z ID w³a¶ciciela pliku 
(na przyk³ad <strong>root</strong>). Podobnie, ustawienie
<strong>ID grupy</strong> dla pliku wykonywalnego, pozwala u¿ytkownikowi
na wykonanie pliku z ID grupy pliku (na przyk³ad <strong>root</strong>). 
Poniewa¿ mo¿e to powodowaæ ryzyko naruszenia bezpieczeñstwa, w³±czanie tych 
opcji wymaga szczególnej ostro¿no¶ci.
<p>
Ustawienie <strong>ID grupy</strong> dla katalogu uaktywnia schemat 
tworzenia plików w stylu BSD, w którym wszystkie pliki tworzone w tym katalogu
nale¿± do <strong>grupy</strong>, maj±cej do niego uprawnienia.
<p>
Ustawienie <strong>bitu lepko¶ci</strong> dla katalogu zapobiega usuwaniu z 
niego plików przez u¿ytkowników, którzy nie s± w³a¶cicielami tych pliku.
W celu zabezpieczenia zawarto¶ci pliku w katalogach zapisywalnych, takich jak
<file>/tmp</file> czy w katalogach, w których prawo zapisu ma grupa, potrzeba
nie tylko, by by³o wy³±czone prawo <strong>zapisu</strong> dla pliku, ale tak¿e
nale¿y ustawiæ <strong>sticky bit</strong> dla katalogu. W innym przypadku plik
mo¿e zostaæ usuniêty, a nastêpnie w jego miejsce mo¿e zostaæ utworzony nowy
plik, o takiej samej nazwie przez dowolnego u¿ytkownika, który ma prawo zapisu
do tego katalogu.
<p>
Poni¿ej kilka interesuj±cych przyk³adów praw do pliku.
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
Istnieje alternatywna metoda numeryczna do opisu praw pliku w
<manref name="chmod" section="1"> poleceniach. Metoda ta u¿ywa trzech lub
czterech cyfr o znaczeniu ósemkowym. Oznaczaj± one odpowiednio:
<list compact>
<item>1-sza cyfra opcjonalna: suma opcji
<strong>ustawione ID u¿ytkownika</strong> (=4),
<strong>ustawione ID grupy</strong> (=2), oraz 
<strong>bit lepko¶ci</strong> (=1)
<item>2-ga cyfra: suma praw
<strong>odczytu</strong> (=4), <strong>zapisu</strong> (=2), oraz
<strong>wykonywania</strong> (=1)
dla <strong>u¿ytkownika</strong>
<item>3-cia cyfra: to samo ale dla <strong>grupy</strong>
<item>4-ta cyfra: to samo ale dla <strong>innych</strong>
</list>
<p>
Brzmi to do¶æ skomplikowanie ale jest ca³kiem proste. Je¶li spojrzysz na
pierwsze kilka kolumn (2-10) bêd±cych wynikiem polecenia <tt>ls -l</tt>
i odczytasz ich znaczenie binarnie (podstawa=2) reprezentacjê praw do pliku
(gdzie "-" to "0" a "rwx" to "1"), warto¶æ takiego wyra¿enia numerycznego
powinna mieæ dla Ciebie poprawny sens jako reprezentacja ósemkowa (podstawa=8) 
praw dostêpu do pliku.
<footnote>
Oczywi¶ce metoda ta sprawdza siê tylko w przypadku 3 cyfr.
</footnote>
Spójrz na ten przyk³ad:
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
Domy¶lna maska praw dostêpu do pliku ustawiana jest przy u¿yciu wbudowanego 
polecenia pow³oki <prgn>umask</prgn>. Zobacz 
<manref name="builtins" section="7">.
</sect1>

<sect1 id="timestamp">Znaczniki czasu
<p>
<!-- old content, minor edit -->
Dla plików GNU/Linux istniej± trzy typy znaczników czasu:
<list compact>
<item><strong>mtime</strong>: czas modyfikacji (<tt>ls -l</tt>),
<item><strong>ctime</strong>: czas zmiany statusu (<tt>ls -lc</tt>), oraz
<item><strong>atime</strong>: czas ostatniego dostêpu (<tt>ls -lu</tt>).
</list>
Zauwa¿, ¿e <strong>ctime</strong> nie jest czasem utworzenia pliku.  
<list compact>
<item>Nadpisanie pliku zmieni wszystkie <strong>mtime</strong>,
  <strong>ctime</strong> i <strong>atime</strong> pliku.
<item>Zmiana praw lub w³a¶ciciela pliku zmieni <strong>ctime</strong> oraz
<strong>atime</strong> pliku.
<item>Odczyt pliku zmieni jego <strong>atime</strong>.
</list>
Zauwa¿, ¿e nawet zwyk³y odczyt z pliku w systemie &debian; powoduje normalnie
operacjê zapisu w celu aktualizacji informacji <strong>atime</strong>
w <strong>inode</strong>.
Montowanie systemu plików z opcj± <tt>noatime</tt> pozwoli systemowi na
ominiêcie tej operacji i zaowocuje szybszym dostêpem do pliku przy odczycie.
Zobacz <manref name="mount" section="8">.
<p>
<!-- new content -->
U¿yj polecenia <manref name="touch" section="1"> aby zmieniæ znacznik czasu
istniej±cego pliku.
</sect1>

<sect1 id="links">Dowi±zania (links)
<p>
<!-- old content -->
Istniej± dwie metody na zwi±zanie pliku <var>foo</var> z innym plikiem 
<var>bar</var>.
<list compact>
<item><strong>dowi±zanie</strong> (hardlink) jest to inna nazwa dla istniej±cego pliku
 (<tt>ln <var>foo</var> <var>bar</var></tt>),
<item><strong>dowi±zanie symboliczne</strong> lub &ldquor;symlink&rdquor; jest specjalnym
plikiem, który wskazuje na inny poprzez nazwê 
(<tt>ln -s <var>foo</var> <var>bar</var></tt>).
</list>
Spójrz na poni¿sze przyk³ady zmian w dowi±zaniach, oraz na subtelne
ró¿nice w rezultacie polecenia <prgn>rm</prgn>.
<example>
$ echo "Oryginalna zawarto¶æ" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # dowi±zanie (hardlink)
$ ln -s <var>foo</var> <var>baz</var>  # dowi±zanie symboliczne
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "Nowa zawarto¶æ" &gt; <var>foo</var>
$ cat <var>bar</var>
Oryginalna zawarto¶æ
$ cat <var>baz</var>
Nowa zawarto¶æ
</example>
Dowi±zanie symboliczne zawsze ma, jak widaæ w przyk³adzie powy¿ej prawa 
dostêpu &ldquor;rwxrwxrwx&rdquor;, a jego faktyczne prawa dostêpu s± takie 
jak wskazywanego pliku.
<p>
Katalog <file>.</file> jest dowi±zaniem do katalogu, w którym sam siê
pojawia, zatem liczba dowi±zañ do nowego katalogu rozpoczyna siê od 2. 
Katalog <file>..</file> jest dowi±zaniem do katalogu nadrzêdnego, 
zatem liczba dowi±zañ do katalogu ro¶nie wraz z liczb± nowych podkatalogów.

<sect1 id="fifo">Nazwane potoki (FIFOs)
<p>
<!-- DDP Debian Tutorial content -->
<p>
Naznway potok jest plikiem, który dzia³a jak potok. Wrzucasz co¶ do pliku
i dostajesz co¶ z niego na zewn±trz. Zwane jest to FIFO, lub 
First-In-First-Out (Pierwsze-Weszlo-Pierwsze-Wysz³o): pierwsza rzecz jak±
w³o¿ysz do takiego pliku, jest pierwsz± rzecz± któr± mo¿esz z niego odebraæ.
<p>
Je¶li zapisujesz do nazwanego potoku, proces który tego dokonuje, nie zakoñczy
siê dopóki dane, które zosta³y do niego zapisane, nie zostan± odczytane. 
Je¶li czytasz z nazwanego potoku, proces który dokonuje odczytu czeka z
zakoñczeniem, dopóki tylko jest co¶ do odczytania. Nazwany potok ma zawsze
zerow± wielko¶æ --- nie przechowuje ¿adnych danych, po prostu ³±czy dwa procesy
tak jak <tt>|</tt> w pow³oce. Jednak¿e, to i¿ taki potok ma swoj± nazwê,
powoduje, ¿e dwa procesy nie musz± byæ w jednej linii poleceñ a nawet, 
mog± byæ uruchamiane przez ró¿nych u¿ytkowników.

<p>
Spróbuj sam wykonuj±c poni¿szy przyk³ad:
<example>
$ cd; mkfifo mypipe
$ echo "hello" &gt;mypipe &amp; # put into background
[1] <var>5952</var>
$ ls -l mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
$ cat mypipe
hello
[1]+  Done                    echo hello &gt;mypipe
$ ls mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
$ rm mypipe
</example>

<sect1 id="sockets">Gniazda
<p>
<!-- new content -->
Gniazdo jest podobne do nazwanego potoku (FIFO) i pozwala procesom na wymianê
informacji. W przypadku gniazda jednak, procesy nie musz± byæ uruchomione w
tym samym czasie, a nawet nie nie musz± byæ procesami potomnymi swoich 
przodków. To jest punkt styku ich komunikacji miêdzyprocesowej.
Informacje mog± byæ wymieniane przez sieæ pomiêdzy dwoma ró¿nymi komputerami.

<sect1 id="device">Pliki urz±dzeñ
<p>
<!-- DDP Debian Tutorial content, modified -->
Plik urz±dzenia odnosi siê do fizycznego lub wirtualnego urz±dzenia, takiego
jak dysk twardy, karta graficzna, ekran czy klawiatura, w Twoim systemie.
Przyk³adem urz±dzenia wirtualnego jest konsola, reprezentowana przez 
<tt>/dev/console</tt>.
<p>
Istniej± dwa typy urz±dzeñ:
<list compact>
<item><strong>urz±dzenie znakowe</strong>
<list compact>
<item>Dostêp do takiego urz±dzenia odbywa siê znak po znaku, to znaczy, ¿e 
najmniejsza porcja danych jaka mo¿e byæ zapisana lub odczytana z urz±dzenia
to jeden znak (bajt).
</list>
<item><strong>urz±dzenie blokowe</strong>
<list compact>
<item>Dostêp do takiego urz±dzenia nastêpuje poprzez zczytania lub zapisanie
wiêkszej ilo¶ci danych, zwanych blokami, które zawieraj± pewn± ilo¶æ znaków.
Dobrym przyk³adem jest tutaj Twój dysk twardy.
</list>
</list>
<p>
Mo¿esz odczytywaæ oraz zapisywaæ do plików urz±dzeñ, lecz mog± one zawieraæ
równie¿ dane binarne o ca³kowicie niezrozumia³ym zapisie dla cz³owieka.
Zapisywanie danych do takich plików jest czasami przydatne przy badaniu
problemów tycz±cych siê ³±czenia sprzêtu. Dla przyk³adu mo¿esz przes³aæ
plik tekstowy do urz±dzenia drukarki <file>/dev/lp0</file> lub wys³aæ 
odpowiednie polecenie modemowe na odpowiedni port szeregowy
<file>/dev/ttyS0</file>. Jednak robi±c to nieostro¿nie mo¿na spowodowaæ
powa¿ne uszkodzenie, wiêc postêpuj z rozwag±.

<sect2 id="devnull"><file>/dev/null</file> i inne 
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> jest specjalnym plikiem urz±dzenia, które porzuca
wszystko co do niego wrzucisz. Je¶li czego¶ nie potrzebujesz, wrzuæ to do 
<file>/dev/null</file>. Jest to taka dziura bez dna. Je¶li spróbujesz co¶
przeczytaæ z <file>/dev/null</file>, dostaniesz natychmiast znak koñca pliku.
<p>
<file>/dev/zero</file> dzia³a podobnie, z tym, ¿e próba odczytu zwraca znak
<tt>\0</tt> (to nie to samo zero co "0" w kodzie ASCII).  Patrz 
<ref id="dummyfile">.

<sect2 id="node">Numer wêz³owy urz±dzenia
<p>
<!-- new content -->
Numer wêz³owy urz±dzenia wy¶wietlany jet jako wynik polecenia <prgn>ls</prgn>:
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
Tutaj,
<list compact>
<item><file>/dev/hda</file> posiada pierwszorzêdny numer urz±dzenia 3 oraz 
pomoniczy numer urz±dzenia 0. Ustawione jest te¿ prawo odczytu/zapisu dla 
u¿ytkowników nale¿acych do grupy <tt>disk</tt>,
<item><file>/dev/ttyS0</file> posiada pierwszorzêdny numer urz±dzenia 4 oraz
drugorzêdny numer urz±dzenia 64. Prawa odczytu/zapisu ustawione s± dla 
u¿ytkowników nale¿±cych do grupy <tt>dialout</tt> i 
<item><file>/dev/zero</file> posiada pierwszorzêdny numer urz±dzenia 1 oraz
drugorzêdny numer urz±dzenia 5. Prawa odczytu/zapisu ustawione s± dla 
wszystkich.
</list>
<p>
W starszych systemach, proces instalacyjny tworzy³ wêz³y urz±dzeñ przy u¿yciu
polecenia <prgn>/sbin/MAKEDEV</prgn>. Patrz <manref name="MAKEDEV" section="8">.
<p>
W systemach nowszych, system plików <file>/dev</file> jest automatycznie
zape³niany przez urz±dzenie systemu plików podobne do <file>/proc</file>.

<sect1 id="procfs">System plików <file>/proc</file>
<p>
<!-- modified heavily, original from Debian Guide -->
System plików <file>/proc</file> jest tak naprawdê pseudo-systemem plików,
który zawiera informacje o systemie oraz uruchomionych w nim procesach.
<p>
Ludzie czêsto nie wiedz± co robiæ, gdy zauwa¿aj± do¶æ du¿y plik w  
<file>/proc/kcore</file>. Jest to mniej wiêcej kopia pamiêci Twojego 
komputera. U¿ywana jest do diagnozowania j±dra. Obecnie ten plik nie 
istnieje, wiêc nie martw siê o jego wielko¶æ. 
<p>
Patrz <ref id="proc-sys"> and <manref name="proc" section="5">.

<sect id="xtuto">System X Window
<p>
<!-- practically new content -->
Patrz <ref id="x">.

<sect1 id="xstart">Uruchamianie systemu X Window
<p>
System X Window mo¿e byæ uruchamiany automatycznie z podobnym do
<prgn>xdm</prgn> graficznym demonem logowania lub poprzez wpisanie w konsoli:
console.
<example>
$ exec startx
</example>

<sect1 id="xmenu">Menu systemu X Window
<p>
Od kiedy ¶rodowisko X potrafi pomie¶ciæ wiele mened¿erów okien, zmieni³
siê znacz±co interfejs u¿ytkownika. Zapamiêtaj, ¿e zawsze po naci¶niêciu 
prawego guzika myszy w g³ównym oknie mened¿era, ujrzysz rozwijalne menu.
<list compact>
<item>Aby uruchomiæ pow³okê, wybierz z menu program Xterm:
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>Aby przegl±daæ strony internetowe w trybie graficznym, wybierz Mozillê:
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>Aby przegl±daæ pliki PDF w trybie graficznym, wybierz Xpdf:
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
Je¶li nie mo¿esz znale¿æ którego¶ programu w menu, zainstaluj odpowiednie 
pakiety. Patrz <ref id="apt-install">.

<sect1 id="xkeys">Skróty klawiszowe w systemie X Window
<p>
Poni¿ej lista wa¿niejszych sekwencji klawiszy, przydatnych podczas pracy 
w systemie X Window.
<list compact>
<item>Ctrl-Alt-F1 do F6: Prze³±cza na inne pseudo-terminale (podobnie do 
systemów X window, DOSEMU, itp.)
<item>Alt-F7:               Prze³±cza z powrotem do systemu X Window
<item>Ctrl-Alt-minus:       Zmienia rozdzielczo¶æ w systemie X Window (minus
odnosi siê do klawisza na klawiaturze numerycznej)
<item>Ctrl-Alt-plus:        Zmienia rozdzielczo¶æ w przeciwn± stronê
w systemie X Window (plus odnosi sie do klawisza na klawiaturze numerycznej)
<item>Ctrl-Alt-Backspace:   Koñczy dzia³anie X Serwera
<item>Alt-X, Alt-C, Alt-V:  Standardowe kombinacje klawiszy: wycinanie, 
kopiowanie oraz wklejanie dzia³aj±ce tak jak w systemach Windows/Mac. W
niektórych programach powy¿sze kombinacje z klawiszem Alt zosta³y zast±pione
odpowiednimi kombinacjami z klawiszem Ctrl, na przyk³±d w Netscape Composer..
</list>

<sect id="cmd-study">Dalsza nauka
<p>
Na tym etapie wiedzy, polecam Ci zaznajomienie siê z kluczowymi ksi±¿kowymi
przewodnikami ze strony 
<url id="&tldp-guide;" name="The Linux Documentation Project: Guides">:
<list compact>
<item>"The Linux System Administrators' Guide",
<list compact>
<item>Opisuje wszelkie aspekty dotycz±ce utrzymania systemu na chodzie, 
w³±czaj±c w to konta u¿ytkownikóa, kopie zapasowe oraz konfigurowanie systemu.
<item>pakiet: <package>&p-sysadmin-guide;</package>
<item>plik: <url id="&f-sysadmin-guide;">
<item>strona: <url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition",
<list compact>
<item>Jest to podrêcznik administracji sieci± w ¶rodowisku Linux.
<item>pakiet: <package>&p-netadmin-guide;</package>
<item>plik: <url id="&f-netadmin-guide;">
<item>strona: <url id="&w-netadmin-guide;">
</list>
 <item>"Linux: Rute User's Tutorial and Exposition"
 <list compact>
  <item>A nice online and hardcover book covering GNU/Linux system 
        administration.
  <item>By Paul Sheer
  <item>Published by Prentice Hall
  <item>Package: <package>&p-rutebook;</package> (from <tt>non-free</tt>)
  <item>File: <file>&f-rutebook;</file>
  <!--
  <item>Web: <url id="&rutehome;">
  -->
 </list>
</list>
<p>
Zobacz <ref id="support"> po wiêcej materia³ów do nauki.

</chapt>

