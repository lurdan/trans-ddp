<!-- CVS revision of this document "$Revision: 1.12 $"  -->
<!-- CVS revision of original english document "1.30"  -->

<chapt id="program">Programmazione
<p>
Non usate "test" come nome di un file eseguibile di prova. <prgn>test</prgn> è un
comando interno di shell.

<sect>Dove iniziare
<p>
Riferimenti:
<list compact>
<item>Documenti ed esempi sotto <file>&dochome;<var>pacchetti</var></file>
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
Molti documenti info più lunghi possono essere ottenuti rilegati da 
<url id="&gnuhome;" name="GNU">.
<p>
Le quattro sezioni a seguire contengono dei semplici scripts, in
linguaggi differenti, per creare un file di testo contenente le
informazioni di account, da aggiungere a <file>/etc/passwd</file>, utilizzando un
"batch processor" come il programma <prgn>newusers</prgn>. Ogni script richiede
come input un file con le righe sotto forma di <tt>nome cognome
password</tt>. (Le directory home reali di ciascun utente non vengono
create con questi script.)
</sect>

<sect id="shell">Shell
<p>
Leggere gli shell script è il <strong>miglior</strong> modo per comprendere il 
funzionamento di un sistema tipo Unix.  Qui fornisco alcuni indirizzi per la programmazione
nella shell.

<sect1 id="bash">Bash &ndash la shell interattiva standard <strong>GNU</strong>
<p>
Riferimenti per Bash:
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>l' LDP <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
per iniziare.
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (Installate il pacchetto <package>bash-doc</package> per vedere dei file di esempio.)
<item><em>Learning the bash Shell</em>, Seconda edizione (O'Reilly)
</list>
<p>
Esempio di programma breve (crea delle voci di account per <prgn>newusers</prgn>
a partire da un input standard):
<example>
#!/bin/bash
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">Le shell POSIX
<p>
Parecchi pacchetti forniscono una shell POSIX shell in &debian;:
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priorità: opzionale
  <item>Dimensioni da installato: 176
  <item>Il più piccolo ed estremamente veloce &mdash; ottimo per il boot d'inizio
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priorità: opzionale
  <item>Dimensioni da installato: 180
  <item>Piccolo e veloce &mdash; buono per il boot d'inizio
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essenziale: si
  <item>Priorità: richiesto
  <item>Dimensioni da installato: 580
  <item>Più grosso e ricco di funzioni &mdash; molte le estensioni implementate
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priorità: opzionale
  <item>Dimensioni da installato: 408
  <item>AT&amp;T completo, somiglia a ksh
 </list>
</list>
<p>
Se scrivete uno script che sia portabile, è meglio scriverlo come script
POSIX.  Usate <file>/bin/sh</file> collegato a 
<prgn>ash</prgn> o (<prgn>dash</prgn>) per testarne la complianza con POSIX. 
Evitate di scrivere gli script con dei <strong>bashismi</strong>.

<sect1 id="shell-param">Parametri della shell 
<p>
Ecco parecchi <strong>parametri speciali</strong> da ricordare:
<example compact>
$0      = nome della shell o dello script
$1      = primo(1) argomento della shell
 ...
$9      = nono(9) argomento della shell
$#      = numero dei parametri posizionali
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = stato di uscita del comando più recente
$$      = PID di questo script
$!      = PID del processo più recente lanciato in background
</example>
<p>
<strong>Espansioni dei parametri</strong> basilari da ricordare:
<example compact>
    Forma       Se <var>var</var> è impostata(*)    Se <var>var</var> non è impostata(*)
${<var>var</var>:-<var>stringa</var>}  $<var>var</var>                <var>stringa</var>
${<var>var</var>:+<var>stringa</var>}  <var>stringa</var>              null
${<var>var</var>:=<var>stringa</var>}  $<var>var</var>                <var>stringa</var> 
                                    (e lancia <var>var</var>=<var>stringa</var>)
${<var>var</var>:?<var>stringa</var>}  $<var>var</var>                (echo <var>stringa</var> ed esce)
</example>
I due punti, qui, `:' in tutti questi operatori sono opzionali.
<list compact>
<item>Con `:' = l'operatore fa il test per "esiste" e per "non zero".
<item>Senza `:' = l'operatore fa il test solo per "esiste".
</list>
<p>
<strong>Sostituzioni dei parametri</strong> basilari da ricordare:
<example compact>
    Forma       Risultato
${<var>var</var>&percnt;<var>suffisso</var>}   Rimuove il più piccolo pattern <var>suffisso</var>
${<var>var</var>&percnt;&percnt;<var>suffisso</var>}  Rimuove il più largo pattern <var>suffisso</var>
${<var>var</var>#<var>prefisso</var>}   Rimuove il più piccolo pattern <var>prefisso</var>
${<var>var</var>##<var>prefisso</var>}  Rimuove il più largo pattern <var>prefisso</var>
</example>

<sect1 id="shell-redirect">Redirezione 
<p>
<strong>Redirezione</strong> basilare da ricordare (dove [n] è un numero opzionale):
<example compact>
[n]&gt; <var>file</var>     Redireziona l'output standard (o n) a <var>file</var>.
[n]&gt;&gt; <var>file</var>    Aggiunge l'output standard (o n) a <var>file</var>.
[n]&lt; <var>file</var>     Redireziona l'input standard (o n) da <var>file</var>.
[n1]&gt;&amp;n2      Redireziona l'output standard (o n1) a n2.
&gt; <var>file</var> &gt;&2    Redireziona l'output standard e di errore a <var>file</var>.
| <var>comando</var>     Con una pipe invia l'output standard (o n) a <var>comando</var>.
&gt;&2 | <var>comando</var> Coun una pipe invia l'output standard e di errore a <var>comando</var>.
</example>

<sect1 id="shell-cond">Condizionali
<p>
Ciascun comando ritorna uno <strong>stato di uscita</strong> che può essere utilizzato per 
le espressioni condizionali:
<list compact>
<item>Successo: 0 (Vero)
<item>Errore: 1 - 255 (Falso)
</list>
Notate che l'utilizzo del valore 0 per "vero" differisce dalle convenzioni
usuali in altre aree di programmazione.
In aggiunta, `[' è l'equivalente del comando <prgn>test</prgn>, che
valuta i suoi argomenti fino a `]' come espressione condizionale.
<p>
<strong>Idiomi condizionali</strong> basilari da ricordare sono:
<example compact>
<var>comando</var> && <var>se_successo_lancia_anche_questo_comando</var>
<var>comando</var> || <var>se_non_ha_successo_lancia_anche_questo_comando</var>

if [ <var>espressione_condizionale</var> ]; then  
 <var>se_ha_successo_lancia_anche_questo_comando</var>
else
 <var>se_non_ha_successo_lancia_anche_questo_comando</var>
fi
</example>
<p>
Gli operatori per la comparazione dei <strong>file</strong> nelle espressioni condizionali sono:
<example compact>
-e <var>file</var>         Vero se <var>file</var> esiste.
-d <var>file</var>         Vero se <var>file</var> esiste ed è una directory.
-f <var>file</var>         Vero se <var>file</var> esiste ed è un file regolare.
-w <var>file</var>         Vero se <var>file</var> esiste ed è scrivibile.
-x <var>file</var>         Vero se <var>file</var> esiste ed è eseguibile.
<var>file1</var> -nt <var>file2</var> Vero se <var>file1</var> è più recente di <var>file2</var>. (modificato)
<var>file1</var> -ot <var>file2</var> Vero se <var>file1</var> è più vecchio di <var>file2</var>. (modificato)
<var>file1</var> -ef <var>file2</var> Vero se se sono gli stessi numeri di inode e device.
</example>
<p>
Gli operatori di comparazione delle <strong>stringhe</strong> nelle espressioni condizionali sono:
<example compact>
     -z <var>str</var>    Vero se la lunghezza di <var>str</var> è zero.
     -n <var>str</var>    Vero se la lunghezza di <var>str</var> è non-zero.
<var>str1</var> == <var>str2</var>   Vero se <var>str</var> sono uguali.
<var>str1</var> = <var>str2</var>    Vero se <var>str</var> sono uguali.
               ( = può essere usato al posto di == )
<var>str1</var> != <var>str2</var>   Vero se <var>str</var> non sono uguali.
<var>str1</var> &lt;  <var>str2</var>   Vero se <var>str1</var> viene prima di <var>str2</var> (dipende da locale).
<var>str1</var> &gt;  <var>str2</var>   Vero se <var>str1</var> viene dopo <var>str2</var> (dipende da locale).
</example>
<p>
Gli operatori <strong>aritmetici</strong> di comparazione degli interi nelle 
espressioni condizionali sono <tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>, 
<tt>-le</tt>, <tt>-gt</tt>, o <tt>-ge</tt>.
</sect1>

<sect1 id="clprocess">Processamento delle righe di comando
<p>
La shell processa uno script come segue:
<list compact>
<item>divide in <strong>tokens</strong> sulla base dei metacaratteri: SPACE, TAB, NEWLINE, ;, (, ), &lt;, &gt;, |, &amp;
<item>controlla le <strong>keyword</strong> se non sono contenute fra "..." o '...' (loop)
<item>espande gli <strong>alias</strong> se non sono contenuti fra "..." o '...' (loop)
<item>espande le <strong>parentesi graffe</strong>, A{b|c} -> Ab Ac, se non sono contenute fra "..." o '...'
<item>espande le <strong>tilde</strong>, ~<var>user</var> -> $HOME/$USER, se non sono contenute fra "..." o '...'
<item>espande <strong>parametro</strong>, $<var>PARAMETRO</var>, se non è contenuto fra '...'
<item>espande la <strong>sostituzione del comando</strong>, $(<var>comando</var>), se non è contenuta fra '...'
<item>divide in <strong>parole</strong> con $IFS se non sono contenute fra "..." o '...'
<item>espande il <strong>pathname</strong> *?[] se non è contenuto fra "..." o '...'
<item>cerca <strong>comando</strong>
<list compact>
<item>funzione
<item>built-in
<item>file in $PATH
</list>
<item>loop
</list>
<p>
Le virgolette semplici all'interno delle doppie non hanno effetto.

</sect1>

</sect>

<sect>Awk
<p>
Referimenti per Awk:
<list compact>
<item><em>Effective awk Programming</em>, Terza edizione (O'Reilly)
<item><em>Sed &amp; awk</em>, Seconda edizione (O'Reilly)
<item><manref name="mawk" section="1"> ed <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
Esempio di programma breve (crea delle voci di account per <prgn>newusers</prgn>):
<example>
#!/usr/bin/awk -f
# Script per creare un file utilizzabile con il comando 'newusers',
# a partire da un file che contiene user IDs e passwords sotto forma di:
# Nome Cognome password
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
          "...where startUID is the starting userid " \
          "to add, and file is \n" \
          "an input file in form firstname last name password\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Starting UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
Due sono i pacchetti che forniscono il POSIX <package>awk</package> in &debian;:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priorità: richiesto
  <item>Dimensioni da installato: 228
  <item>Più piccolo è molto più veloce &mdash; ottimo per l'installazione base
  <item>Esiste un limite di tempo di compilazione
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priorità: opzionale
  <item>Dimensioni da installato: 1708
  <item>Più grande e ricco di funzioni &mdash; molte le estensioni implementate
  <list compact>
   <item>versione UNIX System V Release 4
   <item>awk dei Bell Labs
   <item>GNU-specifico
  </list>
 </list>
</list>
</sect>

<sect>Perl
<p>
Questo è <strong>l'</strong> interprete su un sistema simil-Unix.
<p>
Riferimenti per Perl:
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, Terza edizione (O'Reilly)
</list>
<p>
Esempio di programma breve (crea delle voci di account per <prgn>newusers</prgn>):
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Installate Perl module &lt;module name&gt;:
<example>
# perl -MCPAN -e 'install &lt;module name&gt;'
</example>
 
</sect>

<sect>Python
<p>
E' un valido interprete object-oriented.
<p>
Riferimenti per Python:
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
</list>
<p>
Esempio di programma breve (crea delle voci di account per <prgn>newusers</prgn>):
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input file name. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirstname lastname password\n"
                return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crash with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>Make
<p>
Riferimenti per Make:
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, Seconda edizione (O'Reilly)
</list>
<p>
Semplici variabili automatiche:
<p>
Regole di sintassi:
<example>
<var>Obiettivo</var>: [ <var>Prerequisito</var> ... ]
 [TAB] <var>command1</var>
 [TAB] -<var>command2</var> # ignora gli errori
 [TAB] @<var>command3</var> # sopprime l'echoing
</example>
Qui <tt>[TAB]</tt> è un codice TAB.
Ogni riga viene interpretata dalla shell dopo la sostituzione della variabile da parte di make. 
Usate <tt>\</tt> alla fine della riga per continuare a capo lo script.
Usate <tt>$$</tt> per <tt>$</tt> per le variabili d'ambiente dello shell script.
<p>
Regola delle equivalenze implicite:
<example>
.c:   header.h == &percnt;  : &percnt;.c header.h
.o.c: header.h == &percnt;.c: &percnt;.o header.h
</example>
Variabili automatiche per le summenzionate regole:
<example>
foo.o: new1.c new2.c.c old1.c new3.c
$@ == foo.o                         (obiettivo)
$< == new1.c                        (il primo)
$? == new1.c new2.c new3.c          (i più recenti)
$^ == new1.c new2.c.c old1.c new3.c (tutti)
$* == `&percnt;' motivo corrispondente al motivo obiettivo.
</example>
Riferimenti delle variabili:
<example>
foo1 := bar    # Espansione unica
foo2  = bar    # Espansione ricorsiva
foo3 += bar    # Appendi
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Estrae la "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Per vedere le regole interne automatiche, lanciate <tt>make -p -f/dev/null</tt>. 
</sect>

<sect>C
<p>
Preparazione:
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
Riferimenti per C:
<list compact>
<item><tt>info libc</tt> (riferimento della libreria funzioni in C)
<item><manref name="gcc" section="1">
<item><manref name="<var>each_C_library_function_name</var>" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 
 Seconda edizione (Prentice Hall).
</list>
<p>

<sect1>Un semplice programma in C (<prgn>gcc</prgn>)
<p>
Un semplice esempio di compilazione di <prgn>example.c</prgn>, con una libreria <prgn>libm</prgn> in un eseguibile <prgn>run_example</prgn>:
<example>
$ cat &gt; example.c &lt;&lt; EOF 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* prevent buffer overflow */
        y[10] = '\0'; /* fill to make sure string ends with '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
    1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
    2, 3.082, ./run_exam, 1234567890qwerty
</example>
Qui, <tt>-l<strong>m</strong></tt> è necessario per il link della libreria
<tt>lib<strong>m</strong></tt> per sqrt().  La libreria vera è in <file>/lib</file> con il nome
<file>libm.so.6</file>, link simbolico a <file>libm-2.1.3.so</file>.
<p>
Guardate l'ultimo parametro nel testo risultante. Ci sono più di 10
caratteri, anche se viene specificato <tt>&percnt;10s</tt>.
<p>
L'uso di puntatori di funzioni che richiedano operazioni in memoria
senza controlli sui loro "confini", tipo <prgn>sprintf</prgn> e <prgn>strcpy</prgn>, non è
considerato sufficiente a prevenire gli effetti di exploit tipo buffer
overflow, che annullano gli effetti di overrun. Utilizzate, invece,
<prgn>snprintf</prgn> e <prgn>strncpy</prgn>.
</sect1>

<sect1>Debugging

<sect2>Debugging con <prgn>gdb</prgn>
<p>
Preparazione:
<example>
# apt-get install gdb
</example>
<p>
Riferimenti per <prgn>gdb</prgn>:
<list compact>
<item><tt>info gdb</tt> (tutorial)
<item><manref name="gdb" section="1">
</list>
<p>
Per il debugging di un programma compilato con l'opzione <tt>-g</tt>, usate
<prgn>gdb</prgn>. Molti comandi possono essere abbreviati. L'espansione del comando
mediante tab funziona come per la shell.
<example>
$ gdb program
(gdb) b 1                # imposta il punto di interruzione alla riga 1
(gdb) run <var>arg1 arg2 arg3</var> # lancia il programma
(gdb) next               # riga successiva
...
(gdb) step               # un passo avanti
...
(gdb) p parm             # stampa parm 
...
(gdb) p parm=12          # imposta il valore di parm a 12
</example>
<p>
Anche i seguenti comandi possono essere utili.
<list>
<item><prgn>ldd</prgn>:    stampa le dipendenze delle librerie condivise
<item><prgn>strace</prgn>: traccia le chiamate di sistema ed i segnali
<item><prgn>ltrace</prgn>: traccia le chiamate alle librerie
</list>
<p>
Per il debugging da emacs, fate riferimento a <ref id="editkey">.
</sect2>

<sect2 id="ss-ldd">Controllo delle dipendenze dalle librerie
<p>
Usate <prgn>ldd</prgn> per scoprire da quali librerie dipende un programma:
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
Affinchè <prgn>ls</prgn> funzioni in un ambiente <prgn>chroot</prgn>ato le librerie di 
cui sopra devono essere disponibili all'interno dell'ambiente <prgn>chroot</prgn>ato.
<p>
Utili anche i seguenti comandi:
<list compact>
<item><prgn>strace</prgn>: traccia le chiamate di sistema ed i segnali
<item><prgn>ltrace</prgn>: traccia le chiamate alle librerie
</list>
</sect2>

<sect2>Debugging con gli strumenti per scoprire i memory leak
<p>
Parecchi sono gli strumenti per il riconoscimento dei memory leak in &debian;.
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package>
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> da
  <url id="&parasofthome;" name="Parasoft">. (non-free, commerciale, a pagamento)
</list>
<p>
Vedere anche <url id="&mallocdebughome;" 
  name="Debugging Tools for Dynamic Storage Allocation and Memory Management">.

<sect1>Flex &ndash; una miglior... Lex
<p>
<prgn>flex</prgn> è un veloce generatore ed analizzatore lessicale.
<p>
Riferimenti per <prgn>flex</prgn>:
<list compact>
<item><tt>info flex</tt> (tutorial)
<item><manref name="flex" section="1">
</list>
<p>
Al vostro programma dovete fornire una propria <prgn>main()</prgn> e <prgn>yywrap()</prgn>,
altrimenti <prgn>program.l</prgn> apparirà come nell'esempio qui sotto, tentando la
compilazione senza librerie (<prgn>yywrap</prgn> è una macro; <tt>&percnt;option main</tt>
diventa implicitamente <tt>&percnt;option noyywrap</tt>):
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
In alternativa, potete compilarlo con l'opzione -<tt>lfl</tt> al
termine della riga di comando cc (tipo ATT-Lex con -<tt>ll</tt>). In
questo caso nessuna <tt>&percnt;option</tt> è richiesta.
</sect1>

<sect1>Bison &ndash; un Yacc migliore
<p>
Alcuni pacchetti forniscono un LALR parser generator Yacc-compatible in &debian;:
<p>
<list compact>
 <item><package>bison</package>: GNU LALR parser generator
 <item><package>byacc</package>: Il Berkeley LALR parser generator
 <item><package>byyacc</package>: Backtracking parser generator basato su byacc
</list>
<p>
Riferimenti per <prgn>bison</prgn>:
<list compact>
<item><tt>info bison</tt> (tutorial)
<item><manref name="bison" section="1">
</list>
<p>
Dovete fornire la vostra <prgn>main()</prgn> e
<prgn>yyerror()</prgn>. <prgn>main()</prgn> chiama <prgn>yyparse()</prgn> che
chiama <prgn>yylex()</prgn>, normalmente creata con FleX.
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> è uno strumento per produrre degli shell script in grado
di configurare automaticamente il codice sorgente dei programmi usando
l'intero sistema di compilazione GNU, adattandoli a molti tipi di sistema
simil-Unix.  
<p>
<prgn>autoconf</prgn> produce lo script di configurazione 
<prgn>configure</prgn>.  <prgn>configure</prgn> 
crea automaticamente un <prgn>Makefile</prgn> personalizzato e
<prgn>Makefile.am</prgn>.
 
<sect2>Compilare ed installare un programma
<p>
&debian; non tocca i file in <file>/usr/local</file> (vedere 
<ref id="diverse">). Quindi, se compilate un programma dai sorgenti, installatelo 
in <file>/usr/local</file>, così non interferirà con &debian;.
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # questo comando mette i file nel sistema
</example>

<sect2>Disinstallare un programma
<p>
Se avete ancora il sorgente e Se utilizza <prgn>autoconf</prgn>/<prgn>automake</prgn> e 
se ricordate come l'avete configurato:
<example>
$ ./configure <var>tutte-le-opzioni-che-avevate-dato</var>
# make uninstall
</example>
<p>
In alternativa, se siete assolutamente sicuri che il processo di installazione
pone i file solo sotto <file>/usr/local</file> e che non c'è nulla di
importante lì, potete cancellarne utto il contenuto con:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
Se non siete sicuri di dove i file siano installati, dovreste prendere in
considerazione l'uso di <package>checkinstall</package>, che fornisce un
percorso pulito per la disinstallazione.
</sect1>

</sect>

<sect>Preparazione di documenti
<p>

<sect1><tt>roff</tt> 
<p>
Tradizionalmente, <tt>roff</tt> è il principale sistema di scrittura testo in Unix.
<p>
Vedere <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7">, ed
"<tt>info groff</tt>".
<p>
Esiste un buon tutorial sulle macro <prgn>-me</prgn>.
Se avete groff (1.18 o più recente), trovate <file>&f-meintro;</file> e
fate quanto segue:
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
Quanto segue profurrà un file totalmente in formato testo:
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
Per la stampa, usate l'output PostScript.
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>

<sect>SGML
<p>
Preparazione:
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
Riferimenti per <prgn>debiandoc-sgml</prgn>:
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em>DocBook: The Definitive Guide</em>, di Walsh and Muellner (O'Reilly)
</list>
<p>
SGML permette la gestione dei formati multipli dei documenti. Un
sistema SGML semplice è Debiandoc, utilizzato qui. Richiede delle
comversioni minori dai files di testo originali per i seguenti
caratteri:
<example>
&lt;   &amp;lt;
&gt;   &amp;gt;
"&nbsp;" "&amp;nbsp;"  (spazio non divisibile)
&amp;   &amp;amp;
&percnt; &amp;percnt; &copy; &amp;copy; &ndash; &amp;ndash; &mdash;
&amp;mdash;
</example>
Per marcare una sezione come commento non stampabile, date:
<example>
&lt;!-- Il commento va qui ... --&gt;
</example>
Per marcare una sezione con un commento modificabile, date:
<example>
&lt;![ &percnt;FIXME [ Il commento va qui ... ]]&gt;
</example>
In SGML, la <em>prima definizione</em> di un'entità vince. Per esempio:
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt; &lt;![ &percnt;qref [ &lt;!entity
param "Data 1"&gt; ]]&gt; &lt;!entity param "Data 2"&gt; &amp;param;
</example>
Questa termina come "Data 1". Se la prima riga è, invece, "IGNORE", questa
terminerà come "Data 2" (La seconda riga è un'affermazione
condizionale). Anche le frasi ripetute possono essere definite a priori,
separatamente dal contesto.
<example>
&lt;!entity <var>dichièquesto</var> "mio"&gt;
Ciao amico &amp;<var>dichièquesto</var>;.
Questo è il &amp;<var>dichièquesto</var>; libro.
</example>
Che dà ciò come risultato:
<example>
Ciao amico mio.
Questo è il mio libro.
</example>
Vedere il breve esempio in SGML <file>sample.sgml</file> in 
<url id="&examples;" name="esempi">.
<p>
Quando i documenti SGML diventano voluminosi, talvolta TeX può dare degli errori.
Dovete, in tal caso, aumentare le dimensioni del pool in <file>/etc/texmf/texmf.cnf</file> (o, più
appropriatamente modificate <file>/etc/texmf/texmf.d/95NonPath</file> e lanciate 
<prgn>update-texmf</prgn>) per risolvere questo problema.
</sect>

<sect id="packaging">Creare pacchetti debian
<p>
Preparazione:
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
        &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # se su Potato
</example>
Riferimenti per il packaging:
<list compact>
 <item><ref id="pkg-basics"> (basi)
 <item>Debian New Maintainers' Guide (tutorial)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (migliore dal punto di vista pratico)
 <item>Debian Policy Manual (autorevole)
 <item>Packaging Manual (Potato) 
</list>

<sect1 id="pack-binary">Impacchettare un singolo binario
<p>
Metodo spiccio per impacchettare un singolo binario, da Joey Hess.
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: miopacchetto
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: il mio piccolo pacchetto
Non vi aspettate granchè.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">Impacchettare con gli strumenti
<p>
Usate <prgn>dh_make</prgn> dal pacchetto <package>dh-make</package> per creare un pacchetto base. 
Poi, procedete secondo le istruzioni contenute in <manref
name="dh-make" section="1">.
Queste usano <prgn>debhelper</prgn> in <prgn>debian/rules</prgn>.  
<p>
Un approccio più datato è quello di usare <prgn>deb-make</prgn> dal pacchetto
<package>debmake</package>. Non usa nessuno script <prgn>debhelper</prgn> e dipende esclusivamente
dalla shell.
<p>
Per degli esempi di pacchetti con sorgenti multipli vedete "mc"
(<tt>dpkg-source -x mc_4.5.54.dsc</tt>), che usa "sys-build.mk" di Adam Heath
(<email>doogie@debian.org</email>) e "glibc" (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>), che usa un altro sistema di Joel Klecker
(<email>espy@debian.org</email>).

</sect>

</chapt>
