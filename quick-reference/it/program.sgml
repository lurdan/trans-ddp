<!-- CVS revision of this document "$Revision: 1.17 $"  -->
<!-- CVS revision of original english document "1.71"  -->
<!-- DON'T TOUCH GROFF SECTION!!! -->

<chapt id="program">Programmazione
<p>
Non usate "test" come nome di un file eseguibile di prova. <prgn>test</prgn> è un
comando interno di shell.

<sect>Dove iniziare
<p>
Riferimenti:
<list compact>
<item>Documenti ed esempi sotto <file>&dochome;<var>pacchetti</var></file>
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
Molti documenti info più lunghi possono essere ottenuti rilegati da 
<url id="&gnuhome;" name="GNU">.
<p>
Le quattro sezioni a seguire contengono dei semplici script, in
linguaggi differenti, per creare un file di testo contenente le
informazioni di account, da aggiungere a <file>/etc/passwd</file>, utilizzando un
processore batch come il programma <prgn>newusers</prgn>. Ogni script richiede
come input un file con le righe sotto forma di <tt>nome cognome
password</tt>. (Le directory home reali di ciascun utente non vengono
create con questi script.)
</sect>

<sect id="shell">Shell
<p>
Leggere gli script della shell è il <strong>miglior</strong> modo per comprendere il 
funzionamento di un sistema tipo Unix.  Qui fornisco alcuni indirizzi per la programmazione
nella shell. Vedere <url id="&shell-mistakes;" name="Errori di Shell"> per
imparare dagli errori.

<sect1 id="bash">Bash &ndash la shell interattiva standard <strong>GNU</strong>
<p>
Riferimenti per Bash:
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>l' LDP <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
per iniziare.
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (Installate il pacchetto <package>bash-doc</package> per vedere dei file di esempio.)
<item><em>Learning the bash Shell</em>, Seconda edizione (O'Reilly)
</list>
<p>
Esempio di programma breve (crea delle voci di account per <prgn>newusers</prgn>
a partire da un input standard):
<example>
#!/bin/bash
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">Le shell POSIX
<p>
Parecchi pacchetti forniscono una shell POSIX shell in &debian;:
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priorità: opzionale
  <item>Dimensioni da installato: 176
  <item>Il più piccolo ed estremamente veloce &mdash; ottimo per il boot d'inizio
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priorità: opzionale
  <item>Dimensioni da installato: 180
  <item>Piccolo e veloce &mdash; buono per il boot d'inizio
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essenziale: si
  <item>Priorità: richiesto
  <item>Dimensioni da installato: 580
  <item>Più grosso e ricco di funzioni &mdash; molte le estensioni implementate
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priorità: opzionale
  <item>Dimensioni da installato: 408
  <item>AT&amp;T completo, somiglia a ksh
 </list>
</list>
<p>
Se scrivete uno script che sia portatile, è meglio scriverlo come script
POSIX.  Usate <file>/bin/sh</file> collegato a 
<prgn>ash</prgn> o (<prgn>dash</prgn>) per testarne la complianza con POSIX. 
Evitate di scrivere gli script con espressioni tipiche di bash o zsh.
Evitate, per esempio:
<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>file</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>
<p>
La descrizione per la shell in questo documenti si applica solo per le shell
POSIX e perciò non si applica alle shell di tipo <prgn>csh</prgn>, inclusa
<prgn>tcsh</prgn>.


<sect1 id="shell-param">Parametri della shell 
<p>
Ecco parecchi <strong>parametri speciali</strong> da ricordare:
<example compact>
$0      = nome della shell o dello script
$1      = primo(1) argomento della shell
 ...
$9      = nono(9) argomento della shell
$#      = numero dei parametri posizionali
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = stato di uscita del comando più recente
$$      = PID di questo script
$!      = PID del processo più recente lanciato in background
</example>
<p>
<strong>Espansioni dei parametri</strong> basilari da ricordare:
<example compact>
    Forma       Se <var>var</var> è impostata(*)    Se <var>var</var> non è impostata(*)
${<var>var</var>:-<var>stringa</var>}  $<var>var</var>                <var>stringa</var>
${<var>var</var>:+<var>stringa</var>}  <var>stringa</var>              null
${<var>var</var>:=<var>stringa</var>}  $<var>var</var>                <var>stringa</var> 
                                    (e lancia <var>var</var>=<var>stringa</var>)
${<var>var</var>:?<var>stringa</var>}  $<var>var</var>                (echo <var>stringa</var> ed esce)
</example>
I due punti, qui, `:' in tutti questi operatori sono opzionali.
<list compact>
<item>Con `:' = l'operatore fa il test per "esiste" e per "non zero".
<item>Senza `:' = l'operatore fa il test solo per "esiste".
</list>
<p>
<strong>Sostituzioni dei parametri</strong> basilari da ricordare:
<example compact>
    Forma       Risultato
${<var>var</var>&percnt;<var>suffisso</var>}   Rimuove il più piccolo pattern <var>suffisso</var>
${<var>var</var>&percnt;&percnt;<var>suffisso</var>}  Rimuove il più largo pattern <var>suffisso</var>
${<var>var</var>#<var>prefisso</var>}   Rimuove il più piccolo pattern <var>prefisso</var>
${<var>var</var>##<var>prefisso</var>}  Rimuove il più largo pattern <var>prefisso</var>
</example>

<sect1 id="shell-redirect">Redirezione 
<p>
<strong>Redirezione</strong> basilare da ricordare (dove [<var>n</var>] 
è un numero opzionale per specificare il descrittore del file):
<example compact>
[<var>n</var>]&gt; <var>file</var>     Redirige l'output standard (o n) a <var>file</var>.
[<var>n</var>]&gt;&gt; <var>file</var>    Aggiunge l'output standard (o n) a <var>file</var>.
[<var>n</var>]&lt; <var>file</var>     Redirige l'input standard (o n) da <var>file</var>.
[<var>n1</var>]&gt;&amp;n2      Redirige l'output standard (o n1) a n2.
&gt; <var>file</var> &gt;&2    Redirige l'output standard e di errore a <var>file</var>.
| <var>comando</var>     Con una pipe invia l'output standard (o n) a <var>comando</var>.
&gt;&2 | <var>comando</var> Coun una pipe invia l'output standard e di errore a <var>comando</var>.
2&gt;&1 | <var>command</var> Pipe stderr and stdout to <var>command</var>.
</example>
Dove,
<list compact>
<item>stdin: standard input (descrittore di file = 0)
<item>stdout: standard output (descrittore di file = 1)
<item>stderr: standard error (descrittore di file = 2)
</list>
<p>
La shell  vi permette di aprire i file mediante <prgn>exec</prgn> con un 
descrittore di file arbitrario.
<example>
$ echo Hello &gt;foo
$ exec 3&lt;foo 4&gt;bar  # apre i file
$ cat &lt;&amp;3 &gt;&amp;4       # redirige stdin a 3, stdout a 4
$ exec 3&lt;&amp;- 4&gt;&amp;-    # chiude i file
$ cat bar
Hello
</example>
Qui <var>n</var><tt>&lt;&amp;-</tt> e <var>n</var><tt>&gt;&amp;-</tt>
significano chiudere il descrittore del file <var>n</var>.

<sect1 id="shell-cond">Condizionali
<p>
Ciascun comando ritorna uno <strong>stato di uscita</strong> che può essere utilizzato per 
le espressioni condizionali:
<list compact>
<item>Successo: 0 (Vero)
<item>Errore: 1 - 255 (Falso)
</list>
Notate che l'utilizzo del valore 0 per "vero" differisce dalle convenzioni
usuali in altre aree di programmazione.
In aggiunta, `[' è l'equivalente del comando <prgn>test</prgn>, che
valuta i suoi argomenti fino a `]' come espressione condizionale.
<p>
<strong>Idiomi condizionali</strong> basilari da ricordare sono:
<example compact>
<var>comando</var> && <var>se_successo_lancia_anche_questo_comando</var>
<var>comando</var> || <var>se_non_ha_successo_lancia_anche_questo_comando</var>

if [ <var>espressione_condizionale</var> ]; then  
 <var>se_ha_successo_lancia_anche_questo_comando</var>
else
 <var>se_non_ha_successo_lancia_anche_questo_comando</var>
fi
</example>
Qui, <tt>|| true</tt> era necessario per assicurarsi che lo script non uscisse
a questa riga accidentalmente, quando la shell era invocata con l'opzione <tt>-e</tt>.
<p>
Gli operatori per la comparazione dei <strong>file</strong> nelle espressioni condizionali sono:
<example compact>
-e <var>file</var>         Vero se <var>file</var> esiste.
-d <var>file</var>         Vero se <var>file</var> esiste ed è una directory.
-f <var>file</var>         Vero se <var>file</var> esiste ed è un file regolare.
-w <var>file</var>         Vero se <var>file</var> esiste ed è scrivibile.
-x <var>file</var>         Vero se <var>file</var> esiste ed è eseguibile.
<var>file1</var> -nt <var>file2</var> Vero se <var>file1</var> è più recente di <var>file2</var>. (modificato)
<var>file1</var> -ot <var>file2</var> Vero se <var>file1</var> è più vecchio di <var>file2</var>. (modificato)
<var>file1</var> -ef <var>file2</var> Vero se se sono gli stessi numeri di inode e device.
</example>
<p>
Gli operatori di comparazione delle <strong>stringhe</strong> nelle espressioni condizionali sono:
<example compact>
     -z <var>str</var>    Vero se la lunghezza di <var>str</var> è zero.
     -n <var>str</var>    Vero se la lunghezza di <var>str</var> è non-zero.
<var>str1</var> == <var>str2</var>   Vero se <var>str</var> sono uguali.
<var>str1</var> = <var>str2</var>    Vero se <var>str</var> sono uguali.
               ("=" dovrebbe essere usato al posto di "==", per una stretta
	       complianza POSIX )
<var>str1</var> != <var>str2</var>   Vero se <var>str</var> non sono uguali.
<var>str1</var> &lt;  <var>str2</var>   Vero se <var>str1</var> viene prima di <var>str2</var> (dipende da locale).
<var>str1</var> &gt;  <var>str2</var>   Vero se <var>str1</var> viene dopo <var>str2</var> (dipende da locale).
</example>
<p>
Gli operatori <strong>aritmetici</strong> di comparazione degli interi nelle 
espressioni condizionali sono <tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>, 
<tt>-le</tt>, <tt>-gt</tt>, o <tt>-ge</tt>.
</sect1>

<sect1 id="clprocess">Processamento delle righe di comando
<p>
La shell processa uno script come segue:
<list compact>
<item>divide in <strong>tokens</strong> sulla base dei metacaratteri: SPACE, TAB, NEWLINE, ;, (, ), &lt;, &gt;, |, &amp;
<item>controlla le <strong>keyword</strong> se non sono contenute fra "..." o '...' (loop)
<item>espande gli <strong>alias</strong> se non sono contenuti fra "..." o '...' (loop)
<item>espande le <strong>parentesi graffe</strong>, A{b|c} -> Ab Ac, se non sono contenute fra "..." o '...'
<item>espande le <strong>tilde</strong>, ~<var>user</var> -> $HOME/$USER, se non sono contenute fra "..." o '...'
<item>espande <strong>parametro</strong>, $<var>PARAMETRO</var>, se non è contenuto fra '...'
<item>espande la <strong>sostituzione del comando</strong>, $(<var>comando</var>), se non è contenuta fra '...'
<item>divide in <strong>parole</strong> con $IFS se non sono contenute fra "..." o '...'
<item>espande il <strong>pathname</strong> *?[] se non è contenuto fra "..." o '...'
<item>cerca <strong>comando</strong>
<list compact>
<item>funzione
<item>built-in
<item>file in $PATH
</list>
<item>loop
</list>
<p>
Le virgolette semplici all'interno delle doppie non hanno effetto.
<p>
Eseguire <tt>set -x</tt> nella shell, o invocarla con l'opzione
<tt>-x</tt> fa sì che stampi tutti i comandi eseguiti.
Molto utile per il debugging.
</sect1>

</sect>

<sect id="awk">Awk
<p>
Riferimenti per Awk:
<list compact>
<item><em>Effective awk Programming</em>, Terza edizione (O'Reilly)
<item><em>Sed &amp; awk</em>, Seconda edizione (O'Reilly)
<item><manref name="mawk" section="1"> e <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
Esempio di programma breve (crea delle voci di account per <prgn>newusers</prgn>):
<example>
#!/usr/bin/awk -f
# Script per creare un file utilizzabile con il comando 'newusers',
# a partire da un file che contiene user IDs e passwords sotto forma di:
# Nome Cognome password
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
          "  where:\n" \ 
          "    startUID is the starting userid to add, and\n" \
          "    file is an input file in form:\n" \
          "      first_name last_name password\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Starting UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
Due sono i pacchetti che forniscono il POSIX <package>awk</package> in &debian;:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priorità: richiesto
  <item>Dimensioni da installato: 228
  <item>Più piccolo è molto più veloce &mdash; ottimo per l'installazione base
  <item>Esiste un limite di tempo di compilazione
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priorità: opzionale
  <item>Dimensioni da installato: 1708
  <item>Più grande e ricco di funzioni &mdash; molte le estensioni implementate
  <list compact>
   <item>versione UNIX System V Release 4
   <item>awk dei Bell Labs
   <item>GNU-specifico
  </list>
 </list>
</list>
</sect>

<sect id="perl">Perl
<p>
Questo è <strong>l'</strong> interprete su un sistema simil-Unix.
<p>
Riferimenti per Perl:
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, Terza edizione (O'Reilly)
<item><url id="&perlhome;" name="La directory Perl">
</list>
<p>
Esempio di programma breve (crea delle voci di account per <prgn>newusers</prgn>):
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Installate il modulo Perl <var>module_name</var>:
<example>
# perl -MCPAN -e 'install <var>module_name</var>'
</example>
 
</sect>

<sect id="python">Python
<p>
E' un valido interprete object-oriented.
<p>
Riferimenti per Python:
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
<item><url id="&pythonhome;" name="Python Programming Language">
</list>
<p>
Esempio di programma breve (crea delle voci di account per <prgn>newusers</prgn>):
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input filename. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirst_name lastname password\n"
                return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crash with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect id="make">Make
<p>
Riferimenti per Make:
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, Seconda edizione (O'Reilly)
</list>
<p>
Semplici variabili automatiche:
<p>
Regole di sintassi:
<example>
<var>target</var>: [ <var>prerequisites</var> ... ]
 [TAB]  <var>command1</var>
 [TAB]  -<var>command2</var> # ignora gli errori
 [TAB]  @<var>command3</var> # sopprime l'eco
</example>
Qui <tt>[TAB]</tt> è un codice TAB.
Ogni riga viene interpretata dalla shell dopo la sostituzione della variabile da parte di make. 
Usate <tt>\</tt> alla fine della riga per continuare a capo lo script.
Usate <tt>$$</tt> per <tt>$</tt> per le variabili d'ambiente dello shell script.
<p>
Le <strong>regole implicite</strong> per <var>target</var> e
<var>prerequisites</var> può essere scritta, per esempio come:
<example>
&percnt;: &percnt;.c header.h
</example>
oppure,
<example>
&percnt;.o: &percnt;.c header.h
</example>
Qui, <var>target</var> contiene il carattere <tt>&percnt;</tt>
(esattamente uno di loro). Il <tt>&percnt;</tt> può corrispondere con
qualsiasi sottostringa non vuota nei file target attuali. Similmente <var>prerequisites</var>
usa <tt>&percnt;</tt> come i loro nomi si correlano al nome del
target attuale.
<p>
Le <strong>regole di suffisso</strong> sono il <strong>vecchio</strong> modo
di definire le regole implicite per <prgn>make</prgn>.  Sono ancora supportate
in GNU <prgn>make</prgn> per compatibilità, ma usate quando possibile le
regole equivalenti del modello:
<example>
vecchia regola  --&gt; nuova regola
.c:             --&gt; &percnt;  : &percnt;.c
.c.o:           --&gt; &percnt;.o: &percnt;.c
</example>
Variabili automatiche per le summenzionate regole:
<example>
foo.o: new1.c new2.c old1.c new3.c
$@ == foo.o                         (obiettivo)
$< == new1.c                        (il primo)
$? == new1.c new2.c new3.c          (i più recenti)
$^ == new1.c new2.c.c old1.c new3.c (tutti)
$* == `&percnt;' motivo corrispondente al motivo obiettivo.
</example>
Riferimenti delle variabili:
<example>
foo1 := bar    # Espansione unica
foo2  = bar    # Espansione ricorsiva
foo3 += bar    # Appendi
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Estrae la "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Per vedere le regole interne automatiche, lanciate <tt>make -p -f/dev/null</tt>. 
</sect>

<sect>C
<p>
Preparazione:
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
Riferimenti per C:
<list compact>
<item><tt>info libc</tt> (riferimento della libreria funzioni in C)
<item><manref name="gcc" section="1">
<item><manref name="<var>qualsiasi_nome_funzione_libreria_C</var>" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 
 Seconda edizione (Prentice Hall).
</list>
<p>

<sect1>Un semplice programma in C (<prgn>gcc</prgn>)
<p>
Un semplice esempio di compilazione di <prgn>example.c</prgn>, con una 
libreria <prgn>libm</prgn> in un eseguibile <prgn>run_example</prgn>:
<example>
$ cat &gt; example.c &lt;&lt; EOF 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* prevent buffer overflow */
        y[10] = '\0'; /* fill to make sure string ends with '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
    1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
    2, 3.082, ./run_exam, 1234567890qwerty
</example>
Qui, <tt>-l<strong>m</strong></tt> è necessario per il collegamento della libreria
<tt>lib<strong>m</strong></tt> per <prgn>sqrt()</prgn>.  La libreria vera è in <file>/lib</file> con il nome
<file>libm.so.6</file>, collegamento simbolico a <file>libm-2.1.3.so</file>.
<p>
Guardate l'ultimo parametro nel testo risultante. Ci sono più di 10
caratteri, anche se viene specificato <tt>&percnt;10s</tt>.
<p>
L'uso di puntatori di funzioni che richiedano operazioni in memoria
senza controlli sui loro "confini", tipo <prgn>sprintf</prgn> e <prgn>strcpy</prgn>, non è
considerato sufficiente a prevenire gli effetti di exploit tipo buffer
overflow, che annullano gli effetti di overrun. Utilizzate, invece,
<prgn>snprintf</prgn> e <prgn>strncpy</prgn>.
</sect1>

<sect1>Debugging

<sect2>Debugging con <prgn>gdb</prgn>
<p>
Preparazione:
<example>
# apt-get install gdb
</example>
<p>
Riferimenti per <prgn>gdb</prgn>:
<list compact>
<item><tt>info gdb</tt> (tutorial)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>
<p>
Per il debugging di un programma compilato con l'opzione <tt>-g</tt>, usate
<prgn>gdb</prgn>. Molti comandi possono essere abbreviati. L'espansione del comando
mediante tab funziona come per la shell.
<example>
$ gdb program
(gdb) b 1                # imposta il punto di interruzione alla riga 1
(gdb) run <var>arg1 arg2 arg3</var> # lancia il programma
(gdb) next               # riga successiva
...
(gdb) step               # un passo avanti
...
(gdb) p parm             # stampa parm 
...
(gdb) p parm=12          # imposta il valore di parm a 12
</example>
<p>
Per il debugging da emacs, fate riferimento a <ref id="editkey">.
<p>
Dato che tutti i binari installati devono essere adattati al sistema &debian;
in maniera predefinita, gran parte dei simboli di debug sono stati rimossi.
Per rendere <prgn>gdb</prgn> utile per il debug dei pacchetti &debian;, i pacchetti 
pertinenti devono essere ricompilati con la cura seguente:
<list compact>
<item>Modificate <file>debian/control</file> per eliminare il pacchetto
<url id="&policy-version;" name="version">. 
<item>Controllate gli script di compilazione ed assicuratevi che usino <tt>CFLAGS=-g
-Wall</tt> per compilare i binari.
<item>Esportate <tt>DEB_BUILD_OPTIONS=nostrip,noopt</tt> per compilare il
pacchetto &debian;.
</list>
Vedere <url name="Policy 10.1" id="&strip-symbols;"> per maggiori
informazioni.
</sect2>

<sect2 id="ss-ldd">Controllo delle dipendenze dalle librerie
<p>
Usate <prgn>ldd</prgn> per scoprire da quali librerie dipende un programma:
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
Affinchè <prgn>ls</prgn> funzioni in un ambiente <prgn>chroot</prgn> le librerie di 
cui sopra devono essere disponibili all'interno di esso.
<p>
Utili anche i seguenti comandi:
<list compact>
<item><prgn>strace</prgn>: traccia le chiamate di sistema ed i segnali
<item><prgn>ltrace</prgn>: traccia le chiamate alle librerie
</list>
</sect2>

<sect2>Debugging con gli strumenti per scoprire i memory leak
<p>
Parecchi sono gli strumenti per il riconoscimento dei memory leak in &debian;.
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (non è impacchettato, prendetelo da
 <url id="&memwatch-home;" name="memwatch">.)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> da
  <url id="&parasofthome;" name="Parasoft">. (non-free, commerciale, a pagamento)
</list>
<p>
Vedere anche <url id="&mallocdebughome;" 
  name="Debugging Tools for Dynamic Storage Allocation and Memory Management">.

<sect1>Flex &ndash; un miglior Lex
<p>
<prgn>flex</prgn> è un veloce generatore ed analizzatore lessicale.
<p>
Riferimenti per <prgn>flex</prgn>:
<list compact>
<item><tt>info flex</tt> (tutorial)
<item><manref name="flex" section="1">
</list>
<p>
Al vostro programma dovete fornire una propria <prgn>main()</prgn> e <prgn>yywrap()</prgn>,
altrimenti <prgn>program.l</prgn> apparirà come nell'esempio qui sotto, tentando la
compilazione senza librerie (<prgn>yywrap</prgn> è una macro; <tt>&percnt;option main</tt>
diventa implicitamente <tt>&percnt;option noyywrap</tt>):
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
In alternativa, potete compilarlo con l'opzione -<tt>lfl</tt> al
termine della riga di comando <tt>cc</tt> (tipo AT&amp;T-Lex con -<tt>ll</tt>). In
questo caso nessuna <tt>&percnt;option</tt> è richiesta.
</sect1>

<sect1>Bison &ndash; un Yacc migliore
<p>
Alcuni pacchetti forniscono un LALR parser generator Yacc-compatibile in &debian;:
<p>
<list compact>
 <item><package>bison</package>: GNU LALR parser generator
 <item><package>byacc</package>: Il Berkeley LALR parser generator
 <item><package>btyacc</package>: Backtracking parser generator basato su byacc
</list>
<p>
Riferimenti per <prgn>bison</prgn>:
<list compact>
<item><tt>info bison</tt> (tutorial)
<item><manref name="bison" section="1">
</list>
<p>
Dovete fornire la vostra <prgn>main()</prgn> e
<prgn>yyerror()</prgn>. <prgn>main()</prgn> chiama <prgn>yyparse()</prgn> che
chiama <prgn>yylex()</prgn>, normalmente creata con FleX.
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> è uno strumento per produrre degli shell script in grado
di configurare automaticamente il codice sorgente dei programmi usando
l'intero sistema di compilazione GNU, adattandoli a molti tipi di sistema
simil-Unix.  
<p>
<prgn>autoconf</prgn> produce lo script di configurazione 
<prgn>configure</prgn>.  <prgn>configure</prgn> 
crea automaticamente un <prgn>Makefile</prgn> personalizzato e
<prgn>Makefile.am</prgn>.
 
<sect2>Compilare ed installare un programma
<p>
&debian; non tocca i file in <file>/usr/local</file> (vedere 
<ref id="diverse">). Quindi, se compilate un programma dai sorgenti, installatelo 
in <file>/usr/local</file>, così non interferirà con &debian;.
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # questo comando mette i file nel sistema
</example>

<sect2>Disinstallare un programma
<p>
Se avete ancora il sorgente e Se utilizza <prgn>autoconf</prgn>/<prgn>automake</prgn> e 
se ricordate come l'avete configurato:
<example>
$ ./configure <var>tutte-le-opzioni-che-avevate-dato</var>
# make uninstall
</example>
<p>
In alternativa, se siete assolutamente sicuri che il processo di installazione
pone i file solo sotto <file>/usr/local</file> e che non c'è nulla di
importante lì, potete cancellarne utto il contenuto con:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
Se non siete sicuri di dove i file siano installati, dovreste prendere in
considerazione l'uso di <package>checkinstall</package>, che fornisce un
percorso pulito per la disinstallazione.
</sect1>

</sect>
<sect id="cgi">Web
<p>
Pagine web interattive dinamiche basilari possono essere create come segue:
<list compact>
<item>Le query vengono presentate al browser mediante form HTML.
<item>Riempire e cliccare le voci del form invia una URL con i parametri
codificati.
<footnote>
Qui, <tt>%nn</tt> è usato per il carattere codificato dell'esadecimale
<tt>nn</tt>.
</footnote>
dal browser al server web.  Per esempio:
<list compact>
<item><tt>http://www.foo.dom/cgi-bin/program.pl?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.foo.dom/cgi-bin/program.py?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.foo.dom/program.php?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
</list>
<item>Il programma CGI (uno qualsiasi di <prgn>program.*</prgn>) sul server web
riceverà i parametri codificati "<tt>VAR1=VAL1 VAR2=VAL2 VAR3=VAL3</tt>" come
contenuto della variabile di ambiente "<tt>QUERY_STRING</tt>"  ed esegue sè
stesso.
<item>Lo <tt>stdout</tt> del programma viene inviato al browser e presentato
come pagina web dinamica interattiva.
</list>
Per motivi di sicurezza è meglio non fare modifiche a mano dei parametri per
il processamento CGI. per loro esistono dei moduli già stabiliti in Perl
(vedere <ref id="perl">) e Python (vedere <ref id="python">).  <url id="&phphome;"
name="PHP"> arriva con queste funzionalità. Quando si richiede
l'immagazzinamento dei dati del client, si usano i cookie..  Quando ne è richiesto il 
processamento, su usa frequentemente javascript.
<p>
Per altro, vedere <url id="http://hoohoo.ncsa.uiuc.edu/cgi/" name="The Common
Gateway Interface">, <url id="&apachehome;" name="The Apache Software 
Foundation">, e <url id="&javascripthome;" name="JavaScript">.  
<p>
Cercare su Google "CGI tutorial" digitando l'URL codificata 
<tt>&google-eg;</tt> direttamente nella finestra dell'indirizzo del browser,
è un buon modo per vedere lo script CGI in azione sul server.
<!--
http://www.google.com/search?hl=en&ie=UTF-8&q=CGI+tutorial
http://stein.cshl.org/WWW/CGI/
http://stein.cshl.org/WWW/docs/handout.html
http://stein.cshl.org/WWW/software/mailmerge/
-->

<sect>Preparazione di documenti
<p>

<sect1 id="roff"><tt>roff</tt> 
<p>
Tradizionalmente, <tt>roff</tt> è il principale sistema di scrittura testo in Unix.
<p>
Vedere <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7">, ed
"<tt>info groff</tt>".
<p>
Esiste un buon tutorial sulle macro <prgn>-me</prgn>.
Se avete groff (1.18 o più recente), trovate <file>&f-meintro;</file> e
fate quanto segue:
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
Quanto segue produrrà un file totalmente in formato testo:
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
Per la stampa, usate l'output PostScript.
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>




<sect1 id="sgml">SGML
<p>
Preparazione:
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
Riferimenti per <prgn>debiandoc-sgml</prgn>:
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em><url name="DocBook: The Definitive Guide"
      id="&f-docbook-defguide;"></em>, di Walsh and Muellner (O'Reilly)
      (pacchetto <package>&p-docbook-defguide;</package>)
</list>
<p>
SGML permette la gestione dei formati multipli dei documenti. Un
sistema SGML semplice è Debiandoc, utilizzato qui. Richiede delle
conversioni minori dai file di testo originali per i seguenti
<!-- nbsp bug in PDF ? -->
<list compact>
<item>"&lt;" --&gt; <tt>&amp;lt;</tt>
<item>"&gt;" --&gt; <tt>&amp;gt;</tt>
<item>"&nbsp;" --&gt; <tt>&amp;nbsp;</tt>  (spazio non divisibile)
<item>"&amp;" --&gt; <tt>&amp;amp;</tt>
<item>"&percnt;" --&gt; <tt>&amp;percnt;</tt>
<item>"&copy;" --&gt; <tt>&amp;copy;</tt>
<item>"&ndash;" --&gt; <tt>&amp;ndash;</tt>
<item>"&mdash;" --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
Per marcare una sezione come commento non stampabile, date:
<example>
&lt;!-- Il commento va qui ... --&gt;
</example>
Per marcare una sezione con un commento modificabile, date:
<example>
&lt;![ &percnt;FIXME [ Il commento va qui ... ]]&gt;
</example>
In SGML, la <em>prima definizione</em> di un'entità vince. Per esempio:
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt; 
&lt;![ &percnt;qref; [ &lt;!entity param "Data 1"&gt; ]]&gt; 
&lt;!entity param "Data 2"&gt; 
&amp;param;
</example>
Questa termina come "Data 1". Se la prima riga è, invece, "IGNORE", questa
terminerà come "Data 2" (La seconda riga è un'affermazione
condizionale). Anche le frasi ripetute possono essere definite a priori,
separatamente dal contesto.
<example>
&lt;!entity <var>dichièquesto</var> "mio"&gt;
Ciao amico &amp;<var>dichièquesto</var>;.
Questo è il &amp;<var>dichièquesto</var>; libro.
</example>
Che dà ciò come risultato:
<example>
Ciao amico mio.
Questo è il mio libro.
</example>
Vedere il breve esempio in SGML <file>sample.sgml</file> in 
<url id="&examples;" name="esempi">.
<p>
Quando i documenti SGML diventano voluminosi, talvolta TeX può dare degli errori.
Vedere <ref id="texlatex">.

<!-- XXX FIXME XXX: Add XML section-->

<sect1 id="texlatex">TeX/LaTeX
<p>
Preparazione:
<example>
# tasksel # scegliete Miscellaneous  --&gt; TeX/LaTeX environment
</example>
Riferimenti per LaTeX:
<list compact>
<item><url id="&tetex-howto;" name="The teTeX HOWTO: The Linux-teTeX Local Guide">
<item><manref name="tex" section="1">
<item><manref name="latex" section="1">
<item><em>The TeXbook</em>, di Donald E. Knuth, (Addison-Wesley)
      <footnote>
        I sorgenti TeX di questo libro sono reperibili presso
        <url id="&texbooksource;">.  <url id="&texbookmacros;"> contiene
        gran parte delle macro richieste. Potete processare questo documento
        con <prgn>tex</prgn> dopo aver commentato le righa da 7 a 10,
	aggiungendo
        <tt>\input manmac \proofmodefalse</tt>.
        <p>
        E' caldamente raccomandato l'acquisto di questo libro (e degli altri
        di Donald E. Knuth) invece di usare la versione on line, ma il
	sorgente è un grande esempio di TeX!
      </footnote>
<item><em>LaTeX - A Document Preparation System</em>, di Leslie Lamport,
      (Addison-Wesley)
<item><em>The LaTeX Companion</em>, di Goossens, Mittelbach, Samarin,
      (Addison-Wesley)
</list>
<p>
Qusto è l'ambiente per la scrittura più potente. Molti processori SGML 
lo usano come loro processore back end. Lyx, fornito dal pacchetto
<package>lyx</package>, <package>lyx-xforms</package>, oppure
<package>lyx-qt</package> e GNU TeXmacs fornito da
<package>texmacs</package> offrono dei bei ambienti di scrittura WYSIWYYG per
LaTeX, mentre molti usano Emacs e Vim come come edito dei sorgenti.
<p>
Molte sono le risorse disponibili in rete:
<list compact>
<item><url id="&f-tetex-doc;" name="teTeX - A Documentation Guide">
      (il pacchetto <package>&p-tetex-doc;</package>)
<!-- translators please add the following documents: 
1) "The Not So Short Introduction to LaTeX2e"
(&f-tetex-doc; links to an English copy on harddisk (slightly outdated))
There exist many translations (and MUCH more documents in ../):
ftp://ftp.dante.de/tex-archive/info/lshort/
2) ftp://ftp.dante.de/tex-archive/info/<your-language>

PS: I (Jens) don't like the following references (too short, external)
-->
<item><url id="&pfaffbenhome;" name="A Quick Introduction to LaTeX">
<item><url id="&latexlyx;" name="A Simple Guide to Latex/Lyx">
<item><url id="&latexbasic;" name="Word Processing Using LaTeX">
<item><url id="&local-guide;" name="Local User Guide to teTeX/LaTeX">
</list>
Quando i documenti si ingrandiscono, talvolta TeX può causare degli errori.
Dovete aumentare le dimensioni del pool in <file>/etc/texmf/texmf.cnf</file> (o, più
appropriatamente, modificate <file>/etc/texmf/texmf.d/95NonPath</file> e 
lanciate <prgn>update-texmf</prgn>) per risolvere il problema.


<sect1 id="literate">Literate Programming
<p>
Invece di scrivere codice contenente documentazione, il programmatore
letterato scrive documentazione contenente codice.  Questo approccio assicura
una buona documentazione per un programma.
<p>
Per saperne di più sul literate-programming, vedere
<url id="&literatehome;" name="Literate Programming">.

<sect2 id="noweb">Noweb
<p>
Preparazione:
<example>
# apt-get install nowebm
</example>
Riferimenti per Noweb:
<list compact>
<item><url id="&nowebhome;" name="Noweb --- A Simple, Extensible Tool for Literate Programming">
<item><manref name="noweb" section="1">
</list>
<p>
E' uno strumento per il literate-programming simil-WEB, che è più semplice,
e fornisce allo stesso tempo estensibilità e indipendenza dal tipo di
linguaggio.
<footnote>
Questo WEB non ha <strong>niente</strong> a che fare con il World Wide Web.  
WEB (per PASCAL) e CWEB (per C/C++) sono strumenti tradizionali per il
literate-programming.
</footnote>
Quando si invoca <prgn>noweb</prgn> scrive il codice sorgente del programma
sui file di output menzionati nel file noweb, ed un file TeX per la
documentazione stampabile.
<p>
Il pacchetto &debian; <package>ifupdown</package> ne è un raffinato esempio.
<example>
$ apt-get source ifupdown
$ cd ifupdown*
$ make ifupdown.pdf ifupdown.ps
</example>

<sect2 id="doxygen">Doxygen
<p>
Preparazione:
<example>
# apt-get install doxygen doxygen-doc doxygen-gui
</example>
Riferimenti per Doxygen (creato da <prgn>doxygen</prgn>!):
<list compact>
<item><url id="&doxygenhome;" name="Homepage">
<item><url id="/usr/share/doc/doxygen-doc/html/index.html">
</list>
<p>
Può generare documentazione HTML, RTF, pagine di manuale Unix, PostScript, PDF (usando LaTeX)
per C++, C, Java, IDL, e programmi PHP e C# in qualche modo.
Doxygen è compatibile con JavaDoc (1.1), Qt-Doc, KDOC e è stato disegnato
specificatamente per essere usato per i progetti che usano il toolkit Troll Tech
<url id="&qthome;" name="Qt">.  Crea i grafici delle dipendenze di include,
diagrammi collaborativi, e grafici di gerarchie di classi grafiche persino per
i programmi non documentati.  L'output è simile alla documentazione di QT.

<sect id="packaging">Creare pacchetti debian
<p>
Preparazione:
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
        &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # se su Potato
</example>
Riferimenti per il packaging:
<list compact>
 <item><ref id="pkg-basics"> (basi)
 <item>Debian New Maintainers' Guide (tutorial)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (migliore dal punto di vista pratico)
 <item>Debian Policy Manual (autorevole)
 <item>Packaging Manual (Potato) 
</list>

<sect1 id="pack-binary">Impacchettare un singolo binario
<p>
Metodo spiccio per impacchettare un singolo binario, da Joey Hess.
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: miopacchetto
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: il mio piccolo pacchetto
Non vi aspettate granchè.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">Impacchettare con gli strumenti
<p>
Usate <prgn>dh_make</prgn> dal pacchetto <package>dh-make</package> per creare un pacchetto base. 
Poi, procedete secondo le istruzioni contenute in <manref
name="dh-make" section="1">.
Queste usano <prgn>debhelper</prgn> in <prgn>debian/rules</prgn>.  
<p>
Un approccio più datato è quello di usare <prgn>deb-make</prgn> dal pacchetto
<package>debmake</package>. Non usa nessuno script <prgn>debhelper</prgn> e dipende esclusivamente
dalla shell.
<p>
Per degli esempi di pacchetti con sorgenti multipli vedete "mc"
(<tt>dpkg-source -x mc_4.5.54.dsc</tt>), che usa "sys-build.mk" di Adam Heath
(<email>doogie@debian.org</email>) e "glibc" (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>), che usa un altro sistema di Joel Klecker
(<email>espy@debian.org</email>).

</sect>

</chapt>
