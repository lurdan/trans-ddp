<!-- CVS revision of this document "$Revision: 1.22 $"  -->
<!-- CVS revision of original english document "1.41"  -->
<chapt id="system">Nozioni fondamentali della Debian

<!-- 

Mereged from 4 SGML files in FAQ Feburuary 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding nonenglish is added.

Mereged from another SGML files in FAQ Feburuary 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suits "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suite more for ptato and woody.
Unless slink is used, howmany people care dpkg-ftp :)

-->

<p>
Questo capitolo spiega un sistema Debian a partire dai suoi fondamentali, ed è
indirizzato ai non-sviluppatori. Per avere informazioni più autorevoli,
vedere:
<list>
<item>Debian Policy Manual 
<item>Debian Packaging Manual (Potato) 
<item>Debian Developer's Reference 
<item>Debian New Maintainers' Guide
</list>
reperibili sotto <ref id="references">.

<p>
Se state cercando una qualsiasi risposta che li riguarda senza, però, tutti i
loro dettagli,andate direttamente a <ref id="package"> o ad altri capitoli.
<p>
Questo capitolo è formato da documenti presi dalla "Debian FAQ", e
profondamente riorganizzati, per permettere ad un qualsiasi amministratore di
un sistema Debian di avere un solido punto di partenza.

<!-- "FTP archives" is now changed as simple "archives" since it can be
reached throgh HTTP and other method -->

<sect id="ftparchives">Gli archivi Debian

<sect1 id="dirtree">Struttura della directory

<p>Il software impacchettato per la debian, è disponibile in uno dei numerosi
alberi directory su ciascun
<url id="&mirror-site;" 
     name="Debian mirror site"> raggiungibili tramite FTP o HTTP.

<p>Queste sono le directories presenti su ciascun mirror, sotto la directory
<tt>/debian/</tt>:
<taglist>
  <tag><file>/dists/</file>:
    <item>Contiene le "distribuzioni" ed era il luogo canonico di accesso dei
    pacchetti disponibili nelle versioni rilasciate e pre-rilascio. Alcuni
    vecchi pacchetti ed i files <tt>Packages.gz</tt> sono ancora qui.
  <tag><file>/pool/</file>:
    <item>Nuova locazione, che contiene fisicamente tutti i pacchetti, sia
    quelli della versione rilasciata, che quelli pre-rilascio.
  <tag><file>/tools/</file>:
    <item>Utilità DOS per creare dischetti boot, partizionare il disco rigido,
    comprimere/decomprimere i files e lanciare Linux.
  <tag><file>/doc/</file>:
    <item>La documentazione base, come le FAQ, le istruzioni per la notifica
    dei bachi, ecc.
  <tag><file>/indices/</file>:
    <item>I files dei Manutentori, ed i files override.
  <tag><file>/project/</file>:
    <item>In gran parte materiale solo per sviluppatori, tipo:
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>Pacchetti e strumenti ancora in via di sviluppo, in fase alfa. I
        normali utenti non dovrebbero utilizzare i pacchetti qui contenuti,
        che possono essere pericolosi persino per i più esperti.
      <tag><file>project/orphaned/</file>:
        <item>Pacchetti lasciati dai loro vecchi manutentori e tolti dalla
        distribuzione.
    </taglist>
</taglist>

<sect1 id="dists">Distribuzioni

<p>Di norma sono tre le distribuzioni contenute nella directory
<tt>dists</tt>.  Sono definite come la distribuzione "stable", la "testing" e
la "unstable".  Talvolta se ne aggiunge una quarta, la "frozen".  
Ogni distribuzione viene definita con un link simbolico alla
directory reale, tramite un nome proprio nella directory <tt>dists</tt>.

<sect1 id="stable">La distribuzione <tt>stable</tt>

<p>E' contenuta nella directory <tt>stable</tt>:

<p>Le voci dei pacchetti per la distribuzione <tt>stable</tt>, &stabledebian;, 
vengono inserite nella directory <tt>stable</tt> (symlink a <tt>&stablecodename;</tt>):
<list>
  <item><file>stable/main/</file>:
  Contiene i pacchetti che costituiscono formalmente il
  rilascio più recente del sistema &debian;

  <p>Tutti i pacchetti sono totalmente complianti con le <url name="Debian
  Free Software Guidelines" id="&social-contract;#guidelines"> (disponibile anche
  come <file>&f-social-contract;</file> installato da 
  <package>&p-social-contract;</package>), e sono
  utilizzabili e distribuibili liberamente.

  <item><file>stable/non-free/</file>: Contiene i pacchetti la cui distribuzione è in
  qualche modo limitata, tale da richiedere ai distributori delle cautele
  dovute ai loro requisiti specifici di copyright.

  <p>Per esempio alcuni pacchetti hanno licenze che ne vietano la
  distribuzione commerciale. Altri possono essere ridistribuiti, ma sono degli
  shareware di fatto, e non freeware. Prima che tali pacchetti possano essere
  inclusi in qualsiasi ridistribuzione (come un CD-ROM, p.es.), le loro
  licenze devono essere studiate e possibilmente rinegoziate.

  <item><file>stable/contrib/</file>: Contiene i pacchetti che sono di per sè DFSG-free e
  <strong>liberamente distribuibili</strong>, ma dipendono in qualche modo da un
  pacchetto che <strong>non è</strong> liberamente distribuibile, ed è quindi
  disponibile nella sezione non-free.
</list>
Ora, in aggiunta alle locazioni sopra descritte, i nuovi pacchetti sono fisicamente localizzati 
nella directory <tt>pool</tt> (<ref id="pools">).

<p>Lo stato attuale della distribuzione <tt>stable</tt> è riportato in sulla
pagina Web <url id="&stable-problems;" name="Stable Problems">.

<sect1 id="testing">La distribuzione  <tt>testing</tt>

<p>Le voci dei pacchetti per la distribuzione <tt>testing</tt>, &testingdebian;, 
sono registrate nella directory <tt>testing</tt> (symlink a <tt>&testingcodename;</tt>) 
dopo aver subito un periodo di prova in <tt>unstable</tt>.  
Ora, in aggiunta alle locazioni sopra descritte, i nuovi pacchetti sono fisicamente localizzati 
nella directory <tt>pool</tt> (<ref id="pools">).  
La directory <tt>testing</tt> ha delle sottodirectory, <tt>main</tt>,
<tt>contrib</tt> e <tt>non-free</tt>, che hanno le stesse funzioni che in
<tt>stable</tt>.

<p>I pacchetti devono essere sincronizzati in tutte le architetture per le
quali sono stati compilati e non devono mostrare dipendenze tali da renderli
non installabili; devono inoltre avere meno bachi release-critical delle
versioni in <tt>unstable</tt>. In questo modo si auspica che <tt>testing</tt> sia sempre molto
vicina ad essere candidata al rilascio. Per maggiori dettagli sul meccanismo
che regola la distribuzione vedere <url id="&testing-notes;">.

<p>Lo stato aggiornato della distribuzione <tt>testing</tt> è riportato presso:
<list>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="Release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="Base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="Bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="Other bugs and bug squashing party notes">
</list>

<sect1 id="unstable">La distribuzione <tt>unstable</tt>

<p>Le voci dei pacchetti della distribuzione <tt>unstable</tt>, <tt>sid</tt>, 
sono registrate nella directory <tt>unstable</tt> (symlink a <tt>sid</tt>) dopo
essere state caricate nell'archivio Debian, rimanendovi finchè non vengono spostate in
<tt>testing</tt>.  I nuovi pacchetti sono fisicamente localizzati 
nella directory <tt>pool</tt> (<ref id="pools">).  
La directory <tt>unstable</tt> ha delle sottodirectory, <tt>main</tt>,
<tt>contrib</tt> e <tt>non-free</tt>, che hanno le stesse funzioni che in
<tt>stable</tt>.

<p>La distribuzione <tt>unstable</tt> contiene le immagini più recenti del
sistema in fase di sviluppo. Gli utenti possono liberamente usare e testare
questi pacchetti, ma vengono avvisati del loro precario stato di
preparazione. Il vantaggio di usare la distribuzione <tt>unstable</tt> è
quello di essere sempre al massimo dell'aggiornamento del progetto &debian;
relativo al software&mdash;siate però pronti a raccogliere i pezzi se
qualcosa va storto.

<p>Lo stato aggiornato della distribuzione <tt>unstable</tt> è riportato presso la pagina
Web <url id="&unstable-problems;" name="Unstable Problems">.

<!-- Above was enough
<sect1 id="sid">The "sid" distribution

<p><em>sid</em> or <em>unstable</em> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <em>testing</em>,
in order to be released in <em>stable</em> later on. sid contains packages
for both released and unreleased architectures.

<p>The name "sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">La distribuzione <tt>frozen</tt>

<p>Una volta che la distribuzione testing è sufficientemente matura, diventa
frozen; ciò significa che nessun nuovo codice viene più accettato, solo
eliminazioni di bachi, se necessari. In aggiunta un nuovo albero testing viene
creato nella directory <tt>dists</tt>, con un nuovo nome. La distribuzione
frozen passa attraverso un ciclo di test (chiamato appunto 'test cycles') di
qualche mese caratterizzato da aggiornamenti intermittenti ed importanti
stabilizzazioni.(Il recente processo di rilascio di <tt>woody</tt> non ha prodotto
un link simbolico <tt>frozen</tt>, così <tt>frozen</tt> non era una distribuzione, ma
solo uno stadio di sviluppo della distribuzione <tt>testing</tt>.)

<p>Viene tenuto un registro dei bachi della distribuzione frozen che possono
impedire il rilascio di un pacchetto o di tutta la distribuzione. Una volta
che il conteggio dei bachi scende al di sotto di una valore massimo
prestabilito, la distribuzione frozen diventa stable e viene rilasciata. La
precedente distribuzione stable diventa obsoleta e finisce in archivio.

<sect1 id="codenames">Codice dei nomi della distribuzioni Debian

<p>I nomi delle directory localizzate fisicamente nella directory
<tt>dists</tt>, come <tt>&stablecodename;</tt> e <tt>&testingcodename;</tt>, sono semplicemente dei
nomi in codice. Quando una distribuzione &debian; è nella fase di sviluppo le viene
assegnato un nome in codice e non un numero di versione. Lo scopo di questi
nomi è di rendere il mirroring delle distribuzioni &debian; più semplice (se, ad
esempio, una directory reale come <tt>unstable</tt> cambiasse improvvisamente
di nome in <tt>stable</tt>, una gran quantità di programmi dovrebbe essere
nuovamente scaricata senza motivo).

<p>Attualmente <tt>stable</tt> è un link
simbolico a <tt>&stablecodename;</tt> e <tt>testing</tt> è un
link simbolico a <tt>&testingcodename;</tt>. Ciò significa che <tt>&stablecodename;</tt> è la
distribuzione attualmente stable e <tt>&testingcodename;</tt> è l'attuale testing.

<p><tt>unstable</tt> è un link simbolico permanente a <tt>sid</tt>, dato che
<tt>sid</tt> è sempre la distribuzione unstable. <!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">Nomi in codice usati in passato

<p>I nomi in codice che sono già stati utilizzati sono: <tt>buzz</tt> per la
release 1.1, <tt>rex</tt> per la 1.2, <tt>bo</tt> per la 1.3.x, <tt>hamm</tt>
per la 2.0, <tt>slink</tt> per la 2.1 e <tt>potato</tt> per la 2.2.


<sect1 id="sourceforcodenames">Da dove vengono i nomi delle distribuzioni?

<p>Finora sono stati presi dai nomi dei personaggi del film" Toy Story" della Pixar.
<list>
  <item><strong>buzz</strong> (Buzz Lightyear) era l'astronauta,
  <item><strong>rex</strong> era il tirannosauro,
  <item><strong>bo</strong> (Bo Peep) era la bambina che si prese cura della pecorella,
  <item><strong>hamm</strong> era il porcellino salvadanaio,
  <item><strong>slink</strong> (Slinky Dog) era il cane giocattolo,
  <item><strong>potato</strong> era, ovviamente, Mr. Potato,
  <item><strong>woody</strong> era il cowboy.
  <item><strong>sid</strong> era il bambino della porta accanto che rompeva i giocattoli.
</list>
<!--
  more info in http://www.pixar.com/feature/toystory/toystory.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Sarge and The Green Plastic Army Men
    - Andy (the kid)
    - Etch (Etch-a-Sketch) (the blackboard)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">La directory <tt>pool</tt>

<p>Storicamente i pacchetti erano contenuti nella subdirectory di <tt>dists</tt>
corrispondente alla distribuzione di cui facevano parte. Questo portò a vari
problemi, tipo un grosso consumo di banda di connessione dei mirror ogni volta
che venivano fatti dei cambiamenti di grossa entità.

<p>Ora i pacchetti vengono tenuti in una grossa "vasca" (pool), strutturata in
accordo con il nome del pacchetto sorgente. Per rendere il tutto maneggevole,
la vasca è suddivisa in sezioni (<tt>main</tt>, <tt>contrib</tt> e <tt>non-free</tt>) e per la prima
lettera del nome del pacchetto sorgente. Queste directory contengono svariati
files: binari per ciascuna architettura ed i pacchetti sorgente da cui i
pacchetti binari sono stati generati.

<p>E' possibile sapere dove ciascun pacchetto è situato eseguendo un comando tipo:
<tt>apt-cache showsrc <var>nomemiopacchetto</var></tt> ed andando a leggere la riga "Directory:".
Per esempio, i pacchetti <package>apache</package> sono immagazzinati in
<file>pool/main/a/apache/</file>. Essendo molteplici, i pacchetti <tt>lib*</tt>
vengono trattati in maniera particolare: per esempio, i pacchetti <package>libpaper</package> sono
immagazzinati in <file>pool/main/libp/libpaper/</file>.

<p>Le directory <tt>dists</tt> vengono ancora utilizzate per i file indice
usati da programmi tipo <tt>apt</tt>. Inoltre, al momento attuale le vecchie
distribuzioni non sono state convertite ad usare le vasche, per cui si
troveranno i percorsi contenenti distribuzioni tipo <tt>potato</tt> o <tt>woody</tt> nel campo
"Filename" dell'intestazione.

<p>Di norma non avete da preoccuparvi di ciò, poichè il nuovo <tt>apt</tt> e 
probabilmente il vecchio <tt>dpkg-ftp</tt> (vedere <ref id="howtocurrent">) sono 
in grado di gestire la cosa senza problemi. Se volete maggiori informazioni, andate
a vedere <url id="&pool-faq;" name="RFC: implementation of package pools">.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Alcune note storiche su <tt>sid</tt>

<p>Quando il <tt>sid</tt> attuale non esisteva, l'organizzazione dell'archivio Debian
aveva un problema principale: l'assunto che quando un'architettura veniva
creata nell'<tt>unstable</tt> attuale, sarebbe stata rilasciata quando la distribuzione
diventava la nuova <tt>stable</tt>. Però per molte architetture questo non era il caso,
con il risultato che quelle directory dovevano essere mosse al momento del
rilascio. Fatto poco pratico, poichè lo spostamento avrebbe fagocitato grosse
quantità di banda.

<p>Gli amministratori dell'archivio hanno evitato questo problema per
pacchetti anni piazzando i binari delle architetture ancora non rilasciate in
una directory speciale chiamata <tt>sid</tt>. Al momento del loro rilascio esisteva un link
dall'architettura a quel momento <tt>stable</tt> a <tt>sid</tt> e da quel momento in poi essa
veniva creata all'interno dell'albero <tt>unstable</tt>, come di norma. Tutto ciò era
motivo di confusione per gli utenti.

<p>Con l'avvento della vasca dei pacchetti (vedere <ref id="pools">) durante
lo sviluppo della distribuzione <tt>woody</tt> i pacchetti binari cominciarono ad
essere immagazzinati in una locazione canonica nella vasca, indipendentemente
dalla distribuzione; in tal modo il rilascio di una distribuzione non
determina più la grossa dispersione di banda sui mirror (c'è, ovviamente, un
notevole consumo, ma graduale, di banda durante la fase di sviluppo).

<sect1 id="incoming">Pacchetti caricati in <file>incoming</file>
<p>
I pacchetti che vengono caricati nell'archivio vengono dapprima immagazzinati
in <url id="&incoming;"> prima di accertarsi che provengano realmente da uno
sviluppatore Debian (e vengono piazzati nella sottodirectory <file>DELAYED</file> in caso
di Non-Maintainer Upload (NMU)). Una volta al giorno, vengono mossi da <tt>incoming</tt>
ad <tt>unstable</tt>.
<p>
In caso di emergenza, potreste voler installare i pacchetti da qui, prima che
raggiungano <tt>unstable</tt>.
</sect1>

<sect1 id="snapshot">Recuperare un vecchio pacchetto
<p>
Mentre le distribuzioni Debian più recenti vengono tenute nella directory
<tt>debian</tt> directory su ciascun <url id="&mirror-site;" name="Mirror
Debian">, gli archivi per le distribuzioni più vecchie, tipo Slink, sono
tenuti su <url id="&archivehome;"> o sotto la directory
<tt>debian-archive</tt> di ciascun mirror Debian.
<p>
I vecchi pacchetti <tt>testing</tt> ed <tt>unstable</tt> sono localizzati in
<url id="&snapshothome;">.

</sect1>

<sect1 id="archsections">Sezioni per architettura <!-- What are all those
directories inside <tt>dists/stable/main</tt>?  Simplified this !!!  -->

<p>All'interno di ciascun albero directory principale
(<file>dists/stable/main</file>, <file>dists/stable/contrib</file>,
<file>dists/stable/non-free</file> <file>dists/unstable/main/</file>, etc.),
le voci dei pacchetti binari risiedono all'interno di sottodirectory i cui
nomi indicano l'architettura per la quale sono stati compilati.

<list>
  <item><file>binary-all/</file>, per pacchetti architettura-indipendenti.
    Comprendono, per esempio, scripts Perl o pura documentazione.
    <item><file>binary-<var>piattaforma</var>/</file>, per pacchetti che
    girano su una particolare piattaforma.  <!-- Yes I simplified this -->
</list>

<p>Ricordate che i reali pacchetti binari per <tt>testing</tt> ed
<tt>unstable</tt> non risiedono più in queste directory, ma al livello
principale della directory <tt>pool</tt>. I file elenco (<file>Packages</file>
e <file>Packages.gz</file>) sono stati comunque mantenuti, per compatibilità
con il vecchio sistema.

<p>Per sapere quali architetture sono al momento supportate, leggetevi le Note
di Rilascio per ciascuna distribuzione. Possono essere trovate presso i siti
delle Note di Rilascio per <url id="&stable-release;" name="stable"> e <url
id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.  <p>See <ref id="arches">
for more information.  -->

<sect1 id="source">Il codice sorgente

<p>Il codice sorgente è disponibile per ogni cosa contenuta nel sistema
Debian. In più, i termini di licenza della maggior parte dei programmi
<strong>richiedono</strong> che il codice venga distribuito insieme ai
programmi, o che un'offerta di fornire il codice li accompagni.

<p>Di regola il codice viene reperito nelle directory <tt>source</tt>, che
sono in parallelo a tutte le directory dei binari architettura-specifiche, o
più di recente alla directory <tt>pool</tt> (vedere <ref id="pools">). Per
scaricare il codice sorgente senza la necessità di essere addentro alla
struttura dell'archivio Debian, provate un comando tipo <!--FTP--> <tt>apt-get
source <var>nomemiopacchetto</var></tt>.

<p>Alcuni pacchetti, in particolare <package>pine</package>, sono disponibili
solamente come sorgenti, a causa delle limitazioni delle
licenze. (Recentemente è stato fornito il pacchetto
<package>pine-tracker</package> per facilitare l'installazione di Pine). 
Le procedure descritte in <ref id="port"> e <ref id="packaging"> dovrebbero
fornire tutto il necessario per compilare un pacchetto manualmente.

<p>Il codice sorgente potrebbe non essere disponibile, invece, per i pacchetti
delle directory <file>contrib</file> e <file>non-free</file>, che formalmente non fanno parte del
sistema Debian.

<sect id="pkg-basics">Il sistema di gestione dei pacchetti Debian 

<sect1 id="package-basics">Panoramica dei pacchetti Debian

<p>Normalmente i pacchetti contengono tutti i files necessari all'implementazione
 di una serie di comandi o di funzionalità. Esistono due tipi di pacchetti:

<list>
  <item><strong>Pacchetti binari</strong>, che contengono eseguibili, file di
  configurazione, pagine man/info, informazioni sul copyright ed altra
  documentazione. Questi pacchetti vengono distribuiti in un formato specifico
  alla Debian (vedere <ref id="deb-format">);
  si riconoscono per il suffisso <tt>.deb</tt>. Questi pacchetti possono essere
  "spacchettati" usando l'utilità tutta Debian <tt>dpkg</tt>; i dettagli si
  possono vedere alla pagina man corrispondente.
  
  <item><strong>Pacchetti sorgente</strong>, che consistono in un file <tt>.dsc</tt>
  che descrive il pacchetto sorgente (inclusi in nomi dei file seguenti), un
  file <tt>.orig.tar.gz</tt> che contiene i sorgenti originali non modificati
  in formato tar gzip ed in genere un file <tt>.diff.gz</tt> che contiene le
  modifiche specifiche per Debian ai sorgenti originali. L'utilità
  <tt>dpkg-source</tt> impacchetta e spacchetta questo tipo di pacchetti. Per
  i dettagli, ovviamente, la pagina man corrispondente.
</list>

<p>L'installazione del software attraverso il sistema dei pacchetti utilizza
delle "dipendenze", che sono state accuratamente costruite dal responsabile
(manutentore) del pacchetto. Le dipendenze vengono descritte nel file
<tt>control</tt>, associato a ciascun pacchetto. Ad esempio, il pacchetto
contenente il compilatore GNU C (<package/gcc/) "dipende" dal
pacchetto <package/binutils/ che include il linker e l'assembler. Se
si prova ad installare <package/gcc/ senza aver prima installato
<package/binutils/, il sistema di gestione dei pacchetti (dpkg)
invierà un messaggio di errore riguardo alla necessità di avere anche
<package/binutils/ e bloccherà l'installazione di
<package/gcc/.  (Questo comportamento può comunque essere scavalcato
dall'utente tenace, vedere al riguardo <manref name="dpkg" section="8">.)
Vedere più sotto in <ref id="depends">.

<p>Gli strumenti Debian per la gestione dei pacchetti possono essere usati
per:
<list>
  <item>manipolare e gestire i pacchetti o parte di essi, 
  <item>aiutare l'utente nella frammentazione dei pacchetti che devono essere trasmessi con
    un mezzo di limitate capacità come un floppy,
  <item>aiutare gli sviluppatori nella costruzione degli archivi dei pacchetti e 
  <item>aiutare gli utenti nell'installazione dei pacchetti residenti in un archivio remoto <!--FTP-->
     Debian.
</list>

<sect1 id="deb-format">Il formato dei pacchetti Debian <!--binary-->

<p>Un "pacchetto" Debian, od un file dell'archivio Debian contiene gli
eseguibili,le librerie e tutta la documentazione associata ad un gruppo o
suite di programmi correlati. I file dell'archivio Debian, di norma, hanno il
suffisso <tt>.deb</tt>.

<p>I dettagli dei pacchetti binari Debian sono descritti nella pagina man
<manref name="deb" section="5">. Il loro formato interno è soggetto a cambiamenti
(tra una versione maggiore e l'altra di &debian;), per cui leggete sempre
<manref name="dpkg-deb" section="8"> prima di manipolare i<tt>.deb</tt>
files.

<!-- Below added by Osamu XXX Not sure but should be right -->

<p>Almeno fino a Woody, gli archivi Debian sono sempre stati manipolabili
anche dai normali comandi Unix, tipo <prgn>ar</prgn> e <prgn>tar</prgn>, anche
quando i comandi dpkg non erano disponibili.

<sect1 id="pkgname">Convenzioni nei nomi dei pacchetti Debian
<!--
Why are Debian package file names so long? 
-->
<p>Il nome di un pacchetto Debian <!--binary--> segue la convenzione seguente:
<example>
<var>foo</var>_<var>NumeroVersione</var>-<var>NumeroRevisioneDebian</var>.deb
</example>
<tt>foo</tt> sta per il nome del pacchetto. Come prova, si può risalire al
nome del pacchetto associato ad un archivio Debian particolare (file <tt>.deb</tt>) in
uno dei seguenti modi:
<list>
  <item>ispezionare il file "Packages" nella directory dove è stato archiviato
  in un qualsiasi archivio <!--FTP--> Debian. Questo file contiene una sezione che
  descrive ciascun pacchetto presente; il primo campo di ciascuna sezione
  rappresenta il nome formale del pacchetto.
  
  <item>utilizzando il comando <tt>dpkg --info <var>foo_VVV-RRR</var>.deb</tt> (dove <var>VVV</var>
  e <var>RRR</var> sono rispettivamente la versione e la revisione del pacchetto in
  questione).  Il comando mostra, fra le altre cose, il nome del pacchetto
  corrispondente al file dopo lo spacchettamento.
</list>

<p> <var>VVV</var> rappresenta il numero di versione specificato dallo
sviluppatore principale. Non esiste uno standard, per cui il numero può
presentarsi in formati diversi, tipo "19990513" e "1.3.8pre1".

<p> <tt>RRR</tt> rappresenta il numero di revisione Debian e viene specificato
dallo sviluppatore Debian (o da un utente qualsiasi, se decide di costruirsi
il pacchetto da sè). Il numero corrisponde al livello di revisione del
pacchetto Debian, quindi un nuovo numero in genere significa dei cambiamenti
nel Makefile Debian (<tt>debian/rules</tt>), nel file di controllo Debian
(<tt>debian/control</tt>), negli scripts di installazione o rimozione
(<tt>debian/p*</tt>) oppure nei file di configurazione utilizzati con il
pacchetto.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Mantenimento della configurazione locale
<!--
What is a Debian conffile
-->
<p>Il mantenimento di files configurabili dall'utente viene ottenuto tramite
il meccanismo dei "conffiles" Debian. I file di configurazione dell'utente (di
norma inseriti in <file>/etc</file>) vengono specificati nei <tt>conffiles</tt>
all'interno del sistema dei pacchetti Debian. Il sistema di gestione dei
pacchetti garantisce che, all'aggiornamento, i file di configurazione non
vengano sovrascritti. 
<p>
Quando è possibile configurare il sistema senza modificare i file che appartengono ai
vari pacchetti &debian;, è in genere buona cosa non modificarli, anche se sono dei
"conffiles".  Ciò assicura delle operazioni di aggiornamento più lisce e veloci. 
<!--
<p>I cosiddetti conffiles rappresentano una lista di file di configurazione
(di norma localizzati in <tt>/etc</tt>) che il sistema di gestione dei
pachetti non sovrascrive al momento dell'aggiornamento di un pacchetto. Ciò
assicura il mantenimento dei valori personalizzati contenuti da questi files,
fatto fondamentale che permette l'aggiornamento dei files a sistema in
funzione.
-->
<p>Per determinare esattamente quali files saranno preservati durante un
aggiornamento, lanciare: 
<example>
dpkg --status <var>package</var>
</example> 
E guardare sotto "Conffiles:".

<p>
Le specifiche riguardo al contenuto dei <tt>conffiles</tt> Debian si trovano nel Debian
Policy Manual, sezione 11.7, vedere <ref id="references">.

<sect1 id="maintscripts">Scripts di gestione Debian
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Gli scripts di gestione Debian
sono degli script eseguibili che vengono lanciati automaticamente prima o dopo
l'installazione di un pacchetto. Insieme ad un file chiamato <tt>control</tt>,
tutti questi files fanno parte della sezione "control" di un file Debian.

<p>I singoli files sono:
<taglist>
<tag/preinst/
  <item>Questo script viene eseguito prima che il pacchetto venga estratto dal
  file Debian (<tt>.deb</tt>). Molti script "preinst" interrompono i servizi per i
  pacchetti che devono essere aggiornati fino a che la loro installazione o
  aggiornamento non sono completati (a seguire dell'esecuzione con successo
  dello script "postinst").

<tag/postinst/
  <item>Questo script tipicamente completa ogni configurazione
  richiesta dal pacchetto <tt>foo</tt> dopo che <tt>foo</tt> è stato estratto
  dal suo file Debian (<tt>.deb</tt>). Spesso gli scripts "postinst" richiedono
  all'utente determinate azioni e/o lo avvertono che, qualora accettasse le
  impostazioni di base, deve ricordarsi di riconfigurare il pacchetto se la
  situazione lo richiede. Molti scripts "postinst", poi, eseguono tutti i
  comandi necessari a lanciare o far ripartire i servizi, dopo che il
  pacchetto è stato aggiornato o installato.

<tag/prerm/
  <item>Questo script ferma tutti i demoni associati con un
  pacchetto. Viene eseguito prima della rimozione di file associati ad un
  determinato pacchetto.

<tag/postrm/
  <item>Modifica i links od altri files correlati a <tt>foo</tt>,
  e/o rimuove i files creati da quel pacchetto.(Vedere anche <ref
  id="virtual">.)
</taglist>

<p>Tutti i file di controllo possono essere localizzati nella directory
<file>/var/lib/dpkg/info</file>. I files correlati con il pacchetto <tt>foo</tt>
iniziano, appunto, con il nome "foo" ed hanno le estensioni "preinst",
"postinst", ecc. a seconda della funzione.  Il file <tt>foo.list</tt> nella
stessa directory elenca tutti i files installati con il pacchetto
<tt>foo</tt>.  (Notate che la localizzazione di questi files è interna a
dpkg e può essere soggetta a modifiche.)

<sect1 id="priority">Priorità
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Ad ogni pacchetto viene assegnata una <strong>priorità</strong> dai responsabili
della distribuzione, come aiuto al sistema di gestione dei pacchetti. Le
priorità sono:

<list>
  <item><strong>Richiesto</strong> (Required): pacchetti necessari al corretto
    funzionamento del sistema.  
    <p>Comprende tutti gli strumenti necessari
    alla riparazione di difetti di sistema. Questi pacchetti non devono essere
    rimossi, pena la completa inutilizzabilità del sistema, probabilmente
    nemmeno con <prgn>dpkg</prgn> si riuscirebbe a mettere le cose a posto. I sistemi con
    solo i pacchetti Richiesti probabilmente sarebbero inutilizzabili, ma hanno
    abbastanza funzionalità per permettere all'amministratore di sistema di
    fare un boot ed installare altri programmi.
  <item><strong>Importante</strong> (Important): pacchetti che si ritrovano probabilmente
    su qualsiasi sistema Unix o correlato.  
    <p>Altri pacchetti necessari ad un
    corretto funzionamento del sistema, senza i quali non sarebbe
    utilizzabile. Tra questi <strong>non</strong> sono inclusi Emacs o X11 o TeX o
    qualsiasi altra grossa applicazione. Qui si parla di pacchetti che
    costituiscono l'infrastruttura di base.
  <item><strong>Standard</strong>: pacchetti comuni su qualsiasi sistema
    Linux, compreso un sistema ragionevolmente piccolo ma nemmeno troppo
    limitato all'interfaccia a carattere.
    <p>Questo è ciò che viene
    installato di base se l'utente non seleziona altro. Non include grosse
    applicazioni, però include Emacs (più un pezzo di infrastruttura che
    un'applicazione) ed un ragionevole sottogruppo di TeX e LaTeX (se è
    possibile senza X).
  <item><strong>Opzionale</strong> (Optional): pacchetti che comprendono tutto quello di cui
    potete aver voglia di installare senza nemmeno sapere che cosa è, o se non
    avete delle necessità particolari.  
    <p>Comprende X11, una distribuzione completa di TeX e molte applicazioni.  
  <item><strong>Extra</strong>:
    pacchetti che o entrano in conflitto con altri di priorità più alta,
    probabilmente utili se già sapete a che servono, oppure hanno requisiti
    speciali che li rendono non consoni come "Opzionali".
</list>

<sect1 id="virtual">Pacchetti Virtuali

<p>Il termine pacchetto virtuale è un termine generico che si applica a tutti
i pacchetti di un gruppo che provvede alla medesima funzione. Per esempio, i
programmi <tt>tin</tt> e <tt>trn</tt> sono entrambi dei newsreader, in grado
di soddisfare qualsiasi dipendenza di un programma che richieda un newsreader
su un sistema, al fine di funzionare correttamente. Entrambi, quindi, si dice
che provvedano il "pacchetto virtuale" definito <tt>news-reader</tt>.

<p>Allo stesso modo <tt>exim</tt> e <tt>sendmail</tt> forniscono entrambi la
funzionalità di un agente di trasporto posta (mail transport agent). Entrambi,
quindi, provvedono al pacchetto virtuale "mail transport agent". Se uno dei
due è installato, qualsiasi programma che dipenda dall'installazione di un
<tt>mail-transport-agent</tt> vedrà le proprie dipendenze soddisfatte
dall'esistenza di questo pacchetto virtuale.

<p>La Debian ha un meccanismo tale che, se più di un pacchetto che fornisce lo
stesso pacchetto virtuale è installato, l'amministratore di sistema è in grado
di sceglierne uno come pacchetto preferito. Il comando che viene chiamato in
causa è<tt>update-alternatives</tt> e verrà descritto in dettaglio oltre, in
<ref id="alternatives">.

<sect1 id="depends">Dipendenze
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>Il sistema dei pacchetti Debian ha una serie di "dipendenze" che sono
pensate per indicare (con un singolo termine) il livello di indipendenza di un
dato Programma A a cui può operare, indipendentemente dalla esistenza di un
Programma B su un dato sistema:
<list>
  <item>Il Pacchetto A <strong>dipende</strong> dal Pacchetto B se B deve essere
    assolutamente installato per eseguire A. In alcuni casi, esso no dipende
    solo da B, ma da una sua specifica versione. In tal caso la dipendenza
    dalla versione rappresenta un limite inferiore, nel senso che A dipende da
    qualsiasi versione di B più recente di quella specificata.  
  <item>Il Pacchetto A <strong>raccomanda</strong> il B, se il responsabile del
    pacchetto giudica che la maggior parte degli utenti non vorrebbe A senza
    le funzioni provviste anche da B.  
  <item>Il Pacchetto A <strong>suggerisce</strong> B se B contiene files correlati (e
    che talvolta migliorano) alle funzioni di A.  
  <item>Il Pacchetto A <strong> è in conflitto</strong> con B quando A non è in grado
    di funzionare se B è installato nel sistema. Molto spesso i conflitti si
    hanno quando A contiene dei files che rappresentano dei miglioramenti di
    quelli in B. Spesso "è in conflitto" è combinato con "sostituisce".
  <item>Il Pacchetto A <strong>sostituisce</strong> B quando i files installati da B
    vengono rimossi e (in alcuni casi) sovrascritti da quelli in A.  
  <item>Il Pacchetto A <strong>fornisce</strong> B quando tutti i files e le funzioni di B
    vengono incorporate da A. Questo meccanismo permette agli utenti con
    scarso spazio sul disco rigido di avere solo la parte del pacchetto A che
    serve loro realmente.
</list>

<p>Informazioni più dettagliate possono essere trovate nel manuale di
Packaging ed in quello di Policy.

<p>Bisogna ricordare che <tt>dselect</tt> ha un controllo molto più raffinato
sui pacchetti contrassegnati da <strong>raccomanda </strong> e <strong>suggerisce</strong>
rispetto ad <tt>apt-get</tt>, che prende semplicemente tutti i pacchetti
specificati da <strong>dipende</strong> e lascia quelli indicati da <strong>raccomanda</strong> e
<strong>suggerisce</strong>. Entrambi i programmi nelle forme più moderne utilizzano
come back-end APT.

<sect1 id="pre-depends">Cosa significa Pre-Depends

<p>"Pre-Depends" è una dipendenza speciale. Con la maggior parte dei pacchetti
<prgn>dpkg</prgn> ne spacchetterà il file di archivio (ovvero il file
<tt>.deb</tt>), indipendentemente dal fatto che i files da cui dipendono sono
o no sul sistema. Semplificando, spacchettare il file vuol dire che
<prgn>dpkg</prgn> ne estrarrà i file da installare e li metterà al loro posto. Se
qualche determinato pacchetto <strong>dipende</strong> dall'esistenza di altri pacchetti
nel sistema,<prgn>dpkg</prgn> si rifiuterà di completare l'installazione (eseguendo
l'azione "configura"), finchè non saranno installati gli altri pacchetti.

<p>Per alcuni pacchetti, tuttavia, <prgn>dpkg</prgn> si rifiuterà persino di
spacchettarli finchè certe dipendenze non vengono risolte. Tali pacchetti
"Pre-dipendono" (Pre-depend) dalla presenza di altri pacchetti. Il progetto
Debian previde questo meccanismo per supportare un aggiornamento sicuro di
sistemi dal formato <tt>a.out</tt> al formato <tt>ELF</tt>, dove
<strong>l'ordine</strong> in cui i pacchetti venivano estratti risultava
critico. Esistono altre situazioni di aggiornamenti estesi in cui questo
metodo si rivela utile, tipo pacchetti con priorità richiesta e dipendenza da
libC.

<p>Come sopra, informazioni più dettagliate al riguardo possono essere reperite 
nel manuale di Packaging.

<sect1 id="pkgstatus">Lo stato dei pacchetti
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Lo stato di un pacchetto può essere "sconosciuto", "installa", "rimuovi",
"elimina" o "mantieni".  Queste etichette "voglio", indicano il volere
dell'utente riguardo ad un pacchetto (come indicato dalle azioni dell'utente
nella sezione "Scegli" di <prgn>dselect</prgn> o dal richiamo diretto dell'utente
di <prgn>dpkg</prgn>).

<p>Il loro significato è il seguente:
<list>
  <item><strong>sconosciuto</strong> - l'utente non ha mai indicato se vuole il pacchetto
  <item><strong>installa</strong> - l'utente vuole il pacchetto installato od aggiornato
  <item><strong>rimuovi</strong> - l'utente vuole che il pacchetto sia rimosso, ma non i suoi
                file di configurazione.  
  <item><strong>elimina</strong> - l'utente vuole il pacchetto completamente rimosso, compresi 
                i file di configurazione.  
  <item><strong>mantieni</strong> - l'utente non vuole che il pacchetto sia processato, ovvero 
                vuole mantenere la versione attuale con lo stato corrente, qualunque essi siano.
</list>

<sect1 id="puttingonhold">Evitare l'aggiornamento dei pacchetti
<!--
How do I put a package on hold?
Made major rewite to accomodate new /etc/apt/preferences in progress
-->
<p>Esistono due modi per evitare l'aggiornamento di un pacchetto, tramite <prgn>dpkg</prgn> o,
 in Woody, tramite APT.

<p>Con <prgn>dpkg</prgn>, dovete solo esportare la lista dei pacchetti selezionati con:
<example>
dpkg --get-selections &gt; <var>selections.txt</var>
</example>
Dopodichè modificate il file risultante <file><var>selections.txt</var></file>, cambiando la riga che
contiene il pacchetto da mantenere, tipo <package/libc6/, da:
<example>
libc6                                           install
</example>
a:
<example>
libc6                                  hold
</example>
Salvate il file e ricaricatelo nel database di <prgn>dpkg</prgn> con:
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
Se conoscete il nome del pacchetto da mantenere, basta eseguire: 
<example>
echo libc6 hold | dpkg --set-selections
</example> 
Questo processo evita l'aggiornamento dei pacchetti al momento dell'installazione di ciascun file.

<p>Lo stesso risultato si ottiene tramite <prgn>dselect</prgn>. Basta accedere alla
schermata [S]cegli, trovare il pacchetto da mantenere nello stato attuale e
premere il tasto `=' (o `H'). I cambiamenti saranno effettivi non appena
lasciata la schermata [S]cegli.

<p>Il sistema APT nella nuova distribuzione Woody ha un meccanismo alternativo
per mantenere i pacchetti durante il processo di raccolta di un archivio,
utilizzando la <tt>Pin-Priority</tt>.
Vedere la pagina man <manref name="apt_preferences" section="5">, l'<url id="&apt-howto;"> o il
pacchetto <package>&p-apt-howto;</package>.

<sect1 id="sourcepkgs">Pacchetti sorgente

<p>
I pacchetti sorgente vengono distribuiti in una directory chiamata <tt>source</tt>
e possono essere scaricati o manualmente, oppure tramite il comando
<example>
apt-get source <var>foo</var>
</example>
(vedere <manref name="apt-get" section="8"> la pagina man su come settare APT all'uopo).


<sect1 id="sourcebuild">Compilare pacchetti binari dai sorgenti

<p>Per un dato pacchetto <tt><var>foo</var></tt> avete bisogno di tutti i <file><var>foo_*</var>.dsc</file>,
<file><var>foo_*</var>.tar.gz</file> e <file><var>foo_*.diff</var>.gz</file> (nota bene: non esiste nessun <tt>.diff.gz</tt> per un 
pacchetto Debian nativo).

<p>Una volta presi, se avete installato il pacchetto <package/dpkg-dev/ il seguente
comando:
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
estrarrà il pacchetto in una directory denominata 
<tt><var>foo-version</var></tt>.

<p>Date i seguenti comandi per compilare il pacchetto binario:
<example>
$ cd foo-versione
$ su -c "pat-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
poi
<example>
$ su -c dpkg -i ../<var>foo_version-revision_arch</var>.deb
</example>
per installarlo. Vedere <ref id="port">.

<!-- XXX woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Creare nuovi pacchetti Debian

<p>Per maggiori dettagli al riguardo, leggete la "New Maintainers' Guide",
reperibile nel pacchetto <package/maint-guide/ oppure presso
<url id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rerely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rerely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Aggiornare un sistema Debian

<p>Uno degli scopi della Debian è di fornire un sentiero solido di
aggiornamento ed un processo sicuro (sempre di aggiornamento), e si fa sempre
del proprio meglio per rendere la nuova versione facilmente aggiornabile dalla
precedente. Nel caso di qualcosa di importante da aggiungere al processo di
aggiornamento, i pacchetti avvertiranno gli utenti, spesso provvedendo anche
ad una soluzione ai possibili problemi.

<p>Bisogna sempre leggere le Note di Rilascio (Release Notes), documento che
descrive i dettagli dei singoli aggiornamenti, che viene sempre inserito in
tutti i CD Debian, comunque disponibile sul web presso <url
id="&stable-release;"> oppure presso <url id="&testing-release;">.

<p>
Una guida pratica viene fornita in <ref id="package">. Questa sezione si
occupa dei dettagli fondamentali.

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Metodi per aggiornare un sistema Debian

<p>Si può sempre fare un ftp anonimo od un <prgn>wget</prgn> ad un archivio Debian e
sbirciare nelle directory finchè si trova il file desiderato, scaricarlo ed
infine installarlo con <prgn>dpkg</prgn>. Notate che <prgn>dpkg</prgn> installerà i
file aggiornati al loro posto, persino su un sistema che sta normalmente
girando. Talvolta un pacchetto da aggiornare richiederà l'installazione di un
altro pacchetto aggiornato, in tal caso l'installazione fallirà finchè/a meno
che l'altro pacchetto venga installato.

<p>Molti trovano che un approccio del genere sia troppo dispendioso in
termini di tempo, dato che la Debian si evolve molto velocemente &mdash; tipicamente
una dozzina o più di nuovi pacchetti vengono caricati ogni settimana. Questo
numero diventa ben più grande in prossimità di un rilascio di una nuova
versione. Per trattare con questa massa di pacchetti, molte persone
preferiscono utilizzare programmi automatizzati. Per questo scopo, molti
strumenti di gestione dei pacchetti sono disponibili.

<sect1 id="pkgtools">Panoramica degli strumenti di gestione dei pacchetti

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>Il sistema di gestione dei pacchetti Debian è focalizzato su due punti
principali, la manipolazione del pacchetto stesso, ed il suo recupero da un
archivio Debian.<prgn>dpkg</prgn> è per il primo punto, APT e
<prgn>dselect</prgn> per il secondo.

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>E' il programma principale per la manipolazione dei pacchetti.
Per ulteriori informazioni, leggere la pagina man
<manref name="dpkg" section="8">.
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> è fornito con parecchi programmi supplementari di base.

<list>
<item>dpkg-deb: Manipola i files <tt>.deb</tt>. 
 <manref name="dpkg-deb" section="1">
<item>dpkg-ftp: Vecchio comando per il recupero dei pacchetti. 
 <manref name="dpkg-ftp" section="1">
<item>dpkg-mountable: Vecchio comando per il recupero dei pacchetti. 
 <manref name="dpkg-mountable" section="1">
<item>dpkg-split: Divide grossi pacchetti in files più piccoli. 
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> e <prgn>dpkg-mountable</prgn> sono stati resi obsoleti
dall'introduzione del sistema APT.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT (Advanced Packaging Tool) è un'interfaccia più avanzata per il sistema Debian di gestione dei pacchetti
e consiste di vari programmi i cui nomi iniziano tipicamente con "apt-". 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn> e <prgn>apt-cdrom</prgn> 
sono gli strumenti da riga di comando per maneggiare i pacchetti. Funzionano
anche come programmi backend per l'utente di altri strumenti, come <prgn/dselect/ 
ed <prgn/aptitude/.

<p>Per maggiori informazioni, installare <package/apt/ e leggere
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (woody), e
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>Esistono fonti di informazione alternative, come
<url id="&apt-howto;" name="APT HOWTO">.
Può essere installato tramite <package/apt-howto/ in
<file>&f-apt-howto;</file>.

<p><tt>apt-get upgrade</tt> e <tt>apt-get dist-upgrade</tt> prendono solo
i pacchetti elencati sotto "Dipende", mentre lasciano quelli sotto "Raccomanda" e "Suggerisce". Per evitare ciò,
usate <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>Questo programma rappresenta un'interfaccia utente basata su menu al
sistema di gestione dei pacchetti. E' particolarmente utile per prime
installazioni ed aggiornamenti su larga scala. Vedere <ref id="dselect">.

<p>Per ulteriori informazioni, installare <package/install-doc/ e leggere
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> oppure <url
id="&dselect-beginner;" name="dselect Documentation for Beginners">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <tt>start-stop-daemon</tt> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Aggiornare un sistema in funzione

<p>Il kernel (file system) in &debian; supporta la sostituzione dei files anche mentre sono in uso.

<p>Viene anche fornito un programma chiamato <prgn/start-stop-daemon/ che
viene impiegato per lanciare i demoni al boot o per fermarli al cambiamento di
runlevel del kernel (da multi-utente a singolo, o allo spegnimento della
macchina, per esempio). Lo stesso programma viene usato dagli scripts di
installazione quando un nuovo pacchetto che contiene un demone viene
installato, per fermare i demoni in funzione, e riavviarli al momento giusto.

<p>Notare che il sistema Debian non ha bisogno della modalità singolo
utente per aggiornare un sistema in funzione.

<sect1 id="savedebs">File <tt>.deb</tt> scaricati e tenuti in cache

<p>Se avete scaricato i file <tt>.deb</tt> nel vostro disco rigido (cosa assolutamente non
necessaria, vedere sopra per la descrizione di <prgn>dpkg-ftp</prgn> o di APT), dopo l'installazione
dei pacchetti potete rimuoverli dal vostro sistema.

<p>Se si usa APT, i file vengono tenuti nella directory
<file>/var/cache/apt/archives/</file>.  
Potete cancellarli dopo l'installazione (<tt>apt-get clean</tt>), oppure copiarli sulla stessa directory
<file>/var/cache/apt/archives/</file> di un'altra macchina, per evitare un nuovo download 
durante la successiva installazione.

<sect1 id="keepingalog">Tenere una registrazione dell'aggiornamento

<p><prgn/dpkg/ mantiene una registrazione dei pacchetti scompattati,
configurati, rimossi e/o eliminati, ma (al momento) non tiene nessuna
registrazione dell'attività scritta su terminale durante tali manipolazioni.

<p>Il metodo più semplice per aggirare questo impedimento è di lanciare una
qualsiasi sessione di
<prgn>dpkg</prgn>/<prgn>dselect</prgn> <prgn>apt-get</prgn> all'interno del
programma <manref name="script" section="1">.

<sect id="boot">La sequenza di boot della Debian

<sect1 id="init"><tt>init</tt>

<p>Come ogni buon appartenente alla famiglia degli Unix, Debian esegue il boot
eseguendo il programma <tt>init</tt>.  Il file di configurazione di
<tt>init</tt> (che è <tt>/etc/inittab</tt>) specifica che il primo script da
eseguire deve essere <tt>/etc/init.d/rcS</tt>. Questo script controlla e monta
i filesystems, carica i moduli, lancia i servizi di rete, imposta l'orologio,
esegue altre inizializzazioni e poi lancia tutti gli altri script (tranne
quelli con `.' nel filename) localizzati in <tt>/etc/rc.boot/</tt>. Tutti gli
script in quest'ultima directory sono riservati all'amministratore di sistema,
ed il loro utilizzo nei pacchetti è deprecato.

<sect1 id="runlevels">Runlevels

<p>Dopo il completamento del processo di boot, <tt>init</tt> esegue tutti gli
script contenuti nella directory specificata dal runlevel di default (dato
dalla riga per <tt>id</tt> in <tt>/etc/inittab</tt>).
Come la maggior parte degli Unix compatibili con il <!-- all? SGK --> System V, Linux ha 7 runlevels:
<list>
  <item>0 (ferma il sistema),
  <item>1 (modalità singolo utente),
  <item>2 a 5 (varie modalità multiutente) e
  <item>6 (riavvia il sistema).
</list>
I sistemi Debian hanno <tt>id=2</tt>, che indica che il runlevel di default sarà il 2
quando si entra in modalità multiutente e verranno lanciati gli scripts
localizzati in <tt>/etc/rc2.d/</tt>.

<p>Di fatto gli scripts localizzati in qualsiasi directory denominata
<file>/etc/rc<var>N</var>.d/</file> sono semplici link simbolici che si riferiscono a scripts
localizzati in <file>/etc/init.d/</file>. Tuttavia, i <strong>nomi</strong> dei files in
ciascuna directory <file>/etc/rc<var>N</var>.d/</file> sono selezionati in modo da indicare
il <strong>modo</strong> in cui gli scripts in <file>/etc/init.d/</file> saranno
lanciati. Entrando nello specifico, prima di entrare in qualsiasi runlevel
tutti gli script che iniziano con 'K' vengono lanciati; questi scripts
chiudono (uccidono) i servizi. Poi vengono lanciati tutti quelli che iniziano
per 'S', che fanno partire i servizi. Il numero a due cifre che segue la
lettera 'K' o 'S' indica l'ordine nel quale lo script verrà lanciato. Script
con numeri più bassi vengono eseguiti prima.

<p>Questo approccio funziona perchè gli scripts contenuti in
<tt>/etc/init.d/</tt> accettano un argomento che può essere "start", "stop",
"reload", "restart" o "force-reload" eseguendo poi il compito indicato dallo
specifico argomento. Questi scripts possono essere utilizzato anche dopo il
boot del sistema per controllare svariati processi.

<p>Per esempio, lanciato con l'argomento "reload", il comando
<example>
/etc/init.d/sendmail reload
</example> 
invia al demone sendmail un
  segnale di rileggere il proprio file di configurazione.

<sect1 id="custombootscripts">Personalizzare il processo di boot
<p>
Debian non usa 
<tt>rc.local</tt> in stile BSD per personalizzare il processo di boot; fornisce,
invece, il seguente meccanismo per la personalizzazione.

<p>Supponiamo che un sistema debba lanciare lo script <tt>foo</tt> all'avvio,
o all'ingresso di uno specifico (System V) runlevel. In tal caso l'amministratore di sistema deve:
<list>
  <item>Inserire lo script <tt>foo</tt> nella directory <file>/etc/init.d/</file>.
  <item>Lanciare il comando Debian <prgn>update-rc.d</prgn> con gli argomenti
    appropriati, per impostare i collegamenti (specificati da riga di comando) fra le
    directory <tt>rc<var>?</var>.d</tt> e <file>/etc/init.d/foo</file>. Qui <var>?</var> è un numero compreso fra
    0 e 6 e corrisponde a ciascun runlevel.
  <item>Riavviare il sistema.
</list>

<p>Il comando <tt>update-rc.d</tt> imposterà i collegamenti fra i files delle
directory <tt>rc<var>?</var>.d</tt> e lo script contenuto in <file>/etc/init.d/</file>.  Ogni
collegamento inizia con una 'S' o una 'K', seguite da un numero, seguiti dal
nome dello script. Gli scripts che iniziano con 'S' in <file>/etc/rc<var>N</var>.d/</file>
verranno eseguiti quando si entra nel runlevel <var>N</var>. Quelli che iniziano con 'K'
verranno eseguiti lasciando il runlevel <var>N</var>.

<p>Si può, per esempio, lanciare lo script <tt>foo</tt> al boot mettendolo
<file>/etc/init.d/</file> ed impostando i collegamenti con <tt>update-rc.d foo
defaults 19</tt>. L'argomento <tt>defaults</tt> fa riferimento ai runlevels di
default, che sono quelli da 2 a 5. L'argomento <tt>19</tt> assicura che lo script
<tt>foo</tt> verrà chiamato prima di qualsiasi altro script con il numero 20 o maggiore.

<sect id="diverse">Supportare le differenze
<p>
Debian offre parecchie opportunità per soddisfare le esigenze (e i desideri)
degli amministratori di sistema, senza per questo renderlo inutilizzabile.
<list>
<item><prgn>dpkg-divert</prgn>, vedere <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, vedere <ref id="equivs">.
<item><prgn>update-alternative</prgn>, vedere <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> può accettare svariati boot loaders. 
      Vedere <manref name="make-kpkg" section="1">.
</list>
Tutti i file in <file>/usr/local/</file> appartengono all'amministratore di
sistema e &debian; non li toccherà. Gran parte (o tutti) i file in
<file>/etc</file> sono <tt>conffiles</tt> e &debian; non li sovrascriverà in
caso di aggiornamento a meno che l'amministratore non lo richieda
espressamente.

<sect id="i18n">Internazionalizzazione

<p>
Il sistema &debian; è internazionalizzato e fornisce il supporto per la visualizzazione
e la scrittura dei caratteri in molte lingue, sia da console che sotto X. Molti
documenti, pagine manuali e messaggi di sistema sono stati tradotti in numero
sempre crescente di lingue. Durante l'installazione Debian chiede all'utente
di scegliere la lingua di installazione (e talvolta una variante locale della
stessa).
<p>
Se il vostro sistema non supporta tutte le caratteristiche della lingua di cui
avete bisogno, o se dovete cambiare la lingua od installare una diversa
tastiera che supporti la vostra lingua, andate a leggere <ref id="l10n">.

<sect id="kernel-details">Debian ed il kernel
<p>
Vedere <ref id="kernel">.

<sect1 id="non-debian-kernel">Compilare un kernel da un sorgente non-Debian

<p><!--Yes.  But you have--> 
Bisogna comprendere la politica debian nei confronti degli headers.

<p>Le librerie C Debian sono compilate con le versioni <strong>stabili</strong> più
recenti degli headers del <strong>kernel</strong>.

<p>Ad esempio, le versione Debian-1.2 usava la versione 5.4.13 degli
headers. Questa pratica è in contrasto con i pacchetti sorgente del kernel
distribuiti in tutti gli archivi Linux FTP, pacchetti che usano versioni
persino più recenti degli headers. Gli headers distribuiti con i sorgenti del
kernel sono localizzati in <file>/usr/include/linux/include/</file>.

<p>Se avete bisogno di compilare un programma con headers più recenti di
quelli di quelli forniti da <package/libc6-dev/, quando compilate dovete
aggiungere alla riga di comando <tt>-I/usr/src/linux/include/</tt>. Un
problema del genere è uscito, per esempio, quando si è creato il pacchetto del
demone automounter (<package/amd/). Quando i nuovi kernels cambiavano alcune
istruzioni relative al NFS, <prgn>amd</prgn> aveva necessità di esserne al
corrente. Ciò ha richiesto l'inclusione degli headers più recenti.

<sect1 id="customkernel">Gli strumenti per compilare un kernel personalizzato.

<p>Gli utenti che desiderano (o devono) compilare un kernel personalizzato, sono
 incoraggiati a scaricare il pacchetto <package/kernel-package/. Il pacchetto
 contiene lo script per compilare il pacchetto del kernel e fornisce le
 capacità di creare un pacchetto Debian kernel-image, semplicemente dando
 il comando 
<example>
make-kpkg kernel_image
</example> 
dalla directory  principale del kernel sorgente.  L'aiuto è disponibile dando il comando
<example>
make-kpkg --help
</example> 
o tramite la pagina man <manref name="make-kpkg" section="8"> e <ref id="kernel">.

<p>L'utente deve scaricarsi a parte il sorgente per il kernel, sia esso il più
recente o quello di scelta, dall'archivio Linux preferito, a meno che un
pacchetto kernel-source-<var>version</var> non sia disponibile (dove <var>version</var> sta per la
versione del kernel). Lo script di boot Debian <file>initrd</file> richiede una speciale patch del kernel,
chiamata <prgn>initrd</prgn>; vedere <url id="&bug-initrd;">.

<p>Le istruzioni dettagliate per usare il pacchetto <package/kernel-package/
sono fornite nel file <tt>/usr/doc/kernel-package/README</tt>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">Boot loaders alternativi
<p>
Per utilizzare boot loaders alternativi, tipo <package/grub/ o
<package/loadlin/, copiate il kernel compilato <file>bzimage</file> 
in un'altra locazione (tipo <file>/boot/grub</file> od una partizione MS-DOS).
</sect1>

<sect1 id="custombootdisk">Boot floppy personalizzato

<p>Questo compito è fortemente aiutato dal pacchetto Debian <package/boot-floppies/,
reperibile normalmente nella sezione <tt>admin</tt> dell'archivio FTP Debian.
Gli script di shell di questo pacchetto producono dei boot floppies nel
formato <prgn>syslinux</prgn>. Questi sono floppy formattati MS-DOS i cui
master boot records sono stati modificati in maniera tale da fare il boot di
Linux (o di qualsiasi altro S.O. sia stato definito nel file <tt>syslinux.cfg</tt> del
floppy) direttamente. Altri script del pacchetto producono dei dischi root di
emergenza e possono persino riprodurre i dischi base.

<p>Maggiori informazioni in <file>/usr/doc/boot-floppies/README</file> dopo
l'installazione del pacchetto <package/boot-floppies/ .

<sect1 id="modules">Funzioni speciali per trattare con i moduli

<p>Il pacchetto Debian <package/modconf/ fornisce uno script di shell
(<file>/usr/sbin/modconf</file>) che può essere utilizzato per personalizzare la
configurazione dei moduli. Lo script presenta un'interfaccia a menu, chiedendo
all'utente particolari circa i device drivers caricabili presenti sul proprio
sistema. La risposte vengono utilizzate per personalizzare il file
<file>/etc/modules.conf</file> (che elenca alias ed altri argomenti che devono
essere utilizzati insieme ai vari moduli), tramite i files in
<file>/etc/modutils/</file>, e <file>/etc/modules</file> (che elencano i moduli che
devono essere caricati al boot).

<p>Così come i (nuovi) files Configure.help ora disponibili per aiutare nella
compilazione di kernels personalizzati, il pacchetto <package/modconf/ arriva con tutta
una serie di file di aiuto (in <file>/usr/share/modconf/</file>) che forniscono
informazioni dettagliate sugli argomenti appropriati da dare a ciascun modulo.
Vedere <ref id="kernel-modules"> per gli esempi.

<sect1 id="removeoldkernel">Disinstallare un vecchio pacchetto kernel

<p>Si, lo script <tt>kernel-image-<var>NNN</var>.prerm</tt> controlla se il kernel
attualmente in uso è lo stesso che state tentando di disinstallare. Perciò
potete rimuovere pacchetti kernel che non volete più tramite il comando:

<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(sostituite <var>NNN</var> con la versione ed il numero di revisione del vostro kernel, naturalmente)
</sect>
