<!-- CVS revision of this document "$Revision: 1.25 $"  -->
<!-- CVS revision of original english document "1.85"  -->
<chapt id="system">Nozioni fondamentali della Debian

<!-- 

Merged from 4 SGML files in FAQ Feburuary 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding nonenglish is added.

Mereged from another SGML files in FAQ Feburuary 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suits "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suite more for ptato and woody.
Unless scollegamento  is used, howmany people care dpkg-ftp :)

-->

<p>
Questo capitolo fornisce le informazioni fondamentali sul sistema debian per i
non-sviluppatori. Per avere informazioni più autorevoli,
vedere:
<list>
<item>Debian Policy Manual 
<item>Debian Developer's Reference 
<item>Debian New Maintainers' Guide
<p>
</list>
reperibili sotto <ref id="references">.

<p>
Se state cercando una qualsiasi risposta che li riguarda senza, però, tutti i
loro dettagli,andate direttamente a <ref id="package"> o ad altri capitoli.
<p>
Questo capitolo è formato da documenti presi dalla "Debian FAQ", e
profondamente riorganizzati, per permettere ad un qualsiasi amministratore di
un sistema Debian di avere un solido punto di partenza.

<!-- 
"FTP archives" is now changed as simple "archives" since it can be
reached throgh HTTP and other method 
-->

<sect id="ftparchives">Gli archivi Debian

<sect1 id="dirtree">Struttura della directory

<p>Il software impacchettato per la debian, è disponibile in una delle numerose
directory su ciascun
<url id="&mirror-site;" 
     name="Mirror Debian"> raggiungibili tramite FTP o HTTP.

<p>Queste sono le directory presenti su ciascun mirror, sotto la directory
<tt>/debian/</tt>:
<taglist>
  <tag><file>/dists/</file>:
    <item>Contiene le "distribuzioni" ed era il luogo canonico di accesso dei
    pacchetti disponibili nelle versioni rilasciate e pre-rilascio. Alcuni
    vecchi pacchetti ed i files <file>Packages.gz</file> sono ancora qui.
  <tag><file>pool/</file>:
    <item>Nuova locazione, che contiene fisicamente tutti i pacchetti, sia
    quelli della versione rilasciata, che quelli pre-rilascio.
  <tag><file>tools/</file>:
    <item>Utilità DOS per creare dischetti boot, partizionare il disco rigido,
    comprimere/decomprimere i file e lanciare Linux.
  <tag><file>doc/</file>:
    <item>La documentazione base, come le FAQ, le istruzioni per la notifica
    dei bachi, ecc.
  <tag><file>indices/</file>:
    <item>I file dei Manutentori, ed i file override.
  <tag><file>project/</file>:
    <item>In gran parte materiale solo per sviluppatori, tipo:
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>Pacchetti e strumenti ancora in via di sviluppo, in fase alfa. I
        normali utenti non dovrebbero utilizzare i pacchetti qui contenuti,
        che possono essere pericolosi persino per i più esperti.
      <tag><file>project/orphaned/</file>:
        <item>Pacchetti lasciati dai loro vecchi manutentori e tolti dalla
        distribuzione.
    </taglist>
</taglist>

<sect1 id="dists">Le distribuzioni Debian

<p>Di norma sono tre le distribuzioni contenute nella directory
<file>dists</file>.  Sono definite come la distribuzione <tt>stable</tt>, la
<tt>testing</tt> e
la <tt>unstable</tt>.  Talvolta se ne aggiunge una quarta, la <tt>frozen</tt>.  
Ogni distribuzione viene definita con un collegamento simbolico alla
directory reale, tramite un nome proprio nella directory <file>dists</file>.

<sect1 id="stable">La distribuzione <tt>stable</tt>

<p>Le voci dei pacchetti per la distribuzione <tt>stable</tt>, &stabledebian;, 
vengono inserite nella directory <file>stable</file> (collegamento simbolico a
<file>&stablecodenamedir;/</file>):
<list>
  <item><file>stable/main/</file>:
  Contiene i pacchetti che costituiscono formalmente il
  rilascio più recente del sistema &debian;.

  <p>Tutti i pacchetti sono totalmente complianti con le <url name="Linee
  guida Debian per il Software Libero" id="&social-contract;#guidelines"> (DFSG) (disponibile anche
  come <file>&f-social-contract;</file> installato da 
  <package>&p-social-contract;</package>).

  <item><file>stable/non-free/</file>: Contiene i pacchetti la cui distribuzione è in
  qualche modo limitata, tale da richiedere ai distributori delle cautele
  dovute ai loro requisiti specifici di copyright.

  <p>Per esempio alcuni pacchetti hanno licenze che ne vietano la
  distribuzione commerciale. Altri possono essere ridistribuiti, ma sono degli
  shareware. 

  <item><file>stable/contrib/</file>: Contiene i pacchetti che sono di per sè DFSG-free e
  DFSG-liberi, ma dipendono in qualche modo da un
  pacchetto che <strong>non è</strong> DFSG-libero.
</list>
Ora, in aggiunta alle locazioni sopra descritte, i nuovi pacchetti sono fisicamente localizzati 
nella directory <file>pool</file> (<ref id="pools">).

<p>Lo stato attuale dei bachi della distribuzione <tt>stable</tt> è riportato in sulla
pagina Web <url id="&stable-problems;" name="Problemi di Stable">.

<sect1 id="testing">La distribuzione  <tt>testing</tt>

<p>Le voci dei pacchetti per la distribuzione <tt>testing</tt>, &testingdebian;, 
sono registrate nella directory <file>testing</file> (collegamento simbolico a
<file>&testingcodenamedir;</file>) 
dopo aver subito un periodo di prova in <tt>unstable</tt>.  
Ora, in aggiunta alle locazioni sopra descritte, i nuovi pacchetti sono fisicamente localizzati 
nella directory <file>pool</file> (<ref id="pools">).  
La directory <file>testing</file> ha delle sottodirectory, <file>main</file>,
<file>contrib</file> e <file>non-free</file>, che hanno le stesse funzioni che in
<file>stable</file>.

<p>I pacchetti devono essere sincronizzati in tutte le architetture per le
quali sono stati compilati e non devono mostrare dipendenze tali da renderli
non installabili; devono inoltre avere meno bachi release-critical delle
versioni in <tt>unstable</tt>. In questo modo si auspica che <tt>testing</tt> sia sempre molto
vicina ad essere candidata al rilascio. Per maggiori dettagli sul meccanismo
che regola la distribuzione vedere <url id="&testing-notes;">.

<p>Lo stato aggiornato della distribuzione <tt>testing</tt> è riportato presso:
<list>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="bug release-critical">
<item><url id="&qa-base-bugs;" 
         name="bug del base system">
<item><url id="&qa-standard-bugs;" 
         name="bug nei pacchetti standard e dei task">
<item><url id="&qa-bugs;" 
         name="altri bug e note sul bug squashing party">
</list>

<sect1 id="unstable">La distribuzione <tt>unstable</tt>

<p>Le voci dei pacchetti della distribuzione <tt>unstable</tt>, sempre con
nome in codice "Sid", sono registrate nella directory <file>unstable</file>
(collegamento simbolico a <file>sid/</file>) dopo
essere state caricate nell'archivio Debian, rimanendovi finchè non vengono spostate in
<file>testing</file>.  I nuovi pacchetti sono fisicamente localizzati 
nella directory <file>pool</file> (<ref id="pools">).  
La directory <file>unstable</file> ha delle sottodirectory, <file>main</file>,
<file>contrib</file> e <file>non-free</file>, che hanno le stesse funzioni che in
<file>stable</file>.

<p>La distribuzione <tt>unstable</tt> contiene le immagini più recenti del
sistema in fase di sviluppo. Gli utenti possono liberamente usare e testare
questi pacchetti, ma vengono avvisati del loro precario stato di
preparazione. Il vantaggio di usare <tt>unstable</tt> è
quello di essere sempre al massimo dell'aggiornamento del progetto &debian;
relativo al software&mdash;siate però pronti a raccogliere i pezzi se
qualcosa va storto.

<p>Lo stato aggiornato della distribuzione <tt>unstable</tt> è riportato presso la pagina
Web <url id="&unstable-problems;" name="Unstable Problems">.

<!-- Above was enough
<sect1 id="sid">La distribuzione Sid

<p>Sid o <tt>unstable</tt> è il posto dove gran parte dei pacchetti vengono
inizialmente caricati. Non verrà mai rilasciata direttamente, poichè i
pacchetti che devono essere rilasciato devon prima essere inseriti in <tt>testing</tt>,
per poter poi essere rilasciati in <tt>stable</tt> successivamente. Sid
contiene i pacchetti sia per le architetture rilasciate, sia per quelle per le
quali non c'è stato un rilascio.

<p>The name "sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">La distribuzione <tt>frozen</tt>

<p>Una volta che la distribuzione testing è sufficientemente matura, diventa
frozen; ciò significa che nessun nuovo codice viene più accettato, solo
eliminazioni di bachi, se necessari. In aggiunta un nuovo albero testing viene
creato nella directory <file>dists</file>, con un nuovo nome. La distribuzione
frozen passa attraverso un ciclo di test (chiamato appunto "test cycles") di
qualche mese caratterizzato da aggiornamenti intermittenti ed importanti stabilizzazioni.(Il recente processo di rilascio di <tt>woody</tt> non ha prodotto
un collegamento  simbolico <file>frozen</file>, così <tt>frozen</tt> non era una distribuzione, ma
solo uno stadio di sviluppo della distribuzione <tt>testing</tt>.)

<p>Viene tenuto un registro dei bug della distribuzione frozen che possono
impedire il rilascio di un pacchetto o di tutta la distribuzione. Una volta
che il conteggio dei bug scende al di sotto di una valore massimo
prestabilito, la distribuzione frozen diventa <tt>stable</tt> e viene rilasciata. La
precedente distribuzione stable diventa obsoleta (e finisce in archivio).

<sect1 id="codenames">Codice dei nomi della distribuzioni Debian

<p>I nomi delle directory localizzate fisicamente nella directory
<file>dists</file>, come <file>&stablecodenamedir;</file> e <file>&testingcodenamedir;</file>, sono semplicemente dei
nomi in codice. Quando una distribuzione &debian; è nella fase di sviluppo le viene
assegnato un nome in codice e non un numero di versione. Lo scopo di questi
nomi è di rendere il mirroring delle distribuzioni &debian; più semplice (se, ad
esempio, una directory reale come <file>unstable</file> cambiasse improvvisamente
di nome in <file>stable</file>, una gran quantità di programmi dovrebbe essere
nuovamente scaricata senza motivo).
<p>Attualmente <file>stable</file> è un collegamento 
simbolico a <file>&stablecodenamedir;</file> e <file>testing</file> è un
collegamento  simbolico a <file>&testingcodenamedir;</file>. Ciò significa che <tt>&stablecodename;</tt> è la
distribuzione attualmente stable e <tt>&testingcodename;</tt> è l'attuale testing.

<p><file>unstable</file> è un collegamento  simbolico permanente a
<file>sid</file>, dato che Sid è sempre la distribuzione unstable. <!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">Nomi in codice usati in passato

<p>I nomi in codice che sono già stati utilizzati sono: 
"Buzz" per la release 1.1, 
"Rex" per la 1.2, 
"Bo" per la 1.3.x,
"Hamm" per la 2.0, 
"Slink" per la 2.1, 
"Potato" per la 2.2,
"Woody" per la 3.0  e
"Sarge" per la 3.1.


<sect1 id="sourceforcodenames">Da dove vengono i nomi delle distribuzioni?

<p>Finora sono stati presi dai nomi dei personaggi del film <em> Toy
Story</em> della Pixar.
<list>
  <item><strong>Buzz</strong> (Buzz Lightyear) era l'astronauta,
  <item><strong>Rex</strong> era il tirannosauro,
  <item><strong>Bo</strong> (Bo Peep) era la bambina che si prese cura della pecorella,
  <item><strong>Hamm</strong> era il porcellino salvadanaio,
  <item><strong>Slink</strong> (Slinky Dog) era il cane giocattolo,
  <item><strong>Potato</strong> era, ovviamente, Mr. Potato,
  <item><strong>Woody</strong> era il cowboy.
  <item><strong>Sarge</strong> era il "leader of The Green Plastic Army Men".
  <item><strong>Etch</strong> (Etch-a-Sketch) era la lavagna.
  <item><strong>Sid</strong> era il bambino della porta accanto che rompeva i giocattoli.
</list>
<!--
  more info in http://www.pixar.com/feature/toystory/toystory.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the collegamento s in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">La directory <file>pool</file>

<p>Storicamente i pacchetti erano contenuti nella subdirectory di <file>dists</file>
corrispondente alla distribuzione di cui facevano parte. Questo portò a vari
problemi, tipo un grosso consumo di banda di connessione dei mirror ogni volta
che venivano fatti dei cambiamenti di grossa entità.

<p>Ora i pacchetti vengono tenuti in una grossa "vasca" (pool), strutturata in
accordo con il nome del pacchetto sorgente. Per rendere il tutto maneggevole,
la vasca è suddivisa in sezioni (<tt>main</tt>, <tt>contrib</tt> e <tt>non-free</tt>) e per la prima
lettera del nome del pacchetto sorgente. Queste directory contengono svariati
file: binari per ciascuna architettura ed i pacchetti sorgente da cui i
pacchetti binari sono stati generati.

<p>E' possibile sapere dove ciascun pacchetto è situato eseguendo un comando tipo:
<tt>apt-cache showsrc <var>nomemiopacchetto</var></tt> ed andando a leggere la riga "Directory:".
Per esempio, i pacchetti <package>apache</package> sono immagazzinati in
<file>pool/main/a/apache/</file>. Essendo molteplici, i pacchetti <tt>lib*</tt>
vengono trattati in maniera particolare: per esempio, i pacchetti <package>libpaper</package> sono
immagazzinati in <file>pool/main/libp/libpaper/</file>.


<p>Le directory <file>dists</file> vengono ancora utilizzate per i file indice
usati da programmi tipo <prgn>apt</prgn>. Inoltre, al momento attuale le vecchie
distribuzioni non sono state convertite ad usare le vasche, per cui si
troveranno i percorsi contenenti distribuzioni tipo <tt>potato</tt> o <tt>woody</tt> nel campo
"Filename" dell'intestazione.

<p>Di norma non avete da preoccuparvi di ciò, poichè il nuovo <prgn>apt</prgn> e 
probabilmente il vecchio <prgn>dpkg-ftp</prgn> sono  in grado di gestire la cosa senza problemi. Se volete maggiori informazioni, andate
a vedere 
<url id="&pool-faq;" name="RFC: implementazione dei pool dei pacchetti">.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Alcune note storiche su Sid

<p>Quando il Sid attuale non esisteva, l'organizzazione dell'archivio Debian
aveva un problema principale: l'assunto che quando un'architettura veniva
creata nell'attuale <file>unstable</file>, sarebbe stata rilasciata quando la distribuzione
diventava la nuova <tt>stable</tt>. Però per molte architetture questo non era il caso,
con il risultato che quelle directory dovevano essere mosse al momento del
rilascio. Fatto poco pratico, poichè lo spostamento avrebbe fagocitato grosse
quantità di banda.

<p>Gli amministratori dell'archivio hanno evitato questo problema per
pacchetti anni piazzando i binari delle architetture ancora non rilasciate in
una directory speciale chiamata <file>sid</file>. Al momento del loro rilascio esisteva un collegamento 
dall'architettura a quel momento <file>stable</file> a <file>sid</file> e da quel momento in poi essa
veniva creata all'interno dell'albero <file>unstable</file>, come di norma. Tutto ciò era
motivo di confusione per gli utenti.

<p>Con l'avvento della vasca dei pacchetti (vedere <ref id="pools">) durante
lo sviluppo della distribuzione Woody i pacchetti binari cominciarono ad
essere immagazzinati in una locazione canonica nella vasca, indipendentemente
dalla distribuzione; in tal modo il rilascio di una distribuzione non
determina più la grossa dispersione di banda sui mirror (c'è, ovviamente, un
notevole consumo, ma graduale, di banda durante la fase di sviluppo).

<sect1 id="incoming">Pacchetti caricati in <file>incoming</file>

<p>
I pacchetti che vengono caricati nell'archivio vengono dapprima immagazzinati
in <url id="&incoming;"> prima di accertarsi che provengano realmente da uno
sviluppatore Debian (e vengono piazzati nella sottodirectory <file>DELAYED</file> in caso
di Non-Maintainer Upload (NMU)). Una volta al giorno, vengono mossi da
<file>incoming</file> ad <file>unstable</file>.
<p>
In caso di emergenza, potreste voler installare i pacchetti da qui, prima che
raggiungano <file>unstable</file>.
</sect1>

<sect1 id="snapshot">Recuperare un vecchio pacchetto
<p>
Mentre le distribuzioni Debian più recenti vengono tenute nella directory
<file>debian</file> su ciascun <url id="&mirror-site;" name="Mirror
Debian">, gli archivi per le distribuzioni più vecchie, tipo Scollegamento , sono
tenuti su <url id="&archivehome;"> o sotto la directory
<file>debian-archive</file> di ciascun mirror Debian.
<p>
I vecchi pacchetti <tt>testing</tt> ed <tt>unstable</tt> sono localizzati in
<url id="&snapshothome;">.

</sect1>

<sect1 id="archsections">Sezioni per architettura 
<!-- What are all those
directories inside <tt>dists/stable/main</tt>?  
Simplified this !!!  
-->

<p>All'interno di ciascun albero directory principale
(<file>dists/stable/main</file>, <file>dists/stable/contrib</file>,
<file>dists/stable/non-free</file> <file>dists/unstable/main</file>, etc.),
le voci dei pacchetti binari risiedono all'interno di sottodirectory i cui
nomi indicano l'architettura per la quale sono stati compilati.

<list>
  <item><file>binary-all/</file>, per pacchetti architettura-indipendenti.
    Comprendono, per esempio, scripts Perl o pura documentazione.
  <item><file>binary-<var>piattaforma</var>/</file>, per pacchetti che
    girano su una particolare piattaforma.  
  <!-- Yes I simplified this -->
</list>

<p>Ricordate che i reali pacchetti binari per <tt>testing</tt> ed
<tt>unstable</tt> non risiedono più in queste directory, ma al livello
principale della directory <file>pool</file>. I file elenco (<file>Packages</file>
e <file>Packages.gz</file>) sono stati comunque mantenuti, per compatibilità con il vecchio sistema.

<p>Per sapere quali architetture sono al momento supportate, leggetevi le Note
di Rilascio per ciascuna distribuzione. Possono essere trovate presso i siti
delle Note di Rilascio per <url id="&stable-release;" name="stable"> e <url
id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.  
<p>See <ref id="arches">
for more information.  -->

<sect1 id="source">Il codice sorgente

<p>Il codice sorgente è disponibile per ogni cosa contenuta nel sistema
Debian. In più, i termini di licenza della maggior parte dei programmi
<strong>richiedono</strong> che il codice venga distribuito insieme ai
programmi, o che un'offerta di fornire il codice li accompagni.

<p>Di regola il codice viene reperito nelle directory <file>source</file>, che
sono in parallelo a tutte le directory dei binari architettura-specifiche, o
più di recente alla directory <file>pool</file> (vedere <ref id="pools">). Per
scaricare il codice sorgente senza la necessità di essere addentro alla
struttura dell'archivio Debian, provate un comando tipo <!--FTP--> <tt>apt-get
source <var>nomemiopacchetto</var></tt>.

<p>Alcuni pacchetti, in particolare <package>pine</package>, sono disponibili
solamente come sorgenti, a causa delle limitazioni delle licenze. (Recentemente è stato fornito il pacchetto
<package>pine-tracker</package> per facilitare l'installazione di Pine). 
Le procedure descritte in <ref id="port"> e <ref id="packaging"> dovrebbero
fornire tutto il necessario per compilare un pacchetto manualmente.

<p>Il codice sorgente potrebbe non essere disponibile, invece, per i pacchetti
delle directory <file>contrib</file> e <file>non-free</file>, che formalmente non fanno parte del
sistema Debian.

<sect id="pkg-basics">Il sistema di gestione dei pacchetti Debian 

<sect1 id="package-basics">Panoramica dei pacchetti Debian

<p>Normalmente i pacchetti contengono tutti i file necessari all'implementazione
 di una serie di comandi o di funzionalità. Esistono due tipi di pacchetti:

<list>
  <item><strong>Pacchetti binari</strong>, che contengono eseguibili, file di
  configurazione, pagine man/info, informazioni sul copyright ed altra
  documentazione. Questi pacchetti vengono distribuiti in un formato specifico
  alla Debian (vedere <ref id="deb-format">);
  si riconoscono per il suffisso <tt>.deb</tt>. Questi pacchetti possono essere
  "spacchettati" usando l'utilità tutta Debian <prgn>dpkg</prgn>; i dettagli si
  possono vedere alla pagina di manuale corrispondente.
  
  <item><strong>Pacchetti sorgente</strong>, che consistono in un file <tt>.dsc</tt>
  che descrive il pacchetto sorgente (inclusi in nomi dei file seguenti), un
  file <tt>.orig.tar.gz</tt> che contiene i sorgenti originali non modificati
  in formato tar gzip ed in genere un file <tt>.diff.gz</tt> che contiene le
  modifiche specifiche per Debian ai sorgenti originali. L'utilità
  <prgn>dpkg-source</prgn> impacchetta e spacchetta questo tipo di pacchetti. Per
  i dettagli, ovviamente, la pagina man corrispondente.
</list>

<p>L'installazione del software attraverso il sistema dei pacchetti utilizza
delle "dipendenze", che sono state dichiarate dal responsabile (manutentore) del pacchetto. Le dipendenze vengono descritte nel file
<file>control</file>, associato a ciascun pacchetto. Ad esempio, il pacchetto
contenente il compilatore GNU C (<package/gcc/) "dipende" dal
pacchetto <package/binutils/ che include il collegamento e l'assembler. Se
si prova ad installare <package/gcc/ senza aver prima installato
<package/binutils/, il sistema di gestione dei pacchetti (dpkg)
invierà un messaggio di errore riguardo alla necessità di avere anche
<package/binutils/ e bloccherà l'installazione di <package/gcc/.  (Questo comportamento può comunque essere scavalcato
dall'utente tenace, vedere al riguardo <manref name="dpkg" section="8">.)
Per dettagli aggiuntivi, vedere più sotto in <ref id="depends">.

<p>Gli strumenti Debian per la gestione dei pacchetti possono essere usati
per:
<list>
  <item>manipolare e gestire i pacchetti o parte di essi, 
  <item>aiutare l'utente nella frammentazione dei pacchetti che devono essere trasmessi con
    un mezzo di limitate capacità come un floppy,
  <item>aiutare gli sviluppatori nella costruzione degli archivi dei pacchetti e 
  <item>aiutare gli utenti nell'installazione dei pacchetti residenti in un archivio remoto <!--FTP-->
     Debian.
</list>

<sect1 id="deb-format">Il formato dei pacchetti Debian <!--binary-->

<p>Un "pacchetto" Debian, od un file dell'archivio Debian contiene gli
eseguibili,le librerie e tutta la documentazione associata ad un gruppo o
suite di programmi correlati. I file dell'archivio Debian, di norma, hanno il
suffisso <tt>.deb</tt>.
<footnote>
<!-- Below added by Osamu based on a message posted by Colin Watson -->
<p>Il progetto <prgn>debian-installer</prgn> ha introdotto dei pacchetti i cui
nomi finiscono in <tt>.udeb</tt>.  In breve, è un formato micro-<tt>.deb</tt>
che non necessita di seguire alla lettera le linee guida Debian, manca di alcune
parti, tipo la documentazione ed è pensato per essere utlizzato solo dal
<prgn>debian-installer</prgn>, il nuovo programma di installazione Debian,
sviluppato per il rilascio di Sarge. I due formati, <tt>.deb</tt> e
<tt>.udeb</tt> sono uguali. Il programma <prgn>udpkg</prgn>, usato per gestire
i pacchetti <tt>.udeb</tt>, ha limitate capacità rispetto a
<prgn>dpkg</prgn> e supporta minori relazioni fra i pacchetti. La differenza
di nomi sta nel fatto che i manutentori dell'archivio Debian non erano
contenti di avere dei <tt>.deb</tt> che non seguissero le regole, per cui
venne scelto un nome diverso per accentuare questa diversità e per rendere
meno probabile l'installazione accidentale su sistemi reali.  Gli <tt>.udeb</tt>
vengono usati in un ramdisk iniziale durante l'installazione di base, solo per
creare un sistema Debian molto ristretto.
</footnote>

<p>I dettagli dei pacchetti binari Debian sono descritti nella pagina di
manuale <manref name="deb" section="5">. Il loro formato interno è soggetto a cambiamenti
(tra una versione maggiore e l'altra di &debian;), per cui leggete sempre
<manref name="dpkg-deb" section="8"> prima di manipolare i<tt>.deb</tt>
file.

<!-- Below added by Osamu XXX Not sure but should be right -->

<p>Almeno fino a Sarge, gli archivi Debian sono sempre stati manipolabili
anche dai normali comandi Unix, tipo <prgn>ar</prgn> e <prgn>tar</prgn>, anche
quando i comandi <prgn>dpkg</prgn> non erano disponibili.

<sect1 id="pkgname">Convenzioni nei nomi dei pacchetti Debian
<!--
Why are Debian package file names so long? 
-->
<p>Il nome di un pacchetto Debian <!--binary--> segue la convenzione seguente:
<example>
<var>foo</var>_<var>ver</var>-<var>rev</var>_<var>arch</var>.deb
</example>
Dove in genere <var>foo</var> sta per il nome del pacchetto. 
<var>ver</var> è la versione del programma originale,
<var>rev</var> è il numero di revisione Debian e
<var>arch</var> è l'architettura per la quale il pacchetto è stato compilato.
I file vengono facilmente rinominati, naturalmente.
Potete scoprire quale pacchetto è realmente contenuto in un dato
file di none <var>filename</var> 
dando il comando seguente:
<example>dpkg --info <var>filename</var></example>

<p> Il numero di revisione Debian viene specificato dallo sviluppatore Debian 
o da chiunque compili il pacchetto.
Un cambio nel numero di revisione in genere indica che qualche aspetto
nel pacchetto è cambiato.

<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Mantenimento della configurazione locale
<!--
What is a Debian conffile
-->
<p>I file che sono considerati modificabili dall'amministratore locale 
si trovano in <file>/etc</file>.
Le linee guida &debian; prescrivono che tutte le modifiche ai file localmente
configurabili vengano mantenute attraverso gli aggiornamenti dei pacchetti.
<p>
Se una versione predefinita di un file localmente configurabile viene
fornita con il pacchetto stesso, allora il file viene etichettato come un
"conffile".  Il sistema di gestione dei pacchetti non aggiorna i conffile
che sono stati modificati dall'amministratore dopo l'ultima installazione del
dato pacchetto senza prima aver chiesto il permesso dell'amministratore
stesso. D'altro canto, se il conffile non è stato modificato, allora verrà
aggiornato insieme al 
resto del pacchetto.
Ciò è sempre auspicabile, così
è vantaggiorso minimizzare le modifiche ai conffile.

<p>Per elencare i conffile appartenenti ad un dato pacchetto,
lanciare: 
<example>
dpkg --status <var>package</var>
</example> 
L'elenco segue la riga "Confflies".

<p>
Per maggiori informazioni sui conffile potete leggere la sezione del
Debian Policy Manual
intitolata "Configuration files"
(Vedere <ref id="references">).

<sect1 id="maintscripts">Script di gestione Debian
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Gli script di gestione Debian
sono degli script eseguibili che vengono lanciati automaticamente prima o dopo
l'installazione di un pacchetto. Insieme ad un file chiamato
<file>control</file>, tutti questi file fanno parte della sezione "control" di un file Debian.

<p>I singoli file sono:
<taglist>
<tag/preinst/
  <item>Questo script viene eseguito prima che il pacchetto venga estratto dal
  file Debian (<tt/.deb/). Molti script "preinst" interrompono i servizi per i
  pacchetti che devono essere aggiornati fino a che la loro installazione o
  aggiornamento non sono completati (a seguire dell'esecuzione con successo
  dello script "postinst").

<tag/postinst/
  <item>Questo script tipicamente completa ogni configurazione
  richiesta da un pacchetto dopo che è stato estratto
  dal suo file Debian (<tt/.deb/). Spesso gli script "postinst" richiedono
  all'utente determinate azioni e/o lo avvertono che, qualora accettasse le
  impostazioni di base, deve ricordarsi di riconfigurare il pacchetto se la
  situazione lo richiede. Molti script "postinst", poi, eseguono tutti i
  comandi necessari a lanciare o far ripartire i servizi, dopo che il
  pacchetto è stato aggiornato o installato.

<tag/prerm/
  <item>Questo script ferma tutti i demoni associati con un
  pacchetto. Viene eseguito prima della rimozione di file associati ad un
  determinato pacchetto.

<tag/postrm/
  <item>Modifica i collegamenti od altri file correlati ad un pacchetto
  e/o rimuove i files creati da esso.(Vedere anche <ref
  id="virtual">.)
</taglist>

<p>Tutti i file di controllo possono essere localizzati nella directory
<file>/var/lib/dpkg/info</file>. I file correlati con il pacchetto <tt>foo</tt>
iniziano, appunto, con il nome "foo" ed hanno le estensioni "preinst",
"postinst", ecc. a seconda della funzione.  Il file <tt>foo.list</tt> nella
stessa directory elenca tutti i file installati con il pacchetto
<tt>foo</tt>.  (Notate che la localizzazione di questi file è interna a
dpkg e può essere soggetta a modifiche.)

<sect1 id="priority">Priorità dei pacchetti
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Ad ogni pacchetto viene assegnata una <strong>priorità</strong> dai responsabili
della distribuzione, come aiuto al sistema di gestione dei pacchetti. Le
priorità sono:

<list>
  <item><strong>Richiesto</strong> (Required): pacchetti necessari al corretto
    funzionamento del sistema.  
    <p>Comprende tutti gli strumenti necessari alla riparazione di difetti di sistema. Questi pacchetti non devono essere
    rimossi, pena la completa inutilizzabilità del sistema, probabilmente
    nemmeno con <prgn>dpkg</prgn> si riuscirebbe a mettere le cose a posto. I sistemi con
    solo i pacchetti Richiesti probabilmente sarebbero inutilizzabili, ma hanno
    abbastanza funzionalità per permettere all'amministratore di sistema di
    fare un boot ed installare altri programmi.
  <item><strong>Importante</strong> (Important): pacchetti che si ritrovano probabilmente
    su qualsiasi sistema Unix o correlato.  
    <p>Altri pacchetti necessari ad un corretto funzionamento del sistema, senza i quali non sarebbe
    utilizzabile. Tra questi <strong>non</strong> sono inclusi Emacs o X11 o TeX o
    qualsiasi altra grossa applicazione. Qui si parla di pacchetti che
    costituiscono l'infrastruttura di base.
  <item><strong>Standard</strong>: pacchetti comuni su qualsiasi sistema
    Linux, compreso un sistema ragionevolmente piccolo ma nemmeno troppo
    limitato all'interfaccia a carattere.
    <p>Questo è ciò che viene installato di base se l'utente non seleziona altro. Non include grosse
    applicazioni, però include Emacs (più un pezzo di infrastruttura che
    un'applicazione) ed un ragionevole sottogruppo di TeX e LaTeX (se è
    possibile senza X).
  <item><strong>Opzionale</strong> (Optional): pacchetti che comprendono tutto quello di cui
    potete aver voglia di installare senza nemmeno sapere che cosa è, o se non
    avete delle necessità particolari.  
    <p>Comprende X11, una distribuzione completa di TeX e molte applicazioni.  
  <item><strong>Extra</strong>:
    pacchetti che o entrano in conflitto con altri di priorità più alta,
    probabilmente utili se già sapete a che servono, oppure hanno requisiti
    speciali che li rendono non consoni come "Opzionali".
</list>
<p>Notate le differenze fra "Priority: required", "Section:
base" ed "Essential: yes" nella descrizione dei pacchetti. "Section: base"
significa che il pacchetto viene installato prima tutti su un nuovo sistema.
Molti dei pacchetti in "Section: base" hanno "Priority:
required" o almenot "Priority: important" e molti di loro sono etichettati
con "Essential: yes".  "Essential: yes" significa che il pacchetto richiede
di specificare un'ulteriore opzione force al sistema di gestione dei
pacchetti, tipo <prgn>dpkg</prgn> quando viene rimosso dal sistema. Per
esempio, <package>libc6</package>, <package>mawk</package> e
<package>makedev</package> sono "Priority: required" and "Section: base"
ma non "Essential: yes".

<sect1 id="virtual">Pacchetti Virtuali

<p>Il termine pacchetto virtuale è un termine generico che si applica a tutti
i pacchetti di un gruppo che provvede alla medesima funzione. Per esempio, i
programmi <prgn>tin</prgn> e <prgn>trn</prgn> sono entrambi dei newsreader, in grado
di soddisfare qualsiasi dipendenza di un programma che richieda un newsreader
su un sistema, al fine di funzionare correttamente. Entrambi, quindi, si dice
che provvedano il "pacchetto virtuale" definito <package>news-reader</package>.


<p>Allo stesso modo <package>exim</package> <package>exim4</package>,
<package>sendmail</package> e <package>postfix</package> forniscono la
funzionalità di un agente di trasporto posta (mail transport agent). 
Perciò, provvedono al pacchetto virtuale <package>mail transport
agent</package>. Se uno di loro
è installato, qualsiasi programma che dipenda dall'installazione di un
agente di trasporto posta vedrà le proprie dipendenze soddisfatte
dall'esistenza di questo pacchetto virtuale.

<p>La Debian ha un meccanismo tale che, se più di un pacchetto che fornisce lo
stesso pacchetto virtuale è installato, l'amministratore di sistema è in grado
di sceglierne uno come pacchetto preferito. Il comando che viene chiamato in
causa è<prgn>update-alternatives</prgn> e verrà descritto in dettaglio oltre, in
<ref id="alternatives">.

<sect1 id="depends">Dipendenze dei pacchetti
<p>Il sistema dei pacchetti Debian ha una serie di dipendenze che sono
utilizzate per esprimere il fatto che un pacchetto, per 
funzionare, o per funzionare meglio, ha bisogno dell'installazione di un altro
pacchetto:
<list>
  <item>Il Pacchetto A <strong>Dipende</strong> dal Pacchetto B se B deve essere
    assolutamente installato per eseguire A. In alcuni casi, esso noN dipende
    solo da B, ma da una sua specifica versione. In tal caso la dipendenza
    dalla versione rappresenta un limite inferiore, nel senso che A dipende da
    qualsiasi versione di B più recente di quella specificata.  
  
  <item>Il Pacchetto A <strong>Raccomanda</strong> il B, se il responsabile del
    pacchetto giudica che la maggior parte degli utenti non vorrebbe A senza
    le funzioni fornite anche da B.  
  
  <item>Il Pacchetto A <strong>Suggerisce</strong> B se B contiene file correlati e
    che migliorano le funzioni di A.
    La stessa relazione si esprime dichiarando che il
    Pacchetto B <strong>Migliora</strong> il Pacchetto B.
    
  <item>Il Pacchetto A <strong> è in Conflitto</strong> con B quando A non è in grado
    di funzionare se B è installato nel sistema. Spesso "è in conflitto" 
    è combinato con "Sostituisce".
  
  <item>Il Pacchetto A <strong>Sostituisce</strong> B quando i file installati da B
    vengono rimossi o sovrascritti da quelli in A.  
  
  <item>Il Pacchetto A <strong>Fornisce</strong> B quando tutti i file e le funzioni di B
    vengono incorporate da A. 
</list>

<p>Informazioni più dettagliate possono essere trovate nel 
<em>Packaging Manual</em> e nel <em>Policy Manual</em>.

<p>Notate che <prgn>dselect</prgn> ha un controllo molto più raffinato
sui pacchetti contrassegnati da <strong>Raccomanda </strong> e <strong>Suggerisce</strong>
rispetto ad <prgn>apt-get</prgn>, che prende semplicemente tutti i pacchetti
specificati da <strong>Dipende</strong> e lascia quelli indicati da <strong>Raccomanda</strong> e
<strong>Suggerisce</strong>. Entrambi i programmi nelle forme più moderne utilizzano
come back-end APT.

<sect1 id="pre-depends">Cosa significa "Pre-Depends"

<p><prgn>dpkg</prgn> conigura sempre un pacchetto da cui ne Dipende un altro
prima di configurare quast'ultimo.
Tuttavia, <prgn>dpkg</prgn> in genere spacchetterà il file seguendo un ordine
arbitrario, indipendentemente dalle dipendenze.
(Spacchettare il file vuol dire che estrarre i file e metterli
al posto giusto).
Se, però un pacchetto <strong>Pre-Dipende</strong> da un altro, allora quast'ultimo
veràà spacchettato e configurato prima che quello che ne Pre-Dipende sia anche
solo spacchettato.

<footnote>
Questo meccanismo è stato previsto per supportare un aggiornamento sicuro di
sistemi dal formato <tt>a.out</tt> al formato <tt>ELF</tt>, dove
<strong>l'ordine</strong> in cui i pacchetti venivano estratti risultava critico. 
</footnote>

L'uso di questo tipo di dipendenza è ridotto al minimo.

<sect1 id="pkgstatus">Lo stato dei pacchetti
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Lo stato di un pacchetto può essere "sconosciuto", "installa", "rimuovi",
"elimina" o "mantieni".  Queste etichette "voglio", indicano il volere
dell'utente riguardo ad un pacchetto (come indicato dalle azioni dell'utente
nella sezione "Scegli" di <prgn>dselect</prgn> o dal richiamo diretto dell'utente
di <prgn>dpkg</prgn>).

<p>Il loro significato è il seguente:
<list compact>
  <item><strong>sconosciuto</strong> - l'utente non ha mai indicato se vuole il pacchetto
  
  <item><strong>installa</strong> - l'utente vuole il pacchetto installato od aggiornato
  
  <item><strong>rimuovi</strong> - l'utente vuole che il pacchetto sia rimosso, ma non i suoi
                file di configurazione.  
  <item><strong>elimina</strong> - l'utente vuole il pacchetto completamente rimosso, compresi 
                i file di configurazione.  
  <item><strong>mantieni</strong> - l'utente non vuole che il pacchetto sia processato, ovvero 
                vuole mantenere la versione attuale con lo stato corrente,
		qualunque essa sia.
</list>

<sect1 id="puttingonhold">Evitare l'aggiornamento dei pacchetti
<!--
How do I put a package on hold?
Made major rewite to accomodate new /etc/apt/preferences in progress
-->
<p>Esistono due modi per evitare l'aggiornamento di un pacchetto, tramite <prgn>dpkg</prgn> o,
 da Woody in poi, tramite APT.

<p>Con <prgn>dpkg</prgn>, dovete solo esportare la lista dei pacchetti selezionati con:
<example>
dpkg --get-selections &gt; <var>selections.txt</var>
</example>
Dopodichè modificate il file risultante <file><var>selections.txt</var></file>, cambiando la riga che
contiene il pacchetto da mantenere, tipo <package/libc6/, da:
<example>
libc6                       install
</example>
a:
<example>
libc6                       hold
</example>
Salvate il file e ricaricatelo nel database di <prgn>dpkg</prgn> con:
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
Se conoscete il nome del pacchetto da mantenere, basta eseguire: 
<example>
echo libc6 hold | dpkg --set-selections
</example> 
Questo processo evita l'aggiornamento dei pacchetti al momento dell'installazione di ciascun file.

<p>Lo stesso risultato si ottiene tramite <prgn>dselect</prgn>. Basta accedere alla
schermata [S]cegli, trovare il pacchetto da mantenere nello stato attuale e
premere il tasto `=' (o `H'). I cambiamenti saranno effettivi non appena
lasciata la schermata [S]cegli.

<p>Il sistema APT nella nuova distribuzione Woody ha un meccanismo alternativo
per mantenere i pacchetti durante il processo di raccolta di un archivio,
utilizzando la <tt>Pin-Priority</tt>.
Vedere la pagina di manuale <manref name="apt_preferences" section="5">, l'<url id="&apt-howto;"> o il
pacchetto <package>&p-apt-howto;</package>.

<sect1 id="sourcepkgs">Pacchetti sorgente

<p>
I pacchetti sorgente vengono distribuiti in una directory chiamata
<file>source</file> e possono essere scaricati o manualmente, oppure tramite il comando
<example>
apt-get source <var>foo</var>
</example>
(vedere <manref name="apt-get" section="8"> la pagina man su come impostare APT all'uopo).


<sect1 id="sourcebuild">Compilare pacchetti binari dai sorgenti

<p>Per un dato pacchetto <tt><var>foo</var></tt> avete bisogno di tutti i <file><var>foo_*</var>.dsc</file>,
<file><var>foo_*</var>.tar.gz</file> e <file><var>foo_*.diff</var>.gz</file> (nota bene: non esiste nessun <tt>.diff.gz</tt> per un 
pacchetto Debian nativo).

<p>Una volta presi, se avete installato il pacchetto <package/dpkg-dev/ il seguente
comando:
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
estrarrà il pacchetto in una directory denominata 
<tt><var>foo-version</var></tt>.

<p>Date i seguenti comandi per compilare il pacchetto binario:
<example>
$ cd foo-versione
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
poi
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
per installarlo. Vedere <ref id="port">.

<!-- Woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Creare nuovi pacchetti Debian

<p>Per maggiori dettagli al riguardo, leggete la <em>New Maintainers'
Guide</em>, reperibile nel pacchetto <package/maint-guide/ oppure presso
<url id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Aggiornare un sistema Debian

<p>Uno degli scopi della Debian è di fornire un sentiero solido di
ed un processo sicuro di aggiornamento. Il sistema di gestione dei pacchetti
avverete l'amministratore delle modifiche importanti e talvolta gli chiede di
prendere delle decisioni.
Dovreste leggere anche le Note di Rilascio;
vengono fornite con tutti i CD Debian e sono disponibili sul WWW presso
<url id="&stable-release;"> oppure <url id="&testing-release;">.

<p>
Una guida pratica viene fornita in <ref id="package">. Questa sezione 
fornisce una panoramica generale, cominciando con gli strumenti di gestione
dei pacchetti.

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>E' il programma principale per la manipolazione dei pacchetti.
Per ulteriori informazioni, leggere la pagina di manuale <manref name="dpkg" section="8">.
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> è fornito con parecchi programmi supplementari di base.

<list>
<item><prgn>dpkg-deb</prgn>: Manipola i files <tt>.deb</tt>. 
 <manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>: Vecchio comando per il recupero dei pacchetti. 
 <manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>: Vecchio comando per il recupero dei pacchetti. 
 <manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>: Divide grossi pacchetti in files più piccoli. 
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> e <prgn>dpkg-mountable</prgn> sono stati resi obsoleti
dall'introduzione del sistema APT.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT (Advanced Packaging Tool) è un'interfaccia avanzata per il sistema Debian di gestione dei pacchetti
e consiste di vari programmi i cui nomi iniziano tipicamente con "apt-". 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn> e <prgn>apt-cdrom</prgn> 
sono gli strumenti da riga di comando per maneggiare i pacchetti. Funzionano
anche come programmi backend per l'utente di altri strumenti, come <prgn/dselect/ 
ed <prgn/aptitude/.

<p>Per maggiori informazioni, installare <package/apt/ e leggere
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (Woody), e
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>Esistono fonti di informazione alternative, come
<url id="&apt-howto;" name="APT HOWTO">.
Può essere installato tramite <package/apt-howto/ in
<file>&f-apt-howto;</file>.

<p><tt>apt-get upgrade</tt> e <tt>apt-get dist-upgrade</tt> prendono solo
i pacchetti elencati sotto "Dipende", mentre lasciano quelli sotto "Raccomanda" e "Suggerisce". Per evitare ciò,
usate <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>Questo programma rappresenta un'interfaccia utente basata su menu al
sistema di gestione dei pacchetti. E' particolarmente utile per prime
installazioni ed aggiornamenti su larga scala. Vedere <ref id="dselect">.

<p>Per ulteriori informazioni, installare <package/install-doc/ e leggere
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> oppure <url
id="&dselect-beginner;" name="Documentazione per dselect per Principianti">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single-user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <tt>start-stop-daemon</tt> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Aggiornare un sistema in funzione

<p>Il kernel (filesystem) in &debian; supporta la sostituzione dei file anche mentre sono in uso.
Quando i pacchetti vengono aggiornati, tutti i servizi forniti da essi vengono
riavviati se sono configurati per girare nel runlevel corrente.
Il sistema Debian non ha bisogno della modalità singolo
utente per aggiornare un sistema in funzione.


<sect1 id="savedebs">File <tt>.deb</tt> scaricati e tenuti in cache

<p>Se avete scaricato i pacchetti nel vostro disco rigido (cosa assolutamente non
necessaria, vedere sopra per la descrizione di <prgn>dpkg-ftp</prgn> o di APT), 
dopo l'installazione
dei pacchetti potete rimuoverli dal vostro sistema.

<p>Se si usa APT, i file vengono tenuti nella directory
<file>/var/cache/apt/archives</file>.  
Potete cancellarli dopo l'installazione (<tt>apt-get clean</tt>), oppure copiarli sulla stessa directory
<file>/var/cache/apt/archives</file> di un'altra macchina, per evitare un nuovo download 
durante la successiva installazione.

<sect1 id="keepingalog">Tenere una registrazione dell'aggiornamento

<p><prgn/dpkg/ mantiene una registrazione dei pacchetti scompattati,
configurati, rimossi e/o eliminati, ma (al momento) non tiene nessuna
registrazione dell'attività scritta su terminale durante tali manipolazioni.

<p>Il metodo più semplice per aggirare questo impedimento è di lanciare una
qualsiasi sessione di <prgn>dpkg</prgn>, <prgn>dselect</prgn> <prgn>apt-get</prgn>, ecc. all'interno del
programma <manref name="script" section="1">.

<sect id="boot">La sequenza di boot della Debian

<sect1 id="init">Il programma <prgn>init</prgn>

<p>Come ogni buon appartenente alla famiglia degli Unix, Debian esegue il boot
eseguendo il programma <prgn>init</prgn>.  Il file di configurazione di
<prgn>init</prgn> (che è <file>/etc/inittab</file>) specifica che il primo script da
eseguire deve essere <file>/etc/init.d/rcS</file>. 
<p>
Quello che accade poi dipende se è installato il pacchetto <package>sysv-rc</package>
oppure <package>file-rc</package>. Quanto segue assume che sia installato
<package>sysv-rc</package>.
(<package>file-rc</package> il proprio script
<file>/etc/init.d/rcS</file> ed usa un file invece che collegamenti simbolici
nelle directory rc per controllare quali servizi siano stati avviati ed in
quali runlevel.)
<p>
Il file <file>/etc/init.d/rcS</file> del pacchetto <package>sysv-rc</package>
lancia tutti gli script in <file>/etc/rcS.d/</file> per eseguire
l'inizializzazione, tipo controllo e montaggio dei filesystem, 
caricamento dei
moduli, lancio dei servizi di rete, impostazione dell'orologio, e così via.
Poi, per compatibilità, lancia tutti i file (tranne
quelli con `.' nel filename) localizzati 
in <file>/etc/rc.boot/</file>. Quest'ultima è riservata
all'amministratore di sistema,
ed il suo utilizzo è deprecato.
Vedere <ref id="init-hints"> e
<url id="&sysvinit;" name="System run levels and init.d scripts">
nel Debian Policy Manual per maggiori informazioni.
<p>
Debian non usa una directory <tt>rc.local</tt> in stile BSD.

<sect1 id="runlevels">I Runlevel

<p>Dopo il completamento del processo di boot, <prgn>init</prgn> lancia tutti i
servizi configurati per girare nel runlevel predefinito.
Questo è definito dalla riga per <tt>id</tt> in 
<file>/etc/inittab</file>.
Debian arriva con <tt>id=2</tt>.
<p>
Debian usa i seguenti runlevel:
<list compact>
  <item>1 (modalità singolo utente),
  <item>2 a 5 (varie modalità multiutente) e
  <item>0 (arresta il sistema)
  <item>6 (riavvia il sistema).
</list>
I runlevel 7, 8, e 9 possono essere utilizzati, ma le loro directory rc non
vengono popolate quando i pacchetti vengono installati.
<p>
Scambiate i runlevel mediante il comando <prgn>telinit</prgn>.
<p>
Quando si entra in un runlevel tutti gli script in
<file>/etc/rc<var>runlevel</var>.d/</file> 
vengono eseguiti.
La prima lettera del nome determina il
<strong>modo</strong> in cui lo script viene lanciato:
quelli che iniziano con <tt>K</tt> vengono lanciati con l'argomento
<tt>stop</tt>.
Quelli che iniziano per <tt>S</tt> vengono lanciati con l'argomento
<tt>start</tt>.
Gli script vengono eseguiti in ordine alfabetico;
per cui quelli "stop" vengono lanciati prima di quelli "start" e i numeri a
due cifre che seguono <tt>K</tt> o <tt>S</tt> determinano l'ordine in cui
venono eseguiti.
<p>
Gli script in <file>/etc/rc<var>runlevel</var>.d</file> sono infatti semplici
collegamenti simbolici agli script in
<tt>/etc/init.d/</tt>.
Essi accettano anche argomenti tipo "restart" e "force-reload";
questi ultimi metodi possono essere utilizzati dopo che un sistema è stato
avviato per riavviare i servizi o forzarli a ricaricare i loro file di
configurazione.

<p>Per esempio:
<example>
# /etc/init.d/exim4 reload
</example>

<sect1 id="custombootscripts">Personalizzare i runlevel
<p>
La personalizzazione dei runlevel è un compito avanzato di amministrazione di
sistema. Il suggerimento seguente vale per gran parte dei servizi.
<p>
Per abilitare il servizio <var>service</var> nel runlevel <var>R</var>
create il collegamento simbolico
<file>/etc/rc<var>R</var>.d/S<var>xy</var><var>service</var></file>
con obiettivo
<file>../init.d/<var>service</var></file>.
Il numero di sequenza <var>xy</var> dovrebbe essere quello che è 
stato assegnato al servizio quando il pacchetto è stato installato.
<p>
Per disabilitare il servizio, rinominate il the collegamento simbolico in maniera 
che il nome inizi con <tt>K</tt> invece che con <tt>S</tt>
ed il suo numero di sequenza sia 100 meno <var>xy</var>.
<p>
E' conveniente usare un editor di runlevel, come
<prgn>sysv-rc-conf</prgn> o <prgn>ksysv</prgn>
per questi scopi.
<p>
E' possibile cancellare il collegamento simbolico <tt>S</tt> ad un servizio
in una data directory di un dato runlevel
invece di rinominarlo.
Ciò non disabilita il servizio, ma lo
lascia in uno stato "fluttuante", finchè il sistema di inizio
<package>sysv-rc</package> è interessato: al cambio di
runlevel il servizio non sarà nè lanciato nè fermato, ma verrà lasciato
così com'è, che stia girando o no. Notate comunque che un servizio
lasciato in uno stato tale verrà lanciato se il pacchetto
corrispondente verrà aggiornato, che girasse o meno
prima dell'aggiornamento.
Questo è un limite noto del sistema Debian attuale.
Notate anche che dovreste mantenere i collegamenti simbolici <tt>K</tt> di un
servizio nei runlevel 0 e 6.
Se cancellate tutti i collegamenti simbolici di un servizio, allora 
durante un aggiornamento il pacchetto corrispodente ripristinerà tutti i collegamenti simbolici
al loro stato predefinito iniziale.
<p>
<strong>Not</strong> è consigliabile modificare i collegamenti simbolici
in <file>/etc/rcS.d/</file>.

<sect id="diverse">Supportare le differenze
<p>
Debian offre parecchie opportunità per soddisfare le esigenze (e i desideri)
degli amministratori di sistema, senza per questo renderlo inutilizzabile.
<list>
<item><prgn>dpkg-divert</prgn>, vedere <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, vedere <ref id="equivs">.
<item><prgn>update-alternative</prgn>, vedere <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> può accettare svariati boot loaders. 
      Vedere <manref name="make-kpkg" section="1"> e <ref id="kernel-debian">.
</list>
Tutti i file in <file>/usr/local/</file> appartengono all'amministratore di
sistema e &debian; non li toccherà. Gran parte dei file in
<file>/etc</file> sono <tt>conffiles</tt> e &debian; non li sovrascriverà in
caso di aggiornamento a meno che l'amministratore non lo richieda
espressamente.

<sect id="i18n">Internazionalizzazione
<p>
Il sistema &debian; è internazionalizzato e fornisce il supporto per la visualizzazione
e la scrittura dei caratteri in molte lingue, sia da console che sotto X. Molti
documenti, pagine di manuali e messaggi di sistema sono stati tradotti in numero
sempre crescente di lingue. Durante l'installazione Debian chiede all'utente
di scegliere la lingua di installazione (e talvolta una variante locale della stessa).
<p>
Se il vostro sistema non supporta tutte le caratteristiche della lingua di cui
avete bisogno, o se dovete cambiare la lingua od installare una diversa
tastiera che supporti la vostra lingua, andate a leggere <ref id="l10n">.

<sect id="kernel-details">Debian ed il kernel
<p>
Vedere <ref id="kernel">.

<sect1 id="non-debian-kernel">Compilare un kernel da un sorgente non-Debian

<p><!--Yes.  But you have--> 
Bisogna comprendere le linee guida Debian nei confronti degli header.

<p>Le librerie C Debian sono compilate con le versioni <strong>stabili</strong> più
recenti degli header del <strong>kernel</strong>.

<p>Ad esempio, le versione Debian-1.2 usava la versione 5.4.13 degli
header. Questa pratica è in contrasto con i pacchetti sorgente del kernel
distribuiti in tutti gli archivi Linux FTP, pacchetti che usano versioni
persino più recenti degli header. Gli header distribuiti con i sorgenti del
kernel sono localizzati in <file>/usr/include/linux/include/</file>.

<p>Se avete bisogno di compilare un programma con header più recenti di
quelli di quelli forniti da <package/libc6-dev/, quando compilate dovete
aggiungere alla riga di comando <tt>-I/usr/src/linux/include/</tt>. Un
problema del genere è uscito, per esempio, quando si è creato il pacchetto del
demone automounter (<package/amd/). Quando i nuovi kernel cambiavano alcune
istruzioni relative al NFS, <prgn>amd</prgn> aveva necessità di esserne al
corrente. Ciò ha richiesto l'inclusione degli header più recenti.

<sect1 id="customkernel">Gli strumenti per compilare un kernel personalizzato.

<p>Gli utenti che desiderano (o devono) compilare un kernel personalizzato, sono
 incoraggiati a scaricare il pacchetto <package/kernel-package/. Il pacchetto
 contiene lo script per compilare il pacchetto del kernel e fornisce le
 capacità di creare un pacchetto Debian kernel-image, semplicemente dando
 il comando 
<example>
# make-kpkg kernel_image
</example> 
dalla directory  principale del kernel sorgente.  
L'aiuto è disponibile dando il comando
<example>
# make-kpkg --help
</example> 
o tramite la pagina di manuale <manref name="make-kpkg" section="8"> 
e <ref id="kernel">.

<p>L'utente deve scaricarsi a parte il sorgente per il kernel, sia esso il più
recente o quello di scelta, dall'archivio Linux preferito, a meno che un
pacchetto kernel-source-<var>version</var> non sia disponibile (dove <var>version</var> sta per la
versione del kernel). Lo script di boot Debian <file>initrd</file> richiede una speciale patch del kernel,
chiamata 
<prgn>initrd</prgn>; vedere <url id="&bug-initrd;">.

<p>Le istruzioni dettagliate per usare il pacchetto <package/kernel-package/
sono fornite nel file <file>/usr/share/doc/kernel-package/README.gz</file>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">Boot loader alternativi
<p>
Per utilizzare boot loader alternativi, tipo <package/grub/ o
<package/loadlin/, copiate il kernel compilato <file>bzimage</file> 
in un'altra locazione (tipo <file>/boot/grub</file> od una partizione MS-DOS).
</sect1>

<sect1 id="custombootdisk">Boot floppy personalizzato

<p>Questo compito è fortemente aiutato dal pacchetto Debian 
<!-- FIXME: boot-floppies is no package in Woody but an installation program
 Is this Potato specific? -->
<package/boot-floppies/, reperibile normalmente nella sezione <tt>admin</tt> dell'archivio FTP Debian.
Gli script di shell di questo pacchetto producono dei boot floppy nel
formato <prgn>syslinux</prgn>. Questi sono floppy formattati MS-DOS i cui
master boot record sono stati modificati in maniera tale da fare il boot di
Linux (o di qualsiasi altro S.O. sia stato definito nel file
<file>syslinux.cfg</file> del floppy) direttamente. Altri script del pacchetto producono dei dischi root di
emergenza e possono persino riprodurre i dischi base.

<p>Maggiori informazioni in <file>/usr/doc/boot-floppies/README</file> 
dopo
l'installazione del pacchetto <package/boot-floppies/ .

<sect1 id="modules">Funzioni speciali per trattare con i moduli

<p>Il pacchetto Debian <package/modconf/ fornisce uno script di shell
(<file>/usr/sbin/modconf</file>) che può essere utilizzato per personalizzare la
configurazione dei moduli. Lo script presenta un'interfaccia a menu, chiedendo
all'utente particolari circa i device drivers caricabili presenti sul proprio
sistema. La risposte vengono utilizzate per personalizzare il file
<file>/etc/modules.conf</file> (che elenca alias ed altri argomenti che devono
essere utilizzati insieme ai vari moduli), tramite i file in
<file>/etc/modutils/</file>, e <file>/etc/modules</file> (che elencano i moduli che
devono essere caricati al boot).

<p>Così come i (nuovi) file <file>Configure.help</file> ora disponibili per aiutare nella
compilazione di kernel personalizzati, il pacchetto <package/modconf/ arriva con tutta
una serie di file di aiuto (in <file>/usr/share/modconf/</file>) che forniscono
informazioni dettagliate sugli argomenti appropriati da dare a ciascun modulo.
Vedere <ref id="kernel-modules"> per gli esempi.

<sect1 id="removeoldkernel">Disinstallare un vecchio pacchetto kernel

<p>Si, lo script <tt>kernel-image-<var>NNN</var>.prerm</tt> controlla se il kernel
attualmente in uso è lo stesso che state tentando di disinstallare. Perciò
potete rimuovere pacchetti kernel che non volete più tramite il comando:

<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(sostituite <var>NNN</var> con la versione ed il numero di revisione del vostro kernel, naturalmente)
</sect>
