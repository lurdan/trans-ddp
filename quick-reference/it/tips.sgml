<!-- CVS revision of this document "$Revision: 1.4 $"  -->
<!-- CVS revision of original english document "1.15"  -->
<chapt id="tips"> Trucchi per GNU/Linux

<sect>Il sistema di boot
<p>
Vedete <file>/usr/share/doc/HOWTO/en-txt/BootPrompt-HOWTO.txt.gz</file> 
(LDP) per informazioni dettagliate sul prompt del boot.

<sect1 id="crackroot">Ho scordato la password di root (1)
<p>
Il sistema può comunque essere lanciato nell'account di root, anche se
non se ne conosce la password, basta avere accesso alla tastiera. (Ciò
significa che non esistono altre password richieste dal BIOS, o dal
boot-loader (tipo lilo) che possono prevenire l'accesso al sistema).
<p>
Questa procedura non richiede alcun disco di boot, nè cambiamenti al
BIOS. In questo contesto, "Linux" è l'etichetta per lanciare il kernel
in una installazione Debian standard.
<p>
Alla schermata di boot di lilo (in alcuni sistemi si deve premere il
tasto shift), date:
<example>
boot: Linux init=/bin/sh
</example>
Il sistema lancia il kernel ed esegue /bin/sh al posto dello standard
init. A questo punto avete ottenuto i privilegi di root e la shell di
root. Siccome, però, / è montata in sola lettura e molte altre
partizioni non sono state ancora montate, avete bisogno di eseguire i
passi seguenti per avere un sistema ragionevolmente funzionante.
<example>
init-2.03# mount -n -t remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
Una voce vuota nella seconda colonna di uno di questi files,
disabilita la password. Diversamente da alcuni vecchi Linux, la debian
potato richiede la password solo le si esegue il boot nel runlevel 1.
</sect1>

<sect1>Ho scordato la password di root (2)
<p>
Fate il boot da qualunque set di dischi di emergenza boot/root. Se,
per esempio, /dev/hda3 è la partizione di root originale, i seguenti
comandi permetteranno di aprire il file password facilmente come
sopra.
<example>
# mkdir fixit
# mount /dev/hda3 fixit
# cd fixit/etc
# vi shadow
# vi passwd
</example>
<p>
Il vantaggio di questo approccio rispetto al metodo precedente è che
non richiede la conoscenza della password di lilo. Però, bisogna
essere in grado di settare il boot del sistema da floppy o da CD.
</sect1>

<sect1>Non riesco a fare il boot
<p>
Nessun problema. Nessuno si prende la briga di fare un dischetto di
boot durante l'installazione. Se lilo non funziona, usate come disco
di boot il disco di installazione di Debian (il primo). eseguite il
boot da questo disco. Al prompt, data la partizione di root in
/dev/hda12, e runlevel 3 quello che volete, date:
<example>
boot: rescue root=/dev/hda12 3
</example>
A questo punto siete entrati in un sistema praticamente totalmente
funzionante, basato sul kernel del dischetto. (Potrete avere piccole
noie, dovute alla mancanza di alcuni moduli).
<p>
Se volete crearvi un vostro boot floppy, leggete il readme.txt sul
disco di rescue.
</sect1>

<sect1 id="bootprompt">Altri trucchi per il boot prompt.
<p>
Potete fare il boot in un particolare runlevel e configurazione
tramite il prompt di lilo. I dettagli li potete trovare nel
BootPrompt-HOWTO.txt.gz.
<p>
Se volete fare il boot nel runlevel 4, date il seguente comando al
prompt di lilo.
<example>
boot: Linux 4
</example>
<p>
Se si vuole il boot in modalità singolo utente, conoscendo la password
di root, potete usare uno dei seguenti esempi.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Se sivuole il boot con meno memoria di quanta il sistema ne abbia
(mettiamo 48M in un sistema con 64M), basta dare il seguente comando
al prompt.
<example>
boot: Linux mem=48M
</example>
Evitate di specificare più memoria di quanta ne abbiate, altrimenti il
kernel si pianterà inevitabilmente. Se si hanno più di 64M, per
esempio 128M, con vecchi kernel o BIOS bisogna specificare il comando
mem=128M al prompt, altrimenti non verranno usati più di 64M.
</sect1>
</sect>

<sect>Registrazione degli eventi
<sect1 id="script">Registrare gli eventi della shell
<p>
L'amministrazione di sistema in ambiente Unix è rappresentata da una
serie di compiti molto più elaborati che in un ambiente di un normale
PC.  E' importante conoscere i modi di configurazione basilari, in
caso di soluzione dei problemi del sistema. Le interfacce grafiche di
configurazione basate su X sono carine e convenienti, ma comunque
limitate, specialmente in queste occasioni.
<p>
In questo contesto, la registrazione degli eventi della shell è una
buona pratica, specialmente come root.
<p>
Emacs: Usate "M-x shell" per iniziare la registrazione in un buffer e
"C-x C-w" per scrivere il buffer su un file.
<p>
Shell: Usate il comando script.
<example>
$ script
Script started, file is typescript
 .... fate quello che dovete ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
Si può usare il seguente invece di script.
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>
<sect1>Registrare gli eventi di X
<p>
Se dovete registrare l'immagine di una applicazione di X, incluso
x-term, usate gimp. Può catturare ogni singola finestra, oppure lo
schermo intero. Un'alternativa è xwd (da console).
</sect1>
</sect>

<sect>Muovi / Copia File
<p>
Se dovete riarrangiare l'organizzazione delle directory, muovete il
contenuto, links compresi con:
<example>
# (cd /directory_di_partenza &amp;&amp; tar cf - . ) | \
        (cd /directory_di_arrivo &amp;&amp; tar xvfp - )
# cp -a /directory_di_partenza /directory_di_arrivo
# (cd /directory_di_partenza &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /directory_di_arrivo &amp;&amp; tar xvfp - )
Se non ci sono links:
# scp -pr user1@host1.dom:/directory_di_partenza user2@host2.dom:/directory_di_arrivo
</example>
Qui, scp &lt;==&gt; rcp e ssh &lt;==&gt; rsh.
<p>
If you worry about details such as hardlinks, right way is
<example>
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
</example>
</sect>

<sect>Modificare i files con le espressioni regolari
<p>
Sostitusce tutte le istanze di FROM_REGEX con TO_REGEX 
in tutti i files FILES ...:
<example>
# perl -i -p -e 's/FROM_REGEX/TO_REGEX/g;' FILES ...
</example>
"-i" sta per "editing sul-posto", "-p" sta per "loop implicito tra i FILES ...".
</sect>


<sect>Recuperare un sistema bloccato
<sect1>Uccidere un processo
<p>
Lanciate "top" per vedere quale processo si comporta in maniera
"sconveniente". Premete "P" per ordinarli per tempo di cpu, "M" per
consumo di memoria e "k" per uccidere il processo.
<p>
Usate "kill" e "killall" per uccidere (o mandare il segnale) al
processo, per nome.
<example>
 1: HUP,  riavvia il demone
15: TERM, uccisione normale
 9: KILL, uccisione "dura".
</example>

</sect1>

<sect1>ALT-SysRQ
<p>
L'assicurazione contro i malfunzionamenti di sistema è un'opzione di
compilazione del kernel, denominata "Magic SysRQ key". Premendo
ALT-SysRQ su un sistema i386, mediante una sola chiave 'r0keisub', si
ottiene la "magia".
<p>
un'R'aw riavvia la tastiera quando cose tipo X si bloccano. Cambiare
il loglevel a 0 riduce i messagi di errore. sa'K' (system attention
key) uccide tutti i processi sulla console virtuale attuale.  t'E'rm
uccide tutti i processi su terminale corrente tranne init. k'I'll
uccide tutti i processi, tranne init.
<p>
'S'ync, 'U'mount, e re'B'oot sono utili per uscire da situazioni
veramente spinose.
<p>
I kernel debian standard non sono compilati al momento con questa
opzione attivata. Ricompilate il kernel per farlo. Informazioni
dettagliate le trovate in
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>

<sect>Files di configurazione

<sect1>Controllo del login
<p>
[FIXME]
<example>
/etc/securetty           # controlla il root login da console
/etc/hosts.{allow|deny}  # controlla il login dall'host
/etc/pam.d/login         # controlla il login
</example>
<p>
Decommentate "ALL: PARANOID" in /etc/hosts.deny.
<p>
Cambiate il contenuto di /etc/pam.d/login come segue, se desiderate
dei terminal senza password, ma assolutamente insicuri. A vostro
rischio e pericolo.
<example>
#auth       required   pam_unix.so nullok
auth       required   pam_permit.so
</example>
nfs ecc. richiede il sogin per sunrpc.  "man 8 portmap".
</sect1>

<sect1>Defaults
<p>
<example>
/etc/defaults/rcS        # defaults di boot (motd, sulogin,...)
/etc/syslog.conf         # modalità di log del sistema 
                           (verificate il pacchetto "colorize")
</example>
</sect1>
</sect>

<sect>Alcuni piccoli comandi da ricordare
<sect1>Memoria libera
<p>
"free" e "top" danno buone informazioni sulle risorse di memoria. Non
vi preoccupate sulle dimensioni della memoria "used" nella riga
"Mem:", ma leggete quella sotto.  (38792 nell'esempio qui sotto).
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
La memoria fisica esatta può essere confermata da "grep '^Memory' /var/log/dmesg" 
che è "Memory: 256984k/262144k available (1652k kernel code, 412k 
reserved, 2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free at dmesg = 256984k = Total - kernel - reserved - data - init
Free at shell = 257136k = Total - kernel - reserved - data
</example>
Circa 5MB non sono utilizzabili dal sistema, perchè a disposizione del kernel.
</sect1>

<sect1>Impostare l'ora (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Questo imposterà l'orologio del sistema e dell'hardware a MM/DD hh:mm,
CCYY.  Le ore sono allineate al fuso locale, ma l'orologio
dell'hardware utilizza lo "Universal Time" (UT).
<p>
Coorezione automatica dell'ora di sistema da un server remoto:
<example>
# ntpdate &lt;server&gt;
</example>
Se avete una connessione permanente, è bene averlo in <file>/etc/cron.daily</file>. 
</sect1>

<sect1>Come disabilitare lo screensaver
<p>
In console:
<example>
# setterm -powersave off
</example>
<p>
Lanciate kon2(kanji)con:
<example>
# kon -SaveTime 0
</example>
<p>
In X:
<example>
# xset s off
 o
# xset -dpms
 o
# xscreensaver-command -prefs
</example>
Leggete le pagine man corrispondenti.
</sect1>

<sect1>Disabilitare il suono (beep)
<p>
Potete sempre staccare gli altoparlanti del PC... ;-)  Da shell:
<example>
echo "set bell-style none">> ~/.inputrc:
</example>
</sect1>

<sect1>Messaggi di errore sulla console
<p>
L'impostazione di default da <file>/etc/syslog.conf</file> in Debian è
per sovrascrivere lo schermo in console. Cambiate l'ultima parte di
questo file.
<p>
Eseguite anche "dmesg -n1" per togliere i messaggi di errore su schermo.
</sect1>

<sect1>Riportare la console allo stato normale
<p>
Quando lo schermo impazzisce dopo "$ cat filebinario", (si raccomanda
di digitare alla cieca):
<example>
$ reset
</example>
</sect1>

<sect1>Convertire file di testo da DOS a Unix
<p>
Converte file di testo DOS (^M^J) in file Unix (^J).
<example>
# apt-get install sysutils
$ dos2unix dosfile
</example>
</sect1>

<sect1>Convertire grossi files in files più piccoli
<p>
<example>
$ split -b 650m file   # divide il file in pezzetti di 650 MB
$ cat x* >largefile    # riunisce i files in un unico file
</example>

<sect1>Parti di script per il piping
<p>
Gli script seguenti fanno cose utili come parti di una pipe.
<example>
xargs -n 1 command   # lancia i comandi per tutti gli oggetti da stdin
xargs -n 1 echo|     # divide lo spazio fra gli oggetti in righe
grep -e pattern|     # estrae le righe contenenti i modelli
cut -d: -f3 -|       # estrae il terzo campo separato da :  (file passwd, ecc.)
col -bx |            # rimuove il backspace ed espande le tabs in spazi
expand -|            # espande le tabs
sort -u|             # trova e rimuove i doppioni
tr '\n' ' '|         # concatena le righe in una riga unica
tr '\r' ''|          # rimuove il CR (carriage return, a capo)
tr 'A-Z' 'a-z'|      # converte il maiuscolo in minuscolo
sed 's/^/# /'|       # commenta ogni riga
sed 's/\.ext//g'|    # rimuove .ext
sed  -n -e 2p|       # stampa una seconda riga
head -n 2 -|         # stampa le prime due righe
tail -n 2 -|         # stampa le ultime due righe
</example>
</sect1>

<sect1>Cattura il testo / archivio delle ML da una pagina web.
<p>
Il seguente comando legge la pagina web e la copia in una file di
testo. Molto utile quando si copiano delle configurazioni dalla rete.
<example>
$ lynx -dump http://www.remote-site.com/help-info.html &gt;textfile
</example>
<p>
Se si tratta di un archivio di mailing list, usate "munpack" per ottenere i contenuti mime dal testo.
</sect1>

<sect1>Il comando time
<p>
Mostra il tempo utilizzato dal processo.
<example>
# time df >/dev/null
real    0m0.035s       # tempo sull'orologio a muro (tempo realmente passato)
user    0m0.000s       # tempo in modalità utente
sys     0m0.020s       # tempo in modalità kernel
</example>
</sect1>

<sect1>Il comando nice
<p>
nice (da GNU-shutils) per impostare il valore di nice al lancio del
programma. renice (bsdutild) o top possono rimpostare nice. nice (20)
significa un processo lentissimo. Not-nice (-20) significa super-user
ed un processo molto veloce.
<example>
# nice --19 top                                         # molto nice
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img # molto veloce
</example>
</sect1>

<sect1>Progammare gli eventi (cron, at)
<p>
Usate "cron" e "at" per programmare i task in Linux. Leggete "man at",
"man 5 crontab" e "man 8 crontab".  <p> Eseguite il comando "crontab"
con il file crontab-file per impostare degli eventi con programmazione
irregolare. Ecco un esempio di crontab-file:
<example>
# usa /bin/sh per eseguire i comandi, non importa cosa dice /etc/passwd
SHELL=/bin/sh
# invia ogni output a `paul', non importa a chi appartiene crontab
MAILTO=paul
# Min Hour DayOfMonth Month DayOfWeek comando 
# esecuzione alle 00:05, ogni giorno
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# esecuzione alle 14:15 il I giorno del mese -- output inviato a paul
15 14 1  * *   $HOME/bin/monthly
# esecuzione alle 22:00 i giorni feriali (Lun-Ven) (1-5), annoia Joe. 
% per una nuova riga, l'ultimo % per cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe%Joe,%%Where are your kids?%.%%
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# esecuzione alle 03:40 il I lunedi di ogni mese
40 3 1-7 * *   [ "$(date +%a)" == "Mon" ] && command -args
</example>
Usate il comando "at" per programmare gli eventi che accadono una sola
volta:
<example>
$ echo 'command -args'| at 3:40 monday
</example>
</sect1>

<sect1>Scambio di console
<p>
[FIXME] following seems interesting
<example>
screen per console
xmove  per X
</example>
</sect1>

<sect1>Testare la rete: le basi
<p>
<example>
$ ping yahoo.com            # prova la connessione internet
$ traceroute yahoo.com      # traccia i pacchetti
$ ifconfig                  # prova la configurazione dell'host
$ route -n                  # prova la cofigurazione di routing
$ dig [@dns-server.com] host.dom [{a|mx|any}] |less    \
      # controlla i registri DNS di host.dom [@ dns-server.com] per 
il record [{a|mx|any}]
$ ichains  -L -n |less      # controlla il packet filter (2.2 kernel)
$ iptables -L -n |less      # controlla il packet filter (2.4 kernel)
$ netstat -a | grep LISTEN  # scopre tutte le porte aperte (richiede net-tools)
</example>
</sect1>

<sect1>Eliminare la pasta dallo spool locale
<p>
Per eliminare la posta:
<example>
$ su -c "exim -q"
</example>
</sect1>

<sect1>Pulire il contenuto di un file
<p>
Nel caso al file possano acceder altri, non usare "rm".
<example>
$ :>file-da-ripulire
</example>
</sect1>

<sect1>Files fantoccio
<p>
<example>
$ dd if=/dev/zero    of=nomefile bs=1k count=5 # 5KB di zeri
$ dd if=/dev/urandom of=nomefile bs=1m count=7 # 7MB di contenuto casuale
$ touch nomefile                        #  crea un file di 0B, od aggiorna mtime
</example>
</sect1>

<sect1>chroot
<p>
Potete creare un sistema indipendente condividendo lo stesso kernel.
<example>
# mount /dev/hda1 /mnt/target   # supponiamo che /dev/hda1 contenga 1 sistema
# chroot /mnt/target
... A questo punto è come se root fosse il contenuto di /dev/hda1
# mount proc /proc              # nel caso serva
... lanciate i comandi da dentro /dev/hda1
</example>
Ciò permette di caricare stable/testing/unstable su una sola
macchina. In più, si può far girare un programma che utilizza molta
memoria come dselect, su una macchina host, montando tramite NSF una
macchina satellite sull'host ed entrare tramite chroot con permessi di
lettura e scrittura.
</sect1>

<sect1>Samba
<p>
Le basi per ottenere un file da Window$:
<example>
# mount -t smb -o username=mionome,uid=mio_uid,gid=mio_gid\
   //server/share/mnt/smb/ # monta il file Windows su Linux
# smbclient -L 192.168.1.2 # elenca le condivisioni su un computer
</example>
</sect1>

</sect>

</chapt>

