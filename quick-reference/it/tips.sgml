<!-- CVS revision of this document "$Revision: 1.13 $"  -->
<!-- CVS revision of original english document "1.46"  -->
<chapt id="tips">  Trucchi per &debian;


<sect>Boot del sistema
<p>
Per informazioni dettagliate sul prompt del boot, vedere il 
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> dal LDP.

<sect1 id="crackroot">"Ho scordato la password di root!" (1)
<p>
E' possibile fare il boot del sistema ed accedere all'account di root, anche se
non se ne conosce la password, basta avere accesso alla tastiera. (Premesso che
che non esistono altre password richieste dal BIOS, o dal
boot-loader tipo <prgn>lilo</prgn> che possono impedirvi l'accesso al sistema).
<p>
Questa procedura non richiede alcun disco di boot, nè cambiamenti al
BIOS. In questo contesto, "Linux" è l'etichetta per lanciare il kernel
in una installazione Debian standard.
<p>
Alla schermata di boot di <prgn>lilo</prgn>, non appena appare <tt>boot:</tt>
(in alcuni sistemi si deve premere il tasto maiuscolo per prevenire il boot automatico)
automatic booting), date:
<example>
boot: Linux init=/bin/sh
</example>
Il sistema lancia il kernel ed esegue <file>/bin/sh</file> invece dello
standard <prgn>init</prgn>.  A questo punto avete ottenuto i privilegi di root
e la shell di root.  Siccome, però <file>/</file> è montata in sola lettura e molte altre
partizioni non sono state ancora montate, avete bisogno di eseguire quanto
segue per avere un sistema ragionevolmente funzionante.
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(Se il secondo campo di dati all'interno di <file>/etc/passwd</file> è "x" per ogni
username, il vostro sistema usa le shadow password, per cui dovrete modificare
<file>/etc/shadow</file>.) Per disabilitare la password di root, modificate il secondo
campo nel file password in maniera che risulti vuoto.  Ora potete fare il reboot
ed il log in come root senza una password.  
Quando fa il boot nel runlevel 1, Debian (almeno dopo Potato) 
richiede una password, mentre alcune distribuzioni più vecchie no.
<p>
E' buona cosa avere un piccolo in <file>/bin</file> 
nel caso in cui <file>/usr</file> non fosse accessibile (vedere <ref id="bin-editor">).
<p>
Considerate anche l'installazione del pacchetto <package>sash</package>.  
Se il sistema diventa non più avviabile, eseguite:
<example>
boot: Linux init=/bin/sash
</example>
<prgn>sash</prgn> funziona come sostituto interattivo di 
<prgn>sh</prgn> persino quando <file>/bin/sh</file> è inutilizzabile.  
Ha un collegamento statico ed include molte utilità di base al suo interno
(digitate "help" al prompt per una lista).
</sect1>

<sect1 id="crackroot2">"Ho scordato la password di root!" (2)
<p>
Fate il boot da qualunque set di dischi di emergenza boot/root. Se,
per esempio, <file><var>/dev/hda3</var></file> è la partizione di root originale, i seguenti
comandi permetteranno di aprire il file password facilmente come
sopra.
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
Il vantaggio di questo approccio rispetto al metodo precedente è che
non richiede la conoscenza della password di <prgn>lilo</prgn> (se esiste).
Però, bisogna essere in grado di settare il BIOS, se non lo è già, in modo che
il boot del sistema sia da floppy o da CD.
</sect1>

<sect1 id="dead-lilo">Non riesco a fare il boot
<p>
Nessun problema, persino se non vi siete presi la briga di fare un dischetto di
boot durante l'installazione. Se <prgn>lilo</prgn> non funziona, usate come disco
di boot il disco di installazione di Debian (il primo) ed eseguite il
boot da questo disco.  Al prompt del boot, assumendo che la partizione di root del
vostro Linux è su <file><var>/dev/hda12</var></file> e che volete il runlevel 3, digitate:
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
A questo punto siete entrati in un sistema pressochè funzionante in toto, 
basato sul kernel del dischetto. (Potrete avere piccole
noie, dovute alla mancanza di alcuni moduli). 
<p>
Se volete crearvi un vostro boot floppy, leggete il <prgn>readme.txt</prgn> sul rescue disk.
</sect1>

<sect1 id="no-x-start">"Voglio disabilitare X al boot!"
<p>
Avere <tt>unstable/sid</tt> è divertente, ma <prgn>xdm</prgn>, 
<prgn>gdm</prgn>, <prgn>kdm</prgn>, e <prgn>wdm</prgn> difettosi 
lanciati durante il boot possono fare molto male.
<p>
Primo, guadagnate la shell di root digitando quanto segue al prompt del boot:
<example>
boot: <var>Linux</var> vga=normal s
</example>
Dove <var>Linux</var> è l'etichetta per la kernel image che andate a lanciare,
"vga=normal" vi assicura che lilo si esegue in uno schermo normale VGA ed
"s" (o "S") è il parametro dato ad <prgn>init</prgn> per invocare la modalità
singolo utente.  Al prompt date la password di root.
<p>
Esistono vari modi per disabilitare tutti i demoni che lanciano X:
<list>
<item>eseguite <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6</tt>
<item>inserite "exit 0" all'inizio di tutti i file <file>/etc/init.d/<var>?</var>dm</file>.
<item>rinominate tutti i file <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>rimuovete tutti i file <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>.
<item>eseguite <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Qui <file>rc<var>2</var>.d</file> deve corrispondere al runlevel 
specificato in <file>/etc/inittab</file>.   
<file><var>?</var>dm</file> significa tutti gli <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn>, e <prgn>wdm</prgn>.
<p>
L'unico, vero modo &debian; è il primo della lista.  
L'ultimo è semplice, ma funziona solo sulla &debian; e richiede una nuova impostazione 
in seguito tramite <prgn>dpkg-reconfigure</prgn>.  
Gli altri sono metodi generici per disabilitare i demoni.
<p>
Avete sempre la possibilità di lanciare X con il comando <prgn>startx</prgn> da qualsiasi shell.
</sect1>

<sect1 id="bootprompt">Altri trucchi con il boot prompt
<p>
Potete fare il boot in un particolare runlevel e configurazione
tramite il prompt di <prgn>lilo</prgn>. Dettagli si trovano nel
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Se volete fare il boot nel runlevel 4, date il seguente comando al
prompt di <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Se si vuole il boot in modalità singolo utente, conoscendo la password
di root, potete usare uno dei seguenti esempi al prompt di <prgn>lilo</prgn>.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Se si vuole il boot con meno memoria di quanta il sistema ne abbia
(mettiamo 48M in un sistema con 64M), basta dare il seguente comando
al prompt di <prgn>lilo</prgn>:
<example>
boot: Linux mem=48M
</example>
Evitate di specificare più memoria di quanta ne abbiate, altrimenti il
kernel si pianterà inevitabilmente.  Se si hanno più di 64M, per
esempio 128M, con vecchi kernel o BIOS bisogna specificare il comando
<tt>mem=128M</tt> al prompt, od includere una riga simile in
<file>/etc/lilo.conf</file>, altrimenti non verrà utilizzata memoria sopra i 64MB.
</sect1>

<sect1 id="bootgrub">Come impostare i parametri di boot (GRUB)
<p>
GRUB è un nuovo boot manager proveniente dal progetto Hurd, molto più flessibile di 
Lilo, ma con un modo di maneggiare i parametri di boot lievemente differente.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Dovete conoscere come Hurd nomina i device:
<example>
HURD/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,1)             /dev/hda1           C: (solitamente)
 (hd0,4)             /dev/hda4           F: (solitamente)
 (hd1,4)             /dev/hdb4           ?
</example>
Vedere <file>&f-grub;</file> e <file>&f-grub-doc;</file> per i dettagli.
</sect>

<sect>Registrazione degli eventi

<sect1 id="script">Registrare gli eventi della shell
<p>
L'amministrazione di sistema in ambiente Unix richiede dei compiti molto più
elaborati che in un ambiente di un normale PC.  E' importante conoscere le
modalità di configurazione di base, per poter risolvere i problemi del
sistema. Le interfacce grafiche di configurazione basate su X sono carine e
convenienti, ma comunque limitate, specialmente in casi di emergenza.
<p>
In questo contesto, la registrazione degli eventi della shell è una
buona pratica, specialmente come root.
<p>
Emacs: Usate <tt>M-x shell</tt> per iniziare la registrazione in un buffer e
<tt>C-x C-w</tt> per scrivere il buffer su un file.
<p>
Shell: Usate il comando <prgn>screen</prgn> con "^A H" come decritto in 
<ref id="screen"> od il comando <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 ... fate quello che dovete ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
Si può usare quanto segue invece di <prgn>script</prgn>:
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>Registrare gli eventi di X
<p>
Se dovete registrare l'immagine di una applicazione di X, incluso
x-term, usate <prgn>gimp</prgn> (GUI).  Può catturare ogni singola finestra, oppure lo
schermo intero. Alternative sono <prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>), o <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>


</sect>

<sect id="archiving">Copia ed archiviazione di una intera sottodirectory
<sect1>Comandi base per copiare una intera sottodirectory
<p>
Se avete necessità di riarrangiare la struttura dei file, muovete il
contenuto, compresi i collegamenti con:
<example>
Metodo standard:
# cp -a /partenza/directory /destinazione/directory # richiede GNU cp
# (cd /partenza/directory &amp;&amp; tar cf - . ) | \
        (cd /destinazione/directory &amp;&amp; tar xvfp - )
Se è coinvolto un hardlink, è necessario un metodo più "pedante":
# cd /percorso/alla/vecchia/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/della/nuova/directory
Da remoto:
# (cd /partenza/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /destinazione/directory &amp;&amp; tar xvfp - )
Se non ci sono links:
# scp -pr user1@host1.dom:/partenza/directory \
          user2@host2.dom:/destinazione/directory
</example>
Qui <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> e <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
Le seguenti informazioni comparative su come copiare una intera sottodirectory
sono state presentate da Manoj Srivastava &lt;srivasta@debian.org&gt; nella lista
debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Tradizionalmente, <prgn>cp</prgn> non è mai stato un gran candidato per tali scopi, poichè
non dereferenzia i link simbolici, nè preserva gli hard links. Un'altro
fattore da considerare è lo spezzettamento dei files (files con buchi).
<p>
GNU <prgn>cp</prgn> ha superato questi limiti; comunque su un sistema non GNU,
<prgn>cp</prgn> potrebbe avere ancora problemi. In più, usando <prgn>cp</prgn>
non si possono creare archivi che siano piccoli e facilmente trasportabili.
<example>
&percnt; cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
Tar è andato oltre alcuni dei problemi che aveva <prgn>cp</prgn> con i links
simbolici. Comunque sia, sebbene <prgn>cpio</prgn> sia in grado di trattare
files speciali,il tradizionale <prgn>tar</prgn> no.
<p>								
Il modo in cui <prgn>tar</prgn> tratta hard links multipli ad un file è di porre solo una
copia del link sul nastro, ma il nome collegato a quella copia è il
<em>solo</em> utilizzabile per recuperare il file; <prgn>cpio</prgn> invece,
mette una copia per ciascun link, ma per recuperare il file potete usare uno
qualsiasi dei nomi.
<p>
Nella transizione da Potato a Woody, il comando <prgn>tar</prgn> ha cambiato
l'opzione per i file <file>.bz2</file>, per cui usate <tt>--bzip2</tt> negli
script al posto della forma breve <tt>-I</tt> (Potato) o <tt>-j</tt> (Woody).  
</sect1>

<sect1><prgn>pax</prgn>
<p>
E' l'utilità POSIX Portable Archive
Interchange (IEEE Std 1003.2-1992, pagine 380&ndash;388 (section 4.48) e pagine
936&ndash;940 (sezione E.4.48)), nuova di zecca.  <prgn>pax</prgn> legge,
scrive ed elenca i membri di un file archivio, e ne copia le directory secondo
le gerarchie. Le operazioni di <prgn>pax</prgn> sono indipendenti dal formato
dell'archivio e supportano una grossa varietà di formati diversi.
<p>
Le implementazioni di <prgn>pax</prgn> sono ancora molto nuove (si può dire che puzzano
ancora di latte...).
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 oppure
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
copia i files dentro o fuori un archivio <prgn>cpio</prgn> o <prgn>tar</prgn>.
 L'archivio può essere un'altro file sul disco rigido, un nastro magnetico, oppure una pipe.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> è un metodo migliore per trattare con archivi in formato <prgn>cpio</prgn>.
In genere è più veloce di cpio, ha maggiori opzioni per i nastri e tratta in maniera più
gentile con le corruzioni dei dati in entrata. Supporta gli archivi
multi-volume durante le operazioni in modalità interattiva. <prgn>afio</prgn> può creare
archivi molto più sicuri di quelli compressi con <prgn>tar</prgn> o
<prgn>cpio</prgn>.  <prgn>afio</prgn>
è anche ottimo come 'motore per l'archiviazione' negli script di backup.
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
Tutti i miei backup su nastro usano <prgn>afio</prgn>. 
</sect1>
</sect>

<sect id="diff-backup">Backup differenziali e sincronizzazione dei dati
<p>
I backup differenziali e la sincronizzazione dei dati possono essere implementati 
con vari metodi:
<list>
<item><package>rcs</package>:  backup con storico, solo testo
<item><package>rdiff-backup</package>:  backup con storico. I link simbolici sono OK.
<item><package>rsync</package>:  sincronizzazione ad 1-via
<item><package>unison</package>:  sincronizzazione a 2-vie
<item><package>cvs</package>:  sincronizzazione multivia con server 
 backup e storico, solo testo, maturo. Vedere <ref id="cvs">.
<item><package>arch</package>:  sincronizzazione multivia con server 
 backup e storico, non esiste qualcosa come una "working directory".
<item><package>subversion</package>:  sincronizzazione multivia con server 
 backup e storico, Apache.
</list>
La combinazione di uno dei metodi menzionati con uno dei metodi di archiviazione descritti in 
<ref id="archiving"> associati ad un job automatico regolare descritto
in <ref id="cronjob"> creeranno un ottimo sistema per il backup.
<p>
Mostrerò due utilità facili da usare.

<sect1 id="rdiff-backup">Backup differenziale con rdiff
<p>
<package>Rdiff-backup</package> fornisce dei backup semplici e validi con
lo storico differenziale per file di qualsiasi tipo, compresi i link simbolici. 
Per salvare gran parte di <file>~/</file> su <file>/mnt/backup</file>:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
Per recuperare i dati vecchi tre giorni da questo archivio in <file>~/old</file>:
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
Vedere <manref name="rdiff-backup" section="1">.
</sect1>

<sect1 id="backup">Backup differenziali regolari con RCS
<p>
<package>Changetrack</package> registra regolarmente i cambiamenti ai file di testo
di configurazione negli archivi RCS.  
Vedere <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>Recuperare un sistema bloccato
<sect1>Uccidere un processo
<p>
Lanciate <prgn>top</prgn> per vedere quale processo si comporta in maniera
"sconveniente". Premete "P" per ordinarli per utilizzo di cpu, "M" per consumo
di memoria e "k" per uccidere il processo.In alternativa potete usare i
comandi in stile BSD <tt>ps aux | less</tt> od in stile System V <tt>ps -efH |
less</tt>.  La sintassi del System V mostra l'ID dei processi padri
<tt>PPID</tt> che può essere usato per uccidere i figli zombie (defunti).
<p>
Usate <prgn>kill</prgn> per uccidere (o mandare il segnale a) un processo per ID del processo,
<prgn>killall</prgn> per fare lo stesso con il nome del comando a cui il processo appartiene. 
Segnali più frequentemente usati:
<example>
 1: HUP,  riavvia il demone
15: TERM, uccisione normale
 9: KILL, uccisione "dura"
</example>

</sect1>

<sect1>ALT-SysRq
<p>
L'assicurazione contro i malfunzionamenti di sistema è un'opzione di
compilazione del kernel, denominata "Magic SysRQ key".
Premendo <tt>ALT-SysRq</tt> su un sistema i386, seguito da uno dei tasti <tt>r 0 k
e i s u b</tt>, fa la "magia".
<p>
Un'R'aw riavvia la tastiera quando cose tipo X si bloccano. Cambiare
il loglevel a 0 riduce i messagi di errore. sa'K' (system attention
key) uccide tutti i processi sulla console virtuale attuale.  t'E'rm
uccide tutti i processi su terminale corrente tranne init. k'I'll
uccide tutti i processi, tranne init.
<p>
`S'ync, `'U'mount, e re`b'oot sono utili per uscire da situazioni
veramente spinose.
<p>
I kernel debian standard non sono compilati al momento con questa
opzione attivata. Ricompilate il kernel per farlo. Informazioni
dettagliate le trovate in
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>
o <file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>


<sect>Alcuni piccoli comandi da ricordare

<sect1>Pager
<p>
<prgn>less</prgn> è il pager (browse del contenuto dei file).  Premete `h' per
aiuto. Fa molto di più di <prgn>more</prgn>.  <prgn>less</prgn> 
può essere potenziato mediante l'esecuzione di <tt>eval $(lesspipe)</tt> o 
<tt>eval $(lessfile)</tt> nello script di inizializzazione della shell.  Per ulteriori notizie
guardate in <file>&f-lessopen;</file>. L'opzione <tt>-R</tt> permette l'output di caratteri raw
ed abilita le sequenze ANSI con escape colorate.  Vedere 
<manref name="less" section="1">.
<p>
<prgn>w3m</prgn> può essere un pager alternativo utile per alcuni sistemi di codifica (EUC).

<sect1>Memoria libera
<p>
<prgn>free</prgn> e <prgn>top</prgn> danno buone informazioni sulle risorse di memoria. Non
vi preoccupate sulle dimensioni della memoria "used" nella riga
"Mem:", ma leggete quella sotto.  (38792 nell'esempio qui sotto). 
<example>
$ free -k # per una macchina con 256MB
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
L'esatto ammontare della memoria fisica può essere confermato da <tt>grep '^Memory'
/var/log/dmesg</tt>,
che in questo caso dà "Memory: 256984k/262144k available (1652k kernel
code, 412k reserved, 2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Circa 5MB non sono utilizzabili dal sistema, perchè a disposizione del kernel.
</sect1>

<sect1>Impostare l'ora (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Questo imposterà l'orologio del sistema e dell'hardware a MM/GG hh:mm,
CCYY.  Le ore sono allineate al fuso locale, ma l'orologio
dell'hardware utilizza lo UTC.

<sect1>Impostare l'ora (NTP)
<p>
Riferimento: <url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">.
<p>
<sect2>Impostare l'ora tramite una connessione Internet permanente
<p>
Impostazione automatica dell'ora esatta tramite un server remoto:
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
Se avete una connessione permanente, è bene averlo in <file>/etc/cron.daily</file>.

<sect2>Impostare l'ora tramite una connessione Internet sporadica
<p>
Usate il pacchetto <package>chrony</package>.
</sect1>

<sect1>Come disabilitare lo screensaver
<p>
In console:
<example>
# setterm -powersave off
</example>
<p>
Lanciate la console kon2(kanji)con:
<example>
# kon -SaveTime 0
</example>
<p>
In X:
<example>
# xset s off
 or
# xset -dpms
 or
# xscreensaver-command -prefs
</example>
Leggete le pagine man corrispondenti.
</sect1>

<sect1 id="getent">Ricerca dei database amministrativi
<p>
Glibc offre <manref name="getent" section="1"> per la ricerca di
voci inserite nei database amministrativi, cioè,
passwd, group, hosts, services, protocols, o networks.
<example compact>
getent database [chiave...]
</example>

<sect1>Disabilitare il suono (beep)
<p>
Potete sempre staccare gli altoparlanti del PC... ;-)  Da shell Bash:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Messaggi di errore sulla console
<p>
Per placare i messaggi di errore sullo schermo, il primo posto da vedere è 
<file>/etc/init.d/klogd</file>.  Impostate <tt>KLOGD="-c <var>3</var>"</tt> in questo script ed 
eseguite <tt>/etc/init.d/klogd restart</tt>. metodo alternativo è eseguire 
<tt>dmesg -n<var>3</var></tt>.  
<p>
I livelli di errore significano:
<list compact>
<item>0: KERN_EMERG,   il sistema è inutilizzabile
<item>1: KERN_ALERT,   un'azione va presa immediatamente
<item>2: KERN_CRIT,    condizioni critiche
<item>3: KERN_ERR,     condizioni di errore
<item>4: KERN_WARNING, condizioni di allarme
<item>5: KERN_NOTICE,  condizione normale ma significativa
<item>6: KERN_INFO,    informazioni
<item>7: KERN_DEBUG,   massaggi di debug
</list>
<p>
Se c'è un particolare ed inutile messaggio di errore che vi perseguita, considerate l'ipotesi di 
una banalissima patch per il kernel, tipo <file>shutup-abit-bp6</file> (disponibile presso 
in the <url id="&examples;" name="examples subdirectory">).
<p>
Un altro posto da guardare può essere <file>/etc/syslog.conf</file>; controllate per vedere
se qualche messaggio viene inviato alla console.
</sect1>

<sect1>impostare la console al giusto tipo
<p>
Agli schermi di console nei sistemi simil-Unix si accede generalmente tramite librerie  
(n)curses.  Queste offrono all'utente un metodo indipendente dal terminale di aggiornamento
dei caratteri, con una ottimizzazione ragionevole.
Vedere <manref name="ncurses" section="3X"> e
<manref name="terminfo" section="5">.
<p>
Su un sistema &debian; molte sono le voci predefinite:
<example>
$ toe | less                  # tutte le voci
$ toe /etc/terminfo/ | less   # voci riconfigurabili dall'utente
</example>
Esportate la vostra selezione come variabile d'ambiente <tt>TERM</tt>.
<p>
Se la voce terminfo per xterm non funziona con un xterm non-Debian,
cambiate il tipo di terminale da "xterm" ad una delle versioni con minori opzioni 
tipo "xterm-r6", quando accedete da remoto ad un sistema Debian.  
Vedere <file>&f-libncurse;</file> per ulteriori informazioni.  
"dumb" è il minimo comun denominatore per terminfo.
</sect1>

<sect1>Riportare la console allo stato normale
<p>
Quando lo schermo impazzisce dopo <tt>$ cat <var>qualsiasi-file-binario</var></tt> 
(potreste non essere in grado di vedere il comando dato mentre lo state digitando):
<example>
$ reset
</example>
</sect1>

<sect1>Convertire file di testo da DOS a Unix
<p>
Converte file un di testo DOS (end-of-line = <tt>^M^J</tt>) in un file Unix di testo 
(end-of-line = <tt>^J</tt>).
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1>Sostituzione delle espressioni regolari
<p>
Sostituisce tutte le istanze <var>FROM_REGEX</var> con <var>TO_REGEX</var> in tutti
i file <var>FILES</var> ...:
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_REGEX</var>/g;' <var>FILES</var> ...
</example>
<tt>-i</tt> sta per "in-place editing", <tt>-p</tt> è per "implicit loop over
<var>FILES</var> ...".  se la sostituzione è complessa, potete recuperare più facilmente gli
errori usando il parametro <tt>-i.bak</tt> al posto di <tt>-i</tt>; così si mantiene
ogni file originale, aggiungendo <tt>.bak</tt> come estensione.
</sect1>

<sect1>Estrarre le differenze e fondere gli aggiornamenti da un file sorgente
<p>
Seguendo una delle seguenti procedure, estrarrà le differenze dal file sorgente 
creando dei file diff unificati <var>file.patch0</var> o 
<var>file.patch1</var> a seconda della localizzazione del file:
<example>
$ diff -u <var>file.vecchio</var> <var>file.nuovo1</var> &gt; <var>file.patch0</var>
$ diff -u <var>vecchio/file</var> <var>nuovo1/file</var> &gt; <var>file.patch1</var>
</example>
Il file diff (chiamato anche file patch) è usato per inviare gli aggiornamenti di un 
programma.  Chi lo riceve applicherà questo aggiornamento ad un altro <var>file</var>
con:
<example>
$ patch -p0 <var>file</var> &lt; <var>file.patch0</var>
$ patch -p1 <var>file</var> &lt; <var>file.patch1</var>
</example>
Se avete tre versioni dello stesso codice sorgente, potete farle confluire più efficacemente tutte insieme 
usando <prgn>diff3</prgn>:
<example>
$ diff3 -m <var>file.mio</var> <var>file.vecchio</var> <var>file.tuo</var> &gt; <var>file</var>
</example>
</sect1>

<sect1>Convertire grossi files in files più piccoli
<p>
<example>
$ split -b 650m <var>file</var>   # divide il file in pezzetti di 650 MB
$ cat x* ><var>largefile</var>    # riunisce i files in un unico file
</example>
</sect1>

<sect1>Parti di script per il piping
<p>
Gli script seguenti fanno cose utili come parti di una pipe.
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # trova tutti i file /usr escludendone alcuni
xargs -n 1 <var>command</var>   # lancia i comandi per tutti gli oggetti da stdin
xargs -n 1 echo|     # divide oggetti separati da spazi in righe
grep -e <var>pattern</var>|     # estrae le righe contenenti <var>pattern</var>
cut -d: -f3 -|       # estrae il terzo campo separato da :  
                     # (file passwd, ecc.)
col -bx |            # rimuove il backspace ed espande le tabs in spazi
expand -|            # espande le tabs
sort -u|             # trova e rimuove i doppioni
tr '\n' ' '|         # concatena le righe in una riga unica
tr '\r' ''|          # rimuove il CR (carriage return, a capo)
tr 'A-Z' 'a-z'|      # converte il maiuscolo in minuscolo
sed 's/^/# /'|       # commenta ogni riga
sed 's/\<var>.ext</var>//g'|    # rimuove <var>.ext</var>
sed  -n -e 2p|       # stampa la seconda riga 
head -n 2 -|         # stampa le prime due righe
tail -n 2 -|         # stampa le ultime due righe
</example>
</sect1>

<sect1>Catturare il testo od un archivio delle ML da una pagina web
<p>
Il seguente comando legge la pagina web e la copia in un file di
testo. Molto utile quando si copiano delle configurazioni dalla rete.
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>textfile</var>
</example>
Anche <prgn>links</prgn> e <prgn>w3m</prgn> possono essere usati, con piccole differenze nel rendering.
<p>
Se si tratta di un archivio di mailing list, usate <prgn>munpack</prgn> per ottenere i contenuti mime dal testo.
</sect1>

<sect1>Stampare bene una pagina Web
<p>
Quanto segue stampa una pagina Web in un file o stampante PostScript.  
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Vedere <ref id="lprlpd">.  Controllate anche i pacchetti <prgn>a2ps</prgn> e 
<prgn>mpage</prgn> per la creazione di file PostScript.
</sect1>

<sect1>Stampare bene una pagina man
<p>
Quanto segue stampa una pagina man in un file o stampante PostScript.  
<example>
$ man -Tps <var>some-man-page</var> | lpr
$ man -Tps <var>some-man-page</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Unire due file Postscript o PDF
<p>
Si possono unire due file Postscript o PDF.
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>
 
<sect1>Cronometrare un comando
<p>
Mostra il tempo utilizzato da un processo.
<example>
# time <var>qualsiasi-comando</var> &gt;/dev/null
real    0m0.035s       # tempo sull'orologio a muro (tempo realmente passato)
user    0m0.000s       # tempo in modalità utente
sys     0m0.020s       # tempo in modalità kernel
</example>
</sect1>

<sect1>Il comando <prgn>nice</prgn> 
<p>
Usate <prgn>nice</prgn> (dal pacchetto GNU <package>shellutils</package>) per impostare
il valore nice di un comando quando viene lanciato. <prgn>renice</prgn>
(<package>bsdutils</package>) o <prgn>top</prgn> possono dare il renice ad un processo. Un valore di nice
di 19 rappresenta il processo più lento (priorità bassa);  valori negativi
sono "not-nice", con -20 che rappresenta un processo molto veloce (alta priorità). Solo il
superuser può impostare valori di nice negativi.
<example>
# nice  -19 <var>top</var>                                         # molto nice
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # molto veloce
</example>
Talvolta un valore estremo di nice fa più danni che bene al sistema.
Usate questo comando con cautela.
</sect1>

<sect1 id="cronjob">Programmare gli eventi (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Usate <prgn>cron</prgn> e <prgn>at</prgn> per programmare i task in Linux.
Vedere <manref name="at" section="1">, <manref name="crontab" section="5">,
<manref name="crontab" section="8">. 
<p> 
Eseguite il comando <tt>crontab -e</tt> per creare o modificare un file crontab per impostare
degli eventi regolarmente programmati. Ecco un esempio di file crontab:
<example>
# usa /bin/sh per eseguire i comandi, non importa cosa dice /etc/passwd
SHELL=/bin/sh
# invia ogni output a `paul', non importa a chi appartiene crontab
MAILTO=paul
# Min Hour DayOfMonth Month DayOfWeek comando 
# esecuzione alle 00:05, ogni giorno
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# esecuzione alle 14:15 il I giorno del mese -- output inviato a paul
15 14 1  * *   $HOME/bin/monthly
# esecuzione alle 22:00 i giorni feriali (Lun-Ven) (1-5), annoia Joe. &percnt; per una nuova riga, l'ultimo &percnt; per cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Where are your kids?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# esecuzione alle 03:40 il I lunedi di ogni mese
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
Usate il comando <prgn>at</prgn> per programmare gli eventi che accadono una sola
volta:
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Scambio di console con <prgn>screen</prgn>
<p>
Il programma <prgn>screen</prgn> vi permette di far girare terminali
virtuali <strong>multipli</strong> ciascuno con la propria shell interattiva,
su un <strong>singolo</strong> terminale fisico, o su una finestra di
emulazione di terminale. Anche se usate le consoles virtuali di Linux o
finestre xterm multiple, vale comunque la pena di esplorare
<prgn>screen</prgn> per la sua ricchezza di <strong>opzioni</strong>,che includono
<list compact>
<item>storico per lo scrollback, 
<item>copia-incolla
<item>registrazione dell'output, 
<item>digraph entry, e
<item>l'abilità di <strong>staccare</strong> un'intera sessione di
<prgn>screen</prgn> dal vostro terminale e di riattacarla in seguito. 
</list>

<sect2>Scenario: accesso remoto
<p>
Se accedete frequentemente ad una macchina Linux da terminale remoto o tramite un
programma di terminale VT100,, <prgn>screen</prgn> renderà la vostra vita molto
più semplice con la funzione <strong>detach</strong>.
<p>
<enumlist compact>
<item>Supponiamo che
siate connessi mediante una connessione dialup e che state conducendo una
sessione di <prgn>screen</prgn> con editors ed altri
programmi aperti su molte finestre. 
<item> Improvvisamente dovete abbandonare il
terminale, ma non volete perdere tutto il lavoro allo stacco della
connessione. 
<item>Basta digitare <tt>^A d</tt> per <strong>staccare</strong> la sessione, poi
deconnettersi. (Oppure, più veloce ancora, digitate <tt>^A DD</tt> per dire a <prgn>screen</prgn>
di staccare la sessione e deconnettersi da solo.) 
<item>Quando vi riconnettete di nuovo, date il comando 
<tt>screen -r</tt>, e <prgn>screen</prgn> magicamente
<strong>riattaccherà</strong> tutte le finestre che avevate aperto. 
</enumlist>

<sect2>Comandi tipi di <prgn>screen</prgn> 
<p>
Una volta lanciato <prgn>screen</prgn>, tutto l'input della tastiera viene
indirizzato alla finestra corrente, tranne il tasto di comando, di default <tt>^A</tt>. Tutti
i comandi per <prgn>screen</prgn> vengono dati premendo <tt>^A</tt> più un tasto singolo
[più alcuni parametri]. 
Comandi utili:
<example>
^A ?     mostra una schermata di aiuto (mostra i comandi da tastiera)
^A c     crea una nuova finestra e passa ad essa
^A n     va alla finestra successiva
^A p     va alla finestra precedente
^A <var>0</var>     va alla finestra numero <var>0</var>
^A w     mostra una lsta di finestre
^A a     manda un Ctrl-A alla finestra corrente come input da tastiera
^A h     scrive una copia della finestra corrente su file 
^A H     inizia/termina la registrazione della finestra corrente su file
^A ^X    blocca il terminale (protetto da password)
^A d     stacca la sessione dal terminale
^A DD    stacca la sessione ed esce
</example>
Questo è solo un piccolo assaggio dei comandi e caratteristiche di
<prgn>screen</prgn>. Se c'è qualcosa che volete che <prgn>screen</prgn>
faccia, è probabile che lo sappia fare! Vedere <manref name="screen"
section="1"> per i dettagli.

<sect2>Backspace e/o Ctrl-H durante una sessione di <prgn>screen</prgn>
<p>
Se notate che il backspace e/o Ctrl-H non funzionano appropriatamente mentre state facendo girare <prgn>screen</prgn>, aprite <file>/etc/screenrc</file>,
trovate la riga
<example compact>
bindkey -k kb stuff "\177"
</example>
e coomantatela (cioè, aggiungete "#" come primo carattere). 

<sect2>Programma equivalente a <prgn>screen</prgn> per X
<p>
Vedete <prgn>xmove</prgn>.  Vedere <manref name="xmove" section="1">.

</sect1>

<sect1>Testare la rete: le basi
<p>
Installate i pacchetti
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (per Kernel 2.2),
<package>iptables</package> (per Kernel 2.4), e
<package>net-tools</package> e:
<example>
$ ping <var>yahoo.com</var>            # prova la connessione internet
$ traceroute <var>yahoo.com</var>      # traccia i pacchetti IP
$ ifconfig                  # prova la configurazione dell'host
$ route -n                  # prova la configurazione di routing
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # controlla i record DNS di <var>host.dom</var> tramite <var>dns-server.com</var> 
      # per <var>{mx|any}</var> record
$ ipchains  -L -n |less     # controlla il packet filter (kernel 2.2)
$ iptables -L -n |less      # controlla il packet filter (kernel 2.4)
$ netstat -a                # scopre tutte le porte aperte
$ netstat -l --inet         # trova le porte in ascolto
$ netstat -ln --tcp         # trova le porte tcp in ascolto (numerico)
</example>
</sect1>

<sect1>Eliminare la posta dallo spool locale
<p>
Per eliminare la posta:
<example>
# exim -q    # elimina la posta in attesa
# exim -qf   # elimina tutta la posta
# exim -qff  # elimina persino la posta "congelata"
</example>
<tt>-qff</tt> può essere migliore come opzione per lo script
<file>/etc/ppp/ip-up.d/exim</file>.
</sect1>

<sect1>Rimuovere la posta "congelata" (bloccata) dallo spool locale
<p>
Per rimuovere la posta bloccata dallo spool locale assieme al messaggio di
errore nell'invio:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Riinviare il contenuto delle caselle di posta
<p>
Se la vostra directory home è piena e procmail non è riuscito ad inviare la
posta, dovete inviarla a mano alle varie caselle di posta della directory
home, da <file>/var/mail/<var>username</var></file>. Dopo aver fatto spazio
nella vostra directory home, lanciate:
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>username</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>Ripulire il contenuto di un file
<p>
Per ripulire un file dal suo contenuto, come ad esempio un file di log, non
usate <tt>rm</tt> per cancellarlo, e poi crearne un nuovo vuoto, poichè ci
potrebbero essere ancora degli accessi al file nell'intervallo fra i
comandi. Quanto segue è il modo sicure di ripulire un file dal suo contenuto.
<example>
$ :&gt;<var>file-da-essere-ripulito</var>
</example>
</sect1>

<sect1>File fantoccio
<p>
I comandi seguenti creano dei file fantoccio o vuoti:
<example>
$ dd if=/dev/zero of=<var>nomefile</var> bs=1k count=5 # 5KB di zeri $ dd
if=/dev/urandom of=<var>nomefile</var> bs=1m count=7 # 7MB di contenuto
casuale $ touch <var>nomefile</var> # crea un file di 0B (se il file esiste,
aggiorna mtime)
</example>
</sect1>

<sect1><prgn>chroot</prgn>
<p>
Supponiamo che abbiate installata un'intera distribuzione Linux (può essere
un'altra versione di &debian; o persino una Red Hat) su
<file><var>/dev/hda1</var></file> e ne sta girando un'altra, installata su
<file><var>/dev/hda2</var></file>. Potete lanciare il sistema su
<file><var>/dev/hda1</var></file> senza fare il reboot del sistema attualmente
attivo su <file><var>/dev/hda2</var></file> condividendo lo stesso kernel.
<example>
# mount <var>/dev/hda1 /mnt/target</var>
 ... supponiamo che <var>/dev/hda1</var> contenga un sistema completo
# chroot /mnt/target
 ... Ora il contenuto di <var>/dev/hda1</var> è visto come root directory.
# mount proc /proc              # just in case
 ... eseguite i comandi dall'interno di <var>/dev/hda1</var>
</example>
Ciò permette di caricare stable/testing/unstable su una sola macchina. In più,
si può far girare un programma che utilizza molta memoria come
<prgn>dselect</prgn> su una macchina host mentre si monta via NFS una macchina
satellite aull'host in lettura/scrittura e puntando <prgn>chroot</prgn> sulla
macchina satellite.
<p>
Un sistema <prgn>chroot</prgn> può essere facilmente creato tramite il comando
<prgn>debootstrap</prgn> command in Woody.
<example>
# mkdir <var>potatochroot</var> debootstrap potato <var>potatochroot</var>
# chroot <var>potatochroot</var> apt-setup # imposta /etc/apt/sources.list
</example>
<p>
Esiste un pacchetto chroot ancora più specializzato,
<package>pbuilder</package>, che costruisce un sistema chroot ed al suo
interno crea un pacchetto.  E' il sistema ideale da usare per controllare che
le dipendenze di un pacchetto siano corrette, e che dipendenze inutili o
sbagliate non siano presenti nel pacchetto risultante.<p> Vedere <url
id="&setup-chroot;">
</sect1>

<sect1>Come controllare gli hard link
<p>
potete controllare se due file sono lo stesso file con due hard links tramite:
<example> $ ls -li <var>file1</var> <var>file2</var>
</example>
 
<sect1><prgn>mount</prgn> il file immagine del disco rigido
<p>
Se <file><var>file.img</var></file> contiene l'immagine del contenuto di un
disco rigido ed il disco originale aveva una configurazione che dà
<var>xxxx</var> = (bytes/settore) * (settori/cilindro), allora quanto segue lo
monterà in <file>/mnt</file>:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
Notate cha molti dischi rigidi hanno 512 bytes/sector.

<sect1>Samba
<p>
Le basi per ottenere un file da Window$:
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # monta il file Windows su Linux
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # elenca le condivisioni su un computer
</example>
<p>
I PC collegati tramite Samba possono essere controllati sotto Linux tramite:
<example>
# smbclient -N -L <var>ip_address_del_vostro_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

</sect>

</chapt>

