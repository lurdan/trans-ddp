<!-- CVS revision of this document "$Revision: 1.11 $"  -->
<!-- CVS revision of original english document "1.22"  -->
<chapt id="tips"> Trucchi per &debian;

<sect>Il sistema di boot
<p>
Leggere <file>/usr/share/doc/HOWTO/en-txt/BootPrompt-HOWTO.txt.gz</file> 
(LDP) per informazioni dettagliate sul prompt del boot.

<sect1 id="crackroot">Ho scordato la password di root (1)
<p>
Il sistema può comunque essere lanciato nell'account di root, anche se
non se ne conosce la password, basta avere accesso alla tastiera. (Ciò
significa che non esistono altre password richieste dal BIOS, o dal
boot-loader (tipo lilo) che possono prevenire l'accesso al sistema).
<p>
Questa procedura non richiede alcun disco di boot, nè cambiamenti al
BIOS. In questo contesto, "Linux" è l'etichetta per lanciare il kernel
in una installazione Debian standard.
<p>
Alla schermata di boot di lilo (in alcuni sistemi si deve premere il
tasto shift), date:
<example>
boot: Linux init=/bin/sh
</example>
Il sistema lancia il kernel ed esegue /bin/sh al posto dello standard
init. A questo punto avete ottenuto i privilegi di root e la shell di
root. Siccome, però, / è montata in sola lettura e molte altre
partizioni non sono state ancora montate, avete bisogno di eseguire i
passi seguenti per avere un sistema ragionevolmente funzionante.
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
Una voce vuota nella seconda colonna di uno di questi files,
disabilita la password. Diversamente da alcuni vecchi Linux, la debian
potato richiede la password solo se si esegue il boot nel runlevel 1.
</sect1>

<sect1>Ho scordato la password di root (2)
<p>
Fate il boot da qualunque set di dischi di emergenza boot/root. Se,
per esempio, /dev/hda3 è la partizione di root originale, i seguenti
comandi permetteranno di aprire il file password facilmente come
sopra.
<example>
# mkdir fixit
# mount /dev/hda3 fixit
# cd fixit/etc
# vi shadow
# vi passwd
</example>
<p>
Il vantaggio di questo approccio rispetto al metodo precedente è che
non richiede la conoscenza della password di lilo. Però, bisogna
essere in grado di settare il boot del sistema da floppy o da CD.
</sect1>

<sect1>Non riesco a fare il boot
<p>
Nessun problema. Nessuno si prende la briga di fare un dischetto di
boot durante l'installazione. Se lilo non funziona, usate come disco
di boot il disco di installazione di Debian (il primo). eseguite il
boot da questo disco. Al prompt, data la partizione di root in
/dev/hda12, e runlevel 3 quello che volete, date:
<example>
boot: rescue root=/dev/hda12 3
</example>
A questo punto siete entrati in un sistema pressochè funzionante in toto, 
basato sul kernel del dischetto. (Potrete avere piccole
noie, dovute alla mancanza di alcuni moduli).
<p>
Se volete crearvi un vostro boot floppy, leggete il readme.txt sul
disco di rescue.
</sect1>

<sect1 id="bootprompt">Altri trucchi per il boot prompt
<p>
Potete fare il boot in un particolare runlevel e configurazione
tramite il prompt di lilo. I dettagli li potete trovare nel
BootPrompt-HOWTO.txt.gz.
<p>
Se volete fare il boot nel runlevel 4, date il seguente comando al
prompt di lilo.
<example>
boot: Linux 4
</example>
<p>
Se si vuole il boot in modalità singolo utente, conoscendo la password
di root, potete usare uno dei seguenti esempi.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Se si vuole il boot con meno memoria di quanta il sistema ne abbia
(mettiamo 48M in un sistema con 64M), basta dare il seguente comando
al prompt.
<example>
boot: Linux mem=48M
</example>
Evitate di specificare più memoria di quanta ne abbiate, altrimenti il
kernel si pianterà inevitabilmente. Se si hanno più di 64M, per
esempio 128M, con vecchi kernel o BIOS bisogna specificare il comando
mem=128M al prompt, altrimenti non verranno usati più di 64M.
</sect1>
</sect>

<sect>Registrazione degli eventi
<sect1 id="script">Registrare gli eventi della shell
<p>
L'amministrazione di sistema in ambiente Unix è rappresentata da una
serie di compiti molto più elaborati che in un ambiente di un normale
PC.  E' importante conoscere i modi di configurazione basilari, in
caso di soluzione dei problemi del sistema. Le interfacce grafiche di
configurazione basate su X sono carine e convenienti, ma comunque
limitate, specialmente in queste occasioni.
<p>
In questo contesto, la registrazione degli eventi della shell è una
buona pratica, specialmente come root.
<p>
Emacs: Usate "M-x shell" per iniziare la registrazione in un buffer e
"C-x C-w" per scrivere il buffer su un file.
<p>
Shell: Usate il comando script.
<example>
$ script
Script started, file is typescript
 .... fate quello che dovete ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
Si può usare il seguente invece di script.
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>
<sect1>Registrare gli eventi di X
<p>
Se dovete registrare l'immagine di una applicazione di X, incluso
x-term, usate gimp. Può catturare ogni singola finestra, oppure lo
schermo intero. Un'alternativa è xwd (da console).
</sect1>
</sect>

<sect>Copia ed archiviazione di una intera subdirectory
<sect1>Comandi base per copiare una intera subdirectory
<p>
Se dovete riarrangiare l'organizzazione delle directory, muovete il
contenuto, links compresi con:
<example>
Metodo standard:
# cp -a /partenza/directory /destinazione/directory # deve essere GNU
# (cd /partenza/directory &amp;&amp; tar cf - . ) | \
        (cd /destinazione/directory &amp;&amp; tar xvfp - )
Se sono presenti delle hardlinks, è necessario un metodo più "pedante":
# cd /percorso/alla/vecchia/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/della/nuova/directory
Da remoto:
# (cd /partenza/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /destinazione/directory &amp;&amp; tar xvfp - )
Se non ci sono links:
# scp -pr user1@host1.dom:/partenza/directory \
          user2@host2.dom:/destinazione/directory
</example>
Qui, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> e <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
Il metodo per copiare una intera subdirectory è basato sulle informazioni
fornite da Manoj Srivastava &lt;srivasta@debian.org&gt; sulla lista
debian-user@lists.debian.org.
</sect1>

<sect1>cp
<p>
Tradizionalmente, cp non è mai stato un gran candidato per tali scopi, poichè
non dereferenzia i link simbolici, nè preserva gli hard links. Un'altro
fattore da considerare è lo spezzettamento dei files.
<p>
GNU cp ha superato questi limiti; comunque su un sistema non GNU, cp potrebbe
avere ancora problemi. In più, usando cp non si possono creare archivi che
siano piccoli e facilmente trasportabili..
<example>
&percnt; cp -a . newdir
</example>
<sect1>tar
<p>
Tar è andato oltre alcuni dei problemi che aveva cp con i links
simbolici. Comunque sia, 'cpio' è in grado di trattare files speciali, mentre
il tradizionale 'tar' no.
<p>								
Il modo in cui `tar' tratta hard links multi ad un file è di porre solo una
copia del link sul nastro, ma il nome colegato a quella copia è il
<em>solo</em> utilizzabile per recuperare il file; 'cpio' invece, mette una
copia per ciascun link, ma per recuperare il file potete usare uno qualsiasi
dei nomi.
</sect1>

<sect1>pax
<p>
E' la nuova utilità POSIX (IEEE Std 1003.2-1992, pagine 380-388 (sezione
4.48) e pagine 936-940 (sezione E.4.48)), per lo scambio di archivi portabili,
nuova di zecca. Pax legge, scrive ed elenca i membri di un file
archivio, e ne copia le directories secondo le gerarchie. Le operazioni
di pax sono indipendenti dal formato dell'archivio e supportano una
grossa varietà di formati diversi.
<p>
le implementazioni di pax sono ancora molto nuove (si può dire che puzzano
ancora di latte...).
<example>
$ pax -rw -p e . newdir oppure $ find . -depth | pax -rw -p e newdir
</example>
</sect1>

<sect1>cpio
<p>
copia i files in un archivio cpio o tar. L'archivio può essere un'altro file
sul disco rigido, un nastro magnetico, oppure una pipe.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1>afio
<p>
Afio è un metodo migliore per trattare con archivi in formato cpio. In gener è
più veloce di cpio, ha maggiori opzioni per i nastri e tratta in maniera più
gentile con le corruzioni dei dati in entrata. Supporta gli archivi
multi-volume durante le operazioni in modalità interattiva. Afio può creare
archivi molto più sicuri di quelli compressi con tar o cpio. Afio è anche
ottimo come 'motore per l'archiviazione' negli script di backup.
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
Tutti i miei backup su nastro usano afio. 
</sect1>

</sect>

<sect>Modificare i files con le espressioni regolari
<p>
Sostitusce tutte le istanze di FROM_REGEX con TO_REGEX 
in tutti i files FILES ...:
<example>
# perl -i -p -e 's/FROM_REGEX/TO_REGEX/g;' FILES ...
</example>
"-i" sta per "editing sul-posto", "-p" sta per "loop implicito tra i FILES ...".
</sect>


<sect>Recuperare un sistema bloccato
<sect1>Uccidere un processo
<p>
Lanciate "top" per vedere quale processo si comporta in maniera
"sconveniente". Premete "P" per ordinarli per tempo di cpu, "M" per
consumo di memoria e "k" per uccidere il processo.
<p>
Usate "kill" e "killall" per uccidere (o mandare il segnale) al
processo, per nome.
<example>
 1: HUP,  riavvia il demone
15: TERM, uccisione normale
 9: KILL, uccisione "dura".
</example>

</sect1>

<sect1>ALT-SysRQ
<p>
L'assicurazione contro i malfunzionamenti di sistema è un'opzione di
compilazione del kernel, denominata "Magic SysRQ key". Premendo
ALT-SysRQ su un sistema i386, mediante una sola chiave 'r0keisub', si
ottiene la "magia".
<p>
un'R'aw riavvia la tastiera quando cose tipo X si bloccano. Cambiare
il loglevel a 0 riduce i messagi di errore. sa'K' (system attention
key) uccide tutti i processi sulla console virtuale attuale.  t'E'rm
uccide tutti i processi su terminale corrente tranne init. k'I'll
uccide tutti i processi, tranne init.
<p>
'S'ync, 'U'mount, e re'B'oot sono utili per uscire da situazioni
veramente spinose.
<p>
I kernel debian standard non sono compilati al momento con questa
opzione attivata. Ricompilate il kernel per farlo. Informazioni
dettagliate le trovate in
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>

<sect>Files di configurazione

<sect1 id="loginctrl">Controllo del login
<p>
<![%FIXME;[<p>=== Expansion needed here ===]]>
<example>
/etc/securetty           # controlla il root login da console
/etc/hosts.{allow|deny}  # controlla il login dall'host
/etc/pam.d/login         # controlla il login
</example>
<p>
Decommentate "ALL: PARANOID" in /etc/hosts.deny.
<p>
Cambiate il contenuto di /etc/pam.d/login come segue, se desiderate
dei terminal senza password, ma assolutamente insicuri. A vostro
rischio e pericolo.
<example>
#auth       required   pam_unix.so nullok
auth       required   pam_permit.so
</example>
nfs ecc. richiede il login per sunrpc.  "man 8 portmap".
</sect1>

<sect1>Defaults
<p>
<example>
/etc/defaults/rcS        # defaults di boot (motd, sulogin,...)
/etc/syslog.conf         # modalità di log del sistema 
                           (verificate il pacchetto "colorize")
</example>
</sect1>
</sect>

<sect>Alcuni piccoli comandi da ricordare
<sect1>Memoria libera
<p>
"free" e "top" danno buone informazioni sulle risorse di memoria. Non
vi preoccupate sulle dimensioni della memoria "used" nella riga
"Mem:", ma leggete quella sotto.  (38792 nell'esempio qui sotto).
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
La memoria fisica esatta può essere confermata da "grep '^Memory' /var/log/dmesg" 
che è "Memory: 256984k/262144k available (1652k kernel code, 412k 
reserved, 2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free at dmesg = 256984k = Total - kernel - reserved - data - init
Free at shell = 257136k = Total - kernel - reserved - data
</example>
Circa 5MB non sono utilizzabili dal sistema, perchè a disposizione del kernel.
</sect1>

<sect1>Impostare l'ora (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Questo imposterà l'orologio del sistema e dell'hardware a MM/DD hh:mm,
CCYY.  Le ore sono allineate al fuso locale, ma l'orologio
dell'hardware utilizza lo "Universal Time" (UT).
<p>
Coorezione automatica dell'ora di sistema da un server remoto:
<example>
# ntpdate &lt;server&gt;
</example>
Se avete una connessione permanente, è bene averlo in <file>/etc/cron.daily</file>. 
</sect1>

<sect1>Come disabilitare lo screensaver
<p>
In console:
<example>
# setterm -powersave off
</example>
<p>
Lanciate kon2(kanji)con:
<example>
# kon -SaveTime 0
</example>
<p>
In X:
<example>
# xset s off
 o
# xset -dpms
 o
# xscreensaver-command -prefs
</example>
Leggete le pagine man corrispondenti.
</sect1>

<sect1>Disabilitare il suono (beep)
<p>
Potete sempre staccare gli altoparlanti del PC... ;-)  Da shell:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc:
</example>
</sect1>

<sect1>Messaggi di errore sulla console
<p>
L'impostazione di default da <file>/etc/syslog.conf</file> in Debian è
per sovrascrivere lo schermo in console. Cambiate l'ultima parte di
questo file.
<p>
Eseguite anche "dmesg -n1" per togliere i messaggi di errore su schermo.
<p>
Another place to look may be <file>/etc/syslog.conf</file>; check to see
whether any messages are logged to a console device.
</sect1>

<sect1>Riportare la console allo stato normale
<p>
Quando lo schermo impazzisce dopo "$ cat filebinario", (si raccomanda
di digitare alla cieca):
<example>
$ reset
</example>
</sect1>

<sect1>Convertire file di testo da DOS a Unix
<p>
Converte file di testo DOS (^M^J) in file Unix (^J).
<example>
# apt-get install sysutils
$ dos2unix dosfile
</example>
</sect1>

<sect1>Convertire grossi files in files più piccoli
<p>
<example>
$ split -b 650m file   # divide il file in pezzetti di 650 MB
$ cat x* >largefile    # riunisce i files in un unico file
</example>

<sect1>Parti di script per il piping
<p>
Gli script seguenti fanno cose utili come parti di una pipe.
<example>
xargs -n 1 command   # lancia i comandi per tutti gli oggetti da stdin
xargs -n 1 echo|     # divide lo spazio fra gli oggetti in righe
grep -e pattern|     # estrae le righe contenenti i modelli
cut -d: -f3 -|       # estrae il terzo campo separato da :  
                     # (file passwd, ecc.)
col -bx |            # rimuove il backspace ed espande le tabs in spazi
expand -|            # espande le tabs
sort -u|             # trova e rimuove i doppioni
tr '\n' ' '|         # concatena le righe in una riga unica
tr '\r' ''|          # rimuove il CR (carriage return, a capo)
tr 'A-Z' 'a-z'|      # converte il maiuscolo in minuscolo
sed 's/^/# /'|       # commenta ogni riga
sed 's/\.ext//g'|    # rimuove .ext
sed  -n -e 2p|       # stampa una seconda riga
head -n 2 -|         # stampa le prime due righe
tail -n 2 -|         # stampa le ultime due righe
</example>
</sect1>

<sect1>Cattura il testo / archivio delle ML da una pagina web.
<p>
Il seguente comando legge la pagina web e la copia in un file di
testo. Molto utile quando si copiano delle configurazioni dalla rete.
<example>
$ lynx -dump http://www.remote-site.com/help-info.html &gt;textfile
</example>
<p>
Se si tratta di un archivio di mailing list, usate "munpack" per ottenere i contenuti mime dal testo.
</sect1>

<sect1>Il comando time
<p>
Mostra il tempo utilizzato dal processo.
<example>
# time df >/dev/null
real    0m0.035s       # tempo sull'orologio a muro (tempo realmente passato)
user    0m0.000s       # tempo in modalità utente
sys     0m0.020s       # tempo in modalità kernel
</example>
</sect1>

<sect1>Il comando nice
<p>
nice (da GNU-shutils) per impostare il valore di nice al lancio del
programma. renice (bsdutild) o top possono rimpostare nice. nice (20)
significa un processo lentissimo. Not-nice (-20) significa super-user
ed un processo molto veloce.
<example>
# nice --19 top                                         # molto nice
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img # molto veloce
</example>
</sect1>

<sect1>Programmare gli eventi (cron, at)
<p>
Usate "cron" e "at" per programmare i task in Linux. Leggete "man at",
"man 5 crontab" e "man 8 crontab".  <p> Eseguite il comando "crontab"
con il file crontab-file per impostare degli eventi con programmazione
irregolare. Ecco un esempio di crontab-file:
<example>
# usa /bin/sh per eseguire i comandi, non importa cosa dice /etc/passwd
SHELL=/bin/sh
# invia ogni output a `paul', non importa a chi appartiene crontab
MAILTO=paul
# Min Hour DayOfMonth Month DayOfWeek comando 
# esecuzione alle 00:05, ogni giorno
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# esecuzione alle 14:15 il I giorno del mese -- output inviato a paul
15 14 1  * *   $HOME/bin/monthly
# esecuzione alle 22:00 i giorni feriali (Lun-Ven) (1-5), annoia Joe. 
&percnt; per una nuova riga, l'ultimo &percnt; per cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Where are your kids?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# esecuzione alle 03:40 il I lunedi di ogni mese
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
Usate il comando "at" per programmare gli eventi che accadono una sola
volta:
<example>
$ echo 'command -args'| at 3:40 monday
</example>
</sect1>

<sect1>CScambio di console con <prgn>screen</prgn>
<p>
Il programma <prgn>screen</prgn> vi permette di far girare più terminali
virtuali, ciascuno con la propria shell interattiva, su un singolo terminale
fisico, o su una finestra di emulazione di terminale. Anche se usate le
consoles virtuali di Linux o finestre xterm multiple, vale comunque la pena di
esplorare <prgn>screen</prgn> per la sua ricchezza di opzioni, che includono
la memoria per lo scrollback, copia-e-incolla, registrazione dell'output,
digraph entry e l'abilità di staccare una intera sessione di
<prgn>screen</prgn> dal vostro terminale e di riattacarla in seguito. Se
accedete frequentemente ad una macchina Linux da terminale remoto o tramite un
prgramma di terminale VT100, <prgn>screen</prgn> renderà la vostra vita molto
più semplice.
<p>
Una volta lanciato <prgn>screen</prgn>, tutto l'input della tastiera viene
indirizzato alla finestra corrente, tranne che i comandi da tastiera, che di
default è <tt>^A</tt>. Tutti i comandi di<prgn>screen</prgn> vengono dati
digitando <tt>^A</tt> più una sigola lettera [più alcuni parametri]. Comandi
utili:
<example>
^A ?  mostra una schermata di aiuto (mostra i comandi da tastiera) ^A c crea
una nuova finestra e passa ad essa ^A n va alla prossima finestra ^A p va alla
finestra precedente ^A 0 va alla finestra numero 0 ^A w mostra una lsta di
finestre ^A a manda un Ctrl-A alla finestra corrente come input da tastiera ^A
h scrive una copia della finetra corrente su file ^A H inizia/termina la
registrazione della finestra corrente su file ^A ^X blocca il terminale
(protetto da password) ^A d stacca la sessione dal terminale ^A DD stacca la
sessione ed esce
</example>
L'opzione "detach" di <prgn>screen</prgn> è molto potente. Supponiamo che
siate connessi mediante una connessione dialup e che state conducendo una
sessione di <prgn>screen</prgn> molto complessa, con editors ed altri
programmi aperti su molte finestre. Inprovvisamente dovete abbandonare il
terminale, ma non volete perdere tutto il lavoro allo staco della
connessione. Basta digitare <tt>^A d</tt> per staccare la sessione, poi
deconnettersi. (Oppure, più veloce ancora, digitate <tt>^A DD</tt> per dire a
<prgn>screen</prgn> di staccare la sessione e deconnettersi da solo.) Quando
vi riconnettete di nuovo, date il comando <tt>screen -r</tt> e
<prgn>screen</prgn> magicamente riattaccherà tutte le finestre che avevate
aperte.
<p>
Questo è solo un assaggio dei comandi e caratteristiche di
<prgn>screen</prgn>. Se c'è qualcosa che volete che <prgn>screen</prgn>
faccia, è probabile che lo sappia fare! "man screen" per i dettagli.
<p>
<em>Nota:</em> Se mentre state facendo girare <prgn>screen</prgn> notate che
il backspace e/o Ctrl-H non funzionano appropriatamente, aprite
<file>/etc/screenrc</file>,
trovate la linea
<example>
bindkey -k kb stuff "\177"
</example>
e commentatela (cioè, aggiungete "#" come primo carattere). 
<![%FIXME;[<p>=== Aggiungete "xmove" per X se lo desiderate ===]]>
</sect1>

<sect1>Testare la rete: le basi
<p>
Installare i pacchetti
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (per Kernel 2.2),
<package>iptables</package> (per Kernel 2.4) e
<package>net-tools</package> e:
<example>
$ ping yahoo.com            # prova la connessione internet
$ traceroute yahoo.com      # traccia i pacchetti
$ ifconfig                  # prova la configurazione dell'host
$ route -n                  # prova la cofigurazione di routing
$ dig [@dns-server.com] host.dom [{a|mx|any}] |less 
      # controlla i registri DNS di host.dom [@ dns-server.com] 
      # per il record [{a|mx|any}]
$ ichains  -L -n |less      # controlla il packet filter (2.2 kernel)
$ iptables -L -n |less      # controlla il packet filter (2.4 kernel)
$ netstat -a | grep LISTEN  # scopre tutte le porte aperte 
$ netstat -a                # scopre tutte le porte aperte
$ netstat -l --inet         # trova le porte in ascolto
$ netstat -ln --tcp         # trova le porte tcp in ascolto (numerico)
</example>
</sect1>

<sect1>Eliminare la posta dallo spool locale
<p>
Per eliminare la posta:
<example>
# exim -q    # elimina la posta in attesa
# exim -qf   # elimina tutta la posta
# exim -qff  # elimina persino la posta "congelata"
</example>
"-qff" può essere migliore per lo script /etc/ppp/ip-up.d/exim .
</sect1>

<sect1>Rimuovere la posta "congelata" (bloccata) dallo spool locale
<p>
Per rimuovere la posta bloccata dallo spool locale assieme al messaggio di errore nell'invio:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Pulire il contenuto di un file
<p>
Nel caso al file possano accedere altri, non usare "rm".
<example>
$ :>file-da-ripulire
</example>
</sect1>

<sect1>Files fantoccio
<p>
<example>
$ dd if=/dev/zero    of=nomefile bs=1k count=5 # 5KB di zeri
$ dd if=/dev/urandom of=nomefile bs=1m count=7 # 7MB di contenuto casuale
$ touch nomefile #  crea un file di 0B, od aggiorna mtime
</example>
</sect1>

<sect1>chroot
<p>
Potete creare un sistema indipendente condividendo lo stesso kernel.
<example>
# mount /dev/hda1 /mnt/target   
        # supponiamo che /dev/hda1 contenga 1 sistema
# chroot /mnt/target
... A questo punto è come se root fosse il contenuto di /dev/hda1
# mount proc /proc              # nel caso serva
... lanciate i comandi da dentro /dev/hda1
</example>
Ciò permette di caricare stable/testing/unstable su una sola
macchina. In più, si può far girare un programma che utilizza molta
memoria come dselect, su una macchina host, montando tramite NSF una
macchina satellite sull'host ed entrare tramite chroot con permessi di
lettura e scrittura.
<p>
Un sistema chroot può essere facilmente creato, in woody, con il 
comando <prgn>debootstrap</prgn>.
<example>
# mkdir potatochroot
# debootstrap potato potatochroot
# chroot potatochroot
# apt-setup # set-up /etc/apt/sources.list
</example>
</sect1>

<sect1>Samba
<p>
Le basi per ottenere un file da Window$:
<example>
# mount -t smbfs -o username=myname,uid=my_uid,gid=my_gid \
        //server/share /mnt/smb  # monta il file Windows su Linux
# smbmount //server/share /mnt/smb \
        -o "username=myname,uid=my_uid,gid=my_gid"
# smbclient -L 192.168.1.2 # elenca le condivisioni su un computer
</example>
</sect1>

</sect>

</chapt>

