<!-- CVS revision of this document "$Revision: 1.21 $"  -->
<!-- CVS revision of original english document "1.88"  -->

<chapt id="tutorial">Lezioni di &debian;

<p>
<!-- new content -->
Questa sezione fornisce delle coordinate di base per orientarsi nel
mondo &debian, mirate all'utente inesperto. Se è un pò di tempo che
utilizzate un sistema Unix-like, probabilmente saprete già tutto di quello
che verrà spiegato qui. In tal caso, usatela come ripasso.


<sect id="first">Per iniziare
<p>
<!-- new content -->
Dopo aver installato &debian; sul vostro PC, dovete imparare alcune cose per
renderlo utile. Partiamo a tambur battente con le lezioni.


<sect1 id="login-root">Login come root al prompt dei comandi
<p>
<!-- new content -->
Dopo il reboot vi si presenterà o la schermata grafica di accesso al sistema,
oppure quella a carattere, a seconda della vostra selezione iniziale dei
pacchetti. Per semplicità, se avete davanti la schermata grafica, premete
Ctrl-Alt-F1 
<footnote>
I tasti Ctrl-sinistro, Alt-sinistro ed F1 vanno premuti insieme.
</footnote>
per accedere alla schermata di accesso a carattere. 
<p>
Supponiamo che il vostro hostname sia <tt><var>foo</var></tt>, il prompt del
login sarà così:
<example>
<var>foo</var> login:
</example>
Digitate <tt>root</tt> , premete il tasto Enter e digitate la password scelta
durante il processo di installazione. In &debian;,come da tradizione del mondo
Unix, la password è dipendente anche dal maiuscolo/minuscolo. Dopo di ciò, il
sistema parte con il messaggio di benvenuto e vi presenta il prompt dei
comandi di root in attesa di un vostro comando.
<footnote>
Notate che, se avete modificato il messaggio di benvenuto in in <file>/etc/motd</file>,
this will be different.
</footnote>
<example>
<var>foo</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual file in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
A questo punto siete pronti per amministrare il sistema dal prompt dei comandi
di root. L'account root è anche chiamato utente privilegiato o superuser.
Tramite questo account potete fare qualsiasi cosa:
<list compact>
<item>leggere, modificare e rimuovere qualsiasi file del sistema,
indipendentemente dai loro permessi
<item>impostare i permessi ed il proprietario di qualsiasi file del sistema
<item>impostare la password di qualsiasi utente senza privilegi nel sistema
<item>accedere a qualsiasi account senza bisogno di password
</list>
<p>
E' un'idea veramente pessima condividere l'accesso all'account di root
condividendone la password. Il modo giusto di condividere i privilegi
dell'amministratore è mediante l'uso di programmi come <manref name="sudo"
section="8">.
<p>
Notate che è considerata una buona abitudine in ambito Unix accedere prima ad
un account senza privilegi, anche quando si pensa di eseguire delle attività
di amministrazione di sistema. Utilizzate i comandi <tt>sudo</tt>, <tt>super</tt>,
o <tt>su -c</tt> per guadagnare dei privilegi di root limitati quando ne avete
necessità.
Vedere <ref id="sudo">.
<footnote>
Devo ammettere che ho utilizzato l'account di root più spesso di quanto
necessario, solo perchè era più comodo ed io poco scrupoloso.
</footnote>

<sect1 id="newbiefix">Impostare un ambiente minimale per il novizio
<p>
<!-- new content -->
Credo che imparare ad usare un sistema operativo sia come imparare una nuova
lingua. Sebbene le guide siano utili, uno deve fare pratica con strumenti che
lo possano aiutare. In questo contesto, credo sia una buona idea installare
alcuni pacchetti aggiuntivi, tipo  <package>mc</package>,
<package>vim</package>, <package>lynx</package>, 
<package>doc-linux-text</package> e
<package>debian-policy</package>.
<footnote>
Può essere una buona idea installare anche <package>gpm</package>,
<package>emacs21</package> e <package>doc-linux-html</package>.  Vedere
<ref id="gpm"> e <ref id="edit">.
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
</example>
Se avete questi pacchetti già installati, non accadrà nulla.

<sect1 id="newuser">Aggiungere un account utente
<p>
<!-- new content -->
Durante l'installazione avrete creato un account utente senza privilegi, che
utilizzerete per ricevere le mail inviate all'account di root.  
<footnote>
Tendo a chiamare questo account
<tt>admin</tt>, ma potete dargli il nome che preferite. 
</footnote>
Dato che non volete usare questo account speciale per le esercitazioni che
andrete a fare, dovrete creare un nuovo account utente.
<p>
Supponiamo che vogliate come username <tt><var>penguin</var></tt>,
digitate: 
<example>
root@<var>foo</var>:root# adduser <var>penguin</var>
... rispondete a tutte le domande
</example>
eccolo creato.  
<footnote>
Potete aggiungere l'utente <tt><var>penguin</var></tt> al gruppo
<tt>adm</tt> per concedere l'accesso il lettura ai molti file log contenuti in
<file>/var/log/</file>.  Vedere <manref name="passwd" section="5">, <manref
name="group" section="5">, <manref name="shadow" section="5">, <manref
name="group" section="5">, <manref name="vipw" section="8"> e <manref
name="vigr" section="8">.  Per i significati ufficiali di utente e gruppo
leggetevi una versione recente del documento <url id="&f-users-and-groups;"
name="Users and Groups">.
</footnote>
Prima di andare avanti, impariamo alcune cose.

<sect1 id="sw-console">Muoversi tra le console virtuali
<p>
<!-- modified old content -->
In un sistema &debian; standard esistono 6 pseudo-terminali disponibili, cioè
potete usare lo schermo a carattere VGA del PC come 6 terminali VT-100
intercambiabili. Potete passare da uno all'altro premendo simultaneamente
i tasti Alt-sinistro ed uno dei tasti F1&ndash;F6. Ciascun
(pseudo)terminale permette i login indipendenti agli
account. L'ambiente multiutente è una grande ed avvincente
caratteristica di Unix.
<p>
<!-- new content -->
Se premete accidentalmente Alt-F7 su un sistema con X Window System e lo
schermo mostra l'interfaccia grafica di login, potete riguadagnare l'accesso
all'interfaccia a carattere premendo Ctrl-Alt-F1.  Per abituarvi, provate a
muovervi tra le varie console e a tornare indietro su quella di partenza.

<sect1 id="shutdown">Lo spegnimento del PC
<p>
<!-- heavily modified content -->
Come qualsiasi moderno sistema operativo, in cui i file vengono
tenuti in memoria, il sistema &debian; una procedura di arresto
appropriata, prima che l'interruttore possa essere spento con
sicurezza, per mantenere l'integrità dei file. Date il seguente comando dal
prompt di root per spegnere il sistema:
<example>
# shutdown -h now
</example>
Questo è per la normale modalità multiutente. In modalità singolo utente,
sempre da prompt di root, è invece:
<example>
# poweroff -i -f
</example>
In alternativa, potete premere Ctrl-Alt-Delete (o Ctrl-Alt-Canc per la
tastiera italiana) per spegnere.
<footnote>
I tasti Ctrl-sinistro, Alt-sinistro e Delete (o Canc) vanno premuti
comtemporaneamente da console. In un sistema standard, ciò provoca il reboot.
Potete modificare <file>/etc/inittab</file> per avere il comando <prgn>shutdown</prgn>
comando con l'opzione <tt>-h</tt>, come descritto in <ref id="post-inst">.
</footnote>
<p>
Attendete finchè non appare la scritta "System halted", poi spegnete
il computer.  Se le funzioni APM o ACPI sono state attivate dal BIOS e su Linux, il sistema si
spegnerà da solo. Per i dettagli, vedere <ref id="apm">.


<sect1 id="playtime">E' tempo di giocare
<p>
<!-- new content -->
Ora siete pronti per giocare con &debian; senza rischi, finchè utilizzate
l'account utente senza privilegi <tt><var>penguin</var></tt>.
<footnote>
Ciò è possibile perchè il sistema &debian; è, anche dopo l'installazione di
base, già configurato con i giusti permessi dei file, prevenendo
danneggiamenti del sistema da parte di utenti non privilegiati. Ovviamente
potranno sempre esistere delle falle che potranno essere sfruttate, ma coloro
che se ne preoccupano non dovrebbero leggere questa sezione, ma il
<url id="&securing-debian-howto;" name="Securing Debian Manual">.
</footnote>
<p>
Accediamo come <tt><var>penguin</var></tt>.   
Se eravate al prompt di root, premete Ctrl-D 
<footnote>
I tasti Ctrl-sinistro e d vanno premuti insieme.  Non c'è bisogno di premere
il tasto del maiuscolo, anche se questi caratteri di controllo vengono
definiti come "control D" con il maiuscolo.
</footnote>
per chiudere l'attività della shell di root e tornare al prompt del login.
Inserite lo username appena creato <tt><var>penguin</var></tt> e la password
corrispondente.
<footnote>
Se inserite <tt>root</tt> invece di <tt><var>penguin</var></tt> e la password
corrispondente, avrete l'accesso all'account <tt>root</tt> account.  Questa
procedura vi servirà per riguadagnare l'accesso all'account <tt>root</tt>.
</footnote>
Vi si presenterà il seguente prompt dei comandi.
<example>
<var>penguin</var>@<var>foo</var>:<var>penguin</var>$ 
</example>
<p>
Da ora in poi l'esempio utilizzerà dei prompt semplificati per maggiore
chiarezza. Userò:
<list compact>
<item><tt>#</tt> : prompt della shell di root
<item><tt>$</tt> : prompt della shell di un utente senza privilegi
</list>
<p>
Cominceremo ad imparare il sistema &debian; nel modo più facile <ref
id="mc"> e poi in quello più giusto <ref id="unixlike">.

<sect id="mc">Midnight commander (MC)
<p>
<!-- old content -->
Midnight commander (MC) può essere considerato come uno di quei
coltellini svizzeri multiuso, per la console Linux ed altri
terminali. Ciò offre al novizio un'esperienza con una console con menu, molto
più semplice per imparare i comandi Unix standard. 
<!-- New content -->
<p>
Usate questo comando per esplorare il sistema &debian;.  E' il modo migliore
per imparare. Esplorate alcune locazioni chiave usando solo i tasti cursore ed
il tasto Enter:
<list compact>
<item><file>/etc</file> e le sue sottodirectory.
<item><file>/var/log</file> e le sue sottodirectory.
<item><file>/usr/share/doc</file> e le sue sottodirectory.
<item><file>/sbin</file> e <file>/bin</file>
</list>

<sect1 id="mc-enhance">Migliorare MC
<p>
<!-- modified old content -->
Per far cambiare ad MC la directory di lavoro in uscita, dovete modificare
<file>~/.bashrc</file> (o <file>/etc/bash.bashrc</file>, 
chiamato da <file>.bashrc</file>), come spiegato nella sua pagina di manuale,
<manref name="mc" section="1">, sotto l'opzione <tt>-P</tt>.
<footnote>
Se non capite esattamente di cosa sto parlando, potete farlo in seguito.
</footnote>

<sect1 id="mc-start">Lanciare MC
<p>
<!-- modified old content -->
<example>
$ mc
</example>
MC si prende cura di tutte le operazioni sui file tramite il proprio
menu, richiedendo il minimo sforzo da parte dell'utente. 
Basta premere F1 per accedere alla schermata di aiuto.  Potete giocare con MC
premendo i tasti cursore ed i tasti funzione.
<footnote>
Se siete in un terminale, tipo <prgn>kon</prgn> e <prgn>Kterm</prgn> per il giapponese, che
utilizza dei caratteri grafici speciali, aggiungendo <tt>-a</tt> alla riga di comando di
MC può aiutare a prevenire dei problemi.
</footnote>

<sect1 id="mc-fm">Il file manager in MC
<p>
<!-- old content -->
Come default vengono presentate due finestre affiancate che mostrano 
la lista di file contenuti nelle directory correnti. Un'altra modalità utile è
impostare la finestra di destra ad "informazioni", per avere tute le
informazioni su file, tipo privilegi di accesso, ecc. A seguire si
riportano i tasti fondamentali. Se il demone <prgn>gpm</prgn> sta girando, potete usare anche
il mouse. (Ricordatevi di premere il tasto maiscolo per avere il normale
comportamento sotto MC per taglia ed incolla).
<list compact>
<item>F1: Menu aiuto
<item>F3: File viewer interno
<item>F4: Editor interno
<item>F9:  Attiva il menu a cascata
<item>F10: Esce da Midnight commander
<item>Tab: Muove tra le due finestre
<item>Insert: Marca il file per operazioni con più file, tipo copia
<item>Del: Cancella il file (Fate attenzione&mdash;impostate MC in modalità cancellazione sicura)
<item>Tasti cursore: Si spiegano da sè
</list>

<sect1>Trucchi per la riga di comando in MC
<p>
<!-- old content -->
<list compact>
<item>Qualsiasi comando <prgn>cd</prgn> cambierà la directory mostrata sullo 
schermo selezionato.
<item>Control-Invio o Alt-Invio copiano il nome del file sulla riga di comando. 
Usatelo insieme ai comandi <prgn>cp</prgn> o <prgn>mv</prgn> durante l'editing da riga di comando.
<item>Alt-Tab mostra le scelte per i suffissi di file.
<item>Si possono stabilire le directory di partenza per ciascuna finestra, 
come argomenti per MC; per esempio, <tt>mc /etc /root</tt>.
<item>Esc + <var>tastonumero</var> == F<var>n</var> (cioè,
      Esc + `1' = F1, ecc.; 
      Esc + `0' = F10)
<item>Tasto Esc     == tasto Alt (= Meta,
      M-); cioè, premete Esc + `c' per Alt-C.
<!-- control caratteres are referred with the upper case. -->
</list>

<sect1 id="mcedit">L'editor in MC
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
L'editor interno ha un sistema di taglia ed incolla
interessante. Premendo F3 si marca l'inizio della selezione, un
secondo F3 ne segna la fine e la evidenzia. Muovete ora il
cursore. Premendo F6 l'area selezionata viene mossa dove è il
cursore. Con F5 l'area verrà copiata dove è il cursore. F2 salva il
file, F10 esce. Gran parte dei tasti cursori ha un 
funzionamento intuitivo.

<p>
Questo editor può essere lanciato direttamente per un determinato file:
<example>
$ mc -e file_da_modificare
$ mcedit file_da_modificare
</example>
<p>
Non è un editor multifinestra, si può ottenere lo stesso effetto
utilizzando più console. Per copiare da una finestra all'altra, usate
la combinazione Alt-F<var>n</var> per passare da una console ad un'altra
e"File-&gt;Insert file" o "File-&gt;Copy to file" per muovere parti di
un file in un altro.
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 


Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I see .. but for now I do this not to hack LaTeX
-->
<p>
L'editor interno può essere sostituito da qualsiasi editor esterno preferiate.
<p>
Molti programmi usano variabili d'ambiente tipo <tt>EDITOR</tt> o 
<tt>VISUAL</tt> per decidere quale editor usare. Se vi trovate male con
<prgn>vim</prgn>, impostatele a <tt>mcedit</tt> aggiungendo queste righe a 
<file>~/.bashrc</file>:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
Raccomando comunque di impostarle a <tt>vim</tt>, se possibile. Abituarsi ai
comandi di <prgn>vim</prgn> sarebbe la cosa giusta da fare, dato che gli
editor-Vi sono una costante nel mondo Linux/Unix.
<footnote>
In effetti, <prgn>vi</prgn> o <prgn>nvi</prgn> sono programmi che trovate
ovunque. Ho scelto <prgn>vim</prgn>, invece, per il novizio, poichè offre un
aiuto in linea attraverso il tasto F1, pur essendo simile è più potente dei
programmi sopracitati.
</footnote>
<sect1 id="mc-view">Il visualizzatore in MC
<p>
<!-- almost old content -->
Molto valido. E' uno strumento notevole per la ricerca di parole nei documenti. 
Lo uso sempre per i file nella directory <file>/usr/share/doc</file>. Rappresenta 
uno dei modi più rapidi di girare tra la massa di informazioni su Linux. Può essere lanciato
direttamente con:
<example>
$ mc -v file_da_vedere
</example>

<sect1 id="ma-auto">Le caratteristiche di lancio automatico di MC
<p>
<!-- almost old content, tar.gz and deb are new -->
Premete Invio su un file, ed il programma appropriato si prenderà
cura del suo contenuto. E' una caratteristica di MC molto utile.
<example>
eseguibile:        Esegue il comando
file man, html:    Dirotta il contenuto al viewer corrispondente
file tar.gz, deb:  Sfoglia il contenuto come fosse una sottodirectory
</example>
Per permettere a queste utilità di svolgere il loro compito, i file da
leggere non devono essere segnati come eseguibili. Cambiatene lo stato
tramite il comando <prgn>chmod</prgn>, oppure attraverso il menu file di MC.

<sect1 id="mc-ftp">Il fileystem FTP virtuale di MC
<p>
<!-- old content -->
MC può essere utilizzato per accedere a file tramite Internet, usando FTP. 
Attivate il menu premendo F9, poi attivate il file system virtuale FTP
premendo `p'. Inserite una URL sotto forma di
<tt>username:passwd@nomehost.nomedomain</tt>, 
che raggiungerà una directory remota che apparirà come una locale.
<p>
<!-- new content -->
Provate <tt>&ftp-debian;</tt> come URL e scorrete l'archivio dei file
&debian;. Vedere <ref id="ftparchives"> per come sono organizzati.

<sect id="unixlike">Ambiente di lavoro Unix-like
<p>
<!-- new content -->
Nonostante MC vi permetta di fare qualsiasi cosa, è bene che impariate come
usare gli strumenti da riga di comando invocati dal prompt della shell e che
familiarizziate con l'ambiente di lavoro Unix-like.
<footnote>
In questa lezione, il termine shell significa <prgn>bash</prgn>.  Per
approfondire il significato delle varie shell, vedere <ref id="shell">.
</footnote>

<sect1 id="sp-keys">Combinazioni speciali di tasti
<p>
<!-- practically new content -->
Nell'ambiente Unix-like, esistono alcune combinazioni di tasti che hanno un
significato particolare.
<footnote>
Su una normale console a caratteri Linux solo il Ctrl sinistro ed il tasto
Alt, funzionano come ci si aspetta.
</footnote>
<list compact>
<item>Ctrl-U: Cancella la riga prima del cursore.
<item>Ctrl-H: Cancella il carattere prima del cursore.
<item>Ctrl-D: Termina l'input. (eshe dalla shell se la state usando)
<item>Ctrl-C: Termina l'esecuzione di un programma.
<item>Ctrl-Z: Ferma temporaneamente un programma. (mette il job in background
vedere <ref id="cmd-back">)
<item>Ctrl-S: Interrompe l'output a schermo.
<footnote>
Potete disabilitare questa caratteristica del terminale tramite 
<manref name="stty" section="1">.
</footnote>
<item>Ctrl-Q: Riattiva l'output a schermo.
</list>
<p>
la shell di default, <prgn>bash</prgn>, 
prevede l'editing della cronologia ed il completamento mediante il tasto tab per
facilitarne l'uso interattivo.
<list compact>
<item>freccia su:  Lancia la ricerca della cronologia dei comandi.
<item>Ctrl-R:  Lancia la ricerca incrementale della cronologia dei comandi.
<item>TAB: Completa l'input del nome del file sulla riga di comando.
<item>Ctrl-V TAB: Inserisce TAB senza espandere la riga di comando.
</list>
<p>
Altre combinazioni importanti da ricordare:
<list compact>
<item>Ctrl-Alt-Del:  Reboot/arresta il sistema, vedere <ref id="post-inst">.
<item>Tasto-sinistro-e-sposta il mouse: Seleziona e copia negli appunti.
<item>Tasto centrale del: Incolla il contenuto degli appunti dove è il cursore.
<item>Tasto Meta (terminologia Emacs) viene tradizionalmente assegnato al
tasto Alt sinsitro. Alcuni sistemi possono essere configurati per utilizzare
come tasto Meta il tasto Windows.
</list>
Per usare il mouse sotto la console a caretteri Linux, dovete avere
<prgn>gpm</prgn> lanciato come demone.
<footnote>
Nell'ambiente grafico X le funzioni del mouse sono identiche quando usate il
programma Xterm.
</footnote>
Vedere <ref id="gpm">.

<sect1 id="unixcmds">Comandi base Unix
<p>
<!-- new content -->
Impariamo i comandi base Unix.  
<footnote>
Qui uso "Unix" nel suo significato generico.  Qualsiasi clone di Unix in
genere offre comandi equivalenti. il sistema &debian; non fa eccezione.  
Non preoccupatevi 
se alcuni comandi non funzionano come desiderate. Questi
esempi non sono stati pensati per essere eseguiti in questo ordine.
</footnote>
Provate tutti i comandi dall'account utente senza privilegi
<tt><var>penguin</var></tt> :
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>Mostra il nome della directory attuale/di lavoro.
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>Mostra il nome utente attuale.
 </list>
<item><tt>file <var>foo</var></tt>
 <list compact>
 <item>Mostra il tipo per il dato file <var>foo</var>.
 </list>
<item><tt>type -p <var>nomecomando</var></tt>
 <list compact>
 <item>Mostra la localizzazione del comando <tt><var>nomecomando</var></tt>.
 <item><tt>which <var>nomecomando</var></tt> fa la stessa cosa.
 <footnote>
 Se si usa <tt>alias</tt> nella shell, il loro output sarà differente.
 </footnote>
 </list>
<item><tt>type <var>nomecomando</var></tt>
 <list compact>
 <item>Mostra le informazioni sul comando <tt><var>nomecomando</var></tt>.
 </list>
<item><tt>apropos <var>parola-chiave</var></tt>
 <list compact>
 <item>Trova i comandi correlati a <tt><var>parola-chiave</var></tt>.
 <item><tt>man -k <var>parola-chiave</var></tt> fa la stessa cosa.
 </list>
<item><tt>whatis <var>nomecomando</var></tt>
 <list compact>
 <item>Mostra una linea di spegazione sul comando
  <tt><var>nomecomando</var></tt>.
 </list>
<item><tt>man -a <var>nomecomando</var></tt>
 <list compact>
 <item>Mostra la spiegazione sul comando
  <tt><var>nomecomando</var></tt>. (Unix style)
 </list>
<item><tt>info <var>nomecomando</var></tt>
 <list compact>
 <item>Mostra una spiegazione più lunga sul comando
  <tt><var>nomecomando</var></tt>.  (stile GNU)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>Elenca il contenuto della directory. (file non puntati e directory)
  <footnote>
Unix ha la tradizione di nascondere il file il cui nome comincia con "<tt>.</tt>".
Sono generalmente file che contengono informazioni di configurazione e
preferenze dell'utente.
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>Elenca il contenuto della directory. (tutti i file e directory)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>Elenca il contenuto della directory. (quasi tutti i file e directory,
 ovvero salta "<file>..</file>" e "<file>.</file>")
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>Elenca tutto il contenuto della directory con informazioni dettagliate.
 Vedere <ref id="file-system">.
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>Elenca tutte le directory sotto la directory corrente.
 </list>
<item><tt>lsof <var>foo</var></tt>
 <list compact>
 <item>Mostra lo stato del file <tt><var>foo</var></tt>.
 </list>
<item><tt>mkdir <var>foo</var></tt>
 <list compact>
 <item>Crea una nuova directory <tt><var>foo</var></tt> sotto la directory
 corrente.
 </list>
<item><tt>rmdir <var>foo</var></tt>
 <list compact>
 <item>Rimuove la directory <tt><var>foo</var></tt> nella directory corrente.
 </list>
<item><tt>cd <var>foo</var></tt>
 <list compact>
 <item>Cambia directory nella directory <file><var>foo</var></file> 
  nella directory corrente o in quella elencata nella variabile
  <tt>CDPATH</tt>. Vedere il comando <prgn>cd</prgn> in 
  <manref name="builtins" section="7">.
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>Cambia directory in quella di root.
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>Cambia directory nella home dell'utente attuale.
 </list>
<item><tt>cd /<var>foo</var></tt>
 <list compact>
 <item>Cambia directory seguendo il percorso assoluto 
 <file>/<var>foo</var></file>.
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>Va nella directory superiore.
 </list>
<item><tt>cd ~<var>foo</var></tt>
 <list compact>
 <item>Va nella home directory dell'utente
  <tt><var>foo</var></tt>.
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>Va nella directory precedente.
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>Mostra il contenuto di <file>/etc/motd</file> usando il paginatore di
 default.
   Vedere <ref id="cmd-stdin">.
  <footnote>
Il paginatore di default di un sistema &debian; di base è <prgn>more</prgn>
che non ha lo scorrimento indietro.  Installando il pacchetto <package>less</package>
tramite <tt>apt-get install less</tt>,
<prgn>less</prgn> diventa il paginatore di default, così potrete scorrere
all'indietro tramite i tasti cursore.
  </footnote>
 </list>
<item><tt>touch <var>junkfile</var></tt>
 <list compact>
 <item>Crea un file vuoto <file><var>junkfile</var></file>.
 </list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Copia un file esistente <file><var>foo</var></file> in muovo
  file <file><var>bar</var></file>.
 </list>
<item><tt>rm <var>junkfile</var></tt>
 <list compact>
 <item>Rimuove il file <file><var>junkfile</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Rinomina un file esistente <file><var>foo</var></file> in 
  <file><var>bar</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
 <list compact>
 <item>Muove un file esistente <file><var>foo</var></file> in una nuova
 locazione con un nuovo nome <file><var>bar/baz</var></file>. La
  directory <file><var>bar</var></file> deve esistere.
 </list>
<item><tt>chmod 600 <var>foo</var></tt>
 <list compact>
 <item>Rende un file esistente <file><var>foo</var></file>
 non-leggibile e non-scrivibile dagli altri utenti. (non-eseguibile per tutti)
 </list>
<item><tt>chmod 644 <var>foo</var></tt>
 <list compact>
 <item>Rende un file esistente <file><var>foo</var></file>
 leggibile ma non-scrivibile dagli altri utenti. (non-eseguibile per tutti)
 </list>
<item><tt>chmod 755 <var>foo</var></tt>
 <list compact>
 <item>Rende un file esistente <file><var>foo</var></file> leggibile
 ma non-scrivibile per gli altri utenti. (eseguibile per tutti)
 </list>
<item><tt>top</tt>
 <list compact>
 <item>Mostra le informazioni sui processi a tutto schermo.  Digitate "q" per
 uscire.
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>Mostra le informazioni su tutti i processi in esecuzione usando un
 output in stile BSD. Vedere <ref id="cmd-pipe">.
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>Mostra le informazioni su tutti i processi in esecuzione usando un
 output in stile Unix system-V.
 </list>
<item><tt>ps aux | grep -e "[e]xim4*"</tt>
 <list compact>
 <item>Mostra tutti i processi che usano <prgn>exim</prgn> o
 <prgn>exim4</prgn>.  Imparate le espressioni regolari dalla <manref
 name="grep" section="1"> pagina di manuale digitando <tt>man grep</tt>.
 <footnote>
 <tt>[</tt> e <tt>]</tt> nelle espressioni regolari permettono a
 <prgn>grep</prgn> di evitare di trovare corrispondenze con sè stesso.  Il
 <tt>4*</tt> nella espressione regolare significa 0 o più ripetizioni del
 carattere 4, per cui permette a <prgn>grep</prgn> di trovare corrispondenze
 sia con <prgn>exim</prgn> che con <prgn>exim4</prgn>.  Sebbene <tt>*</tt> sia
 usato come metacarattere sia nei nomi dei file della shell che nelle espressioni
 regolari, ha significati differenti.
 </footnote>
 </list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item>Mostra le informazioni su tutti i processi in esecuzione usando un
 output in arte ASCII.
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>Uccide un processo idenficato dal numero: <var>1234</var>.
 Vedere <ref id="kill">.
 </list>
<item><tt>grep -e "<var>modello</var>" *.html</tt>
 <list compact>
 <item>Trova un "<var>modello</var>" in tutti i file che terminano per
  <tt>.html</tt> nella directory corrente e li mostra tutti.
 </list>
<item><tt>gzip <var>foo</var></tt>
 <list compact>
 <item>Comprime <file><var>foo</var></file> per creare
  <file><var>foo</var>.gz</file> usando la codifica Lempel-Ziv (LZ77).
 </list>
<item><tt>gunzip <var>foo</var>.gz</tt>
 <list compact>
 <item>Decomprime <file><var>foo</var>.gz</file> per creare
  <file><var>foo</var></file>.
 </list>
<item><tt>bzip2 <var>foo</var></tt>
 <list compact>
 <item>Comprime <file><var>foo</var></file> per creare
  <file><var>foo</var>.bz2</file> utilizzando l'algoritmo di compressione del
  testo Burrows-Wheeler e la codifica Huffman. (Migliore compressione
di <prgn>gzip</prgn>)
 </list>
<item><tt>bunzip2 <var>foo</var>.bz2</tt>
 <list compact>
 <item>Decomprime <file><var>foo</var>.bz2</file> per creare
  <file><var>foo</var></file>.
 </list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
 <list compact>
 <item>Estrae i file dall'archivio <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
 <list compact>
 <item>Estrae i file dall'archivio gzippato <file><var>foo</var>.tar.gz</file>.
 </list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
 <list compact>
 <item>Estrae i file dall'archivio <file><var>foo</var>.tar.bz2</file>.
  <footnote>
Qui si è usata l'opzione <tt>--bzip2</tt> al posto della più breve <tt>-j</tt>
per essere sicuri che funzioni anche con le versioni più vecchie di <prgn>tar</prgn> in Potato.
  </footnote>
 </list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
 <list compact>
 <item>Archivia il contenuto della cartella <file><var>bar</var>/</file> in un
 archivio <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
 <list compact>
 <item>Archivia il contenuto della cartella <file><var>bar</var>/</file> in
  un archivio <file><var>foo</var>.tar.gz</file> compresso.
 </list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
 <list compact>
 <item>Archivia il contenuto della cartella <file><var>bar</var>/</file> in
  <file><var>foo</var>.tar.bz2</file>.
  <footnote>
Di nuovo, <tt>--bzip2</tt> viene usato per garantire la compatibilità.
  </footnote>
 </list>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>Mostra il contenuto del compresso
  <file>README.gz</file> usando il paginatore di default.
 </list>
<item><tt>zcat README.gz &gt; foo</tt>
 <list compact>
 <item>Crea un file <file>foo</file> con il contenuto non compresso di 
  <file>README.gz</file>.
 </list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
 <list compact>
 <item>Appende il contenuto non compresso di <file>README.gz</file> alla fine
 del file <file>foo</file>. (Se non esiste, prima lo crea.)
 </list>
<item><tt>find . -name <var>modello</var></tt>
 <list compact>
 <item>trova i file con i nomi corrispondenti usando il
 <tt><var>modello</var></tt> della shell.  (più lento)
 </list>
<item><tt>locate -d . <var>modello</var></tt>
 <list compact>
 <item>find i file con i nomi corrispondenti usando il
 <tt><var>modello</var></tt> della shell.  (più rapido, se si usa un database
 generato regolarmente)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
Come esercizio, attraversate le directory e sbirciate nel sistema usando i
comandi sopraelencati. Se avete dubbi sui comandi, assicuratevi di aver letto
le pagine di manuale. Per esempio, un buon inizio sono questi comandi:
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
Questo è anche il momento giusto per lanciare <prgn>vim</prgn> e premere il
tasto F1. Dovreste leggere almeno le prime 35 righe. Poi fate un pò di
esercizio in linea muovendo il cursore su <tt>|tutor|</tt> e premendo Ctrl-].
Vedere <ref id="edit"> per impararne di più sugli editor.
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
Notate che molti comandi Unix-like, compresi quelli provenienti da GNU e BSD,
mostreranno delle brevi informazioni di aiuto se invocati in uno dei modi
seguenti (o senza argomenti, in alcuni casi):
<example>
$ <var>nomecomando</var> --help
$ <var>nomecomando</var> -h
</example>
<p>
Come esercizio, provate anche gli esempi in <ref id="tips">.

<sect1 id="cmd-exec">Esecuzione dei comandi
<p>
<!-- new content -->
Avete avuto un assaggio su come usare il sistema &debian;.
Addentriamoci ora nei meccanismi di esecuzione dei comandi.
<footnote>
Qui la realtà è stata semplificata, per venire incontro al neofit.  Vedere <manref name="bash"
section="1"> per una spiegazione più completa.
</footnote>

<sect1 id="cmd-simple">Il comando semplice
<p>
<!-- new content -->
Un comando semplice è una sequenza di 
<enumlist compact>
<item>compiti della variabile (opzionale)
<!-- fixme trovare una traduzione migliore -->
<item>nome comando
<item>argomenti (opzionale)
<item>redirezioni (opzionale: <tt>&gt;</tt> , <tt>&gt;&gt;</tt> ,
<tt>&lt;</tt> , <tt>&lt;&lt;</tt> , etc.)
<item>operatore di controllo (opzionale: <tt>&amp;&amp;</tt> , <tt>||</tt> ;
&lt;newline&gt; , <tt>;</tt> , <tt>&amp;</tt> , <tt>(</tt> , <tt>)</tt>
)
</enumlist>
<p>
Per comandi più complessi, con quotazioni e sostituzioni, vedere <ref
id="clprocess">.

<sect1 id="cmd-env">Esecuzione dei comandi e variabili d'ambiente
<p>
<!-- new content -->
Una tipica esecuzione di un comando usa una sequenza di shell coma la seguente:
<footnote>
Per ottenereTo il risultato seguente, dovreste installare il locale Francese,
vedere <ref id="locales">.  Ciò non è essenziale per la lezione. Viene fatto
solo per mostrare gli effetti potenziali.
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
In questo caso il programma <prgn>date</prgn> viene eseguito in primo piano.
La variabile di ambiente <tt>LC_ALL</tt> è:
<list compact>
<item>non impostata (default del sistema, <tt>C</tt>) per il primo comando
<item>impostata a <tt>fr_FR</tt> (locale Francese) per il secondo comando
</list>
Gran parte delle esecuzioni dei comandi non sono generalmente preceduti da una
definizione della variabile di ambiente. In riferimento all'esempio
precedente, potete eseguire, in alternativa:
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
Come potete vedere, il risultato del comando viene influenzato dalla variabile
di ambiente, che produrrà un risultato in francese. Se volete che la variabile
di ambiente venga inglobata dai sottoprocessi (quando chiamate uno script
della shell, per esempio), dovete "esportarla", usando:
<example>
$ export LC_ALL
</example>


<sect1 id="cmd-path">Il percorso di ricerca dei comandi
<p>
<!-- new content -->
Quando date un comando nella shell, essa lo cerca nella lista di directory
contenuta nella variabile <tt>PATH</tt>. Il valore di <tt>PATH</tt> viene
anche chiamato percorso di ricerca della shell.
<p>
In una installazione &debian; di base, la variabile <tt>PATH</tt> degli
account utenti può non comprendere <file>/sbin/</file>.  Quindi, se volete
lanciare un comando tipo <prgn>ifconfig</prgn> da <file>/sbin/</file>, 
dovete modificare <tt>PATH</tt> in maniera da includerlo.
La variabile <tt>PATH</tt> viene di solito impostata dal file di
inizializzazione <file>~/.bash_profile</file>, vedere <ref id="bashconf">.

<sect1 id="cmd-opt">Opzioni della riga di comando
<p>
<!-- new content -->
Alcuni comandi richiedono degli argomenti.  Gli argomenti che cominciano con
<tt>-</tt> o con <tt>--</tt> vengono chiamati opzioni e controllano il
comportamento del comando.
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
In questo caso l'argomento <tt>-R</tt> modifica il comportamento di <prgn>date</prgn>
per dare come risultato una stringa con una data compatibile RFC-2822.

<sect1 id="cmd-wild">Metacaratteri della shell
<p>
<!-- new content -->
Spesso capita che vogliate che un comando funzioni su un gruppo di file, senza
digitarli tutti. Il modello di espansione dei nomi dei file che utlizza
<strong>metacaratteri</strong> facilita questo compito.
<list compact>
<item><tt>*</tt>
<list compact>
<item>Comprende un qualsiasi gruppo di 0 o più caratteri.
<item>Non comprende un file che inizia per "<tt>.</tt>".
</list>
<item><tt>?</tt>
<list compact>
<item>Comprende esattamente un unico carattere.
</list>
<item><tt>[...]</tt>
<list compact>
<item>Comprende esattamente qualsiasi carattere
contenuto fra le parentesi
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>Comprende esattamente qualsiasi carattere
compreso fra <tt>a</tt> e <tt>z</tt>.
</list>
<item><tt>[^...]</tt>
<list compact>
<item>Comprende esattamente qualsiasi carattere diverso da quelli contenuti
tra parentesi (escluso "^").
</list>
</list>

Come esempio, provate da voi e ragionateci su:
<example>
$ mkdir junk; cd junk; touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rm -rf junk
</example>

<sect1 id="cmd-return">Restituire il valore dei comandi
<p>
Ogni comando restituisce il suo stato in uscita come valore restituito.
<list compact>
<item>valore restituito = 0 se il comando è stato eseguito con successo.
<item>valore restituito = non-zero se il comando termina con errori.
</list>
Si può accedere al valore restituito attraverso la variabile di shell <tt>$?</tt>
subito dopo l'esecuzione.
<example>
$ [ 1 = 1 ] ; echo $?
0
$ [ 1 = 2 ] ; echo $?
1
</example>
Notate che, quando il valore restituito viene usato nel contesto logico della
shell, il <strong>successo</strong> viene trattato come il 
<strong>VERO</strong> in logica.  Ciò è poco intuitivo, dato che
<strong>successo</strong> ha valore <strong>zero</strong>.
<p>
Vedere <ref id="shell-cond">.

<sect1 id="cmd-typical">Tipiche sequenze di comandi
<p>
<!-- new content in this whole sect1 ind sect2s -->
Proviamo a ricordare i seguenti comandi idiomatici della shell.  
Vedere <ref id="shell-param">, <ref id="shell-redirect">, 
<ref id="shell-cond">, e <ref id="clprocess"> dopo aver letto questi 
idiomi.

<sect2 id="cmd-back"><tt>comando &amp;</tt>
<p>
Il <prgn>comando</prgn> viene eseguito nella subshell nello
<strong>sfondo</strong>.  I lavori nello sfondo permettono all'utente di
lanciare più programmi in una singola shell.
<p>
La gestione dei processi nello sfondo coinvolge i fondamentali della shell:
<prgn>jobs</prgn>, <prgn>fg</prgn>, <prgn>bg</prgn>, e
<prgn>kill</prgn>. Leggete le sezioni della pagina di manuale <manref name="bash"
section="1"> sotto "SIGNALS",  "JOB CONTROL", e "SHELL
BUILTIN COMMANDS".
<footnote>
Il sistema &debian; è un sistema multi-tasking.
</footnote>
 
<sect2 id="cmd-pipe"><tt>comando1 | comando2</tt>
<p>
Lo standard output di <prgn>comando1</prgn> viene dato allo standard input di
<prgn>comando2</prgn> .  Entrambi i comandi possono essere eseguiti
<strong>contemporaneamente</strong>.  Questa si chiama <strong>pipeline</strong>.

<sect2 id="cmd-list"><tt>comando1 ; comando2</tt>
<p>
<prgn>comando1</prgn> e <prgn>comando2</prgn>
sono eseguiti <strong>in sequenza</strong>.
 
<sect2 id="cmd-and"><tt>comando1 &amp;&amp; comando2</tt>
<p>
<prgn>comando1</prgn> viene eseguito.  Se con successo,
<prgn>comando2</prgn> viene eseguito <strong>in sequenza</strong>.
Verrà restituito un successo se sia <prgn>comando1</prgn> <strong>che</strong>
<prgn>comando2</prgn> sono stati eseguiti con successo.
 
<sect2 id="cmd-or"><tt>comando1 || comando2</tt>
<p>
<prgn>comando1</prgn> viene eseguito.  Se non con successo, allora
anche <prgn>comando2</prgn> viene eseguito <strong>in sequenza</strong>.
Verrà restituito un successo se <prgn>comando1</prgn> <strong>oppure</strong>
<prgn>comando2</prgn> sono stati eseguiti con successo.

<sect2 id="cmd-stdout"><tt>comando &gt; <var>foo</var></tt>
<p>
Redireziona lo standard output di <prgn>comando</prgn> ad un file
<tt><var>foo</var></tt>. (sovrascrive)

<sect2 id="cmd-stdout2"><tt>comando &gt;&gt; <var>foo</var></tt>
<p>
Redireziona lo standard output di <prgn>comando</prgn> ad un file
<tt><var>foo</var></tt>. (appende)

<sect2 id="cmd-stderr"><tt>comando &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
Redireziona sia lo standard output che lo standard error di <prgn>comando</prgn>
ad un file <tt><var>foo</var></tt>.

<sect2 id="cmd-stdin"><tt>comando &lt; <var>foo</var></tt>
<p>
Redireziona lo standard input di <prgn>comando</prgn> ad un file
<tt><var>foo</var></tt>.  Provate:
<example>
$ &lt;/etc/motd pager
 ... (il saluto)
$ pager &lt;/etc/motd
 ... (il saluto)
$ pager /etc/motd
 ... (il saluto)
$ cat /etc/motd | pager
 ... (il saluto)
</example>
Sebbene tutte e 4 le sintassi mostrino la stessa cosa, l'ultimo esempio lancia
un comando in più, <prgn>cat</prgn> e spreca risorse senza motivo.

<sect1 id="cmd-alias">Alias dei comandi
<p>
<!-- new content -->
Potete impostare un alias per i comandi usati più di frequente.  Per esempio:
<example>
$ alias la='ls -la'
</example>
Da adesso in poi, <prgn>la</prgn> funzionerà come abbreviazione di <tt>ls
-la</tt>, che elenca tutti i file in formato esteso.
<p>
Potete identificare il percorso esatto o l'identità di un comando tramite
il comando <prgn>type</prgn>. Per esempio:
<example>
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
</example>
In questo caso <prgn>ls</prgn> è stato usato di recente, mentre <prgn>file</prgn>
no, per cui <prgn>ls</prgn> è "hashed", ovvero la shell ha un registro interno
per un accesso veloce alla locazione del comando <prgn>ls</prgn>.


<sect id="text-process">Elaborazione del testo Unix-like
<p>
Esistono alcuni strumenti standard per l'elaborazione del testo, che vengono
spesso utilizzati nei sistemi Unix-like.
<list compact>
<item>Nessuna espressione regolare viene usata:
<list compact>
<item><prgn>head</prgn> restituisce la prima parte dei file.
<item><prgn>tail</prgn> restituisce l'ultima parte dei file.
<item><prgn>sort</prgn> ordina le righe di testo dei file.
<item><prgn>uniq</prgn> rimuove le righe duplicate da un file ordinato.
<item><prgn>tr</prgn> traduce o cancella i caratteri.
<item><prgn>diff</prgn> confronta i file riga per riga.
</list>
<item>Si usano le espressioni regolari di base (Basic regular expression, BRE):
<list compact>
<item><prgn>grep</prgn> trova il testo corrispondente al modello dato.
<item><prgn>ed</prgn> è un editor primitivo a riga.
<item><prgn>sed</prgn> è un editor a flusso.
<item><prgn>vi</prgn> è un editor a schermo.
<item><prgn>emacs</prgn> è un editor a schermo.
</list>
<item>Si usano le espressioni regolari estese (Extended regular expression, ERE):
<list compact>
<item><prgn>egrep</prgn> trova il testo corrispondente al modello dato.
<item><prgn>awk</prgn> fa della semplice elaborazione di testo.
 Vedere <ref id="awk">.
<item><prgn>perl</prgn> fa qualsiasi concepibile elaborazione di testo. 
 Vedere <ref id="perl">.
</list>
</list>
Vedere <ref id="perl-i">, <ref id="scrp-snip">, e <ref id="perl-mad"> 
per alcuni script di esempio.


<sect1 id="regex">Le espressioni regolari
<p>
Le espressioni regolari vengono utilizzate da molti strumenti di elaborazione
del testo.  Sono analoghe ai metacaratteri della shell (vedere <ref
id="cmd-wild">), ma molto più complesse e potenti.
<p>
L'espressione regolare descrive il modello corrispondente da trovare ed è
fatta da caratteri di testo e da <strong>metacaratteri</strong>. Il
metacarattere è semplicemente un carattere con un significato speciale.
esistono due stili maggiori, BRE ed ERE, aseconda degli strumenti utilizzati,
come descritto in <ref id="text-process">.
<p>
In ERE, i <strong>metacaratteri</strong> comprendono "<tt> \ . [ ] ^
&dollar; * + ? ( ) { } | </tt>". L'espressione regolare significa:
<list compact>
<item><tt>c</tt>
<list compact>
<item>Corrispondenza con il non-metacarattere "<tt>c</tt>".
</list>
<item><tt>\c</tt>
<list compact>
<item>Corrispondenza con il carattere letterale "<tt>c</tt>".
</list>
<item><tt>.</tt>
<list compact>
<item>Corrispondenza con qualsiasi carattere che includa una nuova riga.
</list>
<item><tt>^</tt>
<list compact>
<item>Corrispondenza con l'inizio di una stringa.
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>Corrispondenza con la fine di una stringa.
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>Corrispondenza con l'inizio di una parola.
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>Corrispondenza con la fine di una parola.
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>Questa lista di caratteri ha corrispondenza con uno qualsiasi dei caratteri "<tt>abc...</tt>".
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>Questa lista di caratteri negat ha corrispondenza con qualsiasi
carattere tranne quelli "<tt>abc...</tt>".
</list>
<item><tt>r*</tt>
<list compact>
<item>Ha corrispondenza con nessuna o più espressioni regolari identificate da
 "<tt>r</tt>".
</list>
<item><tt>r+</tt>
<list compact>
<item>Ha corrispondenza co una o più espressioni regolari identificate da
 "<tt>r</tt>".
</list>
<item><tt>r?</tt>
<list compact>
<item>Ha corrispondenza con nessuna od una espressione regolare identificata da
 "<tt>r</tt>".
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>Ha corrispondenza con una delle espressioni regolari identificate da
 "<tt>r1</tt>" or "<tt>r2</tt>".
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>Ha corrispondenza con una delle espressioni regolari identificate da
 "<tt>r1</tt>" or "<tt>r2</tt>" e la tratta come una espressione regolare
 <strong>tra parentesi</strong>.
</list>
</list>
<p>
In BRE i <strong>metacaratteri</strong> "<tt> + ? ( ) { } | </tt>"
perdono il loro significato speciale; al loro posto si usano le versioni con
la backslash "<tt>\+ \? \( \) \{ \} \| </tt>".  Perciò il costrutto
<tt>(r1|r2)</tt> deve essere protetto come <tt>\(r1|r2\)</tt>.
Siccome <prgn>emacs</prgn>, sebbene sia di base BRE, tratta "<tt> + ?
</tt>" come <strong>metacaratteri</strong>,  
non c'è necessità di proteggerli.  Vedere <ref id="replaceex"> per come il
costrutto viene utilizzato.
<p>
Per esempio, <prgn>grep</prgn> può essere utilizzato per eseguita una ricerca
di testo mediante l'espressione regolare:
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">Espressioni sostitutive
<p>
Per le espressioni sostitutive, i caratteri seguenti hanno significati speciali:
<list>
<item><tt>&amp;</tt> 
<list compact>
<item>Rappresenta la corrispondenza dell'espressione regolare.
(usate <tt>\&amp;</tt> in <prgn>emacs</prgn>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>Rappresenta l' <var>n</var>-esima corrispondenza dell'espressione
regolare <strong>tra parentesi</strong>.  
</list>
</list>
Nelle stringhe sostitutive in Perl si usa, <tt>&dollar;<var>n</var></tt> al
posto di <tt>\<var>n</var></tt> e <tt>&amp;</tt> non alcun significato
speciale meaning.
<p>
Per esempio:
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
Ponete particolare attenzione allo stile delle espressioni regolari
<strong>tra parentesi</strong> e a come le stringhe corrispondenti siano state
usate nel processo di sostituzione del testo dai vari strumenti.
<p>
Queste espressioni regolari possono anche essere usate per i movimenti del
cursore e la sostituzione del testo negli editor.
<p>
Per imparare questi comandi, leggete le loro pagine di manuale.

<sect id="unixfile">Il filesystem Unix-like
<p>
<!-- 
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
Nei sistemi operativi GNU/Linux e negli altri Unix-like, i
<strong>file</strong> sono organizzati in <strong>directory</strong>.
<footnote>
Le <strong>directory</strong> vengono chiamate <strong>cartelle</strong> in
altri sistemi. 
</footnote>
Tutti i <strong>file</strong> e le <strong>directory</strong> sono organizzati
in un unico grande albero, la gerarchia dei file, la cui radice è <file>/</file>.
<p>
Questi file e directory possono essere sparsi su vari device. Il comando
<manref name="mount" section="8"> attacca il file
system trovato su un device al grande albero.  Al contrario, il comando
<manref name="umount" section="8"> lo staccherà nuovamente.

<sect1 id="file-basics">Le basi dei file Unix
<p>
<!-- new content -->
I principi basilari:
<list compact>
<item> I nomi dei file dipendono dai caratteri maiuscoli o minuscoli. Ovvero,
<file>MIOFILE</file> e <file>MioFile</file> sono file 
<strong>differenti</strong>.

<item>La root directory è definita semplicemente come
<file>/</file>. Non confondete questa "root" con l'utente root.
Vedere <ref id="login-root">. 

<item>Ciascuna directory ha un nome che può contenere sia lettere che simboli
<strong>tranne</strong> <file>/</file>. 
<footnote>
Anche se <strong>potete</strong> usare qualsiasi lettera o simbolo per il nome
di un file, in pratica è una cattiva idea. E' meglio evitare quei caratteri
che hanno spesso un significato speciale nella riga di comando, compresi
spazi, tabulazioni, a capo ed altri caratteri speciali:
<tt>{ } ( ) [ ] ' ` &quot; \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> .
<p>
Per separare le parole in un nome, buone scelte sono il punto, il trattino e
la sottolineatura. Potete anche iniziare ciascuna parola in maiuscolo,
<tt>ComeQuesta</tt>.
</footnote>
La root directory fa eccezione; il suo nome è <file>/</file>
(pronunciato "slash" o "la root directory") e non può essere rinominata.

<item>Ciascun file o directory viene designato da un <strong>fully-qualified
filename</strong>, <strong>absolute filename</strong>, o
<strong>path</strong>, che fornisce la sequenza delle directory che devono
esserre attraversate per raggiungerlo. I tre termini sono sinonimi. Tutti gli
absolute filenames iniziano con la directory <file>/</file>, e c'è una
<file>/</file> fra ciascuna directory o file nel filename. La prima
<file>/</file> è il nome della directory, mentre le altre sono dei semplici
separatori per distinguere le varie parti del.
<p>
Le parole possono confondere. Prendiamo il seguente esempio:
<example>
/usr/share/keytables/us.map.gz
</example>
Questo è un fully-qualified filename; alcuni lo chiamano
<strong>path</strong>. Comunque sia, ci si riferisce anche a
<file>us.map.gz</file> da solo come un filename.
<footnote> 
Esiste anche un altro utilizzo per la parole <strong>path</strong>.  Vedere <ref
id="cmd-path">.  Il suo significato viene in genere reso chiaro dal contesto.
</footnote>

<item>La root directory ha un certo numero di branche, come
<file>/etc/</file> e <file>/usr/</file>. Queste sottodirectory a turno si
dividono in altre sottodirectory, come <file>/etc/init.d/</file>
e <file>/usr/local/</file>. Il loro insieme è definito
<strong>l'albero delle directory</strong>.
<p>
Potete immaginare l'absolute filename come un percorso che parte dalla base
dell'albero (<file>/</file>) fino alla fine di qualche ramo (un file).
Sentirete anche definire l'albero delle directory come se fosse un albero
<strong>genealogico</strong>: per cui le sottodirectory hanno dei
<strong>genitori</strong>, ed un path mostra la completa storia familiare di
un file.
<p>
Esiste anche un path relativo, cha ha inizio altrove rispetto alla root
directory.  Ricordate che la directory <file>../</file>
si riferisce alla directory genitore. 

<item>Non esiste alcuna directory corrispondente ad un dispositivo fisico,
tipo il vostro disco rigido. In ciò sta la differenza rispetto a CP/M, DOS, e
Windows, dove tutti i paths iniziano con il nome di un dispositivo, come
<tt>C:\</tt>. Vedere <ref id="file-system">.
</list>

<p>
Le pratiche migliori e più dettagliate per la gerarchia dei file vengono
descritte nel<url id="&f-fhs;" name="Filesystem Hierarchy Standard">.  per
iniziare, dovreste ricordare i seguenti fatti:
<list compact>
<item><file>/</file>
<list compact>
<item>Una semplice <file>/</file> rappresenta la root directory.
<p>
</list>
<item><file>/etc/</file>
<list compact>
<item>E' il luogo dei file di configurazione generale del sistema.
</list>
<item><file>/var/log/</file>
<list compact>
<item>E' il luogo per i file di log del sistema.
</list>
<item><file>/home/</file>
<list compact>
<item>E' la directory che contiene tutte le home directory di tutti gli utenti
non privilegiati.
</list>
</list>

<sect1 id="file-system">Il concetto di filesystem in &debian;
<p>
<!-- old content modified with fs.h reference -->
Seguendo la tradizione Unix, il sistema &debian; fa sì che i filesystem sotto i
quali i dati fisici sui dischi rigidi e sugli altri dispositivi di memorie di
massa e l'interazione con i dispositivi hardware tipo le console su schermo e
le console remotes vengano rappresentati in maniera unificata.
<p>
Ciascun file, directory, pipe, o dispositivo fisico in un sistema &debian;
ha una struttura di dati chiamata <strong>inode</strong> che descrive
gli attributi ad esso associati, come l'utente a cui appartiene (proprietario),
il gruppo a cui appartiene, la data di ultimo accesso, ecc..  Vedere <url
id="&f-inode-def;"> per la definizione precisa di <tt>struct inode</tt> nel
sistema &debian; GNU/Linux.
<p>
Questa rappresentazione unificata di entità fisiche risulta molto potente, in
quanto permette l'uso degli stessi comandi per lo stesso tipo di operazioni su
dispositivi complatamente differenti
<p>
Tutti i vostri file potrebbero risiedere su un disco --- oppure potreste
averne 20, alcuni connessi a computer diversi situati altrove sulla rete. Non
potreste distinguerli guerdando semplicemente l'albero delle directory, e
quasi tutti i comandi lavorerebbero alla stessa maniera, non importa su quale
dispositivo(i) fisico(i) i file risiedono realmente.

<sect1 id="file-perm">Permessi di accesso a file e directory
<p>
<!-- old content -->
I permessi di accesso a file e directory vengono definiti separatamente per
ciascuna delle seguenti tre categorie di utenti:
<list compact>
<item>l' <strong>utente</strong> che è proprietario del file (u), 
<item>gli altri utenti nel <strong>gruppo</strong>  a cui il file appartiene
(g) e
<item>tutti gli <strong>altri</strong> utenti (o).
</list>
<p>
Dato un file, ciascun permesso corrispondente permette:
<list compact>
<item><strong>read (lettura)</strong> (r): di esaminare il contenuto del file,
<item><strong>write (scrittura)</strong> (w): di modificare e
<item><strong>execute (esecuzione)</strong> (x): di eseguire il file come un comando.
</list>
<p>
Data una directory, ciascun permesso corrispondente permette:
<list compact>
<item><strong>read</strong> (r): di elencare i contenuti della directory,
<item><strong>write</strong> (w): di aggiungere o rimuovere i file nella
directory e
<item><strong>execute</strong> (x): di accedere ai file nella.
</list>
In questo caso il permesso in <strong>esecuzione</strong> sulla directory non
solo permette di leggere i file nella directory, ma anche di vedere i lori
attributi, come le dimensioni e la data dell'ultima modifica.
<p>
per mostrare le informazioni sui permessi (e molto altro) dei file e delle
directory si usa <prgn>ls</prgn>.  Vedere <manref name="ls" section="1">.  
Quando <prgn>ls</prgn> viene invocato con l'opzione <tt>-l</tt> mostrerà le
seguenti informazioni, nell'ordine:
<list compact>
<item> <strong>tipo di file</strong> (primo carattere)
 <list compact>
 <item><tt>-</tt>: normale
 <item><tt>d</tt>: directory
 <item><tt>l</tt>: collegamento simbolico
 <item><tt>c</tt>: character device node
 <item><tt>b</tt>: block device node
 <item><tt>p</tt>: named pipe
 <item><tt>s</tt>: socket
 </list>
<item>i <strong>permessi</strong> di accesso al file (i nove caratteri
successivi, consistenti di tre caratteri per ciascuno, utente, gruppo ed
altri, in quest'ordine)
<item>il <strong>numero di hard links</strong> al file 
<item>il nome dell' <strong>utente</strong> a cui appartiene
<item>il nome del <strong>gruppo</strong> a cui il file appartiene
<item>le  <strong>dimensioni</strong> del file in caratteri (bytes)
<item>    <strong>data ed ora</strong> del file (mtime)
<item>il  <strong>nome</strong> del file.
</list>
<p>
Per cambiare il proprietario del file, si usa <prgn>chown</prgn> dall'account
di root. Per cambiarne il gruppo, si utlizza <prgn>chgrp</prgn> o dall'account
del proprietario, o da quello di root. Per cambiare i permessi di accesso al
file ed alla directory, si usa <prgn>chmod</prgn> dall'account del
proprietario, o da quello di root. La sintassi di base per manipolare un dato
file <file>foo</file> file è:
<example>
# chown <var>nuovoproprietario</var> foo
# chgrp <var>nuovogruppo</var> foo 
# chmod  [ugoa][+-=][rwx][,...] foo 
</example>
Vedere <manref name="chown" section="1">,
<manref name="chgrp" section="1">, e
<manref name="chmod" section="1"> per i dettagli.

<p>
Per esempio, per rendere proprietario di una directory l'utente 
<var>foo</var> e condivisa da un gruppo <var>bar</var>, eseguite i seguenti
comandi dall'account di root: 
<example>
# cd /una/locazione/
# chown -R <var>foo</var>:<var>bar</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
Esistono altri tre bit di permessi speciali:
<list compact>
<item><strong>set user ID</strong> (s o S invece della x di user),
<item><strong>set group ID</strong> (s o S invece della x di group), and
<item><strong>sticky bit</strong> (t o T invece della x di other).
</list>
In questo caso l'output di <prgn>ls -l</prgn> per detti bit viene dato in
maiuscolo se la modalità nascosta per i bit di esecuzione non è impostata.
<p>
Impostare <strong>set user ID</strong> su un file eseguibile permette
all'utente di eseguirlo con l'owner ID del file (per esempio
<strong>root</strong>). Allo stesso modo, impostare
<strong>set group ID</strong> su un eseguibile permette all'utente di
eseguirlo con il group ID del file (per esempio <strong>root</strong>). Poichè
queste impostazioni possono causare seri problemi di sicurezza, abilitarle
richide estrema cautela.
<p>
Impostare <strong>set group ID</strong> su una directory abilita lo schema di
creazione dei file stile BSD, dove tutti i file creati nella directory
appartengono al <strong>gruppo</strong> della directory.  
<p>
Impostare lo <strong>sticky bit</strong> in una directory previene la
rimozione di un file in detta directory da un utente che non sia il
proprietario del file. Per rendere sicuro il contenuto di un file in una
directory scrivibile da tutti, come ad esempio <file>/tmp</file> o in diretory
scrivibile dal gruppo, non bisogna solamente disabilitare i permessi in
<strong>scrittura</strong> del file, ma anche impostare lo <strong>sticky
bit</strong> nella directory.  Altrimenti il file potrebbe essere rimosso e
sostituito da un nuovo fiole con lo stesso nome, da qualsiasi utente con
accesso in scrittura alla directory. 
<p>
Ecco alcuni esempi interessanti sui permessi.
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
Esiste un metodo numerico alternativo di descrivere i permessi per i comandi
<manref name="chmod" section="1">.  Questo metodo usa numeri da 3 a 4 cifre in
ottale (base 8). Ogni cifra corrisponde a:
<list compact>
<item>1a cifra facoltativa: la somma di <strong>set user ID</strong> (=4), 
 <strong>set group ID</strong> (=2), e <strong>sticky bit</strong> (=1)
<item>2a cifra: la somma dei permessi
 <strong>lettura</strong> (=4), <strong>scrittura</strong> (=2), e 
 <strong>esecuzione</strong> (=1)
 per l' <strong>utente</strong>
<item>3a cifra: idem per il <strong>gruppo</strong>
<item>4a cifra: idem per <strong>other</strong>
</list>
<p>
Suona complicato, ma è in effetti molto semplice. Se guardate alle prime
(2-10) colonne dell'output del comando <tt>ls -l</tt> e le leggete come una
rappresentazione binaria (base 2) dei permessi dei file ("-" essendo
"0" e "rwx" essendo "1"), il valore numerico diventa una rappresentazione in
ottale dei permessi.
<footnote>
Oviamente questo metodo funziona solo per i numeri a 3 cifre.
</footnote>
Provate ad esempio:
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
La maschera di default dei permessi può essere impostata tramite il comando di
shell <prgn>umask</prgn>.  Vedere <manref name="builtins" section="7">.
</sect1>

<sect1 id="timestamp">Timestamp
<p>
<!-- old content, minor edit -->
Per un file GNU/Linux, ci sono tre tipi di timestamp:
<list compact>
<item><strong>mtime</strong>: orario di modifica (<tt>ls -l</tt>),
<item><strong>ctime</strong>: orario di cambio di stato (<tt>ls -lc</tt>), e
<item><strong>atime</strong>: orario dell'ultimo accesso (<tt>ls -lu</tt>).
</list>
Notate che <strong>ctime</strong> non è l'orario di creazione del file.  
<list compact>
<item>La sovrascrittura di un file cambierà tutti e tre, <strong>mtime</strong>,
  <strong>ctime</strong>, e <strong>atime</strong>.
<item>Il cambio di permessi od utente modificherà
  <strong>ctime</strong> e <strong>atime</strong>.
<item>La lettura di un file ne cambierà <strong>atime</strong>.
</list>
Notate che anche una semplice lettura del file in un sistema &debian; causerà
una normale operazione di scrittura del file, per aggiornare le informazioni
relative a <strong>atime</strong> nell' <strong>inode</strong>.  Montare un
filesystem con l'opzione <tt>noatime</tt> farà si che il sistemi salti questa
operazione, risultando un tempo di accesso del file più breve in lettura. Vedere <manref name="mount"
section="8">.
<p>
<!-- new content -->
Usate il comando <manref name="touch" section="1"> per cambiare i timestamp
dei file esistenti.
</sect1>

<sect1 id="links">Collegamenti
<p>
<!-- old content -->
Due sono i metodi per associare un dato file <var>foo</var> con un diverso
nome <var>bar</var>.
<list compact>
<item>un <strong>collegamento</strong> è un nome duplicato di un file esistente
 (<tt>ln <var>foo</var> <var>bar</var></tt>),
<item>un <strong>collegamento simbolico</strong>, o "symlink", è un file
speciale che punta ad un altro file
 (<tt>ln -s <var>foo</var> <var>bar</var></tt>).
</list>
Vedere il seguente esempio per i cambiamenti nella conta dei collegamenti e le
sottili differenze nel risultato del comando <prgn>rm</prgn>.
<example>
$ echo "Contenuto Originale" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # hard link
$ ln -s <var>foo</var> <var>baz</var>  # symlink
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "Nuovo Contenuto" &gt; <var>foo</var>
$ cat <var>bar</var>
Contenuto Originale
$ cat <var>baz</var>
Nuovo Contenuto
</example>
<!-- minor update below -->
Il collegamento simbolico ha sempre i permessi nominali di accesso impostati
su "rwxrwxrwx", come mostrato nell'esempio precedente, con i permessi
effettivi dettati dai permessi del file a cui punta.

<p>
La directory <file>.</file> è collegata alla directory nella quale appare, per
cui la conta dei collegamenti di qualsiasi nuova directory parte da 2. La
directory <file>..</file> e collegata alla directory genitore, per cui la
conta dei collegamenti della directory aumenta all'aggiungere nuove
sottodirectory. 
<sect1 id="fifo">Named pipe (FIFO)
<p>
<!-- DDP Debian Tutorial content -->
<p>
Una named pipe è un file che agisce come una pipe. Inserite qualcosa in un
file da un lato ed esce dall'altro. Da qui il nome FIFO, o First-In-First-Out:
la prima cosa che infilate nella pipe è anche la prima ad uscirne.
<p>
Se avviate un processo di scrittura verso una named pipe, il processo non
terminerà finchè l'informazione che viene scritta non è letta dalla pipe. Se
avviate un processo di lettura dalla pipe, il processo aspetterà prima di
terminare che non ci sia altro da leggere. Le dimesioni della pipe sono sempre
zero --- non memorizza dati, si limita ad unire due processi, come il
carattere <tt>|</tt> della shell. Comunque, poichè questa pipe ha un nome, i
due processi non devono necessariamente stare sulla riga di comando, nè essere
lanciati dallo stesso utente. 
<p>
Provate facendo quanto segue:
<example>
$ cd; mkfifo miapipe
$ echo "hello" &gt;miapipe &amp; # gira nello sfondo
[1] <var>5952</var>
$ ls -l miapipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 miapipe
$ cat miapipe
hello
[1]+  Done                    echo hello &gt;miapipe
$ ls miapipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 miapipe
$ rm miapipe
</example>

<sect1 id="sockets">Socket
<p>
<!-- new content -->
Il socket è simile alla named pipe (FIFO) è permette ai processi di scambiarsi
informazioni. per il socket questi processi non devono girare allo stesso
tempo, nè devono essere figli dello stesso genitore. Questo è il traguardo di
qualsiasi comunicazione interprocesso. Lo scambio di informazioni può avvenire
attraverso una rete, fra host differenti. 

<sect1 id="device">Device
<p>
<!-- DDP Debian Tutorial content, modified -->
Un device fa riferimento ad un dispositivo fisico o virtuale presente nel
sistema, come il disco rigido, la scheda grafica, lo schermo o la tastiera.
Esempio di dispositivo virtuale è la console, rappresentata da <tt>/dev/console</tt>.
<p>
Esistono due tipi di device: 
<list compact>
<item><strong>character device</strong>
<list compact>
<item>Vi può accedere un carattere alla volta, cioè la più piccola unità di
dati che vi può essere scritta è un carattere (byte). 
</list>
<item><strong>block device</strong>
<list compact>
<item>Qui vi si può accedere in unità maggiori, chiamte blocchi, che
contengono un numero di caratteri. Il disco rigido è un block device.
</list>
</list>
<p>
Potete leggere e scrivere sui device, anche se il file potrebbe contenere dati
binari, incomprensibili ai comuni mortali. Scrivere direttamente i dati su
questi file può essere utile per diagnosticare problemi nelle connessioni
hardware. Per esempio, inviare un file di testo al device della stampante
<file>/dev/lp0</file> oppure inviare i comandi del modem alla porta seriale
appropriata <file>/dev/ttyS0</file>.  Attenzione che, se eseguite
imprudentemente, queste manovre possono portare a disastri notevoli. 

<sect2 id="devnull"><file>/dev/null</file> ecc.
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> è un device speciale che elimina qualsiasi cosa gli si
vada a scrivere. Se c'è qualcosa che non volete, gettatela in 
<file>/dev/null</file>.  E' fondamentalmente un pozzo senza fondo. Se andate a
leggere <file>/dev/null</file>, ottenete immediatamente un carattere end-of-file (EOF). 
<p>
<file>/dev/zero</file> is simile, solo che se andate a leggerlo, ottenete il
carattere <tt>\0</tt> (diverso dal numero zero in ASCII).  Vedere <ref
id="dummyfile">.

<sect2 id="node">Numeri dei nodi dei device
<p>
<!-- new content -->
I numeri dei nodi dei device lanciando <prgn>ls</prgn> come:
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
Qui,
<list compact>
<item><file>/dev/hda</file> ha come numero primario 3 e come secondario
0. E' accessibile in lettura/scrittura dall'utente che appartiene al gruppo
<tt>disk</tt>,
<item><file>/dev/ttyS0</file> ha come numero primario 4 e come secondario 64.
E' accessibile in lettura/scrittura dall'utente che appartiene al gruppo
<tt>dialout</tt> group e
<item><file>/dev/zero</file> ha come numero primario 1, secondario 5. E'
accessibile in lettura/scrittura da chiunque.
</list>
<p>
Nei vecchi sistemi il processo di installazione crea i nodi dei device
tramite il comando <prgn>/sbin/MAKEDEV</prgn> command.  Vedere <manref
name="MAKEDEV" section="8">.
<p>
Nei sistemi più recenti il filesystem sotto <file>/dev</file>
viene popolato automaticamente in maniera analoga al filesystem
<file>/proc</file>.

<sect1 id="procfs">Il filesystem <file>/proc</file>
<p>
<!-- modified heavily, original from Debian Guide -->
Il filesystem <file>/proc</file> è uno pseudo-filesystem e contiene
informazioni sul sistema e sui processi in corso.
<p>
La gente in genere si spaventa quando nota un file in particolare -
<file>/proc/kcore</file> - che è generalmente enorme. Esso è (più o
meno) una copia della memoria del vostro computer. Viene utilizzato per il
debug del kernel. In pratica non esiste da nessuna parte, per cui non
preoccupatevi delle sue dimensioni. 
<p>
Vedere <ref id="proc-sys"> and <manref name="proc" section="5">.

<sect id="xtuto">Il sistema X Window
<p>
<!-- practically new content -->
Vedere <ref id="x">.

<sect1 id="xstart">Lanciare il sistema X Window
<p>
X Window può essere lanciato automaticamente con
<prgn>xdm</prgn>-come demone per il login grafico, o digitando quanto segue da
console. 
<example>
$ exec startx
</example>

<sect1 id="xmenu">Il menu di X Window
<p>
Poichè l'ambiente di X è in grado di ospitare molti window manager, le loro
interfacce variano molto. Ricordate che cliccando col pulsante destro del
mouse sulla root window evidenzierà il menu delle scelte. Questo è sempre
disponibile. 
<list compact>
<item>Per avviare la shell, lanciate Xterm dal menu:
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>Per scorrere graficamente le pagine web, lanciate Mozilla dal menu:
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>Per visualizzare graficamente file in PDF, lanciate xpdf del menu:
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
Se vi manca la voce nel menu, installate i pacchetti corrispondenti.  Vedere
<ref id="apt-install">.

<sect1 id="xkeys">Sequenze di tasti per X Window
<p>
Alcune combinazioni da ricordare quandi si è in X:

<list compact>
<item>Ctrl-Alt-F1 fino a F6: Passa ad altri pseudo-terminali
                       (da X-window, DOSEMU, ecc.)
<item>Alt-F7:          Torna ad X
<item>Ctrl-Alt-meno:   Modifica la risoluzione dello schermo in X (il meno si
riferisce al tastierono numerico)
<item>Ctrl-Alt-più:    Modifica la risoluzione in X dalla parte opposta (il
più si riferisce al tastierino numerico)
<item>Ctrl-Alt-Backspace:   Termina il server X
<item>Alt-X, Alt-C, Alt-V:   Le normali combinazioni Windows/Mac per Taglia, 
        Copia, Incolla con Ctrl- in alcuni programmi tipo Netscape 
        Composer vengono sostituite da Alt-.
</list>

<sect id="cmd-study">Studi ulteriori
<p>
In questo momento, vi raccomando la lettura delle guide fondamentali da
<url id="&tldp-guide;" name="The Linux Documentation Project: Guides">:
<list compact>
<item>"The Linux System Administrators' Guide",
<list compact>
<item>Copre tutti gli aspetti del mantenimento di un sistema in funzione,
gestione degli account utente, backup, configurazione del sistema. 
<item>pacchetto: <package>&p-sysadmin-guide;</package>
<item>file: <url id="&f-sysadmin-guide;">
<item>web: <url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition",
<list compact>
<item>Riferimento per l'amministrazione di rete in ambiente Linux.
<item>pacchetto: <package>&p-netadmin-guide;</package>
<item>file: <url id="&f-netadmin-guide;">
<item>web: <url id="&w-netadmin-guide;">
</list>
 <item><em>Linux: Rute User's Tutorial and Exposition</em>
 <list compact>
  <item>Un bel libro e versione on line che copre l'amministrazione dei
  sistemi GNU/Linux.
  <item>Di Paul Sheer
  <item>Pubblicato da Prentice Hall
  <item>Pacchetto: <package>&p-rutebook;</package> (da <tt>non-free</tt>)
  <item>File: <file>&f-rutebook;</file>
  <!--
  <item>Web: <url id="&rutehome;">
  -->
 </list>
</list>
<p>
Vedere <ref id="support"> per ulteriori fonti di apprendimento.
</chapt>
