<!-- CVS revision of this document "$Revision: 1.2 $"  -->
<!-- CVS revision of original english document "1.105"  -->

<chapt id="tips"> &debian; tips


<sect id="booting">システムをブートする
<p>
ブートプロンプトの詳細は LDP にある
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> をご覧ください。

<sect1 id="crackroot">"root パスワードを忘れてしまった!" (その 1)
<p>
コンソールのキーボードにアクセスできる人に限り、root パスワードを
知らずにシステムをブートして root アカウントにログオンできます。
(システムをブートするのを妨げる BIOS や <prgn>lilo</prgn> などの
ブートローダからパスワードを要求されないことを仮定しています。)
<p>
これは外部の boot disk や BIOS のブート設定の変更を要求しない手順
です。ここで、"Linux" は標準の Debian インストールで Linux kernel
をブートするためのラベルです。
<p>
<prgn>lilo</prgn> ブートスクリーンでは、<tt>boot:</tt> が表示されたら
すぐに enter を押し、次のように入力します。
(自動ブートを避けるため、この時点で shift キーを押す必要があるシステム
があります。また、<prgn>lilo</prgn> がフレームバッファを使っている場合、
タイプしたオプションを見るには TAB を押す必要があります。)
<example>
boot: Linux init=/bin/sh
</example>
この操作により、システムが kernel をブートし、標準の <prgn>init</prgn>
の代わりに <file>/bin/sh</file> を起動します。今や root 権限と root シェル
を獲得しました。<file>/</file> は現在読み込みのみでマウントされ、
多くのディスクパーティションはまだマウントされていないので、
十分機能するシステムとするには、次を実行する必要があります。
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(<file>/etc/passwd</file> の 2番目のデータフィールドが全てのユーザ名に対して
"x" である場合、そのシステムはシャドウパスワードを使用しているため、
<file>/etc/shadow</file> を編集する必要があります。)
root パスワードを無効にするには、パスワードファイルの 2番目のフィールド
が空になるように編集してください。システムをリブートして、パスワード無しで
root としてログインできるようになりました。runlevel 1 でブートすると、
(少なくとも Potato 以降の) Debian はパスワードを要求しますが、より古い
システムは要求しませんでした。
<p>
<file>/usr/</file> にアクセスできない場合に備えて <file>/bin/</file>
に最小限のエディタを置いておくのは良い考えです。
(<ref id="bin-editor"> 参照)
<p>
また、<package>sash</package> パッケージのインストールも考慮に入れてください。
システムがブート不能に陥った場合、次を実行します。
<example>
boot: Linux init=/bin/sash
</example>
<prgn>sash</prgn> は <file>/bin/sh</file> が使えなくなった場合でも
<prgn>sh</prgn> 対話的な代替品として働きます。
これはスタティックリンクされており、多くの標準的な機能を組込みえ
含んでいます。
(リファレンスリストのため、プロンプトで "help" をタイプしてみてください)
</sect1>

<sect1 id="crackroot2">"root パスワードを忘れてしまった!" (その 2)
<p>
rescue disk/root disk セットからブートします。
<file><var>/dev/hda3</var></file> がもともとの root パーティションの場合、
次の手順は、パスワードファイルを前述の手順と同じ程度に簡単に編集できるようにします。
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
この手法の前述した手法に対する利点は、<prgn>lilo</prgn> パスワードを知る
(ある場合) 必要がないことです。しかし、本手法を使うには、
システムがフロッピ又は CD からブートできるように BIOS セットアップに
アクセスできる必要があります。
</sect1>

<sect1 id="dead-lilo">boot 不能
<p>
インストール中に boot ディスクを作るのをさぼっていたとしても、問題ありません。
<prgn>lilo</prgn> が壊れた場合、Debian インストールセットから boot disk
を持ってきて、そこからシステムを boot させます。boot プロンプトでは、
root パーティション が <file><var>/dev/hda12</var></file> であり、
ランレベル 3 で起動したいと仮定すると、次のコマンドを入力します。
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
そして、フロッピにある kernel を使ってほとんどフル機能のシステムにブート
します。(kernel の機能やモジュールの不足によるささいな誤作動はあります。)
<p>
システムが壊れた場合、<ref id="un-bootable"> をご覧ください。
<p>
カスタムブートフロッピが必要な場合、rescue disk の <file>readme.txt</file>
に従ってください。
</sect1>

<sect1 id="no-x-start">"boot 時に X を無効にさせてくれ!"
<p>
<tt>unstable</tt> を追いかけることは楽しいですが、ブート中に起動する
バギーな <prgn>xdm</prgn>, <prgn>gdm</prgn>, <prgn>kdm</prgn>, や 
<prgn>wdm</prgn> がひどく噛みつくとも限りません。
<p>
まず boot プロンプトで次を入力して root シェルを獲得します。
<example>
boot: <var>Linux</var> vga=normal s
</example>
ここで、<var>Linux</var> はブートしたい kernel のためのラベルです。
"vga=normal" により、<prgn>lilo</prgn> が必ず通常の VGA モードで起動します。
そして、"s" (又は "S") は <prgn>init</prgn> がシングルユーザモードを呼び出す
ために渡されるパラメータです。
<p>
X の起動デーモンを全て無効にするためのいくつかの方法があります。
<list>
<item>run <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6</tt>
<item>insert "exit 0" at the start of all <file>/etc/init.d/<var>?</var>dm</file> files.
<item>全ての <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> ファイルを
<file>/etc/rc2.d/K99<var>?</var>dm</file> に改名する。
<item>全ての <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> を削除する。
<item><tt>/etc/X11/default-display-manager</tt> を起動する。
</list>
ここで、<file>rc<var>2</var>.d</file> の中の数字は <file>/etc/inittab</file>
で指定したランレベルと対応させなければなりません。また、
<file><var>?</var>dm</file> は全ての <prgn>xdm</prgn>, <prgn>gdm</prgn>, 
<prgn>kdm</prgn>, <prgn>wdm</prgn> を置き換えるために複数回コマンドを
実行する必要があることを意味します。
<p>
このリストの最初だけが &debian; での "真実の道" です。最後の方法は
簡単ですが、&debian; でしか動かず、<prgn>dpkg-reconfigure</prgn>
を使用した後は再度ディスプレイマネージャの設定を要求します。
残りは汎用のデーモンの無効化手段です。
<p>
コンソールシェルから <prgn>startx</prgn> コマンドを使って X をまだ起動
できます。
</sect1>

<sect1 id="bootprompt">ブートプロンプトを使った他のブートトリック
<p>
<prgn>lilo</prgn> のブートプロンプトを使ってシステムを特定のランレベル
と設定でブートすることができます。詳細は
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP) にあります。
<p>
システムをランレベル 4 でブートさせたい場合、<prgn>lilo</prgn> の
ブートプロンプトで次を入力してください。
<example>
boot: Linux 4
</example>
<p>
root パスワードを知っている状態でシステムを普通に動くシングルユーザモード
で起動したい場合、次の例のうち 1つを <prgn>lilo</prgn> のブートプロンプト
で実行してください。
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
システムを実際よりも少ないメモリ容量を用いてブートしたい場合 (例えば
64MB のシステムで 48MB を用いる場合)、<prgn>lilo</prgn> ブートプロンプト
で次を実行してください。
<example>
boot: Linux mem=48M
</example>
実際より多いメモリ容量をここで絶対指定しないでください。さもないと kernel
がクラッシュします。64MB より多い、例えば 128MB のメモリを持っている場合、
<tt>mem=128M</tt> をブートプロンプトで実行するか、同様の行を
<file>/etc/lilo.conf</file> に追加しないと、古い kernel や古い BIOS を
持つマザーボードは 64MB 以上のメモリを使用できません。
</sect1>

<sect1 id="bootgrub">GRUB ブートパラメータの設定
<p>
GRUB は GNU Hurd プロジェクト由来の新しいブートマネージャであり、
Lilo より柔軟性がありますが、ブートパラメータの取り扱い方が lilo
とはずいぶん異なります。
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
ここで、Hurd デバイス名に気づく必要があります。
<example>
the Hurd/GRUB       Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,1)             /dev/hda1           C: (通常)
 (hd0,4)             /dev/hda4           F: (通常)
 (hd1,4)             /dev/hdb4           ?
</example>
詳細は <file>&f-grub;</file> と <file>&f-grub-doc;</file> をご覧ください。
</sect>

<sect>行動を記録する

<sect1 id="script">シェルでの行動を記録する
<p>
システム管理者は Unix 環境において通常の PC 環境よりもより複雑な仕事
を行います。システムトラブルから回復する必要がある場合に備えて、
設定の最も基本的な意味を確実に知る必要があります。X11 ベースの GUI 
設定ツールは見栄えは良く便利ですが、たびたび緊急事態に対応できません。
<p>
このような観点で、シェルでの活動を記録することは、特に root に
とっては良い習慣です。
<p>
Emacs では、M-x <tt>shell</tt> を実行すると、バッファに記録を開始し、
C-x C-w を使うとバッファをファイルに書き出します。
<p>
Shell では、<ref id="screen"> に記述されているように、<prgn>screen</prgn> 
コマンドを "^A H" 付きで実行するか、<prgn>script</prgn> コマンドを
使ってください。
<example>
$ script
スクリプトを開始しました、ファイルは typescript です
 ... 何かを行う ...
 Ctrl-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
次は <prgn>script</prgn> の代わりに使えます。
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>X での行動を記録する
<p>
<prgn>xterm</prgn> の表示を含む X アプリケーションのグラフィックな画像を記録する
必要がある場合、<prgn>gimp</prgn> (GUI) を使いましょう。ウィンドウごとあるいは
スクリーン全体をキャプチャーできます。代替品には、<prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>), <prgn>scrot</prgn>
(<package>scrot</package>), があります。
</sect1>


</sect>

<sect id="archiving">サブディレクトリ全体のコピーとアーカイブ
<sect1>サブディレクトリ全体をコピーする基本的なコマンド
<p>
ファイル構成を再調整する必要がある場合、ファイルのリンクを含む内容を
次のように移動します。
<example>
標準的方法
# cp -a /source/directory /dest/directory # GNU cp が必要
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
ハードリンクを含む場合、衒学的な方法が必要となります。
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
リモートにコピーする。
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
リンクファイルが無い場合は次を実行する。
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
ここで、<prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> であり、
<prgn>ssh</prgn> &lt;==&gt; <prgn>rsh</prgn> です。
<p>
サブディレクトリ全体のコピーに関する次の比較情報は
Manoj Srivastava (<email>srivasta@debian.org</email>) により
debian-user@lists.debian.org で掲示されました。
</sect1>

<sect1><prgn>cp</prgn>
<p>
伝統的に、<prgn>cp</prgn> はシンボリックリンクを参照しませんし、ハードリンク
を保つので、本当はこの仕事に向いていません。もう 1つ考えるべきことは、
まばらなファイル (穴を持つファイル) です。
<p>
GNU <prgn>cp</prgn> はこれらの制限を越えています。しかしながら、非 GNU
システムでは、<prgn>cp</prgn> はまだこの問題を抱えています。また、
<prgn>cp</prgn> を用いて、小さく移植性の高いアーカイブを作成できません。
<example>
&percnt; cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
Tar は <prgn>cp</prgn> が持つシンボリックリンクの問題のいくつかを
解決していますが、<prgn>cpio</prgn> は特別なファイルを扱えるため、
伝統的な <prgn>tar</prgn> は使用されていません。
<p>                                                             
<prgn>tar</prgn> の複数のハードリンクの操作方法は、テープ上に 1つ
しかコピーを置かないことですが、コピーの名前はそのファイルを取得する
ために使用される <em>唯一の</em> 名前です。<prgn>cpio</prgn> の方法は
全リンクに対して 1つのコピーを置きますが、全リンクの名前を使ってファイル
を取得できます。
<p>
<prgn>tar</prgn> コマンドは <file>.bz2</file> ファイルに対するオプションが
Potato と Woody の間で変更されました。ですから、短縮形のオプションである 
<tt>-I</tt> (Potato) や <tt>-j</tt> (Woody) の代わりに、スクリプトでは 
<tt>--bzip2</tt> を使ってください。
</sect1>

<sect1><prgn>pax</prgn>
<p>
新しい POSIX (IEEE Std 1003.2-1992, pages 380&ndash;388 (section 4.48) と pages 936&ndash;940 (section E.4.48)) 互換の移植性のあるアーカイブ
交換ユーティリティです。<prgn>pax</prgn> はアーカイブファイルの読み書き、
内容のリスト表示が行え、ディレクトリ階層のコピーもできます。<prgn>pax</prgn>
の操作は特別なファイルフォーマットに依存せず、さまざまなアーカイブフォーマット
をサポートしています。
<p>
<prgn>pax</prgn> の実装はまだ新しく、未熟です。
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 又は
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn> は <prgn>cpio</prgn> 又は <prgn>tar</prgn>アーカイブへの
ファイルの操作ができます。アーカイブはディスク上の他のファイルにできますし、
磁気テープやパイプにもできます。
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> は <prgn>cpio</prgn> フォーマットアーカイブの操作を
行うより良い手段です。般に、<prgn>cpio</prgn> よりも高速で、データの
変造をいくらか上品な方法で扱います。マルチボリュームなアーカイブを
サポートし、さらに対話的な操作もサポートします。
<prgn>afio</prgn> は <prgn>tar</prgn> や <prgn>cpio</prgn> アーカイブ
を圧縮するよりもより安全な圧縮アーカイブを作成できます。<prgn>afio</prgn>
はバックアップスクリプト内で "アーカイブエンジン" として使うのにベストです。
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
私は磁気テープへのバックアップに <prgn>afio</prgn> を使っています。
</sect1>
</sect>

<sect id="diff-backup">差分バックアップとデータ同期
<p>
差分バックアップとデータ同期はいくつかの方法で実装できます。
<list>
<item><package>rcs</package>:  バックアップと履歴、テキストのみ
<item><package>rdiff-backup</package>:  バックアップと履歴、シンボリックリンクも可能
<item><package>pdumpfs</package>:  ファイルシステム内のバックアップと履歴。シンボリックリンクも可能
<item><package>rsync</package>:  片方向同期
<item><package>unison</package>:  双方向同期
<item><package>cvs</package>:  サーババックアップおよび履歴機能を持つ多方向同期。テキストのみだが熟成している。<ref id="cvs"> 参照
<item><package>arch</package>:  サーババックアップおよび履歴機能を持つ多方向同期、"作業ディレクトリ" のようなものでは無い。
<item><package>subversion</package>:  サーババックアップおよび履歴機能を持つ
多方向同期、Apache と連携。
</list>
<ref id="archiving"> に記述されているアーカイブ手法と <ref id="cronjob">
に記述されている規則的なジョブの自動化を組み合わせると、すばらしい
バックアップシステムとなります。
<p>
3つの使いやすいユーティリティについて説明します。

<sect1 id="rdiff-backup">rdiff を用いた差分バックアップ
<p>
<package>rdiff-backup</package> はあらゆるタイプのファイルに対して
差分バックアップによる素晴らしくシンプルなバックアップを提供します。
<file>~/</file> のほとんどを <file>/mnt/backup</file> にバックアップするには、
次を実行します。
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
このアーカイブから 3日前のデータを <file>~/old</file> に復旧するには、
次を実行します。
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
<manref name="rdiff-backup" section="1"> をご覧ください。

<sect1 id="pdumpfs-backup"><package>pdumpfs</package> による日々のバックアップ
<p>
<package>pdumpfs</package> は 毎日のスナップショットを保存する Plan9 の 
<prgn>dumpfs</prgn> と似たシンプルな日々のバックアップシステムです。
ある日のファイルを取得するために、あらゆる過去のスナップショットにアクセス
できます。ホームディレクトリを <prgn>pdumpfs</prgn> と <prgn>cron</prgn>
でバックアップしましょう!
<p>
<prgn>pdumpfs</prgn> は送り先ディレクトリに <tt>YYYY/MM/DD</tt> の形
でスナップショットを構築します。全ソースファイルは <prgn>pdumpfs</prgn>
が最初に起動された際にスナップショットディレクトリにコピーされます。
次回の起動からは、ディスクスペースの節約のため、<prgn>pdumpfs</prgn> 
は更新されたか、新たに作成されたファイルのみコピーし、未更新ファイルは
前日のスナップショットのファイルにハードリンクされます。
<example>
$ pdumpfs <var>src-dir</var> <var>dest-dir</var> [<var>dest-basename</var>]
</example>
<manref name="pdumpfs" section="8"> をご覧ください。
</sect1>

<sect1 id="backup">RCS による規則的な差分バックアップ
<p>
<package>Changetrack</package> はテキストベースの設定ファイルの変更点を RCS
アーカイブに定期的に記録します。
<manref name="changetrack" section="1"> をご覧ください。
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>システムフリーズからの回復
<sect1 id="kill">プロセスを殺す
<p>
<prgn>top</prgn> を起動し、どのプロセスの動きがおかしいかを調べます。
CPU 使用量でソートするためには `P' 、メモリ量でソートするには `M'、
プロセスを殺すには `k' を押します。又は、BSD スタイルの <tt>ps aux | less</tt>
や System-V スタイルの <tt>ps -efH | less</tt> も使えるかもしれません。
System-V スタイルの文法では親 ID (<tt>PPID</tt>) を表示するので、
ゾンビ (defunct) となった子プロセスを殺すのに使えます。
<p>
プロセス ID によりプロセスを殺す (又はシグナルを送る) には <prgn>kill</prgn>
を、プロセスのコマンド名により同様のことを行うには <prgn>killall</prgn>
を使います。良く使われるシグナルは次の通りです。
<example>
 1: HUP、デーモンを再起動
15: TERM、通常の kill
 9: KILL、激しく kill する
</example>

</sect1>

<sect1>Alt-SysRq
<p>
システム故障に対する緊急手段が kernel のコンパイルオプション "Magic SysRq key"
により供給されています。i386 で Alt-SysRq を押し、<tt>r 0 k
e i s u b</tt> キーのうち一つを続けて押してください。すると魔法が効果を発揮します。
<p>
Un`r'aw は X のクラッシュの後などにキーボードを回復します。端末の
ログレベルを `0' に減らすと、エラーメッセージが減少します。
sa`k' (sytem attention key) は現在の仮想端末上の全プロセスを殺します。
t`e'rminate は現在の端末上の  <prgn>init</prgn> 以外の全プロセスを殺します。
k`i'll は <prgn>init</prgn> 以外の全プロセスを殺します。
<p>
`S'ync、 `u'mount、そして  re`b'oot は本当にひどい状況から脱出するための
ものです。
<p>
Debian の標準でインストールされる kernel は本文書が書かれた現時点では
本オプション付でコンパイルされていません。kernel を再構築してこの機能を
有効にしてください。詳しい情報は 
<file>/usr/share/doc/kernel-doc-<var>version</var>/Documentation/sysrq.txt.gz</file> 又は
<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file> にあります。

</sect1>
</sect>


<sect id="nifty">覚えるべき小さくて洒落たコマンド

<sect1>Pager
<p>
<prgn>less</prgn> は標準的なページャ (ファイル内容のブラウザ) です。
ヘルプは `h' を押してください。<prgn>more</prgn> よりずっと多くのことが
できます。<prgn>less</prgn> は <tt>eval $(lesspipe)</tt> や
<tt>eval $(lessfile)</tt> をシェルの起動スクリプトで実行することにより
ブーストできます。詳細は <file>&f-lessopen;</file> をご覧ください。
<tt>-R</tt> オプションにより、文字をそのまま表示し、ANSI の
カラーエスケープシーケンスを有効にします。<manref name="less" section="1">
をご覧ください。
<p>
<prgn>w3m</prgn> もいくつかのエンコードシステム (EUC) では役に立つ
ページャの代替品かもしれません。

<sect1>フリーなメモリ
<p>
<prgn>free</prgn> と <prgn>top</prgn> はメモリリソースに関する良い情報を
提供します。"Mem:" 行にある "used" のサイズは心配しなくてもよいですが、
その下を読んでください。 (下の例の 38792)
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
物理メモリの正確な量は <tt>grep  '^Memory' /var/log/dmesg</tt> により
確認できます。この場合、
"Memory: 256984k/262144k available (1652k kernel code, 412k reserved, 
2944k data, 152k init)" のような出力となります。
<example>
合計         = 262144k = 256M (1k=1024, 1M=1024k)
dmesg でのフリーなメモリ量 = 256984k = Total - kernel - reserved - data - init
シェルでのフリーなメモリ量 = 257136k = Total - kernel - reserved - data
</example>
約 5MB は kernel が使用するため、システムにより使用不可にされています。
</sect1>

<sect1>時刻の設定 (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
これはシステム時刻とハードウェア時刻を MM/DD hh:mm, CCYY にセットします。
時刻はローカル時間で表示されますが、ハードウェア時間は UTC を用います。

<sect1>時刻の設定 (NTP)
<p>
<url id="&time-howto;" name="Managing Accurate Date and Time HOWTO"> を参照。
<p>
<sect2>インターネットへの常時接続により時刻を設定する
<p>
リモートのサーバ経由自動的にシステムのクロックを設定して時刻を修正します。
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
システムがインターネットに常時接続している場合、<file>/etc/cron.daily/</file> 
に書いておくのがよいでしょう。

<sect2>散発的なインターネット接続で時刻を設定する
<p>
<package>chrony</package> パッケージを使用してください。
</sect1>

<sect1 id="setterm">スクリーンセーバなどのコンソール機能の制御方法
<p>
スクリーンセーバを無効にするには、次のコマンドを使ってください。
<p>
Linux コンソール上では、次を実行します。
<example>
# setterm -powersave off
</example>
<p>
kon2 (kanji) コンソールのスクリーンセーバを起動します。
<example>
# kon -SaveTime 0
</example>
<p>
X 起動中には次を実行します。
<example>
# xset s off
 又は
# xset -dpms
 又は
# xscreensaver-command -prefs
</example>
他のコンソール機能を制御するには、対応するマニュアルを読んでください。
ターミナルの行設定を変更したり印刷するには、<manref name="stty" section="1">
も読んでください。
</sect1>

<sect1 id="getent">管理データベースの検索
<p>
Glibc は管理データベースからエントリ、すなわち、パスワード、グループ、
ホスト、サービス、プロトコル、ネットワークなどを検索するために、
<manref name="getent" section="1"> を提供しています。
<example compact>
getent database [key ...]
</example>

<sect1>サウンド (ビープ音) を無効にする
<p>
PC スピーカを常に抜いておくこともできます ;-) Bash シェルでは次を実行します。
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>コンソールのスクリーン上のエラーメッセージ
<p>
スクリーンに出るエラーメッセージを黙らせるには、まず
<file>/etc/init.d/klogd</file> をチェックします。このスクリプトに
<tt>KLOGD="-c <var>3</var>"</tt> をセットし、
<tt>/etc/init.d/klogd restart</tt> を起動します。
代わりに、<tt>dmesg -n<var>3</var></tt> を起動することもできます。
<p>
エラーレベルの意味を示します。
<list compact>
<item>0: KERN_EMERG,   システムが使用不可
<item>1: KERN_ALERT,   直ちに行動をとる必要がある
<item>2: KERN_CRIT,    致命的状況
<item>3: KERN_ERR,     エラー発生
<item>4: KERN_WARNING, 警告段階
<item>5: KERN_NOTICE,  通常状態だが深刻な状況
<item>6: KERN_INFO,    インフォメーション
<item>7: KERN_DEBUG,   デバッグレベルのメッセージ
</list>
<p>
特定の使えないエラーメッセージが煩わしい場合、<file>shutup-abit-bp6</file> 
のような些細な kernel patch を適用することを考慮に入れましょう。
(<url id="&examples;" name="examples subdirectory"> で入手可能)
<p>
他に見るべき箇所は、<file>/etc/syslog.conf</file> です。コンソールデバイス
にメッセージが出力されるようになっているかをチェックしましょう。
</sect1>

<sect1>正しいタイプに端末を設定する
<p>
Unix ライクシステムでの端末スクリーンは通常 (n)curses  ライブラリ
ルーチンを使ってアクセスされます。これらのライブラリはユーザに
適度な最適化による端末に依存しない文字端末の更新手段を与えます。
<manref name="ncurses" section="3X"> と <manref name="terminfo" section="5">
をご覧ください。
<p>
&debian; システムでは、前もって定義された多数のエントリがあります。
<example>
$ toe | less                  # 全エントリ
$ toe /etc/terminfo/ | less   # ユーザが再定義したエントリ
</example>
環境変数 <tt>TERM</tt> として選択したエントリをエクスポートします。
<p>
Debian でないホストから Debian システムにリモートでログインした時に、<prgn>xterm</prgn> 用の
端末エントリが Debian でない <prgn>xterm</prgn> では動かない場合、
端末のタイプを "xterm" から "xterm-r6" などの機能制限されたものに変更してください。
詳細は <file>&f-libncurse;</file> をご覧ください。"dumb"　は terminfo 用の最小の共通部分
です。 
</sect1>

<sect1>端末を正常な状態に戻す
<p>
<tt>cat <var>some-binary-file</var></tt> を実行してしまって端末が手を付けられなく
なってしまった時は、次を実行します。
(タイプしてもコマンドがエコーされて見えないかもしれません)
<example>
$ reset
</example>
</sect1>

<sect1>DOS から Unix スタイルにテキストファイルを変換する
<p>
(EOF = <tt>^M^J</tt> である) DOS テキストファイルを 
(EOF = <tt>^j</tt> である) Unix テキストファイルに変換します。
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1 id="perl-i">正規表現による置換
<p>
<var>FILES</var> ファイルの全てにある <var>FROM_REGEX</var> を <var>TO_TEXT</var>
に置き換えます。
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_TEXT</var>/g;' <var>FILES</var> ...
</example>
<tt>-i</tt> は "in-place editing"、<tt>-p</tt> は "implicit loop over
<var>FILES</var> ..."　のためのオプションです。
置換が複雑な場合、パラメータ <tt>i.bak</tt> を <tt>-i</tt> の代わりに
使うことで容易にエラーから回復できます。これは元のファイルをそれぞれ
<tt>.bak</tt> をファイルの拡張子として追加して保存しておきます。
</sect1>

<sect1>スクリプトを使ってその場でファイルを編集する
<p>
次のスクリプトはその場で 5&ndash;10 行と 16&ndash;20 行を削除します。
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
ここで、<prgn>ed</prgn> コマンドは <prgn>vi</prgn> コマンドモードコマンドと同じです。
スクリプトがファイルの後ろから編集するのを容易にします。
</sect1>

<sect1>ソースファイルから差分を取得しマージする
<p>
次に挙げる手順は 2つのソースファイルの差分を取り、ファイルの場所に応じて
統合された差分ファイルを <var>file.patch0</var> 又は <var>file.patch1</var>
という名前で作成します。
<example>
$ diff -u <var>file.old</var> <var>file.new1</var> &gt; <var>file.patch0</var>
$ diff -u <var>old/file</var> <var>new1/file</var> &gt; <var>file.patch1</var>
</example>
差分ファイル (パッチファイルとも呼ばれる) はプログラムの更新箇所を送るために
使われます。差分ファイルを受け取ったパーティはこの更新を他の <var>file</var>
に次のように適用します。
<example>
$ patch -p0 <var>file</var> &lt; <var>file.patch0</var>
$ patch -p1 <var>file</var> &lt; <var>file.patch1</var>
</example>
3つの異なるバージョンのソースコードを持っている場合は、<prgn>diff3</prgn>
を使ってより効率的にこれらをマージできます。
<example>
$ diff3 -m <var>file.mine</var> <var>file.old</var> <var>file.yours</var> &gt; <var>file</var>
</example>
</sect1>

<sect1>大きなファイルを複数の小さなファイルに変換する
<p>
<example>
$ split -b 650m <var>file</var>   # ファイルを 650MB 毎に分割
$ cat x* &gt;<var>largefile</var>    # 一つの大きなファイルにマージ
</example>
</sect1>

<sect1>テキストファイルテーブルからデータを取り出す
<p>
全ての元 &debian; リーダの名前と就任日がスペースで分割されたフォーマットで
リストされている <file>DPL</file> と呼ばれるファイルを考えてみましょう。
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   January 1998
Wichert Akkerman  January 1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr March   2003
</example>
これらのタイプのファイルからデータを取り出すには、Awk が良く使われます。
<example>
$ awk '{ print $3 }' &lt;DPL                   # 開始月
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' &lt;DPL          # Ian と呼ばれる DPL のリスト
Ian     Murdock   August  1993
Ian     Jackson   January 1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # Perens 就任時
April 1996
</example>
<p>
Bash などのシェルもこれらのファイルを解釈するのに使えます。
<example>
$ while read first last month year; do 
    echo $month
  done &lt;DPL
... 最初の Awk の例と同じ出力
</example>
ここで、<prgn>read</prgn> 組込みコマンドは $IFS( 内部フィールドセパレータ) 
を用いて行を単語単位で分割します。
<p>
IFS を ":" に変更すると、<file>/etc/passwd</file> をシェルでうまくパーズ
できます。
<example>
$ oldIFS="$IFS"   # 旧値を保存
$ IFS=":"
$ while read user password uid gid rest_of_line; do
    if [ "$user" = "osamu" ]; then 
      echo "$user's ID is $uid"
    fi
  done < /etc/passwd
osamu's ID is 1001
$ IFS="$oldIFS"   # 旧値に戻す
</example>
(同じことを Awk を使って行うには、<tt>FS=":"</tt> を用いてフィールド
セパレータをセットします。)
<p> 
IFS はパラメータ拡張、コマンド置換、算術拡張の結果を分割するためにも
シェルにより使われます。これらはダブルクォートやシングルクォートされた
単語内では発生しません。IFS の標準値は &lt;space&gt;, &lt;tab&gt;, と
&lt;newline&gt; の組合せです。
<p>
シェルの IFS トリックを注意深く使ってください。
シェルがスクリプトの一部を <strong>入力</strong> として解釈した場合、
奇妙なことが起きるかもしれません。
<example>
$ IFS=":,"                        # ":" と ","  を IFS として使う
$ echo IFS=$IFS,   IFS="$IFS"     # echo は Bash 組込みコマンド
IFS=  , IFS=:,
$ date -R                         # 単なるコマンド出力
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # サブシェルの出力をメインシェルに入力
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # IFS を標準にリセット
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>
</sect1>


<sect1 id="scrp-snip">コマンドをパイプするためのわずかなスクリプト
<p>
次のスクリプトはパイプの一部として素晴らしいことをします。
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # いくつかのファイルを除き /usr にある全ファイルを見つける
xargs -n 1 <var>command</var>   # 標準入力からの全てのアイテムに対してコマンドを実行
xargs -n 1 echo |    # スペース区切りのアイテムを行単位で分割する
xargs echo      |    # 全ての行を 1行にマージする
grep -e <var>pattern</var>|     # <var>pattern</var>を含む行を取り出す
cut -d: -f3 -|
        # : で区切られた 3番目のフィールドを取り出す (passwd ファイルなど)
awk '{ print $3 }' | # スペースで区切られた3番目のフィールドを取り出す
awk -F'\t' '{ print $3 }' |
        # タブで区切られた 3番目のフィールドを取り出す
col -bx |            # バックスペースを削除し、タブをスベースに変換する
expand -|            # タブをスペースに変換する
sort -u|             # 入力をソートし重複箇所を削除する
tr '\n' ' '|         # 複数の行を 1行に繋げる
tr '\r' ''|          # キャリッジリターンを削除
tr 'A-Z' 'a-z'|      # 大文字を小文字に変換する
sed 's/^/# /'|       # 各行をコメントアウトする
sed 's/\<var>.ext</var>//g'|    # <var>.ext</var> を削除する
sed  -n -e 2p|       # 2番目の行を表示
head -n 2 -|         # 最初の 2行を表示
tail -n 2 -|         # 最後の 2行を表示
</example>
</sect1>

<sect1>ファイルごとにループするためのわずかなスクリプト
<p>
次の方法は各ファイルについて <tt>*.<var>ext</var></tt> とのマッチングを行います。スペースを持つファイル名などを適切に扱うことを保証し、どの方法も同じように処置します。
<list>
<item>シェルループ (これは <tt>PS2="&gt; "></tt> を用いた複数行の入力です)
<footnote>
この行を 1行でタイプする場合、いくつかのセミコロンを追加し、シェルコマンドの最後に
"<tt>;</tt>" でマークする必要があります。
</footnote>
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>command</var> "$<var>x</var>"
  fi
done
</example>
<item><prgn>find</prgn> と <prgn>xargs</prgn> の組合せ:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>command</var>
</example>
<item><prgn>find</prgn> の <tt>-exec</tt> オプションによりコマンドを使った場合:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>command</var> '{}' \;
</example>
<item><prgn>find</prgn> の <tt>-exec</tt> オプションにより短いシェルスクリプトを使う場合:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>command</var> '{}' && echo 'successful'" \;
</example>
</list>
</sect1>

<sect1 id="perl-mad">Perl ショートスクリプトの狂気
<p>
Awk スクリプトは <manref name="a2p" section="1"> を用いれば自動的に
Perl で書き直せますが、ワンライン Awk スクリプトは手動でワンラインPerl スクリプト
に完璧に変換できます。例えば、
<example>
awk '($2=="1957") { print $3 }' |
</example>
は次の行のどれとも同じです。
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
上の行の <prgn>perl</prgn> への引数の全てのスペースはすべて削除できますし、
Perl における番号と文字列の間の自動変換の利点を利用しています。
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
コマンドラインオプションについては <manref name="perlrun" section="1">
をご覧ください。より狂った Perl スクリプトについては、<url id="&perlgolf;">
が興味深いかもしれません。
</sect1>

<sect1>web ページからテキストやメーリングリストのアーカイブを取得する
<p>
次のコマンドは web ページを読み込んでテキストファイルに整形します。
Web から設定をコピーするときに非常に役立ちます。
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>textfile</var>
</example>
ここで <prgn>links</prgn> と <prgn>w3m</prgn> も使えますが、描画に少し
違いがあります。
<p>
これがメーリングリストのアーカイブの場合、mime contents からテキストにするには
<prgn>munpack</prgn> を使います。
</sect1>

<sect1>web ページをきれいに印刷する
<p>
次のコマンドは web ページを PostScript ファイルに変換して印刷します。
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
<ref id="lprlpd"> をご覧ください。また、PostScript ファイルを作成するには
<prgn>a2ps</prgn> および <prgn>mpage</prgn> パッケージをチェック
してみてください。
</sect1>

<sect1>マニュアルページをきれいに印刷する
<p>
次のコマンドはマニュアルページを PostScript に変換して印刷します。
<example>
$ man -Tps <var>some-manpage</var> | lpr
$ man -Tps <var>some-manpage</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>2つの PostScript や PDF ファイルをマージする
<p>
2つの PostScript や PDF ファイルをマージできます。
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>
 
<sect1>コマンドの実行時間を計測する
<p>
プロセスにより使用された時間を表示します。
<example>
# time <var>some-command</var> &gt;/dev/null
real    0m0.035s       # 壁掛け時計の時間 (真の経過時間)
user    0m0.000s       # ユーザモードでの時間
sys     0m0.020s       # kernel モードでの時間
</example>
</sect1>

<sect1><prgn>nice</prgn> コマンド
<p>
起動時にコマンドの nice 値をセットするには、<prgn>nice</prgn> 
(GNU の <package>shellutils</package> パッケージに収録) を使ってください。
<prgn>renice</prgn> (<package>bsdutils</package>) や <prgn>top</prgn> も
プロセスを renice できます。nice 値が 19 の場合はプロセスは最低速度
(最低の優先度) なプロセスです。負の nice 値は "not-nice" であり、
-20 では最速 (最高の優先度) なプロセスです。スーパーユーザだけが
負の nice 値をセットできます。
<example>
# nice  -19 <var>top</var>                                         # 非常に nice
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # 非常に高速
</example>
極端な nice 値はシステムに悪影響を及ぼすことが時々あります。注意して
このコマンドを使ってください。
</sect1>

<sect1 id="cronjob">タスクのスケジューリング 
(<prgn>cron</prgn>、<prgn>at</prgn>)
<p>
Linux で仕事をスケジューリングするには、<prgn>cron</prgn> や <prgn>at</prgn>
を使いましょう。<manref name="at" section="1">、
<manref name="crontab" section="5">、<manref name="crontab" section="8">
をご覧ください。
<p> 
定期的にスケジューリングするイベントを設定するには、<tt>crontab -e</tt> 
コマンドを起動して crontab ファイルを作成したり編集します。
crontab ファイルの例:
<example>
# (/etc/passwd の指定に関らず) コマンド実行に /bin/sh を使用する。
SHELL=/bin/sh
# (この crontab の所有者に関らず) あらゆる出力を `paul' にメールする。
MAILTO=paul
# 分 時 月内日 月 曜日 コマンド (Day... are OR'ed)
# 毎日、日付変更の 5分後に実行する
5 0 * * *       $HOME/bin/daily.job >> $HOME/tmp/out 2>&1
# 毎月初日の 2:15pm に実行する -- 出力は paul にメールされる
15 14 1 * *     $HOME/bin/monthly
# 平日の午後 10時に実行してジョーを心配させる
0 22 * * 1-5 mail -s "午後 10時だ" joe%ジョー、%%お前の子どもはどこだい?%
23 0-23/2 * * * echo "毎日 0, 2, 4..時 23 分に実行する"
5 4 * * sun     echo "日曜 4時 5分に実行する"
# 毎月第一日曜日の午前 3時 40分に実行する
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
一度きりの仕事をスケジューリングするには、<prgn>at</prgn> コマンドを起動します。
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen"><prgn>screen</prgn> を使って端末を切替える
<p>
<prgn>screen</prgn> プログラムにより、単独の実際の端末又は
端末エミュレータウィンドウ上で複数の仮想端末を起動させ、
それぞれの端末で固有のの対話型シェルを持たせることが可能となります。
Linux の仮想端末や複数の <prgn>xterm</prgn> ウィンドウを使っている場合でさえも、
次に示す <prgn>screen</prgn> の豊富な機能セットを探検する価値はあります。
<list compact>
<item>スクロールバック履歴
<item>コピー & ペースト
<item>出力のロギング
<item>digraph エントリ
<item>端末から <prgn>screen</prgn> セッション全体を <strong>切り離し</strong>、
後で再び取り付ける能力。
</list>

<sect2>遠隔アクセスのシナリオ
<p>
リモートターミナルからや VT100 ターミナルプログラムを使って Linux マシンに
よくログインする場合、<prgn>screen</prgn>を使うと <strong>detach (切り離し)
</strong> 機能により生活がより簡単になります。
<p>
<enumlist compact>
<item>ダイアルアップ接続経由でログインし、いくつかのウィンドウでエディタや
他のプログラムを開いて複数の <prgn>screen</prgn> を起動します。
<item>突然端末を離れることが必要になりましたが、ハングアップすることにより
今までやった仕事を失いたくありません。
<item><tt>^A d</tt> をタイプしてセッションを <strong>デタッチ</strong> 
してログアウトします (又は、より素早くやるには、<tt>^A DD</tt>
をタイプして <prgn>screen</prgn> をデタッチして screen 自身をログアウト
します。)
<item>再びログインする時に、<tt>screen -r</tt> コマンドを入力すると、
<prgn>screen</prgn> は魔法のように前に開いていたウィンドウ全てを
<strong>リアタッチ</strong> します。
</enumlist>

<sect2>典型的な <prgn>screen</prgn> コマンド
<p>
いったん <prgn>screen</prgn> を始めると、標準では <tt>^A</tt> である
コマンドキーストロークを除く全てのキーボード入力が現在のウィンドウに
送られます。全ての <prgn>screen</prgn> コマンドは <tt>^A</tt> に加えて
さらに一つのキー [に加えてパラメータ] をタイプすることにより入力されます。
役立つコマンドを挙げます。
<example>
^A ?     ヘルプスクリーンを表示 (キーバインドダイアログ)
^A c     新規ウィンドウを作成してそこに切替える
^A n     次のウィンドウに移動
^A p     前のウィンドウに移動
^A <var>0</var>     ウィンドウナンバー <var>0</var> に移動
^A w     ウィンドウリストを表示
^A a     カレントウィンドウにキーボード入力として Ctrl-A を送信
^A h     カレントウィンドウのハードコピーをファイルに書き出す
^A H     カレントウィンドウのファイルへのログ記録を開始/終了
^A ^X    端末をロック (パスワードによる保護)
^A d     ターミナルからスクリーンセッションをデタッチする
^A DD    スクリーンセッションをデタッチしてログアウトする
</example>
これは <prgn>screen</prgn> コマンドと機能の小さなサブセットに過ぎません。
<prgn>screen</prgn> にやらせたいことが何かあるなら、たぶんできるでしょう。
詳細は <manref name="screen" section="1"> をご覧ください。

<sect2><prgn>screen</prgn> セッションでのバックスペースと Ctrl-H
<p>
<prgn>screen</prgn> を起動中にバックスペースや Ctrl-H が動かないことに
気づいた場合、 <file>/etc/screenrc</file> を編集し、次の行を見つけたら
コメントアウトしてください。(すなわち、この行の先頭に "#" を追加してください)
<example compact>
bindkey -k kb stuff "\177"
</example>

<sect2>X 用の <prgn>screem</prgn> と等価なプログラム
<p>
<prgn>xmove</prgn> を調べてください。<manref name="xmove" section="1"> 
をご覧ください。

</sect1>

<sect1 id="net-test">ネットワークテストの基礎
<p>
<package>netkit-ping</package>,
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (2.2 kernel 用),
<package>iptables</package> (2.4 kernel用), そして
<package>net-tools</package> パッケージをインストールして次を実行します。
<example>
$ ping <var>yahoo.com</var>            # インターネット接続をチェック
$ traceroute <var>yahoo.com</var>      # IP パケットを追跡
$ ifconfig                  # ホストの設定をチェック
$ route -n                  # ルーティング設定をチェック
$ dig <var>[@dns-server.com] host.dom [{mx|any}]</var> |less
      # <var>dns-server.com</var> による <var>{mx|any}</var> レコード
      # に対する <var>host.dom</var> DNS レコードをチェックする
$ ipchains  -L -n |less     # パケットフィルタをチェック (2.2 kernel 用)
$ iptables -L -n |less      # パケットフィルタをチェック (2.4 kernel 用)
$ netstat -a                # 開いているポート全てを見つける
$ netstat -l --inet         # 接続待ちなポートを見つける
$ netstat -ln --tcp         # 接続待ちな TCP ポート番号を見つける 
</example>
</sect1>

<sect1 id="flush-mail">ローカルのスプールからメールをフラッシュする
<p>
ローカルスプールからメールをフラッシュするには、次を実行します。
<example>
# exim -q    # 送信待ちメールをフラッシュする
# exim -qf   # 全メールをフラッシュする
# exim -qff  # frozen したメールもフラッシュする
</example>
<tt>-qff</tt> オプションを <file>/etc/ppp/ip-up.d/exim</file> スクリプト
にオプションとして入れるのが良いかもしれません。
Sarge では、<prgn>exim</prgn> は <prgn>exim4</prgn> に置き換わっています。
</sect1>

<sect1 id="remove-mail">frozen したメールをローカルスプールから削除する
<p>
ローカルスプールから frozen したメールを配送エラーメッセージを付けて削除
するには、次を実行します。
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
Sarge では、<prgn>exim</prgn> は <prgn>exim4</prgn> に置き換わっています。
</sect1>

<sect1><file>mbox</file> の内容を再配送する
<p>
ホームディレクトリが満杯になり、<prgn>procmail</prgn> が失敗する場合、
<file>/var/mail/<var>username</var></file> からホームディレクトリにある
ソートされたメールボックスにメールを手動で送信する必要があります。
ホームディレクトリにディスクスペースを確保してから、次を実行します。
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>username</var>
# /etc/init.d/exim start
</example>
Sarge では、<prgn>exim</prgn> が <prgn>exim4</prgn> に置き換わっています。
</sect1>

<sect1>ファイルの内容をクリアする
<p>
ログファイルなどのファイルの内容をクリアにするには、<tt>rm</tt> を使って
ファイルを削除してから新しい空のファイルを作成しないでください。
ファイルは削除して作成する間にまだアクセスされるかもしれないからです。
次の方法はファイルの内容をクリアにします。
<example>
$ :&gt;<var>file-to-be-cleared</var>
</example>
</sect1>

<sect1 id="dummyfile">ダミーファイル
<p>
次のコマンドはダミー又は空のファイルを作成します。
<example>
$ dd if=/dev/zero    of=<var>filename</var> bs=1k count=5 # 5KB の空の内容
$ dd if=/dev/urandom of=<var>filename</var> bs=1m count=7 # 7MB のランダムな内容
$ touch <var>filename</var> # 0B ファイルを作成 (既にある場合、mtime を更新)
</example>
例えば、最も実用的な使いかたとして、&debian; のブートフロッピから
実行される次のコマンドはハードディスク <file>/dev/hda</file> の内容を
完全に削除します。
<example>
# dd if=/dev/urandom of=/dev/hda ; dd if=/dev/zero of=/dev/hda
</example>

</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
<prgn>chroot</prgn> プログラム (<manref name="chroot" section="8">) は
リブートせずに単独のシステムで同時に異なる GNU/Linux 環境を起動することを
可能にします。
<p>
また、低速なサテライトマシンを NFS マウントし、そこをより高速なマシンが 
chroot ポイントとして <prgn>apt-get</prgn> や <prgn>dselect</prgn> のような
リソース食いなプログラムを実行することもできます。

<sect2 id="chroot-debian"><prgn>chroot</prgn> を使って異なる &debian;
ディストリビューションを起動する
<p>
Woody にある <prgn>debootstrap</prgn> コマンドを使うと、chroot した 
&debian; 環境を容易に構築できます。例えば、高速なインターネットアクセス環境
を持っているならば、<var>/sid-root</var> に Sid の chroot を作成するには、
次を実行します。
<example>
main # cd / ; mkdir <var>/sid-root</var>
main # debootstrap sid <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... システム全体がダウンロードされるのを監視する
main # echo "proc-sid <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount proc-sid <var>/sid-root</var>/proc -t proc
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # apt-setup # set-up /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # source を unstable が指すように編集
chroot # dselect  # aptitude を使って、mc や vim をインストールしてもよい :)
</example>
<p>
この時点で完全に機能する &debian; システムを持っているはずです。
ここではメインの &debian; 環境に影響を与える恐れなく動きまわれます。
<p>
この <prgn>debootstrap</prgn> のトリックは &debian; ではなく他の GNU/Linux
ディストリビューションのインストールディスクを使って &debian; をインストール
するのにも使えます。

<sect2 id="chroot-console"><prgn>chroot</prgn> 用のログイン設定
<p>
<tt>chroot <var>/sid-root</var> /bin/bash</tt> をタイプするのは簡単ですが、
意図せずに環境変数を全て引き継いでしまったりします。chroot に直接るグイン
できる別の仮想端末で他のログインプロセスを起動するのがよりよい方法です。
<p>
標準の &debian; システムでは、<tt>tty1</tt> から <tt>tty6</tt> は
Linux 端末を起動し、<tt>tty7</tt> は X Window を起動します。例えば
<tt>tty8</tt> を chroot 化された端末に設定しましょう。
<ref id="chroot-debian"> に記述したように chroot システムを作成した後、
メインシステムの root シェルから次をタイプします。
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8"  >> /etc/inittab
main # init q    # init のリロード
</example>

<sect2 id="chroot-x"><prgn>chroot</prgn> 用の X 設定
<p>
chroot で最新の X や GNOME を安全に起動したいですか? これは可能です。
次の例は仮想端末 <tt>vt9</tt> で GDM を起動させます。
<p>
まず <ref id="chroot-debian"> に記述している方法を用いて chroot システム
をインストールします。メインシステムの root から chroot システムに
主要な設定ファイルをコピーします。
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # 又は chroot の端末を使う
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # [servers] セクションの vt7 を vt9 に書き換える
chroot # /etc/init.d/gdm start
</example>
ここで、<file>/etc/gdm/gdm.conf</file> は最初の仮想端末を <tt>vt7</tt> から
<tt>vt9</tt> に変更しました。
<p>
今 chroot での完全な X 環境とメインシステムの間を Linux 仮想端末
を切替えること、例えば Ctrl-Alt-F7 や Ctrl-Alt-F9 を使うことにより
簡単に切替えることができます。お楽しみに!
<p>
[FIXME] Add a comment and link to the init script of the chrooted <prgn>gdm</prgn>.

<sect2 id="chroot-dist"><prgn>chroot</prgn> を使って他のディストリビューション
を起動する
<p>
他の Linux ディストリビューションのための chroot 環境も簡単に作れます。
他のディストリビューションのインストーラを使って別のパーティションにシステム
をインストールします。その root パーティションが 
<file><var>/dev/hda9</var></file> とすると、次のようになります。
<example>
main # cd / ; mkdir <var>/other-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/other-dist</var>
main # chroot <var>/other-dist</var> /bin/bash
</example>
そして <ref id="chroot-debian">, <ref id="chroot-console">, や
<ref id="chroot-x"> にある手順を進めます。

<sect2 id="chroot-build"><prgn>chroot</prgn> によりパッケージを作成する
<p>
より特化した chroot パッケージである <package>pbuilder</package> は
chroot システムを構築し、chroot 内でパッケージを作成します。
パッケージの build-dependencies が正しいかどうかをチェックしたり、
不必要で間違った構築依存性がパッケージに存在しないかを確認するための
理想的なシステムです。

</sect1>

<sect1>ハードリンクのチェック方法
<p>
2つのファイルがハードリンクを使った同じファイルかどうかチェックするには次を
実行します。
<example> 
$ ls -li <var>file1</var> <var>file2</var>
</example>
 
<sect1>ハードディスクイメージファイルを <prgn>mount</prgn> する
<p>
<file><var>file.img</var></file> がハードディスクの内容のイメージを含んでおり、
オリジナルのハードディスクのディスク設定が 
<var>xxxx</var> = (bytes/sector) * (sectors/cylinder) であった場合、
次のコマンドはこのイメージを <file>/mnt</file> にマウントします。
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
ほとんどのハードディスクは一セクタあたり 512 バイトであることに
注意してください。

<sect1 id="smbmount">Samba
<p>
Windows からファイルを取得する基本的な方法は次の通りです。
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # Windows ファイルを Linux にマウント
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # コンピュータ上の共有のリスト
</example>
<p>
Linux から Samba の隣人は次のようにチェックできます。
<example>
# smbclient -N -L <var>ip_address_of_your_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>他の OS のファイルシステムを扱うためのユーティリティ
<p>
他の OS のファイルシステムの多くを Linux kernel はサポートしており、
単にマウントすることによりファイルシステムを含むデバイスにアクセスできます。
特定のファイルシステムのために、デバイスをマウントせずにファイルシステムに
アクセスするための専用のツールが存在します。これは kernel のファイルシステム
のサポートを必要としないようにユーザスペースのプログラムとして実装されて
います。
<list compact>
<item><package>mtools</package>: MSDOS ファイルシステム(MS-DOS, Windows) 用
<item><package>cpmtools</package>: CP-M ファイルシステム用
<item><package>hfsutils</package>: HFS ファイルシステム (昔の Macintosh) 用
<item><package>hfsplus</package>: HFS+ ファイルシステム (最近の Macintosh) 用
</list>
MS-DOS FAT ファイルシステムの作成やチェックを行うには、
<package>dosfstools</package> が役立ちます。
</sect1>

</sect>

<sect id="oops">注意すべき典型的な間違い
<p>
ここに危険な行動の例をいくつか挙げます。特権アカウント <tt>root</tt> を使う
場合、副作用はさらに増大します。

<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>
<!--
ここでコメントを使うのはイレギュラーですが、これ無しでは読みずらい。 
-->
"<tt>rm -rf .*</tt>" において、 "<tt>.*</tt>" は "<tt>.</tt>" と
"<tt>..</tt>" に拡張され、親ディレクトリに書き込む権限がたまたまあった場合、
カレントディレクトリの <strong>隣の</strong> 全てのディレクトリも削除されて
しまいます。
<p>
<list compact>
<item>"<tt>rm -rf .</tt>" : カレントディレクトリにあるもの全てとカレント
ディレクトリ自身を削除
<item>"<tt>rm -rf *</tt>" : カレントディレクトリにある全ての非ドットファイルと
非ドットディレクトリを削除
<item>"<tt>rm -rf .[^.]*</tt>" : カレントディレクトリにある全てのドットファイルと
ドットディレクトリを削除
<item>"<tt>rm -rf .*</tt>" : 親ディレクトリにある全てと親ディレクトリ自身を削除
</list>

<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
&debian; システムは <file>/etc/passwd</file> のような重要なファイルを
間違いにより失うことに対して丈夫です。&debian; システムはこれらを 
<file>/var/backups/</file> に定期的にバックアップします。
これらのファイルを回復させたら、適切な権限を手動でセットしましょう。
<example>
# cp /var/backups/passwd /etc/passwd
# chmod 644 /etc/passwd
</example>
<ref id="recover-status"> をご覧ください。

</chapt>