<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.22"  -->

<chapt id="gnupg">GnuPG

<p>
参考文献をいくつか挙げます。
<list compact>
<item><manref name="gpg" section="1"> 
<item><file>&dochome;gnupg/README.gz</file>
<item><file>&dochome;gnupg-doc/GNU_Privacy_Handbook/</file> にある
  <em>GNU privacy handbook</em>
 (<package>gnupg-doc</package> パッケージをインストールする)
</list>

<sect>GnuPG のインストール
<p>
<example>
# gpg --gen-key                   # 新しい鍵を生成
# gpg --gen-revoke <var>my_user_ID</var>     # <var>my_user_ID</var> 用の失効鍵を生成
# host -l pgp.net | grep www|less # pgp キーサーバを知る
</example>
<file>$HOME/.gnupg/gpg.conf</file> (又は旧バージョンでは 
<file>$HOME/.gnupg/options</file> に) 設定すべき良質の標準キーサーバには
次が含まれます。
<example>
keyserver hkp://subkeys.pgp.net
</example>
ここで 二つ以上のサブ鍵を生成<strong>しない</strong> ように注意する必要が
あります。そうしてしまった場合、pgp.net にあるキーサーバはあなたの鍵を
<strong>壊す</strong> 可能性があります。これらの壊れたサブ鍵を扱うには、
新しい <package>gnupg</package> (1.2.1-2 以降) を使ってください。
<url id="&gpg-subkeys;"> をごらんください。
<p>

</sect>

<sect>GnuPG を使う
<p>
ファイルの操作方法を次に挙げます。
<example>
$ gpg  [options]  <var>command  [args]</var>
$ gpg {--armor|-a} {--sign|-s} <var>file</var> # ファイルに署名してテキストファイル <var>file</var>.asc に置く
$ gpg --clearsign <var>file</var>              # メッセージを clearsign で署名する
$ gpg --clearsign --not-dash-escaped <var>patchfile</var>  # パッチファイルを
clearsign で署名する
$ gpg --verify <var>file</var>                 # clearsign された <var>file</var> を検証する
$ gpg -o <var>file.sig</var> {-b|--detach-sig} <var>file</var> # 単独の署名を作成
$ gpg --verify <var>file.sig</var> <var>file</var>        # <var>file.sig</var> を用いて <var>file</var> を検証する
$ gpg -o <var>crypt_file</var> {--recipient|-r} <var>name</var> {--encrypt|-e} <var>file</var> 
        # 名前を対象とした公開鍵の暗号化
$ gpg -o <var>crypt_file</var> {--symmetric|-c} <var>file</var> # 対称暗号化
$ gpg -o <var>file</var> --decrypt crypt_file  # 復号化
</example>
</sect>

<sect>GnuPG の管理
<p>
GnuPG の主な管理手順をいくつか挙げます。
<example>
$ gpg --edit-key <var>user_ID</var>               # 対話的なヘルプ
$ gpg -o <var>file</var> --exports                # 全ての鍵を <var>file</var> にエクスポート
$ gpg --imports <var>file</var>                   # 全ての鍵を <var>file</var> からインポート
$ gpg --send-keys <var>user_ID</var>              # <var>user_ID</var> の鍵をキーサーバに送信
$ gpg --recv-keys <var>user_ID</var>              # キーサーバから <var>user_ID</var> の鍵を取得
$ gpg --list-keys <var>user_ID</var>              # <var>user_ID</var> の鍵をリスト
$ gpg --list-sigs <var>user_ID</var>              # <var>user_ID</var> の署名をリスト
$ gpg --check-sigs <var>user_ID</var>             # <var>user_ID</var> の署名をチェック
$ gpg --fingerprint <var>user_ID</var>            # <var>user_ID</var> のフィンガープリントをチェック
$ gpg --list-sigs | grep '^sig' | grep '[User id not found]' \
  | awk '{print $2}' | sort -u | xargs gpg --recv-keys # 未知の鍵を取得
  # 全ての未知の署名に対する鍵を更新
$ gpg --refresh-keys                              # ローカルの keyring を更新
</example>
コードの信頼度の指針を示します。
<example>
-         ownertrust が割り当てられていない/まだ計算されていない
e         信頼度の計算に失敗。
q         評価のための情報が足りない。
n         この鍵を信頼できない。
m         ある程度信頼できる。
f         完全に信頼できる。
u         究極的に信頼できる。
</example>
次の手順により、評判の良いキーサーバである  <tt>hkp://subkeys.pgp.net</tt>
に自分の鍵 "<var>A8061F32</var>" をアップロードできます。
<example>
$ gpg --keyserver hkp://subkeys.pgp.net --send-keys <var>A8061F32</var>
</example>
</sect>

<sect>アプリケーションで GnuPG を使う
<p>
<sect1>Mutt で GnuPG を使う
<p>
次の内容を <file>~/.muttrc</file> に追加すれば、処理の重い GnuPG を自動で
起動せずに、index メニューで `<tt>S</tt>' をタイプすると GnuPG が呼び出される
ようになります。

<example>
macro index S ":toggle pgp_verify_sig\n"
set pgp_verify_sig=no
</example>

<sect1 id="vimgpg">Vim で GnuPG を使う
<p>
GnuPG を自動的に起動するために、<url id="&examples;" name="examples subdirectory"> から得られる <file>_vimrc</file> の内容を <file>~/.vimrc</file>に追加してください。

</chapt>
