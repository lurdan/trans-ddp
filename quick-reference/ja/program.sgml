<!-- CVS revision of this document "$Revision: 1.6 $"  -->
<!-- CVS revision of original english document "1.74"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->
<!-- DON'T TOUCH GROFF SECTION!!! -->


<chapt id="program">プログラミング
<p>
実行用テストファイルの名前として "test" を使うのは止めましょう。
<prgn>test</prgn> というコマンドがシェル組込みコマンドにあります。

<sect>始め方
<p>
参考文献をいくつか挙げます。
<list compact>
<item><file>&dochome;<var>package</var></file> にある文書とサンプル。
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
多量の info 文書が書籍として <url id="&gnuhome;" name="GNU"> 
から得られます。
<p>
次の 4 サブセクションには、<prgn>newusers</prgn> プログラムのような
バッチプロセッサを用いて <file>/etc/passwd</file> にアカウント情報を
追加するための数種類の言語によるサンプルスクリプトが含まれます。スクリプトは
<tt>first_name last_name password</tt> の形式の数行の入力ファイルを必要と
します。(実際ユーザのホームディレクトリはこれらのスクリプトによって
作成されません。)

</sect>

<sect id="shell">シェル
<p>
Unix ライクなシステムの働きを理解する <strong>最良の</strong>方法は、
シェルスクリプトを読むことです。ここで、シェルプログラムに関する
いくつかのポイントと注意を与えます。間違いから学ぶには、
<url id="&shell-mistakes;" name="Shell Mistakes"> を読んでください。

<sect1 id="bash">Bash &ndash; <strong>GNU</strong> 標準の対話シェル
<p>
Bash の参考文献をいくつか挙げます。
<list compact>
<item> 学び始めの際の情報としては、これらが良いでしょう
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>LDP <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (サンプルファイルを見るには、<package>bash-doc</package> をインストール
 してください。)
<item><em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
</list>
<p>
次に短いプログラム例を示します。(標準入力から <prgn>newusers</prgn> 用の
アカウントエントリを作成)
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">POSIX シェル
<p>
&debian; では、数種類のパッケージが POSIX シェルを供給します。
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 176
  <item>最小で最軽量。最初のブート時に最適。
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 180
  <item>小さく軽量。最初のブート時に適している。
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essential: yes
  <item>Priority: required
  <item>Installed-Size: 580
  <item>大きく多機能。多くの拡張が実装されている。
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 408
  <item>完全な AT&amp;T ksh 互換
 </list>
</list>
<p>
移植性を考慮してシェルスクリプトを作成している場合、POSIX シェルスクリプト
としてスクリプトを書くのが最良です。シェルスクリプトの POSIX 互換性を
テストするには、<prgn>ash</prgn> (又は <prgn>dash</prgn>) にリンクされた 
<file>/bin/sh</file> を使用してください。"bashism" 又は "zshism" を用いた
スクリプトを作るのは避けましょう。
例えば、次のような表現は避けましょう。
<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>file</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>
<p>
本文書におけるシェルの記述方法は POSIX タイプのシェルのみを用いており、
それゆえ、<prgn>tcsh</prgn> を含む <prgn>csh</prgn> タイプのシェルは
使用していません。

<sect1 id="shell-param">シェルパラメータ
<p>
いくつかの<strong>特別なパラメータ</strong>を覚える必要があります。
<example compact>
$0      = シェル又はシェルスクリプトの名前
$1      = シェルの第 1 引数
 ...
$9      = シェルの第 9 引数
$#      = ポジショナルパラメータの数
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = 最後のコマンドの 終了ステータス
$$      = シェルスクリプトの PID 
$!      = 最後に起動されたバックグラウンドジョブの PID
</example>
<>
基本的な <strong>パラメータ拡張</strong> を覚える必要があります:
<example compact>
    形式         <var>var</var> がセット      <var>var</var> がセットされていない
${<var>var</var>:-<var>string</var>}  $<var>var</var>                <var>string</var>
${<var>var</var>:+<var>string</var>}  <var>string</var>              null
${<var>var</var>:=<var>string</var>}  $<var>var</var>                <var>string</var> 
                                    (そして <var>var</var>=<var>string</var> を起動)
${<var>var</var>:?<var>string</var>}  $<var>var</var>                (echo <var>string</var> して終了する)
</example>
ここで、これらの演算子全てにおいて、コロン  `:' は実際は無くても構いません。
<list compact>
<item>`:' があると演算子は "exist" と "not null" をテストします。
<item>`:' が無いと演算子は "exist" のみテストします。
</list>
<p>
覚えておくべき基本的な <strong>パラメータ置換</strong> には次があります。
<example compact>
    形式        結果
${<var>var</var>&percnt;<var>suffix</var>}   最小の<var>suffix</var> パターンを削除
${<var>var</var>&percnt;&percnt;<var>suffix</var>}  最大の <var>suffix</var> パターンを削除
${<var>var</var>#<var>prefix</var>}   最小の <var>prefix</var> パターンを削除
${<var>var</var>##<var>prefix</var>}  最大の <var>prefix</var> パターンを削除
</example>

<sect1 id="shell-redirect">シェルリダイレクト
<p>
覚えておくべき基本的な <strong>リダイレクト</strong> を次に挙げます。
(ここで [<var>n</var>] はファイルディスクリプタを指定するための任意の
番号)
<example compact>
[<var>n</var>]&gt; <var>file</var>      stdout (又は<var>n</var>) を <var>file</var> にリダイレクト。
[<var>n</var>]&gt;&gt; <var>file</var>     stdout (又は<var>n</var>) を <var>file</var> に追加
[<var>n</var>]&lt; <var>file</var>      <var>file</var> から stdin (又は<var>n</var>) にリダイレクト
[<var>n1</var>]&gt;&amp;<var>n2</var>       stdout (又は <var>n1</var>) を <var>n2</var> にリダイレクト
2&gt; <var>file</var>  &gt;&2   stdout と stderr を <var>file</var> にリダイレクト
 &gt; <var>file</var> 2&gt;&1   stdout と stderr を <var>file</var> にリダイレクト
| <var>command</var>      stdout を <var>command</var> にパイプする
2&gt;&1 | <var>command</var> stderr と stdout を <var>command</var> にパイプする
</example>
ここで、
<list compact>
<item>stdin: 標準入力 (ファイルディスクリプタ = 0)
<item>stdout: 標準出力 (ファイルディスクリプタ = 1)
<item>stderr: 標準エラー出力 (ファイルディスクリプタ = 2)
</list>
です。
<p>
シェルは任意のファイルディスクリプタにより <prgn>exec</prgn> 組込み
コマンドを用いてファイルを開くことができます。
<example>
$ echo Hello &gt;foo
$ exec 3&lt;foo 4&gt;bar  # ファイルを開く
$ cat &lt;&amp;3 &gt;&amp;4       # 標準入力を 3, 標準出力を 4 にリダイレクト
$ exec 3&lt;&amp;- 4&gt;&amp;-    # ファイルを閉じる
$ cat bar
Hello
</example>
ここで <var>n</var><tt>&lt;&amp;-</tt> と <var>n</var><tt>&gt;&amp;-</tt>
はファイルディスクリプタ <var>n</var> を閉じることを意味します。

<sect1 id="shell-cond">シェルの条件文
<p>
コマンドは条件文の表現に使われる <strong>終了ステータス</strong> を返します。
<list compact>
<item>成功: 0 (真)
<item>エラー: 1&ndash;255 (偽)
</list>
ここでは 0 の値を "真" の意味で使っていますが、
これは他の計算分野で使われている慣習とは異なることに注意してください。
又、`[' は <prgn>test</prgn> コマンドと等価であり、
条件文表現として `]' まで引数を評価します。
<p>
覚えておくべき基本的な <strong>条件イディオム</strong> を次に挙げます。
<example compact>
<var>command</var> && <var>if_success_run_this_command_too</var> || true
<var>command</var> || <var>if_not_success_run_this_command_instead</var>

if [ <var>conditional_expression</var> ]; then  
 <var>if_success_run_this_command</var>
else
 <var>if_not_success_run_this_command</var>
fi
</example>
ここで <tt>||</tt> は、シェルが <tt>-e</tt> フラグを呼び出した時に
このシェルスクリプトが誤ってこの行で終了しないことを保証するために必要でした。
<p>
条件文表現内での <strong>ファイル</strong> 比較演算を次に挙げます。
<example compact>
-e <var>file</var>         <var>file</var> が存在する場合に真
-d <var>file</var>         <var>file</var> というディレクトリが存在する場合に真
-f <var>file</var>         <var>file</var> という普通のファイルが存在する場合に真
-w <var>file</var>         <var>file</var> が存在し、書き込み可である場合に真
-x <var>file</var>         <var>file</var> が存在し実行可能出ある場合に真
<var>file1</var> -nt <var>file2</var> <var>file1</var> が <var>file2</var>より (更新時間が)新しい場合に真
<var>file1</var> -ot <var>file2</var> <var>file1</var> が <var>file2</var> よりも (更新時間が) 古い場合に真
<var>file1</var> -ef <var>file2</var> 両者が同じデバイスであり、同じ inode 番号を持つ場合に真
</example>
<p>
条件文表現内での <strong>文字列</strong> 比較演算を次に挙げます。
<example compact>
     -z <var>str</var>    <var>str</var> の長さが 0 の場合に真
     -n <var>str</var>    <var>str</var> の長さが 0 ではない場合に真
<var>str1</var> == <var>str2</var>   二つの文字列が等しい場合に真
<var>str1</var> =  <var>str2</var>   二つの文字列が等しい場合に真
    ("=" は厳密な POSIX 互換なシェルの場合、 "==" の代わりに使用するべき)
<var>str1</var> != <var>str2</var>   二つの文字列が等しくない場合に真
<var>str1</var> &lt;  <var>str2</var>   <var>str1</var> が50音順で <var>str2</var> の前に来る場合に真 (ロケール依存)
<var>str1</var> &gt;  <var>str2</var>    <var>str1</var> が50音順で <var>str2</var> の後に来る場合に真 (ロケール依存)
</example>
<p>
条件文表現内での <strong>算術</strong> 整数比較演算には、
<tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>, <tt>-le</tt>, <tt>-gt</tt>
そして <tt>-ge</tt> があります。
</sect1>

<sect1 id="clprocess">コマンドライン処理
<p>
シェルは次のようにスクリプトを処理します。
<list compact>
<item> スペース,タブ,改行, ;, (, ), &lt;, &gt;, |, &amp; などのメタ文字により <strong>トークン</strong> に分割する。
<item>"..." や '...' 内では無い場合、<strong>keyword</strong> をチェックする。(ループ)
<item>"..." や '...' 内では無い場合、<strong>alias</strong> を展開する。(ループ)
<item>"..." や '...' 内では無い場合、<strong>brace</strong> を展開する (例: <tt>a{1,2}</tt> -> <tt>a1 a2</tt> )
<item>"..." や '...' 内では無い場合、<strong>チルダ</strong> を展開する (例:
 ~<var>user</var> -> <var>user</var> のホームディレクトリ) 
<item>'...' 内で無い場合、<strong>parameter</strong> を  $<var>PARAMETER</var>
に展開する。
<item>'...' 内で無い場合、<strong>コマンド置換</strong> を $(<var>command</var>)に展開する。
<item>"..." や '...' 内では無い場合、$IFS により <strong>単語</strong> に分割する。
<item>"..." や '...' 内では無い場合、<strong>pathname</strong> 内の
*?[] を展開する。
<item><strong>command</strong> を捜す。
<list compact>
<item>関数
<item>組込み
<item>$PATH 内のファイル
</list>
<item>ループ
</list>
<p>
"" 内の '' には何も効果はありません。
<p>
シェル内で <tt>set -x</tt> を実行するか、<tt>-x</tt> オプション付きで
シェルを起動すると、シェルにコマンドの実行結果を全て表示させます。
これはデバッグにはとても便利です。
</sect1>

</sect>

<sect id="awk">Awk
<p>
Awk の参考文献をいくつか挙げます。
<list compact>
<item><em>Effective awk Programming</em>, 3rd edition (O'Reilly)
<item><em>Sed &amp; awk</em>, 2nd edition (O'Reilly)
<item><manref name="mawk" section="1"> and <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
(<prgn>newusers</prgn> のコマンドエントリを作成する) 短いプログラム例
を示します。
<example>
#!/usr/bin/awk -f
# Script to create a file suitable for use in the 'newusers' command,
# from a file consisting of user IDs and passwords in the form:
# first_name last_name password
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
          "  where:\n" \ 
          "    startUID is the starting userid to add, and\n" \
          "    file is an input file in form:\n" \
          "      first_name last_name password\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Starting UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
&debian; では、POSIX 互換の <package>awk</package> を供給するパッケージ
が二種類あります。
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priority: required
  <item>Installed-Size: 228
  <item>小さく高速 &ndash; 標準のインストールには良い
  <item>コンパイル時の制限が存在する
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 1708
  <item>大きく機能が豊富 &ndash; 多くの拡張を実装
  <list compact>
   <item>UNIX System V Release 4 版
   <item>Bell 研究所版 awk
   <item>GNU 独自の拡張
  </list>
 </list>
</list>
</sect>

<sect id="perl">Perl
<p>
これは Unix ライクシステムの <strong>インタプリタ</strong> です。
<p>
Perl の参考文献をいくつか挙げます。
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3rd edition (O'Reilly)
</list>
<p>
(<prgn>newusers</prgn> のコマンドエントリを作成する) 短いプログラム例
を示します。
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Perl モジュール <var>module_name</var> は次のようにインストールします。
<example>
# perl -MCPAN -e 'install <var>module_name</var>'
</example>
 
</sect>

<sect id="python">Python
<p>
すばらしいオブジェクト指向なインタプリタです。
<p>
Python の参考文献をいくつか挙げます。
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
<item><url id="&pythonhome;" name="Python Programming Language">
</list>
<p>
(<prgn>newusers</prgn> のコマンドエントリを作成する) 短いプログラム例
を示します。
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input filename. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirst_name last_name password\n"
                return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crashes with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect id="make">Make
<p>
Make の参考文献をいくつか挙げます。
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2nd edition (O'Reilly)
</list>
<p>
シンプルな自動変数。
<p>
ルールシンタックスを示します。
<example>
<var>target</var>: [ <var>prerequisites</var> ... ]
 [TAB]  <var>command1</var>
 [TAB]  -<var>command2</var> # エラーを無視
 [TAB]  @<var>command3</var> # suppress echoing
</example>
ここで <tt>[TAB]</tt> はタブの文字コードです。
各行は <prgn>make</prgn> 変数置換を行った後にシェルにより解釈されます。
2行以上にわたってスクリプトを続けるには、行の末尾に <tt>\</tt> を
書いてください。シェルスクリプトでの環境変数のため <tt>$</tt> を入力
するには、<tt>$$</tt> を使用してください。
<p>
<var>ターゲット</var> と <var>前提</var> のための
<strong>暗黙のルール</strong> は、例えば次のように書けます。
<example>
&percnt;: &percnt;.c header.h
</example>
又は
<example>
&percnt;.o: &percnt;.c header.h
</example>
ここで、<var>ターゲット</var> には <tt>&percnt;</tt> 
(正確のはこれらのうちの一つ)
が含まれます。<tt>&percnt;</tt> は実際のターゲットのファイル名にある
空でないあらゆる文字列にマッチします。<var>前提</var> は
同様に実際のターゲット名に関連する名前がどのようなものかを示すために
<tt>&percnt;</tt> を使います。
<p>
<strong>サフィックスルール</strong> は <prgn>make</prgn> のために厳密なルール
を定義するためには <strong>時代遅れ</strong> です。互換性のために、
GNU <prgn>make</prgn> ではまだサポートされていますが、可能な限り
次のような等価なパターンルールを使用しましょう。
<example>
古いサフィックスルール   --&gt; 新しいパターンルール
.c:             --&gt; &percnt;  : &percnt;.c
.c.o:           --&gt; &percnt;.o: &percnt;.c
</example>
ルールのための自動変数。
<example>
foo.o: new1.c new2.c old1.c new3.c
$@ == foo.o                         (ターゲット)
$< == new1.c                        (最初の依存関係)
$? == new1.c new2.c new3.c          (新しい依存関係)
$^ == new1.c new2.c old1.c new3.c   (全ての依存関係)
$* == `&percnt;' はターゲットパターンにマッチした語幹です。
</example>
変数のリファレンス。
<example>
foo1 := bar    # 一回だけの展開
foo2  = bar    # 再帰展開
foo3 += bar    # 追加
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # "directory" を展開
 $(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
自動の内部ルールを見るには、<tt>make -p -f/dev/null</tt> を
起動してください。
</sect>

<sect id="c">C
<p>
次をインストールして C を使う準備をしましょう。
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
C の参考文献をいくつか挙げます。
<list compact>
<item><tt>info libc</tt> (C ライブラリ関数のリファレンス)
<item><manref name="gcc" section="1">
<item><manref name="each_C_library_function_name" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 
 2nd edition (Prentice Hall).
</list>
<p>

<sect1>シンプルな C プログラム (<prgn>gcc</prgn>)
<p>
<file>example.c</file> を <file>libm</file> ライブラリを用いて
コンパイルして <prgn>run_example</prgn> 実行ファイルを作成するための
シンプルな例です。
<example>
$ cat &gt; example.c &lt;&lt; EOF
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* prevent buffer overflow */
        y[10] = '\0'; /* fill to make sure string ends with '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
        1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
        2, 3.082, ./run_exam, 1234567890qwerty
</example>
ここで、<prgn>sqrt()</prgn> を使うためにライブラリ 
<file>lib<strong>m</strong></file> をリンクするには 
<tt>-l<strong>m</strong></tt> が必要です。実際のライブラリは
<file>/lib/</file> に <file>libm.so.6</file> という名前で存在し、
これは <file>libm-2.1.3.so</file> のシンボリックリンクです。
<p>
出力テキストの最後のパラメータを見てください。<tt>&percnt;10s</tt>
が指定されているにも係わらず10以上の文字があります。
<p>
境界チェックを行わずに <prgn>sprintf</prgn> や <prgn>strcpy</prgn> のような
ポインタを用いるメモリ操作関数を使うのは上記のオーバーラン効果を利用する
バッファオーバーフロー攻撃を防ぐために時代遅れになっています。
その代わりに、<prgn>snprintf</prgn> や <prgn>strncpy</prgn> をご利用下さい。
</sect1>

<sect1>デバッグ

<sect2><prgn>gdb</prgn> を用いたデバッグ
<p>
準備
<example>
# apt-get install gdb
</example>
<p>
<prgn>gdb</prgn> の参考文献をいくつか挙げます。
<list compact>
<item><tt>info gdb</tt> (チュートリアル)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>
<p>
<tt>-g</tt> オプション付きでコンパイルされたプログラムをデバッグするには
<prgn>gdb</prgn> を使用します。多くのコマンドには省略形が存在します。
タブ拡張もシェルと同様に扱えます。
<example>
$ gdb program
(gdb) b 1                # ブレークポイントを一行目に設定
(gdb) run <var>arg1 arg2 arg3</var> # プログラムを起動
(gdb) next               # 次の行
...
(gdb) step               # 前に進む
...
(gdb) p parm             # parm の内容を表示
...
(gdb) p parm=12          # 値を 12 に設定
</example>
<p>
Emacs からデバッグするには、<ref id="editkey"> をごらんください。
<p>
インストールされる全てのバイナリは &debian; システムでは標準で stripped される
べきですので、ほとんどのデバッグシンボルは削除されています。&debian;
パッケージのデバッグに役立つように <prgn>gdb</prgn> を利用するには、
次の方法で該当するパッケージを再構築する必要があります。
<list compact>
<item>パッケージの <url id="&policy-version;" name="version"> を上げるために
<file>debian/control</file> を編集。
<item>バイナリのコンパイルのために <tt>CFLAGS=-g -Wall</tt> を使うように
ビルドスクリプトをチェック。
<item>&debian; パッケージの構築のために <tt>DEB_BUILD_OPTIONS=nostrip,noopt</tt>をエクスポートする。
</list>
詳細は <url name="Policy 10.1" id="&strip-symbols;"> をごらんください。
</sect2>

<sect2 id="ss-ldd">ライブラリの依存性をチェック
<p>
プログラムがどのライブラリに依存しているかを調べるには、
<prgn>ldd</prgn> を使用します。
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
<prgn>ls</prgn> を <prgn>chroot</prgn> された環境で動かすには、
上記に示したライブラリを <prgn>chroot</prgn> された環境に置く
必要があります。
<p>
次に挙げるコマンドも役立ちます。
<list compact>
<item><prgn>strace</prgn>: システムコールとシグナルを追跡
<item><prgn>ltrace</prgn>: ライブラリコールを追跡
</list>
</sect2>
 
<sect2>メモリリーク検知ツールを用いたデバッグ
<p>
数種類のメモリリーク検知ツールを &debian; で使用できます。
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (パッケージ化されていないが、
 <url id="&memwatch-home;" name="memwatch"> から取得可能です。)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><url id="&parasofthome;" name="Parasoft"> による <tt>Insure++</tt>
  (non-free, 商用では有償)
</list>
<p>
又 <url id="&mallocdebughome;" 
  name="Debugging Tools for Dynamic Storage Allocation and Memory Management">.
も調べてみてください。
<sect1>Flex &ndash; Lex の改良版
<p>
<prgn>flex</prgn> は高速な字句解析器生成器です。
<p>
<prgn>flex</prgn> の参考文献をいくつか挙げます。
<list compact>
<item><tt>info flex</tt> (チュートリアル)
<item><manref name="flex" section="1">
</list>
<p>
ライブラリ無しでコンパイルできるように、次のように見える <prgn>main()</prgn>
と <prgn>yywrap()</prgn> 又は  <file>program.l</file> を供給する必要が
あります。(<prgn>yywrap</prgn> はマクロです。 <tt>&percnt;option main</tt> 
は暗黙に <tt>&percnt;option noyywrap</tt> になります)
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
その代わりに、<prgn>cc</prgn> コマンドラインの最後に
(AT&amp;T-Lex の <tt>-ll</tt> のように) <tt>-lfl</tt> リンカオプション
を付けてコンパイルできます。この場合、 <tt>&percnt;option</tt>
は必要ありません。
</sect1>

<sect1>Bison &ndash; Yacc の改良版
<p>
&debian; では Yacc 互換な LALR パーサジェネレータパッケージが
いくつか供給されています。
<p>
<list compact>
 <item><package>bison</package>: GNU LALR パーサジェネレータ
 <item><package>byacc</package>: バークレー LALR パーサジェネレータ
 <item><package>btyacc</package>: <package>byacc</package> に基づく
 バックトラッキングパーサジェネレータ
</list>
<p>
<prgn>bison</prgn> の参考文献をいくつか挙げます。
<list compact>
<item><tt>info bison</tt> (チュートリアル)
<item><manref name="bison" section="1">
</list>
<p>
<prgn>main()</prgn> と <prgn>yyerror()</prgn> を供給する必要があります。
<prgn>main()</prgn> は <prgn>yyparse()</prgn> を呼び出し、これは
<prgn>yyparse()</prgn> を呼び出します。さらにこれは
通常 FleX により生成される <prgn>yylex()</prgn> を呼び出します。
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> は GNU ビルドシステム全体を使用する
多種の UNIX ライクなシステムに適合するようにソフトウェアのソースコード
パッケージを自動で設定するシェルスクリプトを生成するための
ツールです。
<p>
<prgn>autoconf</prgn> は <prgn>configure</prgn> と呼ばれる
設定スクリプトを生成します。<prgn>configure</prgn> は
<file>Makefile.in</file> テンプレートを用いて自動的に
カスタマイズされた <file>Makefile</file> を生成します。
 
<sect2>プログラムのコンパイルとインストール
<p>
&debian; は<file>/usr/local/</file> 以下にあるファイルに触りません。
(<ref id="diverse"> 参照) 
ですから、ソースからプログラムをコンパイルして
<file>/usr/local/</file> 下に置いても &debian; とは干渉しません。
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # システム上にファイルをインストールする
</example>

<sect2>プログラムのアンインストール
<p>
プログラムを削除したいが、ソースをまだ持っており、<prgn>autoconf</prgn>
や <prgn>automake</prgn> を使っていてコンパイル時の設定を覚えていたならば、
次の手順でアンインストールができます。
<example>
$ ./configure <var>all-of-the-options-you-gave-it</var>
# make uninstall
</example>
<p>
代わりに、インストール手順で <file>/usr/local/</file> の下にしか
ファイルを置いておらず、重要なものは何もないことを絶対確信している
なら、全ての内容を次のように削除できます。
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
どこにファイルをインストールしか確信できない場合、アンインストールのための
クリーンな道筋を供給してくれる <package>checkinstall</package> の使用を
考えるべきです。
</sect1>

</sect>

<sect id="cgi">Web
<p>
基本的なインタラクティブで動的な web ページは
以下の手順で作られます。
<list compact>
<item>HTMLフォームを用いてブラウザユーザに質問が提示されます。。
<item>フォームに書き込みクリックすることで、エンコードされたパラメータを
組み込んだ URL をブラウザから web サーバに送信します。。
<footnote>
ここで 16進数で <tt>nn</tt> に対応する文字
をエンコードするのには、 <tt>%nn</tt> を用います。
</footnote>
例えば、
<list compact>
<item><tt>http://www.foo.dom/cgi-bin/program.pl?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.foo.dom/cgi-bin/program.py?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.foo.dom/program.php?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
</list>
<item> web サーバ 上の CGI プログラム (<prgn>program.*</prgn> 
のいずれか) はデコードされたパラメータ
"<tt>VAR1=VAL1 VAR2=VAL2 VAR3=VAL3</tt>" を
環境変数 "<tt>QUERY_STRING</tt>" の値として受け取り、実行します。
<item>のCGI プログラムの <tt>stdout</tt> は web ブラウザに
送られ、インタラクティブで動的な web ページとして提示されます。
</list>
安全上、勝手に作ったいい加減なプログラムで CGI パラメータを読むのは
賢明でないとされています。Perl (<ref id="perl"> 参照) や 
Python (<ref id="python"> 参照) の確立したモジュールが有ります。
<url id="&phphome;" name="PHP"> は このような機能を自身で持っています。
クライアントサイドでデータ保持が必要な場合はクッキーが用いられます。
クライアントサイドでデータ処理が必要な場合は javascript がよく用いられます。
<p>
詳細は<url id="http://hoohoo.ncsa.uiuc.edu/cgi/" name="The Common
Gateway Interface"> と <url id="&apachehome;" name="The Apache Software
Foundation"> と <url id="&javascripthome;" name="JavaScript">
を参照下さい。
<p>
Google で "CGI tutorial" を探すのに <tt>&google-eg;</tt> 
というエンコードされた URL を直接ブラウザのアドレスに打ち込むことは、
 CGI スクリプトの Google サーバ上での動きを知るための良い方法です。
<!--
http://www.google.com/search?hl=en&ie=UTF-8&q=CGI+tutorial
http://stein.cshl.org/WWW/CGI/
http://stein.cshl.org/WWW/docs/handout.html
http://stein.cshl.org/WWW/software/mailmerge/
-->

<sect id="doc-prep">ドキュメントの準備
<p>

<sect1 id="roff"><tt>roff</tt> 植字
<p>
伝統的に、<tt>roff</tt> は主要な Unix テキスト処理システムです。
<p>
<manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7"> そして
<tt>info groff</tt> をご覧下さい。
<p>
<prgn>-me</prgn> マクロに良質のチュートリアルが存在します。
<package>groff</package> (1.18以後) をインストールしている場合、
<file>&f-meintro;</file> を見付けて次を実行してください。
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
次の手順は完全なプレインテキストファイルを作成します。
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
印刷するには、PostScript 出力を使いましょう。
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>




<sect1 id="sgml">SGML
<p>
次のパッケージをインストールして SGML を使う準備を行います。
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
<package>debiandoc-sgml</package> の参考文献をいくつか挙げます。
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em><url name="DocBook: The Definitive Guide"
      id="&f-docbook-defguide;"></em>, by Walsh and Muellner (O'Reilly)
      (package <package>&p-docbook-defguide;</package>)
</list>
<p>
SGML により複数の文書フォーマットの管理を行えます。簡単な SGML システムの一つ
が Debiandoc であり、本文書でも用いられています。Debiandoc は
オリジナルのテキストファイルから次の文字について些細な変換が必要です。
<!-- nbsp bug in PDF ? -->
<list compact>
<item>"&lt;" --&gt; <tt>&amp;lt;</tt>
<item>"&gt;" --&gt; <tt>&amp;gt;</tt>
<item>"&nbsp;" --&gt; <tt>&amp;nbsp;</tt>  (半角スペース)
<item>"&amp;" --&gt; <tt>&amp;amp;</tt>
<item>"&percnt;" --&gt; <tt>&amp;percnt;</tt>
<item>"(c)" --&gt; <tt>&amp;copy;</tt>
<item>"&ndash;" --&gt; <tt>&amp;ndash;</tt>
<item>"&mdash;" --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
セクションを印刷不可能なコメントとしてマークするには、次に示すような
内容を挿入します。
<example>
&lt;!-- State issue here ... --&gt;
</example>
セクションを変換可能なコメントとしてマークするには、次に示すような内容を
挿入します。
<example>
&lt;![ &percnt;FIXME; [ State issue here ... ]]&gt;
</example>
SGML では、エンティティの <em>最初の定義</em> が優先されます。例えば、
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
では、"Data 1" になります。最初の行が "INCLUDE" ではなく "IGNORE" を
含んでいる場合は、"Data 2" となります。(二行目は条件文) 
又、フレーズの繰り返しは内容からあらかじめ分けて定義できます。
<example>
&lt;!entity <var>whoisthis</var> "my"&gt;
Hello &amp;<var>whoisthis</var>; friend.
This is &amp;<var>whoisthis</var>; book.
</example>
これは次のような結果となります。
<example>
Hello my friend.
This is my book.
</example>
<url id="&examples;" name="examples"> にある短い SGML のサンプルの
<file>sample.sgml</file> をご覧下さい。
<p>
SGML 文書が巨大になった場合、バックエンドテキストプロセッサとして
使われる TeX が時々エラーを起こす場合があります。<ref id="texlatex">
をごらんください。

<!-- XXX FIXME XXX: Add XML section-->

<sect1 id="texlatex">TeX/LaTeX
<p>
準備:
<example>
# tasksel # その他 --&gt; TeX/LaTeX 環境 を選択して
TeX/LaTeX をインストールしましょう。
</example>
LaTeX の参考文献をいくつか示します。
<list compact>
<item><url id="&tetex-howto;" name="The teTeX HOWTO: The Linux-teTeX Local Guide">
<item><manref name="tex" section="1">
<item><manref name="latex" section="1">
<item><em>The TeXbook</em>, by Donald E. Knuth, (Addison-Wesley)
      <footnote>
        この本に収納されている TeX のソースは
        <url id="&texbooksource;"> で取得可能です。
        <url id="&texbookmacros;"> には必要なマクロのほとんどが
        含まれています。この文書の 7 から 10 行目をコメントアウトし、
        <tt>\input manmac \proofmodefalse</tt> を追加した後に   
        文書を <prgn>tex</prgn> で処理できます。
        <p>
        オンライン版を使わずにこの本 (と Donald E. Knuth による他の全ての本)
        を購入するのを強くお薦めします。しかしソースは TeX 入力の
        素晴らしい例です!。
      </footnote>
<item><em>LaTeX - A Document Preparation System</em>, by Leslie Lamport,
      (Addison-Wesley)
<item><em>The LaTeX Companion</em>, by Goossens, Mittelbach, Samarin,
      (Addison-Wesley)
</list>
<p>
TeX は最強の植字環境です。多くの SGML プロセッサは TeX をバックエンド
テキストプロセッサとして使っています。<package>lyx</package>,
<package>lyx-xforms</package> 又は <package>lyx-qt</package> 
により供給される Lyx や、
<package>texmacs</package> により供給される GNU TeXmacs
は見栄えの良い LaTeX 用のWYSIWYG 編集環境を提供しますが、
多くの人はソースの編集のためには Emacs や Vim を選択しています。
<p>
多くのオンラインのリソースが得られます。
<list compact>
<item><url id="&f-tetex-doc;" name="teTeX - A Documentation Guide">
      (<package>&p-tetex-doc;</package> パッケージ)
<!-- translators please add the following documents: 
1) "The Not So Short Introduction to LaTeX2e"
(&f-tetex-doc; links to an English copy on harddisk (slightly outdated))
There exist many translations (and MUCH more documents in ../):
ftp://ftp.dante.de/tex-archive/info/lshort/
2) ftp://ftp.dante.de/tex-archive/info/<your-language>

PS: I (Jens) don't like the following references (too short, external)
-->
<item><url id="&pfaffbenhome;" name="A Quick Introduction to LaTeX">
<item><url id="&latexlyx;" name="A Simple Guide to Latex/Lyx">
<item><url id="&latexbasic;" name="Word Processing Using LaTeX">
<item><url id="&local-guide;" name="Local User Guide to teTeX/LaTeX">
</list>
文書が巨大になった場合、TeX はエラーを起こす場合がときどきあります。
この問題を修正するには、<file>/etc/texmf/texmf.cnf</file> の pool サイズ
を増大させる
(又は <file>/etc/texmf/texmf.d/95NonPath</file> を適切に編集して
<prgn>update-texmf</prgn> を起動する) 必要があります。


<sect1 id="literate">Literate Programming
<p>
文書を含むコードを書く代わりに、文芸的プログラマはコードを含む文書
を書くものです。この手法はプログラムのための良い文書を保証します。
<p>
文芸的プログラムについては、
<url id="&literatehome;" name="Literate Programming"> をごらんください。

<sect2 id="noweb">Noweb
<p>
準備
<example>
# apt-get install nowebm
</example>
Noweb の参考文献をいくつか挙げます。
<list compact>
<item><url id="&nowebhome;" name="Noweb --- A Simple, Extensible Tool for Literate Programming">
<item><manref name="noweb" section="1">
</list>
<p>
これは WEB ライクな文芸的プログラムツールであり、よりシンプルですが
拡張性と言語との独立性を供給します。
<footnote>
WB は World Wide Web とは <strong>何も</strong> 関連はありません。
(PASCAL 用の) WEB と (C/C++ 用の) CWEB は伝統的な文芸的プログラム
ツールです。
</footnote>
<prgn>noweb</prgn> が起動されると、プログラムのソースコードを
noweb ファイルで言及されている出力ファイルに書き出し、文書の植字のために
TeX ファイルを出力します。
<p>
&debian; の <package>ifupdown</package> パッケージが良い例です。
<example>
$ apt-get source ifupdown
$ cd ifupdown*
$ make ifupdown.pdf ifupdown.ps
</example>

<sect2 id="doxygen">Doxygen
<p>
準備
<example>
# apt-get install doxygen doxygen-doc doxygen-gui
</example>
Doxygen (created by <prgn>doxygen</prgn>!) の参考文献をいくつか挙げます。
<list compact>
<item><url id="&doxygenhome;" name="Homepage">
<item><url id="/usr/share/doc/doxygen-doc/html/index.html">
</list>
<p>
C++, C, Java, IDL, さらにある程度は PHP と C#も含めて プログラムに関する
HTML, RTF, Unix マニュアルページ, PostScript そして PDF (LaTeX を用いて)
文書を生成できます。Doxygen は JavaDoc (1.1), Qt-Doc, KDOC と互換性があり、
Troll Tech の <url id="&qthome;" name="Qt"> ツールキットを利用する
プロジェクトが用いるために特別に設計されていました。
Doxygen はドキュメント化されていないプログラムであっても、依存グラフ、
協同ダイアログ、そしてグラフィカルなクラス階層グラフを含む内容を生成します。
この出力は Qt のドキュメントに似ています。

<sect id="packaging">パッケージング
<p>
準備
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
                  &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # if Potato
</example>
パッケージのための参考文献をいくつか挙げます。
<list compact>
 <item><ref id="pkg-basics"> (基礎)
 <item>Debian New Maintainers' Guide (チュートリアル)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (最良の練習)
 <item>Debian Policy Manual (信頼されている)
 <item>Packaging Manual (Potato 用) 
</list>

<sect1 id="pack-binary">単独のバイナリをパッケージングする
<p>
Joey Hess による単独のバイナリをパッケージングするためのクイックハックな
方法です。
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mypackage
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: my little package
 Don't expect much.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">ツールを用いたパッケージング
<p>
<package>dh-make</package> パッケージにある <prgn>dh_make</prgn> を使って
パッケージのベースラインを作成します。そして、
<manref name="dh-make" section="1"> にある指示に従って処理します。
これは <prgn>debian/rules</prgn> 内で <prgn>debhelper</prgn> を利用します。
<p>
古いアプローチでは <package>debmake</package> にある <prgn>deb-make</prgn> 
を使います。この方法は <prgn>debhelper</prgn> を利用せず、シェルのみに
依存します。<package>debmake</package> は使わないようにしましょう。
<p>
複数のソースパッケージの例としては、"mc" 
(<tt>dpkg-source -x mc_4.5.54.dsc</tt> をごらんください。これは Adam Heath
による "sys-build.mk" を利用しています。又、"glibc" 
(<tt>dpkg-source -x glibc_2.2.4-1.dsc</tt>) は Joel Klecker
(<email>espy@debian.org</email>) による他のシステムを利用しています。

</sect>

</chapt>
