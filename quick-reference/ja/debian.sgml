<!-- CVS revision of this document "$Revision: 1.8 $"  -->
<!-- CVS revision of original english document "1.126"  -->

<!--Line width ruler (ruler uses 78 characters) 34567890123456789012345-->

<chapt id="package">&debian; パッケージ管理

<p>
現在 <prgn>aptitude</prgn> は APT のコンソール版のフロントエンドと
みなされています。過去にインストールしたパッケージと依存性を通じて
引っ張って来たパッケージを故意に記憶しています。
故意にインストールしたパッケージによりもはや必要とされなくなった場合、
後者のタイプのパッケージは <prgn>aptitude</prgn> により自動的に
削除されます。先進的なパッケージフィルタ機能を持ちますが、設定するのは
難しいでしょう。
<p>
現在 <prgn>synaptic</prgn> は APT の Gtk 版 GUI フロントエンドと
みなされています。
<prgn>aptitude</prgn> よりも設定しやすいパッケージフィルタ機能を持ちます。
又、<url id="&debtags;" name="Debian Package Tags"> を実験的にサポート
しています。
<p>
&debian; のリポジトリへのネットワーク負荷を低減し、ダウンロードを
高速化するためには、パッケージを &debian; のミラーサイトから
ダウンロードすべきです。
<p>
ローカルネットワーク内の複数のマシンに同じパッケージをインストール
する必要がある場合、APT を通じたパッケージのダウンロードのために
<prgn>squid</prgn> を使ってローカルの HTTP プロキシを立ち上げる
ことができます。必要ならば、<tt>http_proxy</tt> 環境変数を設定
したり、 <file>/etc/apt/apt.conf</file> に <tt>http</tt> 値を
設定してください。
<p>
<manref name="apt_preferences" section="5"> に記載された pin 
機能は強力ですが、その影響について理解や管理がしずらい場合が
あります。これを先進的な機能とみなすべきです。
<p>
<![%f-ref;[
<ref id="chroot"> に記載された手法を用いることは、
]]>
<![%q-ref;[
chroot を用いる手法は、
]]>
システムの安定性と最新版のソフトウエアへのアクセスの両方を確保できる
ために、望ましい手法です。
<p>
本章は Woody 以後のシステムに準拠していますが。
いくつかの機能は Sarge 以後であることを要求するかもしれません。

<sect id="pkg-intro">イントロダクション
<p>
もし全てのデベロッパー向けのドキュメンテーションを読むのが辛いなら、本章を
まず読み、&debian; の <tt>testing</tt>/<tt>unstable</tt> によるフルパワーを
楽しみ始めてください :-)

<sect1>主要なパッケージ管理ツール
<p>
<example>
dpkg      &ndash; &debian; パッケージファイルインストーラ
apt-get   &ndash; APT のコマンドラインフロントエンド
aptitude  &ndash; APT の先進的なコンソール版コマンドラインフロントエンド
synaptic  &ndash; APT の Gtk GUI フロントエンド
dselect   &ndash; メニュドリブンなパッケージマネージャ
tasksel   &ndash; タスクインストーラ
</example>
これらはお互いに置き換わるものではありません。
例えば、<prgn>dselect</prgn> は APT も <prgn>dpkg</prgn>
も使用しています。
<p>
APT は 取得可能なパッケージを追跡するために <file>/var/lib/apt/lists/*</file>
を使いますが、 <prgn>dpkg</prgn> は <file>/var/lib/dpkg/available</file> 
を使います。
<prgn>aptitude</prgn> や他の APT のフロントエンドを使ってパッケージを
インストールしてきて、インストールに <prgn>dselect</prgn> を使いたい場合、まず
最初にすべきことは <prgn>dselect</prgn> のメニュから <tt>[U]pdate</tt> を選択する 
(又は "<tt>dselect update</tt>" を起動する) ことです。
<p>
<prgn>apt-get</prgn> は自動的にインストールを要求したパッケージに Depends する
パッケージをインストールします。インストールを要求したパッケージに単に Recommends
や Suggests するパッケージはインストールしません。
<p>
一方、<prgn>aptitude</prgn> はインストールを要求したパッケージに Recommends や 
Suggests するパッケージをインストールするように設定できます。
<p>
<prgn>dselect</prgn> は選択したパッケージが Recommends や Suggests するパッケージ
のリストをユーザに提供し、それらを個別にインストールするかどうかを選択できます。
<![%f-ref;[
<ref id="depends"> 参照。
]]>
</sect1>

<sect1>便利なツール
<p>
<example>
dpkg-reconfigure  - 既にインストールしたパッケージを再設定する
                    (debconf を使っている場合)
dpkg-source       - source パッケージファイルを管理する
dpkg-buildpackage - パッケージファイルの構築を自動化する
apt-cache         - ローカルキャッシュにあるパッケージアーカイブをチェックする
</example>
</sect1>
</sect>

<sect id="apt-install">&debian; パッケージ管理の基礎
<p>
<ref id="testing-transition"> に記述されているように
<file>sources.list</file> を設定しましょう。
<footnote>
<tt>testing</tt> や <tt>unstable</tt> を追いかけている場合、
<file>/etc/apt/sources.list</file> や <file>/etc/apt/preferences</file>
から <tt>stable</tt> への参照を削除できます。その理由は
<tt>testing</tt> が <tt>stable</tt> のコピーとして始まっているからです。
</footnote>

<![%f-ref;[
<ref id="install">, <ref id="woody">, や <ref id="bin-editor">
でも言及しています。
]]>

<sect1 id="tasksel">task のインストール
<p>
特定の使用目的で &debian; システムに入れ込むために要求される主要な
パッケージ群をインストールできます。
これらのパッケージ群は "task" と呼ばれます。
<p>
最初のインストール時に task をインストールする最も単純な方法は
<prgn>tasksel</prgn> を使用することです。
使用前に <example>dselect update</example> を起動させる必要がある
ことに注意してください。
<p>
<prgn>aptitude</prgn> も task をインストールでき、この目的に
用いるために推奨できるツールです。
インストールの手順に進む前に task 内の個別のパッケージを削除
することを可能とします。
</sect1>

<sect1 id="aptitude"><prgn>aptitude</prgn>
<p>
<prgn>aptitude</prgn> は <prgn>dselect</prgn> に似たメニュドリブンな新しい
パッケージインストーラですが、APT の上に 1 から構築されています。
<prgn>apt-get</prgn> の代わりのコマンドラインコマンドとしても使えます。 
<manref name="aptitude"section="1"> と <file>&f-aptitude-readme;</file>
をご覧ください。
<p>
いったん <prgn>aptitude</prgn> を使いはじめたら、他のパッケージを
インストールする手段を用いずに使い続けるのが良いでしょう。
そうでないと意図してインストールしたパッケージを追跡するという
<prgn>aptitude</prgn> の利点を失ってしまいます。
<p>
<prgn>aptitude</prgn> はフルスクリーンモードで通常小文字の 1文字の
キーコマンドを受け付けます。言及しておくべきキーストロークをいくつか
示します。
<example>
キーストローク  アクション
F10             メニュ
?               キーストロークヘルプを表示
u               パッケージアーカイブ情報を更新
+               パッケージをアップグレードするか新たにインストールするとしてマークする
-               パッケージを削除するとしてマークする (設定はそのまま)
_               パッケージを purge するとしてマークする (設定も削除)
=               パッケージを hold する
U               全てのアップグレード可能なパッケージをアップグレードするとしてマークする
g               選択パッケージのダウンロードおよびインストール
q               現在のスクリーンを終了し、変更点を保存する
x               現在のスクリーンを終了し、変更点を無視する
Enter           パッケージの情報を閲覧
C               パッケージの変更履歴を閲覧
l               表示されたパッケージの制限を変更
/               単語検索
\               最後の検索を繰り返す
</example>
<prgn>apt-get</prgn> のように、<prgn>aptitude</prgn> は選択したパッケージが
Depends するパッケージをインストールできます。<prgn>aptitude</prgn> も
インストールされるパッケージが Recommends したり Suggests する
パッケージを引っ張って来るようなオプションを提供します。
メニュで <tt>F10 -> Options -> Dependency handling</tt> を選択することにより、
標準の挙動を変更できます。
<p>
<prgn>aptitude</prgn> の他の利点には次があります。
<list compact>
<item><prgn>aptitude</prgn> はパッケージの全バージョンにアクセスできます。
<item><prgn>aptitude</prgn> は <file>&f-aptitude-log;</file> に行動を全て記録しています。
<item><prgn>aptitude</prgn> は "Obsolete and Locally Created Packages" の下に
リストすることにより、時代遅れのソフトウェアを追跡するのを簡単にします。
<item><prgn>aptitude</prgn> には特定のパッケージを検索したりパッケージ表示を
制限するためのかなり力強いシステムが含まれます。<prgn>mutt</prgn> に親しんだ
ユーザは、mutt から expression syntax の着想を取り込んだので、すぐに使える
ようになるでしょう。
<file>&f-aptitude-readme;</file> の "SEARCHING, LIMITING, AND EXPRESSIONS"
をご覧下さい。
<item><prgn>aptitude</prgn> はフルスクリーンモードでは <prgn>su</prgn> の機能が
組み込んであり、本当に管理者権限が必要となるまでは通常のユーザから起動
できます。
</list>
</sect1>

<sect1 id="dselect"><prgn>dselect</prgn>
<p>
Potato を含む stable リリースまでは、<prgn>dselect</prgn>
は主要なパッケージ管理ツールでした。
Sarge では、<prgn>aptitude</prgn> を代わりに使うことを考慮すべきです。
<p>
<prgn>dselect</prgn> を起動すると、自動的に "Required", "Important", および
"Standard" パッケージの全てを選択します。 
<p>
<prgn>dselect</prgn> はいくらか奇妙なユーザインターフェースを持ちます。
ほとんどの人は慣れますが、4 個のコマンドがあります。 (大文字は大文字で入力
することを示します!)
<example>
キーストローク   アクション
Q           終了。現在の選択を認め、とにかく終了する。
            (依存性を上書きする)
R           戻る! 悪気はありません。
D           しまった! dselect が考えていることは分かりません。
U           全てを推奨される状態にセットする。
</example>
<tt>D</tt> や <tt>Q</tt> により、リスクを負って衝突した選択を
選ぶことができます。これらのコマンドを注意深く扱ってください。
<p>
雑音を減らすために、 "expert" オプションを含む行を 
<file>/etc/dpkg/dselect.cfg</file> に追加してください。
<p>
あなたのマシンでは <prgn>dselect</prgn> の動きが遅い場合、
インストールしたいパッケージを決定するために他の (高速な) マシン
で <prgn>dselect</prgn> を起動して、実際にインストールするためには
低速なマシンで <tt>apt-get install</tt> を使うことを考えた方が
良いかもしれません。
</sect1>

<sect1 id="apt-track">APT を用いてディストリビューションを追いかける
<p>
<tt>testing</tt> ディストリビューションの変更を追いかけることには、
セキュリティ修正を含むパッケージのインストールが遅れるという副作用
がありうることに注意してください。
そのようなパッケージはまず <tt>unstable</tt> にアップロードされ、
遅れて <tt>testing</tt> に移動してきます。
<p>
例えば、<tt>unstable</tt> から選択したパッケージをインストールしながら
<tt>testing</tt> を追いかけることを許可するようなより複雑な例については
<manref name="apt_preferences" section="5"> をご覧ください。
<p>
他のパッケージを追いかけながら特定のバージョンであるパッケージをロックする
例については、<url id="&examples;" name="examples subdirectory"> 
に <file>preferences.testing</file> や <file>preferences.unstable</file>
として得られます。
<p>
ディストリビューションを混在させる、すなわち
<tt>stable</tt> と <tt>testing</tt> を一緒にしたり、
<tt>stable</tt> と <tt>unstable</tt> を一緒にすると、
結果的には <tt>testing</tt> や <tt>unstable</tt> から
<package>libc6</package> のような主要なパッケージを
引っ張って来てしまうでしょう。これらにはバグが含まれていないと保証
できません。警告しておきます。
<p>
もう一つの例として、<file>preferences.stable</file>
は全てのパッケージの <tt>stable</tt> へのダウングレードを強制します。
<p>
新しいリリースの <strong>package</strong> を古いリリースのものに
ダウングレードすることは &debian; では公式にサポートされていません。
しかしながら、新しいバージョンがうまく動かないので、うまく動くバージョンの
パッケージを再インストールする目的で特定のパッケージをダウングレード
する必要があることが判明するかもしれません。
これらの以前インストールしていたパッケージファイルはローカルの
<file>/var/cache/apt/archives/</file> 又は
リモートでは <url id="&snapshothome;"> に見つかるかもしれません。
<ref id="rescue-dpkg"> もご覧下さい。
<p>
新しいリリースの <strong>ディストリビューション</strong> を古いリリースのものに
ダウングレードすることも &debian; では公式にサポートされていませんし、
問題を引き起こすでしょう。しかしながら、絶望に駆られた場合に
最後の手段として試す価値はあるかもしれません。
</sect1>

<sect1 id="apt-commands"><prgn>aptitude</prgn>, <prgn>apt-get</prgn> と <prgn>apt-cache</prgn> コマンド
<p>
上の例に記述されたように <tt>testing</tt> を追いかける間、
次のコマンドを用いてシステムを管理できます。
<list>
<item><tt>aptitude upgrade</tt> (又は
      <tt>apt-get upgrade</tt> 又は
      <tt>aptitude dist-upgrade</tt> 又は
      <tt>apt-get dist-upgrade</tt>)
 <p>これらは <tt>testing</tt> ディストリビューションを追いかけます &mdash;
 システム上のパッケージをそれぞれアップグレードし、
 その後インストールパッケージが依存するパッケージを <tt>testing</tt> 
 ディストリビューションからのバージョンをインストールします。
<footnote>
<tt>upgrade</tt> と <tt>dist-upgrade</tt> の違いは、新しいバージョンと
古いバージョンのパッケージに依存関係の違いが見られる場合にのみ現れます。
詳細は <manref name="apt-get" section="8"> をご覧下さい。
<p>
<tt>aptitude upgrade</tt> と <tt>aptitude dist-upgrade</tt> は
コマンドラインモードで <prgn>aptitude</prgn> を起動します。
<tt>e</tt> キーを押してこれらをフルスクリーンモードに切替えられます。
</footnote>
<item><tt>apt-get dselect-upgrade</tt>
 <p>これは <tt>testing</tt> ディストリビューションを追いかけます。&mdash;
 システムの各パッケージを <prgn>dselect</prgn> の選択に従って更新します。
<item><tt>aptitude install <var>package</var>/unstable</tt>
 <p><tt>unstable</tt> ディストリビューションから <var>package</var>
 をインストールし、<tt>testing</tt> ディストリビューションから
 依存するパッケージをインストールします。
<item><tt>aptitude install -t unstable <var>package</var></tt>
 <p><tt>unstable</tt> の Pin-Priority を 990 にセットすることにより、
 <tt>unstable</tt> ディストリビューションから <var>package</var>
 をインストールし、<tt>unstable</tt> ディストリビューションから
 このパッケージに依存するパッケージをインストールします。

<item><tt>apt-cache policy <var>foo bar ...</var></tt>
 <p>これは <var>foo bar ...</var> パッケージのステータスをチェックします。
<item><tt>aptitude show <var>foo bar ...</var> | less</tt>
(又は <tt>apt-cache show <var>foo bar ...</var> | less</tt>)
 <p>パッケージ <var>foo bar ...</var> に関する情報をチェックします。
<item><tt>aptitude install <var>foo=2.2.4-1</var></tt>
 <p><var>foo</var> パッケージの特定のバージョン <var>2.2.4-1</var>
 をインストールします。
<item><tt>aptitude install <var>foo bar-</var></tt>
 <p><var>foo</var> パッケージをインストールし、<var>bar</var> パッケージを
 削除します。
<item><tt>aptitude remove <var>bar</var></tt>
 <p><var>bar</var> パッケージを削除しますが、設定ファイルは削除しません。
<item><tt>aptitude purge <var>bar</var></tt>
 <p>全ての設定ファイルと一緒に <var>bar</var> パッケージを削除します。
</list>
上の例では、<prgn>apt-get</prgn> に <tt>-u</tt> オプションを与えると
アップグレードされる全てのパッケージのリストを表示し、次に取る行動を
ユーザに促します。
次の例は <prgn>apt-get</prgn> が常にこの動作を取るようにします。
<example>
$ cat &gt;&gt; /etc/apt/apt.conf &lt;&lt; .
// Always show packages to be upgraded (-u)
APT::Get::Show-Upgraded "true";
.
</example>
<p>
実際にインストール、削除などをあらゆるパッケージに対して行わずに
同様の行動を取るには、<tt>--no-act</tt> を使用してください。

<sect id="survival">Debian で生き残るためのコマンド
<p>
本章の知識により、<strong>永遠の</strong> upgrade 生活をすごせます。 :)

<sect1 id="bug-check">Debian のバグをチェックし、助けを求める
<P>
特定のパッケージに関する問題に直面している場合、助けを求めたり、
バグレポートを出す前にこれらのサイトをチェックしましょう。
(<prgn>lynx</prgn>,  <prgn>links</prgn>, および <prgn>w3m</prgn> は
同じように機能します)。

<example>
$ lynx &bugs;
$ lynx &bugs;<var>package-name</var>  # パッケージ名を知っている場合
$ lynx &bugs;<var>bugnumber</var>     # バグ番号を知っている場合
</example>
"site:debian.org" を含む検索語により Google (www.google.com) を検索して
みてください。
<p>
疑問がある場合は、良質のマニュアルを読んでください。<tt>CDPATH</tt> を
次のように設定してください。
<example>
export CDPATH=.:/usr/local:/usr/share/doc
</example>
そして次を実行してください。
<example>
$ cd <var>packagename</var>
$ pager README.Debian # 存在する場合
$ mc 
</example>
<![%f-ref;[
さらなるサポートリソースを <ref id="support"> に挙げます。
]]>
</sect1>

<sect1 id="apt-trouble">APT アップグレードのトラブルシュート
<p>
パッケージの依存性問題は <ref id="upgrade-system"> に記述したように
<tt>unstable</tt> 又は <tt>testing</tt> にアップグレードする場合に
発生する可能性があります。
ほとんどの場合、これはそのパッケージがまだ得られないパッケージに Depends
しているためです。
これらの問題は次の手順を用いて解決できます。
<example>
# aptitude dist-upgrade
</example>
これが動かない場合、問題が解決するまで次のコマンドを繰り返し実行して
ください。
<example>
# aptitude -f upgrade          # エラーが起きても upgradeを続ける
... 又は
# aptitude -f dist-upgrade    # エラーが起きても dist-upgrade を続ける
</example>
<p>
時々本当に壊れたアップグレードスクリプトにより持続的な問題を起こすことがあります。この種の状況を解決するには、<file>/var/lib/dpkg/info/<var>packagename</var>.{post,pre}{inst,rm}</file> スクリプトを調べ、次を実行するのがよいでしょう。
<example>
# dpkg --configure -a    # 部分的にインストールされたパッケージを全て設定
</example>
<p>
スクリプトに設定ファイルが無いと言っている場合、対応する設定ファイルに対して
<file>/etc/</file> を調べてください。<tt>.new</tt> (又は同種の) 拡張子
を持つファイルが存在する場合、<prgn>mv</prgn> して拡張子を削除してください。
<p>
パッケージの依存性問題は <tt>unstable</tt> 又は <tt>testing</tt> に
インストールする場合に発生する場合があります。依存性を迂回する手段があります。
<example>
# aptitude -f  install <var>package</var> # 壊れた依存性を上書きする
</example>
<p>
これらの状況を修正するための代替手段として、<package>equivs</package>
パッケージを使えます。 
<file>&f-equivs;</file><![%f-ref;[ と <ref id="equivs">]]> をご覧ください。
</sect1>

<sect1 id="rescue-dpkg"><prgn>dpkg</prgn> を用いたレスキュー
<p>
<p>
APT を用いて行き詰まった場合、&debian; のミラーからパッケージを
ダウンロードし、<prgn>dpkg</prgn> を用いてインストールできます。
ネットワークにアクセスできない場合、<file>/var/cache/apt/archives/</file>
にあるパッケージファイルのキャッシュを探せます。
<example>
# dpkg -i fetchmail_6.2.5-4_i386.deb
</example>
依存性の衝突によりこのようにパッケージをインストールするのを失敗してしまい、
本当のそのパッケージをインストールする必要がある場合、
<prgn>dpkg</prgn> の <tt>--ignore-depends</tt>, <tt>--force-depends</tt>,
や他のオプションを用いて依存性のチェックを上書きすることができます。
詳細は <manref name="dpkg" section="8"> をご覧下さい。
</sect1>

<sect1 id="recover-status">パッケージ選択データの回復
<p>
<file>/var/lib/dpkg/status</file> がなんらかの理由で壊れた場合、
&debian; システムはパッケージ選択データを失い、ひどく苦しみます。
<file>/var/lib/dpkg/status-old</file> や<file>/var/backups/dpkg.status.*</file> 
にある古い <file>/var/lib/dpkg/status</file> ファイルを探してください。
<p>
このディレクトリが多くの重要なシステムデータを含んでいるので、
別のパーティションに <file>/var/backups/</file> を保持するのは良い考えです。
<p>
古い <file>/var/lib/dpkg/status</file> ファイルが得られない場合、まだ
<file>/usr/share/doc/</file> にあるディレクトリからの情報で回復できます。
<example>
# ls /usr/share/doc | \
  grep -v [A-Z] | \
  grep -v '^texmf$' | \
  grep -v '^debian$' | \
  awk '{print $1 " install"}' | \
  dpkg --set-selections
# dselect --expert # システムを再インストールし、必要ない物を除外する
</example>

<sect1 id="rescue-var"><file>/var</file> のクラッシュ後のシステム回復
<p>
<file>/var</file> ディレクトリはメールなどの定期的に更新されるデータを
含むので、汚染されやすくなっています。このディレクトリを別のパーティションに
分けることにより、リスクを限定できます。故障が発生した場合、
<file>/var</file> ディレクトリを再構築して &debian; システムを回復
する必要があるかもしれません。
<p>
最小限 &debian; が機能する <file>/var</file> ディレクトリの基幹部分を同一又は古い &debian; バージョンから、例えば  <file><url id="&var-tar-gz;" name="var.tar.gz"></file> などを取得し、壊れたシステムの root ディレクトリに置きます。そして
<example>
# cd /
# mv var var-old      # 役に立つ内容が残っている場合
# tar xvzf var.tar.gz # Woody の基幹ファイルを使用
# aptitude            # 又は dselect
</example>
を実行します。これによりシステムが機能するようになるはずです。
<ref id="recover-status"> に記述している技術を用いてパッケージ選択データ
の回復をはかどらせることができます。
([FIXME]: 本手順はさらなる検証が必要。)
</sect1>

<sect1 id="un-bootable">ブート不能なシステムにパッケージをインストール
<p>
Debian レスキューフロッピ/CD 又は マルチブート Linux システム上の別の
パーティションを用いて Linux をブートしてください。
<![%f-ref;[
<ref id="booting"> 参照。 
]]>
ブート不可能なシステムを <file>/target</file> にマウントし、<prgn>dpkg</prgn>
の chroot インストールモードを使用します。
<example>
# dpkg --root /target -i <var>packagefile.deb</var>
</example>
そして設定を行い、問題を修正します。
<p>
ところで、<prgn>lilo</prgn> が壊れてブート不能になった場合、標準の
Debian レスキューディスクを用いてブートできます。
Linux をインストールしてある root パーティションを <file>/dev/hda12</file>
と仮定し、ランレベル 3 で起動したいとすると、lilo のプロンプトで次を
入力してください。
<example>
boot: rescue root=/dev/<var>hda12</var> 3
</example>
こうしてフロッピディスク上の kernel を用いてほぼ完全に機能するシステムに
ブートできます。(kernel の機能やモジュールがないことによる些細な不都合が
存在するかもしれません。)
</sect1>

<sect1><prgn>dpkg</prgn> コマンドが壊れた場合どうするか
<p>
<prgn>dpkg</prgn> が壊れると <tt>.deb</tt> ファイルがインストール不能になります。
次の手順によりこのような状況からの回復の助けになります。(第 1 行の
"links" を好みのブラウザコマンドに置き換えてください。)
<example>
$ links http://<var>http.us.debian.org</var>/debian/pool/main/d/dpkg/
  ... 良好な dpkg_<var>version</var>_<var>arch</var>.deb をダウンロード
$ su
password: *****
# ar x dpkg_<var>version</var>_<var>arch</var>.deb
# mv data.tar.gz /data.tar.gz
# cd /
# tar xzfv data.tar.gz
</example>
<tt>i386</tt> に対しては、<tt>http://packages.debian.org/dpkg</tt> が
URL としても使われます。
</sect1>

</sect>

<sect id="debian-package">Debian 涅槃コマンド
<p>
これらのコマンドを <strong>愉しむ</strong> と、永遠のアップグレード地獄から救い出し、Debian の <strong>涅槃</strong> に導くことができます。:)

<sect1 id="info-file">ファイルに関する情報
<p>
ある特定のファイル名のパターンがどのインストール済みパッケージに 
所属するかを見つけるには以下を実行します：
<example>
$ dpkg {-S|--search} pattern
</example>
もしくは同様のことを &debian; アーカイブ中で見付けるには以下を実行します：
<example>
$ wget http://ftp.us.debian.org/debian/dists/<var>sarge</var>/<var>Contents-i386.gz</var>
$ zgrep -e pattern <var>Contents-i386.gz</var>
</example>
もしくは特別なパッケージコマンドを使います。
<example>
# aptitude install dlocate  
                 # slocate (locate の安全版) と衝突する
$ dlocate <var>filename</var>         # dpkg -L と dpkg -S の高速な代替品
...
# aptitude install auto-apt # オンデマンドのパッケージインストールツール
# auto-apt update          # autp-apt 用の db ファイルを作成
$ auto-apt search <var>pattern</var>  
# インストールされているかに係わらず、全パッケージをパターン検索
</example>
</sect1>

<sect1 id="info-package">パッケージ情報
<p>
パッケージアーカイブから情報を検索し、表示します。
<file>/etc/apt/sources.list</file> を編集して APT が適切なアーカイブを
指すようにしてください。
<tt>testing</tt> 又は <tt>unstable</tt> にあるパッケージが現在インストール
しているパッケージに対してどうなっているかを知るには、 
<tt>apt-cache policy</tt> を使うのが良いでしょう。
<example>
# apt-get   check      # キャッシュを更新し、壊れたパッケージをチェック
$ apt-cache search  <var>pattern</var> # テキストの説明からパッケージ検索
$ apt-cache policy  <var>package</var> # パッケージの priority/dist 情報を表示
$ apt-cache show -a <var>package</var> # 全 dists のパッケージ説明を表示
$ apt-cache showsrc <var>package</var> # マッチしたソースパッケージの説明を表示
$ apt-cache showpkg <var>package</var> # パッケージのデバッグ情報を表示
# dpkg  --audit|-C          # 部分的にインストールされたパッケージを検索
$ dpkg {-s|--status} <var>package</var> ...  # インストール済みのパッケージの説明を表示
$ dpkg -l <var>package</var> ...    # インストール済みパッケージのステータスを表示 (1行毎)
$ dpkg -L <var>package</var> ...    # 指定したパッケージに含まれるファイル名リストを表示
</example>
<!-- Erase this when manual page gets fixed.  FIXME -->
<tt>apt-cache showrc</tt> は Woody リリースではドキュメント化されていませんが、使えます :)
<p>
また、次に挙げるファイルからもパッケージ情報を検索できます(これらを見るのに
<tt>mc</tt> を使っています)。
<example>
/var/lib/apt/lists/*
/var/lib/dpkg/available
</example>
次のファイルを比較すると、最後のインストールセッションで何が起きたかが
正確に分かります。
<example>
/var/lib/dpkg/status
/var/backups/dpkg.status*
</example>

</sect1>

<sect1 id="apt-get-auto">APT によりキーボードに触らずにインストール
<p>
キーボードに触らずにインストールするには、次の行を 
<file>/etc/apt/apt.conf</file> に追加してください。
<example>
Dpkg::Options {"--force-confold";}
</example>
これは <tt>aptitude -y install <var>packagename</var></tt> を起動するのと
同じことです。これは全プロンプトについて自動的に "yes" で答えるので、
問題が発生するかもしれません。ゆえに慎重にこのトリックを使ってください。
<manref name="apt.conf" section="5"> および <manref name="dpkg" section="1">
をご覧ください。
<p>
<ref id="reconfigure"> に従い、特定のパッケージを後で設定することもできます。

<sect1 id="reconfigure">インストール済みパッケージの再設定
<p>
次のコマンドを使ってインストール済みパッケージの再設定を行います。
<example>
# dpkg-reconfigure --priority=<var>medium</var> <var>package</var> [...]
# dpkg-reconfigure --all   # 全パッケージの再設定
# dpkg-reconfigure locales # 特別なロケールの生成
# dpkg-reconfigure --p=<var>low</var> xserver-xfree86 # X サーバの再設定
</example>
<prgn>debconf</prgn> ダイアログモードが永続的に必要な場合は、
<prgn>debconf</prgn> を再設定してください。
<p>
特別な設定スクリプトを持つプログラムがいくつかあります。
<footnote>
いくつかの <prgn>*config</prgn> スクリプトは新しい Sarge リリースでは
消えており、パッケージの設定機能は <prgn>debconf</prgn> に移動しています。
</footnote>
<example>
apt-setup     - /etc/apt/sources.list の生成
install-mbr   - Master Boot Record manager のインストール
tzconfig      - ローカル time zoneゾーンの設定
gpmconfig     - gpm マウスデーモンの設定
sambaconfig   - Potato で Samba の設定を行う (Woody は debconf を使用)
eximconfig    - Exim (MTA) の設定
texconfig     - teTeX の設定
apacheconfig  - Apache (httpd) の設定
cvsconfig     - CVS の設定
sndconfig     - サウンドシステムの設定
...
update-alternatives - 標準のコマンドの設定、例えば vim を vi に設定
update-rc.d         - System-V init スクリプトマネージャ
update-menus        - Debian menu システム
...
</example>
</sect1>

<sect1 id="remove">パッケージの削除及びパージ
<p>
設定ファイルを維持したままパッケージを削除します。
<example>
# aptitude remove <var>package</var> ...
# dpkg  --remove <var>package</var> ...
</example>
設定ファイルを含め、パッケージを削除します。
<example>
# aptitude purge <var>package</var> ...
# dpkg    --purge        <var>package</var> ...
</example>
</sect1>

<sect1 id="hold">古いパッケージを hold する
<p>
例えば、<package>libc6</package> と <package>libc6-dev</package> を
<prgn>dselect</prgn> および <tt>aptitude install <var>package</var></tt>
に対して hold するには、次を実行します。
<example>
# echo -e "libc6 hold\nlibc6-dev hold" | dpkg --set-selections
</example>
<tt>aptitude install <var>package</var></tt> はこの "hold" により隠されません。
<tt>aptitude upgrade <var>package</var></tt> 又は 
<tt>aptitude dist-upgrade</tt> に対する自動ダウングレードの強行から
パッケージを hold するには、
<file>/etc/apt/preferences</file> に次の行を追加してください。
<example>
Package: libc6
Pin: release a=stable
Pin-Priority: 2000
</example>
ここで、 "<tt>Package:</tt>" エントリは "<tt>libc6*</tt>" のようなエントリを
使えません。<package>glibc</package> ソースパッケージに同期したバージョンの
全バイナリパッケージを hold する必要がある場合、それらのパッケージを明示的に
挙げる必要があります。
<p>
次のコマンドにより hold されたパッケージのリストを表示できます。
<example>
dpkg --get-selections "*"|grep -e "hold$"
</example>
</sect1>

<sect1 id="mixedsys"><tt>stable</tt>/<tt>testing</tt>/<tt>unstable</tt> システムの混在
<p>
<prgn>apt-show-versions</prgn> により、特定のディストリビューションによる
パッケージのバージョンをリストできます。
<example>
$ apt-show-versions | fgrep /testing | wc
... testing からのパッケージ数をカウント
$ apt-show-versions -u
... アップグレード可能なパッケージ数
$ aptitude install `apt-show-versions -u -b | fgrep /unstable`
... 全ての unstable パッケージを最新バージョンにアップグレード
</example>
</sect1>

<sect1 id="cache">キャッシュされたパッケージファイルを取り除く
<p>
APT でパッケージをインストールすると、キャッシュされたパッケージファイルが
<file>/var/cache/apt/archives</file> に残されるので、これらを消す必要が
あります。
<example>
# apt-get autoclean # 必要ないパッケージファイルのみ削除
# apt-get clean     # キャッシュされたパッケージファイル全てを削除
</example>
</sect1>


<sect1 id="record">システム設定の記録/コピー
<p>
パッケージ選択ステータスのローカルコピーを取るには、次を実行します。
<example>
$ dpkg --get-selections "*" &gt;<var>myselections</var>   # 又は \* を使用
</example>
<tt>"*"</tt> により、<tt><var>myselections</var></tt> が "purge" 用の
パッケージエントリにも含まれるようになります。
<p>
このファイルを他のコンピュータに転送し、これを用いてインストール可能です。
<example>
# dselect update
# dpkg --set-selections &lt;<var>myselections</var>
# apt-get -u dselect-upgrade    # <var>又は</var> dselect install
</example>
</sect1>

<sect1 id="port"><tt>stable</tt> システムへのパッケージ移植
<p>
<tt>stable</tt> システムの部分的なアップグレードのためには、ソースパッケージを
用いて <tt>stable</tt> 環境でパッケージを再構築するのが望ましいです。
パッケージ再構築により、依存性による強引なパッケージアップグレードを避けることが
できます。まず、次のエントリを <file>/etc/apt/sources.list</file> に追加します。
<example>
deb-src &http-us;debian testing \
 main contrib non-free
deb-src &http-us;debian unstable \
 main contrib non-free
</example>
ここで、<tt>deb-src</tt> に対する各エントリは印刷時の制限のために 2行に分割
されていますが、実際の <file>sources.list</file> は 1行としてください。
<p>
そしてソースを取得し、ローカルパッケージを作成します。
<example>
$ apt-get update  # ソースパッケージの検索リストを更新
$ apt-get source <var>package</var>
$ dpkg-source -x <var>package.dsc</var>
$ cd <var>package-version</var>
  ... 要求されたパッケージを検査 (.dsc ファイル中の Build-depends) し、
      それらもインストールする。"fakeroot" パッケージも必要。

$ dpkg-buildpackage -rfakeroot 

  ...又は (サイン無し)
$ dpkg-buildpackage -rfakeroot -us -uc #必要ならば後で "debsign" を使用

  ...そしてインストール
$ su -c "dpkg -i <var>packagefile.deb</var>"
</example>
普通、パッケージの依存性を満たすために "-dev" サフィックスが付く 2, 3個の
パッケージをインストールする必要があります。<prgn>debsign</prgn> は
<package>devscripts</package> パッケージにあります。<prgn>auto-apt</prgn>
を使うと、依存性を簡単に満足させられるかもしれません。<prgn>fakeroot</prgn>
を使うと、root アカウントの不必要な使用を避けられます。
<p>
Woody では、依存性の問題は単純にできます。例えば、
ソースのみの <package>pine</package> パッケージをコンパイルするには、
<example>
# apt-get build-dep pine
# apt-get source -b pine
</example>
だけです。
</sect1>

<sect1 id="local">ローカルパッケージのアーカイブ
<p>
APT と <prgn>dselect</prgn> システムとの互換性を持つローカルパッケージの
アーカイブを作成するには、<file>Packages</file> を作成し、
特定のディレクトリツリーに置く必要があります。
<p>
公式の Debian アーカイブと同様のローカル <tt>deb</tt> リポジトリを次のように作成できます。
<example>
# aptitude install dpkg-dev
# cd <var>/usr/local</var>
# install -d <var>pool</var> # 真のパッケージはここに置きます
# install -d dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>
# ls -1 <var>pool</var> | sed 's/_.*$/ <var>priority</var> <var>section</var>/' | uniq &gt; <var>override</var>
# editor <var>override</var> # <var>priority</var> と <var>section</var> を調整
# dpkg-scanpackages <var>pool</var> <var>override</var> <var>/usr/local</var>/ \
   &gt; dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>/Packages
# cat &gt; dists/<var>unstable</var>/<var>main</var>/Release &lt;&lt; EOF
Archive: <var>unstable</var>
Version: <var>3.0</var>
Component: <var>main</var>
Origin: <var>Local</var>
Label: <var>Local</var>
Architecture: <var>i386</var>
EOF
# echo "deb file:<var>/usr/local</var> <var>unstable</var> <var>main</var>" \
   &gt;&gt; /etc/apt/sources.list
</example>
<p>
代わりに、手早いけど汚いローカル <tt>deb</tt> リポジトリを次のように作れます。
<example>
# aptitude install dpkg-dev
# mkdir <var>/usr/local/debian</var>
# mv <var>/some/where/package.deb</var> <var>/usr/local/debian</var>
# dpkg-scanpackages <var>/usr/local/debian</var> /dev/null | \
  gzip - &gt; <var>/usr/local/debian</var>/Packages.gz
#  echo "deb file:<var>/usr/local/debian</var> ./" &gt;&gt; /etc/apt/sources.list
</example>
<p>
HTTP や FTP メソッドによりディレクトリへのアクセス手段を供給し、
<file>/etc/apt/sources.list</file> にエントリを追加することにより、
これらのアーカイブへのリモートからのアクセスを可能にします。

<sect1 id="alien">alien バイナリパッケージへの変換又はインストール
<p>
<package>alien</package> は Red Hat <tt>rpm</tt> 形式、Stampede <tt>slp</tt> 形式、Slackware <tt>tgz</tt> 形式、そして Solaris <tt>pkg</tt> 形式で供給される
バイナリパッケージを &debian; <tt>deb</tt> パッケージ形式に変換することを
可能とします。他の Linux ディストリビューションからのパッケージを
システムにインストールしているディストリビューションで使いたい場合、
<prgn>alien</prgn> を使って使用中のディストリビューションのパッケージフォーマットに変換し、インストールできます。<package>alien</package> は LSB パッケージもサポートします。
</sect1>

<sect1 id="auto-apt">自動でコマンドをインストールする
<p>
<prgn>auto-apt</prgn> はオンデマンドのパッケージインストールツールです。
<example>
$ sudo auto-apt update
 ... データベースを更新
$ auto-apt -x -y run
Entering auto-apt mode: /bin/bash
Exit the command to leave auto-apt mode.
$ less /usr/share/doc/med-bio/copyright # 存在しないファイルにアクセスする
 ...  このファイルを供給するパッケージをインストールする
 ... 依存するパッケージもインストールする
</example>
</sect1>

<sect1 id="debsums">インストールされたパッケージファイルを検証する
<p>
<prgn>debsums</prgn> は MD5 チェックサムを用いてインストールされたパッケージファイルの検証ができます。いくつかのパッケージは MD5 チェックサムを得られません。
システム管理者が可能な一時的な修正はこのようなものです。
<example>
# cat >>/etc/apt/apt.conf.d/90debsums
DPkg::Post-Install-Pkgs {"xargs /usr/bin/debsums -sg";};
^D
</example>
Joerg Wendland <email>joergland@debian.org</email> からのメールによる (未検証)。

<![%f-ref;[
<sect1 id="spy">最適化された <file>sources.list</file>
<p>
簡単に言うと、最適化された <file>sources.list</file> を作成するための手の込んだ努力は USA に住んでいる私にとってはあまり効果を生みませんでした。
私は <prgn>apt-setup</prgn> を使って近くのサイトを手動で選びました。
<p>
<prgn>apt-spy</prgn> はレイテンシとバンド幅に基づいて自動で 
<file>sources.list</file> を作成します。 <prgn>netselect-apt</prgn> 
はより完全な <file>sources.list</file> を作成しますが、最適なミラーサイト
を選択する、より優れた方法 (ping 時間の比較) を使用しています。
<example>
# aptitude install apt-spy
# cd /etc/apt ; mv sources.list sources.list.org
# apt-spy -d testing -l sources.apt
</example>
</sect1>

]]>


</sect>

<sect id="pecuriarities">他の Debian 独特な点

<sect1 id="dpkg-divert"><prgn>dpkg-divert</prgn> コマンド
<p>
<!-- copied from manual page -->
<strong>Diversions</strong> というファイルにより、<prgn>dpkg</prgn> は
ファイルをインストールする時に本来意図していた場所ではなく、
<strong>退避した</strong> 場所にインストールするようになります。
<strong>Diversions</strong> は &debian; パッケージスクリプトで衝突が起こりうる
ファイルを移動させるために使うことができます。システム管理者はパッケー ジ
の設定ファイルや他のファイルを (<strong>conffiles</strong> としてマーク
されていなければ) <prgn>dpkg</prgn> が新しいバージョンのパッケージを
インストールする時にそれらのファイルを上書きしてしまわないようにするために
diversion を使うことができます。
<![%f-ref;[
(<ref id="conffile">) 参照]]>.
<example>
# dpkg-divert [--add]  <var>filename</var> # "diversion" を追加
# dpkg-divert --remove <var>filename</var> # "diversion" を削除
</example>
本当に必要でない限り、<prgn>dpkg-divert</prgn> を使わない方が
通常は良いでしょう。
</sect1>

<sect1 id="equivs"><package>equivs</package> パッケージ
<p>
ソースからプログラムをコンパイルした場合、最も良いのは本当のローカルな
debian 化したパッケージ (<tt>.deb</tt>) にすることです。
<tt>equivs</tt> を最後の手段として使います。
<example>
Package: equivs
Priority: extra
Section: admin
Description: Debian パッケージの依存関係を偽るためのパッケージ
 これはダミーパッケージで、依存情報だけを含んだ Debian パッケージの
 作成に使用することができます。
</example>
</sect1>

<sect1 id="alternatives">Alternative コマンド
<p>
<prgn>vi</prgn> コマンドが <prgn>vim</prgn> を起動するようにするには、
<prgn>update-alternatives</prgn> を使います。
<example>
# update-alternatives --display vi
...
# update-alternatives --config vi
  Selection    Command
-----------------------------------------------
      1        /usr/bin/elvis-tiny
      2        /usr/bin/vim
*+    3        /usr/bin/nvi

default[*] を保つために Enter を打つか、selection 番号 2 をタイプしましょう。
</example>
Debian alternatives システムのアイテムは <file>/etc/alternatives/</file> に
シンボリックリンクとして保持されています。
<p>
好みの X Window 環境を設定するには、<prgn>update-alternatives</prgn> を
<file>/usr/bin/x-session-manager</file> と 
<file>/usr/bin/x-window-manager</file> に適用します。
<![%f-ref;[
詳細は、<ref id="custom-x"> を参照。
]]>
<p>
<file>/bin/sh</file> は <file>/bin/bash</file> 又は <file>/bin/dash</file>
の直接のシンボリックリンクです。  
古い Bashism で汚染されたスクリプトとの互換性のため、 <file>/bin/bash</file>
を使う方が安全ですが、POSIX 互換性を強制するには、<file>/bin/dash</file>
を使うのがより良い訓練となります。
2.4 Linux kernel にアップグレードすると、<file>/bin/sh</file> を
<file>/bin/dash</file> にセットしがちです。
</sect1>

<sect1 id="sys-v">ランレベルの使い方
<p>
インストール直後は、ほとんどの &debian; パッケージはサービスを
ランレベル 2 から 5 まで起動するように設定します。
これゆえに、カスタマイズされていない &debian; システムではランレベル 2, 3, 4, と
5 には何の違いがありません。&debian; はローカルの管理者に任せています。
<![%f-ref;[
<ref id="custombootscripts"> に記述しているようにランレベルをカスタマイズすることを
]]>
<![%q-ref;[
ランレベルのカスタマイズを
]]>
ローカルの管理者に任せています。
これは他の有名な GNU/Linux ディストリビューションにより用いられている
ランレベルの方法とは異なります。
ブートシーケンスの終わりで X ディスプレイマネージャが起動されないように
ランレベル 2 で <prgn>xdm</prgn> や <prgn>gdm</prgn> を無効にしたい時が
来るかもしれません。
その時はランレベル 3 から起動するように変更できます。
<![%f-ref;[
ランレベルについてのより詳しい情報は <ref id="runlevels"> をご覧下さい。
]]>

<sect1 id="disables">デーモンサービスを無効にする
<p>
&debian; 開発者はシステムのセキュリティを深刻にとらえています。
多くのデーモンサービスは最小のサービスと機能を有効にして
インストールされます。
<p>
デーモンサービス (Exim, DHCP など) に疑いを持った場合、
<tt>ps aux</tt> を起動するか、<file>/etc/init.d/*</file> や
<file>/etc/inetd.conf</file> の内容を調べましょう。
また、<file>/etc/hosts.deny</file>
(<![%f-ref;[ 
<ref id="loginctrl"> 参照
]]>
)も調べましょう。
<prgn>pidof</prgn> コマンドも役立ちます。
(<manref name="pidof" section="8"> 参照)

<p>
最近の &debian; において、標準では X11 は TCP/IP 経由の遠隔接続を
許可していません。
<![%f-ref;[
<ref id="xtcp"> 参照
]]>

SSH での X フォワードも無効にされています。
<![%f-ref;[
<ref id="xssh"> 参照
]]>
</sect1>
</sect>

</chapt>
