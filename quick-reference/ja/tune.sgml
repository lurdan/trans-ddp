<!-- CVS revision of this document "$Revision: 1.6 $"  -->
<!-- CVS revision of original english document "1.169"  -->

<chapt id="tune">&debian; システムのチューニング 
<p>
本章はシステム設定の基本をコマンドラインインターフェース
のみで説明します。本章を読む前に<ref id="install">を読んで下さい。
<p>
セキュリティに関して関心があるなら、
<package>&p-securing-debian-howto;</package> パッケージにある
<url id="&securing-debian-howto;" name="Securing Debian Manual">
を読んでください。

<sect id="init-hints">システムの初期化
<p>
&debian; は Systen V 形式の init スクリプトシステムを採用しています。
イントロダクションとして <ref id="init"> をご覧ください。

<sect1 id="init-defaults">init スクリプトのカスタマイズ
<p>
init スクリプトの挙動を制御する最も易しい方法は <file>/etc/default/</file>
ディレクトリにある init スクリプトのような名前のファイルにある環境変数の
指定を変更することです。
<footnote>
<file>/etc/default/</file> にあるディレクトリは環境変数の割り当て
<strong>のみ</strong> を含みます。
各ファイルはこれらの割り当てが init スクリプト自身にある標準の
変数の設定を上書きするような方法で、対応する init スクリプトにより
読み込まれます。
このディレクトリ名の選択は &debian; <url id="&etc-defaults;" name="独特">
のものです。
大まかに言うと、Red Hat や他のディストリビューションで見られる
<file>/etc/sysconfig</file> と同じものです。
</footnote>
例えば、<file>/etc/default/hotplug</file> は <file>/etc/init.d/hotplug</file>
の挙動を制御するために使えます。
<file>/etc/default/rcS</file> ファイルは <prgn>motd</prgn>、
<prgn>sulogin</prgn> などのブート時の標準をカスタマイズするために使えます。
<p>
これらの変数を変更することにより望みの挙動を実現できない場合は、
init スクリプト自身を修正できます。これらは全て設定ファイルです。

<sect1 id="syslogd">システムのログ記録をカスタマイズする
<p>
システムのログモードは <file>/etc/syslog.conf</file> を使って設定可能です。
システムのログファイルに色づけするためのプログラムについては
<package>colorize</package> パッケージをチェックしてください。
又、<manref name="syslogd" section="8"> や 
<manref name="syslog.conf" section="5"> もご覧ください。
</sect1>

<sect1 id="hdtune">ハードウェアの最適化
<p>
&debian; でシステム管理者に管理が任されているハードウェアの最適化設定はあまり
ありません。
<list>
<item><package>hdparm</package>
 <list compact>
<item>ハードディスクアクセスの最適化ツール。非常に効果的。
<item>危険です。まず <manref name="hdparm" section="8"> を読む必要があります。
<item><tt>hdparm -tT <var>/dev/hda</var></tt> によりディスクのアクセス速度
をテストします。
<item><tt>hdparm -q -c3 -d1 -u1 -m16 <var>/dev/hda</var></tt> により
最近の IDE システムではディスク速度を高速化できます。(危険かもしれません。)
 </list>

<item><package>setcd</package>
 <list compact>
<item>コンパクトディスクドライブのアクセスの最適化ツール。
<item><tt>setcd -x <var>2</var></tt> により速度を <var>2</var> 
倍速に落とします。
<item><manref name="setcd" section="1"> をご覧ください。
 </list>

<item><package>setserial</package>
 <list compact>
<item>シリアルポートの管理ツール集。
 </list>

<item><package>scsitools</package>
 <list compact>
<item>SCSI ハードウェアの管理ツール集。
 </list>

<item><package>memtest86</package>
 <list compact>
<item>メモリデバイスの管理ツール集。
 </list>

<item><package>hwtools</package>
 <list compact>
<item>低レベルハードウェア管理ツール集。
  <list compact>
   <item><prgn>irqtune</prgn>: 優先度が高く高速なサービスを要求するデバイス 
   (例: シリアルポートやモデム) にデバイスの IRQ 優先度を変更する。
   シリアルポート/モデムの 3倍の高速化が可能。
   <item><prgn>scanport</prgn>: 装着した ISA デバイスを探すために
   0x100 から 0x3ff までの I/O 空間を検索する。
   <item><prgn>inb</prgn>: I/O ポートを読み込み、8進数又はバイナリ形式で 
   値をダンプする小さなクイックハック。
  </list>

 </list>

<item><package>schedutils</package>
 <list compact>
<item>Linux スケジューラユーティリティ。
<item><prgn>taskset</prgn>, <prgn>irqset</prgn>, <prgn>lsrt</prgn>, と
 <prgn>rt</prgn> が含まれます。
<item>(これには含まれていない) <prgn>nice</prgn> や <prgn>renice</prgn> 
 と組み合わせて、プロセスのスケジューリングパラメータの完全な制御が
 行えます。
 </list>
</list>
<p>
<tt>noatime</tt> オプション付でファイルシステムをマウントすることも
ファイルへの読み込みアクセスが高速化するには非常に効率的です。
<manref name="fstab" section="5"> と <manref name="mount" section="8">
をご覧ください。
<p>
proc ファイルシステムを通じて Linux kernel 自身により直接チューンできる
ハードウェアもあります。<ref id="proc-sys"> をご覧ください。
<p>
Debian には特定のハードウェアに特化した設定ユーティリティが数多く存在します。
これらの多くはノート PC に特定したニーズに対応しています。ここに Debian で
得られるいくつかの興味深いパッケージを挙げます。
<list compact>
<item><package>tpconfig</package> - タッチパッドデバイスの設定プログラム
<item><package>apmd</package> - Advanced Power Management (APM) 用ユーティリティ
<item><package>acpi</package> - ACPI デバイスの情報を表示
<item><package>acpid</package> - ACPI を使うためのユーティリティ
<item><package>lphdisk</package> - Phoenix NoteBIOS 用のハイパネーション
パーティションの準備を行う
<item><package>sleepd</package> - 使わない間ノート PC をスリープさせる
<item><package>noflushd</package> - アイドルになっているハードディスクの回転を止める
<item><package>big-cursor</package> - X 用の大きいマウスカーソル
<item><package>acme</package> - ノート PC にある "マルチメディアボタン" を有効にする
<item><package>tpctl</package> - IBM ThinkPad ハードウェア設定ツール
<item><package>mwavem</package> - Mwave/ACP モデムのサポート
<item><package>toshset</package> - 東芝ノート PC のインターフェースの多くにアクセスする
<item><package>toshutils</package> - 東芝ノート PC 用ユーティリティ
<item><package>sjog</package> - Sony VAIO ノートの "ジョグダイアル" を使うためのプログラム
<item><package>spicctrl</package> - LCD のバックライトの輝度設定用の Sony
VAIO コントローラプログラム
</list>
ここで、ACPI は APM より新しい電源管理システムのフレームワークです。
<p>
これらのパッケージのいくつかは特別な kernel モジュールを要求します。
これらは多くの場合、既に最新の kernel ソースに含まれています。
問題が発生した場合、kernel に最新のパッチを適用する必要があるかもしれません。

<sect>アクセス制限

<sect1 id="loginctrl">PAM を用いたログイン制限
<p>
PAM (Pluggable Authentication Modules) により、ユーザのログイン方法を制御
できます。
<example>
/etc/pam.d/*             # PAM 制御ファイル
/etc/pam.d/login         # ログイン用の PAM 制御ファイル
/etc/security/*          # PAM モジュールパラメータ
/etc/securetty           # 端末による root でのログインを制御
/etc/login.defs          # ログインの挙動を制御
</example>
<p>
自分でリスクを負って、安全ではないがパスワード無しで端末にログインしたい
場合は、<file>/etc/pam.d/login</file> の内容を次のように変えてください。
<example>
#auth       required   pam_unix.so nullok
auth       required   pam_permit.so
</example>
パスワード無しで X コンソールにログインするために同様のトリックを
 <prgn>xdm</prgn>, <prgn>gdm</prgn> などに適用できます。
<p>
一方、良いパスワードポリシーを実施したい場合には、次のように 
<package>cracklib2</package> をインストールして
<file>/etc/pam.d/passwd</file> をセットしてください。
<example>
password required       pam_cracklib.so retry=3 minlen=6 difok=3
</example>
ワンタイムログインパスワードも役に立つかもしれません。
この目的には、<prgn>passwd</prgn> コマンドを <tt>-e</tt> オプション付で
使ってください。<manref name="passwd" section="1"> をご覧ください。
<p>
Bash シェルではプロセスの最大数を <tt>ulimit -u 1000</tt> としてセット
できますし、<file>/etc/security/limits.conf</file> で PAM から設定
することもできます。<tt>core</tt> のような他のパラメータも
同様に設定できます。<prgn>PATH</prgn> の初期値はシェル起動スクリプトの
起動前に <file>/etc/login.defs</file> によりセットできます。
<p>
PAM のドキュメントは <package>libpam-doc</package> パッケージで
パッケージングされています。<em>Linux-PAM システム管理者ガイド</em>
は PAM の設定、必要なモジュールなどについてカバーしています。この
ドキュメントは <em>Linux-PAM アプリケーション開発ガイド</em> と
<em>Linux-PAM モジュール開発者ガイド</em> も含んでいます。
</sect1>

<sect1 id="wheel">"なぜ GNU <prgn>su</prgn> は <tt>wheel</tt> グループを
サポートしていないのか"
<p>
これは Richard M. Stallman による古い <tt>info su</tt> ページの末尾にある
有名なフレーズです。心配ありません。&debian; にある現在の <prgn>su</prgn>
は PAM を使っているので、<prgn>su</prgn> が使える能力を 
<file>/etc/pam.d/su</file> にある <prgn>pam_wheel.so</prgn> を使って
あらゆるグループに対して制限できます。次の設定は &debian; システムの <tt>adm</tt> 
グループを BSD の <tt>wheel</tt> グループと同じようにセットし、
このグループに属するメンバーがパスワード無しで <prgn>su</prgn> 
を使用することを許可します。
<example>
# /etc/pam.d/su において反 RMS 設定を行う
auth       required   pam_wheel.so group=adm

# Wheel メンバーがパスワード無しで suを使えるようにする
auth       sufficient pam_wheel.so trust group=adm
</example>

<sect1>標準で存在するグループの目的
<p>
興味深いグループがいくつか存在します。
<list compact>
<item><tt>root</tt> グループは <prgn>pam_wheel.so</prgn> が <tt>group=</tt>
 引数無しで使用されている場合の標準的な wheel グループです。
<item><tt>adm</tt> グループはログファイルを読むことが可能です。
<item><tt>cdrom</tt> グループは CD-ROM ドライブへのユーザのアクセスを
局所的に許すために使われます。
<item><tt>floppy</tt> グループはフロッピドライブへのユーザのアクセスを
局所的に許すために使われます。
<item><tt>audio</tt> グループはオーディオデバイスへのユーザのアクセスを
局所的に許すために使われます。
<item><tt>src</tt> グループは <file>/usr/src/</file> にあるソースコードを
所有しています。システムのソースコードを管理する能力をユーザに局所的に
与えるために使われます。
<item><tt>staff</tt> メンバは ヘルプデスクやシステム管理者補に対して
<file>/use/local/</file> で作業を行い、<file>/home/</file> に
ディレクトリを作成する能力を与えるのに役立ちます。
</list>
<p>
完全なリストは、Woody では <package>&p-securing-debian-howto;</package>
パッケージでも見つかる 
<url id="&securing-debian-howto;" name="Securing Debian Manual"> の
"FAQ" セクションをご覧ください。
又、新しい <package>&p-base-passwd;</package> (3.4.6 以降) にも信頼できる
リスト: <file>&f-users-and-groups;</file> が含まれます。

<sect1 id="sudo">&ndash; <prgn>sudo</prgn> を使ってより安全に作業をする
<p>
私の <prgn>sudo</prgn> の使いかたはほとんど自分のミスからの防御が目的です。
個人的には、<prgn>sudo</prgn> を使うことは、常に root としてシステムを使う
ことに対するより良い代替手段と考えます。
<p>
<prgn>sudo</prgn> をインストールして 
<file><url id="&examples;" name="/etc/sudoers"></file> にあるオプションを
設定して有効にします。また、<file>&dochome;sudo/OPTIONS</file> にある
<tt>sudo</tt> グループ機能を調べます。
<p>
設定サンプルは "staff" グループのメンバが <prgn>sudo</prgn> の元で
root としてあらゆるコマンドを起動することと "src" メンバが <prgn>sudo</prgn>
の元で root として選ばれたコマンドを起動することを許可します。
<p>
<prgn>sudo</prgn> の利点は、ユーザの普通のログインパスワードしか必要とせず、
その行動がモニタできるということです。これはシステム管理者補にいくらかの
権限を与える良い方法です。例えば、
<example>
$ sudo chown -R <var>myself</var>:<var>mygrp</var> .
</example>
<p>
もちろん root パスワードを知っている場合、(ほとんどのホームユーザがしているように) 
ユーザアカウントから root としてコマンドを起動できます。
<example>
$ su -c "shutdown -h now"
Password:
</example>
(管理者アカウントの <prgn>sudo</prgn> 権限を強化すべきだと知っていますが、
これは私のホームサーバなので、まだ困っていません。)
<p>
通常のユーザが root 権限でコマンドを実行することを許可するプログラムが
他にあります。<package>super</package> パッケージをご覧ください。
</sect1>
    
<sect1 id="tcpd">サービスへのアクセスを制限する
<p>
インターネット <em>スーパーサーバ</em> すなわち <prgn>inetd</prgn> は
ブート時に  <file>/etc/init.d/inetd</file> のシンボリックリンクである
<file>/etc/rc2.d/S20inetd</file> (ランレベルが 2の場合) により起動されます。
基本的に、<prgn>inetd</prgn> は 1つの起動中のデーモンが複数の他のデーモン
を起動し、システムの負荷を低減することを許可します。
<p>
サービス要求が届いた時には常に
<file>/etc/protocols</file> と <file>/etc/services</file> にあるデータベース
を検索することによりプロトコル並びにサービスが識別されます。
そして <prgn>inetd</prgn> は通常のインターネットサービスを
<file>/etc/inetd.conf</file> データベース、
Sun-RPC ベースのサービスを <file>/etc/rpc.conf</file> にあるデータベースから
捜し出します。
<p>
システムのセキュリティのために、<file>/etc/inetd.conf</file> にある
使用しないサービスを必ず無効化してください。
Sun-RPC サービスは NFS や他の RPC ベースのプログラムが必要とします。
<p>
時々、<prgn>inetd</prgn> は意図したサーバを直接起動しませんが、
<prgn>tcpd</prgn> TCP/IP デーモンラッパプログラムが意図したサーバ名を用いて
<file>/etc/inetd.conf</file> にある引数として起動されます。
<p>
この場合、<prgn>tcpd</prgn> は要求を記録した後に適切なサーバプログラムを
起動し、<file>/etc/hosts.deny</file> と <file>/etc/hosts.allow</file>
を使ったいくつかの付随的な検査を行います。
<p>
最近の &debian; システムで遠隔アクセスに問題が発生した場合、
<file>/etc/hosts.deny</file> に  "ALL: PARANOID" という行が存在する
場合はこれをコメントアウトしてください。
<p>
詳細については
<manref name="inetd" section="8">,
<manref name="inetd.conf" section="5">,
<manref name="protocols" section="5">,
<manref name="services" section="5">,
<manref name="tcpd" section="8">,
<manref name="hosts_access" section="5">, そして
<manref name="hosts_options" section="5"> をご覧ください。
<p>
Sun-RPC についての詳細は、
<manref name="rpcinfo" section="8">,
<manref name="portmap" section="8">, そして
<file>&f-portmap;</file> をご覧ください。

<sect1 id="ldap">集権的認証 &ndash; LDAP
<p>
Lightweight Directory Access Protocol (LDAP) を使いましょう。
以下を参照してください。
<list compact>
<item><url id="&openldaphome;" name="OpenLDAP">
<item><package>openldap-guide</package> パッケージにある OpenLDAP 管理者ガイド
<item>LDP: <url id="&ldap-linux-howto;" name="LDAP Linux HOWTO">
<item>LDP: <url id="&ldap-implementation-howto;" name="LDAP Implementation HOWTO">
<item><url id="&ldap-use1;" name="OpenLDAP, extensive use reports">
<item><url id="&ldap-use2;" name="Open LDAP with Courier IMAP and Postfix">
</list>
</sect>

<sect id="cdrw">CD ライター
<p>
ATAPI/IDE インターフェースを用いた CD ライターは最近非常にポピュラーな
選択肢になっています。640MB 以下の容量しか必要としないホームユーザ
にとってのシステムバックアップとアーカイブのための素晴らしい媒体です。
CD ライターに関する最も信頼できる情報は、LDP 
<url id="&cd-writing-howto;" name="CD-Writing-HOWTO"> をご覧ください。

<sect1>導入
<p>
まず、CD ライターに送るデータが中断すると CD に回復できない被害が発生します。
できるだけ大きなバッファを CD ライターに与えて下さい。
お金を問わないならば、ATAPI/IDE に拘らず、SCSI を使ってください。
接続する IDE インターフェースを選択する場合、ISA バス上 (SB16 カード
など) にあるものよりも PCI バス上 (マザーボードにあるものなど) にあるものを
使ってください。
<p>
CD ライターが IDE に接続されていると、Linux 2.2 kernel と 2.4 kernel では
通常の IDE CD ドライバの代わりに IDE-SCSI ドライバが働きます。
又、IDE-SCCI ドライバを有効にするには SCSI generic ドライバが必要となります。
最新のディストリビューション (2001 年 3 月現在)により配布されている kernel 
の使用を仮定すると、CD を焼くためには 2つの可能なアプローチが存在します。
<p>
Linux 2.6 カーネルの場合には、通常の IDE ドライバーを使い CD-RW デバイスに
<file>/dev/hd<var>x</var></file> と言ったデバイス名で直接アクセスするべきです。
こうすれば DMA が使えます。
</sect1>

<sect1>アプローチ 1: モジュール + <prgn>lilo</prgn>
<p>
Debian パッケージの kernel を使っている場合は、<file>/etc/lilo.conf</file>
に次の行を追加してください。複数のオプションを使う場合、スペースでそれらを
区切ってください。
<example>
append="hd<var>x</var>=ide-scsi ignore=hd<var>x</var>"
</example>
ここで CD ライターの場所は、ide-scsi ドライバを通してアクセスする場合は
<tt>hd<var>x</var></tt> により示されます。ここで <var>x</var> は
次のいずれかを表します。
<example>
hda          プライマリ IDE ポートのマスター
hdb          プライマリ IDE ポートのスレーブ
hdc          セカンダリ IDE ポートのマスター
hdd          セカンダリ IDE ポートのスレーブ
hde から hdh  外部 IDE ポート又は ATA66/100 IDE ポートに接続されたドライブ
</example>
root で次のコマンドをタイプすることにより、全設定が有効になります。
<example>
# lilo
# shutdown -h now
</example>
</sect1>


<sect1>アプローチ 2: kernel 再構築
<p>
Debian は kernel を作るために <prgn>make-kpkg</prgn> を用います。
複数の kernel イメージを構築するため、<prgn>make-kpkg</prgn> の
新しい <tt>--append_to_version</tt> オプションを用います。
<ref id="kernel"> をご覧ください。
<p>
<tt>make menuconfig</tt> を通じて次のセットアップを使用してください。
<list>
<item>bzImage
<item>IDE CD ドライバを除く (必須ではないがシンプルになります)
<item>ide-scsi と sg を組み込むかモジュールとしてコンパイルする
</list>
</sect1>

<sect1>設定後のステップ
<p>
次を実行することによりブート中に kernel の CD ライターのサポートを有効に
できます。
<example>
# echo ide-scsi &gt;&gt;/etc/modules
# echo sg       &gt;&gt;/etc/modules
# cd /dev; ln -sf scd0 cdrom
</example>
手動により CD ライターを有効にするには次を実行します。
<example>
# modprobe ide-scsi
# modprobe sg
</example>
リブート後、このように CD ライターのインストールをチェックできます。
<example>
$ dmesg|less
# apt-get install cdrecord
# cdrecord -scanbus
</example>
<p>
[Warren Dodge による] 
CD-ROM と CD-R/RW がシステムに同時に存在する場合、時々 <tt>ide-scsi</tt> と
<tt>ide-cd</tt> の間で衝突が発生することがありえます。
<file>/etc/modutils/aliaese</file> に次の行を追加して、
<prgn>update-modules</prgn> を起動してからリブートしてみてください。
<example>
pre-install      ide-scsi      modprobe ide-cd
</example>
この設定は IDE ドライバを <tt>ide-scsi</tt> の前にロードさせます。
IDE ドライバ <tt>ide-cd</tt> は ATAPI CD-ROM を制御します。 &mdash; 
これは <tt>ide-scsi</tt> が制御するデバイスを無視するだけです。
</sect1>

<sect1>CD イメージファイル (ブータブル)
<p>
<file>target-directory/</file> にあるファイルの CD イメージを
<file>cd-image.raw</file> 
として作成するには、フロッピドライブにブートフロッピを挿入して次を
実行します。
(ブータブルな Joilet TRANS.TBL が有効化されたフォーマット。
ブート不能な場合は、<tt>-b</tt> と <tt>-c</tt> オプションを取る)
<example>
# dd if=<var>/dev/fd0</var> <var>target-directory/boot.img</var> 
# mkisofs -r -V <var>volume_id</var> -b <var>boot.img</var> -c <var>bootcatalog</var> -J -T \
        -o <var>cd-image.raw</var> <var>target_directory/</var>
</example>
<p>
ブータブル DOS CD-ROM を作るのは面白いハックです。通常の DOS ブートフロッピ
ディスクイメージは <file><var>boot.img</var></file> にあり、CD-ROM
は DOS フロッピが A ドライブにあるかのようにブートします。これを
freeDOS を使って行うとより面白いかもしれません。
<p>
この CD イメージはループバックデバイスによりマウントして検査できます。
<example>
# mount -t iso9660 -o ro,loop <var>cd-image.raw</var> /cdrom
# cd /cdrom
# mc
# umount /cdrom
</example>
</sect1>

<sect1>CD ライター (R,RW) に書き込む
<p>
まず次のようにテストを行います。 (倍速と仮定)
<example>
# nice --10 cdrecord -dummy speed=2 dev=0,0 <var>disk.img</var>
</example>
結果が OK ならば、CD-R に次のように書き込みます。
<example>
# nice --10 cdrecord -v -eject speed=2 dev=0,0 <var>disk.img</var>
</example>
又は CD-RW ディスクに次のように書き込みます。
<example>
# nice --10 cdrecord -v -eject blank=fast speed=2 dev=0,0 <var>disk.img</var>
</example>
次のようにした方が良い CD-RW ドライブもあります。
<example>
# nice --10 cdrecord -v blank=all speed=2 dev=0,0 <var>disk.img</var>
</example>
に続いて
<example>
# nice --10 cdrecord -v -eject speed=2 dev=0,0 <var>disk.img</var>
</example>
を実行します。
この 2ステップは消去作業中に、書き込み作業を妨害するのを防ぐために
必要となります。<prgn>nice</prgn> の引数は幾らか調整が必要となる
かもしれません。
</sect1>

<sect1>CD イメージファイルの作成
<p>
ある CD-R や商用 CD は <prgn>dd</prgn> によるコピーができなくなるように
終わりに壊れたセクタを持っています。(Windows 98 CD はこの 1つです)
<package>cdrecord</package> パッケージには <prgn>readcd</prgn>
コマンドが付随しています。このコマンドを使うと CD の内容をコピーして
イメージファイルを作成できます。データディスクの場合、マウントして
<prgn>df</prgn> を実行することにより実際のサイズがわかります。
そのブロック数を2で割って実際の CD セクター数がわかります。
(1セクタ = 2048 byte)
そして <prgn>readcd</prgn> を次に示すオプション付きで実行し、
作成されたディスクイメージを使って CD-R/RW に書き込めます。
<example>
# readcd dev=<var>target</var>,<var>lun</var>,<var>scsibusno</var> # 機能 11 を選択
</example> 
ここで、ほとんどの場合はこれら 3つのパラメータは全て 0 にセットします。
通常 <prgn>readcd</prgn> により与えられるセクタ数は過大です!
実際にマウントして得られる数を使う方がより良い結果をもたらします。
<p>
<prgn>dd</prgn> を CD に対して使うといくつか問題が発生することを
言及すべきです。<prgn>dd</prgn> コマンドを最初に実行すると、
エラーが発生し、末尾が失われた短いディスクイメージができるかもしれません。
次に <prgn>dd</prgn> コマンドを実行すると、ディスクサイズが指定されていない
場合、後ろにごみデータが付随した大きなディスクイメージができるかもしれない
システムがあるかもしれません。引数として正しいディスクサイズを与えて 
<prgn>dd</prgn> コマンドを 2回実行し、エラーメッセージの後に CD 
をイジェクトしなければこれらの問題を避けられるようです。
例えば、<prgn>df</prgn> により表示されるイメージサイズが 
<tt>46301184</tt> であった場合、次のコマンドを 2回実行すると
正しいイメージを得られます。(これは経験的な情報です)
<example>
# dd if=/dev/cdrom of=cd.img bs=2048 count=$((46301184/2))
</example>
</sect1>

<sect1>Debian CD イメージ
<p>
&debian; CD の最新情報を得るには、
<url id="&debian-cd;" name="Debian CD site"> を訪れてください。
<p>
高速なインターネット接続を持っている場合は、次を用いてネットワーク越しに
インストールすることを考えてみてください。
<list compact>
<item>数枚の <url id="&debian-floppyinst;" name="floppy images"> 又は
<item> <url id="&debian-netinst;" name="minimal bootable CD image">。
</list>
<p>
高速なインターネット接続を持っていない場合は、
<url id="&debian-venders;" name="CD vendor"> から CD を購入することを
考慮してください。
<p>
CD イメージのテスタで無い限り、(たとえ新しい jigdo を使ったとしても)
標準の CD イメージをダウンロードしてバンド幅を無駄に消費しないでください。
<p>
言及すべき CD イメージは
<url id="&knoppix;"  name="KNOPPIX - Live Linux Filesystem On CD"> です。
この CD はハードディスクにインストールせずに機能する &debian; システムを
ブートします。

<!-- old document section
$ export CVSROOT=anonymous@cvs.debian.org:/cvs/debian-boot
$ cvs co debian-cd
</example>
次は CD イメージ作成のためのサマリです。
<example>
# apt-get install debian-cd
# cd /etc/debian-cd
# vim CONF.sh
$ . CONF.sh
$ make distclean
$ make status
$ make list COMPLETE=1 SIZELIMIT1=555000000 SRCSIZELIMIT=665000000
$ make official_images
 又はバイナリイメージしか欲しくない場合は、次を実行します。
$ make bin-official_images
-->
</sect1>

<sect1>システムを CD-R にバックアップ
<p>
主要な設定ファイルとデータファイルを CD-R にコピーするには、
<file><url id="&examples;" name="backup"></file> にあるサンプルバックアップ
スクリプトを使います。又、<ref id="archiving"> と <ref id="diff-backup"> 
もご覧下さい。
</sect1>

<sect1>音楽 CD を CD-R にコピーする
<p>
テストしていません。
<example>
# apt-get install cdrecord cdparanoia
# cdparanoia -s -B
# cdrecord dev=0,0,0 speed=2 -v -dao -eject defpregap=1 -audio *.wav
</example>
又は
<example>
# apt-get install cdrdao #disk at once
# cdrdao read-cd --device /dev/cdrom --paranoia-mode 3 my_cd # CD を読み込む
# cdrdao write --device /dev/cdrom --speed 8 my_cd    # 新しい CD を書き込む
</example>
<prgn>cdrdao</prgn> は (ギャップなどが無い) 真のコピーを作ります。
</sect1>

<sect1 id="dvd">DVD-R や DVD-RW や DVD+RW への書き込み
<p>
DVD に書き込む場合, 2 つのアプローチがあります:
<list compact>
<item><package>growisofs</package> を <package>mkisofs</package> とともに使う。
</sect1><file>&f-readmedvd;</file> に書かれた手順で <package>cdrecord</package> 
を dvd オプションでリコンパイルしローカルパッケージを作る。
</sect>

<sect id="x">X
<p>
W Window System は <url id="&xfree86home;" name="XFree86"> により
供給されています。&debian; システムでは 2つのメジャーバージョンの X サーバ、
すなわち XFree86 Version 3.3 (XF3) と XFree86 Version 4.x シリーズ (XF4)
が得られますが、どちらも <url id="&xorghome;" name="X.Org"> による X11R6
規格に基づいています。
<p>
X の基礎は、<manref name="X" section="7">、LDP 
<url id="&xwindowuser-howto;" name="XWindow-User-HOWTO"> や
<url id="&remote-xapps-howto;" name="Remote X Apps mini-HOWTO">
を参照してください。&debian; 特有のユーザガイドは、
<package>xfree86-common</package> パッケージにより供給される
<file>&f-x-deb-faq;</file> をご覧下さい。
これには Branded Robinson による興味深く信頼が置けるキーバインディング
問題の報告が含まれます。
<p>
<taglist>
<tag><ref id="xsrvr">
<item>ユーザのモニタ (CDT,液晶) に X window やデスクトップを
表示し、キーボードやマウスの入力を受け付けるローカルホストでのプログラム。
<tag><ref id="xclnt">
<item>X 互換なアプリケーションソフトを起動する (ローカル又はリモートでの)
プログラム
</taglist>
これは他の文脈での通常の "サーバ" と "クライアント" の逆の使いかたです。
<p>
"X クライアント" (アプリケーション側) から "X サーバ" (ディスプレイ側)
がリモート接続を得るための複数の方法があります。

<list>
<item><prgn>xhost</prgn> 
<list compact>
<item>ホストリストを用いた方法 (非常に危険)
<item>暗号化されていないプロトコル (盗聴されやすい)
<item>できるならば使わないでください。
<item><ref id="xhost"> と <manref name="xhost" section="1x"> 参照。
</list>
<item><strong><prgn>xauth</prgn></strong> 
<list compact>
<item>MIT magic cookie を使った方法 (安全ではないが <prgn>xhost</prgn> 
よりは良い)
<item>暗号化されていないプロトコル (盗聴されやすい)
<item><prgn>ssh -X</prgn> よりは CPU 負荷が少ないのでローカル接続に限り
使ってください。
<item><ref id="ss-xsu"> と <manref name="xauth" section="1x"> 参照。
</list>
<item><prgn>xdm</prgn>, <prgn>wdm</prgn>, <prgn>gdm</prgn>,
 <prgn>kdm</prgn> などの方法
<list compact>
<item>MIT magic cookie を用いた方法 (<prgn>xauth</prgn> と同様に安全では無い)
<item>X ディスプレイアクセス制御については <manref name="xdm" section="1x"> と
 <manref name="Xsecurity" section="7"> を参照。
<item>インストールしている場合、詳細は <manref name="wdm" section="1x">,
<manref name="gdm" section="8">, と <manref name="kdm.options" section="5">
を参照。
<item><prgn>xdm</prgn> パッケージをパージせずにブート時に Linux コンソール
を得るために <prgn>xdm</prgn> を無効にする方法は <ref id="custombootscripts"> を参照。
</list>
<item><strong><prgn>ssh -X</prgn></strong> 
<list compact>
<item>安全なシェル (<strong>ssh</strong>) によるポートフォワードを用いる
方法
<item>暗号化されたプロトコル (ローカル接続の場合リソースの無駄)
<item>リモート接続の場合はこれを使ってください。
<item><ref id="xssh"> 参照。
</list>
</list>
<prgn>ssh</prgn> を除いて、全てのリモート接続は X サーバ上で可能な
TCP/IP 接続を要求します。<ref id="xtcp"> をご覧下さい。

<sect1 id="x-system">X パッケージ
<p>
Woody に X システムをインストールするのを簡単にするためにいくつかの
(メタ)パッケージが供給されています。
<taglist>
<tag><package>x-window-system-core</package>
<item>
このメタパッケージは X Window System を起動するスタンドアロンの
ワークステーションに不可欠な構成要素を供給します。X ライブラリ、
X サーバ (<package>xserver-xfree86</package>)、フォント群、そして
基本的な X クライアントおよびユーティリティ群を供給します。

<tag><package>x-window-system</package> 
<item>
このメタパッケージは XFree86 プロジェクトにより開発されている
X Window System としての実質上全ての構成要素を供給するだけでなく、
歴史的に有名なアクセサリプログラムのセットを供給します。
(とりわけ、<package>x-window-system-core</package>, <package>twm</package>,
そして <package>xdm</package> などに依存します。これをインストールする場合
<package>x-window-system-core</package> をインストールする必要はありません。)

<tag><package>xserver-common-v3</package> 
<item>
XFree86 3.x X サーバ (XF3) に共通のファイルやユーティリティです。

<tag><package>xserver-*</package> 
<item>
何らかの理由で新しい XF4 サーバ (<package>xserver-xfree86</package>)
によりサポートされていないハードウェアをサポートするための補助的な
XF3 サーバパッケージです。いくつかの古い ATI mach64 カードは XF4
でサポートされていませんし、他のカードも Woody でのバージョンの XF4
ではひどくハングします。(取得可能なパッケージは、
<tt>apt-cache search xserver-|less</tt> により判明します。
これら XF3 サーバの全ては <package>xserver-common-v3</package> に
依存します。)
</taglist>
<p>
ほとんどの場合、<package>x-window-system</package> パッケージをインストール
すべきです。(コンソールでログインしたい場合は、<ref id="no-x-start">
で言及されているように <package>xdm</package> を無効にすることを忘れないで
ください。)

<sect1 id="hdetect-x">X 用のハードウェア検出
<p>
X の設定段階でハードウェアの検出を有効にするには、
X システムをインストールする前に次のパッケージをインストールしてください。
<list>
<item><package>discover</package> &ndash; ハードウェア認識システム。
<item><package>mdetect</package> &ndash; マウスデバイス自動検知ツール。
<item><package>read-edid</package> &ndash; VESA PnP モニタ用のハードウェア
情報収集ツール。
</list>

<sect1 id="xsrvr">X サーバ
<p>
X サーバに関する情報は <manref name="XFree86" section="1x"> をご覧下さい。
<p>
ローカルの端末から X サーバを起動するには、次を実行します。
<example>
$ startx -- :&lt;display&gt; <var>vtXX</var>
例えば、
$ startx -- :1 vt8 -bpp 16
... vt8 で 16bpp モードを用いて X サーバを起動し、localhost:1 に接続
</example>
<tt>--</tt> の後に与えられた引数は X サーバのためのものです。
<p>
X サーバ起動スクリプトをカスタマイズするために  <file>~/.xserverrc</file>
スクリプトを使用している場合、本当の X サーバを必ず <tt>exec</tt> してください。
こうしないと X サーバの起動が遅くなり、exit することに注意してください。
例えば、
<example>
#!/bin/sh
exec /usr/bin/X11/X -dpi 100 -nolisten tcp
</example>

<sect2 id="config-x4">X サーバの設定 (version 4)
<p>
XF4 サーバの(再)設定を行うには、
<example>
# dpkg-reconfigure --priority=low xserver-common
# dpkg-reconfigure --priority=low xserver-xfree86
</example>
を実行して <file>/etc/X11/XF86Config-4</file> ファイルを生成し、
<prgn>dexconf</prgn> スクリプトを用いて X の設定を行います。

<sect2 id="config-x3">X サーバの設定 (version 3)
<p>
XF3 サーバの(再)設定を行うには、例えば、ATI mach64 の場合、
<example>
# dpkg-reconfigure --priority=low xserver-common-v3
# dpkg-reconfigure --priority=low xserver-mach64
</example>
を実行して <file>/etc/X11/XF86Config</file> ファイルを生成し、
<prgn>xf86config-v3</prgn> スクリプトを用いて X の設定を行います。

<sect2 id="manual-config-x">X サーバを手動で設定する
<p>
Woody の場合、<file>/etc/X11/XF86Config-4</file> ファイルにユーザの
カスタマイズを追加します。
<strong>設定ファイル中の次の行を決して編集しないでください。</strong>
<!-- FIXME for XF3 -->
<example>
### BEGIN DEBCONF SECTION
[snip]
### END DEBCONF SECTION
</example>
<p>
その代わり、<strong>テキストの前にカスタマイズを追加してください。</strong>
例えば、ビデオデバイスをカスタマイズするには、ファイルの <em>先頭</em>
に次のテキストに似た行を追加してください。
<example>
Section "Device"
  Identifier        "Custom Device"
  Driver            "ati"
  Option            "NoAccel"
EndSection

Section "Screen"
  Identifier  "Custom Screen"
  Device      "Custom Device"
  Monitor     "Generic Monitor"
  DefaultDepth 24
  Subsection "Display"
    Depth       8
    Modes       "1280x960" "1152x864" "1024x768" "800x600" "640x480"
  EndSubsection
  Subsection "Display"
    Depth       16
    Modes       "1280x960" "1152x864" "1024x768" "800x600" "640x480"
  EndSubsection
  Subsection "Display"
    Depth       24
    Modes       "1280x960" "1152x864" "1024x768" "800x600" "640x480"
  EndSubsection
EndSection

Section "ServerLayout"
    Identifier        "Custom"
    Screen            "Custom Screen"
    InputDevice       "Generic Keyboard" "CoreKeyboard"
    InputDevice       "Configured Mouse" "CorePointer"
EndSection
</example>
<p>
Sarge (この文書の作成時は <tt>testing</tt>) の場合、
アップグレードを通じてカスタマイズした設定を <file>/etc/X11/XF86Config</file> 
保ちたい場合、次のコマンドを root として実行してください。
<example>
# cp /etc/X11/XF86Config-4 /etc/X11/XF86Config-4.custom
# md5sum /etc/X11/XF86Config-4 &gt; /var/lib/xfree86/XF86Config-4.md5sum
# dpkg-reconfigure xserver-xfree86
</example> 
<strong>フォントのアンチエイリアス</strong> を行うには、
<ref id="xfs-tt"> に記述されているように <file>/etc/X11/XF86Config-4</file>
を編集する必要があります。
<!--
<p>
For XF3, in order to achieve <strong>font de-uglification</strong>, 
you need to edit the order of <tt>FontPath</tt> in
<file>/etc/X11/XF86Config</file> 
while adding <tt>:unscaled</tt> as follows.
<example>
FontPath        "/usr/X11R6/lib/X11/fonts/misc:unscaled"
FontPath        "/usr/X11R6/lib/X11/fonts/100dpi:unscaled"
FontPath        "/usr/X11R6/lib/X11/fonts/75dpi:unscaled"
FontPath        "/usr/X11R6/lib/X11/fonts/Type1"
FontPath        "/usr/X11R6/lib/X11/fonts/Speedo"
FontPath        "/usr/X11R6/lib/X11/fonts/misc"
FontPath        "/usr/X11R6/lib/X11/fonts/100dpi"
FontPath        "/usr/X11R6/lib/X11/fonts/75dpi"
</example>
<p>
If you use xfs serves fonts via a Unix Domain Socket, you may also edit
<tt>catalogue</tt> entry of <file>/etc/X11/fs/config</file> as:
<example>
catalogue = /usr/X11R6/lib/X11/fonts/misc:unscaled,
            /usr/X11R6/lib/X11/fonts/100dpi:unscaled,
            /usr/X11R6/lib/X11/fonts/75dpi:unscaled,
            /usr/X11R6/lib/X11/fonts/Type1,
            /usr/X11R6/lib/X11/fonts/Speedo,
            /usr/X11R6/lib/X11/fonts/misc,
            /usr/X11R6/lib/X11/fonts/100dpi,
            /usr/X11R6/lib/X11/fonts/75dpi,
</example>
<p>
These <tt>:unscaled</tt> tricks are depreciated in new XF4 and no longer
needed.
-->
<!-- per /usr/share/doc/xfree86-common/README.fonts.gz in 4.2.1 -->
<p>
X の設定ファイルの他の部分もチェックしてみてください。ひどいモニタ設定
はひどいフォントよりも頭痛をもたらします。ですのでリフレッシュレートが
使っているモニタが発揮できるレートと同じ位高いことを確認してください。
(85 Hz なら素晴らしい、75 Hz なら大丈夫、60Hz だと苦痛です)

<sect1 id="xclnt">X クライアント
<p>
X クライアントプログラムのほとんどは次のようなコマンドで起動されます。
<example>
client $ xterm -geometry 80x24+30+200 -fn 6x10 -display <var>hostname</var>:0 &amp;
</example>
ここで、任意のコマンドライン引数は次を意味します。
<list>
<item><tt>-geometry <var>WIDTH</var>x<var>HEIGHT</var>+<var>XOFF</var>+<var>YOFF</var></tt>: 
起動時のウィンドウのサイズと位置

<item><tt>-fn <var>FONTNAME</var></tt>: テキスト表示用のフォント
 <tt><var>FONTNAME</var></tt> は次を設定可能です。
<list compact>
<item>a14: 通常サイズのフォント
<item>a24: 大きなサイズのフォント
<item>など (<tt>xlsfont</tt> でフォントが使えるかをチェックしてください。)
</list>
<item><tt>-display <var>displayname</var></tt>: 使用する X サーバ名
 <tt><var>displayname</var></tt> は次のようになります。
<list compact>
<item><tt><var>hostname</var>:<var>D.S</var></tt> 
はホスト <tt><var>hostname</var></tt> のディスプレイ <var>D</var> 上の
<tt><var>S</var></tt> スクリーンを意味します。このディスプレイ用の
X サーバは UNIX domain socket <file>/tmp/.X11-unix/XD</file> を listen
しています。(それゆえ <tt><var>host</var></tt> からしか読めません)

<item><tt><var>:D.S</var></tt> は <tt><var>host</var>/unix:<var>D.S</var></tt>
と等価です。ここで <tt><var>host</var></tt> はローカルのホスト名です。
</list>
</list>
<p>
X クライアントプログラム (アプリケーション側) 用の標準の 
<tt><var>displayname</var></tt> は DISPLAY 環境変数によりセットできます。
例えば、環境変数を設定するために X クライアントプログラムより先に
次のコマンドのうちひとつを実行します。
<example>
$ export DISPLAY=:0 
        # 標準、ローカルマシンの第一スクリーン
$ export DISPLAY=<var>hostname.fulldomain.name</var>:0.2
$ export DISPLAY=localhost:0
</example>
この設定は <file>~/.xinitrc</file> によりカスタマイズできます。例えば、
<example>
xrdb -load $HOME/.Xresources
xsetroot -solid gray &amp;
xclock -g 50x50-0+0 -bw 0 &amp;
xload -g 50x50-50+0 -bw 0 &amp;
xterm -g 80x24+0+0 &amp;
xterm -g 80x24+0-0 &amp;
twm
</example>
<ref id="custom-x"> に記述したように、この設定は <prgn>startx</prgn>
から実行された場合、<prgn>Xsession</prgn> の通常の実行結果を全て上書きします。
その代わり、<file>~/.xsession</file> を苦肉の策としてのみ使ってください。
<manref name="xsetroot" section="1x">、
<manref name="xset" section="1x"> と <ref id="xresources"> をご覧下さい。
</sect1>

<sect1 id="x-session">X セッション
<p>
X セッション (X サーバ + X クライアント) は次のように起動できます。
<list compact>
<item><prgn>startx</prgn>: Linux 文字端末から X サーバと X クライアントを
起動するための <prgn>xinit</prgn> のラッパースクリプトコマンド。
<file>~/.xinitrc</file> が存在しない場合、<file>/etc/X11/Xsession</file>
が <file>/etc/X11/xinit/xinitrc</file> を通じて実行される。
<item><prgn>xdm</prgn>, <prgn>gdm</prgn>, <prgn>kdm</prgn>, や
      <prgn>wdm</prgn>: X サーバと X クライアントを起動し、GUI スクリーン
経由でログインを制御するためのX ディスプレイマネージャデーモン。
<file>/etc/X11/Xsession</file> が直接実行される。
</list>
コンソールは <ref id="no-x-start"> に記述されている方法で取得できます。

<sect2 id="custom-x">X セッションのカスタマイズ
<p>
標準の起動スクリプト <file>/etc/X11/Xsession</file> は
<file>/etc/X11/Xsession.d/50xfree86-common_determine-startup</file> と
<file>/etc/X11/Xsession.d/99xfree86-common_start</file> が組み合わさったもの
です。
<p>
<file>/etc/X11/Xsession</file> の実行は
<file>/etc/X11/Xsession.options</file> にいくらか影響を受け、本質的には
次の順序で最初に見付かったプログラムを <prgn>exec</prgn> コマンドで
実行することになります。
<enumlist compact>
<item>定義されている場合、 <file>~/.xsession</file> か <file>~/.Xsession</file>
<item>定義されている場合、 <file>/usr/bin/x-session-manager</file>
<item>定義されている場合、<file>/usr/bin/x-window-manager</file>
<item>定義されている場合、<file>/usr/bin/x-terminal-emulator</file>
</enumlist>
<p>
これらのコマンドの正確な意味は <ref id="alternatives"> に記述されている
&debian; alternative システムにより定義されています。
例えば、
<example>
# update-alternatives --config x-session-manager
又は
# update-alternatives --config x-window-manager
</example>
GNOME や KDE のセッションマネージャをインストールしたまま他の
X ウィンドウマネージャを標準にするには、
<file>/etc/X11/Xsession.d/50xfree86-common_determine-startup</file>
を <url id="&bug-xfree;"> の 2番目のバグレポートに添付されているもの
に置き換え (これがすぐに含まれればいいのですが)、
X セッションマネージャを禁じるために次のように
<file>/etc/X11/Xsession.options</file> を編集します。
<example>
# /etc/X11/Xsession.options
#
# configuration options for /etc/X11/Xsession
# See Xsession.options(5) for an explanation of the available options.
# Default enabled
allow-failsafe
allow-user-resources
allow-user-xsession
use-ssh-agent
# Default disabled (enable them by uncommenting)
do-not-use-x-session-manager
#do-not-use-x-window-manager
</example>
<p>
上で述べた修正をシステムに行わないと、<package>gnome-session</package> 
と <package>kdebase</package> はこれらの X セッションマネージャを含む
パッケージとなります。これらを削除すると X ウィンドウマネージャが標準
になります。(Yack, any better idea?)
<p>
<file>/etc/X11/Xsession.options</file> に 
<tt>allow-user-xsession</tt> という行が有効になっている場合、
<file>~/.xsession</file> や <file>~/.Xsession</file> を定義したユーザは
<file>/etc/X11/Xsession</file> のアクションをカスタマイズできます。
<p>
お好みの X ウィンドウ/セッションマネージャを起動するために、
<file>~/.xsession</file> ファイルの最後のコマンドは
<tt>exec <var>some-window/session-manager</var></tt> の形にすべきです。
<p>
<file>~/.xsession</file> スクリプトの良い例は <file>&f-xsession;</file>
に置いておきます。
<p>
私はこれをウィンドウマネージャ、スクリーンへのアクセス、ユーザアカウント毎の
言語サポートの設定のために使っています。
<ref id="s-w-manager">, <ref id="ss-xsu">, そして <ref id="x-cjk">
をご覧下さい。
<p>
複数の X クライアントプログラムを同時に起動したい場合、
<ref id="xclnt"> の例を見て、それらを <file>~/.xinitrc</file> ではなく
<file>~/.xsession</file> から起動してください。
<p>
ユーザが指定する追加的な X リソースは <file>~/.Xresources</file> に
保存できます。<ref id="xresources"> をご覧下さい。
<p>
X においてユーザがカスタマイズしたキーマップとポインタデバイスのマッピングも
ユーザの起動スクリプトで指定できます。<ref id="xmodmap"> をご覧下さい。

<sect2 id="s-w-manager">ユーザ用に X セッションを開始する
<p>
<ref id="custom-x"> に記述されている原則に従い、ユーザ指定の X 
セッション/ウィンドウマネージャは、指示されたパッケージをインストールし、
次のように <file>~/.xsession</file> の最後に設定することにより有効化
できます。
(私はシンプルなスタイルと高速性から <package>blackbox</package>/
<package>fluxbox</package> が好きです。)

<list>
<item>標準の X セッションマネージャ
<list compact>
<item><ref id="alternatives"> 参照
<item><tt>exec /usr/bin/x-session-manager</tt>
</list>
<item>標準の X ウィンドウマネージャ
<list compact>
<item><ref id="alternatives"> 参照
<item><tt>exec /usr/bin/x-window-manager</tt>
</list>

<item>GNOME セッションマネージャ (重い)
<list compact>
<item>インストールするパッケージ: <package>gnome-session</package>
<item><tt>exec /usr/bin/gnome-session</tt>
</list>

<item>KDE セッションマネージャ (重い)
<list compact>
<item>インストールするパッケージ: <package>kdebase</package> (又は
KDE3 の場合 <package>kdebase3</package>)
<item><tt>exec /usr/bin/kde2</tt>
</list>

<item>Blackbox ウィンドウマネージャ (軽量でしなやか)
<list compact>
<item>インストールするパッケージ: <package>blackbox</package>
<item><tt>exec /usr/bin/blackbox</tt>
</list>

<item>Fluxbox ウィンドウマネージャ (軽量、新しい blackbox)
<list compact>
<item>インストールするパッケージ: <package>fluxbox</package>
<item><tt>exec /usr/bin/fluxbox</tt>
</list>

<item>Xfce ウィンドウマネージャ (Mac OS-X や SUN CDE ライク)
<list compact>
<item>インストールするパッケージ: <package>xfce</package>
<item><tt>exec /usr/bin/xfwm</tt>
</list>

<item>IceWM ウィンドウマネージャ (軽量、GNOME の代替品)
<list compact>
<item>インストールするパッケージ: <package>icewm</package>
<item><tt>exec /usr/bin/X11/icewm</tt>
</list>

<item>FVWM2 仮想ウィンドウマネージャ (軽量、Win95 ライク)
<list compact>
<item>インストールするパッケージ: <package>fvwm</package>
<item><tt>exec /usr/bin/fvwm2</tt>
</list>

<item>Windowmaker ウィンドウマネージャ (幾らか NexT ライク)
<list compact>
<item>インストールするパッケージ: <package>wmaker</package>
<item><tt>exec /usr/bin/wmaker</tt>
</list>

<item>Enlightenment ウィンドウマネージャ (重い)
<list compact>
<item>インストールするパッケージ: <package>enlightenment</package>
<item><tt>exec /usr/bin/enlightenment</tt>
</list>

</list>
<url id="&windomanagerhome;" name="Window Managers for X"> をご覧下さい。


<sect2 id="kde-gnome">KDE と GNOME の設定
<p>
KDE 又は GNOME 環境を完全に設定するためには、次のメタパッケージが
役立ちます。
<list compact>
<item>KDE: <package>kde</package> パッケージをインストール
<item>GNOME: <package>gnome</package> パッケージをインストール
</list>
これらのパッケージを <tt>Recommends</tt> を操作できる <prgn>dselect</prgn>
や <prgn>aptitude</prgn> のようなツールでインストールすると、
ただ <prgn>apt-get</prgn> でインストールするよりも適切な
ソフトウェアの選択を行えます。
<p>
端末からログインをしたい場合、<package>kdm</package>、
<package>gdm</package> のような X ディスプレイマネージャを必ず無効に
してください。これらは <ref id="no-x-start"> に記述されているように、
メタパッケージといっしょに依存性に従いインストールされるかもしれません。
<p>
KDE ではなく、GNOME をシステムの標準にしたい場合、
<ref id="alternatives"> にあるように <prgn>x-session-manager</prgn> の
設定を必ず行ってください。

<sect1 id="xtcp">TCP/IP 越しに X を使う
<p>
暗号化を行わずにリモートの TCP/IP ソケット接続を行うのは盗聴攻撃を
受けやすいので、最近の &debian; における標準の X の設定は TCP/IP
ソケットを無効にしています。リモートから X へ接続するには、
<prgn>ssh</prgn> の使用を考慮してください。(<ref id="xssh"> 参照)
<p>
ここで記述する方法は信頼できるユーザしか存在しない良質のファイアーウォール
システムの後ろに隠れた非常に安全な環境にいるので無ければ推奨されません。
現在の TCP/IP ソケットに関する X の設定を検証するために、次のコマンドを
使用してください。
<example>
# find /etc/X11 -type f -print0 | xargs -0 grep nolisten
/etc/X11/xinit/xserverrc:exec /usr/bin/X11/X -dpi 100 -nolisten tcp
</example>
X サーバが TCP/IP を listen されるには、<tt>-nolisten</tt>
を削除してください。
</sect1>
 
<sect1 id="xhost">リモートの X サーバに接続する &ndash; <prgn>xhost</prgn>
<p>
<prgn>xhost</prgn> を使ってホスト名に基づいてリモートホストにアクセスできる
ようになります。これは非常に危険です。次の手順によりホストのチェックを
無効にし、TCP/IP ソケット接続が許されている所からならどこからでも
接続を許すようになります。(<ref id="xtcp"> 参照)
<example>
$ xhost +
</example>
ホストのチェックを次の手順で再び有効にできます
<example>
$ xhost -
</example>
<p>
<prgn>xhost</prgn> はリモートホストの異なるユーザを区別できません。
又、ホスト名 (実際はアドレス) はだまされ得ます。
<p>
この方法は信頼できないネットワーク (例えばインターネットへダイアルアップ
PPP 接続している場合など) では、より制限されたホスト基準を用いていたとしても
避けるべきです。<manref name="xhost" section="1x"> をご覧下さい。
</sect1>

<sect1 id="xssh">リモートの X サーバに接続する &ndash; <prgn>ssh</prgn>
<p>
<prgn>ssh</prgn> を使うと、ローカルの X サーバからリモートのアプリケーション
サーバに安全な接続を行うことが可能になります。
<list>
<item>コマンドラインオプションを省略したい場合、リモートホストの
<file>/etc/ssh/sshd_config</file> にある <tt>X11Forwarding</tt> および
<tt>AllowTcpForwarding</tt> エントリを <tt>yes</tt> にセットしてください。
<item>ローカルホストで X サーバを起動する。
<item>ローカルホストで <prgn>xterm</prgn> を開く。
<item><prgn>ssh</prgn> を起動してリモートサイトへの接続を確立する。
<example>
localname @ localhost $ ssh -q -X -l loginname remotehost.domain
Password:
.....
</example>
<item>リモートサイトで X アプリケーションを起動する。
<example>
loginname @ remotehost $ gimp &
</example>
</list>
この方法はローカルの UNIX ドメインソケットを通してローカルで接続
しているかのようにリモートの X クライアントの出力を表示できます。
</sect1>

<sect1 id="xtermfaq">X ターミナルエミュレータ &ndash; <prgn>xterm</prgn>
<p>
<url id="&xtermfaq;"> で <prgn>xterm</prgn> についての全てを学んでください。
</sect1>

<sect1 id="xresources">X リソース
<p>
<prgn>xterm</prgn> のような多くの古い X プログラムは、見栄えを設定する
ために X リソースデータベースを用います。
ユーザのリソース指定を保存するため、<file>~/.Xresources</file> ファイルを
用います。このファイルはログイン時に標準の X リソースと自動的に
マージされます。システムの標準となっている X リソースは
<file>/etc/X11/Xresources/*</file> に、アプリケーションの標準リソースは
<file>/etc/X11/app-defaults/*</file> に保存されます。
これらの設定を開始点として使用します。
<p>
<file>~/.Xresources</file> ファイルに追加すべき役立つ設定を
いくつか示します。
<example>
! フォントを読みやすい 9x15 にセット
XTerm*font: 9x15

! スクロールバーを表示
XTerm*scrollBar: true

! バッファサイズを 1000 行にセット
XTerm*saveLines: 1000

! 大きな kterm スクリーン
KTerm*VT100*fontList: -*-fixed-medium-r-normal--24-*,\
 -*-gothic-medium-r-normal--24-*,\
 -*-mincho-medium-r-normal--24-*
</example>
これらの設定を直ちに有効にするには、次のコマンドを使ってデータベースに
マージします。
<example>
xrdb -merge ~/.Xresources
</example>
<manref name="xrdb" section="1x"> をご覧下さい。

<sect1 id="xmodmap">X における keymap とポインタボタンマッピング
<p>
<prgn>xmodmap</prgn> プログラムは X クライアントアプリケーション上で
イベントのキーコードをキーシムに変換するために用いるキーボード modifier
 マップと keymap テーブルを編集したり表示するために用いられます。
<example>
$ xmodmap -pm 
 ... 現在の modifier マップを表示
$ xmodmap -pk | pager
 ... 現在の keymap テーブルを表示
$ xmodmap -e "pointer = 3 2 1" # 左利き用マウスに設定
$ xmodmap ~/.xmodmaprc # キーボードのマッピングを ~/.xmodmaprc で設定
</example>
これは通常ユーザのセッション起動スクリプトである <file>~/.xsession</file>
から起動されます。
<!--
X におけるユーザ指定のキーマップとポインタボタンのマッピングは
<file>~/.xmodmaprc</file> で指定できます。
-->
<p>
<tt>keycode</tt> を取得するには、X 上で <prgn>xev</prgn> を起動し、
keycode を取得したいキーを押します。<tt>keysym</tt> の意味を知るには、
<file>/usr/include/X11/keysymdef.h</file> ファイルにある MACRO 定義を
調べます。このファイルにある全ての <tt>#define</tt> 文は
<tt>XK_</tt> として指定されており、それぞれが <tt>keysym</tt> 名
と対応しています。
<p>
<manref name="xmodmap" section="1x"> をご覧下さい。

<sect1 id="ss-xsu">X で root 権限を取得する
<p>
GUI プログラムを root 権限で起動する必要がある場合、次の手順に従って
プログラムの出力をユーザの X サーバに表示してください。
セキュリティの問題を可能な限り避けるため、
<strong>決して X サーバを直接 root から起動しようとしてはいけません</strong>。
<p>
X サーバを通常のユーザとして起動し、<prgn>xterm</prgn> 端末を開きます。
そして次を実行します。
<example>
$ XAUTHORITY=$HOME/.Xauthority
$ export XAUTHORITY
$ su root
Password:*****
# printtool &
</example>
このトリックを <prgn>su</prgn> で非 root ユーザに変更するために使う場合、
<file>~/.Xauthority</file> がその非 root ユーザが属するグループが
読み込み可能であることを確認してください。
<p>

<!-- this section moved up -->

この作業を自動化するには、ユーザアカウントの <file>~/.xsession</file> に
次の行を追加します。
<example>
# root アカウント に su した時に X が動くようにする。
if [ -z "$XAUTHORITY" ]; then
        XAUTHORITY=$HOME/.Xauthority
        export XAUTHORITY
fi
unset XSTARTUP
# 特定のウィンドウ/セッションが必要な場合、次の行のコメントを外して
# 必要に応じて編集する。
#XSTARTUP=/usr/bin/blackbox
# x-window/session-manager プログラムを起動
if [ -z "$XSTARTUP" ]; then
  if [ -x /usr/bin/x-session-manager ]; then
    XSTARTUP=x-session-manager
  elif [ -x /usr/bin/x-window-manager ]; then
    XSTARTUP=x-window-manager
  elif [ -x /usr/bin/x-terminal-emulator ]; then
    XSTARTUP=x-terminal-emulator
  fi
fi
# X window/session manager を自動実行
exec $XSTARTUP
</example>
そして (<tt>su -</tt> ではなく) <prgn>su</prgn> を ユーザの <prgn>xterm</prgn>
ウィンドウ上で起動します。するとこの <prgn>xterm</prgn> から起動する GUI
プログラムは root 権限で動きますが出力をユーザの X window 上に表示できます。
このトリックは標準の <file>/etc/X11/Xsession</file> が実行される限り
動きます。ユーザが <file>~/.xinitrc</file> や  <file>~/.xsession</file> 
をカスタマイズした場合、上で言及した環境変数 <tt>XAUTHORITY</tt> 
がこれらのスクリプトと同じように設定される必要があります。

<p>代わりに、<package>sudo</package> を上記の手順を自動化するために
使用できます。
<example>
$ sudo xterm
... 又は
$ sudo -H -s
</example>
ここで、<file>/root/.bashrc</file> に次の行が含まれる必要があります。
<example>
if [ $SUDO_USER ]; then
    sudo -H -u $SUDO_USER xauth extract - $DISPLAY | xauth merge -
fi
</example>
これはユーザのホームディレクトリが NFS マウントされている場合でさえも
うまく動きます。それは root が <file>.Xauthority</file> ファイルを読まない
ためです。
<p>
この目的のために用いられる専門プログラムとしては、
<package>kdesu</package>, <package>gksu</package>, 
<package>gksudo</package>, <package>gnome-sudo</package>, そして
<package>xsu</package> 
などが存在します。
同様の結果を得るために、
<file>/root/.Xauthority</file> のシンボリックリンクをユーザのホームディレクトリ
に作成することや、スクリプト <url id="&suxhome;" name="sux"> を使う、
root の初期化スクリプトに
"<tt>xauth merge ~<var>USER_RUNNING_X</var>/.Xauthority</tt>" を追加するなどの
他にいくつかの方法が使えます。
<p>
さらに知りたい場合は <url id="&deb-dev-su;" name="debian-devel mailing list"> 
をご覧下さい。
</sect1>

<sect1 id="xfs-tt">X での TrueType フォント
<p>
XFree86-4 での標準的な <prgn>xfs</prgn> は TrueType をうまく処理します。
XFree86-3 を使っている場合は、<prgn>xfs-xtt</prgn> のような
サードパーティのフォントサーバをインストールする必要があります。
<p>
TrueType フォントを使いたいアプリケーションが libXft にリンクされているか、
それとも libfreetype にリンクされているかを確認することだけが必要です。
(前もってコンパイルされた .deb を使っている場合はこれさえも心配する必要は
たぶん無いでしょう。)
<p>
まずフォントのサポートインフラを設定します。
<list compact>
<item><package>x-ttcidfont-conf</package> および
<package>defoma</package> パッケージをインストールする。
これは <file>fonts.scale</file> と <file>fonts.dir</file> ファイルの
自動生成を行います。
<example>
# apt-get install x-ttcidfont-conf
</example>
<item><file>/etc/X11/XF86Config-4</file> の <tt>Section "Files"</tt> を
次のように編集します。
<example>
Section "Files"
    FontPath  "/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType"
    FontPath  "/usr/share/fonts/truetype"
    FontPath  "/usr/lib/X11/fonts/CID"
    FontPath  "/usr/lib/X11/fonts/Speedo"
    FontPath  "/usr/lib/X11/fonts/misc"
    FontPath  "/usr/lib/X11/fonts/cyrillic"
    FontPath  "/usr/lib/X11/fonts/100dpi:unscaled"
    FontPath  "/usr/lib/X11/fonts/75dpi:unscaled"
    FontPath  "/usr/lib/X11/fonts/Type1"
EndSection
</example>
最初の行は、 XFree86 が &debian; パッケージからインストールした TrueType
フォントを使えるように設定します。
XFree86 が Type1 フォントのレンダリングをうまくできないので、Type1 
フォントのエントリは格下げされています。
ビットマップフォントに対する <tt>:unscaled</tt> のトリックは XF4 ではもはや
必要ありませんが、残しています。
<!-- version 4.2.1 の /usr/share/doc/xfree86-common/README.fonts.gz in から -->
<p>
<file>/etc/X11/XF86Config-4</file> の手動での変更を保存するには、
<ref id="manual-config-x"> にある指示に従ってください。
</list>
<p>
次に、DFSG フォントパッケージをインストールします。
<list compact>
<item>欧米TrueType フォント:
<list compact>
<item><package>ttf-bitstream-vera</package>: Bitstream, Inc により作成
された高品質な TrueType フォントセット。
<footnote>
これは Woody では得られませんが、Sarge からインストールできます。
</footnote>
<item><package>ttf-freefont</package>: UCS 文字セットをカバーする TrueType
フォント。
<item><package>ttf-thryomanes</package>: Latin,  Greek,  Cyrillic, および 
IPA をカバーする TrueType Unicode フォント。
</list>
<item>アジア圏のフォント:
<list compact>
<item><package>tfm-arphic-bsmi00lp</package>: Tex フォトメトリックデータ用の
中国 Arphic "AR PL Mingti2L Big5" TrueType フォント。
<item><package>tfm-arphic-bkai00mp</package>: Tex フォトメトリックデータ用の
中国 Arphic "AR PL KaitiM GB" TrueType フォント。
<item><package>tfm-arphic-gbsn00lp</package>: Tex フォトメトリックデータ用の
中国 Arphic "AR PL SungtiL GB" TrueType フォント。
<item><package>tfm-arphic-gkai00mp</package>: Tex フォトメトリックデータ用の
中国 Arphic "AR PL KaitiM GB" TrueType フォント。
<item><package>ttf-baekmuk</package>: 韓国の Baekmuk シリーズ TrueType フォント
<item><package>hbf-jfs56</package>: CJK 用の 中国 Jianti Fangsong 56x56 
ビットマップフォント (GB2312)
<item><package>hbf-cns40-b5</package>: CJK 用の中国 Fanti Song 40x40 
ビットマップフォント (Big5)
<item><package>hbf-kanji48</package>: CJK 用の日本語漢字 48x49 ビットマップ
フォント
</list>
</list>
<!-- Need to watch Japanese font issue -->
<p>
<strong>フリーな</strong> フォントは時々制限があるので、&debian; ユーザ
にとって商用の TrueType フォントをインストール又は共有することは
選択肢のひとつです。
この手順を容易にするためにいくつか便利なパッケージが作成されています。
<list compact>
<item><package>ttf-commercial</package>
<item><package>msttcorefonts (>1.1.0)</package>
<footnote>
Woody ではこのパッケージは Microsoft の website の変更により、
2002年 8月の時点で動きません。Woody をインストールしていても Sarge
のパッケージを使いましょう。
</footnote>
</list>
<strong>フリーな</strong> システムを非フリーなフォントで汚染することを
犠牲にするならば、本当に良い TrueType フォントの選択を行ってください。
<p>
&debian; におけるこれらのフォントパッケージは努力無しで動き、
通常の "コア" フォントシステムを使用する全ての X プログラムに対して
使用できるようになるべきです。X プログラムには Xterm、Emacs や
他のほとんどの 非 KDE 、非 GNOME アプリケーションが含まれます。
<p>
ついに、<prgn>xfontsel</prgn> を起動して fndry メニュで TrueType
フォントを選べば、"fmly" メニュにたくさんの黒色の選択可能なエントリ
が見付けられるはずです。
<p>
(GTK 1.2 がアンチエイリアスフォントレンダリングを行えるようにハックされた
libgdkxft0 を使っている) KDE 2.2 とGNOME 1.4 では、Xft1 を設定する必要が
あります。その上、Xft1 はかなり時代遅れになっており、基本的に 
GNOME 1.4 と KDE 2.2 でしか使われていません。
<file>/etc/X11/XftConfig</file> を編集し、
<example>
    dir "/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType"
</example>
のような行を他の dir 行の前に追加してください。
<p>
<footnote>
xft1 を他には使っていないので、この変更が効力を及ぼす前に X を
再起動する必要があるかどうか分かりません。"xftcache" が Xft1 キャッシュを
更新するはずだと記憶していますが、だれかが確認して私に知らせていただくと
ありがたい。
</footnote>
<p>
GNOME2 と KDE3 (Sarge リリース後) では、フォントを見付けるのに
Xft2 を使っている <package>fontconfig</package> を設定する必要があります。
<footnote>
<package>Fontconfig</package> は Woody には存在しません。
</footnote>
<package>fontconfig</package> に依存するパッケージは既に (間接的に)
このパッケージに Depends しているので、設定を行うのに何か特別なパッケージを
インストールする必要はありません。
<p>
まず、<file>/etc/fonts/fonts.conf</file> を見ます。下に示すような行
があるはずです。無い場合は、<file>/etc/fonts/local.conf</file> を開き、
下の内容を &lt;fontconfig&gt; の行のすぐ後に追加します。
<example>
    &lt;dir&gt;/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType&lt;/dir&gt;
</example>
<p>
<package>fontconfig</package> はこの変更に直ちに対応し、
"fc-list" により新しいフォントが追加されるはずです。
<package>fontconfig</package> の他の巧妙な機能によって、
フォントを <file>~/.fonts/</file> に入れるだけで fontconfig を
使用するプログラムは直ちにこれらのフォントを使用可能になります。
<p>
&debian; パッケージを使わずに X 上で新しい TrueType フォントセットを
手動でインストールした場合、次を実行します。
<example>
# xset fp rehash
</example>
これにより XFree86 がこのディレクトリの内容を再び見て新しいフォントを
取得するようになります。

<sect1 id="ss-browser">X でのウェブブラウザ
<p>
Woody リリース時点でグラフィカルに表示可能なウェブブラウザパッケージ
がいくつか存在します。
<list compact>
<item><package>mozilla</package> The Mozilla ブラウザ (新規)
<item><package>galeon</package> Gnome UI を持つ Mozilla ベースのブラウザ (新規)
<item><package>konqueror</package> KDE ブラウザ
<item><package>dillo</package> GTK ブラウザ
<item><package>amaya-gtk</package> W3C リファレンスブラウザ
<item><package>amaya-lesstif</package> W3C リファレンスブラウザ
<item><package>netscape-...</package> (多数、古くなっている)
<item><package>communicator-...</package> (多数、古くなっている)
<item>などなど。
</list>
<package>mozilla</package> のバージョンと <package>galeon</package>
のバージョンは同じである必要があります。これらは UI が異なりますが、
Gecko HTML レンダリングエンジンを共有しているからです。
<p>
<package>mozilla</package> や <package>galeon</package> のようなブラウザの
プラグインはプラグインディレクトリに手動で "<tt>*.so</tt>" をインストールし、
ブラウザを再起動することにより有効にできます。
<p>
プラグイン一覧
<list compact>
<item>Java プラグイン: <url id="&javasunhome;"> からバイナリの "J2SE" を
インストール。
<item>Flash プラグイン: <url id="&flashhome;"> からバイナリの 
"Macromedia Flash Player 5" をインストール。
<item><package>freewrl</package>: VRML ブラウザと Netscape プラグイン。
<item>など。
</list>
</sect1>

<!-- CJK and X moved to bottom with different name to locale section -->

</sect>

<sect id="ssh">SSH
<p>
SSH (Secure SHell) はインターネットに接続するための安全な方法です。
OpenSSH と呼ばれるフリー版の SSH は &debian; では <package>ssh</package>
パッケージとして得られます。

<sect1 id="ssh-basics">SSH の基礎
<p>
まず OpenSSH サーバとクライアントをインストールします。
<example>
# apt-get update && apt-get install ssh
</example>
<file>/etc/apt/source.list</file> に non-US エントリが必要となります。
OpenSSH サーバを起動したい場合は <file>/etc/ssh/sshd_not_to_be_run</file>
が存在する必要があります。
<p>
SSH には二つの認証プロトコルが存在します。
<list>
<item>SSH プロトコル version 1: 
 <list compact>
<item>Potato はこのプロトコルしかサポートしていません。
<item>使用可能な認証方法
  <list compact>
<item>RSAAuthentication: RSA 認証キーベースのユーザ認証
<item>RhostsAuthentication: .rhosts ベースのホスト認証
 (危険であり無効にされている)
<item>RhostsRSAAuthentication: RSA ホストキーと .rhosts 認証の組合せ (無効)
<item>ChallengeResponseAuthentication: RSA challenge-response 認証
<item>PasswordAuthentication: パスワードベースの認証
  </list>
 </list>
<item>SSH プロトコル version 2: 
 <list compact>
<item>Woody 以降のバージョンはこれを主要なプロトコルとして使っている。
<item>使用可能な認証方法
  <list compact>
<item>PubkeyAuthentication: 公開鍵ベースのユーザ認証
<item>HostbasedAuthentication: <file>.rhosts</file> 又は
 <file>/etc/hosts.equiv</file> による認証と公開鍵クライアントホスト認証の
 組合せ (無効)
<item>ChallengeResponseAuthentication: challenge-response 認証
<item>PasswordAuthentication: パスワードベースの認証
  </list>
 </list>
</list>

<p>
Woody や他の非 &debian; システムに移行しようする場合、これらのプロトコルの違い
に注意してください。
<p>
詳細は <file>/usr/share/doc/ssh/README.Debian.gz</file> や
<manref name="ssh" section="1">,
<manref name="sshd" section="8">,
<manref name="ssh-agent" section="1">, 並びに
<manref name="ssh-keygen" section="1"> をご覧下さい。

<p>
主要な設定ファイルを次に挙げます。

<list>

<item><file>/etc/ssh/ssh_config</file>: SSH クライアント標準
 <manref name="ssh" section="1">をご覧下さい。 注目に値すべきエントリ
 は次のとおり。

 <list compact>
<item><tt>Host</tt>: キーワードの後にあたえたパターンの一つにマッチしたホスト
 のみに対して (次のホストキーワードまで) 宣言により制限する。
<item><tt>Protocol</tt>: SSH プロトコルバージョンを指定する。
 標準は "2.1"。
<item><tt>PreferredAuthentications</tt>: SSH2 クライアント認証方法を指定する。
 標準は "hostbased,publickey,keyboard-interactive,password"。
<item><tt>PasswordAuthentication</tt>: パスワードを使ってログインしたい場合、
 これが <tt>no</tt> にセットされていないことを確認してください。
<item><tt>ForwardX11</tt>: 標準では無効。これはコマンドラインオプション
 <tt>-X</tt> により上書き可能です。
 </list>

<item><file>/etc/ssh/sshd_config</file>: SSH サーバの標準。
 <manref name="sshd" section="8"> をご覧下さい。注目に値すべきエントリは
 次のとおり。

 <list compact>
<item><tt>ListenAddress</tt>: <prgn>sshd</prgn> が listen すべきローカル
 アドレスを指定。複数のオプションが許される。
<item><tt>AllowTcpForwarding</tt>: 標準では無効。
<item><tt>X11Forwarding</tt>: 標準では無効。
 </list>

<item><file>$HOME/.ssh/authorized_keys</file>: クライアントがこのホストで
本アカウントに接続するために使う標準の公開鍵のリスト。
<manref name="ssh-keygen" section="1"> をご覧下さい。

<item><file>$HOME/.ssh/identity</file>: 
<manref name="ssh-add" section="1"> と<manref name="ssh-agent" section="1"> 
をご覧下さい。
</list>

<p>
次のコマンドは <prgn>ssh</prgn> 接続をクライアントから開始します。
<example>
$ ssh username@hostname.domain.ext
$ ssh -1 username@hostname.domain.ext # Force SSH version 1
$ ssh -1 -o RSAAuthentication=no -l username foo.host
    # SSH1 でパスワードを強制
$ ssh -o PreferredAuthentications=password -l username foo.host
    # SSH2 でパスワードを強制。
</example>
ユーザにとって、<prgn>ssh</prgn> は (^] を用いて爆撃しない) 賢くより安全な
<prgn>telnet</prgn> として働きます。

</sect1>

<sect1 id="ssh-forward">SMTP/POP3 トンネル用のポートフォワード
<p>
<prgn>ssh</prgn> を通して
localhost の port 4025 から <var>remote-server</var> の port 25 並びに
localhost の port 4110 から <var>remote-server</var> の port 100 に接続
するパイプを構築するには、ローカルマシンで次を実行します。
<example>
# ssh -q -L 4025:remote-server:25 4110:remote-server:110 \
           username@remote-server
</example>
これはインターネットを通して SMPT/POP3 サーバに接続するための安全な手段です。
リモートホストの <file>/etc/ssh/sshd_config</file> の 
<tt>AllowTcpForwarding</tt> エントリを <tt>yes</tt> にセットしてください。
</sect1>

<sect1 id="ssh-rsa">パスワードの入力が少ない接続 &ndash; RSA
<p>
RSAAuthentication (SSH プロトコル) 又は PubkeyAuthentication (SSH2 プロトコル)
を用いてリモートシステムごとのパスワードを覚えるのを避けられます。
<p>
リモートホストで、<file>/etc/ssh/sshd_config</file> の各エントリを
"RSAAuthentication yes" 又は "PubkeyAuthentication yes" にセットします。
<p>
そしてローカルで認証キーを生成し、リモートシステムに公開鍵をインストールします。<example>
$ ssh-keygen          # RSAAuthentication: SSH1 用の RSA 鍵
$ cat .ssh/identity.pub | ssh user1@remote \
        "cat - &gt;&gt;.ssh/authorized_keys"
...
$ ssh-keygen -t rsa   # PubkeyAuthentication: SSH2 用の RSA 鍵
$ cat .ssh/id_rsa.pub | ssh user1@remote \
        "cat - &gt;&gt;.ssh/authorized_keys"
...
$ ssh-keygen -t dsa   # PubkeyAuthentication: SSH2 用の DSA 鍵
$ cat .ssh/id_dsa.pub | ssh user1@remote \
        "cat - &gt;&gt;.ssh/authorized_keys"
</example>
"<tt>ssh-keygen -p</tt>" を用いて後にパスフレーズを変更できます。
接続できるかテストして必ず設定を検証してください。
問題がある場合は、"<tt>ssh -v</tt>" を使ってください。
<p>
ホスト制限や特定のコマンドを起動するために <prgn>authorized_keys</prgn> に
あるエントリにオプションを追加できます。詳細は
<manref name="sshd" section="8"> をご覧下さい。
<p>
SSH2 には <tt>HostbasedAuthentication</tt> 機能があることに注意してください。
これを動かすには、サーバマシンの <file>/etc/ssh/sshd_config</file> と
クライアントマシンの <file>/etc/ssh/ssh_config</file> 又は
<file>$HOME/.ssh/config</file> の両方を <tt>yes</tt> にセットする
必要があります。
</sect1>

<sect1 id="ssh-client">他の SSH クライアントの扱い
<p>
非 Unix ライクプラットフォームのためのフリーな SSH クライアントは
あまり存在しません。
<taglist>
<tag>Windows
<item><url id="&puttyhome;" name="puTTY"> (GPL)
<tag>Windows (cygwin)
<item><url id="&cygwinhome;" name="cygwin"> (GPL) にある SSH
<tag>Macintosh Classic
<item><url id="&macsshhome;" name="macSSH"> (GPL)
 [Mac OS X には OpenSSH が含まれていることに注意してください。Terminal
 アプリケーション上で <tt>ssh</tt> を使ってください。]
</taglist>
<url id="&sfdochome;" name="SourceForge.net, site documentation"> の
"6. CVS Instructions" もご覧下さい。

<sect1 id="ssh-agent"><prgn>ssh-agent</prgn> のセットアップ
<p>
パスフレーズで SSH 認証鍵を保護する方がより安全です。パスフレーズが
セットされていなかった場合、<tt>ssh-keygen -p</tt> を使ってセットしてください。
<p>
リモートホストの <file>~/.ssh/authorized_keys</file> に
パスワードを用いてリモートホストに接続して <ref id="ssh-rsa"> 
に記述されているように公開鍵 (すなわち、<file>~/.ssh/id_rsa.pub</file>) 
を置いてください。
<example>
$ ssh-agent bash # 又は代わりに zsh/tcsh/pdksh プログラムを起動する。
$ ssh-add ~/.ssh/id_rsa
Enter passphrase for /home/osamu/.ssh/id_rsa:
Identity added: /home/osamu/.ssh/id_rsa (/home/osamu/.ssh/id_rsa)
$ scp <var>foo</var> <var>user@remote.host:foo</var>
 ... ここからはパスフレーズが必要 :-)
$^D
 ... ssh-agent セッションを終了。
</example>
X サーバの場合、通常 &debian; の起動スクリプトは <prgn>ssh-agent</prgn>
を親プロセスとして実行します。ですので <prgn>ssh-add</prgn> を一度だけしか
実行する必要がありません。
<p>
より詳しくは、<manref name="ssh-agent" section="1"> と
<manref name="ssh-add" section="1"> をご覧下さい。
</sect1>

<sect1 id="ssh-trouble">SSH のトラブルシュート
<p>
問題が発生した場合、設定ファイルのアクセス権をチェックし、<prgn>ssh</prgn>
を "<tt>-v</tt>" オプションつきで実行してください。
<p>
root であってファイアーウォールのトラブルが発生した場合、 "<tt>-P</tt>" 
オプションを使ってください。これはサーバのポート 1 から 1023 の使用を
避けます。
<p>
リモートのサイトへの <prgn>ssh</prgn> 接続が突然動かなくなった場合、
それはシステム管理者のやっつけ仕事のせいかもしれませんし、最もありえるのは
システムメンテナンス中に <prgn>host_key</prgn> が変更されたためです。
このような原因で接続が停止し、だれもハックしてリモートホストを偽造しようと
していないことを確認してから、<prgn>host_key</prgn> エントリを
ローカルマシンの <file>$HOME/.ssh/known_hosts</file> から削除して
接続を回復できます。
</sect1>

</sect>

<sect id="mail">メール
<p>
メールの設定は三つのカテゴリに分割されます。
<list>
<item>mail transfer agent (MTA): <prgn>exim4</prgn>, <prgn>postfix</prgn>, 
 <prgn>sendmail</prgn>, <prgn>qmail</prgn>, <prgn>ssmtp</prgn>,
 <prgn>nullmailer</prgn> など
<item>mail utilities: <prgn>procmail</prgn>, <prgn>fetchmail</prgn>,
<prgn>mailx</prgn>, <prgn>crm114</prgn>,  など
<item>mail user agent (MUA): <prgn>mutt</prgn>,
<prgn>emacs</prgn>+<prgn>gnus</prgn> など
</list>

<sect1 id="mta">Mail transport agents (MTAs)
<p>
フル機能の MTA としては、Woody では <package>exim</package>を、Sarge では
<package>exim4</package> を使っています。
<footnote>
次の章では <prgn>exim</prgn> を例として使っています。
Sarge の場合は必要に応じて <prgn>exim4</prgn> に置き換えてください。
</footnote>
リファレンス:
<list compact>
<item><package>exim</package> 用の <package>exim-doc</package> と
<package>exim-doc-html</package> パッケージ。
<item><package>exim4</package> 用の <package>exim4-doc-info</package> と
<package>exim-doc-html</package> パッケージ。
<item><url id="&eximhome;">
</list>
セキュリティを心配している場合の唯一の妥当な代替 MTA は 
<package>postfix</package> です。<package>sendmail</package> と
<package>qmail</package> も &debian; パッケージとして得られますが、
お薦めできません。
<p>
ノート PC などのサテライトシステムであって MTA のリレー機能が必要ない場合、
次に挙げる軽量なパッケージのどれかの使用を考えても良いかもしれません。
<list compact>
<item><prgn>ssmtp</prgn>: SMTP 接続とエイリアス機能が必要な場合に良い。又は
<item><prgn>nullmailer</prgn>: スプール可能だがエイリアス機能は無い。
</list>
現時点では、私はノート PC をパーソナルワークステーションとして
使う場合でも、<prgn>exim</prgn> が最適と考えています。
<p>
これらの衝突するパッケージをインストールする場合、<prgn>exim</prgn> を
削除する必要があるかもしれません。
<example>
# dpkg -P --force-depends exim
# apt-get install nullmailer         # 又は ssmtp
</example> 

<sect2 id="exim-smart">Smarthost
<p>
消費者レベルのサービスの接続をしているホスト上で <prgn>exim4</prgn> 
又は <prgn>exim</prgn> を起動している場合、ISP や他の手段で提供されている smarthost を
通じてメールを送るようにしてください。
<footnote>
ブロードバンドルータ経由でダイアルアップ, DSL, ケーブルサービス又は LAN
接続を行っているホストに対してこのルールに従う必要があります。ホストが
固定 IP を持っている場合でも、このルールに従うのは依然良い考えです。
ほとんどのワークステーションやホームサーバはこのカテゴリに属します。
</footnote>
いくつかの理由があります。
<list compact>
<item>通常 ISP の smarthost はより信頼できる接続環境を持っているので
SMTP リトライを確実にできます。
<item>多分ダイアルアップの spam リストによりブロックされるであろう
<strong>ダイナミック IP アドレス</strong> からメールを直接送るのを
避けられます。
<item>複数の送信者にメールを送るためのローカルのバンド幅を節約できます。
</list>
<p>
想像できる唯一の例外としては次があげられます。
<list compact>
<item>ISP の SMTP サービスのトラブルの際の緊急手段。
<item>教育目的の実験台として。
<item>営業目的のホストサーバにするため。
</list>

<sect2 id="exim-base">Exim の基本的な設定
<p>
<prgn>exim4</prgn> 又は <prgn>exim</prgn> を MTA として使うには、
次の設定を行います。
<example>
/etc/exim/exim.conf     "eximconfig" を実行し、編集 (exim)
/etc/exim4/*            "dpkg-reconfigure exim4" を実行し、編集 (exim4)
/etc/inetd.conf         exim をデーモンとして起動するために smtp をコメントアウトする
/etc/email-addresses    外に出すメールのためのドメインリストを追加
</example>
<prgn>exim4</prgn> 又は <prgn>exim</prgn> を <tt>-brw, -bf, -bF, など</tt> の
オプション付きで用いてフィルタをチェックしてください。

<sect2 id="addr-catchall">Exim の元で存在しないメールアドレスのための物置を設定する
<p>
<file>/etc/exim/exim.conf</file> (Woody 以降) の DIRECTORS パートにおいて、
末尾 (localuser: director の後) にその前の director が解決できない
全てのアドレスにマッチするごみ箱 director を追加してください。
(Miquel van Smoorenburg による)
<example>
catchall:
  driver = smartuser
    new_address = <var>webmaster@mydomain.com</var>
</example>
<p>
各仮想ドメインなどに対するより詳しいレシピを設定したい場合、
<file>/etc/exim/exim.conf</file> の末尾に次の内容を追加してください。
(あまりテストしていません)
<example>
*@yourdomain.com ${lookup{$1}lsearch*{/etc/email-addresses} \
        {$value}fail} T
</example>
そして、<file>/etc/email-addresses</file> に "*" エントリを追加してください。
</sect2>

<sect2 id="addr-rewrite">Exim の元で送信メールに対してアドレス書き換えを設定する
<p>
<!-- Derrick 'dman' Hudson dman@dman.ddts.net -->
適切な "From:" ヘッダを生成するために送信メールのアドレス書き換えを行う
には、<prgn>exim</prgn> を用いて <file>/etc/exim/exim.conf</file> の末尾
近くに次のような設定を行うことにより行えます。
<example>
*@host1.something.dyndns.org \
  "${if eq {${lookup{$1}lsearch{/etc/passwd}{1}{0}}} {1}  \
   {$0}{$1@somethig.dyndns.org}}"  frFs
</example>
これは <tt>*@host1.something.dyndns.org</tt> にマッチする全アドレスを
書き換えます。
<enumlist>
<item>local part ($1) がローカルユーザかどうかを <file>/etc/password</file> 
を通じて検索する。
<item>ローカルユーザである場合、アドレスを最初の場所 ($0) にあったものに
書き換えます。
<item>ローカルユーザでない場合は、ドメイン部分を書き換えます。
</enumlist>

<sect2 id="smtp-aauth">Exim の元で SMTP 認証を設定する。
<p>
yahoo.com のような SMTP サーバは SMTP 認証を要求します。
<file>/etc/exim/exim.conf</file> を次のように設定します。
<example>
remote_smtp:
  driver = smtp
  authenticate_hosts = smtp.mail.yahoo.com
...

smarthost:
  driver = domainlist
  transport = remote_smtp
  route_list = "* smtp.mail.yahoo.com bydns_a"
...

plain:
  driver = plaintext
  public_name = PLAIN
  client_send = "^cmatheson3^this_is_my_password"
</example>
最後の行をダブルクォートするのを忘れないでください。

<sect1 id="fetchmail">メールを取得する &ndash; Fetchmail
<p>
<prgn>fetchmail</prgn> はデーモンモードで起動され、メールを ISP の
POP3 アカウントから取得し、ローカルのメールシステムに転送します。
設定ファイルは次のとおり。
<example>
/etc/init.d/fetchmail   
/etc/rc?.d/???fetchmail 標準では優先度 30 で update-rc.d fetchmail を起動する
/etc/fetchmailrc        設定ファイル (chmod600 のアクセス権限で fetchmail により所有される)
</example>
<p>
Potato で <prgn>init.d</prgn> スクリプトから <prgn>fetchmail</prgn> を
デーモンモードで起動する方法に関する情報は混乱しています。
(Woody では既に修正されています) <url id="&examples;" name="example scripts">
にある <file>/etc/init.d/fetchmail</file> と <file>/etc/fetchmailrc</file>
のサンプルをご覧下さい。
<p>
メールのヘッダが ISP のメーラのせいで ^M で汚染されている場合、
<file>$HOME/.fetchmailrc</file> に "stripcr" をオプションとして
次のように追加してください。
<example>
options fetchall no keep stripcr
</example>
</sect1>

<sect1 id="crm114"><package>crm114</package> でのスパム処理
<p>
<package>crm114</package> パッケージは CRM114 で書かれた
<prgn>/usr/share/crm114/mailfilter.crm</prgn> スクリプト
を提供します。このスクリプトはスパム(不要メール)とハム(有用メール)
を流し込むと非常に効率的に訓練できるスパムフィルターを提供します。
<p>
CRM114 はフィルターを書くために設計された小さな言語です。
スーパーパワーを与えた grep のような物と考えて下さい。
<manref name="crm" section="1"> を参照してください。
</sect1>

<sect1 id="procmail">メール処理 &ndash; Procmail
<p>
<prgn>procmail</prgn> はローカルのメール配信およびフィルタプログラムです。
本プログラムを使う際にはアカウント毎に <file>$HOME/.procmailrc</file>
を作成する必要があります。例は <url id="&examples;" name="_procmailrc">
にあります。
</sect1>

<sect1 id="mutt">メールを読む &ndash; Mutt
<p>
mail user agent (MUA) として <prgn>mutt</prgn> を <prgn>vim</prgn> と
組み合わせて使ってください。
<file>~/.muttrc</file> でカスタマイズできます。例えば、
<example>
# use visual mode and "gq" to reformat quotes
set editor="vim -c 'set tw=72 et ft=mail'"
#
# header weeding taken from the manual (Sven's Draconian header weeding)
#
ignore *
unignore from: date subject to cc
unignore user-agent x-mailer
hdr_order from subject to cc date user-agent x-mailer
auto_view application/msword
....
</example>
<p>
HTML メールと MS Word 添付ファイルをインラインで表示するため、次を
<file>/etc/mailcap</file> 又は <file>$HOME/.mailcap</file> に追加してください。
<example>
text/html; lynx -force_html &percnt;s; needsterminal;
application/msword; /usr/bin/antiword '&percnt;s'; copiousoutput;
description="Microsoft Word Text"; nametemplate=&percnt;s.doc
</example>

</sect1>

</sect>

<sect id="l10n">国際化
<p>
&debian; は国際化されており、言語や地域差に関するサポートが充実しつつあります。
次のサブセクションは &debian; が現在サポートする多様性の形態の一部をリストし、
それに続くサブセクションにおいて地域に従って異なる日付表示、数字や金銭の
フォーマットなどの円滑な入出力が可能となるように使用環境を
カスタマイズするプロセスである <strong>地域化</strong> について議論します。

<sect1 id="languages">ローカライゼーションの基本
<p>
ローカライゼーションと各国語サポートにはいくつかの観点があります。

<sect2 id="keyboard">キーボードのローカライゼーション
<p>
&debian; は24程のキーマップが配布されています。
Woody でのキーボードを再設定するには、次を実行します。
<list compact>
<item><tt>dpkg-reconfigure --priority=low console-data # 端末</tt>
<item><tt>dpkg-reconfigure --priority=low xserver-xfree86   # XF4</tt>
<item><tt>dpkg-reconfigure --priority=low xserver-common-v3 # XF3</tt>
</list>
</sect2>

<sect2 id="data-stream">データファイルのローカライゼーション
<p>
膨大な Debian ソフトウェアパッケージの大部分は glibc に存在する
<strong>ロケール</strong> 技術 により提供される LC_CTYPE 環境変数
を通して非 US-ASCII 文字データの操作をサポートしています。
   
    <list compact>
    <item>8-bit クリーン: 実際には全プログラムがサポート
    <item>他の Latin 文字セット (例えば ISO-8859-1 や ISO-8859-2): ほとんどの
    プログラムがサポート
    <item>中国語、日本語、韓国語のようなマルチバイト言語:
    多くの新しめのアプリケーションがサポート
    </list>
</sect2>

<sect2 id="display">表示のローカライゼーション
<p>
X は UTF-8 を含むあらゆるコーディングを表示できますし、全てのフォントを
サポートします。全ての 8 ビットフォントだけでなく、中国語、日本語や韓国語
のような 16 ビットフォントも含まれます。マルチバイト文字の入力メソッドは
<ref id="x-input"> メカニズムによりサポートされています。
<ref id="x-cjk"> と <ref id="x-utf-8"> をご覧下さい。
<p>
日本語 EUC コードは <package>kon2</package> パッケージを通して
(S)VGA グラフィックコンソールにも表示できます。<package>jfbterm</package>
という新しい代わりになる日本語ディスプレイがありますが、これはフレームバッファ
端末も使っています。これらの端末環境では、日本語の入力メソッドが
アプリケーションによりサポートされている必要があります。
Emacs で日本語を入力するには、<package>egg</package> パッケージを、
Vim 環境で日本語を入力するには、日本語化された <package>jvim</package>
パッケージを使ってください。
<p>
非 Unicode フォントを X にインストールすると、X においてあらゆる
エンコーディングのドキュメントを表示するのに役立ちます。ですから、
フォントのエンコーディングについてあまり心配する必要はありません。
</sect2>

<sect2 id="translation">メッセージやドキュメンテーションのローカライゼーション
<p>
エラーメッセージ、標準的なプログラムの出力、メニュ、そしてマニュアルページ
などの &debian; システムで表示されるテキストメッセージやドキュメントの多くは
既に翻訳されています。現在、ドイツ語、スペイン語、フィン語、フランス語、
ハンガリー語、イタリア語、日本語、韓国語、ポーランド語、ポルトガル語、
中国語、そしてロシア語のマニュアルページが <tt>manpages-<var>LANG</var></tt>
パッケージ (ここで <var>LANG</var> は 2文字のコンマで分けられた ISO 
country code のリストです。取得可能な Unix マニュアルページのリストを得る
には <tt>apt-cache search manpages-|less</tt> を使ってください。)
を通じて供給されています。
<p>
NLS マニュアルページにアクセスするには、ユーザは環境変数 LC_MESSAGES を
適切な文字列にセットする必要があります。例えば、イタリア語のマニュアルページ
の場合は、LC_MESSAGES を <tt>it</tt> にセットする必要があります。
すると <prgn/man/ プログラムは <file>/usr/share/man/it/</file> の下にある
イタリア語のマニュアルページを検索します。
</sect2>
</sect1>

<sect1 id="locales">ロケール
<p>
Debian は <strong>ロケール</strong> 技術をサポートしています。ロケールは
プログラムが文字セット、時刻や時間のフォーマット、通貨文字などのような
ローカルのしきたりに従って適切な出力や機能を供給することを可能とするための
機構です。例えば、米国英語とドイツのロケールの両方をシステムにインストール
したと仮定すると、多くのプログラムのエラーメッセージは 2ヵ国語にできます。
<example>
$ LANG="en_US" cat foo
cat: foo: No such file or directory
$ LANG="de_DE" cat foo
cat: foo: Datei oder Verzeichnis nicht gefunden
</example>
Glibc はこの機能のプログラムへのサポートをライブラリとして供給します。
<manref name="locale" section="7"> をご覧下さい。

<sect1 id="base-locale">ロケール入門
<p>
完全なロケールの説明は 3つの部分、すなわち  <tt>xx_YY.ZZZZ</tt>
から構成されます。
<list compact>
<item><strong><tt>xx</tt></strong>: ISO 639 言語コード (小文字)
<item><strong><tt>YY</tt></strong>: ISO 3166 国コード (大文字)
<item><strong><tt>ZZZZ</tt></strong>: コードセット、すなわち文字セットや
エンコードの識別子。
</list>
<p>
言語コードと国コードについては、<tt>info gettext</tt> にある適切な説明
をご覧下さい。
<p>
このコードセット部分はクロスプラットフォーム互換性を達成するために
全ての <tt>-</tt> を削除し、全ての文字を小文字に変換することにより
内部で正規化されることがあります。典型的なコードセットは次のとおりです。
<list compact>
  <item><strong>UTF-8</strong>: 全ての領域のための Unicode、ほとんどは 1-3 Octed(新しいデファクトスタンダード。)
  <item><strong>ISO-8859-1</strong>: 西ヨーロッパ (古いデファクトスタンダード)
  <item><strong>ISO-8859-2</strong>: 東ヨーロッパ (ボスニア、クロアチア、チェコ、ハンガリー、ポーランド、ルーマニア、セルバニア、スロバキア、スロベニア)
  <item><strong>ISO-8859-3</strong>: マルタ語
  <item><strong>ISO-8859-5</strong>: マケドニア語、セルビア語
  <item><strong>ISO-8859-6</strong>: アラビア語
  <item><strong>ISO-8859-7</strong>: ギリシャ語
  <item><strong>ISO-8859-8</strong>: ヘブライ語
  <item><strong>ISO-8859-9</strong>: トルコ語
  <item><strong>ISO-8859-11</strong>: タイ語 (=TIS-620)
  <item><strong>ISO-8859-13</strong>: ラトビア語、リトアニア語、マオリ語
  <item><strong>ISO-8859-14</strong>: ウェールズ語
  <item><strong>ISO-8859-15</strong>: ユーロを用いた西ヨーロッパ
  <item><strong>KOI8-R</strong>: ロシア語
  <item><strong>KOI8-U</strong>: ウクライナ語
  <item><strong>CP1250</strong>: チェコ語、ハンガリー語、ポーランド語
  (MS Windows が起源)
  <item><strong>CP1251</strong>: ブルガリア語、ベラルーシ語 (MS Windows が起源)
  <item><strong>eucJP</strong>: Unix スタイルの日本語 (=ujis)
  <item><strong>eucKR</strong>: Unix スタイルの韓国語
  <item><strong>GB2312</strong>: zh_CN 用の Unix スタイルの簡体字 (=GB, =eucCN)   <item><strong>Big5</strong>: zh_TW 用の繁体字
  <item><strong>sjis</strong>: Microsoft スタイルの日本語 (シフト JIS) 
</list>
基本的なエンコーディングシステムの jargon の意味については次のとおり。
<list compact>
<item><strong>ASCII</strong>: 7 ビット (0-0x7f)
<item><strong>ISO-8859-?</strong>: 8 ビット (0-0xff)
<item><strong>ISO-10646-1</strong>: 国際文字集合 (UCS) (31 ビット,0-0x7fffffff)
<item><strong>UCS-2</strong>: 2個のオクテッドを用いた 16 ビットの UCS
(Unicode: 0-0xffff)
<item><strong>UCS-4</strong>: 4個のオクテッドを使った UCS (UCS: 0-0x7fffffff)
<item><strong>UTF-8</strong>: 1-6 オクテッドでエンコードされた UCS
(ほとんどは 3 オクテッド)
<item><strong>ISO-2022</strong>: エスケープシーケンス付きの 7 ビット(0-0xff) 
ISO-2022-JP は日本語のメールで最もポピュラーなエンコーディングです。
<item><strong>EUC</strong>: 8 ビット + 16 ビットの組合せ (0-0xff) で
Unix スタイル。
<item><strong>Shift-JIS</strong>: 8 ビット + 16 ビットの組合せ (0-0xff)、
Microsoft スタイル。
</list>
ISO-8859-?, EUC, ISO-10646-1, UCS-2, UCS-4, そして UTF-8 は ASCII コード
を 7 ビット文字のために共有しています。EUC と シフト JIS は
最上位ビットが立った (0x80-0xff) 文字をその部分のエンコードが 16 ビット
であることを示すために使います。UTF-8 も最上位ビットが立った文字 (0x80-0xff)
をこれが非 7 ビット文字シーケンスバイトであり、これが非 ASCII 文字を操作
するのに最適なエンコーディングシステムであることを示すために使います。
<p>
Unicode の実装でバイトオーダーが異なるものがあることに注意してください。
<list compact>
<item><strong>標準の UCS2, UCS4</strong>: ビッグエンディアン
<item><strong>Microsoft UCS-2, UCS-4</strong>: x86 用のリトルエンディアン (マシン依存)
</list>
各種文字セット間の変換に関しては <ref id="recode"> を御覧下さい。
より詳しくは <url id="&intro-i18n;" name="Introduction to i18n"> 
をご覧下さい。

<sect1 id="activate-locales">ロケールサポートを有効にする
<p>
&debian; は全ての使用可能なロケールを前もってコンパイルして 
<strong>いません</strong>。(標準の "C" ロケールを除いて)
システムにコンパイルされているロケールの種類を知るには、
<file>/usr/lib/locale</file> をチェックしてください。
必要なロケールがコンパイルされていない場合には、2つのオプションがあります。
<list compact>
 <item><file>/etc/locale.gen</file> を編集して望みのロケールを追加しましょう。
 そして root で <prgn>locale-gen</prgn> を実行し、ロケールを
 コンパイルします。<manref name="locale-gen" section="8"> と
 このマニュアルページの "SEE ALSO" セクションにリストされた
 マニュアルページをご覧下さい。
 <item><package>locales</package> パッケージの再設定のために
 <tt>dpkg-reconfigure locales</tt> を起動しましょう。又は、このパッケージが
 まだインストールされていない場合は、<package>locales</package> を
 インストールして debconf インターフェースを起動して必要なロケールを選択し、
 データベースをコンパイルします。
 <!--  XXX FIXME XXX 
 <item>ユーザアカウントから <prgn>localedef</prgn> を手動で起動し、
 ロケールデータベースをコンパイルしてこれを <tt>LOC_PATH</tt> 
 環境変数にセットすることにより使用します。例えば <tt>en_GB.UTF-8</tt>
 の場合は次のようになります。
   <example>
$ localedef -v -c -i en_GB -f UTF-8 <var>somewhere/</var>en_GB.UTF-8
$ export LOC_PATH=<var>somewhere/</var>
   </example>
 -->
</list>

<sect1 id="env-locale">特定のロケールを有効にする
<p>
次に示す環境変数はこの順番で評価され、特定のロケール値をプログラムに提供します。<enumlist>
<item>LANGUAGE: この環境変数はコロンで分割され、優先順位の高い順に並んだ
ロケール名のリストです。POSIX ロケールが "C" 以外の値にセットされている場合
のみ使われます。[Woody での説明。Potato では常に POSIX ロケールより高い
優先度を持つ] (GNU 拡張)
<item>LC_ALL: これが null ではない場合、全てのロケールカテゴリに対して
使用されます。(POSIX.1) 通常 "" (null) です。
<item>LC_*: これが null ではない場合、この値は対応するカテゴリに対して
使用されます。(POSIX.1) 通常 "C" です。
<p>
      LC_* variables には次の値が存在します。
 <list compact>
<item>LC_CTYPE: 文字の種類とエンコーディング。
<item>LC_COLLATE: ソートの順番。
<item>LC_TIME: 日付と時間の表示フォーマット。
<item>LC_NUMERIC: 数字のフォーマット。
<item>LC_MONETARY: 通貨のフォーマット。
<item>LC_MESSAGES: 情報およびダイアログメッセージと対話式な応答のフォーマット。
<item>LC_PAPER: 紙サイズ。
<item>LC_NAME: 名前のフォーマット。
<item>LC_ADDRESS: アドレスのフォーマットと位置情報。
<item>LC_TELEPHONE: 電話番号フォーマット。
<item>LC_MEASUREMENT: 測定単位。 (メートル又はその他の単位)
<item>LC_IDENTIFICATION: ロケール情報に関するメタデータ。
 </list>
<item>LANG: これが null でなく、LC_ALL が未定義の場合、この値は
未定義の値の全ての LC_* ロケールカテゴリに対して使われます。(POSIX.1)
通常 "C" です。
</enumlist>
(Netscape4 などの) いくつかのアプリケーションは LC_* の設定を無視する
ことに注意してください。
<p>
<prgn>locale</prgn> プログラムは有効なロケールの設定と使用可能な
ロケールを表示できます。<manref name="locale" section="1"> をご覧下さい。
(<tt>locale -a</tt> はシステムが存在を知っている全てのロケールを表示しますが、
これは全てがコンパイル済みであることを意味 <em>しない</em> ことに注意下さい。
<ref id="activate-locales"> をご覧下さい。)


<sect1 id="ISO-locale">ISO 8601 日付表示ロケール
<p>
国際的なデータ標準である <tt>yyyy-mm-dd</tt> 形式 (ISO 8601 データフォーマット) 
の日付のロケールのサポートは <tt>en_DK</tt> すなわち "English in Denmark"
と呼ばれるロケールによりサポートされています。これはちょっとしたジョークです。
これは端末上で <prgn>ls</prgn> のためにしか動かないようです。

<!-- beyond locale moved to below -->

<sect1 id="iso-8859-1">米国 (ISO-8859-1) の例
<p>
次の行を <file>~/.bash_profile</file> に追加してください。
<example>
LC_CTYPE=en_US.ISO-8859-1
export LC_CTYPE
</example>

<sect1 id="france">ユーロを用いたフランス語の例 (ISO-8859-15)
<p>
次の行を <file>~/.bash_profile</file> に追加してください。
<example>
LANG=fr_FR@euro
export LANG
LC_CTYPE=fr_FR@euro
export LC_CTYPE
</example>
<p>
フランスの "AZERTY" キーボードを <ref id="keyboard"> に記述しているように
設定し、<package>manpages-fr</package> をインストールしてフランス語の
マニュアルページを追加してください。米国での 右 Alt キーはヨーロッパでは
右 Gr と呼ばれます。これを他のキーと同時に押すと数多くのアクセント付き
文字や特別な文字の入力ができます。例えば、Alt-Gr+E はユーロ記号になります。
<p>
ほとんどの西ヨーロッパ言語は同様に設定可能です。
<p>
新しいユーロ貨幣のサポートを追加するには、
<url id="&debian-euro-support;" name="Debian Euro HOWTO"> を、
フランス語についてより詳しく知るには、
<url id="&debian-fr-howto;" name="Utiliser et configurer Debian pour le francais"> 
をご覧下さい。

<sect1 id="x-cjk">多言語 X window システムの例
<p>
コンソール毎に、日本語と英語とドイツ語とフランス語を、それぞれ EUC と UTF-8 
と ISO-8859-1 のエンコーディングで同時にサポートする多言語 X window システム
を設定しましょう。
<p>
まず &debian; menu システムを用いたカスタマイズをお見せします。
&debian; menu システムの詳細は <url id="&f-menu;"> をご覧下さい。
また、この例では <prgn>mozilla</prgn> web ブラウザへのショートカットを
作成します。
 <footnote>
In this example, 2 bug work arounds are deployed for the version of
<prgn>blackbox</prgn> in 2003. I use <tt>sh -c</tt> in command. Also
<file>~/.menu/*</file> entry is not used but root requiring
<file>/etc/menu/*</file> was used instead.
 </footnote>
<list>

 <item><ref id="l10n"> で記述されている方法を用いて日本語の ja_JP.eucJP 
ロケールや他の必要なロケールのサポートを追加します。(全員)

 <item>かな漢字変換システムとその辞書をインストールします。(日本語用)
  <list compact>
  <item><package>canna</package> &ndash; ローカルサーバ 
("フリービール" ライセンス) 又は
  <item><package>freewnn-jserver</package> &ndash; ネットワーク拡張性の高い
サーバ (パブリックドメイン) 
   (Public Domain)
  </list>

 <item>日本語入力メソッドシステムをインストールします。(日本語用)
  <list compact>
  <item><package>kinput2-canna</package> &ndash; X 用 又は
  <item><package>kinput2-canna-wnn</package> &ndash; X 用 
  <item><package>egg</package> &ndash; 端末でも Emacsen 環境で直接動く (任意)
  </list>

 <item>vt 互換端末をインストールします。(全員)
  <list compact>
  <item><package>xterm</package> &ndash; X (ISO-8859-1 と UTF-8 用)
  <item><package>kterm</package> &ndash; X (日本語 EUC 用)
  <item><package>mlterm</package> &ndash; X (多言語用)
  </list>

 <item>必要な全てのフォントパッケージをインストールします。(全員)
 
 <item>ユーザ指定の X 環境をセットする <file>~/.xsession</file> ファイルを
 <ref id="custom-x"> の記述に従い作成します。(全員)

<example>
#!/bin/sh
# root に su した時も X が動くようにする。
if [ -z "$XAUTHORITY" ]; then
        XAUTHORITY=$HOME/.Xauthority
        export XAUTHORITY
fi

# debian menu システムを通じて特別な環境をセットする。
# ロケールのリセット
unset LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES 
unset LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT 
unset LC_IDENTIFICATION LC_ALL LANG LANGUAGE PAGER
# X での標準のロケールをセット
LANG=C
# ロケールをエクスポート
export LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES 
export LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT 
export LC_IDENTIFICATION LC_ALL LANG LANGUAGE PAGER
###
# kinput2 による日本語入力メソッドを有効にする
kinput2 &
XMODIFIERS="@im=kinput2"
export XMODIFIERS
# blackbox ウィンドウマネージャはどうですか? (軽いですよ)
exec blackbox
#exec xfwm
#exec wmaker
</example>

 <item>Linux 端末用に <file>~/.bash_profile</file> にロケールを設定する。
 (全員)
 
 <item>存在するならば<file>~/.bashrc</file> からロケールの設定を削除する。
 (全員)

 <item><file>/etc/menu/</file> にいくつかファイルを追加する。(全員)
 <list compact>
 <item><file>/etc/menu/xterm-local</file>: (menu に新しいエントリを追加)
 <footnote>
パッケージ名と重複しない名前を使いましょう。
 </footnote>
<example>
?package(xterm):\
 needs=x11\
 section=XShells\
 longtitle="XTerm: terminal emulator (en_US.ISO-8859-1)"\
 title="XTerm (en_US.ISO-8859-1)"\
 command="sh -c 'LC_ALL=en_US.ISO-8859-1 xterm'"
?package(xterm):\
 needs=x11\
 section=XShells\
 longtitle="XTerm: terminal emulator (de_DE.ISO-8859-1)"\
 title="XTerm (de_DE.ISO-8859-1)"\
 command="sh -c 'LC_ALL=de_DE.ISO-8859-1 xterm -T xterm-de'"
?package(xterm):\
 needs=x11\
 section=XShells\
 longtitle="XTerm: terminal emulator for X with Unicode support (Japanese)"\
 title="UXTerm (ja_JP.UTF-8)"\
 command="sh -c 'LC_ALL=ja_JP.UTF-8 uxterm'"
</example>
 <item><file>/etc/menu/kterm</file>: (システムの標準を上書き)
 <footnote>
パッケージ名と重複しないファイル名を使いましょう。
 </footnote>
<example>
?package(kterm):\
 needs="x11"\
 section="XShells"\
 command="sh -c 'LC_ALL=ja_JP.eucJP PAGER=w3m /usr/X11R6/bin/kterm -xim'" \
 title="Kanji Terminal"
?package(kterm):\
 needs="x11"\
 section="XShells"\
 command="sh -c 'LANG=ja_JP.eucJP \
          LC_MESSAGES=en_US.ISO-8859-1 PAGER=w3m /usr/X11R6/bin/kterm -xim'" \
 title="Kanji Terminal (bilingal)"
</example>
 <item><file>/etc/menu/mozilla-local</file>: (新しいショートカットを追加)
 <footnote>
 <tt>section="/"</tt> のスラッシュは最初の menu へのエントリを可能にし、
 <tt>title=" Mozilla Navigator"</tt> にある先頭のスペースはリストの
 先頭へのエントリを可能にします。
 </footnote>
<example>
?package(mozilla-browser):needs="x11" section="/" \
        title=" Mozilla Navigator" command="mozilla-1.5" hints="Web browsers" \
        icon=/usr/share/pixmaps/mozilla.xpm
</example>
 <item>root アカウントから <prgn>update-menus</prgn> を起動します。
 </list>
 <item><file>~/.muttrc</file> に次の行を追加します。 (日本語)
<example>
# UTF-8 support is not popular in popular Japanese EMACS environment
# 7-bit encoding of iso-2022-jp is easier for everyone.
# default encoding order = us-ascii --&gt; iso-8859-1 --&gt; iso-2022-jp
set send_charset="us-ascii:iso-8859-1:iso-2022-jp"
set allow_8bit=no
</example>
 <item>X アプリケーションのために XIM <prgn>kinput2</prgn> を有効にします。
 (日本語用)
  <list compact>
  <item>X リソースファイルに <tt>*inputMethod: kinput2</tt> と
  <tt>KTerm*VT100*OpenIm:true</tt> を追加します。
 (Debian はこれをどういうわけか自動で対応しているようです。)
  <item>(<prgn>mlterm</prgn> のような) いくつかのアプリケーションは
  <tt>*inputMethod:</tt> を設定すると他の情報は動的に起動時に設定する
  ことを許可します。
  (<prgn>mlterm</prgn> では <strong>Ctrl-MouseButton-3</strong>  を押します。)
  </list>
 <item><tt>startx</tt> をタイプするか、ディスプレイマネージャ 
 (<prgn>xdm</prgn>, <prgn>gdm</prgn>, <prgn>kdm</prgn>,
  <prgn>wdm</prgn> など) のどれかを用いてログインすることにより X
  を起動します。(全員)
 <item>Vim 6, (x)emacs21, mc-4.5, mutt-1.4 のような日本語に対応した
 アプリケーションを <prgn>kterm</prgn> 上で起動します。(日本語用)
  (Emacs は最もポピュラーなプラットフォームのようですが、私は使っていません。)
 <item><strong>Shift+Space</strong> を押して日本語入力モードの ON/OFF
 をトグルします。(日本語用)
 <item>ローカライズされた端末上でコマンドを起動して翻訳済みの
 マニュアルページを読みます。(全員)
</list>
他の CJK 言語のサポートについては、次の章に続いて
<url id="&suse-cjk;" name="SuSE pages for CJK"> をご覧下さい。

<sect1 id="x-input">X での代替入力メソッド
<!-- I need feed back from Chinese and Korean people for here -->
<p>
パッケージとして使用可能な X 入力メソッドがいくつか存在します。
<example>
言語   LC_CTYPE     XIM サーバ  XMODIFIERS              開始キー
日本語   ja_JP*       kinput2    "@im=kinput2"           Shift-Space
韓国語     ko_KR*       ami        "@im=Ami"               Shift-Space
中国語(繁体字) zh_TW.Big5   xcin       "@im=xcin-zh_TW.big5"   Ctrl-Space
中国語(簡体字) zh_CN.GB2312 xcin       "@im=xcin-zh_CN.GB2312" Ctrl-Space
</example>
<p>
日本語入力メソッドである <prgn>kinput2</prgn> は 
<package>kinput2-canna-wnn</package>, <package>kinput2-canna</package>,
<package>kinput2-wnn</package> のようなパッケージにより供給されています。
日本語入力には他に <package>canna</package> や
<package>freewnn-jserver</package> のような辞書サーバが実際には
必要になります。

<!--
<p>
Korean and Chinese may also use dictionary server such as 
<package>freewnn-kserver</package> and
<package>freewnn-cserver</package> too.
-->

<sect1 id="x-term">X ターミナルエミュレータ
<p>
適切なフォントがインストールされた時に 8 ビットエンコーディングを
サポートする X 端末は数多く存在します。
<list compact>
  <item><package>xterm</package> &ndash; X 付属のターミナルエミュレータ
  <item><package>gnome-terminal</package> &ndash; Gnome 用の
   <package>xterm</package> 
  <item><package>konsole</package> &ndash; KDE 用の <package>xterm</package> 
  <item><package>rxvt</package> &ndash; VT102 ターミナル (軽量)
  <item><package>aterm</package> &ndash; Afterstep WM 用の VT102
  <item><package>eterm</package> &ndash; Enlightment WM 用の VT102 
  <item><package>wterm</package> &ndash; WindowMaker WM 用の VT102
</list>
<p>
X 端末のマルチバイトエンコーディングのサポートは
UTF-8 エンコーディング (<ref id="x-utf-8">)を通じて 
<package>xterm</package> により供給されています。
他の伝統的なエンコーディングのサポートは (2003 年時点で) 推進中です。
次のパッケージは伝統的なエンコーディングのサポートを提供します。
<list compact>
  <item><package>aterm-ml</package> &ndash; 多言語
  <item><package>kterm</package> &ndash; 多言語 (日本語など)
  <item><package>rxvt-ml</package> &ndash; 多言語
  <item><package>wterm-ml</package> &ndash; 多言語
  <item><package>cxterm-big5</package> &ndash; 中国語 (繁体字、 Big5)
  <item><package>cxterm-gb</package> &ndash; 中国語  (簡体字、 GB)
  <item><package>cxterm-ks</package> &ndash; 中国語 (KS)
  <item><package>cxterm-jis</package> &ndash; 日本語
  <item><package>hanterm-classic</package> &ndash; 韓国語 (ハングル)
  <item><package>hanterm-xf</package> &ndash; 韓国語 (ハングル)
  <item><package>hztty</package> &ndash; 中国語 (GB, Big5, zW/HZ)
</list>
<prgn>kterm</prgn> では、(多分他の端末でも)
Ctrl-中クリックマウス操作をした後にメニュから XIM を有効にしたいかも
しれません。

<sect1 id="x-utf-8">X 端末エミュレータの UTF-8 サポート
<p>
X ターミナルエミュレータの UTF-8 サポートは、XFree86 4.x 用の
<package>xterm</package> パッケージにある <prgn>uxterm</prgn> プログラム
により供給されています。これは全言語のサポートを可能にします。
これは "UXTerm" X リソースクラスセットを用いた後者のプログラムを起動する
<manref name="xterm" section="1"> プログラムのラッパーです。
<p>
例えば、英語、ロシア語、日本語、中国語、韓国語の文字をきれいに大きく表示
することを可能にするには、関連する全フォントをインストールした後に
<file>~/.Xresources</file> に次を追加してください。
<example>
! set large font
UXTerm*font: -misc-fixed-medium-r-normal-*-18-120-100-100-c-90-iso10646-1
! Use XIM for Japanese
*inputMethod: kinput2
</example> 
そして X リソースを更新するため、 <ref id="xresources"> に記述されているように
<tt>xrdb -merge ~/.Xresources</tt> を起動します。
<p>
<prgn>vim</prgn>, <prgn>mutt</prgn> や <prgn>emacs</prgn> のような
有名なコンソールプログラムのほとんどは最近 (Woody から Sarge にかけて)
UTF-8 と互換性がありますが、<package>mc</package> のようなプログラムは
まだ UTF-8 互換ではなく、シンプルな 8 ビット文字を表示できるだけです。
未知あるいは混在したエンコーディングのファイルの中の 7 ビット ASCII の
部分を編集する場合、ロケールを気にしない 8 ビットクリーンなエディタを
使う方が安全です。
<p>
<url id="&unicode-howto;" name="The Unicode HOWTO"> をご覧下さい。

<sect1 id="fb-utf-8">フレームバッファコンソールで UTF-8 を使う例
<p>
フレームバッファコンソール上での UTF-8 のサポートは
<prgn>debian-installer</prgn> 上で使用される <package>bterm</package>
により供給されています。

<sect1 id="beyond-locale">ロケールを越えて
<p>
まず最初に <strong>母国語環境</strong> の設定を行う際には、
言語環境に対応するタスクを選ぶことにより選び抜かれるパッケージを調べるために
<prgn>tasksel</prgn> や <prgn>aptitude</prgn> を使うことを考えてください。
このパッケージの選択は多言語環境のセットアップのためでも役に立ちます。
システムを注意深く設定するために、インストール中に依存性の衝突に出くわした
場合、既存のシステムと衝突するソフトウェアのインストールを避けてください。
新たにインストールしたパッケージは既存のパッケージよりも高い優先度を
持っているかもしれないので、いくつかのコマンドでは元の状態に戻す
ために <prgn>update-alternative</prgn> を使う必要があるかもしれません。
<p>
新しめの主要なプログラムは glibc 2.2 を使っており、ほぼ国際化されています。
それゆえ、Vim に対する <prgn>jvim</prgn> のような特別に国際化された
バージョンは <prgn>vim</prgn> version 6.0 により X 上でほぼ同様の機能が
提供されているために必要では無いかもしれません。
現実には、まだいくらかおおざっぱです。<prgn>jvim</prgn> は端末上でも直接
日本語入力メソッド (<prgn>canna</prgn>) のサポート付きでコンパイルされており、
さらに多くの他の日本語特有の問題に分別深く対応しているので、まだこれが欲しい
かもしれません。 :-)
<p>
快適な作業環境を可能にするには、<tt>ロケール</tt> 設定を越えた設定が
必要になるかもしれません。<package>language-env</package> パッケージや
その <prgn>set-language-env</prgn> コマンドはこの設定作業をかなり
軽減してくれます。
<p>
又、国際化に関する文書である 
<url id="&intro-i18n;" name="Introduction to i18n"> もご覧下さい。
これは開発者向けですが、システム管理者に対しても有用です。
</sect1>

</sect>
</chapt>
