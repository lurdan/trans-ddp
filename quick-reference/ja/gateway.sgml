<!-- CVS revision of this document "$Revision: 1.11 $"  -->
<!-- CVS revision of original english document "1.249"  -->

<chapt id="gateway">ネットワークの設定
<p>
<!-- I keep above id as gateway to have the same html file name. -->
<!-- Once all translations are in sync, I may change it to network. -->
この章では &debian; でのネットワーク管理に焦点を当てています。
GNU/Linux のネットワークに関する一般的な紹介は
<url id="&net-howto;" name="Net-HOWTO"> をごらんください。
<p>
&debian; ホストのインターネットへのアクセスを可能にするには、
ネットワークインターフェイスが適切に設定される必要があります。
<p>
まず最初に必要なことは、ネットワークインターフェイスデバイスのカーネルサポートです。
ネットワークデバイスの例としては、以下が挙げられます:
イーサネットカード、無線 LAN カードやモデム。
ネットワークインターフェイスデバイスを kernel がサポートすることです。
これらのサポートを有効にするには、 <ref id="kernel"> で記述されているように
kernel を再構築してモジュールを追加する必要があるかもしれません。
<p>
ネットワークデバイスの設定は以降で説明します。
本章の情報は Sarge 向けに更新されました。
本章の内容のほとんどは以前のリリースには適用できません。
<!--
I move these to comment, Thomas, please remove once you are ready
<p>
<list compact>
<item>XXX FIXME XXX: Update HW config, Ethernet kernel module
<item>XXX FIXME XXX: Add section to reconfigure network on initial install.
</list>
-->

<sect id="net-basic">IP ネットワークの基礎
<p>
&debian; ホストはそれぞれが異なった Internet Protocol (IP) アドレスを持った
複数のインターフェイスを持つことができます。
インターフェイスは次に挙げるいくつかの異なるタイプかもしれません。
<list compact>
<item>ループバック:  <tt>lo</tt>
<item>イーサネット:  <tt>eth0</tt>, <tt>eth1</tt>, ...
<item>無線LAN:  <tt>wlan0</tt>, <tt>wlan1</tt>,<tt>wifi0</tt> ...
<footnote>
無線 LAN インターフェイスの一部は本当はイーサネットインターフェイスの別名
であり、無線 LAN 独特の設定パラメータへのヒントを与えてくれます。
これらのパラメータは <prgn>iwconfig</prgn> プログラムを用いて
制御可能です。
</footnote>
<item>トークンリング:  <tt>tr0</tt>, <tt>tr1</tt>, ...
<item>PPP:  <tt>ppp0</tt>, <tt>ppp1</tt>, ...
</list>
SLIP, PLIP (srrial line IP と pararell line IP), 特定のデバイスで
トラフィックを制御するための "shaper" なデバイス, フレームリレー,
Ax.25, X.25, ARCnet そして LocalTalk のような他のさまざまな種類の
ネットワークデバイスが使用可能です。
<p>
インターネット (又は IP ベースのネットワーク) に直接接続された全ての
ネットワークインターフェイスはユニークな 32 ビットの IP アドレスにより
識別されます。
<footnote>
これは IPv4 が使用されている場合に正しい。IPv6 ではアドレスは 128 ビット。
<url id="&ipv6home;"> 参照。
</footnote>
IP アドレスネットワークを示す部分とホストを示す部分に分割できます。
IP アドレスのネットワークアドレスの部分を 1 に、ホストアドレスの
部分を 0 にすると、ネットワークのいわゆるネットマスクが得られます。
<p>
伝統的に、IP ネットワークはそれぞれ 8 ビット、16 ビット、24 ビットの長さの
ワークアドレス部分を持つクラスに分類されています。
これらのシステムは柔軟性に欠けており、多数の IP アドレスを無駄にしていました。
それゆえ、今日では IPv4 ネットワークは可変長のネットワークアドレス部分を持つ
ように割り当てられています。
<example>
                IP アドレス               ネットマスク   長さ
クラス A   1.0.0.0     - 126.255.255.255  255.0.0.0     =  /8
クラス B   128.0.0.0   - 191.255.255.255  255.255.0.0   = /16
クラス C   192.0.0.0   - 223.255.255.255  255.255.255.0 = /24
</example>
以上の長さを持たない IP アドレスは特別な目的に用いられます。
<p>
各クラスのためにローカルエリアネットワーク (LAN) で使用するために予約された
アドレスの範囲が存在します。
これらのアドレスはインターネット上のあらゆるアドレスと衝突しないことが
保証されています。
(同じトークンにより、これらのアドレスの 1つがホストに割り当てられた場合、
そのホストはインターネットに直接アクセスしてはいけませんが、
個別のサービスのためのプロキシとして機能するゲートウェイを通して
アクセスするか、ネットワークアドレス変換を通じてアクセスする
必要があります。)
これらのアドレスの範囲はそれぞれのクラスにあるアドレスの数に応じて、
次のテーブルに示すように与えられています。
<example>
              ネットワークアドレス      長さ    数
クラス A   10.x.x.x                     /8      1
クラス B   172.16.x.x -  172.31.x.x     /16     16
クラス C   192.168.0.x - 192.168.255.x  /24     256
</example>
IP ネットワークの最初のアドレスはネットワーク自身のアドレスです。
最後のアドレスはネットワークのブロードキャストアドレスです。
<footnote>
ネットワークのアドレスはネットワークアドレスとネットワークのネットマスクの和を
取ることにより得られます。ブロードキャストアドレスはネットワークアドレスと
ネットマスクの一の補数の積を取ることにより得られます。
</footnote>
他の全てのアドレスはネットワーク上のホストに割り当てられます。
これらのうち、最初又は最後のアドレスは通常ネットワークの
インターネットゲートウェイに割り当てられます。
<p>
ルーティングテーブルは kernel の目的地への IP パケットの送信方法
についての情報を含んでいます。
ここに IP アドレス 192.168.50.x/24 を持つローカルエリアネットワーク (LAN)
上の &debian; ホストのためのサンプルのルーティングテーブルを示します。
ホスト 192.168.50.x (LAN 上にもある) は企業ネットワーク 172.20.x.x/16
のためのルータであり、192.168.50.254 (LAN 上にもある) はインターネット
用のルータです。
<!-- I shrunk shell output within 72 characters                       -->
<example>
# route
Kernel IP routing table
Destination   Gateway        Genmask       Flags Metric Ref Use Iface
127.0.0.0     *              255.0.0.0     U     0      0     2 lo
192.168.50.0  *              255.255.255.0 U     0      0   137 eth0
172.20.0.0    192.168.50.1   255.255.0.0   UG    1      0     7 eth0
default       192.168.50.254 0.0.0.0       UG    1      0    36 eth0
</example>
<list compact>
<item>
ヘッダの後の最初の行は <tt>127.x.x.x</tt> 向けのトラフィックは
<tt>lo</tt> すなわちループバックインターフェイスを通ることを示しています。
<item>
2 行目は LAN 上のホスト向けのトラフィックは <tt>eth0</tt> を通ることを
示しています。
<item>
3 行目は企業ネットワーク向けのトラフィックは <tt>eth0</tt> を通って
ゲートウェイ <tt>192.168.50.1</tt>に向けられることを示しています。
<item>
4 行目はインターネット向けのトラフィックは<tt>eth0</tt> を通ってゲートウェイ
 <tt>192.168.50.254</tt> に向けられることを示しています。
</list>
テーブル上の IP アドレスは <file>/etc/networks</file> を調べるか
C ライブラリのリゾルバを用いて得られる名前としても表せます。
<p>
ルーティングに加え、kernel はネットワークアドレス変換、トラフィック整理
やフィルタリングも行えます。
<p>
より詳しい背景情報については <url id="&net-howto;" name="Net-HOWTO"> と
<url id="&net-howto-over;" name="other networking HOWTOs"> をごらんください。


<sect id="net-low">低レベルネットワークの設定
<p>
GNU/Linux システム上での伝統的な低レベルネットワーク設定ツールとしては
<package>net-tools</package> パッケージに収録されている
<prgn>ifconfig</prgn> や <prgn>route</prgn> プログラムがあります。
これらのツールは公式に <package>iproute</package> パッケージに収録
されている <prgn>ip</prgn> により取って代われています。
<prgn>ip</prgn> プログラムは Linux 2.2 以上で動き、旧式のツールよりも
より機能的です。しかしながら、旧式のツールもまだ動き、多くのユーザにより
親しまれています。

<sect1 id="low-ifconfig">低レベルネットワーク設定ツール &ndash; 
<prgn>ifconfig</prgn> と <prgn>route</prgn>
<p>
ここにインターフェイス <tt>eth0</tt> の IP アドレスを <tt>192.168.0.3</tt>
から <tt>192.168.0.111</tt> に変更し、<tt>192.168.0.1</tt> 経由で 
<tt>10.0.0.0</tt> ネットワークに通すように <tt>eth0</tt> を設定
する方法を示します。
現在の全てのネットワークインターフェイスとルーティングの状況を表示するため、
まずはインターフェイス引数無しで <prgn>ifconfig</prgn> と <prgn>route</prgn>
を起動することから始めましょう。
<example>
# ifconfig
eth0 Link encap:Ethernet  HWaddr 08:00:46:7A:02:B0
     inet addr:192.168.0.3  Bcast:192.168.255.255  Mask:255.255.0.0
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     RX packets:23363 errors:0 dropped:0 overruns:0 frame:0
     TX packets:21798 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:100
     RX bytes:13479541 (12.8 MiB)  TX bytes:20262643 (19.3 MiB)
     Interrupt:9

lo   Link encap:Local Loopback
     inet addr:127.0.0.1  Mask:255.0.0.0
     UP LOOPBACK RUNNING  MTU:16436  Metric:1
     RX packets:230172 errors:0 dropped:0 overruns:0 frame:0
     TX packets:230172 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:0
     RX bytes:22685256 (21.6 MiB)  TX bytes:22685256 (21.6 MiB)
# route
Kernel IP routing table
Destination  Gateway      Genmask          Flags Metric Ref Use Iface
192.168.0.0  *            255.255.0.0      U     0      0     0 eth0
default      192.168.0.1  255.255.255.255  UG    0      0     0 eth0
</example>
まずインターフェイスをダウンさせます。
<example>
# ifconfig eth0 inet down
# ifconfig
lo   Link encap:Local Loopback
  ... (eth0 エントリはもはや存在しない)
# route
  ... (ルーティングテーブルのエントリももはや存在しない)
</example>
次に eth0 を新しい IP アドレスと新しいルーティングを用いて立ち上げます。
<example>
# ifconfig eth0 inet up 192.168.0.111 \
           netmask 255.255.255.0 broadcast 192.168.0.255
# route add -net 10.0.0.0 netmask 255.0.0.0 gw 192.168.0.1 dev eth0
</example>
結果は次のようになります。
<example>
# ifconfig
eth0 Link encap:Ethernet  HWaddr 08:00:46:7A:02:B0
     inet addr:192.168.0.111  Bcast:192.168.0.255  Mask:255.255.255.0
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     ...

lo   Link encap:Local Loopback
     inet addr:127.0.0.1  Mask:255.0.0.0
     ...
# route
Kernel IP routing table
Destination  Gateway      Genmask      Flags Metric Ref Use Iface
192.168.0.0  *            255.255.255.0  U     0      0     0 eth0
10.0.0.0     192.168.0.1  255.0.0.0    UG    0      0     0 eth0
</example>
<p>
より詳しい情報は、<manref name="ifconfig" section="8"> と
<manref name="route" section="8"> をごらんください。

<sect1 id="low-ip">低レベルネットワーク設定ツール &ndash; <prgn>ip</prgn>
<p>
前記の <prgn>ifconfig</prgn> や <prgn>route</prgn> コマンドと等価な
<prgn>ip</prgn> コマンドは次のようになります。
<list compact>
<item><tt>ip link show</tt>
<item><tt>ip route list</tt>
<item><tt>ip link set eth0 down</tt>
<item><tt>ip addr del dev eth0 local 192.168.0.3</tt>
<item><tt>ip addr add dev eth0 local 192.168.0.111/24 broadcast 192.168.0.255</tt>
<item><tt>ip link set eth0 up</tt>
<item><tt>ip route add dev eth0 to 10.0.0.0/8 src 192.168.0.111 via 192.168.0.1</tt>
</list>
<p>
<prgn>ip</prgn> プログラムは引数 <tt>help</tt> 付きで起動するとその
コマンド文法を表示します。例えば、<tt>ip link help</tt> は次を表示します。
<example>
Usage: ip link set DEVICE { up | down | arp { on | off } |
                     dynamic { on | off } |
                     multicast { on | off } | txqueuelen PACKETS |
                     name NEWNAME |
                     address LLADDR | broadcast LLADDR |
                     mtu MTU }
       ip link show [ DEVICE ]
</example>
<manref name="ip" section="8"> をごらんください。

<sect1 id="low-wifi">無線 LAN インターフェイスの設定
<p>
無線 LAN インターフェイスの設定には、<package>wireless-tools</package> 
パッケージに収録されている <prgn>iwconfig</prgn> プログラムが
<prgn>ifconfig</prgn> と <prgn>ip</prgn> の両方に加えて使われます。
<p>
<manref name="iwconfig" section="8"> をごらんください。

<sect1 id="low-ppp">PPP インターフェイスの設定
<p>
インターネットにダイアルアップ電話線を接続したモデム経由でアクセス
する場合、Point-to-Point Protocol (PPP) を用いて接続をネゴシエイト
します。そのような接続はネットワークインターフェイス <tt>ppp0</tt>,
<tt>ppp1</tt>, などとしてアクセスされます。
<p>
PPP インターフェイスは <package>ppp</package> パッケージに収録されている
PPP デーモン <prgn>pppd</prgn> により管理されます。
それゆえ、ユーザにとっては、PPP インターフェイスを設定するのは
<prgn>pppd</prgn> を設定することを意味します。

<sect2 id="ppp-pppd"><prgn>pppd</prgn> を手動で設定する
<p>
ネットワークリンクを確立するには、通信ポート (通常シリアルポート)
を開き、コマンドを通信デバイス (通常はモデム) に送信し、
電話番号をダイアルし、外部の PPP デーモンへの認証を行い、
PPP インターフェイスがカーネルにより作成され、トラフィックが
リンクを通じて送られるようにルーティングテーブルが修正される必要があります。
<prgn>pppd</prgn> はこれらの仕事の全てをこなし、その結果として
非常に長い操作オプションのリストを持ちます。
これらのオプションは <manref name="pppd" section="8"> に記述されています。
<p>
&debian; システムでは、汎用のオプションは <file>/etc/ppp/options</file>
にセットされています。ユーザが指定するオプションは <file>~/.ppprc</file>
にセットします。使用する通信ポートに依存するオプションは
<file>/etc/ppp/options.<var>portname</var></file> に保存されます。
例えば、二つのモデム &mdash; 組込みの /dev/LT-modem を通じてアクセス
される Lucent LT モデムと外付けの /dev/ttyS0 を通じてアクセスされる
モデムを持っていると仮定します。
次の 2 つのオプションファイルを作成します。
<example>
# cat &gt; /etc/ppp/options.LT-modem &lt;&lt;EOF
115200
init "/usr/sbin/chat -f /etc/chatscripts/setup-LT-modem"
EOF
# cat &gt; /etc/ppp/options.ttyS0 &lt;&lt;EOF
115200
init "/usr/sbin/chat -f /etc/chatscripts/setup-ttyS0"
EOF
</example>
これらは次のチャットスクリプトを参照しています。まず、
<file>/etc/chatscripts/setup-LT-modem</file> です。
<example>
ABORT ERROR
'' ATZ
OK 'ATW2X2 S7=70 S11=55'
OK AT
</example>
次に、<file>/etc/chatscripts/setup-ttyS0</file> です。
<example>
ABORT ERROR
'' ATZ
OK 'ATL1M1Q0V1W2X4&amp;C1&amp;D2 S6=4 S7=70 S11=55 S95=63 S109=1 +FCLASS=0'
OK AT
</example>
これらのファイルの内容はもちろんハードウェアに依存している必要があります。
<p>
オプションは <prgn>pppd</prgn> に引数としても与えられます。
<p>
&debian; では、<prgn>pppd</prgn> は普通 <prgn>pon</prgn> コマンドを
用いて起動されます。<prgn>pon</prgn> が起動されると、その第一引数は
<prgn>pppd</prgn> によっても読まれる <file>/etc/ppp/peers/</file> に
あるオプションファイルと同じ名前です。
<footnote>
このオプションファイルは <tt>call</tt> オプションを用いて含まれます。
</footnote>
こうして特定の peer&mdash;例えば、特定のインターネットサービスプロバイダ
(ISP) を指定するオプションを設定できます。
<p>
例えば、アムステルダムとハーグの間を通信したいとします。
それぞれの町には 2つの ISP サービス&mdash;Planet と KPN を持っています。
まず各 ISP 用の基本的なオプションファイルを作ります。
<example>
# cat &gt; /etc/ppp/peers/KPN &lt;&lt;EOF
remotename KPN
noauth
user kpn
noipdefault
ipparam KPN
EOF
# cat &gt; /etc/ppp/peers/Planet &lt;&lt;EOF
remotename Planet
auth
user user3579@planet.nl
noipdefault 
mru 1000
mtu 1000
ipparam Planet
EOF
</example>
これらのファイルは 2つの ISP 間で異なるオプションを設定します。
両方の ISP に共通のオプションは <file>/etc/ppp/options</file>
又は適切なインターフェイス独自のオプションファイルのどちらかに
置きます。
<p>
次にそれぞれの町のための各 ISP 用のオプションファイルを作成します。
この例では片方の場所の ISP へ接続するのと他の場所の ISP に
接続する時の違いのみを必要なチャットスクリプトにします。
(ローカルのアクセス電話番号が異なるので、チャットスクリプトは異なります。)
<example>
# cat &gt; /etc/ppp/peers/KPN-Amsterdam &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/KPN-Amsterdam"
file /etc/ppp/peers/KPN
EOF
# cat &gt; /etc/ppp/peers/KPN-DenHaag &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/KPN-DenHaag"
file /etc/ppp/peers/KPN
EOF
# cat &gt; /etc/ppp/peers/Planet-Amsterdam &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/Planet-Amsterdam"
file /etc/ppp/peers/Planet
EOF
# cat &gt; /etc/ppp/peers/Planet-DenHaag &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/Planet-DenHaag"
file /etc/ppp/peers/Planet
EOF
</example>
それぞれの <tt>file</tt> 指示は早く示されるオプションファイルの一つ
の一つを含みます。
<tt>connect</tt> 指示は接続を確立するために <prgn>pppd</prgn> が使う
コマンドを指示します。
通常この目的には <prgn>chat</prgn> プログラムを使い、
チャットスクリプトを ISP に適応させます。
アムステルダムは電話番号を除いて同じかもしれませんし、ISP が
他の会社を通じてサービスを提供しているならば、異なるかもしれません。
<example>
# cat &gt; /etc/chatscripts/KPN-DenHaag &lt;&lt;EOF
ABORT BUSY
ABORT 'NO CARRIER'
ABORT VOICE
ABORT 'NO DIALTONE'
ABORT 'NO DIAL TONE'
ABORT 'NO ANSWER'
ABORT ERROR
OK-AT-OK ATDT <var>0676012321</var>
CONNECT \d\c
EOF
# cat &gt; /etc/chatscripts/Planet-DenHaag &lt;&lt;EOF
ABORT BUSY
ABORT 'NO CARRIER'
ABORT VOICE
ABORT 'NO DIALTONE'
ABORT 'NO DIAL TONE'
ABORT 'NO ANSWER'
ABORT ERROR
OK-AT-OK ATDT <var>0676002505</var>
CONNECT \d\c
EOF
</example>
これらの ISP と接続を確立できるようにするには、<prgn>pppd</prgn>
が peer に要求に応じて供給するクライアント名とパスワードが必要です。
これらの情報は <file>/etc/ppp/pap-secrets</file> (PAP プロトコル使用時) 又は
<file>/etc/ppp/chap-secrets</file> (CHAP プロトコル使用時) に保存されます。
CHAP はより安全ですが、PAP は依然広く使われています。
これらのファイルには秘密が含まれているので、グループと他人が読み書きできない
ファイルアクセス権限を設定しなくてはなりません。
これらのファイルのフォーマットは <manref name="pppd" section="8"> で
説明されています。
"secret" (3 番目のフィールド) はファイル中のクライアント名 (最初のフィールド)
および/又は サーバ名 (2 番目のフィールド) を検索することにより調べられます。
ISP に接続している場合、一般にサーバ名は知りませんので、クライアント名を
代わりに供給します。これは上に示した <file>peers/KPN</file> と 
<file>peers/Planet</file>にある <tt>user</tt> 行で行われます。
<example>
# client name       server name  secret
kpn                 *            kpn
user3579@planet.nl  *            myfavoritepet
</example>
詳細は <file>&f-ppp-readme;</file> をごらんください。

<sect2 id="ppp-pppconfig"><package>pppconfig</package> を用いて 
<prgn>pppd</prgn> を設定する
<p>
<prgn>pppd</prgn> を設定する手軽な方法は同名のパッケージにより
供給される <prgn>pppconfig</prgn> を使うことです。
<prgn>pppconfig</prgn> はメニュインターフェイスを通じてユーザが質問
に答えた後に上に示したようなファイルを設定します。

<sect2 id="ppp-wvdial"><package>wvdial</package> を用いて PPP 
インターフェイスを設定する
<p>
<prgn>pppd</prgn> を用いる異なるアプローチとしては、
<package>wvdial</package> パッケージに収録されている <prgn>wvdial</prgn>
から <prgn>pppd</prgn> を起動することです。
<prgn>pppd</prgn> の代わりに、<prgn>chat</prgn> を起動してダイアルし、
接続のネゴシエイトを行います。<prgn>wvdial</prgn> はダイアルと最初のネゴ
シエイトを行い、そして残りの作業を行うために <prgn>pppd</prgn>を起動します。
電話番号、ユーザ名、そしてパスワードを与えるだけで <prgn>wvdial</prgn> は
ほとんどの場合接続を確立できます。

<sect id="net-name">コンピュータの名前付け
<p>

<sect1 id="name-host">ホスト名
<p>
カーネルはシステムの <strong>ホスト名</strong>を維持します。
initscript <file>/etc/init.d/hostname.sh</file> はシステムのホスト名を
ブート時に (<prgn>hostname</prgn> を用いて) <file>/etc/hostname</file>
に保存されている名前に設定します。
このファイルには完全修飾ドメイン名 (FQDN) ではなく、
システムのホスト名 <strong>のみ</strong> が含まれていなくてはなりません。
<p>
現在のホスト名を表示するには、引数無しで <prgn>hostname</prgn>
を起動してください。

<sect1 id="name-mail">Mailname
<p>
ホストの <strong>mailname</strong> はホストを識別するためにメール関連の
プログラムが使用する名前です。
<file>/etc/mailname</file> ファイルには名前に続いて改行を持つ行が
含まれます。
mailname はホストの IP アドレスの一つを解決する完全修飾ドメイン名です。
<manref name="mailname" section="5"> をごらんください。
<p>
&debian; ホストにより送信されるメールの <tt>From:</tt> ヘッダにある
受取人が何かは Mail User Agent (MUA) や Mail Transfer Agent (MTA)
がどのように設定されているかに依存します。
ローカルユーザ <tt><var>foo</var></tt> がメールを mailname 
<tt><var>myhost.dom</var></tt> から送ると仮定します。
すると、送信されるメールの <tt>From:</tt> ヘッダは次のようになります。
<list compact>
<item>MUA が <tt>From:</tt> ヘッダセットを持たない場合
"<tt>From: <var>foo</var>@<var>myhost.dom</var></tt>"
<item>MUA が "<tt>From: <var>bar</var></tt>" セットを持つ場合
"<tt>From: <var>bar</var>@<var>myhost.dom</var></tt>"
<item>MUA が "<tt>From: <var>bar</var>@<var>bogus.dom</var></tt>" セットを持つ場合
"<tt>From: <var>bar</var>@<var>bogus.dom</var></tt>"
</list>
MUA が <tt>From:</tt> ヘッダをセットしたとしても、MTA が
"<tt>Sender:<var>foo</var>@<var>herman.dom</var></tt>" ヘッダを
本当の発信源を示すために追加するかもしれません。
<p>
もちろん <ref id="addr-catchall"> や <ref id="addr-rewrite"> で議論
したように、受信者が見るメールアドレスは他のアドレスに変更可能です。

<sect id="net-dns">ドメインネームサービス (DNS)
<p>
ホストは IP アドレスに加え、ドメイン名によっても参照されます。
DNS はネームリゾルバがドメイン名を IP アドレスや他のホストの属性と
関連付けるためにネームサーバを勤めるクライアントサーバシステムです。
GNU C ライブラリ <manref name="resolver" section="3"> もファイルにある
IP アドレスの検索を行えますし、Network Information Services (NIS) 
の役目も勤めます。
<p>
ソフトウェアには (例えば GNOME のように) システムのホスト名が標準的な 
FQDN を持つ IP アドレスに解決可能であることを期待しています。
システムのホスト名どドメイン名はまったく異なるものであるため、これは
本当に不適切です。しかし、これらのソフトを使わざるを得ません。
これらのソフトをサポートするには、システムのホスト名が解決可能
であることを保証する必要があります。
ほとんどの場合、これは <file>/etc/hosts</file> に IP アドレスと
システムのホスト名を含む行を追加することにより行なわれます。
システムに継続的な IP アドレスが割り当てられている場合、この手段は
利用できますが、そうでは無い場合、アドレス 127.0.0.1 を使います。
<example>
 127.0.0.1 localhost
 127.0.0.1 uranus
</example>
システムのホスト名が FQDN を持つ IP アドレスに解決可能であるかを
知るには、<tt>hostname --fqdn</tt> コマンドを使用ください。
<p>

<sect1 id="dns-resolver">リゾルバ
<p>
特定のドメイン名に関連づけられた IP アドレスを捜し出す仕事は、リゾルバ
の仕事です。最も良く使われているリゾルバは GNU C ライブラリにある
リゾルバ (<manref name="resolver" section="3">) により実現される
関数群です。他のリゾルバとしては、<package>libfiredns</package>  
パッケージに収録されている FireDNS リゾルバがあります。
他のパッケージも存在します。
<p>
どのように GNU LIBC リゾルバが名前を解決するかは 
<file>/etc/nsswitch.conf</file> 設定ファイル中の <tt>hosts</tt> 
行により制御されています。
この行は名前を解決するために使われるサービス、例えば <tt>dns</tt>, 
<tt>files</tt>, <tt>nis</tt>, <tt>nisplus</tt> をリストしています。
<manref name="nsswitch.conf" section="5"> をごらんください。
<tt>files</tt> サービスが使用されている範囲については、リゾルバの挙動は
<file>/etc/hosts</file> 設定ファイルによっても制御されています。
<manref name="hosts" section="5"> をごらんください。
<p>
上の全てのファイルは静的であり、お好みのエディタで編集できます。
<p>
<tt>dns</tt> サービスが使用される範囲においては、リゾルバの挙動は
<file>/etc/resolv.conf</file> 設定ファイルによっても制御されています。
<manref name="resolv.conf" section="5"> をごらんください。
<file>resolv.conf</file> の重要な機能のひとつは、名前を解決するために
接続されるネームサーバの IP アドレスをリストすることです。
このリストはたびたびネットワーク環境に依存し、ネットワーク環境はコンピュータ
を起動する間時にふれて変化します。
<prgn>pppd</prgn> や <prgn>dhclient</prgn> のようなプログラムは
<file>resolv.conf</file> 内の行を追加したり削除する操作を行えますが、
これらの機能は常に適切に動くとは限らず、お互いに衝突しかねません。
<package>resolvconf</package> パッケージはこのファイルを更新するための
標準的なフレームワークを供給することにより、よりうまくこの問題を解決します。
<ref id="dns-resolvconf"> をごらんください。
<p>

<sect1 id="dns-resolvconf">ネームサーバ情報の管理 &ndash; <package>resolvconf</package>
<p>
<package>resolvconf</package> パッケージは利用可能なネームサーバ
に関する情報の動的な管理のためのフレームワークを供給します。
リゾルバや DNS キャッシュが使うためのネームサーバのリストを動的に管理
する方法についての長年の問題を解決します。
resolvconf は自身をネットワークインターフェイスを制御するプログラムと
ネームサーバ情報を供給するプログラム、そしてネームサーバ情報を必要とする
アプリケーションの間の仲介人として設定します。
<p>
<package>resolvconf</package> は手動の設定を必要とせずに動作するように
設計されています。しかしながら、パッケージはまだ非常に新しく、
適切に動作させるためには、まだ手動の介入をいくらか必要とするかもしれません。
あなたが <file>/etc/resolv.conf</file> を更新するようにパッケージを
カスタマイズしたならば、これは確実に当てはまります。ですので、
カスタマイズを無効にする必要があります。
詳細は <url id="&f-resolvconf;"> をごらんください。

<sect1 id="dns-dnsmasq">検索した名前をキャッシュする &ndash;  <package>nscd</package>, <package>dnsmasq</package>, <package>pdnsd</package>, <package>bind9</package>
<p>
もしネームサーバの反応が遅い場合は <package>libc6</package> リゾルバ
を用いて検索される結果を <prgn>nscd</prgn> を用いてキャッシュしたくなる
でしょう。
<p>
もしあなたのローカルネットの他のホストのために検索結果をキャッシュしようと
するなら、<package>dnsmasq</package> や <package>pdnsd</package> のような
キャッシュフォワーディングネームサーバを使うのがいいでしょう。
<p>
<package>bind9</package> の <prgn>named</prgn> も
キャッシュフォワーディングネームサーバとして使えない事はありません。
ただ重いプログラムなので、その先進的機能を使わないなら、
先程述べた他のプログラムを使う方が賢明です。
<package>resolvconf</package> と連係しうまく動きます。

<sect1 id="dns-bind-server">ドメインネームサービスを供給する &ndash; <package>bind</package>
<p>
あるドメインのための信頼できるネームサービスを供給する必要がある場合、
<package>bind9</package> パッケージ
による <prgn>named</prgn> のような完全に一人前のネームサーバが必要です。
新たにインストールする場合、<package>bind9</package> がお薦めです。
<p>
<package>bind9</package> をインストールした際には、<package>dnsutils</package> 
もインストールしましょう。
次に、<package>bind9-host</package>, <package>dns-browse</package>, 
<package>dnscvsutil</package>, <package>nslint</package> のような
ユーティリティパッケージもインストールしたいかもしれません。
さらに、<package>bind9-doc</package> のようなドキュメントパッケージも
インストールしたいかもしれません。そして、<package>libbind-dev</package> や
<package>libnet-dns-perl</package> のような開発用パッケージもインストール
したいかもしれません。
DHCP を用いたインターフェイスを設定する場合、<package>dhcp-dns</package>
パッケージを見つけるかもしれません。
<p>
基本的な設定を行うには、<package>bind9</package> をインストールするか、
<prgn>dpkg-reconfigure</prgn> を実行しましょう。設定は
<file>named.conf</file> を編集することです。
&debian; では、このファイルは <file>/etc/bind/</file> にあり、
主に基本的な DNS ゾーンの定義のために用いられます。
このファイルには <file>named.conf.local</file> というローカルゾーンを定義する
ファイルと、<file>named.conf.options</file> という設定オプションのために
用いられるファイルという二つの別ファイルが <tt>含まれます</tt>。
(後者は <file>/var/run/bind/named.options</file> ファイルを生成するために
<package>resolvconf</package> によって処理されます。この生成ファイルは
<tt>forwarders</tt> 指定が現在利用できるローカルではないネームサーバの
リストであるという点を除いてオリジナルと同じです。
これを利用するには、<file>named.conf</file> の <tt>include</tt> 行が
<file>/var/run/bind/named.options</file> を含むように変更してください。
<ref id="dns-resolvconf"> をごらんください。)
<p>
完全なパス名無しで <file>named.conf*</file> という名前のデータベースファイル
が <file>/var/cache/bind/</file> に保存されます。
これは <prgn>named</prgn> により生成されるファイルを保存する正しい場所です。
例えば、デーモンが働いているセカンダリゾーン用のデータベースファイルです。
<file>/etc/bind/</file> にある静的なデータベースファイルは、
フルパス名により  <file>named.conf</file> にあるものと参照
されなくてはなりません。詳細は <url id="&f-bind9;"> をごらんください。

<sect id="net-dhcp">DHCP を用いてネットワークインターフェイスを設定する
<p>
低レベルのネットワークインターフェイスの設定は 
Dynamic Host Configuration Protocol (DHCP) を用いて自動化できます。
ファイアーウォールやルータボックス、そしてあなたが使っているブロードバンド 
ISP は IP アドレスや他のパラメータをこの方法で提供しているかもしれません。
<p>
DHCP を動かすには、次のパッケージのうち一つをインストールする必要があります。
<list compact>
<item><package>dhcp3-client</package> (version 3, Internet Software Consortium による)
<item><package>dhcpcd</package> (Yoichi Hariguchi と Sergei Viznyuk による)
<item><package>pump</package> (Red Hat による)
</list>

<package>pump</package> はシンプルで広く使われています。
<package>dhcp3-client</package> は複雑ですがより広範な設定が可能です。
<footnote>
2004年4月時点では、<package>dhcp-client</package> パッケージも利用可能です。
これには ISC DHCP クライアントの version2 が含まれています。
これは現在 <package>dhcp3-client</package> に収録されている version 3 により
置き換えられます。メンテナは <package>dhcp3-client</package> を 
Sarge 以降に <package>dhcp-client</package> に改名しようと計画しています。
<p>
experimentalバージョンの <package>dhcp-client</package> がインストールされ
てない事を確認して下さい。<package>ifupdown</package> がうまく動きません。
</footnote>

<sect id="net-high">&debian; での高レベルなネットワーク設定
<p>
<sect1 id="net-ifupdown"><package>ifupdown</package>を用いた高レベルなネットワーク設定
<p>
ネットワーク設定をより容易にするため、&debian; は <prgn>ifup</prgn> と
<prgn>ifdown</prgn> プログラムと <file>/etc/network/interfaces</file> ファイル
から構成される標準の高レベルネットワーク設定ツールを供給します。
<footnote>
最新のバージョンの <file>/etc/network/interfaces</file> の
ファイルフォーマットは Potato 以前のフォーマットと少し互換性がありません。
<package>ifupdown</package> のインストール後スクリプトが必要な場合に
自動的にこのファイルを更新します。
<!--
しかしながら、変換されたファイルをチェックして見るのは良い考えです。
-->
</footnote>
ネットワークの設定に <package>ifupdown</package> を使おうとした場合、
通常低レベルのコマンドを同時に使うべき <strong>ではありません</strong>。
これは、低レベルな設定ツールを呼び出す <package>whereami</package>,
<package>divine</package>,<package>intuitively</package> などのような他の
高レベルな設定ツールを使うべきではないということも意味しています。
<package>ifupdown</package> プログラムはこのプログラム単独でネットワーク
インターフェイスの設定や設定解除に利用されるという意図を持って書かれました。
<p>
インターフェイスの設定を更新するには、次のようにします。
<example>
# ifdown eth0
# editor /etc/network/interfaces  # お好きなようにいじる
# ifup eth0
</example>
<p>
より詳しい情報は <manref name="interfaces" section="5">,
<url id="&f-ifupdown;">, と <manref name="ifup" section="8"> をごらんください。

<sect2 id="high-static">スタティック IP アドレスを用いたインターフェイスの設定
<p>
<tt>192.168.0.111</tt> の固定 IP アドレスを持った Ethernet インタフェース
の設定を行いたいと仮定します。このアドレスは <tt>192.168.0</tt> から始まるので、LAN 上にある必要があります。さらに、LAN のインターネットへのゲートウェイの
アドレスを <tt>192.168.0.1</tt> と仮定します。
次のような行を含むように <file>/etc/network/interfaces</file>
を編集しましょう。
<example>
iface eth0 inet static
       address 192.168.0.111
       netmask 255.255.255.0
        gateway 192.168.0.1
</example>
"up" や "down" 行の適切なコマンドを指定することにより、インターフェイスの
他の面についての設定ができますし、インターフェイスを
立ち上げた後又は落とした後に他のアクションを取ることもできます。
<example>
iface eth0 inet static
  	address 192.168.0.111
        netmask 255.255.255.0
        gateway 192.168.0.1
        up route add -net 10.0.0.0 netmask 255.0.0.0 gw 192.168.0.2 dev $IFACE
  	down route del -net 10.0.0.0 netmask 255.0.0.0 gw 192.168.0.2 dev $IFACE 
        up echo Interface $IFACE going up | /usr/bin/logger -t ifup
        down echo Interface $IFACE Going down | /usr/bin/logger -t ifdown
</example>
その代わりに、<file>/etc/network/if-up.d</file> や <file>/etc/network/if-down.d</file> ディレクトリにスクリプトを挿入できます。
そのようなスクリプトは拡張オプションも実装できます。
詳細は <manref name="interfaces" section="5"> をごらんください。
例えば、<package>resolvconf</package> パッケージには
インターフェイスを立ち上げるときに <file>/etc/resolv.conf</file>
に含まれるような DNS 情報を指定するオプションを追加できます。
<example>
iface eth0 inet static
        address 192.168.0.111
        netmask 255.255.255.0
        gateway 192.168.0.1
        dns-search somedomain.org
        dns-nameservers 195.238.2.21 195.238.2.22
</example>
<tt>dns-search</tt> オプションの <tt>somedomain.org</tt> 引数は
<manref name="resolv.conf" section="5"> にある <tt>search</tt> 
オプションの引数に対応します。
<tt>dns-nameservers</tt> オプションの <tt>195.238.2.21</tt> および
<tt>195.238.2.22</tt> 引数は <tt>nameserver</tt> オプションの引数に
対応します。
他の利用可能なオプションとしては、<tt>dns-domain</tt> と <tt>dns-sortlist</tt>
があります。
<ref id="dns-resolvconf"> をごらんください。

<sect2 id="high-dhcp">DHCP を用いてインターフェイスを設定する
<p>
DHCP を用いてインターフェイスを設定するには、
次のような行を含めるように <file>/etc/network/interfaces</file> 
を編集してください。
<example>
iface eth0 inet dhcp
</example>
これを機能させるには、 <ref id="net-dhcp"> で言及した DHCP クライアント
のうちいずれかをインストールする必要があります。

<sect2 id="high-wifi">無線 LAN インターフェイスの設定を行う
<p>
<package>wireless-tools</package> パッケージには、インターフェイスを
立ち上げる前に無線 LAN (802.11a/b/g) ハードウェアの設定を可能とする
フックスクリプト <file>/etc/network/if-pre-up.d/wireless-tools</file>
が含まれます。
設定は <prgn>iwconfig</prgn> プログラムを通じて行われます。
<manref name="iwconfig" section="8"> をごらんください。
<prgn>iwconfig</prgn> に与えることが可能なコマンドパラメータそれぞれ
に対して、"wireless-" 接頭辞を付けたパラメータのような名前で
<file>/etc/network/interfaces</file> 内にオプションとして含めることが
できます。
例えば、DHCP を用いて <tt>eth0</tt> を立ち上げる前に
<tt>eth0</tt> の ESSID を <tt>myessid</tt> に、暗号鍵を <tt>123456789e</tt>
に設定するには、次のような行を含むように
<file>/etc/network/interfaces</file> を編集しましょう。
<example>
iface eth0 inet dhcp
        wireless-essid myessid
        wireless-key 123456789e
</example>
このインターフェイスに対して <prgn>waproamd</prgn> を走らせている場合、
ESSID と暗号鍵を設定するこの方法を用いるべきではありません。
<prgn>ifup</prgn> が起動された時、<prgn>waproamd</prgn> は既に
ESSID と暗号鍵を設定済みです。
<ref id="trigger-waproamd"> をごらんください。

<sect2 id="high-ppp">PPP インターフェイスの設定を行う
<p>
<prgn>ifup</prgn> と
<prgn>ifdown</prgn> プログラムは
PPP インターフェイスの追加と削除のために
<prgn>pon</prgn> と
<prgn>poff</prgn> を使います。ですから、まずは
<ref id="low-ppp"> を読みましょう。
<p>
peer <tt>myisp</tt> に対して動くように PPP を設定する必要があると仮定します。
次のような行を含むように <file>/etc/network/interfaces</file> を
編集しましょう。
<example>
iface ppp0 inet ppp
        provider myisp
</example>
この一区切りが正しい位置にあれば、<prgn>ifup ppp0</prgn> は次を実行します。
<example>
pon myisp
</example>
不運なことに、<file>/etc/network/interfaces</file> にある <tt>ppp</tt>
節に <prgn>pppd</prgn> オプションをさらに供給することはいまのところ
できません。
<footnote>
bug <url id="&bug-iud-pon-args;" name="#196877"> 参照。
</footnote>
<p>
現在 PPP インターフェイスの補助的な設定を行うために <package>ifupdown</package>
を使うことはできません。<prgn>pon</prgn> は <prgn>pppd</prgn> が接続を
確立する前に存在するため、<prgn>ifup</prgn> は インターフェイスの
準備ができる前に <tt>up</tt> スクリプトを起動します。
このバグ
<footnote>
bug <url id="&bug-iud-ppp-wait;" name="#127786"> 参照
</footnote>
が修正されるまでは、<file>/etc/ppp/ip-up</file> 又は 
<file>/etc/ppp/ip-up.d/</file> にある補助的な設定を実行する必要性が
残ります。

<sect2 id="high-pppoe">PPPoE インターフェイスの設定を行う
<p>
たとえ、カスタマのマシンが Ethernet や ATM ネットワーク経由でつないでいた
としても、多くのブロードバンドインターネットサービスプロバイダ (ISP) は 
PPP を接続のネゴシエイトを行うために使用します。
これは PPP over Ethernet (PPPoE) により実現されます。この技術は
PPP ストリームを Ethernet フレーム内にカプセル化する技術です。
ISP が <tt><var>myisp</var></tt> と呼ばれていると仮定します。
まず peer <tt><var>myisp</var></tt> のための PPP と PPPOE を設定します。
最も簡単な方法は <package>pppoeconf</package> パッケージをインストールし、
コンソールから <prgn>pppoeconf</prgn> を起動することです。
次に、下に示す行を含むように <file>/etc/network/interfaces</file>
を編集します。
<example>
iface eth0 inet ppp
        provider <var>myisp</var>
</example>
<!--
もっと良いのは次の内容だが検証が必要
<example>
mapping eth0
        script /root/bin/echo-ppp0

iface ppp0 inet ppp
        provider <var>myisp</var>
</example>
ここで、
<example>
# cat &gt; /root/bin/echo-ppp0 &lt;&lt;EOF
# /bin/sh
echo ppp0
EOF
# chmod 755 /root/bin/echo-ppp0
</example>
という起動スクリプトを作成する。
-->
<p>
時々 PPPoE over DSL を用いた時の Maximum Transmit Unit (MTU) 
についての問題が発生します。
詳細は <url id="&dsl-howto;" name="DSL-HOWTO"> をごらんください。
<p>
ブロードバンドモデムがルータ機能を持っている場合、モデム/ルータは
それ自身で PPPoE 接続を操作し、LAN 側では単なる インターネットへの
Ethernet ゲートウェイにしか見えないことに注意してください。

<sect2 id="high-dual">ゲートウェイ用に複数の Ethernet インターフェイスを設定する<p>
<file>eth0</file> が DHCP により設定した IP アドレスを用いてインターネット
に接続し、<file>eth1</file> が固定 IP アドレス <tt>192.168.1.1</tt>
を用いて LAN に接続していると仮定します。
次に示すような行を含むように <file>/etc/network/interfaces</file>
を編集しましょう。
<example>
iface eth0 inet dhcp

iface eth1 inet static
        address 192.168.1.1
        netmask 255.255.255.0
</example>
<ref id="net-router"> に記述しているようにホストの NAT を有効にしている
場合、LAN 上の全てのホストでインターネット接続を共有できます。

<sect2 id="high-virtual">仮想インターフェイスを設定する
<p>
仮想インターフェイスを用いると、1つの Ethernet カードを複数の IP
サブネットへのインターフェイスとして設定できます。
例えば、ホストが 192.168.0.x/24 の LAN ネットワーク上にあると仮定
します。ホストを既存の Ethernet カードを用いて DHCP を用いて供給される
パブリックな IP アドレスを用いてインターネットに接続したい場合、
次に示すような行を含むように <file>/etc/network/interfaces</file> 
を編集しましょう。
<example>
iface eth0 inet static
        address 192.168.0.1
        netmask 255.255.255.0
        network 192.168.0.0
        broadcast 192.168.0.255

iface eth0:0 inet dhcp
</example>
インターフェイス <tt>eth0:0</tt> は仮想インターフェイスです。
これが立ち上がると、親の <tt>eth0</tt> も立ち上がります。

<sect1 id="net-reconf"><package>ifupdown</package>論理インターフェイス定義を用いた高レベルなネットワーク設定
<p>
次の章では、読者は <strong>物理インターフェイス</strong> と
<strong>論理インターフェイス</strong> の違いを理解することが重要に
なります。
<footnote>
この技術は <package>ifupdown</package> のドキュメントで使用されています。
</footnote>
<strong>物理インターフェイス</strong>は私達が 通常"インターフェイス" 
と呼んでいる物でカーネルによって
<tt>eth0</tt>, <tt>ppp1</tt> などと名付けられるものです。
<strong>論理インターフェイス</strong>は物理インターフェイスの
変数パラメータに割り当てられる値のセットのことです。
この説明が分かりにくいなら、
"論理インターフェイス <var>X</var> として設定する"
という表現を
"インターフェイスプロファイル <var>X</var> を用いて設定する"
に置き換えます。
<p>
<file>/etc/network/interfaces</file> にある <tt>iface</tt> 定義は
実際は物理インターフェイスの定義ではなく、論理インターフェイスの
定義です。
<footnote>
<tt>auto</tt> 行にあるインターフェイス名は物理インターフェイスで
無ければいけません。論理インターフェイスではありません。
</footnote>
インターフェイスを絶対再設定したくない場合、物理インターフェイス <var>X</var>
は標準では論理インターフェイス <var>X</var> として設定されるので無視できます。
<p>
しかしながら、あなたのコンピュータが仕事場と家の間を持ち運ぶノート PC である
と仮定しましょう。コンピュータを職場のネットワークに接続した時と
家庭内 LAN に接続したときでは、接続する場所に従い <tt>eth0</tt> を再設定
する必要があります。
<p>
まず (以前行ったように <tt>eth0</tt> ではなく) 二つの論理インターフェイス
<tt>home</tt> と <tt>work</tt> を定義し、インターフェイスが家庭内 LAN 
と職場ネットワークのために設定されるかをそれそれ記述します。
<example>
iface home inet static
        address 192.168.0.123
        netmask 255.255.255.0
        gateway 192.168.0.1

iface work inet static
        address 81.201.3.123
        netmask 255.255.0.0
        gateway 81.201.1.1
</example>
そして、物理インターフェイス <tt>eth0</tt> をコマンドラインで、次のように
適切な設定ファイルを指定して立ち上げます。
<example>
# ifup eth0=home
</example>
<p>
職場ネットワークのために <tt>eth0</tt> を再設定するには、次のコマンド
を実行します。
<example>
# ifdown eth0
# ifup eth0=work
</example>
<p>
上記で書かれた <file>interfaces</file> ファイルを用いると、もはや
<tt>ifup eth0</tt> を用いるだけで <tt>eth0</tt> を立ち上げる
ことができることに注意してください。
この理由としては、<prgn>ifup</prgn> は物理インターフェイスの名前を
標準の論理インターフェイスの名前として使用しており、私達の例では
<tt>eth0</tt> という論理インターフェイスを定義していないためです。

<sect1 id="net-magic-reconf"><package>ifupdown</package> を用いた魔法のような
ネットワーク設定
<p>
インターフェイス名は <prgn>ifup</prgn> が起動する時に他の
名前に "マップ" できます。
どのような名前にマップされるかは状況に依存して変更できます。
それゆえ、<prgn>ifup</prgn> は前もって定義された候補の中から適切な
論理インターフェイスとして与えられた物理インターフェイスを立ち上げる
ように設定できます。
<p>
論理インターフェイスの名前のマッピングは次のように発生します。
<list compact>
<item>論理インターフェイス名が <prgn>ifup</prgn> コマンドラインに
与えられていない場合、物理インターフェイス名は論理インターフェイス名
の初期値として使用される。
<item>論理インターフェイス名が <tt>mapping</tt> 節の glob パターンに
マッチする場合、新しい論理インターフェイス名の生成にマッピングが
適用される。これは各マッピング節に対して順々に行われる。
<item>最後の論理インターフェイス名が <file>/etc/network/interfaces</file>
に定義されている論理インターフェイスの定義のラベルである場合、
物理インターフェイスが論理インターフェイスとして立ち上げられる。
上記に当てはまらない場合は、<prgn>ifup</prgn> が "Ignoring unknown interface" 
というメッセージを表示して終了する。
</list>
<tt>mapping</tt> 行の文法は次のとおりです。
<example>
mapping <var>glob-pattern</var>
         script <var>script-name</var>
        [map <var>script input</var>]
</example>

<tt>mapping</tt> 行で示されたスクリプトは 
<strong>物理</strong>インターフェイス名を引数にし、
"map" 行の "map" に続く ("map"自身を除く) 全ての内容を標準入力に送り込み
毎回起動されます。
スクリプトは終了前に標準出力にマッピングの結果を表示します。
<p>
例えば、次の <tt>mapping</tt> 行は <tt>eth0</tt> を <tt>home</tt>
論理インターフェイスとして <prgn>ifup</prgn> を立ち上げさせます。
<example>
mapping eth0
        script /usr/local/sbin/echo-home
</example>
ここで <prgn>/usr/local/sbin/echo-home</prgn> の内容は次のようなものです。
<example>
#!/bin/sh
echo home
</example>
<p>
マッピングはスクリプトを用いて行われるので、ある種のテストに基づいて
論理インターフェイスを選択することが可能です。
この例は <ref id="high-guessnet"> を参照ください。

<sect2 id="high-guessnet"><package>guessnet</package>を使った論理インターフェイス選択
<p>
<package>guessnet</package> をインストールして
<file>/etc/network/interfaces</file> に次のような行を
追加しましょう。
<example>
mapping eth0
        script guessnet-ifupdown
        map home
        map work
</example>
<prgn>ifup eth0</prgn> すると、<prgn>guessnet</prgn> は
<tt>eth0</tt> が <tt>home</tt> と <tt>work</tt> のどちらで立ち上げられたかを
チェックします。これには、論理インターフェイスの定義内に保存された情報を
用います。

<sect2 id="high-laptop-net"><package>laptop-net</package>を使った自動ネットワーク設定
<p>
<package>laptop-net</package> パッケージはネットワークの再設定に
異なる手法を取っています。laptop-net は <package>ifupdown</package> の
論理インターフェイスを利用していませんが、その代わり、固有の
設定 "スキーム" とシステム "プロファイル" というシステムを持っています。
しかしながら、物理インターフェイスを設定するために、laptop-net は依然
<prgn>ifup</prgn> と <prgn>ifdown</prgn> を使用しています。
詳細な情報は、<package>laptop-net-doc</package> にある良質な情報に
当たってください。

<sect1 id="high-network-manager"><package>network-manager</package> を用いた
自動ネットワーク設定
<p>
<package>network-manager</package> プログラムは現在 Fedora 開発者により
開発中であり、Ubuntu 用にパッケージされています。いつか Debian に表れて
ifupdown や類似品を時代遅れにするかもしれません。
  	 
<sect id="high-rename">カーネルによる一貫性のないインターフェイスの命名を扱う
<p>
<tt>eth0</tt>, <tt>eth1</tt> などの名前は kernel がインターフェイスを作成する
順番に従い kernel により割り当てられます。
一方、ブート時に検知されるアダプタは通常毎回同じ順番で検知され、それゆえ
毎回同じ名前が割り当てられます。
ホットプラグされたアダプタにはこれは当てはまりません。ホットプラグされた
アダプタはあらゆる順序で検知され、異なる状況下では kernel により結局異なる
名前が割り当てられる結果となります。
<p>
現行の<package>udev</package>パッケージではコンフィギュレーション
によりこの問題を解決できます。
<!--
この事実により、ネットワークアダプタがホットプラグされるシステムでは
<tt>eth0</tt>, <tt>eth1</tt> などのデフォールトマッピングに
頼るべきではありません。むしろ論理インターフェイスに独自の名前を与え、
論理インターフェイスにどのアダプタが割り当てられるかを制限する次の二つの
方法を利用すべきです。
<p>
最初の方法は、 kernel がアダプタに内在する特性に従いインターフェイスに
名前を割り当てるように、(<package>net-tools</package> パッケージにある )
<prgn>nameif</prgn> ユーティリティ又はより柔軟性のある
(<package>ifrename</package> パッケージにある) <prgn>ifrename</prgn>
ユーティリティを利用することです。
この命名手順を用いる事で、物理インターフェイス名がどのアダプタを指すか
に用いられるようになります。
<p>
もう一つの方法は、<prgn>ifup</prgn> のマッピング機構を利用し、
物理インターフェイスが立ち上がる際に内在するアダプタの特性に従って
論理インターフェイスが選択されるようにする方法がある。
<p>
例えば <tt>net1</tt> と <tt>net2</tt> 各々のネットワークで使う 2 つの
ネットワークアダプタを持っていると仮定しましょう。
<file>/usr/share/doc/ifupdown/examples/</file> ディレクトリには
アダプタの Media Access Controller アドレス (MAC アドレス)
に基づいて論理インターフェイスが選択されるマッピングスクリプト
があります。まずスクリプトを適当なディレクトリにインストールします。
<example>
# install -m770 /usr/share/doc/ifupdown/examples/get-mac-address.sh \
   /usr/local/sbin/
</example>
<file>/etc/network/interfaces</file>に以下の行を追加する。
<example>
   mapping eth0
        script /usr/local/sbin/get-mac-address.sh
        map 02:23:45:3C:45:3C net1
        map 00:A3:03:63:26:93 net2
</example>
もう少し複雑な例は <ref id="high-multistage-mapping"> を参照してください。
<p>
どちらの方法を適用する場合でも、アダプタを認識するために最も広く用いられる
特性は MAC アドレスです。
-->

<sect id="net-trigger">ネットワーク設定のトリガを設定する
<p>
インターフェイスがどのように設定や再設定されるのかを見てきました。
これらは適切な時期に行われる必要があります。
<p>
伝統的にネットワークは <file>/etc/rcS.d/S40networking</file> initscript
経由でブートシーケンスの間に設定され、滅多に再設定されませんでした。
ネットワークに依存するサービスはブートシーケンスで後に起動されました。
シャットダウン又はリブート時に initscript は逆の順番で起動されました。
<p>
しかしながら、現在 GNU と Linux において動的に変化するハードウェアと状況
のサポートがトレンドです。前者のサポートはホットスワップ可能な PCMCIA 
カードのために追加されました。より最近では、<tt>hotplug</tt> 機構が
追加され、多くの周辺機器がコンピュータの起動中に抜き差しできるように
なりました。
これにはネットワーク関連のハードウェアが含まれます。
ハードウェアに依存するホットスワップされるハードウェアはハードウェアが
挿入された後に起動され、ハードウェアが外された時に停止する必要がある
ことに注意してください。
これはこの種のサービスが System V init システムの制御から外され、
その代わりに <package>ifupdown</package> の制御下に置かれる必要がある
ことを意味しています。
<p>
例えば、initscript <file>/etc/init.d/foo</file> により制御される
サービス <tt>foo</tt>  が動的に再設定されるネットワークインターフェイス
<tt>eth0</tt> に依存するとします。
<list compact>
<item>まず init システムの制御から <tt>foo</tt> を取り除きます。
<package>sysv-rc</package> init システムを利用している場合、
次を行います。
<footnote>
詳細は <ref id="runlevels"> を参照下さい。
</footnote>
<example>
# rm /etc/rc[2345].d/S??f00
</example>
<item>次に foo initscript を呼び出す <tt>up</tt> と <tt>down</tt> 
オプションを <file>/etc/network/interfaces</file> にある 
<tt>eth0</tt> 行に追加することにより <tt>foo</tt> を 
<package>ifupdown</package> の制御の元に置きます。
<example>
iface eth0 inet dhcp
        up /etc/init.d/foo start
        down /etc/init.d/foo stop
</example>
</list>

<sect1 id="trigger-auto">ブート時にネットワーク設定のトリガーを設定する

<p>
ブート時に <prgn>/etc/rcS.d/S40networking</prgn> init スクリプトは
<prgn>ifup -a</prgn> コマンドを起動します。
これは <file>/etc/network/interfaces</file> の <tt>auto</tt> 節にリスト
されている全ての物理インターフェイスを立ち上げます。
<p>
最近動的な方法を用いてネットワーク設定を操作する方がより良いことが
たびたびあります。
いったん動的に変化するハードウェアのサポートメカニズムが機能すると、
まるで動的であったかのように静的なハードウェアを扱うことがシンプルになります。
ブートはもう 1つの hotplug イベントとして扱えます。
(<ref id="trigger-hotplug"> 参照)
<p>
しかしながら、ほとんど全ての場合、少なくともループバックデバイス
<tt>lo</tt> はブート時に立ち上げておきたいでしょう。
それゆえ、<file>/etc/network/interfaces</file> に次の行が含まれている
ことを確認してください。
<example>
auto lo

iface lo inet loopback
</example>
ブート時に他の物理インターフェイスも立ち上げたい場合、 <tt>auto</tt>
行にさらに物理インターフェイスを追加できます。
<tt>auto</tt> 行に <strong>決して</strong> PCMCIA インターフェイスを
リストしてはなりません。PCMCIA <prgn>cardmgr</prgn> はブートシーケンス
において <prgn>/etc/rcS.d/S40networking</prgn> が起動する時よりも後に
起動されます。

<sect1 id="trigger-hotplug">ネットワーク設定のトリガを設定する &ndash; <package>hotplug</package>
<p>
hot-plug のサポートを追加するには、<package>hotplug</package> パッケージ
をインストールしてください。
<p>
ネットワークハードウェアはブート時や、カード (例えば PCMCIA カード) を
マシンに挿入した時、 <prgn>discover</prgn> が起動され、必要なドライバ
モジュールをロードした時にもホットプラグできます。
<p>
kernel が新しいハードウェアを検知すると、ハードウェアのドライバを初期化し、
設定を行うために <prgn>hotplug</prgn> プログラムを起動します。
その後、ハードウェアが削除されると、kernel は異なる環境変数設定を
用いて <prgn>hotplug</prgn> を再び起動します。
&debian; では、<prgn>hotplug</prgn> が呼ばれると、<file>/etc/hotplug/</file>
と <file>/etc/hotplug.d/</file> にあるスクリプトを起動します。
詳細は <manref name="hotplug" section="8"> をごらんください。
<p>
新たに挿入されたネットワークハードウェアはスクリプト 
<file>/etc/hotplug/net.agent</file> により設定されます。
<footnote>
<file>/etc/hotplug.d/net/</file> にインストールされたあらゆる
フックスクリプトによっても設定されるかもしれません。
例えば <package>ifplugd</package> や <package>waproamd</package>
パッケージはフックスクリプトをそこにインストールします。
</footnote>
PCMCIA ネットワークカードが挿入され、<tt>eth0</tt> が利用可能になる
と仮定します
<footnote>
<package>hotplug</package> はバージョン0.0.20040329-4あたりでは
ここに記載されたのと異なった挙動をするモードに設定できる。
そのようなモードの一つはいわゆる "all" モードで、
<prgn>hotplug</prgn> は全てのホットプラグ可能なインターフェイスを
起動します。そうのようなもう一つのモードはいわゆる "auto" モードで
<prgn>hotplug</prgn> は <file>/etc/network/interfaces</file>
の中に <tt>auto</tt> 行にリストされている場合にのみインターフェイスを
起動します。このような特殊なモードでは <prgn>ifup</prgn> は
<tt>=hotplug</tt> というサフィックス無しで起動されます。
</footnote>
。
<example>
ifup eth0=hotplug
</example>
<file>/etc/network/interfaces</file> に論理インターフェイスの定義を追加するか、
<tt>hotplug</tt> という名のマッピングをしなければ、このコマンドは
何もしません。
コマンドが <tt>eth0</tt> を設定するようにするには、次の行を
<file>/etc/network/interfaces</file> に追加しましょう。
<example>
mapping hotplug
        script echo
</example>
<ref id="net-reconf"> で説明したように、これは次と等価になるように
上に示したコマンドをマップします。
<example>
ifup eth0=eth0
</example>
<p>
もしインターフェイスをコントロールするために <prgn>hotplug</prgn> 
によってスタートした <prgn>ifplugd</prgn> や <prgn>waproamd</prgn> 
のインスタンスを用いている場合、このようなマッピング行を
追加<strong>しないでください</strong>。
<p>
<tt>eth0</tt> のみを使いたく、他のインターフェイスをホットプラグ時に
立ち上げたくない場合、次のように <prgn>echo</prgn> の代わりに
<prgn>grep</prgn> を使いましょう。
<example>
mapping hotplug
        script grep
        map eth0
</example>
さらに小技を学ぶには、<ref id="net-magic-reconf"> と <url id="&f-hotplug;">
をごらんください。

<sect1 id="trigger-ifplugd">ネットワーク設定のトリガを設定する &ndash; <package>ifplugd</package>
<p>
<package>ifplugd</package> デーモンはハードウェアがネットワークに
接続されているかどうかによりインターフェイスの立ち上げや切断を行います。
このプログラムは Ethernet インターフェイスに接続されている通信中の
ケーブルや無線 LAN インターフェイスとつながったアクセスポイントを検知します
(無線 LAN インターフェイスの場合は実際には <prgn>waproamd</prgn> 
を使うのでしょうが) 。
<prgn>ifplugd</prgn> がリンクの状態の変化を検知すると、標準では
インターフェイスに対して <prgn>ifup</prgn> や <prgn>ifdown</prgn>
を呼び出します。

<sect1 id="trigger-waproamd">ネットワーク設定のトリガを設定する &ndash; <package>waproamd</package>
<p>
<prgn>waproamd</prgn> デーモンは <prgn>ifplugd</prgn> と
無線 LAN カードと一緒に使うように設計されている以外は同じです。
無線 LAN ハードウエアがつながるアクセスポイントをアクティブに
スキャンします。つながった場合には、<prgn>waproamd</prgn>
は <prgn>ifup</prgn> を起動します。
<p>
もし <prgn>waproamd</prgn> を使っている場合には、無線 LAN カードは
<prgn>waproamd</prgn> を通じて設定されます。つまり、
<file>/etc/network/interfaces</file> の <tt>wireless-*</tt>
オプションは使いません。

<sect1 id="trigger-pcmcia">ネットワーク設定と PCMCIA
<p> 
PCMCIA ネットワークインターフェイス (2.4 と 2.6 カーネル)
を設定するための可能なアプローチはいくつか存在します。
<list compact>
<item>32 ビット PCI (CardBus) PCMCIA ネットワークカード用
  <list compact>
  <item><package>ifupdown</package> が <package>hotplug</package>
   によりコントロールされる。
  <list compact>
  <item>Woody と Sarge
    <ref id="trigger-hotplug"> に記述されているように、
    <file>/etc/network/interfaces</file> にマッピング行を追加
    することにより、<package>ifupdown</package> への
    <package>hotplug</package> の制御をローカルで有効にする
    必要があります。
  </list>
</list>
<item>16 ビット PCMCIA ネットワークカード用
  <list compact>
  <item>モジュールのロードを制限された <package>pcmcia-cs</package> を用いて
  <package>hotplug</package> により制御された <package>ifupdown</package>
   <list compact>
   <item><strong>推奨</strong>
<!--
      <item>Sarge 以降の <package>pcmcia-cs</package>
        <file>/etc/default/pcmcia</file> 中で確実に
	<tt>REFRAIN_FROM_IFUP=yes</tt> とすることで
	<package>pcmcia-cs</package> が
        <package>hotplug</package> の邪魔をしないようにする必要があります。
-->
      <item>Woody と Sarge 
        <file>/etc/pcmcia/network</file> の先頭に <tt>exit 0</tt> を
        加えることにより、ローカルで無効にする必要があります。
        また、<ref id="trigger-hotplug"> に記述されているように、
        <file>/etc/network/interfaces</file> にマッピング行を追加
        することにより、<package>ifupdown</package> への
        <package>hotplug</package> の制御をローカルで有効にする
        必要があります。
      </list>
    <item>標準の <file>/etc/pcmcia/network</file> 経由で
     <package>pcmcia-cs</package> により制御される <package>ifupdown</package>
     <list compact>
     <item><strong>時代遅れ</strong> だが Woody と Sarge では依然標準
     </list>
    <item><file>/etc/pcmcia/network.opts</file> にある特別なコードを
     経由して <package>pcmcia-cs</package> により制御される低レベルツール
     <list compact>
     <item><strong>時代遅れ</strong>
     <item>Woody および Sarge
     <file>/etc/pcmcia/network.opts</file> を編集することにより
     特別なコードが有効にされます。
     </list>
  </list>
</list>
<p>
16 ビットカードに関する推奨アプローチは Linux 2.4 のホットプラグ
サブシステムが PCMCIA もサポートするようになった事を利用しています。
<footnote>
過去の &debian; リリースでは、PCMCIA ネットワークカードの標準的な
設定方法は <prgn>cardmgr</prgn> を通じた <file>/etc/pcmcia/network</file>
と <file>/etc/pcmcia/network.opts</file> フックスクリプトでした。
これらのフックスクリプトはより一般的な目的の hotplug 能力が得られた
Linux の前の時代に開発されました。
<p>
標準状態では、
インターフェイスが追加されると <prgn>ifup</prgn> を、
インターフェイスが削除されると <prgn>igdown</prgn> を単に呼び出すだけの
これらのスクリプトをまだ使っている人がいます。
上に述べたように、今はインターフェイスの追加削除の作業を行うには、
<prgn>hotplug</prgn> を使うことを推奨します。
<p>
<file>/etc/pcmcia/network.opts</file> にある特定の変数が <tt>y</tt>
にセットされると有効にされる低レベルなネットワーク設定コマンドを呼ぶ
&debian; Woody の特別なシステムを利用する人もまだいます。
このシステムには複数の問題があります。
問題としては、競合条件による不具合や、16 ビット PCMCIA カードしか
動かないこと、<package>ifupdown</package> が行うために残した方が
良いことをやってしまうことがあります。
結果としてこれは時代遅れです。
</footnote>
<!--
  XXX FIXME XXX
  I do not know to what extent 2.4 kernel needs pcmcia-cs.
  But for now translate as below.  So we can chabge translation later too.
-->
PCMCIA ネットワークカードはホットプラグ可能です。
従って、PCMCIA カードを通じてネットワークを要求するあらゆるサービスは
カードの挿入時にサービスを開始し、カードを抜いた時にサービスを停止
するように設定されなければなりません。
これは通常サービスが <tt>ifup</tt> で起動され、<tt>ifdown</tt> で停止される
ように調整することにより実現されます。
しかしながら、PCMCIA ネットワークカードをコールドプラグするように
設定するのを選択する人も中にはいます。
システムをブートする前にカードを挿入し、ブートシーケンス中で
カードを通じたネットワークを要求するサービスを起動するのです。
サービスの開始前にカードが完全に設定されるのを保証するため、
次に示す設定を行う必要があります。
<list compact>
<item><prgn>cardmgr</prgn> がフォアグラウンドで走るように
 <file>/etc/default/pcmcia</file> 中で
 <tt>CARDMGR_OPTS="-f"</tt> と設定します。
<item><file>/etc/rc?.d/S20pcmcia</file>を <file>/etc/rc?.d/S12pcmcia</file>
  などとリネームします。
</list>
<p>
16 ビットの  PCMCIA カードを使っている場合は
<package>pcmcia-cs</package> がまだ必要なことに注意して下さい。
このパッケージに含まれる <prgn>cardmgr</prgn> デーモンは
ソケットの管理やドライバーモジュールの起動に必要です。
ネットワークの設定を <file>/etc/pcmcia/network</file>
を通して行いたく無いだけです。
<p>
<prgn>cardmgr</prgn>が正常に動作するには、
16 ビット PCMCIA カードにリソースを割り当てるよう、
<file>/etc/pcmcia/config.opts</file> を編集する必要があるかもしれません。

より詳しい情報は 
<url id="&pcmcia-howto;" name="Linux PCMCIA HOWTO">
をごらんください。

<sect id="high-multistage-mapping">多段マッピング
<p>
あなたのネットワークカードがホットプラグされ
<ref id="trigger-hotplug"> に書かれている
自動設定が有効になっていると仮定しましょう。
さらに論理インターフェイスを、
(<ref id="high-rename"> に書かれたように)アダプタ固有の
物理インターフェイスの特徴に従かうか、
(例えば <ref id="high-guessnet"> に書かれたように)
インターフェイスがつながれているネットワークの特徴に従って
「物理」インターフェイスにマップする必要が有ると仮定しましょう。
<p>
第一段階のマッピングは <tt>hotplug</tt> のグループ名が
与えられると、インターフェイスがホットプラグされると
kernel が割り当てたしたインターフェイス名を出力します。
第二段階のマッピングは kernel が割り当てたインターフェイス名が
与えられると、アダプタの名前を出力します。
第三段階のマッピングはアダプタの名前が与えられると、
ネットワーク環境に基づく論理インターフェイス名を出力します。
<example>
# hotplug にインターフェイスを起動させる
mapping hotplug
        script echo

# インターフェイスが有線か無線 LAN かを決定
mapping eth?
        script /usr/local/sbin/get-mac-address.sh
        map 02:23:45:3C:45:3C wired
        map 00:A3:03:63:26:93 wifi

# どの有線ネットワークが使えるかを決める
mapping wired
        script guessnet-ifupdown
        map work-wired
        map home

# どの無線 LAN ネットワークが使えるかを決める
mapping wifi
        script ifscout
        map starbucks
        map work-wireless

iface work-wired inet static
        ...
</example>

<sect id="net-service-conf">ネットワークサービスの設定
<p>
デスクトップやホームサーバ環境における典型的なネットワークサービスの設定には
次が挙げられます。
<list compact>
<item>インターネット <em>スーパーサーバ</em> と TCP/IP デーモンラッパ。
<ref id="tcpd"> 参照。
<list compact>
<item><file>/etc/inetd.conf</file>
</list>
<item><package>ssh</package>: OpenSSH secure shell。<ref id="ssh"> 参照。
<list compact>
<item><file>/etc/ssh/ssh_config</file>
<item><file>/etc/ssh/sshd_config</file>
</list>
<item><package>exim</package>: メール転送エージェント。
<ref id="name-mail"> および <ref id="mta"> 参照。
<list compact>
<item><file>/etc/exim/exim.conf</file>
<item><file>/etc/mailname</file>
<item><file>/etc/aliases</file>
<item><file>/etc/email-addresses</file>
</list>
<item><package>fetchmail</package>: POP3 アカウントからメールを取得。
<ref id="fetchmail"> 参照。
<list compact>
<item><file>/etc/fetchmailrc</file>
</list>
<item><package>procmail</package>: ローカルのメール配達およびフィルタプログラム。<ref id="procmail"> 参照。
<list compact>
<item><file>~/.procmailrc</file>
</list>
<item>ホスト名と DNS (プロキシ、キャッシュなど)。<ref id="name-host"> 
と<ref id="net-dns"> 参照。
<list compact>
<item><file>/etc/host.conf</file>
<item><file>/etc/hostname</file>
<item><file>/etc/hosts</file>
<item><file>/etc/hosts.allow</file>
<item><file>/etc/hosts.deny</file>
<item><file>/etc/resolv.conf</file>
<item><file>/etc/bind/named.conf</file> (編集)
<item><file>/etc/bind/db.lan</file> (LAN ホスト用に追加)
<item><file>/etc/bind/db.<var>192.168.0</var></file> (LAN の逆引き用に追加)
</list>
<item>DHCP。<ref id="net-dhcp"> 参照。
<list compact>
<item><file>/etc/dhcp3/dhclient.conf</file> (DHCP クライアント)
<item><file>/etc/default/dhcp3-server</file> (DHCP サーバ)
<item><file>/etc/dhcp3/dhcpd.conf</file> (DHCP サーバ)
</list>
<item><package>cvs</package>: バージョン管理システム。<ref id="cvs"> 参照。
<list compact>
<item><file>/etc/cvs-cron.conf</file>
<item><file>/etc/cvs-pserver.conf</file>
</list>
<item><package>nfs-kernel-server</package>: ネットワークファイルシステム。
<ref id="nfs"> 参照。 (unix ライクシステム用)
<list compact>
<item><file>/etc/exports</file>
</list>
<item><package>samba</package>: Windows 用のネットワークファイルシステムおよびプリンタ共有。<ref id="samba"> および <ref id="smbmount"> 参照。
<list compact>
<item><file>/etc/samba/smb.conf</file>
</list>
<item>プリンタデーモンシステム。<ref id="printer"> 参照。
<list compact>
<item><file>/etc/printcap</file> (lpr 用)
</list>
<item><package>apache</package> と <package>apache2</package> ウェブサーバ。
<list compact>
<item><file>/etc/apache/*</file>
<item><file>/etc/apache2/*</file>
</list>
<item><package>squid</package>: ウェブプロキシキャッシュサーバ。
<list compact>
<item><file>/etc/squid/*</file>
</list>
</list>

<!--
XXX FIXME XXX: 
The network service section needs more detailed contents.
Volunteers are welcomed.  
-->
<!-- explain each types under sect1 -->
<!-- equivalent ones under sect2 -->
<!-- avoid duplication with tune.sgml -->
<!-- this needs major rewrite -->
<!-- Keep It Short and Simple (KISS) -->
<!-- Use /bin/sh instead of English -->

<sect id="net-trouble">ネットワークのトラブルシュート
<p>
ネットワークに関する問題に直面したら、次の出力を最初の真偽の確認として
チェックしてください。
<example>
# ifconfig
# cat /proc/pci
# cat /proc/interrupts
# dmesg | more
</example>
又、<ref id="net-test"> をごらんください。
<!-- add id="..." to corresponding 3 sect1 tags in tips.sgml -->
<!-- That section should be moved here //JDTH -->
<!-- Yes.  But when you do, do it for all languages and fix 
 version tracking number if you can -->
<p>
特定のウェブサイトを見れない問題に直面した場合は、<ref id="killecn">
をごらんください。

<sect id="net-router">ゲートウェイルータを構築する
<p>
&debian; ホストはネットワークアドレス変換 (NAT、マスカレードとしても知られる)
、メール転送、DHCP、DNS キャッシング、HTTP プロキシキャッシング、CVS
サービス、NFS サービス、そして Samba サービスを行う多目的の
ゲートウェイマシンにできます。これらの設定の例は <ref id="ipmap">
をごらんください。

<sect1 id="router-netfilter">Netfilter 設定
<p>
netfilter/iptables プロジェクトは Linux 2.4 以降のための
ファイアーウォールサブシステムです。
<url id="&netfilterhome;" name="Netfilter"> をごらんください。
この文書では多くのネットワーク設定例が説明されています。

<sect2 id="netfilter-basics">netfilter の基礎
<p>
Netfilter は五つの組込みチェイン、すなわち
PREROUTING, INPUT, FORWARD, OUTPUT そして POSTROUTING
を使うパケットを処理します。
<example>
                ルーティング
                方向
IN ------> PRE ---> ------> FORWARD -----> ----> POST -----> OUT
interface   ROUTING ＼       filter       /       ROUTING     interface
              DNAT        |      tracking     ^       SNAT
            REDIRECT    |                      |       MASQUERADE
                              v                     |
                          INPUT                OUTPUT
                             | filter                ^ filter,DNAT 
                             v                       |
                           \--&gt; ローカルのプロセス --/
                                ユーザスペースのプログラム
</example>

<sect2 id="netfilter-table">Netfilter テーブル
<p>
パケットはそれぞれの組込みチェインにて次のテーブルを用いて処理されます。
<list compact>
<item>フィルタ (パケットフィルタ、標準)
<list compact>
<item>INPUT (ルータ自体に入り込むパケット用)
<item>FORWARD (ルータを通ってルーティングされているパケット用)
<item>OUTPUT (ローカルで生成されたパケット用)
</list>
<item>nat (ネットワークアドレス変換)
<list compact>
<item>PREROUTING (入り込んですぐにパケットを変換するため)
<item>OUTPUT (ルーティング前にローカルで生成されたパケットを変換するため)
<item>POSTROUTING (出て行こうとするパケットを変換するため)
</list>
<item>mangle (ネットワークアドレス変換、kernel 2.4.18 以降のみでうまく動く)
<list compact>
<item>全ての組込チェインが利用可能
</list>
</list>

<sect2 id="netfilter-target">Netfilter のターゲット
<p>
ファイアーウォールのルールにはいくつかのターゲットがあります。
<list compact>
<item>四つの基本的なターゲット
<list compact>
<item>ACCEPT はパケットの通過を許すことを意味する。
<item>DROP はパケットを落とすことを意味する。
<item>QUEUE はパケットをユーザスペースに通すことを意味する。(kernel がサポートしている場合)
<item>RETURN はこのチェインの検討を止め、以前の (呼び出し元) チェイン内の
次のルールから検討を始めることを意味する。
</list>
<item>拡張されたターゲット。
<list compact>
<item>LOG は kernel ログに記録する。
<item>REJECT はエラーパケットを送信し、そのパケットを落とす。
<item>SNAT パケットの送信元アドレスを変換し、POSTROUTING チェインでのみ使用する
(nat テーブルのみ)
<example compact>
--to-source ipaddr[-ipaddr][:port-port]
</example>
<item>MASQUERADE は SNAT と同じだが動的に割り当てられる IP (ダイアルアップ) 
接続用 (nat テーブルのみ)
<example compact>
--to-ports port[-port]
</example>
<item>DNAT はパケットの送信先アドレスを変換し、PREROUTING と OUTPUT チェイン
とこれらのチェインからのみ呼ばれるユーザが定義したチェインで使用される。
(nat テーブルのみ)
<example compact>
--to-destination ipaddr[-ipaddr][:port-port]
</example>
<item>REDIRECT はマシン自身にパケットを送るためにパケットの送信先 IP アドレス
をマシン自身の IP アドレスに変換する。
<example compact>
--to-ports port[-port]
</example>
</list>
</list>

<sect2 id="netfilter-command">Netfilter コマンド
<p>
<prgn>iptables</prgn> の基本的なコマンドは次のようになります。
<example compact>
iptables -N <var>chain</var>                   #<var>chain</var> を作成

iptables -A <var>chain</var> \                 # <var>chain</var> にルールを追加
         -t <var>table</var> \                 # <var>table</var> を使用 (filter, nat, mangle)
         -p <var>protocol</var> \              # tcp, udp, icmp, 又はこれら全て
         -s <var>source-address[/mask]</var> \
         --sport <var>port[:port]</var> \      # -p が tcp 又は udp の場合は送信元ポート
         -d <var>destination-address[/mask]</var> \
         --dport <var>port[:port]</var> \      # -p が tcp 又は udp の場合は送信先ポート
         -j <var>target</var> \                # マッチした場合の行動
         -i <var>in-interface-name</var> \     # INPUT,  FORWARD, PREROUTING 用
         -o <var>out-interface-name</var>      # FORWARD, OUTPUT, POSTROUTING 用
</example>

<sect2 id="ip-masq">ネットワークアドレス変換
<p>
LAN 上のマシンは LAN 上の IP アドレスをインターネット上で使える IP
アドレスに変換するゲートウェイを経由してインターネットのリソースに
アクセスできます。
<example>
# apt-get install ipmasq
</example>
<prgn>ipmasq</prgn> の防護を強化するためにサンプルルールを追加してください。
<p>
又、ネットワークに PCMCIA NIC 経由でアクセスしている場合、<prgn>ipmasq</prgn>
が <file>/etc/pcmcia/network.opts</file> (<url id="&f-ipmasq;"> 参照) 又は
<file>/etc/network/interfaces</file> (<ref id="trigger-pcmcia"> と <ref id="net-trigger">
参照) から起動される必要があります。

<sect2 id="ip-redirect">SMTP 接続をリダイレクトする (2.4 用)
<p>
他の LAN 環境で利用するように設定しているノート PC を持っており、
再設定せずにノート PC 上でメーラを使いたいとします。
<p>
ゲートウェイマシンに <prgn>iptables</prgn> を通じて次のルールを 
追加し、SMTP 接続をゲートウェイマシンにリダイレクトします。
<example>
# iptables -t nat -A PREROUTING -s 192.168.1.0/24 -j REDIRECT \
           -p tcp --dport smtp --to-port 25 # smtp=25, INPUT is open
</example>
より徹底的なリダイレクトルールセットが必要な場合は、
<package>ipmasq</package> パッケージをインストールし、
<file>/etc/ipmasq/rules/</file> ディレクトリに
<file><url id="&examples;" name="M30redirect.def"></file> を
追加することを考えてください。

<sect1>複数のネット接続を管理する
<p>
[FIXME] Policy routing (by Phil Brutsche
<email>pbrutsch@tux.creighton.edu</email>):
詳細は <url id="&iproute;" name="iproute manual"> をごらんください。
トラフィックコントロール (tc) にも興味が湧くかもしれません。
<p>
次のような環境を考えます。
<example>
eth0: 192.168.1.2/24; gateway 192.168.1.1
eth1: 10.0.0.2/24; gateway 10.0.0.1
このマシン上でマスカレードは行いません。
</example>
特別な魔法を施します。
<enumlist compact>
<item>ip rule add from 192.168.1.2 lookup 1
<item>ip rule add from 10.0.0.2 lookup 2
<item>ip route add to default via 10.0.0.1 metric 0
<item>ip route add to default via 192.168.1.1 metric 1
<item>ip route add table 1 to 192.168.1.0/24 via eth0
<item>ip route add table 1 to 10.0.0.2/24 via eth1
<item>ip route add table 1 to default via 192.168.1.1
<item>ip route add table 2 to 192.168.1.0/24 via eth0
<item>ip route add table 2 to 10.0.0.2/24 via eth1
<item>ip route add table 2 to default via 10.0.0.2
</enumlist>
<p>
[FIXME] これを試したことはありません。オートダイアル機能を使わないで
高速な接続のバックアップとしてダイアルアップをどうやって設定しますか?
パッチを送ってください。:)
</sect>


</chapt>
