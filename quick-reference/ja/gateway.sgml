<!-- CVS revision of this document "$Revision: 1.4 $"  -->
<!-- CVS revision of original english document "1.215"  -->

<chapt id="gateway">ネットワークの設定
<p>
<!-- I keep above id as gateway to have the same html file name. -->
<!-- Once all translations are in sync, I may change it to network. -->
この章では &debian; でのネットワーク管理に焦点を当てています。
GNU/Linux のネットワークに関する一般的な紹介は
<url id="&net-howto;" name="Net-HOWTO"> をご覧下さい。
<p>
&debian; ホストのインターネットへのアクセスを可能にするには、
ネットワークインターフェースが kernel によりサポートされ、適切に
設定される必要があります。
<p>
まず必要なことは、イーサネットカード、無線 LAN カードやモデムのような
ネットワークインターフェースデバイスを kernel がサポートすることです。
これらのサポートを有効にするには、 <ref id="kernel"> に記述しているように
kernel を再構築してモジュールを追加する必要があるかもしれません。
<p>
ネットワークデバイスの設定は以降で説明します。
本章の情報は Sarge のために更新中ですので、Woody 
以前には適用できません。
<!--
I move these to comment, Thomas, please remove once you are ready
<p>
<list compact>
<item>XXX FIXME XXX: Update HW config, Ethernet kernel module
<item>XXX FIXME XXX: Add section to reconfigure network on initial install.
</list>
-->

<sect id="net-basic">IP ネットワークの基礎
<p>
&debian; ホストはそれぞれが異なった Internet Protocol (IP) アドレスを持った
複数のインターフェースを持つことができます。
インターフェースは次に挙げるいくつかの異なるタイプかもしれません。
<list compact>
<item>ループバック:  <tt>lo</tt>
<item>イーサネット:  <tt>eth0</tt>, <tt>eth1</tt>, ...
<item>無線LAN:  <tt>wlan0</tt>, <tt>wlan1</tt>, ...
<footnote>
無線 LAN インターフェースは本当は 無線 LAN 独特の設定パラメータへの
アクセスを与えるイーサネットインターフェースのエイリアスです。
これらのパラメータは <prgn>iwconfig</prgn> プログラムを用いて
制御可能です。
</footnote>
<item>トークンリング:  <tt>tr0</tt>, <tt>tr1</tt>, ...
<item>PPP:  <tt>ppp0</tt>, <tt>ppp1</tt>, ...
</list>
SLIP, PLIP (srrial line IP と pararell line IP), 特定のデバイスで
トラフィックを制御するための "shaper" なデバイス, フレームリレー,
Ax.25, X.25, ARCnet そして LocalTakl のような他のさまざまな種類の
ネットワークデバイスが使用可能です。
<p>
インターネット (又は IP ベースのネットワーク) に直接接続された全ての
ネットワークインターフェースはユニークな 32 ビットの IP アドレスにより
識別されます。
<footnote>
これは IPv4 が使用されている場合に正しい。IPv6 ではアドレスは 128 ビット。
<url id="&ipv6home;"> 参照。
</footnote>
IP アドレスネットワークを示す部分とホストを示す部分に分割できます。
IP アドレスのネットワークアドレスの部分を 1 に、ホストアドレスの
部分を 0 にするとネットワークのネットマスクを得られます。
<p>
伝統的に、IP ネットワークはそれぞれ 8 ビット、16 ビット、24 ビットの長さの
ワークアドレス部分を持つクラスに分類されています。
<footnote>
このシステムは融通が効かず、多くの IP アドレスを無駄にしてきました。
それゆえ、現在 IPv4 ネットワークはネットワークアドレス部分の長さを変えて
割り当てられています。
</footnote>
<example>
              IP アドレス                       ネットマスク     長さ
クラス A   1.0.0.0     - 126.255.255.255  255.0.0.0       =  /8
クラス B   128.0.0.0   - 191.255.255.255  255.255.0.0    = /16
クラス C   192.0.0.0   - 223.255.255.255  255.255.255.0 = /24
</example>
以上の長さを持たない IP アドレスは特別な目的に用いられます。
<p>
各クラスのためにローカルエリアネットワーク (LAN) で使用するために予約された
アドレスの範囲が存在します。
これらのアドレスはインターネット上のあらゆるアドレスと衝突しないことが
保証されています。
(同じトークンにより、これらのアドレスの 1つがホストに割り当てられた場合、
そのホストはインターネットに直接アクセスしてはいけませんが、
個別のサービスのためのプロキシとして機能するゲートウェイを通して
アクセスするか、ネットワークアドレス変換を通じてアクセスする
必要があります。)
これらのアドレスの範囲はそれぞれのクラスにあるアドレスの数に応じて、
次のテーブルに示すように与えられています。
<example>
              ネットワークアドレス           長さ    数
クラス A   10.x.x.x                             /8      1
クラス B   172.16.x.x -  172.31.x.x        /16     16
クラス C   192.168.0.x - 192.168.255.x  /24     256
</example>
IP ネットワークの最初のアドレスはネットワーク自身のアドレスです。
最後のアドレスはネットワークのブロードキャストアドレスです。
<footnote>
ネットワークのアドレスはネットワークアドレスとネットワークのネットマスクの和を
取ることにより得られます。ブロードキャストアドレスはネットワークアドレスと
ネットマスクの一の補数の積を取ることにより得られます。
</footnote>
他の全てのアドレスはネットワーク上のホストに割り当てられます。
これらのうち、最初又は最後のアドレスは通常ネットワークの
インターネットゲートウェイに割り当てられます。
<p>
ルーティングテーブルは kernel の目的地への IP パケットの送信方法
についての情報を含んでいます。
ここに IP アドレス 192.168.50.x/24 を持つローカルエリアネットワーク (LAN)
上の &debian; ホストのためのサンプルのルーティングテーブルを示します。
ホスト 192.168.50.x (LAN 上にもある) は企業ネットワーク 172.20.x.x/16
のためのルータであり、192.168.50.254 (LAN 上にもある) はインターネット
用のルータです。
<!-- I shrunk shell output within 72 characters                       -->
<example>
# route
Kernel IP routing table
Destination   Gateway        Genmask       Flags Metric Ref Use Iface
127.0.0.0     *              255.0.0.0     U     0      0     2 lo
192.168.50.0  *              255.255.255.0 U     0      0   137 eth0
172.20.0.0    192.168.50.1   255.255.0.0   UG    1      0     7 eth0
default       192.168.50.254 0.0.0.0       UG    1      0    36 eth0
</example>
<list compact>
<item>
ヘッダの後の最初の行は <tt>127.x.x.x</tt> 向けのトラフィックは
<tt>lo</tt> すなわちループバックインターフェースを通ることを示しています。
<item>
2行目は LAN 上のホスト向けのトラフィックは <tt>eth0</tt> を通ることを
示しています。
<item>
3行目は企業ネットワーク向けのトラフィックは <tt>eth0</tt> を通って
ゲートウェイ <tt>192.168.50.1</tt>に向けられることを示しています。
<item>
4行目はインターネット向けのトラフィックは<tt>eth0</tt> を通ってゲートウェイ
 <tt>192.168.50.254</tt> に向けられることを示しています。
</list>
テーブル上の IP アドレスは <file>/etc/networks</file> を調べるか
C ライブラリのリゾルバを用いて得られる名前としても表せます。
<p>
ルーティングに加え、kernel はネットワークアドレス変換、トラフィック整理
やフィルタリングも行えます。
<p>
より詳しい背景情報については <url id="&net-howto;" name="Net-HOWTO"> と
<url id="&net-howto-over;" name="other networking HOWTOs"> をご覧下さい。


<sect id="net-low">低レベルネットワークの設定
<p>
GNU/Linux システム上での伝統的な低レベルネットワーク設定ツールとしては
<package>net-tools</package> パッケージに収録されている
<prgn>ifconfig</prgn> や <prgn>route</prgn> プログラムがあります。
これらのツールは公式に <package>iproute</package> パッケージに収録
されている <prgn>ip</prgn> により取って代われています。
<prgn>ip</prgn> プログラムは Linux 2.2 以上で動き、旧式のツールよりも
より機能的です。しかしながら、旧式のツールもまだ動き、多くのユーザにより
親しまれています。

<sect1 id="low-ifconfig">低レベルネットワーク設定ツール &ndash; 
<prgn>ifconfig</prgn> と <prgn>route</prgn>
<p>
ここにインターフェース <tt>eth0</tt> の IP アドレスを <tt>192.168.0.3</tt>
から <tt>192.168.0.111</tt> に変更し、<tt>192.168.0.1</tt> 経由で 
<tt>10.0.0.0</tt> ネットワークに通すように <tt>eth0</tt> を設定
する方法を示します。
現在の全てのネットワークインターフェースとルーティングの状況を表示するため、
まずはインターフェース引数無しで <prgn>ifconfig</prgn> と <prgn>route</prgn>
を起動することから始めましょう。
<example>
# ifconfig
eth0 Link encap:Ethernet  HWaddr 08:00:46:7A:02:B0
     inet addr:192.168.0.3  Bcast:192.168.0.255  Mask:255.255.255.0
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     RX packets:23363 errors:0 dropped:0 overruns:0 frame:0
     TX packets:21798 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:100
     RX bytes:13479541 (12.8 MiB)  TX bytes:20262643 (19.3 MiB)
     Interrupt:9

lo   Link encap:Local Loopback
     inet addr:127.0.0.1  Mask:255.0.0.0
     UP LOOPBACK RUNNING  MTU:16436  Metric:1
     RX packets:230172 errors:0 dropped:0 overruns:0 frame:0
     TX packets:230172 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:0
     RX bytes:22685256 (21.6 MiB)  TX bytes:22685256 (21.6 MiB)
# route
Kernel IP routing table
Destination  Gateway      Genmask          Flags Metric Ref Use Iface
192.168.0.0  *            255.255.0.0      U     0      0     0 eth0
default      192.168.0.1  255.255.255.255  UG    0      0     0 eth0
</example>
まずインターフェースをダウンさせます。
<example>
# ifconfig eth0 inet down
# ifconfig
lo   Link encap:Local Loopback
  ... (eth0 エントリはもはや存在しない)
# route
  ... (ルーティングテーブルのエントリももはや存在しない)
</example>
次に eth0 を新しい IP アドレスと新しいルーティングを用いて立ち上げます。
<example>
# ifconfig eth0 inet up 192.168.0.111 \
           netmask 255.255.0.0 broadcast 192.168.255.255
# route add -net 10.0.0.0 netmask 255.0.0.0 gw 192.168.0.1 dev eth0
</example>
The result:
<example>
# ifconfig
eth0 Link encap:Ethernet  HWaddr 08:00:46:7A:02:B0
     inet addr:192.168.0.111  Bcast:192.168.255.255  Mask:255.255.0.0
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     ...

lo   Link encap:Local Loopback
     inet addr:127.0.0.1  Mask:255.0.0.0
     ...
# route
Kernel IP routing table
Destination  Gateway      Genmask      Flags Metric Ref Use Iface
192.168.0.0  *            255.255.0.0  U     0      0     0 eth0
10.0.0.0     192.168.0.1  255.0.0.0    UG    0      0     0 eth0
</example>
<p>
より詳しい情報は、<manref name="ifconfig" section="8"> と
<manref name="route" section="8"> をご覧下さい。

<sect1 id="low-ip">低レベルネットワーク設定ツール &ndash; <prgn>ip</prgn>
<p>
前記の <prgn>ifconfig</prgn> や <prgn>route</prgn> コマンドと等価な
<prgn>ip</prgn> コマンドは次のようになります。
<list compact>
<item><tt>ip link show</tt>
<item><tt>ip route list</tt>
<item><tt>ip link set eth0 down</tt>
<item><tt>ip addr del dev eth0 local 192.168.0.3</tt>
<item><tt>ip addr add dev eth0 local 192.168.0.111/16 broadcast 192.168.255.255</tt>
<item><tt>ip link set eth0 up</tt>
<item><tt>ip route add dev eth0 to 10.0.0.0/8 src 192.168.0.111 via 192.168.0.1</tt>
</list>
<p>
<prgn>ip</prgn> プログラムは引数 <tt>help</tt> 付きで起動するとその
コマンド文法を表示します。例えば、<tt>ip link help</tt> は次を表示します。
<example>
Usage: ip link set DEVICE { up | down | arp { on | off } |
                     dynamic { on | off } |
                     multicast { on | off } | txqueuelen PACKETS |
                     name NEWNAME |
                     address LLADDR | broadcast LLADDR |
                     mtu MTU }
       ip link show [ DEVICE ]
</example>
<manref name="ip" section="8"> をご覧下さい。

<sect1 id="low-wifi">無線 LAN インターフェースの設定
<p>
無線 LAN インターフェースの設定には、<package>wireless-tools</package> 
パッケージに収録されている <prgn>iwconfig</prgn> プログラムが
<prgn>ifconfig</prgn> と <prgn>ip</prgn> の両方に加えて使われます。
<p>
<manref name="iwconfig" section="8"> をご覧下さい。

<sect1 id="low-ppp">PPP インターフェースの設定
<p>
インターネットにダイアルアップ電話線を接続したモデム経由でアクセス
する場合、Point-to-Point Protocol (PPP) を用いて接続をネゴシエイト
します。そのような接続はネットワークインターフェース <tt>ppp0</tt>,
<tt>ppp1</tt>, などとしてアクセスされます。
<p>
PPP インターフェースは <package>ppp</package> パッケージに収録されている
PPP デーモン <prgn>pppd</prgn> により管理されます。
それゆえ、ユーザにとっては、PPP インターフェースを設定するのは
<prgn>pppd</prgn> を設定することを意味します。

<sect2 id="ppp-pppd"><prgn>pppd</prgn> を手動で設定する
<p>
ネットワークリンクを確立するには、通信ポート (通常シリアルポート)
を開き、コマンドを通信デバイス (通常モデム) に送信し、
電話番号をダイアルし、外の PPP デーモンへの認証を行い、
PPP インターフェースが作成されてルーティングテーブルが
トラフィックがリンクを通じて送られるように修正される必要があります。
<prgn>pppd</prgn> はこれらの仕事の全てをこなし、その結果として
非常に長い操作オプションのリストを持ちます。
これらのオプションは <manref name="pppd" section="8"> に記述されています。
<p>
&debian; システムでは、汎用のオプションは <file>/etc/ppp/options</file>
にセットされています。ユーザが指定するオプションは <file>~/.ppprc</file>
にセットします。使用する通信ポートに依存するオプションは
<file>/etc/ppp/options.<var>portname</var></file> に保存されます。
例えば、二つのモデム &mdash; 組込みの /dev/LT-modem を通じてアクセス
される Lucent LT モデムと外付けの /dev/ttyS0 を通じてアクセスされる
モデムを持っていると仮定します。
次の 2つのオプションファイルを作成します。
<example>
# cat &gt; /etc/ppp/options.LT-modem &lt;&lt;EOF
115200
init "/usr/sbin/chat -f /etc/chatscripts/setup-LT-modem"
EOF
# cat &gt; /etc/ppp/options.ttyS0 &lt;&lt;EOF
115200
init "/usr/sbin/chat -f /etc/chatscripts/setup-ttyS0"
EOF
</example>
これらは次のチャットスクリプトを参照しています。まず、
<file>/etc/chatscripts/setup-LT-modem</file> です。
<example>
ABORT ERROR
'' ATZ
OK 'ATW2X2 S7=70 S11=55'
OK AT
</example>
次に、<file>/etc/chatscripts/setup-ttyS0</file> です。
<example>
ABORT ERROR
'' ATZ
OK 'ATL1M1Q0V1W2X4&amp;C1&amp;D2 S6=4 S7=70 S11=55 S95=63 S109=1 +FCLASS=0'
OK AT
</example>
これらのファイルの内容はもちろんハードウェアに依存している必要があります。
<p>
オプションは <prgn>pppd</prgn> に引数としても与えられます。
<p>
&debian; では、<prgn>pppd</prgn> は普通 <prgn>pon</prgn> コマンドを
用いて起動されます。<prgn>pon</prgn> が起動されると、その第一引数は
<prgn>pppd</prgn> によっても読まれる <file>/etc/ppp/peers/</file> に
あるオプションファイルと同じ名前です。
<footnote>
このオプションファイルは <tt>call</tt> オプションを用いて含まれます。
</footnote>
こうして特定の peer&mdash;例えば、特定のインターネットサービスプロバイダ
(ISP) を指定するオプションを設定できます。
<p>
例えば、アムステルダムとハーグの間を通信したいとします。
それぞれの町には 2つの ISP サービス&mdash;Planet と KPN を持っています。
まず各 ISP 用の基本的なオプションファイルを作ります。
<example>
# cat &gt; /etc/ppp/peers/KPN &lt;&lt;EOF
remotename KPN
noauth
user kpn
noipdefault
ipparam KPN
EOF
# cat &gt; /etc/ppp/peers/Planet &lt;&lt;EOF
remotename Planet
auth
user user3579@planet.nl
noipdefault 
mru 1000
mtu 1000
ipparam Planet
EOF
</example>
これらのファイルは 2つの ISP 間で異なるオプションを設定します。
両方の ISP に共通のオプションは <file>/etc/ppp/options</file>
又は適切なインターフェース独自のオプションファイルのどちらかに
置きます。
<p>
次にそれぞれの町のための各 ISP 用のオプションファイルを作成します。
この例では片方の場所の ISP へ接続するのと他の場所の ISP に
接続する時の違いのみを必要なチャットスクリプトにします。
(ローカルのアクセス電話番号が異なるので、チャットスクリプトは異なります。)
<example>
# cat &gt; /etc/ppp/peers/KPN-Amsterdam &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/KPN-Amsterdam"
file /etc/ppp/peers/KPN
EOF
# cat &gt; /etc/ppp/peers/KPN-DenHaag &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/KPN-DenHaag"
file /etc/ppp/peers/KPN
EOF
# cat &gt; /etc/ppp/peers/Planet-Amsterdam &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/Planet-Amsterdam"
file /etc/ppp/peers/Planet
EOF
# cat &gt; /etc/ppp/peers/Planet-DenHaag &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/Planet-DenHaag"
file /etc/ppp/peers/Planet
EOF
</example>
それぞれの <tt>file</tt> 指示は早く示されるオプションファイルの一つ
の一つを含みます。
<tt>connect</tt> 指示は接続を確立するために <prgn>pppd</prgn> が使う
コマンドを指示します。
通常この目的には <prgn>chat</prgn> プログラムを使い、
チャットスクリプトを ISP に適応させます。
アムステルダムは電話番号を除いて同じかもしれませんし、ISP が
他の会社を通じてサービスを提供しているならば、異なるかもしれません。
<example>
# cat &gt; /etc/chatscripts/KPN-DenHaag &lt;&lt;EOF
ABORT BUSY
ABORT 'NO CARRIER'
ABORT VOICE
ABORT 'NO DIALTONE'
ABORT 'NO DIAL TONE'
ABORT 'NO ANSWER'
ABORT ERROR
OK-AT-OK ATDT <var>0676012321</var>
CONNECT \d\c
EOF
# cat &gt; /etc/chatscripts/Planet-DenHaag &lt;&lt;EOF
ABORT BUSY
ABORT 'NO CARRIER'
ABORT VOICE
ABORT 'NO DIALTONE'
ABORT 'NO DIAL TONE'
ABORT 'NO ANSWER'
ABORT ERROR
OK-AT-OK ATDT <var>0676002505</var>
CONNECT \d\c
EOF
</example>
これらの ISP と接続を確立できるようにするには、<prgn>pppd</prgn>
が peer に要求に応じて供給するクライアント名とパスワードが必要です。
これらの情報は <file>/etc/ppp/pap-secrets</file> (PAP プロトコル使用時) 又は
<file>/etc/ppp/chap-secrets</file> (CHAP プロトコル使用時) に保存されます。
CHAP はより安全ですが、PAP は依然広く使われています。
これらのファイルには秘密が含まれているので、グループと他人が読み書きできない
ファイルアクセス権限を設定しなくてはなりません。
これらのファイルのフォーマットは <manref name="pppd" section="8"> で
説明されています。
"secret" (3番目のフィールド) はファイル中のクライアント名 (最初のフィールド)
および/又は サーバ名 (2番目のフィールド) を検索することにより調べられます。
ISP に接続している場合、一般にサーバ名は知りませんので、クライアント名を
代わりに供給します。これは上に示した <file>peers/KPN</file> と 
<file>peers/Planet</file>にある <tt>user</tt> 行で行われます。
<example>
# client name       server name  secret
kpn                 *            kpn
user3579@planet.nl  *            myfavoritepet
</example>

<sect2 id="ppp-pppconfig"><package>pppconfig</package> を用いて 
<prgn>pppd</prgn> を設定する
<p>
<prgn>pppd</prgn> を設定する手軽な方法は同名のパッケージにより
供給される <prgn>pppconfig</prgn> を使うことです。
<prgn>pppconfig</prgn> はメニュインターフェースを通じてユーザが質問
に答えた後に上に示したようなファイルを設定します。
<p>
<package>resolvconf</package> を使っている場合、
"Configure Nameservers" スクリーンで "None" を選ぶことを忘れずに。

<sect2 id="ppp-wvdial"><package>wvdial</package> を用いて PPP 
インターフェースを設定する
<p>
<prgn>pppd</prgn> を用いる異なるアプローチとしては、
<package>wvdial</package> パッケージに収録されている <prgn>wvdial</prgn>
から <prgn>pppd</prgn> を起動することです。
<prgn>pppd</prgn> の代わりに、<prgn>chat</prgn> を起動してダイアルし、
接続のネゴシエイトを行います。<prgn>wvdial</prgn> はダイアルと最初のネゴ
シエイトを行い、そして残りの作業を行うために <prgn>pppd</prgn>を起動します。
電話番号、ユーザ名、そしてパスワードを与えるだけで <prgn>wvdial</prgn> は
ほとんどの場合接続を確立できます。

<sect id="net-name">コンピュータの名前付け
<p>

<sect1 id="name-host">hostname
<p>
&debian; システムは時々自分自身を名前で識別する必要があります。
この目的のため、<strong>hostname</strong> が kernel により維持されています。
<p>
initscript <file>/etc/init.d/hostname.sh</file> は hostname を
ブート時に (<prgn>hostname</prgn> を用いて) <file>/etc/hostname</file>
に保存されている名前に設定します。
このファイルには完全修飾ドメイン名 (FQDN) ではなく、
hostname <strong>のみ</strong> が含まれていなくてはなりません。
<p>
現在の hostname を表示するには、引数無しで <prgn>hostname</prgn>
を起動してください。

<sect1 id="name-mail">Mailname
<p>
ホストの <strong>mailname</strong> はホストを識別するためにメール関連の
プログラムが使用する名前です。
<file>/etc/mailname</file> ファイルには名前に続いて改行を持つ行が
含まれます。
mailname は通常ホストの完全修飾ドメイン名の一つです。
<manref name="mailname" section="5"> をご覧下さい。
<p>
&debian; ホストにより送信されるメールの <tt>From:</tt> ヘッダにある
受取人が何かは Mail User Agent (MUA) や Mail Transfer Agent (MTA)
がどのように設定されているかに依存します。
ローカルユーザ <tt><var>foo</var></tt> がメールを mailname 
<tt><var>myhost.dom</var></tt> から送ると仮定します。
すると、送信されるメールの <tt>From:</tt> ヘッダは次のようになります。
<list compact>
<item>MUA が <tt>From:</tt> ヘッダセットを持たない場合
"<tt>From: <var>foo</var>@<var>myhost.dom</var></tt>"
<item>MUA が "<tt>From: <var>bar</var></tt>" セットを持つ場合
"<tt>From: <var>bar</var>@<var>myhost.dom</var></tt>"
<item>MUA が "<tt>From: <var>bar</var>@<var>bogus.dom</var></tt>" セットを持つ場合
"<tt>From: <var>bar</var>@<var>bogus.dom</var></tt>"
</list>
MUA が <tt>From:</tt> ヘッダをセットしたとしても、MTA が
"<tt>Sender:<var>foo</var>@<var>herman.dom</var></tt>" ヘッダを
本当の発信源を示すために追加するかもしれません。
<p>
もちろん <ref id="addr-catchall"> や <ref id="addr-rewrite"> で議論
したように、関連する MTA がアドレスの書き換えを行った時、受取人が見る
メールアドレスはどうにでも変えられ得ます。

<sect id="net-dns">ドメインネームサービス (DNS)
<p>
ホストは IP アドレスに加え、ドメイン名によっても参照されます。
DNS はネームリゾルバがドメイン名を IP アドレスや他のホストの属性と
関連付けるためにネームサーバを勤めるクライアントサーバシステムです。
GNU C ライブラリ <manref name="resolver" section="3"> もファイルにある
IP アドレスの検索を行えますし、Network Information Services (NIS) 
の役目も勤めます。
<p>
ローカルのホストに関連づけられているドメインが何かを知るには、
<tt>hostname --fqdn</tt> コマンドを使いましょう。このコマンドはリゾルバが
ローカルの hostname に対して捜し出した最初の FQDN を表示します。
<footnote>
技術的には、これは <manref name="gethostname" section="2"> により
返された hostname に対する <manref name="gethostbyname" section="2">
により返された FQDN です。
</footnote>
<p>

<sect1 id="dns-resolver">リゾルバ
<p>
特定のドメイン名に関連づけられた IP アドレスを捜し出す仕事は、リゾルバ
の仕事です。最も良く使われているリゾルバは GNU C ライブラリにある
リゾルバ (<manref name="resolver" section="3">) により実現される
関数群です。他のリゾルバとしては、<package>libfiredns</package>  
パッケージに収録されている FireDNS リゾルバがあります。
<p>
どのように LIBC リゾルバが名前を解決するかは <file>/etc/nsswitch.conf</file>
設定ファイル中の <tt>hosts</tt> 行により制御されています。
この行は名前を解決するために使われるサービス、例えば <tt>dns</tt>, 
<tt>files</tt>, <tt>nis</tt>, <tt>nisplus</tt> をリストしています。
<footnote>
リゾルバが名前を解決する方法は <file>/etc/host.conf</file> 設定ファイル
により制御されるとも主張されます。この設定ファイル中の<tt>order</tt> 行は
名前を解決するのに使われる方法、すなわち <tt>bind</tt>, <tt>hosts</tt>,
<tt>nis</tt> をリストしています。
<manref name="host.conf" section="5"> をご覧下さい。
私はこの行は <file>nsswitch.conf</file> の <tt>hosts</tt> 行により
置き換えられていると信じていますが、確信できていません。
</footnote>
<manref name="nsswitch.conf" section="5"> をご覧下さい。
<tt>files</tt> サービスが使用されている範囲については、リゾルバの挙動は
<file>/etc/hosts</file> 設定ファイルによっても制御されています。
<manref name="hosts" section="5"> をご覧下さい。
<p>
上の全てのファイルは静的であり、お好みのエディタで編集できます。
<p>
<tt>dns</tt> サービスが使用される範囲においては、リゾルバの挙動は
<file>/etc/resolv.conf</file> 設定ファイルによっても制御されています。
<manref name="resolv.conf" section="5"> をご覧下さい。
<file>resolv.conf</file> の重要な機能のひとつは、名前を解決するために
接続されるネームサーバの IP アドレスをリストすることです。
このリストはたびたびネットワーク環境に依存し、ネットワーク環境はコンピュータ
を起動する間時にふれて変化します。
<prgn>pppd</prgn> や <prgn>dhclient</prgn> のようなプログラムは
<file>resolv.conf</file> 内の行を追加したり削除する操作を行えますが、
これらの機能は常に適切に動くとは限らず、お互いに衝突しかねません。
<package>resolvconf</package> パッケージはこのファイルを更新するための
標準的なフレームワークを供給することにより、よりうまくこの問題を解決します。
<ref id="dns-resolvconf"> をご覧下さい。
<p>

<sect1 id="dns-resolvconf">ネームサーバ情報の管理 &ndash; <package>resolvconf</package>
<p>
<package>resolvconf</package> パッケージは利用可能なネームサーバ
に関する情報の動的な管理のためのフレームワークを供給します。
リゾルバや DNS キャッシュが使うためのネームサーバのリストを動的に管理
する方法についての長年の問題を解決します。
resolvconf は自身をネットワークインターフェースを制御するプログラムと
ネームサーバ情報を供給するプログラム、そしてネームサーバ情報を必要とする
アプリケーションの間の仲介人として設定します。
<p>
<package>resolvconf</package> は手動の設定を必要とせずに動作するように
設計されています。しかしながら、パッケージはまだ非常に新しく、
適切に動作させるためには、まだ手動の介入をいくらか必要とするかもしれません。
あなたが <file>/etc/resolv.conf</file> を更新するようにパッケージを
カスタマイズしたならば、これは確実に当てはまります。ですので、
カスタマイズを無効にする必要があります。
<p>
詳細は <url id="&f-resolvconf;"> をご覧下さい。

<sect1 id="dns-dnsmasq">検索した名前をキャッシュする &ndash; <package>dnsmasq</package>
<p>
ネームサーバがドメインを信頼できなければ、キャッシングとフォワーデイング
を行う <package>dnsmasq</package> のようなネームサーバを起動させるのが
賢明です。
<package>resolvconf</package> と同時に用いてもうまく動きます。

<sect1 id="dns-bind-server">ドメインネームサービスを供給する &ndash; <package>bind</package>
<p>
あるドメインのための信頼できるネームサービスを供給する必要がある場合、
<package>bind9</package> 又は <package>bind</package> パッケージのどちらか
による <prgn>named</prgn> のような完全に一人前のネームサーバが必要です。
新たにインストールする場合、<package>bind9</package> がお薦めです。
<p>
<package>bind9</package> をインストールするには、<package>bind9</package>, 
<package>dnsutils</package> のような基本的なパッケージをインストール
しましょう。
次に、<package>bind9-host</package>, <package>dns-browse</package>, 
<package>dnscvsutil</package>,  <package>nslint</package> のような
ユーティリティパッケージもインストールしたいかもしれません。
さらに、<package>bind9-doc</package> のようなドキュメントパッケージも
インストールしたいかもしれません。そして、<package>libbind-dev</package> や
<package>libnet-dns-perl</package> のような開発用パッケージもインストール
したいかもしれません。
DHCP を用いたインターフェースを設定する場合、<package>dhcp-dns</package>
パッケージを見つけるかもしれません。
<p>
基本的な設定を行うには、<package>bind9</package> をインストールするか、
<prgn>dpkg-reconfigure</prgn> を実行しましょう。設定は
<file>named.conf</file> を編集することからなります。
&debian; では、このファイルは <file>/etc/bind/</file> にあり、
主に基本的な DNS ゾーンの定義のために用いられます。
このファイルには <file>named.conf.local</file> というローカルゾーンを定義する
ファイルと、<file>named.conf.options</file> という設定オプションのために
用いられるファイルという二つの別ファイルが <tt>含まれます</tt>。
(後者は <file>/var/run/bind/named.options</file> ファイルを生成するために
<package>resolvconf</package> によって処理されます。この生成ファイルは
<tt>forwarders</tt> 指定が現在利用できるローカルではないネームサーバの
リストであるという点を除いてオリジナルと同じです。
これを利用するには、<file>named.conf</file> の <tt>include</tt> 行が
<file>/var/run/bind/named.options</file> を含むように変更してください。
<ref id="dns-resolvconf"> をご覧下さい。)
<p>
完全なパス名無しで <file>named.conf*</file> という名前のデータベースファイル
が <file>/var/cache/bind/</file> に保存されます。
これは <prgn>named</prgn> により生成されるファイルを保存する正しい場所です。
例えば、デーモンが働いているセカンダリゾーン用のデータベースファイルです。
<file>/etc/bind/</file> にある静的なデータベースファイルは、
フルパス名により  <file>named.conf</file> にあるものと参照
されなくてはなりません。詳細は <url id="&f-bind9;"> をご覧下さい。

<sect id="net-dhcp">DHCP を用いてネットワークインターフェースを設定する
<p>
低レベルのネットワークインターフェースの設定は 
Dynamic Host Configuration Protocol (DHCP) を用いて自動化できます。
ファイアーウォールやルータボックス、そしてあなたが使っているブロードバンド 
ISP は IP アドレスや他のパラメータをこの方法で提供しているかもしれません。
<p>
DHCP を動かすには、次のパッケージのうち一つをインストールする必要があります。
<list compact>
<item><package>dhcp3-client</package> (version 3, Internet Software Consortium による)
<item><package>dhcpcd</package> (Yoichi Hariguchi と Sergei Viznyuk による)
<item><package>pump</package> (Red Hat による)
</list>

<package>pump</package> はシンプルで広く使われています。
<package>dhcp3-client</package> は複雑ですがより広範な設定が可能です。
<footnote>
2003年10月時点では、<package>dhcp-client</package> パッケージも利用可能です。
これには <package>dhcp3-client</package> に収録されている version 3 により
置き換えられている ISC DHCP クライアントの version2 が含まれています。
メンテナは <package>dhcp3-client</package> を <package>dhcp-client</package>
に改名しようと計画していますが、Sarge のリリースまでには間に合いそうも
ありません。)
</footnote>

<sect id="net-high">&debian; での高レベルなネットワーク設定
<p>
ネットワーク設定をより容易にするため、&debian; は <prgn>ifup</prgn> と
<prgn>ifdown</prgn> プログラムと <file>/etc/network/interfaces</file> ファイル
から構成される標準の高レベルネットワーク設定ツールを供給します。
<footnote>
最新のバージョンの <file>/etc/network/interfaces</file> の
ファイルフォーマットは Potato 以前のフォーマットと少し互換性がありません。
<package>ifupdown</package> のインストール後スクリプトが必要な場合に
自動的にこのファイルを更新します。
<!--
しかしながら、Potato から更新する場合、<manref name="interfaces" section="5">
を読み、ファイルが適切に変換されたかどうか確認するために
<file>/etc/network/interfaces</file> を調べるべきです。

最初の注意は Woody から Potato にダウングレードすることに関する問題
でしたが、Woody は既に安定しており、Potato 用の安定版サポートはもはや
存在しないので、必要ありません。
-->
</footnote>
ネットワークの設定に <package>ifupdown</package> を使おうとした場合、
通常低レベルのコマンドを同時に使うべき <strong>ではありません</strong>。
<footnote>
これは、低レベルな設定ツールを呼び出す <package>whereami</package>
のような他の高レベルな設定ツールを使うべきではないということも意味しています。
</footnote>
<package>Ifupdown</package>  はネットワークインターフェースの設定と
解除のために使われるのは自分自身だけという仮定の元に書かれています。
<p>
インターフェースの設定を更新するには、次のようにします。
<example>
# ifdown eth0
# editor /etc/network/interfaces  # お好きなようにいじる
# ifup eth0
</example>
<p>
より詳しい情報は <manref name="interfaces" section="5">,
<url id="&f-ifupdown;">, と <manref name="ifup" section="8"> をご覧下さい。

<sect1 id="high-static">スタティック IP アドレスを用いたインターフェースの設定
<p>
<tt>192.168.0.123</tt> の固定 IP アドレスを持った Ethernet インタフェース
の設定を行いたいと仮定します。このアドレスは <tt>192.168.0</tt> から始まるので、LAN 上にある必要があります。さらに、LAN のインターネットへのゲートウェイの
アドレスを <tt>192.168.0.1</tt> と仮定します。
次のような一区切りを含むように <file>/etc/network/interfaces</file>
を編集しましょう。
<example>
iface eth0 inet static
        address 192.168.0.123
        netmask 255.255.255.0
        gateway 192.168.0.1
</example>
<package>resolvconf</package> をインストールしている場合、次のように DNS 
情報を指定する行を追加できます。
<example>
iface eth0 inet static
        address 192.168.0.123
        netmask 255.255.255.0
        gateway 192.168.0.1
        dns-search nicedomain.org
        dns-nameservers 195.238.2.21 195.238.2.22
</example>
インターフェースが立ち上がった後、<tt>dns-search</tt> オプションと 
<tt>dns-nameservers</tt> オプションの引数は <package>resolvconf</package>
が <file>resolv.conf</file> に含めることにより利用可能になります。
<tt>dns-search</tt> オプションの <tt>nicedomain.org</tt> 引数は
<manref name="resolv.conf" section="5"> にある <tt>search</tt> 
オプションの引数に対応します。
<tt>dns-nameservers</tt> オプションの <tt>195.238.2.21</tt> と
<tt>195.238.2.22</tt> オプションは <manref name="resolv.conf" section="5">
にある <tt>nameserver</tt> オプションの引数に対応します。
他の利用可能なオプションとしては、<tt>dns-domain</tt> と
<tt>dns-sortlist</tt> があります。
<ref id="dns-resolvconf"> をご覧下さい。

<sect1 id="high-dhcp">DHCP を用いてインターフェースを設定する
<p>
DHCP を用いてインターフェースを設定するには、
次のような一区切りを含めるように <file>/etc/network/interfaces</file> 
を編集してください。
<example>
iface eth0 inet dhcp
</example>
これを機能させるには、 <ref id="net-dhcp"> で言及した DHCP クライアント
のうちいずれかをインストールする必要があります。

<sect1 id="high-wifi">無線 LAN インターフェースの設定を行う
<p>
<package>wireless-tools</package> パッケージには、インターフェースを
立ち上げる前に無線 LAN (802.11a/b/g) ハードウェアの設定を可能とする
フックスクリプト <file>/etc/network/if-pre-up.d/wireless-tools</file>
が含まれます。
設定は <prgn>iwconfig</prgn> プログラムを通じて行われます。
<manref name="iwconfig" section="8"> をご覧下さい。
<prgn>iwconfig</prgn> に与えることが可能なコマンドパラメータそれぞれ
に対して、"wireless-" 接頭辞を付けたパラメータのような名前で
<file>/etc/network/interfaces</file> 内ににオプションとして含めることが
できます。
例えば、DHCP を用いて <tt>eth0</tt> を立ち上げる前に
<tt>eth0</tt> の ESSID を <tt>myessid</tt> に、暗号鍵を <tt>123456789e</tt>
に設定するには、次のような一区切りを含むように
<file>/etc/network/interfaces</file> を編集しましょう。
<example>
iface eth0 inet dhcp
        wireless-essid myessid
        wireless-key 123456789e
</example>
このインターフェースに対して <prgn>waproamd</prgn> を走らせている場合、
ESSID と暗号鍵を設定するこの方法を用いるべきではありません。
<prgn>ifup</prgn> が起動された時、<prgn>waproamd</prgn> は既に
ESSID と暗号鍵を設定済みです。
<ref id="trigger-waproamd"> をご覧下さい。

<sect1 id="high-ppp">PPP インターフェースの設定を行う
<p>
<prgn>ifup</prgn> と
<prgn>ifdown</prgn> プログラムは
PPP インターフェースの追加と削除のために
<prgn>pon</prgn> と
<prgn>poff</prgn> を使います。ですから、まずは
<ref id="low-ppp"> を読みましょう。
<p>
peer <tt>myisp</tt> に対して動くように PPP を設定する必要があると仮定します。
次のような一区切りを含むように <file>/etc/network/interfaces</file> を
編集しましょう。
<example>
iface ppp0 inet ppp
        provider myisp
</example>
この一区切りが正しい位置にあれば、<prgn>ifup ppp0</prgn> は次を実行します。
<example>
pon myisp
</example>
不運なことに、<file>/etc/network/interfaces</file> にある <tt>ppp</tt>
節に <prgn>pppd</prgn> オプションをさらに供給することはいまのところ
できません。
<footnote>
bug <url id="&bug-iud-pon-args;" name="#196877"> 参照。
</footnote>
<p>
現在 PPP インターフェースの補助的な設定を行うために <package>ifupdown</package>
を使うことはできません。<prgn>pon</prgn> は <prgn>pppd</prgn> が接続を
確立する前に存在するため、<prgn>ifup</prgn> は インターフェースの
準備ができる前に <tt>up</tt> スクリプトを起動します。
このバグ
<footnote>
bug <url id="&bug-iud-ppp-wait;" name="#127786"> 参照
</footnote>
が修正されるまでは、<file>/etc/ppp/ip-up</file> 又は 
<file>/etc/ppp/ip-up.d/</file> にある補助的な設定を実行する必要性が
残ります。

<sect1 id="high-pppoe">PPPoE インターフェースの設定を行う
<p>
たとえ、カスタマのマシンが Ethernet や ATM ネットワーク経由でつないでいた
としても、多くのブロードバンドインターネットサービスプロバイダ (ISP) は 
PPP を接続のネゴシエイトを行うために使用します。
これは PPP over Ethernet (PPPoE) により実現されます。この技術は
PPP ストリームを Ethernet フレーム内にカプセル化する技術です。
ISP が <tt><var>myisp</var></tt> と呼ばれていると仮定します。
まず peer <tt><var>myisp</var></tt> のための PPP と PPPOE を設定します。
最も簡単な方法は <package>pppoeconf</package> パッケージをインストールし、
コンソールから <prgn>pppoeconf</prgn> を起動することです。
次に、次に挙げる一区切りを含むように <file>/etc/network/interfaces</file>
を編集します。
<example>
iface eth0 inet ppp
        provider <var>myisp</var>
</example>
<!--
もっと良いのは次の内容だが検証が必要
<example>
mapping eth0
        script /root/bin/echo-ppp0

iface ppp0 inet ppp
        provider <var>myisp</var>
</example>
ここで、
<example>
# cat &gt; /root/bin/echo-ppp0 &lt;&lt;EOF
# /bin/sh
echo ppp0
EOF
# chmod 755 /root/bin/echo-ppp0
</example>
という起動スクリプトを作成する。
-->
<p>
時々 PPPoE over DSL を用いた時の Maximum Transmit Unit (MTU) 
についての問題が発生します。
詳細は <url id="&dsl-howto;" name="DSL-HOWTO"> をご覧下さい。
<p>
ブロードバンドモデムがルータ機能を持っている場合、モデム/ルータは
それ自身で PPPoE 接続を操作し、LAN 側では単なる インターネットへの
Ethernet ゲートウェイにしか見えないことに注意してください。

<sect1 id="high-dual">ゲートウェイ用に複数の Ethernet インターフェースを設定する<p>
<file>eth0</file> が DHCP により設定した IP アドレスを用いてインターネット
に接続し、<file>eth1</file> が固定 IP アドレス <tt>192.168.1.1</tt>
を用いて LAN に接続していると仮定します。
次に示すような一区切りを含むように <file>/etc/network/interfaces</file>
を編集しましょう。
<example>
iface eth0 inet dhcp

iface eth1 inet static
        address 192.168.1.1
        netmask 255.255.255.0
</example>
<ref id="net-router"> に記述しているようにホストの NAT を有効にしている
場合、LAN 上の全てのホストでインターネット接続を共有できます。

<sect1 id="high-virtual">仮想インターフェースを設定する
<p>
仮想インターフェースを用いると、1つの Ethernet カードを複数の IP
サブネットへのインターフェースとして設定できます。
例えば、ホストが 192.168.0.x/24 の LAN ネットワーク上にあると仮定
します。ホストを既存の Ethernet カードを用いて DHCP を用いて供給される
パブリックな IP アドレスを用いてインターネットに接続したい場合、
次に示すような一区切りを含むように <file>/etc/network/interfaces</file> 
を編集しましょう。
<example>
iface eth0 inet static
        address 192.168.0.1
        netmask 255.255.255.0
        network 192.168.0.0
        broadcast 192.168.0.255

iface eth0:0 inet dhcp
</example>
インターフェース <tt>eth0:0</tt> は仮想インターフェースです。
これが立ち上がると、親の <tt>eth0</tt> も立ち上がります。

<sect id="net-reconf">ネットワーク <strong>再</strong>設定
<p>
次の章では、読者は <strong>物理インターフェース</strong> と
<strong>論理インターフェース</strong> の違いを理解することが重要に
なります。
<footnote>
この技術は <package>ifupdown</package> のドキュメントで使用されています。
</footnote>
物理インターフェースは私達が "インターフェース" と呼ぶ <tt>eth0</tt>,
<tt>ppp1</tt> などと名付けられるものです。
論理インターフェースは物理インターフェースの変数パラメータに割り当てられる
値のセットのことです。これに混乱する場合、
"論理インターフェース <tt>X</tt> として設定する"
という表現を
"インターフェースプロファイル <tt>X</tt> を用いて設定する"
に置き換えます。
<p>
<file>/etc/network/interfaces</file> にある <tt>iface</tt> 定義は
実際は物理インターフェースの定義ではなく、論理インターフェースの
定義です。
<footnote>
<tt>auto</tt> 行にあるインターフェース名は論理インターフェース
ではなく、物理インターフェースであることに注意してください。
</footnote>
インターフェースを絶対再設定したくない場合、物理インターフェース <tt>X</tt>
は標準では論理インターフェース <tt>X</tt> として設定されるので無視できます。
<p>
しかしながら、あなたのコンピュータが仕事場と家の間を持ち運ぶノート PC である
と仮定しましょう。コンピュータを職場のネットワークに接続した時と
家庭内 LAN に接続したときでは、接続する場所に従い <tt>eth0</tt> を再設定
する必要があります。
<p>
まず (以前行ったように <tt>eth0</tt> ではなく) 二つの論理インターフェース 
<tt>home</tt> と <tt>work</tt> を定義し、インターフェースが家庭内 LAN 
と職場ネットワークのためにに設定されるかをそれそれ記述します。
<example>
iface home inet static
        address 192.168.0.123
        netmask 255.255.255.0
        gateway 192.168.0.1

iface work inet static
        address 81.201.3.123
        netmask 255.255.0.0
        gateway 81.201.1.1
</example>
そして、物理インターフェース <tt>eth0</tt> をコマンドラインで、次のように
適切な設定ファイルを指定して立ち上げます。
<example>
# ifup eth0=home
</example>
<p>
職場ネットワークのために <tt>eth0</tt> を再設定するには、次のコマンド
を実行します。
<example>
# ifdown eth0
# ifup eth0=work
</example>
<p>
上記で書かれた <file>interfaces</file> ファイルを用いると、もはや
<tt>ifup eth0</tt> を用いるだけで <tt>eth0</tt> を立ち上げる
ことができることに注意してください。
この理由としては、<prgn>ifup</prgn> は物理インターフェースの名前を
標準の論理インターフェースの名前として使用しており、私達の例では
<tt>eth0</tt> という論理インターフェースを定義していないためです。

<sect id="net-magic-reconf">魔法のようなネットワーク再設定
<p>
論理インターフェース名は <prgn>ifup</prgn> が起動する時に他の
論理インターフェース名に "マップ" できます。
どのような名前にマップされるかは状況に依存して変更できます。
それゆえ、<prgn>ifup</prgn> は前もって定義された候補の中から適切な
論理インターフェースとして与えられた物理インターフェースを立ち上げる
ように設定できます。
<p>
論理インターフェースの名前のマッピングは次のように発生します。
<list compact>
<item>論理インターフェース名が <prgn>ifup</prgn> コマンドラインに
与えられていない場合、物理インターフェース名は論理インターフェース名
の初期値として使用される。
<item>論理インターフェース名が <tt>mapping</tt> 節の glob パターンに
マッチする場合、新しい論理インターフェース名の生成にマッピングが
適用される。
<item>最後の論理インターフェース名が <file>/etc/network/interfaces</file>
に定義されている論理インターフェースの定義のラベルである場合、
物理インターフェースが論理インターフェースとして立ち上げられる。
上記に当てはまらない場合は、<prgn>ifup</prgn> が "Ignoring unknown interface" 
というメッセージを表示して終了する。
</list>
<tt>mapping</tt> 節の文法は次のとおりです。
<example>
mapping <var>glob-pattern</var>
         script <var>script-name</var>
        [map <var>script input</var>]
</example>

<tt>mapping</tt> 節で示されたスクリプトは物理インターフェース名と、
標準入力でスクリプトに供給される節の中の全ての "map" 行
の内容を引数として起動されます。
スクリプトは終了前に標準出力にマッピングの結果を表示します。
<p>
例えば、次の <tt>mapping</tt> 節は <tt>eth0</tt> を <tt>home</tt>
論理インターフェースとして <prgn>ifup</prgn> を立ち上げさせます。
<example>
mapping eth0
        script /usr/local/sbin/echo-home
</example>
ここで <prgn>/usr/local/sbin/echo-home</prgn> の内容は次のようなものです。
<example>
#!/bin/sh
echo home
</example>
<p>
マッピングはスクリプトを用いて行われるので、ある種のテストに基づいて
論理インターフェースを選択することが可能です。
例題を始めましょう。
家庭用と職場用で異なるネットワークカードを持っているとします。
<file>/usr/share/doc/ifupdown/examples/</file> ディレクトリには
Media Access Controller address (MAC address) に基づき論理インターフェース
を選択するために用いられるスクリプトが含まれています。
まずスクリプトを適切なディレクトリにインストールします。
<example>
# install -m770 /usr/share/doc/ifupdown/examples/match-mac-address.sh \
   /usr/local/sbin/
</example>
次に次のような節を <file>/etc/network/interfaces</file> に追加します。
<example>
mapping eth0
        script /usr/local/sbin/match-mac-address.sh
        map 02:23:45:3C:45:3C home
        map 00:A3:03:63:26:93 work
</example>
<p>
より洗練されたマッピングプログラムについては下の
<ref id="high-guessnet"> と
<ref id="high-laptop-net"> に記述しています。

<sect1 id="high-guessnet">guessnet
<p>
<package>guessnet</package> をインストールして
<file>/etc/network/interfaces</file> に次のような節を
追加しましょう。
<example>
mapping eth0
        script guessnet-ifupdown
        map home
        map work
</example>
<prgn>ifup eth0</prgn> すると、<prgn>guessnet</prgn> は
<tt>eth0</tt> が <tt>home</tt> と <tt>work</tt> のどちらで立ち上げられたかを
チェックします。これには、論理インターフェースの定義内に保存された情報を
用います。<prgn>guessnet</prgn> はゲートウェイか <tt>tesgt-peer</tt> 行
で認識されるホストかどうかを識別するために ARP 要求を用います。
<p>
<package>guessnet</package> はまだ開発中です。

<sect1 id="high-laptop-net">laptop-net
<p>
<package>laptop-net</package> パッケージはネットワークの再設定に
異なる手法を取っています。Laptop-net は <package>ifupdown</package> の
論理インターフェースを利用していませんが、その代わり、固有の
設定 "スキーム" とシステム "プロファイル" というシステムを持っています。
しかしながら、物理インターフェースを設定するために、Laptop-net は依然
<package>ifupdown</package> を使用しています。
詳細な情報は、<package>laptop-net-doc</package> にある良質な情報に
あたってください。

<sect id="net-trigger">ネットワーク再設定のトリガを設定する
<p>
インターフェースがどのように再設定されるのかを見てきました。
再設定は適切な時期に行われる必要があります。
<p>
伝統的にネットワークは <file>/etc/rcS.d/S40networking</file> initscript
経由でブートシーケンスの間に設定され、滅多に再設定されませんでした。
ネットワークに依存するサービスはブートシーケンスで後に起動されました。
シャットダウン又はリブート時に initscript は逆の順番で起動されました。
<p>
しかしながら、現在 GNU と Linux において動的に変化するハードウェアと状況
のサポートがトレンドです。前者のサポートはホットスワップ可能な PCMCIA 
カードのために追加されました。より最近では、<tt>hotplug</tt> 機構が
追加され、多くの周辺機器がコンピュータの起動中に抜き差しできるように
なりました。
これにはネットワーク関連のハードウェアが含まれます。
ハードウェアに依存するホットスワップされるハードウェアはハードウェアが
挿入された後に起動され、ハードウェアが外された時に停止する必要がある
ことに注意してください。
これはこの種のサービスが System V init システムの制御から外され、
その代わりに <package>ifupdown</package> の制御下に置かれる必要がある
ことを意味しています。
<p>
例えば、initscript <file>/etc/init.d/foo</file> により制御される
サービス <tt>foo</tt>  が動的に再設定されるネットワークインターフェース
<tt>eth0</tt> に依存するとします。
<list compact>
<item>まず init システムの制御から <tt>foo</tt> を取り除きます。
<package>sysv-rc</package> init システムを利用している場合、
次を行います。
<footnote>
これは "stop" リンク (<file>/etc/rc?.d/K??foo</file>) を残しておくことに
注意してください。
これらが無いと <tt>foo</tt> のパッケージがアップグレード時に
出荷時の標準状態に全ての rc シンボリックリンクを回復してしまうので、
例えば、ランレベル 0 と 6 で "stop" を保持したいかもしれません。
</footnote>
<example>
# rm /etc/rc?.d/S??f00
</example>
<item>次に foo initscript を呼び出す <tt>up</tt> と <tt>down</tt> 
オプションを <file>/etc/network/interfaces</file> にある 
<tt>eth0</tt> 節に追加することにより <tt>foo</tt> を 
<package>ifupdown</package> の制御の元に置きます。
<example>
iface eth0 inet dhcp
        up /etc/init.d/foo start
        down /etc/init.d/foo stop
</example>
</list>

<sect1 id="trigger-auto">ブート時にネットワーク設定のトリガーを設定する

<p>
ブート時に <prgn>/etc/rcS.d/S40networking</prgn> init スクリプトは
<prgn>ifup -a</prgn> コマンドを起動します。
これは <file>/etc/network/interfaces</file> の <tt>auto</tt> 節にリスト
されている全ての物理インターフェースを立ち上げます。
<p>
最近動的な方法を用いてネットワーク設定を操作する方がより良いことが
たびたびあります。
いったん動的に変化するハードウェアのサポートメカニズムが機能すると、
まるで動的であったかのように静的なハードウェアを扱うことがシンプルになります。
ブートはもう 1つの hotplug イベントとして扱えます。
(<ref id="trigger-hotplug"> 参照)
<p>
しかしながら、ほとんど全ての場合、少なくともループバックデバイス
<tt>lo</tt> はブート時に立ち上げておきたいでしょう。
それゆえ、<file>/etc/network/interfaces</file> に次の節が含まれている
ことを確認してください。
<example>
auto lo

iface lo inet loopback
</example>
<!--
上記は厳密な節であることを示すためにスベースにより区切られるべき
-->
ブート時に他の物理インターフェースも立ち上げたい場合、 <tt>auto</tt>
節にさらに物理インターフェースを追加できます。
<tt>auto</tt> 節に <strong>決して</strong> PCMCIA インターフェースを
リストしてはなりません。PCMCIA <prgn>cardmgr</prgn> はブートシーケンス
において <prgn>/etc/rcS.d/S40networking</prgn> が起動する時よりも後に
起動されます。

<sect1 id="trigger-hotplug">ネットワーク設定のトリガを設定する &ndash; <package>hotplug</package>
<p>
hotplug のサポートを追加するには、<package>hotplug</package> パッケージ
をインストールしてください。
<p>
ネットワークハードウェアはブート時や、カード (例えば PCMCIA カード) を
マシンに挿入した時、 <prgn>discover</prgn> が起動され、必要なドライバ
モジュールをロードした時にもホットプラグできます。
<p>
kernel が新しいハードウェアを検知すると、ハードウェアのドライバを初期化し、
設定を行うために <prgn>hotplug</prgn> プログラムを起動します。
その後、ハードウェアが削除されると、kernel は異なる環境変数設定を
用いて <prgn>hotplug</prgn> を再び起動します。
&debian; では、<prgn>hotplug</prgn> が呼ばれると、<file>/etc/hotplug/</file>
と <file>/etc/hotplug.d/</file> にあるスクリプトを起動します。
詳細は <manref name="hotplug" section="8"> をご覧下さい。
<p>
新たに挿入されたネットワークハードウェアはスクリプト 
<file>/etc/hotplug/net.agent</file> により設定されます。
<footnote>
<file>/etc/hotplug.d/net/</file> にインストールされたあらゆるスクリプトに
よっても設定されるかもしれません。
</footnote>
PCMCIA ネットワークカードが挿入され、<tt>eth0</tt> が利用可能になる
と仮定します。
<example>
ifup eth0=hotplug
</example>
<file>/etc/network/interfaces</file> に論理インターフェースの定義を追加するか、
<tt>hotplug</tt> という名のマッピングをしなければ、このコマンドは
何もしません。
コマンドが <tt>eth0</tt> を設定するようにするには、次の節を
<file>/etc/network/interfaces</file> に追加しましょう。
<example>
mapping hotplug
        script echo
</example>
<ref id="net-reconf"> で説明したように、これは次と等価になるように
上に示したコマンドをマップします。
<example>
ifup eth0=eth0
</example>
<p>
(<ref id="trigger-ifplugd"> で述べているように、インターフェースを制御
するために <prgn>hotplug</prgn> により起動される <prgn>ifplugd</prgn>
 インスタンスを用いている場合、このようなマッピング節を
追加<strong>しないでください</strong>。)
<p>
<tt>eth0</tt> のみを使いたく、他のインターフェースをホットプラグ時に
立ち上げたくない場合、次のように <prgn>echo</prgn> の代わりに
<prgn>grep</prgn> を使いましょう。
<example>
mapping hotplug
        script grep
        map eth0
</example>
さらに小技を学ぶには、<ref id="net-magic-reconf"> と <url id="&f-hotplug;">
をご覧下さい。

<sect1 id="trigger-ifplugd">ネットワーク設定のトリガを設定する &ndash; <package>ifplugd</package>
<p>
<package>ifplugd</package> はハードウェアがネットワークに接続されているか
どうかによりインターフェースの立ち上げや切断を行います。このプログラムは
Ethernet インターフェースに接続されている通信中のケーブルや無線 
インターフェースとつながったアクセスポイントを検知します。
<prgn>ifplugd</prgn> がリンクの状態の変化を検知すると、標準では
インターフェースに対して <prgn>ifup</prgn> や <prgn>ifdown</prgn>
を呼び出すプロキシスクリプトを起動します。
<p>
<package>ifplugd</package> は <package>hotplug</package> と組み合わせて
うまく動作します。
カードが挿入されると、インターフェースが利用可能となり、
<file>/etc/hotplug.d/net/ifplugd.hotplug</file>  がインターフェースに対して
<prgn>ifplugd</prgn> のインスタンスを起動します。
<prgn>ifplugd</prgn> がネットワークに接続されたカードを検知すると、
インターフェースを <prgn>ifup</prgn> します。

<sect1 id="trigger-waproamd">ネットワーク設定のトリガを設定する &ndash; <package>waproamd</package>
<p>
アクセスポイントに接続するためには、無線 LAN カードが適切な WEP
暗号鍵を用いてプログラムされる必要があるかもしれません。
<ref id="trigger-ifplugd"> に記述されているように <prgn>ifup</prgn>
を制御するために <prgn>ifplugd</prgn> を用いている場合、
明らかに <prgn>ifup</prgn> を用いて暗号鍵を設定できません。なぜならば
<prgn>ifup</prgn> はカードが接続された後でしか呼ばれないからです。
唯一可能な解決策としては、あらゆる必要な鍵を無線 LAN カードの不揮発メモリ
にプログラムしておくことです。
ネットワークをうろつくと、あなたの無線 LAN カードは十分な鍵を保存できない
かもしれません。
<p>
他の解決策としては、スキャニングにより利用可能なことが分かったアクセス
ポイントに従い WEP 暗号鍵を設定する <prgn>waproamd</prgn> を使うことが
挙げられます。
<p>
<package>waproamd</package> は <package>hotplug</package>
と組み合わせてうまく動きます。
カードが挿入され、インターフェースが使用可能となると、
<file>/etc/hotplug.d/net/waproamd.hotplug</file> が
そのインターフェースのために <prgn>waproamd</prgn> の
インスタンスを起動します。
<p>
詳細は <package>waproamd</package> パッケージの README ファイルを
ご覧下さい。

<sect1 id="trigger-pcmcia">ネットワーク設定と PCMCIA
<p> 
16 ビット ISA PCMCIA ネットワークカードを使用している場合、
まず <file>/etc/default/pcmcia</file> に
<tt>CARDMGR_OPTS="-f"</tt> をセットすべきです。
これは 16 ビット PCMCIA システムの初期化をわずかに遅らせますが、
16 ビットのカードが設定されるまで <prgn>cardmgr</prgn> を
フォアグラウンドで起動させることにより競業条件を防ぎます。
<p>
標準では <file>/etc/rc2.d/S20pcmcia</file> から
<file>/etc/init.d/pcmcia</file> スクリプトが起動されますが、
ネットワークサービスが S20 で起動される前に
PCMCIA サブシステムが初期化されることをを保証するために、
このスクリプトをもっと前に、例えば <file>/etc/rc2.d/S12pcmcia</file>
に移動したいかもしれません。
<p>
PCMCIA ネットワークインターフェースを設定するための可能なアプローチ
はいくつか存在します。
<list compact>
<item>32 ビット PCI (CardBus) PCMCIA ネットワークカード用
  <list compact>
  <item><package>hotplug</package> /
  <package>ifupdown</package>
  </list>
<item>16 ビット PCMCIA ネットワークカード用
  <list compact>
  <item><package>hotplug</package> /
  <package>ifupdown</package> とローカルで無効にされた
  <file>/etc/pcmcia/network.opts</file> の組合せ (推奨) 
  又は
  <item><file>/etc/pcmcia/interfaces</file> の機能を有効にする
  ことによりカスタマイズされた <item><package>pcmcia</package> (時代遅れ)
  </list>
</list>
<p>
16 ビットカードのために推奨したアプローチは Linux 2.4 の hot plug
サブシステムが現在 PCMCIA をサポートしているという事実を利用しています。
ただ <ref id="trigger-hotplug"> の指示に従うだけです。
<footnote>
過去の &debian; リリースでは、PCMCIA ネットワークカードの標準的な
設定方法は <prgn>cardmgr</prgn> を通じた <file>/etc/pcmcia/network</file>
と <file>/etc/pcmcia/network.opts</file> フックスクリプトでした。
これらのフックスクリプトはより一般的な目的の hot plug 能力が得られた
Linux の前の時代に開発されました。
<p>
標準状態では、
インターフェースが追加されると <prgn>ifup</prgn> を、
インターフェースが削除されると <prgn>igdown</prgn> を単に呼び出すだけの
これらのスクリプトをまだ使っている人がいます。
上に述べたように、今はインターフェースの追加削除の作業を行うには、
<prgn>hotplug</prgn> を使うことを推奨します。
<p>
<file>/etc/pcmcia/network.opts</file> にある特定の変数が <tt>y</tt>
にセットされると有効にされる低レベルなネットワーク設定コマンドを呼ぶ
特別なシステムを利用する人もまだいます。
このシステムには複数の問題があります。
問題としては、競合条件による不具合や、16 ビット PCMCIA カードしか
動かないこと、<package>ifupdown</package> が行うために残した方が
良いことをやってしまうことがあります。
結果としてこれは時代遅れです。
</footnote>
しかしながら、<prgn>cardmgr</prgn> のフックスクリプト
<file>/etc/pcmcia/network</file> が <package>hotplug</package> と
干渉するのを防ぐためには、標準の挙動を無効にするためにローカルで
<example>
exit 0
</example>
を <file>/etc/pcmcia/network</file> の先頭に追加する必要があります。
<p>
<prgn>cardmgr</prgn> を起動しても何の問題もないことに注意してください。
ただネットワーク設定プログラムを呼び出されたくないだけです。
<p>
<prgn>cardmgr</prgn> を適切に動かすためには、
16 ビット PCMCIA カードにリソースを割り当てるために
<file>/etc/pcmcia/config.opts</file> を編集する必要があるかもしれません。
しれません。
より詳しい情報は <ref id="kernel-pcmcia"> と 
<url id="&pcmcia-howto;" name="Linux PCMCIA HOWTO">
をご覧下さい。

<sect id="net-service-conf">ネットワークサービスの設定
<p>
デスクトップやホームサーバ環境における典型的なネットワークサービスの設定には
次が挙げられます。
<list compact>
<item>インターネット <em>スーパーサーバ</em> と TCP/IP デーモンラッパー。
<ref id="tcpd"> 参照。
<list compact>
<item><file>/etc/inetd.conf</file>
</list>
<item><package>ssh</package>: OpenSSH secure shell。<ref id="ssh"> 参照。
<list compact>
<item><file>/etc/ssh/ssh_config</file>
<item><file>/etc/ssh/sshd_config</file>
</list>
<item><package>exim</package>: メール転送エージェント。
<ref id="name-mail"> および <ref id="mta"> 参照。
<list compact>
<item><file>/etc/exim/exim.conf</file>
<item><file>/etc/mailname</file>
<item><file>/etc/aliases</file>
<item><file>/etc/email-addresses</file>
</list>
<item><package>fetchmail</package>: POP3 アカウントからメールを取得。
<ref id="fetchmail"> 参照。
<list compact>
<item><file>/etc/fetchmailrc</file>
</list>
<item><package>procmail</package>: ローカルのメール配達およびフィルタプログラム。<ref id="procmail"> 参照。
<list compact>
<item><file>~/.procmailrc</file>
</list>
<item>ホスト名と DNS (プロキシ、キャッシュなど)。<ref id="name-host"> 
と<ref id="net-dns"> 参照。
<list compact>
<item><file>/etc/host.conf</file>
<item><file>/etc/hostname</file>
<item><file>/etc/hosts</file>
<item><file>/etc/hosts.allow</file>
<item><file>/etc/hosts.deny</file>
<item><file>/etc/resolv.conf</file>
<item><file>/etc/bind/named.conf</file> (編集)
<item><file>/etc/bind/db.lan</file> (LAN ホスト用に追加)
<item><file>/etc/bind/db.<var>192.168.0</var></file> (LAN の逆引き用に追加)
</list>
<item>DHCP。<ref id="net-dhcp"> 参照。
<list compact>
<item><file>/etc/dhcp3/dhclient.conf</file> (DHCP クライアント)
<item><file>/etc/default/dhcp3-server</file> (DHCP サーバ)
<item><file>/etc/dhcp3/dhcpd.conf</file> (DHCP サーバ)
</list>
<item><package>cvs</package>: バージョン管理システム。<ref id="cvs"> 参照。
<list compact>
<item><file>/etc/cvs-cron.conf</file>
<item><file>/etc/cvs-pserver.conf</file>
</list>
<item><package>nfs-kernel-server</package>: ネットワークファイルシステム。
<ref id="nfs"> 参照。 (unix ライクシステム用)
<list compact>
<item><file>/etc/exports</file>
</list>
<item><package>samba</package>: Windows 用のネットワークファイルシステムおよびプリンタ共有。<ref id="samba"> および <ref id="smbmount"> 参照。
<list compact>
<item><file>/etc/samba/smb.conf</file>
</list>
<item>プリンタデーモンシステム。<ref id="printer"> 参照。
<list compact>
<item><file>/etc/printcap</file> (lpr 用)
</list>
<item><package>apache</package> と <package>apache2</package>: ウェブサーバ。
<list compact>
<item><file>/etc/apache/*</file>
<item><file>/etc/apache2/*</file>
</list>
<item><package>squid</package>: ウェブプロキシキャッシュサーバ。
<list compact>
<item><file>/etc/squid/*</file>
</list>
</list>

<!--
XXX FIXME XXX: 
The network service section needs more detailed contents.
Volunteers are welcomed.  
-->
<!-- explain each types under sect1 -->
<!-- equivalent ones under sect2 -->
<!-- avoid duplication with tune.sgml -->
<!-- this needs major rewrite -->
<!-- Keep It Short and Simple (KISS) -->
<!-- Use /bin/sh instead of English -->

<sect id="net-trouble">ネットワークのトラブルシュート
<p>
ネットワークに関する問題に直面したら、次の出力を最初の真偽の確認として
チェックしてください。
<example>
# ifconfig
# cat /proc/pci
# cat /proc/interrupts
# dmesg | more
</example>
又、<ref id="net-test"> をご覧下さい。
<!-- add id="..." to corresponding 3 sect1 tags in tips.sgml -->
<!-- That section should be moved here //JDTH -->
<!-- Yes.  But when you do, do it for all languages and fix 
 version tracking number if you can -->
<p>
特定のウェブサイトを見れない問題に直面した場合は、<ref id="killecn">
をご覧下さい。

<sect id="net-router">ゲートウェイルータを構築する
<p>
&debian; ホストはネットワークアドレス変換 (NAT、マスカレードとしても知られる)
、メール転送、DHCP、DNS キャッシング、HTTP プロキシキャッシング、CVS
サービス、NFS サービス、そして Samba サービスを行う多目的の
ゲートウェイマシンにできます。これらの設定の例は <ref id="ipmap">
をご覧下さい。

<sect1 id="router-netfilter">Netfilter 設定
<p>
netfilter/iptables プロジェクトは Linux 2.4 以降のための
ファイアーウォールサブシステムです。
<url id="&netfilterhome;" name="Netfilter"> をご覧下さい。
この文書では多くのネットワーク設定例が説明されています。

<sect2 id="netfilter-basics">netfilter の基礎
<p>
Netfilter は五つの組込みチェイン、すなわち
PREROUTING, INPUT, FORWARD, OUTPUT そして POSTROUTING
を使うパケットを処理します。
<example>
                ルーティング
                方向
IN ------> PRE ---> ------> FORWARD -----> ----> POST -----> OUT
interface   ROUTING ＼       filter       /       ROUTING     interface
              DNAT        |      tracking     ^       SNAT
            REDIRECT    |                      |       MASQUERADE
                              v                     |
                          INPUT                OUTPUT
                             | filter                ^ filter,DNAT 
                             v                       |
                           \--&gt; ローカルのプロセス --/
                                ユーザスペースのプログラム
</example>

<sect2 id="netfilter-table">Netfilter テーブル
<p>
パケットはそれぞれの組込みチェインにて次のテーブルを用いて処理されます。
<list compact>
<item>フィルタ (パケットフィルタ、標準)
<list compact>
<item>INPUT (ルータ自体に入り込むパケット用)
<item>FORWARD (ルータを通ってルーティングされているパケット用)
<item>OUTPUT (ローカルで生成されたパケット用)
</list>
<item>nat (ネットワークアドレス変換)
<list compact>
<item>PREROUTING (入り込んですぐにパケットを変換するため)
<item>OUTPUT (ルーティング前にローカルで生成されたパケットを変換するため)
<item>POSTROUTING (出て行こうとするパケットを変換するため)
</list>
<item>mangle (ネットワークアドレス変換、kernel 2.4.18 以降のみでうまく動く)
<list compact>
<item>全ての組込チェインが利用可能
</list>
</list>

<sect2 id="netfilter-target">Netfilter のターゲット
<p>
ファイアーウォールのルールにはいくつかのターゲットがあります。
<list compact>
<item>四つの基本的なターゲット
<list compact>
<item>ACCEPT はパケットの通過を許すことを意味する。
<item>DROP はパケットを落とすことを意味する。
<item>QUEUE はパケットをユーザスペースに通すことを意味する。(kernel がサポートしている場合)
<item>RETURN はこのチェインの検討を止め、以前の (呼び出し元) チェイン内の
次のルールから検討を始めることを意味する。
</list>
<item>拡張されたターゲット。
<list compact>
<item>LOG は kernel ログに記録する。
<item>REJECT はエラーパケットを送信し、そのパケットを落とす。
<item>SNAT パケットの送信元アドレスを変換し、POSTROUTING チェインでのみ使用する
(nat テーブルのみ)
<example compact>
--to-source ipaddr[-ipaddr][:port-port]
</example>
<item>MASQUERADE は SNAT と同じだが動的に割り当てられる IP (ダイアルアップ) 
接続用 (nat テーブルのみ)
<example compact>
--to-ports port[-port]
</example>
<item>DNAT はパケットの送信先アドレスを変換し、PREROUTING と OUTPUT チェイン
とこれらのチェインからのみ呼ばれるユーザが定義したチェインで使用される。
(nat テーブルのみ)
<example compact>
--to-destination ipaddr[-ipaddr][:port-port]
</example>
<item>REDIRECT はマシン自身にパケットを送るためにパケットの送信先 IP アドレス
をマシン自身の IP アドレスに変換する。
<example compact>
--to-ports port[-port]
</example>
</list>
</list>

<sect2 id="netfilter-command">Netfilter コマンド
<p>
<prgn>iptables</prgn> の基本的なコマンドは次のようになります。
<example compact>
iptables -N <var>chain</var>                   #<var>chain</var> を作成

iptables -A <var>chain</var> \                 # <var>chain</var> にルールを追加
         -t <var>table</var> \                 # <var>table</var> を使用 (filter, nat, mangle)
         -p <var>protocol</var> \              # tcp, udp, icmp, 又はこれら全て
         -s <var>source-address[/mask]</var> \
         --sport <var>port[:port]</var> \      # -p が tcp 又は udp の場合は送信元ポート
         -d <var>destination-address[/mask]</var> \
         --dport <var>port[:port]</var> \      # -p が tcp 又は udp の場合は送信先ポート
         -j <var>target</var> \                # マッチした場合の行動
         -i <var>in-interface-name</var> \     # INPUT,  FORWARD, PREROUTING 用
         -o <var>out-interface-name</var>      # FORWARD, OUTPUT, POSTROUTING 用
</example>

<sect2 id="ip-masq">ネットワークアドレス変換
<p>
LAN 上のマシンは LAN 上の IP アドレスをインターネット上で使える IP
アドレスに変換するゲートウェイを経由してインターネットのリソースに
アクセスできます。
<example>
# apt-get install ipmasq
</example>
<prgn>ipmasq</prgn> の防護を強化するためにサンプルルールを追加してください。
<url id="&f-ipmasq-strong;"> をご覧下さい。
woody にある Debian の kernel-image-2.4 の場合、適切なモジュールが
ロードされていることを確認してください。
設定方法については <ref id="kernel-net"> をご覧下さい。
<p>
Debian の kernel-image-2.2 の場合、<file>/etc/masq/rules</file> にある
<file>Z92timeouts.rul</file> を次に示すように編集し、リモートサイトへの
より長い接続を保証するようにしてください。(大きなメールなどのために役立ちます)
<example>
# tcp, tcp-fin, udp
# 2hr, 10 sec, 160 sec - default
# 1 day, 10 min, 10 min - longer example
$IPCHAINS -M -S 86400 600 600
</example>
又、ネットワークに PCMCIA NIC 経由でアクセスしている場合、<prgn>ipmasq</prgn>
が <file>/etc/pcmcia/network.opts</file> (<url id="&f-ipmasq;"> 参照) 又は
<file>/etc/network/interfaces</file> (<ref id="trigger-pcmcia"> と <ref id="net-trigger">
参照) から起動される必要があります。

<sect2 id="ip-redirect">SMTP 接続をリダイレクトする (2.4 用)
<p>
他の LAN 環境で利用するように設定しているノート PC を持っており、
再設定せずにノート PC 上でメーラを使いたいとします。
<p>
ゲートウェイマシンに <prgn>iptables</prgn> を通じて次のルールを 
追加し、SMTP 接続をゲートウェイマシンにリダイレクトします。
<example>
# iptables -t nat -A PREROUTING -s 192.168.1.0/24 -j REDIRECT \
           -p tcp --dport smtp --to-port 25 # smtp=25, INPUT is open
</example>
より徹底的なリダイレクトルールセットが必要な場合は、
<package>ipmasq</package> パッケージをインストールし、
<file>/etc/ipmasq/rules/</file> ディレクトリに
<file><url id="&examples;" name="M30redirect.def"></file> を
追加することを考えてください。

<sect1>複数のネット接続を管理する
<p>
[FIXME] Policy routing (by Phil Brutsche
<email>pbrutsch@tux.creighton.edu</email>):
詳細は <url id="&iproute;" name="iproute manual"> をご覧下さい。
トラフィックコントロール (tc) にも興味が湧くかもしれません。
<p>
次のような環境を考えます。
<example>
eth0: 192.168.1.2/24; gateway 192.168.1.1
eth1: 10.0.0.2/24; gateway 10.0.0.1
このマシン上でマスカレードは行いません。
</example>
特別な魔法を施します。
<enumlist compact>
<item>ip rule add from 192.168.1.2 lookup 1
<item>ip rule add from 10.0.0.2 lookup 2
<item>ip route add to default via 10.0.0.1 metric 0
<item>ip route add to default via 192.168.1.1 metric 1
<item>ip route add table 1 to 192.168.1.0/24 via eth0
<item>ip route add table 1 to 10.0.0.2/24 via eth1
<item>ip route add table 1 to default via 192.168.1.1
<item>ip route add table 2 to 192.168.1.0/24 via eth0
<item>ip route add table 2 to 10.0.0.2/24 via eth1
<item>ip route add table 2 to default via 10.0.0.2
</enumlist>
<p>
[FIXME] これを試したことはありません。オートダイアル機能を使わないで
高速な接続のバックアップとしてダイアルアップをどうやって設定しますか?
パッチを送ってください。:)
</sect>


</chapt>
