<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.82"  -->
<chapt id="system">Debian の基礎知識

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p> 
本章は非開発者のために Debian システムの基礎的な情報を供給します。
信頼できる情報が欲しい場合は、次を参照してください。

<list compact>
<item>Debian ポリシーマニュアル
<item>Debian パッケージングマニュアル (Potato)
<item>Debian デベロッパーリファレンス
<item>Debian ニューメンテナーズガイド
</list>
<ref id="references"> にリストされています。

<p>
あまり詳しくない "how-to" 的な説明を探している場合、
<ref id="package"> や他の該当する章にすぐ飛んでください。
<p>
本章は "Debian FAQ" から取られた文書に基づき、通常の Debian 
システム管理者が始められるように大規模な再構成を行いました。

<!-- 
HTTP や他の方法でも取得できるので、"FTP archives" は現在シンプルな 
"archives" に変更されました。
-->

<sect id="ftparchives">Debian アーカイブ

<sect1 id="dirtree">ディレクトリ構造

<p>&debian; 用にパッケージングされているソフトウェアは
<url id="&mirror-site; "name="Debian mirror site"> のそれぞれのいくつかの
ディレクトリツリーの一つから FTP 並びに HTTP 経由で取得できます。

<p>次のディレクトリは 各 Debian ミラーサイトの <file>debian</file> 
ディレクトリの下で見つかります。
<taglist>
  <tag><file>dists/</file>:
    <item>このディレクトリには "distributions" が含まれており、これは
    現在 Debian release および pre-release で得られるパッケージへの
    標準的なアクセス手段として使用されます。いくつかの古いパッケージや
    <file>Packages.gz</file> もまだここにあります。
  <tag><file>pool/</file>:
    <item>ここは Debian release および pre-release の全パッケージ
    の物理的に存在する場所です。
  <tag><file>tools/</file>:
    <item>ブートディスク作成、ハードディスクのパーティショニング、
    ファイル圧縮/解凍、そして Linux のブート用の DOS ユーティリティが
    ここにあります。
  <tag><file>doc/</file>:
    <item>FAQ, バグ報告システム指示書などの基本的な Debian に関する
    文書がここにあります。
  <tag><file>indices/</file>:
    <item>Maintainers ファイルや override ファイルがここにあります。
  <tag><file>project/</file>:
    <item>主に開発者のみ必要なものです。例えば、
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>本ディレクトリにはまだ開発中であり、まだ α テスト段階の
        パッケージやツールが含まれます。ユーザはここにあるパッケージを
        使用するべきではありません。なぜなら、最も経験を積んだ人でさえも
        危険で害を及ぼす可能性があるからです。
      <tag><file>project/orphaned/</file>:
        <item>古いメンテナにより「みなしご化」され、ディストリビューションから
        なくなったパッケージです。
    </taglist>
</taglist>

<sect1 id="dists">Debian ディストリビューション

<p>通常 <file>dists</file> ディレクトリには 3種類の Debian 
ディストリビューションが存在します。これらは <tt>stable</tt>.  
<tt>testing</tt> そして <tt>unstable</tt> と呼ばれます。
時々 <tt>frozen</tt> も存在します。各ディストリビューションは 
<file>dists</file> ディレクトリにある、コードネームが付いた
実際のディレクトリのシンボリックリンクとして定義されています。

<sect1 id="stable"><tt>stable</tt> ディストリビューション

<p><tt>stable</tt> ディストリビューション, &stabledebian; 用のパッケージ
エントリは <tt>stable</tt> (<file>&stablecodenamedir;/</file> への
シンボリックリンク) ディレクトリに記録されています。
<list>
  <item><file>stable/main/</file>:
  このディレクトリには &debian; システムの最新の公式リリースに属する
  バージョンのパッケージが含まれます。

  <p>これらのパッケージは全てフリーです。すなわち、これらは全て
  <url name="Debian Free Software Guidelines"
  id="&social-contract;#guidelines"> (DFSG) 
  に適合しています。(<package>&p-social-contract;</package> により 
  インストールされる  <file>&f-social-contract;</file> としても
  得られます。)

  <item><file>stable/non-free/</file>:  このディレクトリには
  DFSG に従ってフリーと認定されないパッケージが含まれます。
  <p>
  例えば、いくつかのパッケージは商用配布を禁止するライセンスを持っています。
  また、あるパッケージは再配布可能ですが、実はシェアウェアです。

  <item><file>stable/contrib/</file>: このディレクトリには
  それら自体は DFSG-free ですが、DFSG-free では<strong>ない</strong>
  パッケージになぜか依存しているパッケージです。
</list>
現在は、上に挙げた場所に加えて、<file>pool</file> ディレクトリに新しい
物理的なパッケージがあります。 (<ref id="pools"> 参照)

<p><tt>stable</tt> ディストリビューションの最新バグステータスは
<url id="&stable-problems;" name="Stable Problems"> web ページに
報告されています。


<sect1 id="testing"><tt>testing</tt> ディストリビューション

<p><tt>testing</tt> ディストリビューション、&testingdebian; のパッケージ
エントリは <tt>unstable</tt> でしばらくテストを受けた後に
<file>testing</file> (<file>&testingcodenamedir;/</file> への
シンボリックリンク) ディレクトリに記録されます。
上に挙げた場所に加え、<file>pool</file> ディレクトリに新しい
物理的なパッケージがあります。 (<ref id="pools"> 参照)
<file>testing/</file> に <file>stable/</file> と同じ機能を提供する 
<file>main</file>、<file>contrib</file> そして <file>non-free</file>
サブディレクトリもあります。

<p>これらのパッケージはビルドされる全てのアーキテクチャで同期を取られ、
インストール可能でなくてはなりません。また、<tt>unstable</tt>
にあるバージョンよりも release-critical bug が少なくてはなりません。
このように、<tt>testing</tt> は常に release candidate 間近であることを
希望しています。testing のメカニズムの詳細については
<url id="&testing-notes;"> にあります。

<p><tt>testing</tt> ディストリビューションの最新バグステータスはこれらのサイト
で報告されています。
<list compact>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="other bugs and bug-squashing party notes">
</list>

<sect1 id="unstable"><tt>unstable</tt> ディストリビューション

<p><tt>unstable</tt> ディストリビューションは、常に "Sid" というコードネームであり、パッケージエントリは Debian archive にアップロードされた後に 
<file>unstable</file> (<file>sid/</file> へのシンボリックリンク) ディレクトリに
記録され、<file>testing/</file> に移動されるまでここにあります。
上に挙げた場所に加え、<file>pool</file> ディレクトリに新しい
物理的なパッケージがあります。 (<ref id="pools"> 参照)
<file>testing/</file> に <file>stable/</file> と同じ機能を提供する 
<file>main</file>, <file>contrib</file>, そして <file>non-free</file>
サブディレクトリもあります。

<p><tt>unstable</tt> ディストリビューションには最新の開発版システムの
スナップショットが含まれます。ユーザがパッケージを使ってテストするのは
歓迎されますが、これらのパッケージが準備段階にあることは警告されます。
<tt>unstable</tt> ディストリビューションを使う利点としては、
常に最新の &debian; ソフトウェアプロジェクトを使えます。
&mdash; たとえシステムを壊すようなことがあったとしても、
壊れたシステムをそのままキープできます。

<p><tt>unstable</tt> ディストリビューションの最新バグステータスは
<url id="&unstable-problems;" name="Unstable Problems">web ページで
報告されています。

<!-- Above was enough
<sect1 id="sid">The Sid distribution

<p>Sid or <tt>unstable</tt> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <tt>testing</tt>,
in order to be released in <tt>stable</tt> later on. Sid contains packages
for both released and unreleased architectures.

<p>The name "Sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen"><tt>frozen</tt> ディストリビューション

<p><tt>testing</tt> ディストリビューションが充分成熟すると、frozen されます。
そして、新しいコードはもはや受け付けず、必要ならばバグフィックスのみ
受け付けられます。さらに、新しい testing ツリーが <file>dists</file>
ディレクトリに作成され、新しいコードネームを割り当てられます。
frozen ディストリビューションは数ヵ月テストされ、"テストサイクル"
と呼ばれる deep freeze に入ります。
(最近の Woody リリースは <file>froze</file> シンボリックリンクを作成
しません。それゆえ、<tt>frozen</tt> はディストリビューションではなく、
<tt>testing</tt> ディストリビューションの開発段階です。)

<p>パッケージのリリースを遅らせたり、リリース全体を止めてしまう
frozen ディストリビューションのバグを記録し続けています。
バグ総数が最大許容数を下回ったら、frozen ディストリビューション
は stable になり、リリースされます。そして以前の stable ディストリビューション
は obsolete になります。(そして archive に移動します)

<sect1 id="codenames">Debian ディストリビューションのコードネーム

<p><file>&stablecodenamedir;/</file> や <file>&testingcodenamedir;/</file>
などの、<file>dists</file> ディレクトリにある物理的に存在するディレクトリ名は、
単なる "コードネーム" です。&debian; ディストリビューションが開発段階に
あるとき、バージョン番号を持ちませんが、その代わりコードネームを持ちます。
これらのコードネームの目的は、&debian; ディストリビューションのミラーリングを
より簡単に行うためです。(<file>unstable</file> のような真のディレクトリ名が
<file>stable</file> に突然変わると、多くの努力が無駄になり、再び
ダウンロードを行わなくてはならなくなります)

<p>現在、<file>stable</file> は <file>&stablecodenamedir;/</file> の、
<file>testing</file> は <file>&testingcodenamedir;/</file> のシンボリック
リンクです。これは <tt>&stablecodename;</tt> が現在の stable 
ディストリビューションであり、<tt>&testingcodename;</tt> が現在の
testing ディストリビューションであることを意味しています。

<p>Sid は常に unstable ディストリビューションですので、<file>unstable/</file>
は <file>sid/</file> の永続的なシンボリックリンクです。 
<!-- (<ref id="sid">参照)。-->

<sect1 id="oldcodenames">過去に使用されたコードネーム

<p>過去に使われたコードネームは次の通りです。
release 1.1 では "Buzz", 
release 1.2 では "Rex", 
release 1.3.x では "Bo", 
release 2.0 では "Hamm", 
release 2.1 では "Slink", 
release 2.2 では "Potato",
release 3.0 では "Woody", 
release 3.1 では "Sarge"。

<sect1 id="sourceforcodenames">コードネームの由来

<p>いままではコードネームは Pixar 作の映画 <em>トイストーリー</em> の
キャラクター名から取られていました。
<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) は宇宙飛行士です。
  <item><strong>Rex</strong> はチラノザウルスです。
  <item><strong>Bo</strong> (Bo Peep) は羊飼いの娘です。
  <item><strong>Hamm</strong> Hamm は豚の形の貯金箱です。
  <item><strong>Slink</strong> (Slinky Dog) おもちゃの犬です。
  <item><strong>Potato</strong> はもちろん、ミスターポテトです。
  <item><strong>Woody</strong> はカウボーイです。
  <item><strong>Sarge</strong> はグリーンプラスティックアーミーのリーダーです。
  <item><strong>Etch</strong> (Etch-a-Sketch) はおもちゃの黒板です。
  <item><strong>Sid</strong> は隣に住んでいる、おもちゃを壊す男の子です。
</list>
<!--
  more info in http://www.pixar.com/featurefilms/ts/index.html
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools"><file>pool</file> ディレクトリ

<p>歴史的に、パッケージはパッケージを含むディストリビューションに対応した
<file>dists</file> サブディレクトリに保持されました。これは大きな変更が
発生した場合、ミラーするのに大きなバンド幅を消費するなどのさまざまな
問題を引き起こしました。

<p>パッケージは現在大きな "pool" に保存され、source パッケージの名前に
従って構造化されます。この "pool" を管理可能にするため、pool は
セクション (<tt>main</tt>, <tt>contrib</tt>, そして <tt>non-free</tt>)
および source パッケージの先頭の文字により分割されます。これらのディレクトリ
には、各アーキテクチャ用のバイナリパッケージ、そして
バイナリパッケージの生成元である source パッケージなどが含まれます。

<p><tt>apt-cache showrc <var>mypackagename</var></tt> のようなコマンドを
実行し、"Directory:" 行を見ることにより、パッケージの場所を見つけられます。
例えば、<package>apache</package> パッケージは  
<file>pool/main/a/apache/</file> にあります。非常に多くの <tt>lib*</tt> 
パッケージが存在するため、これらのパッケージは特別扱いされています。
例えば、<package>libpaper</package> パッケージは 
<file>pool/main/libp/libpaper/</file> に保存されています。

<p><file>dists</file> ディレクトリは依然 <prgn>apt</prgn> のような
プログラムにより使用される索引ファイルのために使われています。また、
本文書を書いている時点では、以前のディストリビューションは pool を
使うように変換されていませんので、"Directory" ヘッダフィールドの
<tt>potato</tt> や <tt>woody</tt> のようなディストリビューション名を
含むパスを見掛けるでしょう。

<p>新しい <prgn>apt</prgn> や多分古い <prgn>dpkg-ftp</prgn> 
はシームレスな処理を行うので、通常は
これらのことを心配する必要はありません。詳細を知りたい場合は、
<url id="&pool-faq;" name="RFC: implementation of package pools"> 
をご覧ください。

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Sid に関するヒストリカルノート

<p>昔 Sid は存在していませんでした。Debian archive サイトは大きな欠陥を 
1つ持っていました。アーキテクチャが最新の <file>unstable</file> 
に作られると、ディストリビューションが新しい <tt>stable</tt> になった時に
それがリリースされるという前提がありました。このケースにあてはまらない
多くのアーキテクチャにとって、リリース時にこれらのディレクトリが移動
しなければならないという結果となりました。この移動が膨大なバンド幅を
消費するため、これは実際的ではありません。

<p>アーキテクチャ管理者はこの問題に数年間取り掛かり、<file>sid</file> と
呼ばれる特別なディレクトリに未リリースのアーキテクチャのためのバイナリを置く
ことにより問題を解決しました。未リリースのアーキテクチャが最初にリリースされる
場合、最新の <file>stable/</file> に対し <file>sid/</file> がリンク
されました。そして、それ以降は通常どおり <file>unstable</file> 内に
バイナリが作成されました。

<p>Woody ディストリビューションの開発中にパッケージプールを
(<ref id="pools"> 参照) 発明したことにより、バイナリパッケージは
ディストリビューションに依らずにプール内の標準的な場所に保存され始めました。
それゆえ、ディストリビューションのリリースを行っても、もはやミラー時に
大きなバンド幅を消費しません。(しかし、開発過程を通し、緩やかなバンド幅
消費が発生します。)

<sect1 id="incoming"><file>incoming/</file> にパッケージをアップロードする
<p>パッケージのアップロードはそれらが本当に Debian 開発者からのものかを
検査した後に <url id="&incoming;"> にまず置かれます。
(そしてそれがノンメンテナアップロード (NMU) の場合は、<file>DELAYED</file>
サブディレクトリに置かれます。)
1日に 1度、それらは <file>incoming/</file> から <file>unstable/</file> 
に移されます。
<p>
緊急時には、<file>incoming/</file> が <file>unstable/</file> に移る前に
パッケージをインストールしたい場合があるかもしれません。
</sect1>

<sect1 id="snapshot">古いパッケージを取得する
<p>
最新の Debian ディストリビューションは <url id="&mirror-site;" name="Debian mirror site"> の <file>debian</file> ディレクトリ下に保持されますが、Slink 
などの古い Debian ディストリビューションのアーカイブは 
<url id="&archivehome;"> や Debian の各ミラーサイトの 
<file>debian-archive</file> ディレクトリに保存されています。
<p>
<tt>testing</tt> や <tt>unstable</tt> の昔のパッケージは
<url id="&snapshothome;"> にあります。

</sect1>

<sect1 id="archsections">アーキテクチャセクション
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>主要なディレクトリツリーそれぞれ (<file>dists/stable/main</file>,
<file>dists/stable/contrib</file>, <file>dists/stable/non-free</file>, 
<file>dists/unstable/main/</file> など) の中に、バイナリパッケージエントリが
パッケージがコンパイルされたアーキテクチャを示す名前を持つサブディレクトリ
内に存在します。

<list>
  <item><file>binary-all/</file>: アーキテクチャに依存しないパッケージ用。
  これらには例えば、Perl スクリプトや、純粋なドキュメントが含まれます。
  <item><file>binary-<var>platform</var>/</file>: 特定のバイナリ
  プラットフォームで実行するパッケージ用。
  <!-- Yes I simplified this -->
</list>

<p><tt>testing</tt> と <tt>unstable</tt> 用の実際のバイナリパッケージは
もはやこれらのディレクトリに無く、<file>pool</file> ディレクトリに
あることに注意してください。しかし、索引ファイル (<file>Packages</file> と
<file>Packages.gz</file>) は下位互換性のために保持されています。

<p>実際にサポートされているバイナリパッケージについては、
各ディストリビューションのリリースノートをご覧ください。
これらは <url id="&stable-release;" name="stable"> および
<url id="&testing-release;" name="testing"> のためのリリースノート
サイトにあります。

<!-- 上のリリースノートが充分になったら削除してください。
<p>詳細は <ref id="arches"> をご覧ください。
-->

<sect1 id="source">ソースコード

<p>ソースコードは Debian システムにおける全てに対して含まれます。さらに、
システムのほとんどのプログラムのライセンス事項は、ソースコードが
プログラムと共に配布されるか、プログラムに添付するソースコードを
提供することを <strong>要求</strong>します。

<p>通常ソースコードは <file>source</file> ディレクトリで配布され、
アーキテクチャ特有のバイナリディレクトリ全てと並列になっているか、
より最近では <file>pool</file> ディレクトリにあります。
(<ref id="pools"> 参照)
Debian アーカイブの構造を熟知せずにソースコードを取得するには、
<tt>apt-get source <var>mypackagename</var></tt> のようなコマンドを
試してみてください。

<p>いくつかのパッケージ、とりわけ <package>pine</package> は
そのライセンスの制限により、ソースパッケージでしか得られません。
(最近、<package>pine-tracker</package> パッケージが Pine のインストールを
容易にするために導入されました。<ref id="port"> や <ref id="packaging">
に記述された手順により、パッケージを手動で構築する方法を習得できます。

<p>公式には Debian システムの一部では無い <file>contrib</file> や 
<file>non-free</file> ディレクトリにあるパッケージのソースコードは
入手できるかもしれませんし、できないかもしれません。

<sect id="pkg-basics">Debian パッケージ管理システム

<sect1 id="package-basics">Debian パッケージの概観

<p>一般にパッケージには関連するコマンドや機能を実装するのに必要な
ファイルすべてが含まれています。Debian パッケージには 2つのタイプがあります。
<list>
  <item><strong>バイナリパッケージ</strong>。これには実行ファイル、
  設定ファイル、 man ページと info ページ、著作権情報やその他の文書が
  含まれます。これら のパッケージは Debian 固有のアーカイブ形式で
  配布されています。(<ref id="deb-format">参照) また .deb という
  ファイル拡張子を持っています。バイナリパッケージは Debian ユーティリティ 
  <prgn>dpkg</prgn> を用いて展開できます。詳細は <prgn>dpkg</prgn> の
  マニュアルページに記載されてあります。
  
  <item><strong>ソースパッケージ</strong>。ソースパッケージの解説が書かれた 
  <tt>.dsc</tt> ファイル (このファイルには以下のファイルの名前も書かれています)
  や、修正されていないオリジナルのプログラムソースが gzip で圧縮された 
  tar フォーマット形式で含まれている <tt>.orig.tar.gz</tt> ファイ ル、
  通常 Debian 固有の変更を記した <tt>.diff.gz</tt> ファイルから構成
  されています。<prgn>dpkg-source</prgn> ユーティリティは Debian 
  ソースアーカイブをパックしたりアンパックしたりします。
  詳細は<prgn>dpkg-source</prgn> のマニュアルページに記載されています。
</list>

<p>このパッケージシステムでは、ソフトウェアをインストールするとき、
パッケージ保守担当者により宣言された "依存情報" を使います。
この依存情報はそれぞれのパッケージに関連する <file>制御 (control)</file>
ファイルに記載されています。例えば、GNU C コンパイラ (<package/gcc/) 
を含むパッケージは、リンカやアセンブラを含む <package/binutils/ パッケージに
"依存"しています。もしユーザがあらかじめ <package/binutils/ をインストール
していないの に <package/gcc/ をインストールしようとしたなら、Debian の
パッケージシステムは <package/binutils/ も必要であるというエラーメッセージを
出力し、ユーザがまず <package/binutils/ をインストールするのに同意するまで 
<package/gcc/ をインストールしません (とは言うものの、頑固なユーザは
この機能を上書きできます。<manref name="dpkg" section="8"> 参照)
さらに詳しい情報は、<ref id="depends"> 下をご覧ください。


<p>Debian のパッケージングツールは以下の用途に使えます。
<list>
  <item>パッケージやパッケージの一部を操作したり管理したりする。
  <item>フロッピーディスクなどの限られたサイズの媒体を通じて
  輸送しなければならないパッケージをユーザが分解するのを助ける。
  <item>パッケージアーカイブを開発者が構築するのを助ける。
  <item>遠隔の Debian アーカイブサイトに置かれたパッケージをユーザが
  インストールするのを助ける。
</list>

<sect1 id="deb-format">Debian パッケージのフォーマット
<p>
Debian の "パッケージ" つまり Debian アーカイブファイルには、
実行プログラム一式や関連するプログラムのセットに関係する実行ファイルや、
ライブラリ、ドキュメントが含まれています。通常、Debian アーカイブファイルは
ファイル名の最後に <tt>.deb</tt> が付いています。
<footnote>

<!-- Colin Watson により投稿されたメッセージに基づき、 Osamu が下文書を追加 -->
<p><prgn>debian-installer</prgn> プロジェクトは <tt>.udeb</tt> で終わる
ファイル名のパッケージを導入しました。要するに、マイクロ <tt>.deb</tt>
フォーマットは ポリシーに正しくは従う必要はなく、ドキュメントなどの
内容を欠いており、<prgn>debian-installer</prgn> だけに用いられることを
意味しています。新しい Debian インストーラは Sarge のリリースのために
開発されています。<tt>.deb</tt> と <tt>.udeb</tt> のファイルフォーマット
は同じ物です。<prgn>udpkg</prgn> プログラムは 標準の <prgn>dpkg</prgn>
より制限された能力を持つ <tt>.udeb</tt> パッケージを操作するために使われ、
より少ないパッケージの関係をサポートします。名前に違いがあるのは、
Debian アーカイブのメンテナはポリシーに従わないアーカイブに <tt>.deb</tt>
という名前を持つのを好まなかったからです。それゆえ、2つのフォーマットの違い
を目立たせ、本当のシステムに <tt>.udeb</tt> ファイルを無意識にインストール
しないように名前を変更しました。<tt>.udeb</tt> は本当に制限された Debian 
システムを作成するため、base システムをインストールする間に最初のラムディスク
上で使用されます。
</footnote>

<p>Debian バイナリパッケージフォーマットの内部仕様は 
<manref name="deb" section="5"> マニュアルページに解説されています。
このフォーマットは (&debian; のメジャーリリースの間で) 変更されることが
あるので、<tt>.deb</tt> ファイルを操作する時は必ず 
<manref name="dpkg-deb" section="8"> を使って下さい。

<!-- 下の文書は Osamu により追加された。確信していませんが、正しいはず -->
<p>少なくても Sarge ディストリビューションを通じ、全ての Debian アーカイブ
ファイルは、<prgn>dpkg</prgn> コマンドが使えない場合であっても、
標準的な Unix コマンドである <prgn>ar</prgn> や <prgn>tar</prgn>
により操作できます。


<sect1 id="pkgname">Debian パッケージ名の命名規則
<!--
どうして Debian パッケージのファイル名はこんなに長いのですか?
-->
<p>Debian <!--binary-->パッケージのファイル名は次のような規則に従います。
<example>
<var>foo</var>_<var>バージョン番号</var>-<var>リビジョン番号</var>__<var>アーキテクチャ</var>.deb
</example>
ここで、通常 <var>foo</var> はパッケージ名であり、<var>var</var> は
上流のバージョン番号、<var>rev</var> は Debian でのリビジョン番号、
そして <var>arch</var> はターゲットのアーキテクチャです。
ファイルはもちろん簡単に改名できます。
次のコマンドを実行することにより、<var>filename</var> という名前の
ファイルに含まれているパッケージを調べることができます。
<example>dpkg --info <var>filename</var></example>

<p>Debian のリビジョン番号は Debian 開発者又はパッケージを構築した人
により指定されます。通常リビジョン番号の変更はパッケージングの観点から
変更が加えられたことを意味しています。

<sect1 id="conffile">ローカル設定の保存
<!--
Debian 制御ファイルとは何ですか?
-->
<p>ローカルの管理者により変更可能とされているファイルは <file>/etc/</file>
に保持されています。
&debian; ポリシーはローカルの設定可能なファイルへの全ての変更が
パッケージのアップグレードを通じて保持されるべきであることを指示しています。
<p>
ローカルの設定可能なファイルの標準のバージョンがパッケージ自身に
含まれている場合、そのファイルは "conffile" としてリストされます。
パッケージは管理者の許可無しで最後にインストールされたので、
パッケージ管理システムは管理者により変更された conffile を更新しません。
一方、conffile が管理者により変更されていないと、パッケージの他のファイル
と一緒に conffile もアップグレードされます。
これはほとんど常に好ましく、conffile への変更を最小限にすることは好都合です。
<p>パッケージに所属する conffile をリストするには、次のコマンドを実行します。
<example>
dpkg --status <var>package</var>
</example>
このリストの "Conffiles:" 行に conffile が表示されます。

<p>
conffile に関するより詳しい情報については、Debian ポリシーマニュアルの
"Configuration files" という章を読んでください。(<ref id="references"> 参照)

<sect1 id="maintscripts">Debian メンテナンススクリプト
<!--
Debian preinst, postinst, prerm, postrm スクリプトとは何ですか?
-->
<p><!--These files--> 
Debian メンテナンススクリプトはパッケージがインストールされる前か後で
自動的に実行される実行可能なスクリプトです。これらのファイルは 
<file>control</file> という名前のファイルと一緒に全て 
Debian アーカイブファイルの "制御 (control)" セクションの一部となっています。

<p>個々のファイルは以下の通りです。
<taglist>
<tag/preinst/
  <item>このスクリプトは、パッケージが Debian アーカイブ (<tt/.deb/) 
  ファイルからアンパックされる前に実行されます。パッケージがインストールか
   アップグレードし終わる ("postinst" スクリプトが正常に実行された後) 
  まで、多くの"preinst" スクリプトの中で、更新されるパッケージのために
  サービスが停止されるようになっています。

<tag/postinst/
  <item>このスクリプトの典型的な仕事は、Debian アーカイブファイル 
  (<tt/.deb/) からアンパックされたら、それに必要な設定をすべて完了させる
  ことです。
  "postinst" スクリプトのよくある動作として、ユーザに入力を求め、
  既定値を受け入れるなら後戻りしてこのパッケージを環境に沿うように
  再設定することを忘れないように警告を表示します。
  新しいパッケージがインストールされるかアップグレードされると、
  多くの "postinst" スクリプトはサービスを開始または再開するのに
  必要なコマンドをすべて実行します。

<tag/prerm/
  <item>このスクリプトは、典型的にはパッケージに関連したあらゆる
  デーモンを停止します。これはパッケージに関連したファイルを
  削除する前に実行されます。 

<tag/postrm/
  <item>このスクリプトは、典型的にはパッケージに関連したリンクや
  他のファイルを修整したりパッケージが作成したファイルを削除したりします。
  (<ref id="virtual"> も参照。)
</taglist>

<p>現在、制御ファイルは全て <file>/var/lib/dpkg/info/</file>
に置かれています。パッケージ <tt>foo</tt> に関係するファイルは "foo" で始まる
名前を持ち、"preinst" や "postinst" などの適当なファイル拡張子を持ちます。
このディレクトリにある <file>foo.list</file> というファイルは、
パッケージ <tt>foo</tt> によってインストールされたファイルがすべて
リストされています (これらのファイルの存在場所は <prgn>dpkg</prgn> が
内部に持っていることに注意して下さい。存在場所を頼りにしないほうが
いいでしょう)。

<sect1 id="priority">パッケージ優先度
<!--
Required/Important/Standard/Optional/Extra パッケー ジとはなんですか ?
-->
<p>それぞれの Debian パッケージには、パッケージ管理システムの助けとして、
ディストリビューション保守担当者が <strong>優先度</strong> を割りあてています。
優先度には以下のものがあります。

<list>
  <item><strong>Required (要求)</strong> パッケージはシステムを正しく
  動作させるために必要なパッケージです。
    <p>システムの欠陥を修復するのに必要なツールをすべて含みます。
    これらのパッケージを消去してはいけません。システムがすっかり破壊され、
   復旧 するために <prgn>dpkg</prgn> を使うことすら恐らくできなくなります。
   Required パッケージだけのシステムは恐らく使いものになりませんが、
   システム管理者が起動したり他のソフトウェアをインストールするだけの
   機能はあります。
 
  <item><strong>Important (重要)</strong> パッケージはどのような Unix 
  ライクなシステムにもあるべきパッケージです。

    <p>Required 以外のパッケージで、無いとシステムがうまく動かなかったり
    不便だったりするものにこの優先度がつけられています。これには Emacs や 
    X11、TeX 他の巨大なアプリケーションは含まれて<strong>いません</strong>。
    ここのパッケージは、素のインフラストラクチャを構成するだけです。

  <item><strong>Standard (標準)</strong> パッケージはどんな Linux システム
  にも標準的なパッケージで、手頃な小ささですが機能が限定されすぎていない
  キャラクタモードシステムを含んでいます。

    <p>これはユーザが何も指示しなかったらデフォルトでインストールされます。
    多くの巨大なアプリケーションは含まれませんが、Emacs はあります 
    (これはアプリケーションというよりも多くのプログラムのための
    インフラストラクチャの一部です) し、TeX と LaTeX の手頃なサブセットが 
    (X なしで稼動可能な部分なら) 含まれています。

  <item><strong>Optional (任意)</strong> パッケージにはそのパッケージが
  何なのかを知らなかったり、そのパッケージを使わなければならない特別な
  要求がなかったりしてもインストールしてかまわないパッケージが含まれています。

    <p>これには X11 や TeX 配布物全体、多くのアプリケーションが含まれています。

  <item><strong>Extra (付録)</strong> パッケージはより高い優先度を持つ
  パッケージと衝突するか、そのパッケージがどういうものか知っているか、
  あるいは "任意" というには相応しくない特殊な要求を持っているパッケージです。
</list>
<p>パッケージの説明にある "Priority: required", "Section: base" および
"Essential: yes" の違いについて注意してください。"Section: base" は
新しいシステムには他の全てをインストールする前にこのパッケージが
インストールされることを意味しています。"Section: base" なパッケージの
ほとんどは "Priority: required" または少なくても "Priority: important" 
であり、それらの多くは "Essential: yes" にタグづけられています。
"Essential: yes" はこのパッケージをシステムから削除するには、
<prgn>dpkg</prgn> のようなパッケージ管理システムに特別な強制オプションを
指示する必要があることを意味しています。例えば、
<package>libc6</package>、 <package>mawk</package> や
<package>makedev</package> は  "Priority: required" かつ  "Section: base"
ですが、"Essential: yes" ではありません。

<sect1 id="virtual">仮想パッケージ

<p>仮想パッケージとは、すべて同じ基本機能を提供するパッケージの集まりの
どれか一つに供される一般的な名前のことです。
例えば、 <prgn>tin</prgn> と <prgn>trn</prgn> プログラムはどちらも
ニュースリーダであり、それゆえ、動作するか利用するためにニュースリーダを
要求するプログラムの依存性を満たします。したがって、両プログラムは 
<package>news-reader</package> と呼ばれる "仮想パッケージ" を供給します。

<p>同様に、<prgn>exim</prgn> 、<prgn>exim4</prgn>、<prgn>sendmail</prgn>、
<prgn>postfix</prgn> のような多くのパッケージは
メール配送エージェント (mail transport agent) の機能を備えているために
仮想パッケージ <package>mail-transport-agent</package> を
提供すると言われます。これらのうちどれかがインストールされていれば、
mail transport agent がインストールされていることに依存する
プログラムはどれでもこの仮想パッケージが存在しているために
条件を満足しています。

<p>Debian はこのようなしくみを提供するので、同じ仮想パッケージを持つ
パッケージが 1つ以上システムにインストールされると、システム管理者は
優先パッケージを設定できます。関連するコマンドは 
<prgn>update-alternatives</prgn> で、 <ref id="alternatives"> で
さらに詳しく述べられています。

<sect1 id="depends">パッケージの依存性

<p>Debian パッケージングシステムは、あるパッケージが機能したり、うまく
働くようにインストールされるべき他のパッケージを要求するという事実を
表現するために使われる依存性に関する宣言を操作します。

<list>
  <item>A を使うために B が絶対インストールされなければならない場合、
  パッケージ A はパッケージ B に <strong>Depends</strong> すると表現します。
  いくつかの場合、A は B だけでなく、B の特別なバージョンに依存
  します。この場合、バージョンの依存性は、A がある指定したバージョン
  以降のバージョンの B に依存するという意味で、通常下限を表します。
  <item>ほとんどのユーザは B により供給される機能も持たない A を
  欲しいとは思わないとパッケージのメンテナが判断した場合、
  パッケージ A はパッケージ B を <strong>Recommends</strong> すると
  表現します。
  <item>A に関係し、A の機能を強化するファイルが B に含まれている場合、
  パッケージ A はパッケージ B を <strong>Suggusts</strong> すると表現します。
  同じ関係は、パッケージ B がパッケージ A を <strong>Enhances</strong>
  すると表現します。
  <item>B がシステムにインストールされていると A が適切に動作しない場合、
  パッケージ A はパッケージ B と <strong>Conflicts</strong> すると
  表現します。"Conflicts" ステータスはたびたび "Replaces" と置き換えられます。
  <item>B によりインストールされるファイルが A にあるファイルにより
  削除あるいは上書きされる場合、パッケージ A はパッケージ B を
  <strong>Replaces</strong> すると表現します。
  <item>B の全てのファイルと機能が A にも組み込まれている場合、
  パッケージ A はパッケージ B を <strong>Provides</strong> すると
  表現します。
</list>

<p>これらの用語の使用法についてのより詳しい情報は <em>Debian パッケージング
マニュアル</em> と <em>Debian ポリシーマニュアル</em> にあります。

<p><strong>Depends</strong> と指定されたパッケージ全てを単に取得しますが、
<strong>Recommends</strong> や <strong>Suggests</strong> と指定された
パッケージを全て無視する <prgn>apt-get</prgn> に比べ、<prgn>dselect</prgn> 
はより洗練した <strong>Recommends</strong> や <strong>Suggests</strong>
により指定されるパッケージ制御機能を有します。これらのプログラムは共に
現代的な形で APT をバックエンドとして使用します。

<sect1 id="pre-depends">"pre-depends" の意味
<p><prgn>dpkg</prgn> は、常に他のパッケージが依存しているパッケージを
先に設定します。しかしながら、<prgn>dpkg</prgn>
は通常ファイルを任意の順番で、依存性と関係なく解凍します。
(解凍とは、アーカイブファイルからのファイルの展開とそれらのファイルを
正しい場所に置くことから構成されます。)
しかしながら、もしパッケージが他のパッケージに <strong>Pre-Depends</strong>
している場合、Pre-Depends しているパッケージが解凍されていても、
その前に Pre-Depends されているパッケージの解凍と設定が行われます。

<footnote>
このメカニズムはパッケージを展開する <strong>順番</strong>が非常に重要
であった <tt>a.out</tt> フォーマットから ELF フォーマットへのシステムの
安全な更新をサポートするために供給されました。
</footnote>

この依存性の使用は最小限に保たれています。

<sect1 id="pkgstatus">パッケージステータス
<!--
パッケージ状態の unknown/install/remove/purge/hold とはどういう意味ですか?
-->
<p>パッケージステータスには "unknown", "install", "remove", "purge", "hold"
があります。
これらの "want" フラグは利用者がそのパッケージをどう扱いたいかを示しています。
利用者は <prgn>dselect</prgn> の "Select" セクションでのアクション や 
<prgn>dpkg</prgn> の直接起動によってこれを示すことができます。

<p>それぞれの意味は以下の通りです。
<list compact>
  <item><strong>unknown</strong>  - インストールするかどうかユーザが
  表明していないパッケージ
  <item><strong>install</strong>  - ユーザがインストールまたはアップグレード
  したいパッケージ
  <item><strong>remove</strong>   - 削除はしたいが、既存の設定ファイルは
  一つも削除したくないパッケージ
  <item><strong>purge</strong>    - 設定ファイルを含め、完全に削除してしまう
  パッケージ
  <item><strong>hold</strong>     - 処理はしない、つまりどのような状態
  であれ現在の状態で現在のバージョンを維持するパッケージ
</list>

<sect1 id="puttingonhold">更新からパッケージを hold する
<!--
どうしたらパッケージを hold にできますか?
進行中の /etc/apt/preferences に対応して大規模な書き直しを行った
-->
<p> パッケージを hold するには二つの方法があります。<prgn>dpkg</prgn>
 を使う方法と、Woody から始まった APT を使う方法です。

<p><prgn>dpkg</prgn> では、パッケージ選択の一覧を
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
で書き出すだけです。それから書き出されたファイル 
<file><var>selections.txt</var></file> を編集して hold したいパッケージの
行を変更します。例えば、
<example>
libc6                       install
</example>
を
<example>
libc6                       hold
</example>
にします。ファイルを保存して、
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
でdpkg データベースに再ロードしてください。又、hold したいパッケージ名
を知っている場合は、単に
<example>
echo libc6 hold | dpkg --set-selections
</example>
を実行するだけです。この手順は各パッケージファイルのインストール処理で
パッケージを hold します。

<p>同様の効果が <prgn>dselect</prgn> を通しても得られます。[S]elect 画面に
入って hold したいパッケージの現在の状態を確認し、「=」キー (もしくは「H」キー) を押下するだけです。変更は [S]elect 画面を終了するとすぐに反映します

<p>Woody ディストリビューションにおける APT システムは <tt>Pin-Priority</tt>
を用いてアーカイブ取得処理中にパッケージを hold する新しいもう一つの機構
を持ちます。  <url id="&apt-howto;"> 又は <package>&p-apt-howto;</package> 
パッケージのに、マニュアルページ  <manref name="apt_preferences" section="5">
をご覧ください。

<sect1 id="sourcepkgs">ソースパッケージ

<p>
ソースパッケージは <file>source</file> と呼ばれるディレクトリで
配布されています。手動でダウンロードできますし、
<example>
apt-get source <var>foo</var>
</example>
を使ってダウンロードもできます。
(このための APT の設定法については apt-get(8) マニュアルページを
参照してください。)
     apt-get source foo

を使って取得することもできます (このための APT の設定法については 
<manref name="apt-get" section="8"> を参照願います。)

<sect1 id="sourcebuild">ソースパッケージからバイナリパッケージを作る

<p>パッケージ <tt><var>foo</var></tt> をソースからコンパイルするには、
<file><var>foo_*</var>.dsc</file>, <file><var>foo_*</var>.tar.gz</file> 
および <file><var>foo_*.diff</var>.gz</file> の全てが必要となります
(注意:Debian 固有のパッケージに は <tt>.diff.gz</tt> はありません)。

<p>これらを入手し、<package/dpkg-dev/ パッケージをインストールしている場合、
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
というコマンドを実行すれば <tt><var>foo-version</var></tt> というディレクトリ
にパッケージが取り出されます。

<p>バイナリパッケージをコンパイルしたいならば、
<example>
$ cd foo-version
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
を実行し、
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
で新たに構築したパッケージをインストールします。
<ref id="port"> をご覧ください。

<!-- Woody にはより簡単なコマンドと build-depends があります -->

<sect1 id="creatingdebs">新しい Debian パッケージを作る

<p>新しいパッケージを作ることに関する詳細な情報は、
<package/maint-guide/ パッケージで得られる <em>Debian メンテナ入門</em> 
 又は <url id="&maint-guide;" name="&urlname;"> をご覧ください。
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Debian システムのアップグレード

<p>Debian の目標の一つは首尾一貫したアップグレード方針と安全な
アップグレード手順を提供することです。パッケージングシステムは
管理者に重要な変更について警告し、時々は管理者に決定を促します。
リリースノートも読むべきです。これは全ての Debian CD と一緒に
出荷されており、WWW でも <url id="&stable-release;"> や 
<url id="&testing-release;"> で利用可能です。

<p>
アップグレードを行う実際的なガイドは <ref id="package"> で供給されます。
本章では単に概要を供給します。まずはパッケージングツールから始めます。

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>これはパッケージファイルの操作のための主要なプログラムです。
完全な説明は <manref name="dpkg" section="8"> を読んでください。
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> にはいくつかの原始的な補助プログラムが付随します。

<list>
<item><prgn>dpkg-deb</prgn>: <tt>.deb</tt> ファイルを操作します。
 <manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>: 旧型のパッケージファイル取得コマンドです。
 <manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>: 旧型のパッケージファイル取得用コマンドです。
 <manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>: 大規模なパッケージを小さなファイルに分割します。
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> と <prgn>dpkg-mountable</prgn> は APT システムに
取って代わられました。

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT (the Advanced Packaging Tool) は Debian パッケージングシステムの先進的なインターフェースであり、"apt-" で始まる名前を持ついくつかのプログラムから
構成されています。
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn>, と <prgn>apt-cdrom</prgn> 
はパッケージ操作用のコマンドラインツールです。これらには <prgn/dselect/ や
<prgn/aptitude/ のような他のツールへのユーザ "バックエンド" としても働きます。

<p>
より詳しい情報は、<package/apt/ パッケージをインストールし、
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">,
<manref name="apt_preferences" section="5"> (Woody), そして
<file>/usr/share/doc/apt/guide.html/index.html</file> を読んでください。

<p>もう一つの情報源としては、
<url id="&apt-howto;" name="APT HOWTO"> があります。
<file>&f-apt-howto;</file> の <package/apt-howto/ によりインストールできます。

<p><tt>apt-get upgrade</tt> と <tt>apt-get dist-upgrade</tt>
は "Depends:" にリストされたパッケージのみを引っ張ってきますが、
"Recommends:" や "Suggests:" にリストされたパッケージは無視します。
これを避けるには、<prgn>dselect</prgn> を御使用ください。

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>このプログラムは Debian パッケージ管理システムへのメニュドリブンな
ユーザインターフェースです。最初のインストール時や大規模なアップグレード時
に特に役立ちます。<ref id="dselect"> をご覧ください。

<p>より詳しい情報は、<package/install-doc/ パッケージをインストールし、
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> や
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">
を読んでください。

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">パッケージをアップグレードするのに
シングルユーザモードに入る必要はありますか?

<p>いいえ。システムが起動中でもパッケージをその場でアップグレードできます。
Debian にはパッケージのアップグレード中に必要な場合は起動中のプロセスの
停止と再開のために呼び出される <prgn>start-stop-daemon</prgn> があります。
-->

<sect1 id="updaterunning">起動中のシステムをアップグレードする

<p>&debian; システムにおける kernel (ファイルシステム) はファイルを使用中
でさえも、そのファイルの置き換えをサポートしてます。
現在のランレベルで起動されるようにパッケージが設定されている場合、
パッケージの更新時にパッケージにより供給されるサービスが再起動
されます。
Debian システムは起動中のシステムをアップグレードするのに
シングルユーザモードを必要としません。

<sect1 id="savedebs"><tt>.deb</tt> アーカイブファイルのダウンロードとキャッシュ

<p>手動でパッケージファイルをディスクにダウンロードした場合、
(これは必ずしも必要ではありません。上に記述した <prgn>dpkg-ftp</prgn> 
または APT の説明をご覧ください) パッケージをインストールした後、
システムから <tt>.deb</tt> ファイルを削除できます。

<p>APT を使っている場合、これらのファイルは 
<file>/var/cache/apt/archives</file> ディレクトリにキャッシュされます。
これらをインストール後に削除 (<tt>apt-get clean</tt>) できますし、
その後のインストール中のダウンロード時間を節約するため、
他のマシーンの <file>/var/cache/apt/archives</file> ディレクトリにコピー
してもかまいません。

<sect1 id="keepingalog">アップグレードの記録を取る

<p><prgn/dpkg/ は展開、設定、削除またはパージされたパッケージの記録を取ります
が、 (現在) パッケージにそのような操作が行われている間に起こったターミナル上の
コマンドログを取っていません。

<p>コマンドログを取る最もシンプルな方法は、<prgn>dpkg</prgn>,
<prgn>dselect</prgn>, <prgn>apt-get</prgn> などのセッションを 
<manref name="script" section="1">プログラム内で起動することです。

<sect id="boot">Debian ブートプロセス

<sect1 id="init"><prgn>init</prgn> プログラム

<p>他の Unix ライク OS と同様に、Debian は <prgn>init</prgn> プログラムを
実行することによりブートを始めます。<prgn>init</prgn> 用の設定ファイル
(<file>/etc/inittab</file>) は、実行されるべき最初のスクリプトが
<file>/etc/init.d/rcS</file> であることを指定しています。
<p>
次に起きることは <package>sysv-rc</package> 又は <package>file-rc</package> 
のどちらかがインストールされているかどうかに依存しています。
次に述べることは <package>sysv-rc</package> がインストールされていることを
仮定しています。(<package>file-rc</package> には固有の
<file>/etc/init.d/rcS</file> スクリプトが含まれており、ランレベル毎に
起動されるサービスの種類を制御するために rc ディレクトリにある
シンボリックリンクの代わりにこのスクリプトが用いられます。)
<p>
<package>sysv-rc</package> パッケージにある <file>/etc/init.d/rcS</file>
ファイルはファイルシステムのチェックやマウント、モジュールの読み込み、
ネットワークサービスの開始、時計の設定などの初期化作業を行うために
<file>/etc/rcS.d/</file> にあるスクリプト全てを起動します。
そして、互換性のために、<file>/etc/rc.boot/</file> 下にあるファイル 
(ファイル名に  `.' が付くファイルを除く) も実行します。
後者のディレクトリ内のスクリプトは、通常システム管理者が使用するために
予約されており、パッケージがこのディレクトリにスクリプトを置くのは
時代遅れです。詳細は Debian ポリシーマニュアルの <ref id="init-hints"> や 
<url id="&sysvinit;" name="System run levels and init.d scripts"> 
をご覧ください。

<sect1 id="runlevels">ランレベル

<p>ブートプロセス完了後、<prgn>init</prgn> は (<file>/etc/inittab</file> の 
<tt>id</tt> 用のエントリにより与えられる) 標準のランレベルで
起動されるように設定された全てのサービスを起動します。
標準のランレベルは <file>/etc/inittab</file> 中の <tt>id</tt> エントリ
により与えられます。
Debian は <tt>id=2</tt> となっています。
<p>
Debian は次のランレベルを使用しています。
<list compact>
  <item>1 (シングルユーザモード),
  <item>2 から 5 (さまざまなマルチユーザモード),
  <item>0 (システムを停止), そして
  <item>6 (システムをリブート)。
</list>
ランレベル 7, 8, 9 も使用可能ですが、パッケージがインストールされる時に
これらの rc ディレクトリにはあまり起動スクリプトがリンクされません。
<p>
ランレベルを切替えるには <prgn>telinit</prgn> コマンドを用います。
<p> 
あるランレベルに入ると、<file>/etc/rc<var>runlevel</var>.d/</file>
にある全てのスクリプトが実行されます。
スクリプトの最初の 1文字はスクリプトの起動<strong>方法</strong>
を決定します。
<tt>K</tt> で始まる名前のスクリプトは、引数 <tt>stop</tt> を取って
起動されます。
<tt>S</tt> で始まる名前のスクリプトは、引数 <tt>start</tt> を取って
起動されます。
これらのスクリプトは名前のアルファベット順で起動されます。それゆえ、
"stop" スクリプトは "start" スクリプトより前に起動され、
<tt>K</tt> や <tt>S</tt> に続く 2桁の数字はスクリプトの起動順序
を決定します。
<p>
実は、<file>/etc/rc<var>runlevel</var>.d/</file> ディレクトリにある
スクリプトは、<file>/etc/init.d/</file> にあるスクリプトの
単なるシンボリックリンクです。
これらのスクリプトは引数として "restart" や "force-reload" という
引数も受け取ります。システムのブート後にサービスを再起動
するためや、設定ファイルを再読み込みさせるためにこれらの引数を使えます。

<p>例えば、
<example>
# /etc/init.d/sendmail reload
</example>
のように使います。

<sect1 id="custombootscripts">ランレベルのカスタマイズ
<p>
ランレベルをカスタマイズするのは一歩進んだシステム管理者の仕事です。
ほとんどのサービスの場合、次に示すアドバイスが適用できます。
<p>
ランレベル <var>R</var> でサービス <var>service</var> を有効にするには、
ターゲットを <file>../init.d/<var>service</var></file> として
シンボリックリンク 
<file>/etc/rc<var>R</var>.d/S<var>xy</var><var>service</var></file>
を作成します。
シーケンス番号 <var>xy</var> はパッケージがインストールされた時の
サービスに割り当てられたシーケンス番号と一致させてください。
<p>
サービスを無効にするには、名前が <tt>S</tt> で始まるのではなく 
<tt>K</tt> で始まるようにシンボリックリンクをリネームし、
シーケンス番号を 100-<var>xy</var> にします。
<p>
これらの目的には <prgn>sysv-rc-conf</prgn> や <prgn>ksysv</prgn>
のようなランレベルエディタを使うのが便利です。
<p>
特定のランレベルディレクトリにあるサービスのシンボリックリンクを
リネームするのではなく削除することも可能です。
これはサービスを無効にしますが、<package>sysv-rc</package> の
初期化システムに関する限りに "floating" な状態に保ちます。
ランレベルを変更すると、サービスは起動されませんし、
停止もされませんが、起動しているかそうでないかにかかわらずそのままに
保たれます。
しかしながら、そのような浮いた状態にされたサービスは、
サービスを提供するパッケージがアップグレードされた場合、
アップグレード前に起動されているかにかかわらず起動されてしまうことに
注意してください。
これは現在の Debian システムの欠点として良く知られています。
又、ランレベル 0 と 6 では <tt>K</tt> で始まるサービスのシンボリックリンク
を保持すべきであることに注意してください。
このサービスに対するシンボリックリンクを全て削除してしまうと、
アップグレードの際、出荷時の標準の状態にサービスを提供するパッケージが
シンボリックリンクを回復させてしまいます。
<p>
<file>/etc/rcS.d/</file> にあるシンボリックリンクにあらゆる変更を加える
ことは推奨<strong>できません</strong>。

<sect id="diverse">多様性のサポート
<p>
Debian はシステムを壊さずにシステム管理者の希望を満たすためのいくつかの手段
を提供します。
<list>
<item><prgn>dpkg-divert</prgn>, <ref id="dpkg-divert"> 参照。
<item><prgn>equivs</prgn>, <ref id="equivs"> 参照。
<item><prgn>update-alternative</prgn>, <ref id="alternatives"> 参照。
<item><prgn>make-kpkg</prgn> は多くのブートローダに対応します。
<manref name="make-kpkg" section="1"> および <ref id="kernel-debian"> 参照。
</list>
<file>/usr/local/</file> 以下のファイルはシステム管理者のものであり、
&debian; は一切触りません。 <file>/etc</file> 以下のほとんどの
ファイルは <tt>conffiles</tt> であり、
<!-- mtab を除く -->
&debian; はシステム管理者が明示的に要求しない限りアップグレード時に
上書きしません。



<sect id="i18n">国際化
<p>
&debian; システムは国際化されており、コンソール上ならびに X 上で
多種の言語の文字を表示し、入力するためのサポートを供給します。
たくさんのドキュメント、マニュアルページ、そしてシステムメッセージが
翻訳されており、翻訳されている言語は増加し続けています。インストール中、
Debian はユーザにインストール言語 (そして時々はローカル言語変数 )の選択を
促します。
<p>
あなたが必要な言語の機能全てをインストールしたシステムがサポート
していない場合、又はあなたの言語をサポートするために言語の変更や、
異なるキーボードのインストールが必要な場合、<ref id="l10n"> をご覧ください。

<sect id="kernel-details">Debian と kernel
<p>
<ref id="kernel"> をご覧ください。

<sect1 id="non-debian-kernel">非 Debian なソースから kernel をコンパイルする

<p><!--Yes.  But you have-->
header に関する Debian ポリシーを理解する必要があります。

<p>Debian C ライブラリは <strong>kernel</strong> header の最新の 
<strong>stable</strong> リリースを用いて構築されています。

<p>例えば、Debian-1.2 リリースは version 5.4.13 のヘッダを用いていました。
この慣習は全ての Linux FTP アーカイブサイトにおいて配布される Linux kernel
ソースパッケージに対照しており、Linux kernel ソースパッケージはより最新
の header を使ってさえいます。kernel source により配布される kernel header
は <file>/usr/include/linux/include/</file> にあります。

<p><package/libc6-dev/ により供給されるものより新しい kernel header を用いて
プログラムをコンパイルする必要がある場合には、コンパイル時、コマンドラインに
<tt>-I/usr/src/linux/include/</tt> を付け加える必要があります。
これは、例えば automounter daemon (<package/amd/) のパッケージングをする
場合に使われます。新しい kernel が NFS を扱うための内部処理を変更した場合、
<prgn>amd</prgn> はそれを知る必要があるため、最新の kernel header を
含める必要性が発生します。

<sect1 id="customkernel">カスタム kernel 構築ツール
<p>カスタム kernel を構築したい (する必要がある) 人は <package/kernel-package/
パッケージのダウンロードが推奨されます。本パッケージには kernel パッケージ
の構築用スクリプトが含まれ、次のようなコマンドを kernel ソースディレクトリの
最上段で実行するだけで Debian kernel-image パッケージを構築する機能を
供給します。
<example>
# make-kpkg kernel_image
</example>
ヘルプは次のコマンドを実行すると得られます。
<example>
# make-kpkg --help
</example>
また、マニュアルページ  <manref name="make-kpkg" section="8"> 全体と
<ref id="kernel"> も参照願います。

<p>kernel-source-<var>version</var> (<var>version</var> は kernel バージョンを
表す) パッケージが得られない場合、好みの Linux アーカイブサイトから最新の
kernel (又は選んだ kernel) のソースコードを別途ダウンロードする必要があります。
Debian の <file>initrd</file> ブートスクリプトは <prgn>initrd</prgn> と呼ばれる
特別な kernel patch を要求します。<url id="&bug-initrd;"> をご覧ください。

<p><package/kernel-package/ パッケージの詳細な使用方法は
<file>/usr/share/doc/kernel-package/README.gz</file> にあります。

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">代替ブートローダ
<p><package/grub/ や <package/loadlin/ のような代替ブートローダを使いたい場合、
コンパイルした Linux kernel <file>bzimage</file> を他の場所 
(例えば、<file>/boot/grub</file> や MS-DOS パーティション) にコピーしましょう。
</sect1>

<sect1 id="custombootdisk">カスタムブートフロッピ

<p>カスタムブートフロッピを作成する作業は、Potato 以前の Debian FTP 
アーカイブの <tt>admin</tt> セクションにある Debian パッケージ 
<package/boot-floppies/ により、大きな手助けが得られます。
 <!-- FIXME: boot-floppies is no package in Woody but an installation
program
 Is this Potato specific? -->
本パッケージにあるシェルスクリプトはブートフロッピを
<prgn>syslinux</prgn> フォーマットで作成します。これらは MS-DOS フォーマット
され、直接 Linux (又は<file>syslinux.cfg</file> で定義された他のオペレーション
システム) をブートするようにマスターブートレコードが変更されたフロッピです。
本パッケージの他のスクリプトは緊急 root ディスクを作成し、base ディスクの
再製作さえできます。

<p>詳細は <package/boot-floppies/ パッケージをインストールした後、
<file>/usr/doc/boot-floppies/README</file> ファイルをご覧ください。

<sect1 id="modules">モジュールを扱うための特別な準備

<p>Debian の <package/modconf/ パッケージはモジュールの設定をカスタマイズする
ために使用できるシェルスクリプト (<file>/usr/sbin/modconf</file>) を供給
します。このスクリプトはメニュベースのインターフェースを表示し、システムの
ローダブルデバイスドライバに関する詳細に対してユーザを促します。
その応答は <file>/etc/modules.conf</file> や <file>/etc/modules</file> 
をカスタマイズするのに使用されます (これらにはブート時にロードされる
モジュールがリストされています)。

<p>カスタム kernel の構築をサポートするために得られる (新しい) 
<file>Configure.help</file> ファイルと同様に、<package/modconf/ パッケージには
モジュールそれぞれに対して適切な引数についての詳細な情報を供給する 
(<file>/usr/share/modconf/</file> にある) ヘルプファイルが付属します。
用例は <ref id="kernel-modules"> をご覧ください。

<sect1 id="removeoldkernel">古い kernel パッケージを削除する

<p><prgn>kernel-image-<var>NNN</var>.prerm</prgn> スクリプトは現在起動している
 kernel が削除しようとしている kernel と同じかどうかチェックします。それゆえ、
使わない kernel image パッケージを安全に次のコマンドを用いて削除できます。

<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(もちろん、<var>NNN</var> を削除したい kernel のバージョンとリビジョンに
置き換えます。)
</sect>
