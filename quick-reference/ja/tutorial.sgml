<!-- CVS revision of this document "$Revision: 1.1 $"  -->
<!-- CVS revision of original english document "1.79"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="tutorial">&debian; チュートリアル
<p>
<!-- new content -->
本章は 本当の初心者に &debian; ワールドへの基本的なオリエンテーションを供給
します。しばらく Unix ライクなシステムを使っていたならば、ここで説明する
ことは多分ほとんど知っているでしょう。常識の確認としてこれを使ってください。

<sect id="first">始め方
<p>
<!-- new content -->
PC に &debian; システムをインストールした後、有用ないくつかのことを
学ぶ必要があります。素早い説明をします。

<sect1 id="login-root">root としてシェルにログインする
<p>
<!-- new content -->
システムのリブート後、パッケージの最初の選択により、グラフィカルな
ログインスクリーン又は文字ベースのログインスクリーンが表れます。
単純化のため、グラフィカルなログインスクリーンが表れた場合、
キャラクタベースのログインスクリーンを表示させるために
Ctrl-Alt-F1 を押してください。
<footnote>
左側の Ctrl キー、左側の Alt キー、そして F1 キーを同時に押すことです。
</footnote>
<p>
あなたのホスト名が <tt><var>foo</var></tt> と仮定すると、ログインプロンプトは
次のようになります:
<example>
<var>foo</var> login:
</example>
<tt>root</tt> とタイプし、Enter キーを押してインストール手順の間に
選んだパスワードをタイプしてください。&debian; システムでは、
Unix の伝統に従い、パスワードは大文字と小文字が区別されます。
ログインに成功すると、システムは歓迎メッセージを表示し、root コマンド
プロンプトを表示してあなたの入力を待ちます。

<footnote>
<file>/etc/motd</file> にある歓迎メッセージを編集した場合、メッセージは
異なることに注意。
</footnote>
<example>
<var>foo</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
あなたは既にこの root コマンドプロンプトからシステム管理を行う準備が
できています。この root アカウントは、スーパーユーザや特権ユーザとも
呼ばれています。このアカウントからは、次のようなことができます:

<list compact>
<item>ファイルパーミッションに依らずあらゆるファイルの読み書き削除
<item>システム上のあらゆるファイルのファイル所有者やパーミッションの設定
<item>システム上の非特権ユーザのパスワードの設定
<item>パスワード無しでの全アカウントへのログイン
</list>
<p>パスワードを共有することにより root アカウントへのアクセスを
共有することは非常にまずい考えです。<manref name="sudo "section="8"> 
のようなプログラムを使って管理者権限を共有するのが良い考えです。
<p>
管理行動を行おうとする場合でも、まず自分の非特権者アカウントでログイン
するのは、良い Unix 的習慣であると考えられていることに注意してください。
必要な際に制限された root 権限を得るために、<tt>sudo</tt>、 
<tt>super</tt> や <tt>su -c</tt> コマンドを使いましょう。
<ref id="sudo"> をご覧ください。
<footnote>
簡単でだらしがないだけの理由で必要以上にスーパーユーザアカウントを
使っていたことを認めなくてはなりません。
</footnote>

<sect1 id="newbiefix">最小限の初心者用環境をセットアップ
<p>
<!-- new content -->
コンピュータシステムを学ぶことは新しい外国語を学ぶことに似ていると
考えます。チュートリアルブックは有用ですが、ヘルパーツールを用いて
実際に学ぶことが必要です。こういう背景から、<package>mc</package>、
<package>vim</package>、 <package>lynx</package>, 
<package>doc-linux-text</package> そして 
<package>debian-policy</package> のようないくつかの追加パッケージを
インストールするのは良い考えです。
<footnote>
<package>gpm</package>、<package>emacs21</package> や
<package>doc-linux-html</package>. をインストールするのも良い考え
かもしれません。<ref id="gpm"> や <ref id="edit"> 参照。
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
</example>
これらのパッケージを既にインストールしている場合、何もインストール
しなくても良いです。

<sect1 id="newuser">ユーザアカウントを追加
<p>
<!-- new content -->
インストール中に、通常 root アカウントへのメールを受け取る非特権ユーザ
アカウントを作成します。
<footnote>
私はインストール中に作成されるアカウントを <tt>admin</tt> といつもしますが、
任意の名前でかまいません。
</footnote>
この特別なユーザアカウントを以降の訓練用にも使いたくないならば、
他の新ユーザアカウントを作成すべきです。
<p>
新しいユーザ名を <tt><var>penguin</var></tt> と仮定すると、次のように
タイプするとアカウントが作成されます。
<example>
root@<var>foo</var>:root# adduser <var>penguin</var>
... 質問全てに答える
</example>
<footnote>
この <tt><var>penguin</var></tt> ユーザを <tt>adm</tt> グループに追加
して <file>/var/log/</file> にある多くのログファイルを読めるようにしたい
かもしれません。
<manref name="passwd" section="5">、 <manref name="group" section="5">、
<manref name="shadow" section="5">, <manref name="group" section="5">、
<manref name="vipw" section="8">、そして <manref name="vigr" section="8">
をご覧ください。
ユーザやグループの公式な意味は、 <url id="&f-users-and-groups;"
name="Users and Groups"> 文書の最近のバージョンをご覧ください。
</footnote>
先に進む前に、いくつかのことをまず学びましょう。

<sect1 id="sw-console">仮想コンソールを切替える
<p>
<!-- modified old content -->
&debian; システムには、6個の独立した仮想端末が使えます。すなわち、
PC の VGA キャラクタコンソールスクリーンを6個の切替え可能な VT100
端末として使えるということです。スクリーンの切替えは左側の Alt キー
と F1&ndash;F6 キーを同時に押すことにより行えます。仮想ターミナル
それぞれに独立したアカウントでログインすることができます。
マルチユーザ環境は偉大な Unix の機能であり、中毒性が非常にあります。
<p>
<!-- new content -->
X Window System を起動中のシステムにおいて Alt-F7 を間違ってタイプし、
コンソールスクリーンがグラフィカルなスクリーンを表示していた場合、
Ctrl-Alt-F1 を押すことによりキャラクタコンソールへのアクセスを回復します。
この現象に慣れるため、違うコンソールに移動して元に戻ってみてください。

<sect1 id="shutdown">シャットダウンのやりかた
<p>
<!-- heavily modified content -->
ファイル操作がメモリへのキャッシュにかかわる他の現代的な OS と同様に、
&debian; システムは電源を OFF にする前にファイルの完全性を維持するため、
適切なシャットダウン手順を取る必要があります。
システムをシャットダウンするためには、 root コマンドプロンプトから
次に示すコマンドを実行してください:
<example>
# shutdown -h now
</example>
これは通常のマルチユーザモード用です。シングルユーザモードの場合は、
root コマンドプロンプトから次のコマンドを実行してください:
<example>
# poweroff -i -f
</example>
これの代わりに、Ctrl-Alt-Delete を押してシャットダウンできるかもしれません。
<footnote>
コンソールから左 Ctrl キー、左 Alt キーと Delete キーを同時に押します。
標準のシステムでは、これはシステムをリブートさせます。<ref id="post-inst">
に記述しているように、<prgn>shutdown</prgn> コマンドのオプションが
<tt>-h</tt> となるように <file>/etc/inittab</file> を修正する必要が
あります。
</footnote>
<p>
システムが "System halted" と表示するまで待ち、そして電源を OFF に
しましょう。BIOS と Linux により APM 又は ACPI の機能が有効化された場合、
システムはなにもせずに電源を OFF にします。詳細は <ref id="apm"> を
ご覧ください。

<sect1 id="playtime">プレイ時間
<p>
<!-- new content -->
ついに &debian; システムを非特権ユーザアカウント <tt><var>penguin</var></tt>
を使ってできるだけリスクを負わずに楽しむ準備ができました。
<footnote>
これは &debian; システムでは、標準のインストール直後でさえも、
非特権ユーザがシステムに損害を与えるのを防ぐように適切なファイル許可を
設定されているからです。もちろん、まだ利用される可能性のある穴がいくつか
残っているかもしれませんが、この問題を心配している人は本書ではなく、
<url id="&securing-debian-howto;" name="Securing Debian Manual"> 
を読むべきです。
</footnote>
<p>
<tt><var>penguin</var></tt> にログインしましょう。まだ root シェルプロンプト
にいるなら、Ctrl-D をタイプしましょう。
<footnote>
左 Ctrl キーと d キーを同時に押すこと。これらのコントロールキーが
"control D" のように大文字で書かれていても、Shift キーを押す必要は
ありません。
</footnote>
こうして root シェルでの行動を止めるために root コマンドプロンプトから
出て、ログインプロンプトに戻ります。新しく作ったユーザ名
<tt><var>penguin</var></tt> と対応したパスワードを入力しましょう。
<footnote>
ここで <tt><var>penguin</var></tt> の代わりに <tt>root</tt>
と対応したパスワードを入力すると、<tt>root</tt> アカウントに
ログインします。この手順は <tt>root</tt> アカウントへのアクセスを
回復するために必要です。
</footnote>
するとこのようなコマンドプロンプトが表示されるでしょう。
<example>
<var>penguin</var>@<var>foo</var>:<var>penguin</var>$ 
</example>
<p>
ここから、単純化のために、シンプルにしたコマンドプロンプトの例を下に挙げます:
<list compact>
<item><tt>#</tt> : root シェルプロンプト
<item><tt>$</tt> : 非特権ユーザシェルプロンプト
</list>
<p>
まず簡単な方法 <ref id="mc"> を使って &debian; システムを学び、後で
適切な方法 (<ref id="unixlike">) を用いて学ぶことにします。

<sect id="mc">Midnight Commander (MC)
<p>
<!-- old content -->
Midnight Commander (MC) は Linux コンソールや他の端末環境のためのGNU 製
"スイス軍ナイフ" です。初心者にメニュドリブンなコンソール経験を与え、
標準的な Unix コマンドを習うよりもより簡単です。
<!-- New content -->
<p>
&debian; システムを探検するためにこのコマンドを使いましょう。これは
学習するための最良の方法です。カーソルキーとエンターキーを使うだけで
いくつかの主要な場所を探検してください。
<list compact>
<item><file>/etc</file> とサブディレクトリ。
<item><file>/var/log</file> とサブディレクトリ。
<item><file>/usr/share/doc</file> とサブディレクトリ。
<item><file>/sbin</file> と <file>/bin</file>
</list>

<sect1 id="mc-enhance">強化型 MC
<p>
<!-- modified old content -->
終了時に作業ディレクトリを MC に変更させるためには、<file>~/.bashrc</file>
(又は <file>.bashrc</file> から呼ばれる <file>/etc/bash.bashrc</file>)
をマニュアルページ <manref name="mc" section="1">の中の
<tt>-P</tt> オプションの所に記述されているように修正する必要があります。
<footnote>
たとえここで説明したことを正確に理解できなくともこの作業は後でできます。
</footnote>

<sect1 id="mc-start">MC の開始
<p>
<!-- modified old content -->
<example>
$ mc
</example>
MC はメニュを通じて、最小限のユーザの苦労しか要求せずに全てのファイル操作を
注意深く行います。ヘルプ表示を出すには、ただ F1 を押すだけす。
カーソルキーとファンクションキーの操作だけで MC を楽しめます。
<footnote>
日本人用の <prgn>kon</prgn> や <prgn>kterm</prgn> のような端末上の場合は、
特定のグラフィック文字に関する問題が発生します。MC のコマンドライン
オプションに <tt>-a</tt> を追加すると、問題を防止できるかもしれません。
</footnote>

<sect1 id="mc-fm">MC でのファイル操作
<p>
<!-- old content -->
MC の標準ではファイルリストを含む二つのディレクトリパネルがあります。
他の役立つモードとして、右側のウィンドウにファイル権限情報などを表示する
"information" をセットするモードがあります。
次にいくつかの不可欠なキーストロークを示します。<prgn>gpm</prgn> デーモン
を起動させると、マウスも使えます。(MC でのカットアンドペーストの通常の
挙動を回復するためには、shift キーを押してください。)
<list compact>
<item>F1: ヘルプメニュ
<item>F3: 内部ファイルビューア
<item>F4: 内部エディタ
<item>F9: プルダウンメニュを有効にする
<item>F10: Midnight Commander を終了する
<item>Tab: 二つのウィンドウの間を移動する
<item>Insert: コピーのような複数のファイル操作のため、ファイルにマークする
<item>Del: ファイルの削除 (気をつけて &mdash; MC を安全削除モードに設定)
<item>カーソルキー: 自明な動きをします
</list>

<sect1 id="mc-cl">MC のコマンドライントリック
<p>
<!-- old content -->
<list compact>
<item><prgn>cd</prgn> コマンドは選択されたスクリーンに表示された
ディレクトリを変更します。
<item>Ctrl-Enter 又は Alt-Enter はファイル名をコマンドラインにコピー
します。コマンドライン編集と一緒に <prgn>cp</prgn> や <prgn>mv</prgn> 
コマンドで御使用ください。
<item>Alt-Tab はシェルファイル名の拡張子の選択肢を表示します。
<item>MC への引数として、両ウィンドウが開くディレクトリの指定ができます。
例えば、<tt>mc /etc/ /root</tt> などです。
<item>Esc + <var>numberkey</var> == F<var>n</var> (すなわち、
      Esc + `1' = F1,同様に;
      Esc + `0' = F10)
<item>Esc キー       == Alt キー (= Meta,
      M-); すなわち、 Esc + `c' は Alt-C と同じです。
<!-- control characters are referred with the upper case. -->
</list>

<sect1 id="mcedit">MC 内のエディタ
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
MC の内部エディタは興味深いカットアンドペースト機構を持ちます。
F3 キーを押すと、選択範囲の開始としてマークし、次に F3 を押すと、
選択範囲の終了としてマークし、選択範囲を強調します。そして
カーソルを動かすことができます。F6 を押すと、選択範囲はカーソルの位置
に移動します。F5 を押すと、選択範囲はコピーされ、カーソルの位置に
挿入されます。F2 を押すとファイルをセーブします。F10 を押すと選択範囲
はなくなります。ほとんどのカーソルキーは直感的に働きます。
<p>
このエディタはファイル上で直接起動できます:
<example>
$ mc -e filename_to_edit
$ mcedit filename_to_edit
</example>
<p>
これはマルチモードエディタではありませんが、同じ効果を発揮させるため、
複数の Linux コンソール上で使用できます。ウィンドウ間のコピーを行うには、
Alt-F<var>n</var> キーを押して仮想コンソールを切替えて、ファイルの一部を
他のファイルに動かすために "File-&gt;Insert file" や "File-&gt;Copy to file"
を用います。
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I see .. but for now I do this not to hack LaTeX
-->
<p>
この内部エディタは他の外部エディタと置き換えが可能です。
<p>
また、多くのプログラムは使用するエディタを決定するために環境変数 
<tt>EDITOR</tt> や <tt>VISUAL</tt> を使用します。
<prgn>vim</prgn> が不快な場合、<file>~/.bashrc</file> に
次に示す行を追加してエディタを <tt>mcedit</tt> にセットします:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
可能ならばこれらを <tt>vim</tt> にセットすることをお薦めします。
<prgn>vim</prgn> コマンドに慣れることは正しいことです。なぜならば、
Vi エディタは常に Linux/Unix 世界に存在するからです。
<footnote>
実際には、<prgn>vi</prgn> や <prgn>nvi</prgn> のようなプログラムも
見つかります。私は初心者のためには <prgn>vim</prgn> を代わりに選択します。
vim は F1 キーを通したヘルプを提供し、同じ位十分かつより力強いからです。
</footnote>

<sect1 id="mc-view">MC 内のビューア
<p>
<!-- almost old content -->
非常に小さなビューアです。文書内の単語を検索するための素晴らしいツールです。
<file>/usr/share/doc</file> ディレクトリ内のファイルに対していつもこれを
使います。これは 大量の Linux 情報をブラウズするための最速の方法です。
このビューアはこのように直接起動できます:
<example>
$ mc -v filename_to_view
</example>

<sect1 id="ma-auto">MC の自動起動機能
<p>
<!-- almost old content, tar.gz and deb are new -->
ファイルの上で Enter を押すと、適切なプログラムがファイルの内容を操作
します。これは非常に便利な MC の機能です。
<example>
実行ファイル：コマンドを実行
man、 html ファイル:ビューアソフトに内容をパイプする
tar.gz、 deb ファイル:  サブディレクトリであるかのように内容を表示
</example>
これらのビューアや仮想ファイルの機能を有効にするため、閲覧可能なファイルには
実行権が設定されていなくてはなりません。<prgn>chmod</prgn> コマンドを使うか、
MC のファイルメニュ経由で状態を変更してください。

<sect1 id="mc-ftp">MC の FTP 仮想ファイルシステム
<p>
<!-- old content -->
MC は FTP を用いた Internet 越しのファイルアクセスに使えます。
F9 を押してメニュに行き、`p' を押して FTP 仮想ファイルシステムを有効に
します。<tt>username:passwd@hostname.domainname</tt> の形式で URL を
入力すると、それがローカルにあるかのようにリモートディレクトリを取得
します。
<p>
<!-- new content -->
<tt>&ftp-debian;</tt> を URL として試し、&debian; ファイルアーカイブの
閲覧をしてみてください。&debian; アーカイブがどのように構成されているか
については <ref id="ftparchives"> をご覧ください。

<sect id="unixlike">Unix ライクな作業環境
<p>
<!-- new content -->
mc はほとんど全てのことを可能にしますが、シェルプロンプトから
実行されるコマンドラインツールの使用方法について学び、
Unix ライクな作業環境に親しむのは非常に重要なことです。
<footnote>
チュートリアルの章では、シェルは <prgn>bash</prgn> を意味します。
他種のシェルの真実については、<ref id="shell"> 参照。
</footnote>

<sect1 id="sp-keys">特別なキーストローク
<p>
<!-- practically new content -->
Unix ライクな環境では、特別な意味を持ついくつかのキーストロークがあります。
<footnote>
通常の Linux キャラクタコンソールでは、左側の Ctrl と Alt キーを使う
ことを想定しています。
</footnote>
<list compact>
<item>Ctrl-U: カーソルの前の行を削除する。
<item>Ctrl-H: カーソルの前の文字を削除する。
<item>Ctrl-D: 入力を終了する。(シェルを使用中の場合、シェルを終了する)
<item>Ctrl-C: 起動中のプログラムを終了する。
<item>Ctrl-Z: 一時的にプログラムを停止する。(バックグラウンドジョブに入れる。
<ref id="cmd-back"> 参照)
<item>Ctrl-S: スクリーンへの出力を止める
<footnote>
<manref name="stty" section="1"> を使ってこれらのターミナル機能を無効
にできます。
</footnote>
<item>Ctrl-Q: スクリーンへの出力を再び有効にする。
</list>
<p>
標準のシェルである <prgn>bash</prgn> には対話的な利用を手助けする
履歴編集機能とタブ補完機能があります。
<list compact>
<item>右矢印:  コマンド履歴検索を開始。
<item>Ctrl-R:  インクリメンタルなコマンド履歴検索を開始。
<item>TAB: コマンドラインに入力ファイルを補完。
<item>Ctrl-V TAB: コマンドラインに拡張無しで TAB を入力。
</list>
<p>
覚えておく価値のある他の重要なキーストロークを挙げます:
<list compact>
<item>Ctrl-Alt-Del:  システムをリブート/停止する。<ref id="post-inst"> 参照。
<item>マウスを左クリックしながらドラッグする:選択領域をクリップボードにコピー。
<item>マウスの中ボタンを押す:カーソルの位置にクリップボードの中身をペースト。
<item>メタキー (Emacs の専門用語) は伝統的に左側 Alt キーに割り当てられている。
あるシステムでは Window キーがメタキーに設定されている。
</list>
ここで、Linux キャラクタコンソール上でマウスを使うためには、<prgn>gpm</prgn>
をデーモンとして起動する必要があります。
<footnote>
X Window 環境では、マウスは Xterm プログラムを用いると同様に機能します。
</footnote>
<ref id="gpm"> 参照。

<sect1 id="unixcmds">基本的な Unix コマンド
<p>
<!-- new content -->
基本的な Unix コマンドを学びましょう。
<footnote>
ここで "Unix" を純粋な意味で使用しています。Unix クローン OS は通常
等価なコマンドを提供します。&debian; システムも例外ではありません。
望んだようにコマンドが働かなくても心配しないでください。
これらの例はこの順序で実行されることを意味していません。
</footnote>
非特権ユーザアカウント <tt><var>penguin</var></tt> から次に挙げる
コマンドを全て試してみてください:
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>カレント/ワーキングディレクトリの名前を表示。
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>ユーザ名を表示。
 </list>
<item><tt>file <var>foo</var></tt>
 <list compact>
 <item>ファイル <var>foo</var> のファイル形式を表示。
 </list>
<item><tt>type -p <var>commandname</var></tt>
 <list compact>
 <item><tt><var>commandname</var></tt> コマンドの場所を表示。
 <item><tt>which <var>commandname</var></tt> も同じ。
 </list>
<item><tt>type <var>commandname</var></tt>
 <list compact>
 <item><tt><var>commandname</var></tt> コマンドに関する情報を表示。
 </list>
<item><tt>apropos <var>key-word</var></tt>
 <list compact>
 <item><tt><var>key-word</var></tt> に関するコマンドを検索。
 <item><tt>man -k <var>key-word</var></tt> も同様。
 </list>
<item><tt>whatis <var>commandname</var></tt>
 <list compact>
 <item><tt><var>commandname</var></tt> コマンドの一行説明を表示。
 </list>
<item><tt>man -a <var>commandname</var></tt>
 <list compact>
 <item><tt><var>commandname</var></tt> コマンドの説明を表示。
(Unix スタイル)
 </list>
<item><tt>info <var>commandname</var></tt>
 <list compact>
 <item><tt><var>commandname</var></tt> コマンドのかなり長い説明を表示。
(GNU スタイル)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>ディレクトリの内容を表示 (非ドットファイルおよびディレクトリを表示)
  <footnote>
Unix は伝統的に、"<tt>.</tt>" で始まるファイル名を隠します。これらは
伝統的に設定情報やユーザプリファレンスを含むファイルです。
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>ディレクトリの内容を表示。(全ファイルおよびディレクトリ)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>ディレクトリの内容を表示。(ほとんど全てのファイルとディレクトリを表示。
すなわり、"<file>/..</file> と "<file>.</file>" をのぞく。)
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>詳細な情報を含むディレクトリの全内容を表示。<ref id="file-system"> 
参照。
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>カレントディレクトリ下の全ディレクトリを表示。
 </list>
<item><tt>lsof <var>foo</var></tt>
 <list compact>
 <item>ファイル <tt><var>foo</var></tt> のオープンされている状況を表示。
 </list>
<item><tt>mkdir <var>foo</var></tt>
 <list compact>
 <item>カレントディレクトリに <tt><var>foo</var></tt> という新ディレクトリ
を作成。
 </list>
<item><tt>rmdir <var>foo</var></tt>
 <list compact>
 <item>カレントディレクトリにある <tt><var>foo</var></tt> ディレクトリを
削除。
 </list>
<item><tt>cd <var>foo</var></tt>
 <list compact>
 <item>カレントディレクトリ又は変数 <tt>CDPATH</tt> にリストされた
ディレクトリを <file><var>foo</var></file> ディレクトリに変更する。
<manref name="builtins" section="7"> の <prgn>cd</prgn> コマンドに関する
部分を参照。
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>root ディレクトリにディレクトリを変更。
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>カレントユーザのホームディレクトリにディレクトリを変更。
 </list>
<item><tt>cd /<var>foo</var></tt>
 <list compact>
 <item>ディレクトリを絶対パス指定でディレクトリ  <file>/<var>foo</var></file>
変更。
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>ディレクトリを親ディレクトリに変更。
 </list>
<item><tt>cd ~<var>foo</var></tt>
 <list compact>
 <item>ディレクトリをユーザ <tt><var>foo</var></tt> のホームディレクトリ
に変更。
  <tt><var>foo</var></tt>.
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>ディレクトリを前いたディレクトリに変更。
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>標準のページャを使って <file>/etc/motd</file> の内容を表示。
 <ref id="cmd-stdin"> 参照。
  <footnote>
ベアボーン &debian; システムの標準のページャは <prgn>more</prgn>
であり、スクロールバックができません。コマンドライン
<tt>apt-get install less</tt> を用いて <package>less</package> を
インストールすることにより、<prgn>less</prgn> が標準のページャ
になり、カーソルキーでスクロールバックできるようになります。
  </footnote>
 </list>
<item><tt>touch <var>junkfile</var></tt>
 <list compact>
 <item>空の <file><var>junkfile</var></file> ファイルを作成。
 </list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>既存のファイル <file><var>foo</var></file> を新規ファイル
 <file><var>bar</var></file> にコピーする。
 </list>
<item><tt>rm <var>junkfile</var></tt>
 <list compact>
 <item>ファイル <file><var>junkfile</var></file> を削除する。
 </list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>既存のファイル <file><var>foo</var></file> の名前を新しい名前
 <file><var>bar</var></file> に変更する。
 </list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
 <list compact>
 <item>既存のファイル <file><var>foo</var></file> を新しい場所
 <file><var>bar</var></file> に移動させ、名前を 
 <file><var>baz</var></file> に変更する。ディレクトリ
 <file><var>bar</var></file> が存在している必要があります。
 </list>
<item><tt>chmod 600 <var>foo</var></tt>
 <list compact>
 <item>既存のファイル <file><var>foo</var></file> を他の人に読み書きできなく
 する。 (全ての人が実行不可)
 </list>
<item><tt>chmod 644 <var>foo</var></tt>
 <list compact>
 <item>既存のファイル <file><var>foo</var></file> を他の人に読めるが、
 書き込みができないようにする。(全ての人が実行不可)
 </list>
<item><tt>chmod 755 <var>foo</var></tt>
 <list compact>
 <item>既存のファイル <file><var>foo</var></file> を他の人に読めるが、
 書き込みができないようにする。(全ての人が実行可能)
 </list>
<item><tt>top</tt>
 <list compact>
 <item>フルスクリーンを用いてプロセス情報を表示。"q" を押すと終了。
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>起動中の全プロセスの情報を BSD スタイルの出力を用いて表示。
 <ref id="cmd-pipe"> 参照。
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>起動中の全プロセスの情報を System-V スタイルの出力を用いて表示。
 </list>
<item><tt>ps aux | grep -e "[e]xim4"</tt>
 <list compact>
 <item><prgn>exim4</prgn> を起動中の全プロセスを表示。<tt>man grep</tt>
 をタイプして、<manref name="grep" section="1"> マニュアルページから
 正規表現について学びましょう。
 </list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item>起動中の全プロセスの情報を ASCII アート出力を用いて表示。
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>プロセス ID <var>1234</var> により識別されるプロセスを殺す。
 <ref id="kill"> 参照。
 </list>
<item><tt>grep -e "<var>pattern</var>" *.html</tt>
 <list compact>
 <item>カレントディレクトリにある <tt>.html</tt> で終わる全ファイルから 
 "<var>pattern</var>" のパターンを検索し、該当する全ファイルを表示する。
 </list>
<item><tt>gzip <var>foo</var></tt>
 <list compact>
 <item>Lempel-Ziv コーディング (L777) を用いて <file><var>foo</var></file>
 を圧縮し、<file><var>foo</var>.gz</file> を作成する。
 </list>
<item><tt>gunzip <var>foo</var>.gz</tt>
 <list compact>
 <item><file><var>foo</var>.gz</file> を解凍して <file><var>foo</var></file>
 を作成する。
 </list>
<item><tt>bzip2 <var>foo</var></tt>
 <list compact>
 <item>Burrows-Wheeler ブロックソートテキスト圧縮アルゴリズムとハフマン
 コーディング (<prgn>gzip</prgn> より高圧縮率) を用いて 
 <file><var>foo</var></file> を圧縮し、<file><var>foo</var>.bz2</file>
 を作成する。
 </list>
<item><tt>bunzip2 <var>foo</var>.bz2</tt>
 <list compact>
 <item><file><var>foo</var>.bz2</file> を解凍して <file><var>foo</var></file>
 を作成する。
 </list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
 <list compact>
 <item><file><var>foo</var>.tar</file> アーカイブからファイルを展開する。
 </list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
 <list compact>
 <item>gzip 圧縮された <file><var>foo</var>.tar.gz</file> アーカイブから
 ファイルを展開する。
 </list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
 <list compact>
 <item>bzip2 圧縮された <file><var>foo</var>.tar.bz2</file> アーカイブから
 ファイルを展開する。
  <footnote>
 Potato にある旧版の <prgn>tar</prgn> でも動くように、新しい短縮形の
オプション <tt>-j</tt> の代わりに <tt>--bzip2</tt> をここでは用いています。
  </footnote>
 </list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
 <list compact>
 <item>フォルダ <file><var>bar</var>/</file> の内容を 
<file><var>foo</var>.tar</file> アーカイブにアーカイブする。
 </list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
 <list compact>
 <item>フォルダ <file><var>bar</var>/</file> の内容を
<file><var>foo</var>.tar.gz</file> アーカイブに圧縮アーカイブする
 </list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
 <list compact>
 <item>フォルダ <file><var>bar</var>/</file> の内容を
<file><var>foo</var>.tar.bz2</file> アーカイブに圧縮アーカイブする
 </list>
  <footnote>
互換性を保つためにここでは <tt>--bzip2</tt> を用いられています。
  </footnote>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>標準のページャを用いて圧縮された <file>README.gz</file> の
 内容を表示する。
 </list>
<item><tt>zcat README.gz &gt; foo</tt>
 <list compact>
 <item><file>README.gz</file> の内容を解凍してファイル <file>foo</file>
 を作成する。
 </list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
 <list compact>
 <item>圧縮された <file>README.gz</file> の内容をファイル <file>foo</file> の
 末尾に追加する。(<file>foo</file> が存在しない場合、先頭に作成される。)
 </list>
<item><tt>find . -name <var>pattern</var></tt>
 <list compact>
 <item>シェルを用いて <tt><var>pattern</var></tt>. にマッチするファイル名を
 検索する。(低速)
 </list>
<item><tt>locate -d . <var>pattern</var></tt>
 <list compact>
 <item>シェルを用いて <tt><var>pattern</var></tt>. にマッチするファイル名を
 検索する。(定期的に作成されたデータベースを使うため高速)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
訓練として、上記のコマンドを用いてディレクトリを横断し、システムの中を
のぞきこんでみてください。コンソールのコマンドに関して質問がある場合は、
必ずマニュアルページを読んでみてください。例えば、これらのコマンドは
良い開始点でしょう:
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
また、<prgn>vim</prgn> を始め、F1 キーを押す良い時期でしょう。
少なくとも最初の35行を読むべきです。そしてカーソルを <tt>|tutor|</tt>
まで動かし、Ctrl-] を押してオンラインコースを受けましょう。
エディタについてより詳しく学ぶには、<ref id="edit"> をご覧ください。
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
GNU や BSD 由来の多くの Unix コマンドは次のような手順 (又は
ある場合には引数無し) を行えば主要なヘルプ情報を表示できます:
<example>
$ <var>commandname</var> --help
$ <var>commandname</var> -h
</example>
<p>
自習のために、 <ref id="tips"> も例として試してみてください。

<sect1 id="cmd-exec">コマンドの実行
<p>
<!-- new content -->
ついに &debian; システムの使用方法を幾らか感じとれました。
&debian; システムでのコマンド実行機構について深く見ていきましょう。
<footnote>
ここで、初心者のために事実を単純化しています。正確な説明は
<manref name="bash" section="1"> 参照。
</footnote>

<sect1 id="cmd-simple">シンプルなコマンド
<p>
<!-- new content -->
シンプルなコマンドは、次の順序となります:
<enumlist compact>
<item>変数の割り当て (任意)
<item>コマンド名
<item>引数 (任意)
<item>リダイレクト (任意: <tt>&gt;</tt> 、 <tt>&gt;&gt;</tt> 、
<tt>&lt;</tt> 、 <tt>&lt;&lt;</tt> 、など)
<item>制御演算子 (任意: <tt>&amp;&amp;</tt> 、 <tt>||</tt> ;
&lt;newline&gt; 、 <tt>;</tt> 、 <tt>&amp;</tt> 、 <tt>(</tt> 、 <tt>)</tt>
)
</enumlist>
<p>
引用や置換を持つより複雑なコマンドについては、<ref id="clprocess"> 参照。

<sect1 id="cmd-env">コマンド実行と環境変数
<p>
<!-- new content -->
典型的なコマンドの実行は次のようなシェル行シーケンスを使用します:
<footnote>
次のような出力を得るには、フランス語ロケールのインストールが必要です。
<ref id="locales"> 参照。これは必ずしもチュートリアルには必要ありません。
これはその潜在的な効果を示すためだけに行われました。
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
ここで、プログラム <prgn>date</prgn> はフォアグランドジョブで実行されています。
環境変数 <tt>LC_ALL</tt> は次のようになっています:
<list compact>
<item>最初のコマンドでは unset (システムの標準。<tt>C</tt> と同等) 
<item>次のコマンドでは <tt>fr_FR</tt> (フランス語ロケール) にセット。
</list>
ほとんどのコマンドの実行は通常前の環境変数の定義を使用しません。
上の例では、次のように実行することもできます:
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
ここで見たように、コマンドの出力は環境変数により影響され、フランス語の
出力が行われました。環境変数をサブプロセスに継承されるようにしたい
(すなわち、シェルスクリプトを呼ぶとき) 場合は、代わりに 次のように
"export" する必要があります:
<example>
$ export LC_ALL
</example>


<sect1 id="cmd-path">コマンド検索パス
<p>
<!-- new content -->
シェル上でコマンドをタイプした場合、シェルはコマンドを <tt>PATH</tt>
環境変数内にリストされたディレクトリのリストから検索します。<tt>PATH</tt>
環境変数の値は、シェルの検索パスとも呼ばれます。
<p>
標準の &debian; インストールでは、ユーザアカウントの <tt>PATH</tt> 環境変数
には <file>/sbin/</file> が含まれないかもしれません。それゆえ、
<file>/sbin/</file> にある <prgn>ifconfig</prgn> のようなコマンドを
実行したい場合は、<tt>PATH</tt> 環境変数を、このディレクトリを含むように
変更する必要があります。<tt>PATH</tt> 環境変数は通常初期化ファイル
<file>~/.bash_profile</file> に含まれます。<ref id="bashconf"> を
ご覧ください。

<sect1 id="cmd-opt">コマンドラインオプション
<p>
<!-- new content -->
いくつかのコマンドは引数を取ります。<tt>-</tt> 又は <tt>--</tt> で始まる
引数はオプションと呼ばれ、コマンドの挙動を制御します。
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
ここでコマンドライン引数 <tt>-R</tt> は <prgn>date</prgn> コマンドが
RFC-2822 互換のデータ文字列を出力するように挙動を変更させます。

<sect1 id="cmd-wild">シェルのワイルドカード
<p>
<!-- new content -->
処理したいファイル名を全てタイプせずにファイルをコマンド処理したいことが
よくあります。シェルの <strong>ワイルドカード</strong> を用いた
ファイル名のパターン展開はこのニーズを促進します。
<list compact>
<item><tt>*</tt>
<list compact>
<item>空列を含む任意の文字列にマッチする。
<item>これは "<tt>.</tt>" で始まるファイル名にはマッチしません。
</list>
<item><tt>?</tt>
<list compact>
<item>任意の一文字にマッチする。
</list>
<item><tt>[...]</tt>
<list compact>
<item>括弧中の一文字にマッチする。
</list>
<item><tt>[a-z]</tt>
<list compact>
<item><tt>a</tt> と <tt>z</tt> の範囲にある文字とマッチする。
</list>
<item><tt>[^...]</tt>
<list compact>
<item>括弧内 ("^" 以外) に含まれる文字以外の文字にマッチ。
</list>
</list>
<p>
例えば、次の例を試してみて、自分で考えてみましょう:
<example>
$ mkdir junk; cd junk; touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rmdir junk
</example>

<sect1 id="cmd-return">コマンドの戻り値
<p>
コマンドは戻り値として終了ステータスを返します。
<list compact>
<item>コマンドが正常に終了した場合、戻り値は 0。
<item>コマンドがエラーで終了した場合、戻り値は非 0。
</list>
この戻り値は実行後すぐに <tt>$?</tt> シェル変数によりアクセス
できます。
<p>
戻り値はシェルのために論理的な観点で使用される場合、<strong>成功</strong>
は論理的に <strong>真</strong> として扱われることに注意してください。
これは <strong>正常終了</strong> は <strong>ゼロ</strong> の値を持つため、
いくらか非直感的です。
<p>
<ref id="shell-cond"> をご覧ください。

<sect1 id="cmd-typical">典型的なコマンドシーケンス
<p>
<!-- new content in this whole sect1 ind sect2s -->
次に挙げるシェルコマンドのイディオムを覚えてみましょう。
これらのイディオムを読んだ後に、<ref id="shell-param">、
<ref id="shell-redirect">、<ref id="shell-cond">、 そして
<ref id="clprocess"> をご覧ください。

<sect2 id="cmd-back"><tt>command &amp;</tt>
<p>
<prgn>command</prgn> は <strong>バックグラウンド</strong> で
サブシェルにて実行されます。バックグラウンドジョブにより、
複数のプログラムを単独のシェルで実行することが可能となります。
<p>
バックグラウンドプロセスの管理は次に挙げるシェル組込みコマンドに関連します:
<prgn>jobs</prgn>、<prgn>fg</prgn>、<prgn>bg</prgn> および
<prgn>kill</prgn> 。 
<manref name="bash" section="1"> マニュアルページの
"SIGNALS"、 "JOB CONTROLS" および "SHELL BUILTIN COMMANDS" の章を
読んでみてください。
<footnote>
&debian; システムはマルチタスクシステムです。
></footnote>
 
<sect2 id="cmd-pipe"><tt>command1 | command2</tt>
<p>
<prgn>command1</prgn> の標準出力は <prgn>command2</prgn> の標準入力
に導かれます。両方のコマンドは <strong>同時に</strong> 動くかも
しれません。これは <strong>パイプライン</strong> と呼ばれます。

<sect2 id="cmd-list"><tt>command1 ; command2</tt>
<p>
<prgn>command1</prgn> と <prgn>command2</prgn> は 
<strong>連続して</strong> 実行されます。
 
<sect2 id="cmd-and"><tt>command1 &amp;&amp; command2</tt>
<p>
<prgn>command1</prgn> がまず実行されます。コマンドの実行が
正常終了した場合は、<prgn>command2</prgn> も <strong>連続して</strong>
実行されます。<prgn>command1</prgn> と <prgn>command2</prgn> の
<strong>両方</strong> が正常終了した場合に正常終了を返します。
 
<sect2 id="cmd-or"><tt>command1 || command2</tt>
<p>
<prgn>command1</prgn> がまず実行されます。失敗した場合、
<prgn>command2</prgn> も <strong>連続して</strong> 実行されます。
<prgn>command1</prgn> <strong>又は</strong> <prgn>command2</prgn>
のどちらかが正常終了した場合に正常終了を返します。

<sect2 id="cmd-stdout"><tt>command &gt; <var>foo</var></tt>
<p>
<prgn>command</prgn> の標準出力をファイル <tt><var>foo</var></tt>
にリダイレクト (上書き) します。

<sect2 id="cmd-stdout2"><tt>command &gt;&gt; <var>foo</var></tt>
<p>
<prgn>command</prgn> の標準出力をファイル <tt><var>foo</var></tt>
にリダイレクト (追記) します。

<sect2 id="cmd-stderr"><tt>command &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
<prgn>command</prgn> の標準出力と標準エラー出力の両方をファイル 
<tt><var>foo</var></tt> にリダイレクトします。

<sect2 id="cmd-stdin"><tt>command &lt; <var>foo</var></tt>
<p>
<prgn>command</prgn> の標準入力をファイル <tt><var>foo</var></tt> に
リダイレクトします。試してみましょう:
<example>
$ &lt;/etc/motd pager
 ... (グリーティングメッセージを表示)
$ pager &lt;/etc/motd
 ... (グリーティングメッセージを表示)
$ pager /etc/motd
 ... (グリーティングメッセージを表示)
$ cat /etc/motd | pager
 ... (グリーティングメッセージを表示)
</example>
この4つの構文は同じ出力を表示しますが、最後の例は特別な <prgn>cat</prgn>
コマンドを起動し、無駄なリソースを消費しています。

<sect1 id="cmd-alias">コマンドエイリアス
<p>
<!-- new content -->
良く使うコマンドにエイリアスを設定できます。例えば:
<example>
$ alias la='ls -la'
</example>
ここで、<prgn>la</prgn> は 一列形式で全ファイルをリストする <tt>ls -la</tt>
の短縮形として働きます。
<p>
<prgn>type</prgn> コマンドを使って、正確なパス又はコマンドの正体を
識別できます。例えば:
<example>
$ type ls
ls is hashed /bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
</example>
ここで <prgn>ls</prgn> は最近検索されましたが、<prgn>file</prgn>
はそうではないので、<prgn>ls</prgn> は "ハッシュされた" といいます。
すなわち、シェルは <prgn>ls</prgn> コマンドの場所への高速なアクセス
のために、内部記録を取っています。

<sect id="text-process">Unix ライクなテキスト処理
<p>
頻繁に Unix ライクシステムで使用される標準的なテキスト処理ツールが
いくつかあります。
<list compact>
<item>正規表現未使用ツール:
<list compact>
<item><prgn>head</prgn> はファイルの先頭部分を出力します。
<item><prgn>tail</prgn> はファイルの末尾の部分を出力します。
<item><prgn>sort</prgn> はテキストファイルの行をソートします。
<item><prgn>uniq</prgn> はソートされたファイルの重複行を削除します。
<item><prgn>tr</prgn> は文字を変換したり削除します。
<item><prgn>diff</prgn> は一行ごとにファイルを比較します。
</list>
<item>基本的な正規表現 (BRE) を使用するツール:
<list compact>
<item><prgn>grep</prgn> はテキストにパターンをマッチさせます。
<item><prgn>ed</prgn> は原始的なラインエディタです。
<item><prgn>sed</prgn> はストリームエディタです。
<item><prgn>vi</prgn> はスクリーンエディタです。
<item><prgn>emacs</prgn> はスクリーンエディタです。
</list>
<item>拡張正規表現 (ERE) を使用するツール:
<list compact>
<item><prgn>egrep</prgn> はテキストにパターンをマッチさせます。
<item><prgn>awk</prgn> はシンプルなテキスト処理を行います。<ref id="awk">
参照。
<item><prgn>perl</prgn> は考えられる全てのテキスト処理を行います。
<ref id="perl"> 参照。
</list>
</list>
いくつかのスクリプト例は <ref id="perl-i">、 <ref id="scrp-snip">、
そして <ref id="perl-mad"> をご覧ください。


<sect1 id="regex">正規表現
<p>
正規表現は多くのテキスト処理ツールで使われています。シェルのワイルドカード
(<ref id="cmd-wild"> 参照) に似ていますが、より複雑かつパワフルです。
<p>
正規表現はパターンマッチを記述し、テキスト文字と <strong>メタ文字</strong>
からなります。メタ文字は単なる特別な意味を持つ文字です。BRE と ERE の
二つの主要な形式がありますが、どちらを使うかは <ref id="text-process"> 
に記述されているテキストツールの種類に依ります。
<p>
ERE の場合、<strong>メタ文字</strong> には
"<tt> \ . [ ] ^ &dollar; * + ? ( ) { } | </tt>" が含まれます。
正規表現は次の意味を持ちます:
<list compact>
<item><tt>c</tt>
<list compact>
<item>非メタ文字の "<tt>c</tt>" にマッチ。
</list>
<item><tt>\c</tt>
<list compact>
<item>文字通り "<tt>c</tt>" にマッチ。
</list>
<item><tt>.</tt>
<list compact>
<item>空白を含む全文字にマッチ。
</list>
<item><tt>^</tt>
<list compact>
<item>文字列の先頭にマッチ。
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>文字列の末尾にマッチ。
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>単語の先頭にマッチ。
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>単語の末尾にマッチ。
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>"<tt>abc...</tt>" のいずれかの文字にマッチ。
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>"<tt>abc...</tt>" 以外のいずれかの文字にマッチ。
</list>
<item><tt>r*</tt>
<list compact>
<item>"<tt>r</tt>" で認識される0回を含む正規表現の繰り返しにマッチ。
</list>
<item><tt>r+</tt>
<list compact>
<item>"<tt>r</tt>" で認識される1回以上の正規表現の繰り返しにマッチ。
</list>
<item><tt>r?</tt>
<list compact>
<item>"<tt>r</tt>" で認識される0回を含む正規表現の繰り返しにマッチ。
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>"<tt>r1</tt>" 又は "<tt>r2</tt>" で認識される正規表現のいずれか
にマッチ。
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>"<tt>r1</tt>" 又は "<tt>r2</tt>" で認識される正規表現のいずれか
にマッチし、<strong>ひとまとめの</strong> 正規表現として扱われます。
</list>
</list>
<p>
BRE では、<strong>メタ文字</strong>  "<tt> + ? ( ) { } | </tt>"
はその特別な意味を失っています。その代わり、バックスラッシュされた
"<tt> \+ \? \( \) \{ \} \| </tt>" を使います。それゆえ、grouping construct
 <tt>(r1|r2)</tt> は BRE では <tt>\(r1|r2\)</tt> の
ように引用符で囲む必要があります。<prgn>emacs</prgn> は、基本的に BRE
を使いますが、"<tt> + ?</tt>" を <strong>メタ文字</strong> として
扱います。それゆえ、引用符で囲む必要はありません。grouping construct
がどのように使われるかについては <ref id="replaceex"> をご覧ください。
<p>
例えば、<prgn>grep</prgn> は正規表現を用いてテキスト検索を行うために使えます:
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">置換表現
<p>
置換表現の場合、次の文字には特別な意味があります:
<list>
<item><tt>&amp;</tt> 
<list compact>
<item>正規表現がマッチするものを示す。(<prgn>emacs</prgn> では
<tt>\&amp;</tt> を使用)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item><var>n</var> 番目に <strong>括弧で囲まれた</strong> 正規表現に
マッチするものを示す。
</list>
</list>
Perl の置換文字列の場合、<tt>&dollar;<var>n</var></tt> は
<tt>\<var>n</var></tt> の代わりに用いられ、<tt>&amp;</tt> は
特別な意味を持ちません。
<p>
例:
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
ここで、<strong>括弧で囲まれた</strong> 正規表現と、マッチした文字列が
異なったツールでテキスト置換処理にどのように使われるかに特別な注意を
払ってください。
<p>
これらの正規表現はエディタ内でカーソルの動きとテキスト置換アクションの両方
に対して使えます。
<p>
これらのコマンドを習うために、関連するマニュアルページを全て読んでください。

<sect id="unixfile">Unix ライクなファイルシステム
<p>
<!-- 
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
GNU/Linux や他の Unix ライク OS システムでは、<strong>ファイル</strong> は
<strong>ディレクトリ</strong> に組織化されています。
<footnote>
<strong>ディレクトリ</strong> はいくつかのシステムでは <strong>フォルダ</strong>と呼ばれています。
</footnote>
全ての <strong>ファイル</strong> と <strong>ディレクトリ</strong> は
<file>/</file> を根とする一つの大きなツリー、すなわちファイル階層に配置
されています。
<p>
これらのファイルは複数のデバイスに展開することができます。
<manref name="mount" section="8"> コマンドは
あるデバイス上にあるファイルシステムを大きなファイルツリーに所属させます。
逆に、<manref name="umount" section="8"> コマンドは再び分離させます。

<sect1 id="file-basics">Unix ファイルの基礎
<p>
<!-- new content -->
次に挙げることは基礎知識です:
<list compact>
<item> ファイル名は大文字と小文字を区別します。すなわち、
<file>MYFILE</file> と <file>MyFile</file> は <strong>異なる</strong>
ファイルです。

<item>root ディレクトリは単に <file>/</file> として参照されます。
root ユーザとこの "root" を混同しないでください。<ref id="login-root"> 参照。

<item>全てのディレクトリ名には <file>/</file> を<strong>除く</strong>全ての
文字と記号を使用できます。
<footnote>
ファイル名にはほとんど全ての文字や記号を<strong>使えます</strong>が、
実際には使うべきでない文字や記号があります。コマンドラインで特別な意味
を持つ文字を使うのを避けるのが良いでしょう。それらには、スペース、タブ、
改行や他の特別な文字:
<tt>{ } ( ) [ ] ' ` &quot; \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> 
が含まれます。
<p>
複数の単語からなるファイル名を付けたい場合、ピリオド、ハイフンや下線を
使うのが良い選択です。各単語の先頭文字を、<tt>LikeThis</tt> のように
大文字にするのも良いでしょう。
</footnote>
root ディレクトリは例外です。名前は <file>/</file> 
("スラッシュ" や "root ディレクトリ" と呼ぶ) であり、変えられません。

<item>各ファイルおよびディレクトリは <strong>完全に記述したファイル名</strong>
、<strong>絶対ファイル名</strong> や <strong>パス</strong> により
指定され、たどっていくとファイルに到達するディレクトリの列を与えます。
この3つの用語は同意語です。全ての絶対ファイル名は <file>/</file> 
ディレクトリで始まり、ファイル名内のディレクトリやファイルの間には
<file>/</file> がはさまります。最初の <file>/</file> はディレクトリ名
ですが、その他はファイル名の部分部分を区別するための単なるセパレータです。
<p>
ここで使われる単語は混乱を招きます。次の例をご覧ください:
<example>
/usr/share/keytables/us.map.gz
</example>
これは完全に記述されたファイル名です。ある人はこれを <strong>パス</strong>
と呼びますが、<file>us.map.gz</file> だけをファイル名として呼ぶ人もいます。
<footnote> 
<strong>パス</strong> という単語の他の使いかたもあります。
<ref id="cmd-path"> をご覧ください。意図された意味は通常文脈から
判断するとはっきりします。
</footnote>

<item>root ファイルシステムは <file>/etc/</file> や <file>/usr/</file>
のような複数の枝を持ちます。これらのサブディレクトリもまた
<file>/etc/init.d/</file> や <file>/usr/local/</file> のように、さらに
サブディレクトリに枝別れします。これらの全体をまとめて 
<strong>ディレクトリツリー</strong> と呼びます。
<p>
絶対ファイル名をツリーの根元 (<file>/</file>) から枝の先 (ファイル)
までの経路として考えることもできます。また、ディレクトリツリーは
あたかも <strong>家系図</strong> であり、だからサブディレクトリは
<strong>子供</strong> で、パスはファイルの完全な系統を示すかのように
人が話すのを聞いたことがあるでしょう。
<p>
root ディレクトリではない他の場所から始まる相対パスもあります。
<file>../</file> は親ディレクトリを参照していることを覚えておきましょう。

<item>ハードディスクのような物理デバイスに対応したディレクトリは存在しません。
ここが 全てのパスが <tt>C:</tt> のようなデバイス名から始まる
CP/M、DOS、そして Windows と違う点です。<ref id="file-system"> をご覧ください。
</list>

<p>
ファイル階層について詳細に学ぶ最も良い方法は、
<url id="&f-fhs;" name="Filesystem Hierarchy Standard"> に記述されています。
手始めとして次の事実を覚えるべきです:
<list compact>
<item><file>/</file>
<list compact>
<item>単なる <file>/</file> は root ディレクトリを表す。
<p>
</list>
<item><file>/etc/</file>
<list compact>
<item>ここはシステム全体の設定ファイルを置く場所です。
</list>
<item><file>/var/log/</file>
<list compact>
<item>ここはシステムのログファイルを置く場所です。
</list>
<item><file>/home/</file>
<list compact>
<item>ここは全ての非特権ユーザのホームディレクトリがあるディレクトリです。
</list>
</list>

<sect1 id="file-system">&debian; でのファイルシステムの概念
<p>
<!-- old content modified with fs.h reference -->
Unix の伝統に従い、&debian; システムはハードディスクや他のストレージデバイス
上の物理データ、そしてコンソールスクリーンなどのハードウェアデバイス
とリモートのシリアルコンソールとの相互作用を統一された形式で表される
ファイルシステムを供給します。
<p>
&debian; での各ファイル、ディレクトリ、名前付きパイプ、そして物理データ
はそのデータの所有者 (owner)、データが所属するグループ、最後にアクセスされた
時間などの付随する属性を記述する  <strong>inode</strong> と呼ばれる
データ構造を持ちます。
&debian; GNU/Linux システムでの <tt>inode 構造</tt> の正確な定義を知るには、
<url id="&f-inode-def;"> をご覧ください。
<p>
物理エントリの統一された表現は非常にパワフルなので、完全に異なるデバイスに
同種の操作を行うために、同じコマンドを使用することを可能とします。
<p>
ファイルは一つのディスク上に置けますし、20個のディスクに分けることも、
ネットワーク上のどこかにある違うコンピュータにあって接続することもできます。
<!-- 逆の意味かも。-->
ファイルが本当にある物理デバイスが何であっても、ほとんど全ての
コマンドが同じように動くかどうかはディレクトリツリーを見るだけでは
見分けがつきません。


<sect1 id="file-perm">ファイルとディレクトリのアクセス権
<p>
<!-- old content -->
ファイルとディレクトリのアクセス権はそれぞれ次に挙げる三つの
影響されるユーザのカテゴリのために定義されています:
<list compact>
<item>ファイルを所有する <strong>ユーザ</strong> (u)。
<item>ファイルが所属する <strong>グループ</strong> のユーザ (g)。そして
to (g), and
<item>全ての <strong>他の</strong> ユーザ (o)。
</list>
<p>
ファイルでは、それぞれに対応する権限は次のようになります:
<list compact>
<item><strong>読み込み</strong> (r): ファイルの内容を検査する権限。
<item><strong>書き込み</strong> (w): ファイルの修正を行う権限。 そして
<item><strong>実行</strong> (x): ファイルをコマンドとして実行する権限。
</list>
<p>
ディレクトリでは、対応する権限はそれぞれ次のようになります:
<list compact>
<item><strong>読み込み</strong> (r): ディレクトリの内容をリストする権限。
<item><strong>書き込み</strong> (w): ディレクトリにファイルを追加したり削除する権限。そして
<item><strong>実行</strong> (x): ディレクトリ内のファイルにアクセスする権限。
</list>
ここで、ディレクトリでの <strong>実行</strong> 権はディレクトリにあるファイルの
読み込みを許可するだけでなく、サイズや修正時間などの属性を見ることも許可します。<p>
ファイルやディレクトリのアクセス権情報 (やそれ以上) を表示するには、
<prgn>ls</prgn> が使われます。<manref name="ls" section="1"> をご覧ください。
<prgn>ls</prgn> を <tt>-l</tt> オプション付きで実行すると、次の情報が
この順序で表示されます:
<list compact>
<item><strong>ファイルタイプ</strong> (先頭文字)
 <list compact>
 <item><tt>-</tt>: 通常のファイル
 <item><tt>d</tt>: ディレクトリ
 <item><tt>l</tt>: シンボリックリンク
 <item><tt>c</tt>: キャラクタデバイス node
 <item><tt>b</tt>: ブロックデバイス node
 <item><tt>p</tt>: 名前付きパイプ
 <item><tt>s</tt>: ソケット
 </list>
<item>ファイルの <strong>アクセス権</strong> (次の9文字。ユーザ、グループ、
そして他者それぞれに対して3つの文字から構成)
<item>そのファイルへの <strong>ハードリンク数</strong>
<item>ファイルを所有する <strong>ユーザ</strong> の名前
<item>ファイルが所属する <strong>グループ</strong> の名前
<item>ファイルのバイト単位での <strong>サイズ</strong>
<item>ファイルの <strong>タイムスタンプ</strong> (mtime)
<item>ファイルの <strong>名前</strong>
</list>
<p>
ファイルの所有者を変更するには、root アカウントから <prgn>chown</prgn> を
使用します。ファイルのグループを変更するには、ファイルの所有者又は root 
アカウントから <prgn>chgrp</prgn> を使用します。ファイルやディレクトリの
アクセス権を変更するには、ファイルの所有者又は root アカウントから
<prgn>chmod</prgn> を使います。<file>foo</file> ファイルの操作を行う
基本的な文法は次の通り:
<example>
# chown <var>newowner</var> foo
# chgrp <var>newgroup</var> foo 
# chmod  [ugoa][+-=][rwx][,...] foo 
</example>
詳細は <manref name="chown" section="1">、<manref name="chgrp" section="1">
および <manref name="chmod" section="1"> をご覧ください。

<p>
例えば、ディレクトリツリーの所有者をユーザ <var>foo</var> に変更し、
グループ <var>bar</var> で共有する場合、root アカウントから次のコマンドを
実行します:
<example>
# cd /some/location/
# chown -R <var>foo</var>:<var>bar</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
3つのさらに専門的なアクセス権ビットが存在します:
<list compact>
<item><strong>setuid ビット</strong> (ユーザの x の代わりに s 又は S)
<item><strong>setgid ビット</strong> (グループの x の代わりに s 又は S) 
<item><strong>sticky ビット</strong> (他者の x の代わりに t 又は T)
</list>
ここで <prgn>ls -l</prgn> のこれらのビットを表す出力は、これらのビットが出力
されることにより隠される実行ビットがセットされていない場合、大文字になります。
<p>
<strong>setuid ビット</strong> を実行ファイルにセットすると、ユーザは
ファイルの所有者 ID (例えば、<strong>root</strong>) により実行ファイルを
実行することを許可します。同様に、
<strong>setgid ビット</strong> をを実行ファイルにセットすると、ユーザは
ファイルのグループ ID (例えば、<strong>root</strong>) により実行ファイルを
実行することを許可します。これらの設定はセキュリティを破るリスクを引き起こす
ので、これらのビットを有効にするには特別な注意が必要です。
<p>
<strong>setgid ビット</strong> をディレクトリに対して有効にすると、
ディレクトリに作成した全ファイルがディレクトリの <strong>グループ</strong>
に所属するというBSD ライクなファイル生成手法が有効になります。
<p>
<strong>sticky ビット</strong> をディレクトリに対して有効にすると、
ディレクトリにあるファイルがファイルの所有者以外から削除されるのを防ぎます。
<file>/tmp</file> やグループの書き込み可能なディレクトリなどの
world-writable なディレクトリにあるファイルの内容を安全にするためには、
<strong>書き込み</strong> 権を無効にするだけでなく、
ディレクトリに <strong>sticky ビット</strong> もセットする必要があります。
さもなければ、ディレクトリに書き込みできるユーザにより、ファイルが削除され、
同じ名前で新しいファイルが作成されることを許してしまいます。
<p>
次にファイルアクセス権の興味深い例を挙げます:
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
<manref name="chmod" section="1"> コマンドを用いて、ファイルアクセス権を
記述するためのもう一つの数字モードが存在します。この数字モードは8進数
を使った4桁の数字を用います。各桁は次のように対応します:
<list compact>
<item>最初の任意桁:: <strong>setuid</strong> (=4)、
 <strong>setgid</strong> (=2)、 <strong>sticky ビット</strong> (=1) の合計。
<item>2番目の桁: 所有者に対する
 <strong>読み込み</strong> (=4)、 <strong>書き込み</strong> (=2)、
 <strong>実行</strong> (=1) 権の合計。
<item>3番目の桁: <strong>グループ</strong> に対する同様の合計。
<item>4番目の桁: <strong>他者</strong> に対する同様の合計。
</list>
<p>
これは複雑に聞こえるかもしれませんが、実際は本当にシンプルです。
<tt>ls -l</tt> コマンドの出力の最初の数行を見て、それをファイルアクセス権の
バイナリ (2進数) 表現 ("-" を "0"、 "rwx" を "1) として読むと、
この数字モードの値はファイルアクセス権の8進数表現として意味を持ちます。
<footnote>
もちろんこの方法は3桁の数字モードの場合のみ機能します。
</footnote>
例えば、次を試してみてください:
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
標準のファイルアクセス権マスクは <prgn>umask</prgn> シェル組込み
コマンドを使うことによりセットできます。<manref name="builtins" section="7">
をご覧ください。
</sect1>

<sect1 id="timestamp">タイムスタンプ
<p>
<!-- old content, minor edit -->
GNU/Linux のファイルには、3種類のタイプスタンプが存在します:
<list compact>
<item><strong>mtime</strong>: 修正時刻 (<tt>ls -l</tt>)
<item><strong>ctime</strong>: ステータス変更時刻 (<tt>ls -lc</tt>)
<item><strong>atime</strong>: 最後にアクセスした時刻 (<tt>ls -lu</tt>)
</list>
<strong>ctime</strong> が作成時刻ではないことに注意してください。
<list compact>
<item>ファイルを上書きすると、そのファイルの <strong>mtime</strong>、
<strong>ctime</strong>、<strong>atime</strong> の全てが変更されます。
<item>ファイルのアクセス権や所有者を変更すると、<strong>ctime</strong>、
<strong>atime</strong> が変更されます。
<item>ファイルを読み込むと、そのファイルの <strong>atime</strong> が
変更されます。
</list>
&debian; システム上では、ファイルをただ読み込むだけで通常ファイルの書き込み操作
が発生し、<strong>inode</strong> の<strong>atime</strong> 情報が更新される
ことに注意してください。ファイルシステムを <tt>noatime</tt> オプション付きで
マウントすると、システムはこの操作を飛ばし、ファイル読み込みアクセスが
より高速になります。<manref name="mount"section="8"> をご覧ください。
<p>
<!-- new content -->
既存のファイルのタイムスタンプを変更するには、<manref name="touch" section="1">
をご覧ください。
</sect1>

<sect1 id="links">リンク
<p>
<!-- old content -->
異なるファイル <var>bar</var> とファイル <var>foo</var> を連携させる
二つの方法があります。
<list compact>
<item><strong>ハードリンク</strong> は既存のファイルに対する重複した名前です。
(<tt>ln <var>foo</var> <var>bar</var></tt>)
<item><strong>シンボリックリンク</strong> 又は "symlink" は他のファイルを
名前により指示する特別なファイルです。
(<tt>ln -s <var>foo</var> <var>bar</var></tt>)
</list>
リンク数の変更と <prgn>rm</prgn> コマンドの結果の厳密な違いについての次の例
をご覧ください。
<example>
$ echo "Original Content" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # hard link
$ ln -s <var>foo</var> <var>baz</var>  # symlink
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "New Content" &gt; <var>foo</var>
$ cat <var>bar</var>
Original Content
$ cat <var>baz</var>
New Content
</example>
<!-- minor update below -->
シンボリックリンクは上の例に示したように、常にファイルアクセス権 "rwxrwxrwx"
を持ちますので、シンボリックリンクが指すファイルのアクセス権により指示される
ファイルアクセス権が実際の効果を持ちます。

<p>
<file>.</file> ディレクトリは中にあるディレクトリとリンクしていますので、
新しいディレクトリリンク数は2から始まります。<file>..</file> ディレクトリ
は親ディレクトリとリンクしているので、このディレクトリのリンク数は
新しいサブディレクトリの増加に伴い増加します。

<sect1 id="fifo">名前付きパイプ (FIFO)
<p>
<!-- DDP Debian Tutorial content -->
<p>
名前付きパイプは、パイプのように働くファイルです。何かをファイルに
入れ、もう一方から出ます。こうしてこれは FIFO 又は First-In-First-Out
と呼ばれます：最初にパイプに入れるものが最初にもう一方から出てきます。
<p>
名前付きパイプに書き込んだ場合、パイプに書き込んだプロセスは情報が
パイプから読み込まれるまで終了しません。名前付きパイプを読み込んだ場合、
読み込んだプロセスは何か読み込むものが存在するまで終了するのを待ちます。
パイプのサイズは常に 0 です。 -- 名前付きパイプはデータを保存せず、
シェルの <tt>|</tt> のように二つのプロセスをリンクするだけです。
しかし、このパイプは名前を持つので、二つのプロセスは同じコマンドライン
にあったり、同じユーザにより実行される必要さえありません。
<p>
名前付きパイプを次を実行することにより試せます:
<example>
$ cd; mkfifo mypipe
$ echo "hello" &gt;mypipe &amp; # バックグラウンドに入れる
[1] <var>5952</var>
$ ls -l mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
$ cat mypipe
hello
[1]+  Done                    echo hello &gt;mypipe
$ ls mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
$ rm mypipe
</example>

<sect1 id="sockets">ソケット
<p>
<!-- new content -->
ソケットは名前つきパイプ (FIFO) に似ており、プロセス間の情報交換を
行えます。ソケットにとって、これらのプロセスは同時に実行する必要
はありませんし、同じ祖先プロセスの子供である必要もありません。
これはプロセス間通信の終端点です。情報の交換は異なるホストの間の
ネットワーク越しでさえ発生します。

<sect1 id="device">デバイス名
<p>
<!-- DDP Debian Tutorial content, modified -->
デバイスファイルは、システム上のハードディスク、ビデオカード、ディスプレイ、
キーボードなどの物理デバイス又は仮想デバイスに関連します。仮想デバイスの
例として、<tt>/dev/console</tt> として表されるコンソールがあります。
<p>
デバイスには二つのタイプがあります:
<list compact>
<item><strong>キャラクタデバイス</strong>
<list compact>
<item>一度に一つの文字にアクセス、すなわち、デバイスから書き込みや読み込みを
行うデータの最小単位が文字 (バイト) であるデバイスです。
</list>
<item><strong>ブロックデバイス</strong>
<list compact>
<item>ブロックと呼ばれる、多量の文字を含むより大きな単位でアクセスされる
デバイスです。ハードディスクはブロックデバイスです。
</list>
</list>
<p>
デバイスファイルの読み書きが可能ですが、ファイルには、人間にとっては
ちんぷんかんぷんで理解できないバイナリデータが多分含まれます。
データを直接デバイスファイルに書き込むことは時々ハードウェアの
接続に関するトラブルシュートに役立ちます。例えば、
プリンタデバイス <file>/dev/lp0</file> にテキストデータをダンプしたり、
適切なシリアルポート <file>/dev/ttyS0</file> にモデムコマンドを送る
ことができます。しかし、注意深くやらないと、大災害をもたらすことがあります。
だから気をつけてください。

<sect2 id="devnull"><file>/dev/null</file> など
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> は書き込む全てを捨てる特別なデバイスファイルです。
何かをしたくない場合、それを <file>/dev/null</file> に投げ込みます。
これは基本的に底無し穴です。<file>/dev/null</file> を読み込むと、
ファイル終端 (EOF) 文字がすぐさま得られます。
<p>
<file>/dev/zero</file> は同様に、ここから読み込むと、<tt>\0</tt> 文字
を取得します。(ASCII コードの 0 とは異なる) <ref id="dummyfile"> を
ご覧ください。

<sect2 id="node">デバイスノード数
<p>
<!-- new content -->
デバイスノード数は <prgn>ls</prgn> を次のように実行すると表示されます:
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
ここで、
<list compact>
<item><file>/dev/hda</file> はmajor device number 3 と minor device number 0
を持ちます。これは <tt>disk</tt> グループに所属するユーザにより、読み書き
が可能です。
<item><file>/dev/ttyS0</file> は major device number 4 と minor device number
64 を持ちます。これは <tt>dialout</tt> グループに所属するユーザにより読み書き
が可能です。
<item><file>/dev/zero</file> は major device number 1 と minor device number 5
を持ちます。これはだれでも読み書き可能です。
</list>
<p>
古いシステムでは、インストール過程で <prgn>/sbin/MAKEDEV</prgn> コマンド
を使ってデバイスノードを作成します。 <manref name="MAKEDEV" section="8">
をご覧ください。
<p>
新しいシステムでは、<file>/dev</file> 下のファイルシステムは
<file>/proc</file> ファイルシステムと同様のデバイスファイルシステムにより
自動的に生成されます。

<sect1 id="procfs"><file>/proc</file> ファイルシステム
<p>
<!-- modified heavily, original from Debian Guide -->
<file>/proc</file> ファイルシステムは仮想ファイルシステムであり、
システムや起動中のプロセスに関する情報を含みます。
<p>
特にあるファイル - <file>/proc/kcore</file> に気づくと、パニックになる人が
良くいます。これは一般に巨大です。これは (おおよそ) コンピュータのメモリ
の内容のコピーです。これは kernel をデバッグするのに用いられます。
実際にはどこにも存在しないので、そのサイズに関して心配する必要は
全くありません。
<p>
<ref id="proc-sys"> と <manref name="proc" section="5"> をご覧ください。

<sect id="xtuto">X Window System
<p>
<!-- practically new content -->
<ref id="x"> をご覧ください。

<sect1 id="xstart">X Window System を起動する
<p>
X Window System は <prgn>xdm</prgn> のようなグラフィカルなログイン
デーモンにより自動的に起動できますし、コンソールから次をタイプしても
起動できます。
<example>
$ exec startx
</example>

<sect1 id="xmenu">X Window System におけるメニュ
<p>
X 環境は多くのウィンドウマネージャを提供するので、ユーザインターフェース
はかなり変化します。root ウィンドウを右クリックするとメニュインターフェース
が上がって来ます。これはいつも使えます。
<list compact>
<item>シェルコマンドプロンプトを得るには、メニュから Xterm を起動します:
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>web ページのグラフィカルなブラウズを行うには、メニュから Mozilla を起動
します:
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>PDF ファイルのグラフィカルなブラウズを行うには、メニュから Xpdf を
起動します:
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
メニュエントリが見付からない場合、関連するパッケージをインストールしてください。<ref id="apt-install"> をご覧ください。

<sect1 id="xkeys">X Window System でのキーボードシーケンス
<p>
X Window System を起動中にオボエテオクベキジュうようなキーストローク
を次に挙げます:
<list compact>
<item>Ctrl-Alt-F1 から F6:  他の仮想端末に切替える (X window、DOSEMU などから)
<item>Alt-F7:               X window に戻る
<item>Ctrl-Alt-minus:       画面の解像度を変更 (マイナスは数字キーパッド
にあるキー)
<item>Ctrl-Alt-plus:        画面の解像度を逆向きに変更 (プラスは数字
キーパッドにあるキー)
<item>Ctrl-Alt-Backspace:   X サーバプログラムを終了
<item>Alt-X, Alt-C, Alt-V:  良く使う Window/Mac のカット、コピー、ペーストキー
の組合せで使う Ctrl- キーはこれらの Alt- キーで Netscape Composer のような
いくつかのプログラムでは置き換えられる。
</list>

<sect id="cmd-study">Further study
<p>
現時点では、<url id="&tldp-guide;" name="The Linux Documentation Project: Guides"> から引用する主要なガイドブックを読むことをお薦めします:
<list compact>
<item>"The Linux System Administrators' Guide",
<list compact>
<item>システムの起動、ユーザアカウント、バックアップ、システム設定を
維持する見地を全てカバーしている。
<item>パッケージ: <package>&p-sysadmin-guide;</package>
<item>ファイル: <url id="&f-sysadmin-guide;">
<item>web: <url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition",
<list compact>
<item>Linux 環境でのネットワーク管理のためのただ一つのリファレンスです。
<item>パッケージ: <package>&p-netadmin-guide;</package>
<item>ファイル: <url id="&f-netadmin-guide;">
<item>web: <url id="&w-netadmin-guide;">
</list>
<item>"The Linux Cookbook",
<list compact>
<item>忙しい現代のコンピュータユーザのための1500以上の時間を節約する
レシピとヒントを提供。
<item>パッケージ: <package>&p-linuxcookbook;</package>
<item>ファイル: <url id="&f-linuxcookbook;">
<item>web: <url id="&w-linuxcookbook;">
</list>
</list>
<p>
さらに学ぶためのリソースは <ref id="support"> をご覧ください。
</chapt>

