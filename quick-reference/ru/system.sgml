<!-- CVS revision of this document "$Revision: 1.2 $"  -->
<!-- CVS revision of original english document "1.61"  -->
<chapt id="system">Основы Debian

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
Эта статья обеспечивает основную информацию по системе Debian
для пользователей. За авторитетной информацией обращайтесь к документам:
<p>
<list compact>
<item>Руководство по политике Debian
<item>Руководство по созданию пакетов в Debian 
<item>Справочник Debian-разработчика
<item>Руководство начинающего Debian-мейнтейнера
<p>
</list>
ссылки на которые приведены в <ref id="references">.

<p>
Если вы ищете менее детализированные описания (в форме HOW-TO),
переходите к главе <ref id="package"> или другие соответствующие главы.
<p>
Эта статья основана на документах, взятых из "Debian FAQ", тщательным образом
реорганизованного в форму введения для обычного администратора системы Debian.

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">Архивы Debian

<sect1 id="dirtree">Структура каталогов

<p>  
Программное обеспечение, сформированное в debian-пакеты, доступно в одной из 
нескольких древовидных структур каталогов на каждом зеркальном сайте Debian
<url id="&mirror-site;" name="Debian mirror site"> по протоколам FTP или HTTP. 

<p>Следующие каталоги могут быть найдены на каждом зеркале Debian в каталоге
<file>debian</file>:
<taglist>
  <tag><file>dists/</file>:
   <item>Этот каталог содержит "дистрибутивы" и используется
         для канонического пути для доступа к имеющимся (в настоящее время)
         пакетам в релизах и пре-релизах Debian. Некоторые старые пакеты
         и файлы <file>Packages.gz</file> могут быть до сих пор и здесь. 
  <tag><file>pool/</file>:
    <item>Это новое физическое расположение всех пакетов релизов и пре-релизов Debian.
  <tag><file>tools/</file>:
    <item>DOS-утилиты для создания загрузочных дискет, разбиения
          вашего жесткого диска, сжатия/распаковки файлов и загрузки Linux.
  <tag><file>doc/</file>:
    <item>Это основная документация по Debian, такая как FAQ,
          инструкции по системе оповещения об ошибках и т.д.
  <tag><file>indices/</file>:
    <item>The Maintainers file and the override files.
  <tag><file>project/</file>:
    <item>материалы, в основном, для разработчиков. Это:
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>Этот каталог содержит пакеты и инструменты, которые находятся
	      в разработке или даже в альфа-тестировании. Пользователи не должны
	      использовать эти пакеты, так как они могут быть опасны и вредны даже для
	      достаточно опытных.
      <tag><file>project/orphaned/</file>:
        <item>Здесь находятся пакеты, которые 'осиротели' (т.е. остались без мейнтейнера)
	      и были изъяты из дистрибутива.
    </taglist>
</taglist>

<sect1 id="dists">Дистрибутивы Debian

<p>Обычно существует три дистрибутива Debian в каталоге <file>dists</file>.
Это дистрибутив <tt>stable</tt>, дистрибутив <tt>testing</tt> и дистрибутив
<tt>unstable</tt>. Иногда может быть еще и <tt>frozen</tt>. Каждый дистрибутив
определяется как символическая ссылка на реальный каталог под кодовым именем
в каталоге <tt>dists</tt>.

<sect1 id="stable">Дистрибутив <tt>stable</tt>

<p>Пакеты <tt>stable</tt> дистрибутива &stabledebian; записываются
   в каталог <file>stable</file> (символическая ссылка на каталог <file>&stablecodenamedir;/</file>):
<list>
  <item><file>stable/main/</file>:
  Этот каталог содержит пакеты, которые формально составляют самый свежий
  релиз системы &debian;.

  <p>Эти пакеты полностью отвечают <url name="Рекомендациям об открытом ПО в Debian (DFSG)"
   id="&social-contract;#guidelines"> (смотрите также файл <file>&f-social-contract;</file>
   из пакета <package>&p-social-contract;</package>) и являются полностью свободными к
   использованию и распространению. 

  <item><file>stable/non-free/</file>: Этот каталог содержит пакеты, распространение которых
        ограничено требованиями ряда копирайтов.

  <p>Например, некоторые пакеты имеют лицензию, которая запрещает коммерческую дистрибуцию.
     Другие могут распространяться в составе дистрибутива, но в действительности являются
     shareware и несвободным ПО. Лицензия каждого из этих пакетов должна быть изучена и
     учтена перед тем, как пакет будет включен в дистрибутив на CDROM и т.д.  
  
  <item><file>stable/contrib/</file>: Этот каталог содержит пакеты, которые сами по себе
       являются свободными (отвечают DFSG) и могут <strong>свободно распространяться</strong>,
       но неким образом зависят от <strong>несвободного</strong> пакета из non-free секции.
</list>
Теперь, в дополнение к выше указанным расположениям пакетов, пакеты физически располагаются
в каталоге <file>pool</file> (<ref id="pools">).

<p>Текущее состояние по найденным ошибкам в <tt>stable</tt> дистрибутиве отображается на
странице <url id="&stable-problems;" name="Stable Problems">.


<sect1 id="testing">Дистрибутив <tt>testing</tt>
<p>Пакеты для дистрибутива <tt>testing</tt>, &testingdebian;, записываются в
<file>testing</file> каталог (символическая ссылка на <file>&testingcodenamedir;/</file>)
после того, как они пройдут некоторое тестирование в <tt>unstable</tt>. Физически пакеты
располагаются в каталоге <file>pool</file>' (<ref id="pools">). В каталоге <file>testing/</file>
также имеются подкаталоги <file>main</file>, <file>contrib</file> и <file>non-free</file>, которые
выполняют те же функции, что и в дистрибутиве <file>stable/</file>.

<p>Для всех архитектур, под которые собираются пакеты дистрибутива <tt>testing</tt>,
обеспечивается синхронность версий, также эти пакеты не должны иметь зависимостей,
которые могли бы привести к невозможности их удалить, и должны иметь меньше критических
ошибок, чем версия, находящаяся сейчас в <tt>unstable</tt>. Таким образом, мы надеемся,
что <tt>testing</tt> всегда близок, чтобы стать кандидатом в релиз. Подробности о механизме
тестирования смотрите в документе <url id="&testing-notes;">.


<p>Самое последнее состояние дистрибутива <tt>testing</tt> публикуется на этих сайтах:

<list compact>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="проблемы testing">
<item><url id="&release-critical;" 
         name="критические ошибки">
<item><url id="&qa-base-bugs;" 
         name="ошибки в базовой системе">
<item><url id="&qa-standard-bugs;" 
         name="ошибки в стандартных пакетах и пакетах задач">
<item><url id="&qa-bugs;" 
         name="замечания по другим ошибкам и их исправлениям">
</list>

<sect1 id="unstable">Дистрибутив <tt>unstable</tt>

<p>Пакеты для <tt>unstable</tt> дистрибутива, который всегда имеет кодовое имя "Sid",
сохраняются в каталоге <file>unstable</file> (символическая ссылка на <file>sid/</file>)
сразу после того, как их закачают в Debian-архив и они находятся там до их перемещения
в <file>testing/</file>. Сами пакеты размещаются в каталоге <file>pool</file> (<ref id="pools">).
В каталоге <tt>unstable</tt> также существуют подкаталоги <file>main</file>, <file>contrib</file>
и <file>non-free</file>, которые выполняют те же функции, что и в дистрибутиве <file>stable/</file>.

Дистрибутив <tt>unstable</tt> содержит снимок разрабатываемой в настоящий момент системы.
Вы можете использовать и тестировать эти пакеты, осознавая состояние их готовности.
Преимущество от использования дистрибутива <tt>unstable</tt> в том, что вы всегда используете
самое последнее ПО из проекта &debian; &mdash оно является и самым нестабильным. 

<p>Текущее состояние ошибок в дистрибутиве <tt>unstable</tt> отображается
на странице <url id="&unstable-problems;" name="Unstable Problems">.

<!-- Above was enough
<sect1 id="sid">Дистрибутив Sid

<p>Sid или <tt>unstable</tt> это то место, куда большинство пакетов изначально
были закачены. Этот дистрибутив никогда не будет выпущен, так как пакеты, подлежащие этому выпуску
должны будут сначала помещены в <tt>testing</tt>, чтобы позже быть выпущены в составе <tt>stable</tt>.
Sid содержит пакеты под архитектуры, релиз которых уже был или еще нет.

<p>Имя "Sid" также пришло из анимационного фильма "Toy Story":
Sid был парнем по-соседству, который разрушал игрушки:-)
-->

<sect1 id="frozen">Дистрибутив <tt>frozen</tt>
<p>Когда дистрибутив <tt>testing</tt> достаточно созреет, он замораживается,
означая тем самым, что новый код более не принимается, а только исправления ошибок,
если таковые необходимы. Также, создается новое тестируемое дерево в каталоге
<tt>dists</tt> c новым кодовым названием. Замороженный дистрибутив проходит 
в течение нескольких месяцев фазу тестирования  с нерегулярными обновлениями и глубокими
заморозками, называемыми тест-циклами. (Недавний процесс создания релиза Woody
не создавал символическую ссылку <file>frozen</file>, таким образом <tt>frozen</tt>
не был дистрибутивом, а являлся просто стадией разработки дистрибутива 'testing'.)

<p>Мы ведем запись ошибок в замороженном дистрибутиве, которые могут задержать какой-либо
пакет от прохождения его в релиз или ошибок, которые могут задержать весь релиз от выхода.
В момент, когда количество ошибок понизится до максимально приемлемого значения, <tt>frozen</tt>
становится стабильным, он выпускается, а предыдущий стабильный дистрибутив становится <tt>obsolete</tt>
(устаревшим)( и переносится в архив).

<sect1 id="codenames">Кодовые имена дистрибутивов Debian

<p>Реальные имена каталогов в каталоге <file>dists</file>, такие как <file>&stablecodenamedir;/</file> и 
<file>&testingcodenamedir;/</file> являются просто кодовыми именами. Когда дистрибутив &debian; находится
в стадии разработки, он не имеет номера версии, зато имеет кодовое имя. Такое назначение кодовых имен упрощает
зеркалирование дистрибутива &debian;(если реальное имя каталога <file>unstable</file> менялось бы на
<file>stable/</file> (дистрибутив стал стабильным - прим. переводчика), то пришлось бы скачивать повторно
большое количество файлов).

<p>В настоящее время <file>stable/</file> - это символическая ссылка на каталог <file>&stablecodenamedir;/</file>,
а <file>testing/</file> - ссылка на <file>&testingcodenamedir;/</file>. Это означает, что <tt>&stablecodename;</tt>
является текущим стабильным дистрибутивом, а <tt>&testingcodename;</tt> находится в стадии тестирования.

<p><file>unstable/</file> - это постоянная символическая ссылка на каталог <file>sid/</file>,
так как Sid является всегда нестабильным дистрибутивом.

<sect1 id="oldcodenames">Кодовые имена прошлого

<p>Вот кодовые имена, которые уже использовались:
"Buzz" для релиза 1.1,"Rex" для релиза 1.2, "Bo" для релизов 1.3.x, "Hamm" для релиза 2.0,
"Slink" для релиза 2.1 и "Potato" для релиза 2.2.

<sect1 id="sourceforcodenames">Источник кодовых имен
<p>Имена дистрибутивов до сих пор были именами персонажей из фильма <em>Toy Story</em> от студии Pixar.

<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) был космонавтом
  <item><strong>Rex</strong> был тиранозавром,
  <item><strong>Bo</strong> (Bo Peep) была девочкой, ухаживающей за овечкой,
  <item><strong>Hamm</strong> был piggy bank
  <item><strong>Slink</strong> (Slinky Dog) был игрушечной собакой,
  <item><strong>Sarge</strong> был предводителем армии людей Зеленого Пластика,
  <item><strong>Potato</strong> был, конечно, мистером Картошечья Голова,
  <item><strong>Woody</strong> был ковбоем,
  <item><strong>Sid</strong> был парнем по-соседству, который сломал игрушки.
</list>
<!--
  more info in http://www.pixar.com/featurefilms/ts/index.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Etch (Etch-a-Sketch) (the blackboard)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">Каталог <file>pool</file>
<p>Исторически пакеты хранились в каталоге дистрибутива, для которого они были созданы.
Сам каталог дистрибутива находился в каталоге <file>dists</file>. Это вызывало различного
рода проблемы, в том числе и большой расход пропускной способности канала на зеркалирующих
серверах, когда производились большие изменения. 
<p>Теперь пакеты хранятся в большом "пуле", структурированном в соответствии с именем исходного пакета.
Чтобы сделать пул управляемым, он поделен на секции (<tt>main</tt>, <tt>contrib</tt>, и
<tt>non-free</tt>) и далее по первым буквам имени исходного пакета. Эти каталоги содержат несколько
файлов: бинарные пакеты для каждой архитектуры и пакеты с исходными текстами, на основе которых эти
бинарные пакеты были собраны.

<p>Вы можете выяснить, где размещается каждый пакет, выполнив команду типа
<tt>apt-cache showsrc <var>имя_моего_пакета</var></tt> и посмотрев на строку "Directory:".
Например, пакеты <package>apache</package> хранятся в <file>pool/main/a/apache/</file>. Так как
существует очень большое количество пакетов библиотек <tt>lib*</tt>, то они обрабатываются несколько
иначе. Например, пакеты <package>libpaper</package> хранятся в <file>pool/main/libp/libpaper/</file>.

<p>Каталоги <file>dists</file> все еще используются индексными файлами  
для программ типа <prgn>apt</prgn>. Также, на момент написания этого документа, 
старые дистрибутивы еще не сконвертированы использовать пулы, и поэтому в поле Directory заголовка пакета
Вы увидите пути, содержащие имена дистрибутивов типа <tt>potato</tt> или <tt>woody</tt>.

<p>Обычно Вам не нужно беспокоиться об этом, так как новая программа <prgn>apt</prgn> и,
вероятно, старые <prgn>dpkg-ftp</prgn> (смотрите <ref id="howtocurrent">) обработают это
без проблем. Если Вам нужно больше информации, смотрите
<url id="&pool-faq;" name="RFC: Реализация пула пакетов">.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Историческая справка относительно Sid

<p>Когда не существовало современного Sid, <!--FTP removed --> 
организация сайта с архивом Debian имела одни большой недостаток: существовало предположение,
что когда создавалась архитектура в текущем <file>unstable/</file>, она могла 
быть также выпущена, когда сам дистрибутив переходил в фазу релиза или <tt>stable</tt>. Для
множество архитектур это было неверным, что приводило к необходимости переноса соответствующих каталогов
в момент релиза (в <tt>unstable</tt> - прим. пер.). Такие перемещения
были непрактичными из-за повышенного расхода пропускной способности канала.


<p>Администраторы архива решали эту проблему в течение нескольких лет путем
помещения бинарных файлов для архитектур, которая не готова к выпуску, в специальный каталог,
называемый <file>sid</file>. Когда такая архитектура входила в фазу релиза, то в первое время
существовала ссылка из текущего <file>stable/</file> на <file>sid/</file>, and from then on
they were created inside the <file>unstable/</file>tree as usual. Это расположение вводило
в заблуждение пользователей.

<p>С приходом пула пакетов (смотрите <ref id="pools">) в процессе разработки дистрибутива Woody,
бинарные пакеты начали хранить в каноническом месте пула вне зависимости от дистрибутива,
и таким образом выпуск дистрибутива больше не вызывает повышенного расхода пропускной способности канала
на зеркалах (существует, однако,<strong> a lot of gradual  bandwidth
consumption throughout the development process</strong>).

<sect1 id="incoming">Пакеты, закаченные в <file>incoming/</file>

<p>Закаченные пакеты, находящиеся в <url id="&incoming;"> проходят проверку для гарантии того,
что они в действительности отправлены разработчиком Debian (в противном случае, т.е. случае
закачки пакета лицом, не являющимся мейнтейнером - закачка NMU, пакет помещается в под-каталог <file>DELAYED</file>).
Один раз в день пакеты из <file>incoming/</file> перемещаются в <file>unstable/</file>. 


<p>
В крайних случаях Вы можете пожелать установить пакеты из  <file>incoming/</file> до того, как они достигнут
<file>unstable/</file>.  
</sect1>

<sect1 id="snapshot">Доступ к старым пакетам
<p>В то время, как самые последние дистрибутивы Debain хранятся в каталоге 
<file>debian</file> на каждом <url id="&mirror-site;" name="зеркале Debian">, 
архивы старых дистрибутивов типа Slink хранятся по адресу <url id="&archivehome;"> или 
в каталоге <file>debian-archive</file> на каждом зеркале Debian. 
<p>
Пакеты старых <tt>testing</tt> и <tt>unstable</tt> дистрибутивов могут быть найдены по адресу
<url id="&snapshothome;">.

</sect1>

<sect1 id="archsections">Секции архитектрур
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>Внутри каждого основного дерева каталогов (<file>dists/stable/main</file>,
<file>dists/stable/contrib</file>, <file>dists/stable/non-free</file>, 
<file>dists/unstable/main/</file>, и пр.), бинарные пакеты размещаются в под-каталогах,
чьи имена обозначают архитектуру процессора, под которую эти пакеты были собраны.

<list>
  <item><file>binary-all/</file> - для архитектурно-независимых пакетов.
    Сюда относятся, например, скрипты на языке Perl, документация.
  <item><file>binary-<var>platform</var>/</file> - для пакетов, которые могут исполняться на определенной 
  аппаратной платформе.
  <!-- Yes I simplified this -->
</list>

<p>Обратите внимание, что бинарные пакеты дистрибутивов <tt>testing</tt> и
<tt>unstable</tt> теперь размещаются не в описанных каталогах, а каталоге верхнего уровня
<file>pool</file>. Индексные файлы типа (<file>Packages</file> и
<file>Packages.gz</file>) тем не менее хранятся для обратной совместимости.

<p>В каждом дистрибутиве для поддерживаемых аппаратных архитектур существуют Release Notes.
Их можно найти на странице Release Notes соответствующего дистрибутива:
<url id="&stable-release;" name="stable"> и 
<url id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">Исходный код

<p>Для всех компонентов системы Debian имеется исходный код. Более того,
условия лицензий большинства программ в системе <strong>требуют</strong>, чтобы
исходный код распространялся вместе с программой, либо был бы способ его получить.

<p>Обычно исходный код располагается в каталогах <file>source</file>,
находящиеся по-соседству с каталогами архитектур, или, с недавнего времени,  
в каталоге <file>pool</file> (смотрите <ref id="pools">). Чтобы получить 
исходный код пакета, не вникая в структуру архива <!--FTP--> Debian, используйте команду
<tt>apt-get source <var>mypackagename</var></tt>.

<p>Некоторые пакеты, например <package>pine</package>, доступны только в виде
исходных текстов из-за ограничений лицензии. (Недавно был представлен пакет
<package>pine-tracker</package> для облегчения установки Pine.) Процедуры, описанные
в <ref id="port"> и <ref id="packaging"> описывают способы ручной сборки пакетов.


<p>Исходный код для пакетов из каталогов <file>contrib</file> и <file>non-free</file>, 
может отсутствовать, так как пакеты из этих каталогов формально не являются часть системы Debian.

<sect id="pkg-basics">Система управления пакетами в Debian

<sect1 id="package-basics">Обзор пакетов Debian

<p>Пакеты, как правило, содержат все необходимые файлы для реализации какого-либо набора
команд или возможностей.  Существует два типа пакетов Debian:

<list>
  <item><strong>Бинарные пакеты</strong>, которые содержат исполняемые и конфигурационные файлы,
  страницы руководств в формате man/info, информацию о копирайтах и другую документацию.
  Эти пакеты распространяются в специальном архивном формате Debian
  (смотрите <ref id="deb-format">) и обычно выделяются наличием <tt>.deb</tt> расширения файлов.
  Бинарные пакеты могут быть распакованы при помощи утилиты Debian <prgn>dpkg</prgn>; подробности
  приведены в ее man-странице.
  
  <item><strong>Пакеты с исходным текстом</strong>, которые состоят из <tt>.dsc</tt> файла,
  описывающего пакет (включая имена далее идущих файлов), файла <tt>.orig.tar.gz</tt>, который
  содержит немодифицированный исходный код в формате tar и упакованный программой gzip, и обычно
  файл <tt>.diff.gz</tt>, который содержит изменения исходного текста, специфичные для Debian.
  Утилита <prgn>dpkg-source</prgn> упаковывает и распаковывает пакеты Debian с исходными текстами;
  подробности смотрите в ее man-странице.
</list>

<p>Установка программного обеспечения при помощи пакетной системы использует так называемые
"зависимости", которые тщательно спроектированы мейнтейнерами пакета.  Эти зависимости
задокументированы в файле <file>control</file>, связанным с каждым пакетом.
Например, пакет, содержащий компилятор GNU C (<package/gcc/) "зависит" от пакета <package/binutils/,
который включает в себя компоновщик и транслятор. Если пользователь попытается установить <package/gcc/
без предварительной установки <package/binutils/, система управления пакетами (dpkg) выведет сообщение
об ошибке, что также необходима установка <package/binutils/, и прервет установку
<package/gcc/. (Однако, это поведение может быть изменено по требованию пользователя; смотрите
<manref name="dpkg" section="8">.) Дополнительные подробности смотрите <ref id="depends"> ниже.

<p>Инструменты для работы с пакетами Debian можно использовать для того, чтобы:
<list>
  <item>манипулировать и управлять пакетами или их частями,
  <item>помочь пользователю разбить пакеты, которые нужно передать на носителях ограниченного размера (флоппи-диски),
  <item>помочь разработчикам в создании архивов пакетов, 
  <item>помочь пользователям в установке пакетов, размещающихся на удаленном <!--FTP-->сайте архива Debian.
</list>

<sect1 id="deb-format">Формат Debian <!--binary--> пакета

<p>"Пакет" Debian или архивный файл Debian содержит исполняемые файлы, библиотеки
и документацию, ассоциированные с некоторым программмным комплектом или набором связанных программ.
Обычно архивный файл Debian имеет имя файла с расширением <tt>.deb</tt>.

<footnote>
<!-- Below added by Osamu based on a message posted by Colin Watson -->

<p>Проект <prgn>debian-installer</prgn> ввел имена файлов пакетов,
которые заканчиваются на <tt>.udeb</tt>.  Коротко, это микро-<tt>.deb</tt>
формат, который точно не следует политике Debian, не содержит документации
и должен использоваться только <prgn>debian-installer</prgn>, который является новым
установщиком Debian, разработанным для Sarge. Формат файла <tt>.udeb</tt> идентичен
формату <tt>.deb</tt>.  Программа <prgn>udpkg</prgn>, используемая для работы с
<tt>.udeb</tt> пакетами имеет ограниченные возможности по сравнению с
<prgn>dpkg</prgn> и меньше поддерживает связи пакетов.  Разница в имени существует
из-за того, что мейнтейнерам архива Debian не нравилось присутствие в архиве пакетов <tt>.deb</tt>,
которые не отвечали политике, поэтому для них было выбрано другое имя, чтобы подчеркнуть это и не допустить 
их непреднамеренную установку на рабочую систему. Пакеты <tt>.udeb</tt>
используются на <strong>initial</strong> ram-диске при установке базовой системы, только чтобы создать 
очень ограниченную систему Debian.
</footnote>

<p>Внутренние подробности этого формата бинарного пакета Debian описывются на
<manref name="deb" section="5"> man-странице. Так как внутренний формат может 
изменяться (от релиза к релизу &debian;), всегда используйте страницу
<manref name="dpkg-deb" section="8"> для манипулирования <tt>.deb</tt> файлами.


<!-- Below added by Osamu Not sure but should be right -->

<p>До дистрибутива Sarge включительно со всеми архивными файлами Debian
можно работать стандартными командами Unix типа <prgn>ar</prgn> и
<prgn>tar</prgn>, даже когда не доступны команды <prgn>dpkg</prgn>.


<sect1 id="pkgname">Соглашение об именах файлов Debian-пакетов
<!--
Why are Debian package filenames so long? 
-->
<p>Имена файлов пакетов Debian <!--binary--> подчиняются следующему соглашению:
<example>
<var>foo</var>_<var>НомерВерсии</var>-<var>номерDebianРевизии</var>.deb
</example>
где <var>foo</var> является именем пакета. Для проверки можно определить
имя пакета, связанное с некоторым архивным файлом (<tt>.deb</tt> file) одним
из следующих способов:
<list>
  <item>Изучить файл "Packages" в каталоге дистрибутива на архивном <!--FTP-->сайте
  Debian. Этот файл содержит записи, описывающие каждый пакет; первое поле в них - это
  формальное имя пакета.
  <item>Использовать команду <tt>dpkg --info <var>foo_VVV-RRR</var>.deb</tt> (где
  <var>VVV</var> и <var>RRR</var> - номера версии и ревизии запрашиваемого пакета,
  соответственно).  Команда отображает, помимо других данных, имя пакета, соответствующее
  изучаемому архивному файлу.
</list>

<p>Компонент <var>VVV</var> - это номер версии, указанный разработчиком программы (upstream developer).
Не существует стандарта о нумерации версий, поэтому они могут иметь различные форматы типа "19990513" 
или "1.3.8pre1".

<p>Компонент <var>RRR</var> - это ревизионный номер Debian, который указывается 
разработчиком Debian (или частным пользователем, если он пожелал собрать пакет самостоятельно).
Этот номер соответствует уровню ревизии пакета Debian, поэтому новый ревизионный номер обычно означает
изменения в Debian makefile (<file>debian/rules</file>), файле Debian control
(<file>debian/control</file>), скриптах установки или удаления 
(<file>debian/p*</file>), или конфигурационных файлах, используемых в пакете.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Сохранение текущей конфигурации
<!--
What is a Debian conffile
-->
<p>Сохранение файлов настройки реализуется через механизм "conffiles" системы &debian;. Файлы настройки
(обычно размещаемые в <file>/etc/</file>) указываются в файле <file>conffiles</file> системы пакетов Debian.
Cистема управления пакетами гарантирует, что при обновлении пакета эти файлы не будут перезаписаны.

<p>
When it is possible to configure the system without modifying files that belong
to various &debian; packages, it is usually a good idea not to modify them
even if they are "conffiles".  This ensures faster and smoother upgrade
operations.

<!--
<p>Файл Conffiles - список конфигурационных файлов (обычно размещаемых в <file>/etc</file>),
которые система управления пакетами не перезапишет при обновлении пакета. Это гарантирует, что
текущее содержимое этих файлов не будет изменено. Эта особенность является крайне необходимой,
поскольку позволет заменить пакеты на работающей системе.
-->

<p>Чтобы точно определить, какие файлы будут сохранены при обновлении пакета, выполните:
<example>
dpkg --status <var>package</var>
</example>
и смотрите под строкой "Conffiles:".

<p>
Подробности, связанные с содержимым Debian-файла <file>conffiles</file>, представлены
в руководстве по политике Debian, секция 11.7 (смотрите <ref id="references">).

<sect1 id="maintscripts">Скрипты сопровождения Debian
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->

<p><!--These files--> 
Скрипты сопровождения Debian это исполняемые скрипты, автоматически выполняемые перед или после
установки пакета. Вместе с файлом <file>control</file>, эти файлы являются частью секции "control"
архивного файла Debian.

<p>В частности, такими файлами являются:
<taglist>
<tag/preinst/
  <item>Этот скрипт выполняется до распаковки пакета, к которому он принадлежит,
  из архивного файла Debian (<tt/.deb/). Многие "preinst" скрипты останвливают сервисы обновляемых
  пакетов до окончания установки или обновления (с последующим
  успешным выполнением скрипта "postinst").

<tag/postinst/
  <item>Этот скрипт обычно завершает конфигурирование пакета после его распаковки
   из архивного файла Debian (<tt/.deb/). Часто скрипт "postinst"  запрашивает у пользователя некоторую
   информацию и/или предупреждает пользователя что, если он принимает значения по умолчанию, то 
   нужно будет не забыть переконфигурировать пакет, как это требуется. Многие скрипты "postinst"
   затем выполняют команды, необходимые для запуска или перезапуска сервиса после установки или обновления пакета.

<tag/prerm/
  <item>Этот скрипт обычно останавливает какие-либо демоны (сервисы - прим. переводчика), связанные с пакетом.
  Он выполняется перед удалением файлов пакета. 

<tag/postrm/
  <item>Этот скрипт обычно модифицирует ссылки или другие файлы, связанные с пакетом,
  и/или удаляет файлы, созданные им.
  (Смотрите также <ref id="virtual">.)
</taglist>

<p>В настоящее время все control-файлы могут быть найдены в каталоге
<file>/var/lib/dpkg/info</file>. Файлы, относящиеся к пакету <tt>foo</tt>
начинаются с имени  "foo" и, соответственно, имеют расширение файла типа "preinst", "postinst",
и так далее. Файл  <file>foo.list</file> в этом каталоге описывет все файлы, установленные с пакетом <tt>foo</tt>.
(Заметьте, что месторасположение этих файлов является внутренней особенностью программы <prgn>dpkg</prgn>, и 
поэтому может меняться.)


<sect1 id="priority">Приоритеты пакетов
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>В помощь системе управления пакетами каждому пакету Debian мейнтейнерами дистрибутива назначается приоритет
 <strong>priority</strong>. Приоритеты бывают:

<list>
  <item><strong>Required</strong> (требующиеся) пакеты, которые необходимы для правильного функционирования системы.
    <p>Сюда относятся все инструменты, которые необходимы для исправления повреждений системы.
    Вы не должны удалять эти пакеты, иначе Ваша система может стать неработоспособной, и Вы даже не сможете
    использовать программу <prgn>dpkg</prgn>, чтобы вернуть все назад. Системы с установленными только пакетами
    Required могут не соответствовать для решения большинства задач, но они имеет достаточно функций для того, чтобы
    позволить системному администратору загрузить и установить дополнительное программное обеспечение.

  <item><strong>Important</strong> (важные) пакеты должны быть найдены на любой Unix-подобной
    системе.
    <p>Пакеты с таким приоритетом - это остальные пакеты, без которых система не будет нормально работать или не будет 
    удобной. Сюда <strong>не</strong> относятся пакеты типа Emacs, X11, TeX или любые другие крупные приложения.
    Эти пакеты составляют минимальную инфраструктуру.

  <item><strong>Standard</strong> (стандартные) пакеты являются стандратными на любой Linux системе,
    включая разумно небольшую, но не ограниченную систему текстового режима.
    <p>Это то, что устанавливается по умолчанию, если пользователь ничего не выбрал.
    "Standard" не включает многих крупных приложений, но уже включает Emacs (Это больше часть инфрастурктуры,
    чем приложение.) и разумное подмножество систем Tex и LaTeX (разумное настолько, чтобы не требовать X11).

  <item><strong>Optional</strong> (опциональные) пакеты включает все те, которые вы можете захотеть установить, 
    даже если с ними не знакомы, и если не имеете специальных требований. 
    <p>Это включает X11, полностью TeX и множество приложений.

  <item><strong>Extra</strong> пакеты, которые или конфликтуют с другими более высокими приоритетами, несут малую
    пользу для пользователей, с ними незнакомыми, или имеют специальные требования, делающие их неподходящими к 
    "Optional".
</list>

<p>Пожалуйста, заметьте разницу между "Priority: required", "Section:
base" и "Essential: yes" в описании пакета.  "Section: base"
означает, что пакет устанавливается перед чем бы то нибыло на новой системе.
Большинство пакетов с "Section: base" имеют приоритет "Priority:
required" или  "Priority: important", и многие из них помечены как "Essential: yes".
"Essential: yes" означает, что при удалении этого пакета из системы необходимо указать
дополнительную форсирующую опцию системе управления пакетами <prgn>dpkg</prgn>. Например,
пакеты <package>libc6</package>, <package>mawk</package> и <package>makedev</package> являются
пакетами с приоритетом "Priority: required" из секции "Section: base", но не являются "Essential: yes".


<sect1 id="virtual">Виртуальные пакеты

<p>Виртуальный пакет - это общее имя, употребляемое к любому из пакетов некой группы, все пакеты из которой
обеспечивают подобную базовую функциональность. Например, пакеты <prgn>tin</prgn> и <prgn>trn</prgn> являются 
программами для чтения news-конференций, и любая из них должна, следовательно, удовлетворять зависимость
программы, требующей для нормального своего функционирования установленной программы чтения news-конференций.
Эти пакеты, таким образом, обеcпечивают "виртуальный пакет", называемый <package>news-reader</package>.

<p>Подобным образом, оба пакета <prgn>exim</prgn> и <prgn>sendmail</prgn> обеспечивают функциональность
почтового транспортного агента. Следовательно, они предоставляют виртуальный пакет
 <package>mail-transport-agent</package>. Если один из них установлен, то любая программа, зависящая от
наличия установленного почтового транспортного агента будет удовлетворена существованием этого виртуального пакета.

<p>Debian имеет такой механизм, что если в системе установлено более одного пакета, предоставляющего 
виртуальный пакет, то системный администратор может установить один из них, как предпочитаемый.
Для этого используется команда <prgn>update-alternatives</prgn>, описываемая далее <ref id="alternatives">.

<sect1 id="depends">Зависимости пакетов
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>Система пакетов в Debian имеет ряд "зависимостей" пакетов, 
которые предназначены для того, чтобы показать (одним признаком) уровень, на котором
программа A может работать независимо от существования программы B в данной системе:
<list>
  <item>Пакет A <strong>зависит</strong> (depends) от пакета B, если пакет B безусловно должен быть
    установлен для выполнения пакета A. В некоторых случаях, пакет A зависит не только от пакета B, а еще и от
    конкретной версии пакета B.  В этом случае зависимость от версии пакета означает нижний предел, в том смысле,
    что пакет А зависит от любой версии пакета B, не старее указанной версии.  
  <item>Пакет A <strong>рекомендует</strong> (recommends) пакет B, если мейнтейнер пакета решил, что большинство пользователей
    не захотят иметь пакет А без функциональности, предоставляемой пакетом B.
  <item>Пакет A <strong>предлагает</strong> (suggests) пакет B, если пакет B содержит файлы, относящиеся к (или обычно улучшающие)
    функциональности пакета A.
  <item>Пакет А <strong>конфликтует</strong> (conflicts) с пакетом B, когда пакет A не будет работать, если пакет B установлен
    в системе.  Более частый случай конфликта, когда пакет A содержит файлы, которые являются улучшением тех, 
    что находятся в пакете B. Статус "конфликтует" часто комбинируется с "заменяет".
  <item>Пакет A <strong>заменяет</strong> (replaces) пакет B, когда установленные файлы пакета B удаляются и, в некоторых
    случаях перезаписываются файлами пакета A.
  <item>Пакет A <strong>обеспечивает</strong> (provides) пакет B, когда все файлы и функциональность пакета B
    включается в состав пакета A. Этот механизм предоставляет для пользователей с ограниченным дисковым пространством 
    способ получить только реально нужную им часть пакета A.    
</list>

<p>Более подробную информацию об использовании каждого из этих терминов можно найти в
<em>Руководстве по созданию пакетов</em> и в <em>Руководстве по политике</em>.

<p>Заметьте, что программа <prgn>dselect</prgn> имеет более тонко настроенный 
контроль над пакетами, указываемыми зависимостями вида <strong>рекомендует</strong> и 
<strong>предлагает</strong>, нежели программа <prgn>apt-get</prgn>, которая просто вытаскивает все
пакеты, указанные в зависимости <strong>зависит</strong> и не трогает все пакеты, указанные в зависимостях
пакета <strong>рекомендует</strong> и <strong>предлагает</strong>. Обе программы в современном виде используют
за основу систему APT.

<sect1 id="pre-depends">Значение "pre-depends"

<p>"Pre-depends" - специальный вид зависимости. В случае обычного пакета
программа <prgn>dpkg</prgn> распаковывает архивный файл пакета  (т.е., файл <tt>.deb</tt>)
вне зависимости от существования в системе файлов, от которых зависит данный пакет. Распаковка же,
по существу, означает, что  программа <prgn>dpkg</prgn> извлечет из архива <tt>.deb</tt> файлы,
подлежащие установке на Вашу файловую систему и разместит их на своих местах. Если данный пакет
<strong>зависит</strong> (depends) от наличия неких других пакетов на Вашей системе, то 
программа <prgn>dpkg</prgn> откажется завершить установку (выполняя действие "configure") до тех 
пор, пока требуемые пакеты не будут установлены. 

<p>Однако, существуют некоторые пакеты, даже распаковка которых при помощи программы <prgn>dpkg</prgn>
будет отменена, пока не будут разрешены определенные зависимости. Считается, что такие пакеты 
критично зависят ("pre-depend") (а как еще перевести "pre-depends? - прим. переводчика) от присутствия
некоторых других пакета(ов).  Проект Debian предоставил этот механизм, чтобы поддержать безопасное
обновление систем с формата <tt>a.out</tt> на ELF формат, когда был критичен <strong>порядок</strong>,
в котором пакеты распаковываются.
Бывают еще другие ситуации крупных обновлений, где этот метод полезен, например, в случае пакетов
с приоритетом "Required" и их зависимостями от libc.

<p>Замечу, что более детальная информация об этом может быть найдена в 
<em>Руководстве по созданию пакетов</em>.

<sect1 id="pkgstatus">Статус пакета
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Статус пакета может быть "unknown" (неизвестный), "install" (установить), "remove" (удалить),
 "purge" (очистить)  или "hold" (удержать).

Эти предписывающие флаги показывают то, что пользователь желает сделать с пакетом (делая свой выбор 
в секции "Select" программы <prgn>dselect</prgn>, или прямо вызывая программу <prgn>dpkg</prgn>).

<p>Смысл эти значений:
<list compact>
  <item><strong>unknown</strong> (неизвестный) - пользователь никогда не показывал свою потребность в пакете.
  <item><strong>install</strong> (установить) - пользователь желает, чтобы пакет был установлен или обновлен.
  <item><strong>remove</strong> (удалить) - пользователь желает, чтобы пакет был удален, но
                не желает удалять никакие конфигурационные файлы.
  <item><strong>purge</strong> (очистить) - пользователь желает, чтобы пакет был полностью удален, включая 
                его конфигурационные файлы.
  <item><strong>hold</strong> (удержать) - пользователь желает, чтобы этот пакет не обрабатывался, т.е. 
                     он хочет сохранить его текущую версию с его текущим состоянием, каким бы оно не было.
</list>

<sect1 id="puttingonhold">Удержание пакетов от обновления
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->

<p>Существует два механизма для удержания пакета от обновления: 
через программу <prgn>dpkg</prgn> или, начиная с Woody, через систему APT.

<p>В случае с <prgn>dpkg</prgn>, сначала экспортируем список выбора пакетов:
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
Затем отредактируем получившийся файл <file><var>selections.txt</var></file>, изменив строку,
содержащую пакет, который хотим удержать, например  <package/libc6/, следующим образом:
<example>
libc6                       install
</example>
заменяем на:
<example>
libc6                       hold
</example>
Сохраням файл и перезагружаем его в базу данных <prgn>dpkg</prgn> таким способом:
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
Или, если вы знаете имя пакета для удержания, просто выполните:
<example>
echo libc6 hold | dpkg --set-selections
</example>
Эта процедура удерживает пакеты в процессе установки каждого пакета.

<p>Тот же самый эффект можно получить, используя программу <prgn>dselect</prgn>. Просто войдите
на экран [S]elect, найдите пакет, который желаете удержать в его настоящем состоянии
и нажмите клавишу `=' (или `H'). Изменения войдут в силу сразу после выхода из экрана [S]elect.


<p>Система APT в дистрибутиве Woody имеет новый альтернативный механизм 
для удержания пакетов во время процесcа выборки архива, используя <tt>Pin-Priority</tt>.
Смотрите man-страницу <manref name="apt_preferences" section="5">, а также <url id="&apt-howto;"> или
пакет <package>&p-apt-howto;</package>; глава <ref id="apt-preferences"> тоже содержит краткое объяснение.


<sect1 id="sourcepkgs">Пакеты с исходным текстом

<P>Пакеты с исходным текстом располагаются в каталоге  <file>source</file>, либо 
Вы можете скачать их вручную или использовать APT
<example>
apt-get source <var>foo</var>
</example>
чтобы их получить (смотрите man-страницу <manref name="apt-get" section="8">, чтобы настроить APT для этого).


<sect1 id="sourcebuild">Сборка бинарного пакета из пакета с исходным текстом

<p>Чтобы скомпилировать исходный текст пакета <tt><var>foo</var></tt>, Вам нужны будут все следующие файлы - 
<file><var>foo_*</var>.dsc</file>, <file><var>foo_*</var>.tar.gz</file> и <file><var>foo_*.diff</var>.gz</file>
(заметьте, что не существует файла <tt>.diff.gz</tt> для самого пакета Debian).

<p>Как только Вы их получите, и если у Вас установлен пакет <package/dpkg-dev/,
команда 
<example>
$ dpkg-source -x <var>foo_версия-ревизия</var>.dsc
</example>
распакует пакет с исходным текстом в каталог под именем <tt><var>foo-версия</var></tt>.

<p>Вызовите следущую команду, чтобы собрать бинарный пакет:
<example>
$ cd foo-версия
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
Далее,
<example>
# su -c "dpkg -i ../<var>foo_версия-ревизия_архитектура</var>.deb"
</example>
чтобы установить только что собранный бинарный пакет. Смотрите <ref id="port">.

<!-- Woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Создание новых пакетов Debian

<p>За детальной информацией по созданию новых пакетов читайте <em>Руководство новым
мейнтейнерам (New Maintainers' Guide)</em>, имеющееся в пакете <package/maint-guide/ или по адресу <url
id="&maint-guide;" name="&urlname;">.

<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--

<sect id="pkgtools">Инструменты управления пакетами
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Обновление системы Debian

<p>Одной из задач Debian является обеспечение совместимого пути обновления и надежного процесса
обновления, и мы всегда делали все от нас зависящее по созданию таких новых релизов, которые способны гладко обновить
предыдущие. Пакеты предупредят пользователя о важных моментах в процессе обновления и, зачастую, предоставят 
решение возможных проблем.

<p>Вам также нужно изучить документ Release Notes, который описывает подробности конкретных обновлений, размещающийся
на всех компакт-дисках с Debian, или по адресам <url id="&stable-release;"> и <url id="&testing-release;">.

<p>
Практическое руководство по обновлению представлено в <ref id="package">. Эта секция лишь описывает основные принципы.

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Способы обновления системы Debian

<p>Всегда можно просто, используя анонимный доступ по FTP или через программу <prgn>wget</prgn>
зайти в архив Debian, внимательно изучить каталоги, найти желаемый файл, скачать его, и, наконец, установить 
его при помощи программы <prgn>dpkg</prgn>. (Заметьте, что программа <prgn>dpkg</prgn> установит файлы обновления
на свое место даже на работающей системе.)  Иногда, однако, обновленный пакет потребует установки новой обновленной
версии еще одного пакета, и пока он не будет установлен, установка не будет завершена.


<p>Много людей сочли, что этот ручной способ расходует массу времени, так как Debian
развивается очень быстро &mdash; обычно каждую неделю закачивается множество новых пакетов. 
И их число увеличивается перед новым главным релизом.
Чтобы иметь дело с таким потоком, пользователи предпочитают использовать автоматизированную программу 
для обновления. Для этого существует несколько специальных инструментов управления пакетами.


<sect1 id="pkgtools">Обзор инструментов управления пакетами

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->

<p>Система управления пакетами в Debian имеет две цели: манипулирование собственно файлами пакетов
и выборка файлов пакетов из архива Debian. Программа <prgn>dpkg</prgn> выполняет первую задачу, система APT
and программа <prgn>dselect</prgn> последнюю.

<sect1 id="dpkg">Программа <prgn>dpkg</prgn>

<p>Это основная программа для манипулирования файлами пакетов; за полным описанием обращайтесь к 
man-странице <manref name="dpkg" section="8">.

<!-- "install dpkg" deleted because it's a required package -->

<p>Программа <prgn>dpkg</prgn> идет вместе с несколькими простыми дополнительными программами:

<list>
<item><prgn>dpkg-deb</prgn>: Манипулирует файлами <tt>.deb</tt>. 
 <manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>: Старая команда для выборки файлов пакетов. 
 <manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>: Старая команда для выборки файлов пакетов. 
 <manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>: Разбивает большой пакет на более мелкие файлы. 
 <manref name="dpkg-split" section="1">
</list>


Программы <prgn>dpkg-ftp</prgn> и <prgn>dpkg-mountable</prgn> были замещены 
введением системы APT.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">Система APT

<p>Система APT (Улучшенный инструмент для работы с пакетами) представляет собой улучшенный интерфейс к системе
управления пакетами в Debian, и состоит из нескольких программ, обычно начинающихся со префикса "apt-". 
Программы <prgn>apt-get</prgn>, <prgn>apt-cache</prgn> и <prgn>apt-cdrom</prgn> 
- это инструменты командой строки для манипулирования пакетами.  Они также функционируют как 
пользовательские программы-платформы (back end) для других инструментов, таких как <prgn/dselect/ 
и <prgn/aptitude/.

<p>Для дополнительной информации установите пакет <package/apt/ и прочтите соответствующие man-страницы:
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (Woody), а также 
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>Альтернативным источником информации является страница 
<url id="&apt-howto;" name="APT HOWTO">.
Она может быть установлена из пакета <package/apt-howto/, файл
<file>&f-apt-howto;</file>.

<p>Команды <tt>apt-get upgrade</tt> и <tt>apt-get dist-upgrade</tt>
обновляют только пакеты, описываемые как "Depends:" и просматривают все пакеты 
с зависимостями "Recommends:" и "Suggests:". Чтобы избежать этого, используйте
программу <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics">Программа <prgn>dselect</prgn>

<p>Это программа представляет собой управляемый с помощью меню интерфейс к системе управления пакетами в Debian.
Она особенно полезна в первых установках или крупномасштабных обновлениях. Смотрите  <ref id="dselect">.

<p>Для дополнительной информации установите пакет <package/install-doc/ и изучите файл
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> или страницу по адресу
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single-user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <prgn>start-stop-daemon</prgn> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Обновление работающей системы

<p>Ядро (файловая система) в &debian; системах поддерживает замену файлов даже во время их использования.

<p>Мы также предоставляем программу, называемую <prgn/start-stop-daemon/, которая используется
для запуска демонов на этапе загрузки или для их останова, когда изменяется уровень исполнения ядра
(например, при переходе из многопользовательского в однопользовательский режим или в состояние "останов" /halt/).
Та же программа используется установочными скриптами, когда новый пакет содержит устанавливаемый демон, для остановки 
работающих демонов и их рестарта, если это необходимо.

<p>Заметьте, что система Debian не требует использования однопользовательского режима для обновления работающей 
системы.

<sect1 id="savedebs">Скаченные и кэшированные архивные файлы <tt>.deb</tt>

<p>Если Вы вручную скачали файлы пакетов на Ваш жесткий диск (что, кстати, совершенно
не нужно; смотрите описание программ <prgn>dpkg-ftp</prgn> или APT выше), то после установки пакетов
Вы можете удалить файлы <tt>.deb</tt> из системы.

<p>Если же используется система APT, то эти файлы кэшируются в каталоге 
<file>/var/cache/apt/archives</file>. Вы можете стереть их после установки
(командой <tt>apt-get clean</tt>) или скопировать их в каталог <file>/var/cache/apt/archives</file>
другой машины с целью экономии входящего трафика при последующих установках.

<sect1 id="keepingalog">Журналирование (record-keeping) процесса обновления

<p>Программа <prgn/dpkg/ хранит записи о пакетах, которые были распакованы,
сконфигурированы, удалены, и/или очищены, но не хранит (в настоящее время) журнал
действий пользователя на терминале во время работы с пакетами.

<p>Самый простой путь исправить это - это запускать сессию программы <prgn>dpkg</prgn>,
<prgn>dselect</prgn>, <prgn>apt-get</prgn>, и пр. c программой <manref name="script" section="1">.

<sect id="boot">Процесс загрузки Debian

<sect1 id="init">Программа <prgn>init</prgn>

<p>Как и все Unix-подобные операционные системы, Debian загружается, выполняя программу <prgn>init</prgn>.
Конфигурационный файл для <prgn>init</prgn> (<file>/etc/inittab</file>)
указывает, что первый скрипт, который должен быть выполнен, - это скрипт
<file>/etc/init.d/rcS</file>. Данный скрипт запускает все скрипты из каталога
<file>/etc/rcS.d/</file> по порядку (как перевести by sourcing ? - прим. перев.) или порождая подчиненные
процессы (в зависимости от расширения имени файла) с целью инициализации системы, как то проверка и монтирование
файловых систем, загрузка модулей, запуск сетевых сервисов, установка системных часов и пр. 
Далее (для совместимости) этот скрипт выполняет файлы из каталога <file>/etc/rc.boot/</file>
(кроме тех, что имеют `.' в имени файла). Любые скрипты из последнего каталога обычно предназначаются 
для использования системным администратором, и применение их в пакетах не допускается. За дополнительной
информацией обращайтесь к <ref id="init-hints"> или странице <url id="&sysvinit;"
 name="System run levels and init.d scripts"> Руководства по политике Debian.

<sect1 id="runlevels">Уровни выполнения 

<p>По окончании процесса загрузки программа <prgn>init</prgn> выполняет все стартовые скрипты
в каталоге, определяемым уровнем выполенения по умолчанию (это уровень выполнения задается 
элементом <tt>id</tt> в файле <file>/etc/inittab</file>).
Как и большинство <!-- all? SGK --> System V - совместимых Unix-систем, Линукс имеет 7 уровней выполнения:
<list compact>
  <item>0 (останов системы),
  <item>1 (однопользовательский режим),
  <item>2 - 5 (различные многопользовательские режимы), и
  <item>6 (перезагрузка системы).
</list>

<p>
Системы Debian идут с <tt>id=2</tt>, который показывает, что при входе в 
многопользовательский режим уровень выполнения по умолчанию - второй, и поэтому требуется выполнить скрипты 
из каталога <file>/etc/rc2.d/</file>.

<p>Скрипты в любом из каталогов <file>/etc/rc<var>N</var>.d/</file>,
по сути, являются символическими ссылками на скрипты из каталога <file>/etc/init.d/</file>. Однако,
сами <strong>имена</strong> файлов в каждом <file>/etc/rc<var>N</var>.d/</file> каталоге 
определяют <strong>способ</strong>, которым будут запущены скрипты из <file>/etc/init.d/</file>. 
Конкретнее, перед входом в любой уровень исполнения сначала запускаются все скрипты, начинающиеся с буквы `K';
данные скрипты останавливают сервисы. Далее выполняются все скрипты, начинающиеся в буквы `S'; эти 
скрипты запускают сервисы. Двузначное число после буквы `K' или `S' показывает
порядок, в котором выполняются скрипты. Скрипты с меньшим номером выполняются первыми.

<p>Это способ работает, так как все скрипты из каталога <file>/etc/init.d/</file> 
принимают аргумент с одним из возможных значений "start", "stop", "reload", "restart"
или "force-reload", и выполняют задачу, соответствующую значению данного аргумента.
Эти скрипты могут также использоваться после загрузки системы для управления различными процессами.

<p>Например, следующая команда с аргументом "reload"
<example>
# /etc/init.d/sendmail reload
</example>
посылает демону sendmail сигнал, побуждающий его перечитать конфигурационный файл.

<sect1 id="custombootscripts">Настройка процесса загрузки
<p>
Debian не использует свойственный BSD каталог <tt>rc.local</tt> для настройки процесса загрузки; вместо этого
он предоставляет следующий механизм.

<p>Предположим, системе нужно на этапе загрузки или при входе в определенный (System V) уровень выполнения
исполнить скрипт <tt>foo</tt>. Тогда системный администратор должен сделать:
<enumlist>
  <item>Разместить скрипт <tt>foo</tt> в каталоге <file>/etc/init.d/</file>.
  <item>Выполнить Debian-команду <prgn>update-rc.d</prgn> с соответствующими аргументами, чтобы создать
    символические ссылки между каталогами <tt>rc<var>?</var>.d</tt> (задаваемый в командой строке)
    и файлом <file>/etc/init.d/foo</file>. Здесь <var>?</var> - это номер от 0 до 6, который соответствует
    одному из System V уровней выполнения.
  <item>Перезагрузить систему.
</enumlist>

<p>Команда <prgn>update-rc.d</prgn> установит ссылки между файлами в каталоге <tt>rc<var>?</var>.d</tt> и
скриптом из <file>/etc/init.d/</file>. Каждая ссылка будет начинаться с `S' или `K'
с последующим номером и именем скрипта. Когда система входит в уровень выполнения <var>N</var>, из каталога 
<file>/etc/rc<var>N</var>.d/</file> скрипты, начинающиеся с `K', запускаются с аргументом <tt>stop</tt>, а потом 
оттуда же скрипты, начинающиеся с `S', запускаются с аргументом <tt>start</tt>.

<p>Например, можно настроить, чтобы скрипт <tt>foo</tt> выполнялся при загрузке, разместив его в каталог
<file>/etc/init.d/</file> и установив ссылки при помощи команды <tt>update-rc.d foo defaults 19</tt>. 
Аргумент <tt>defaults</tt> ссылается на уровни выполнения по умолчанию, которые могут быть от 2 до 5. Аргумент
<tt>19</tt> обеспечивает, что скрипт <tt>foo</tt> вызывается до любых других с номером 20 или больше.

<sect id="diverse">Поддержание многообразия программного обеспечения
<p>
Debian предлагает несколько путей удовлетворения любых потребностей системного администратора без
нарушений в системе: 
<list>
<item><prgn>dpkg-divert</prgn>, смотрите <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, смотрите <ref id="equivs">.
<item><prgn>update-alternative</prgn>, смотрите <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> поддерживает множество системных загрузчиков. 
      Смотрите страницы <manref name="make-kpkg" section="1"> и <ref id="kernel-debian">.
</list>

Любые файлы в каталоге <file>/usr/local/</file> принадлежат системному администратору 
и &debian; их не трогает. Большинство (или все) файлы в каталоге <file>/etc</file> являются  
<tt>конфигурационными</tt> файлами и &debian; их не будет перезаписывать при обновлениях, пока системный 
администратор явным образом этого не запросит.

<sect id="i18n">Интернационализация
<p>
Система  &debian; интернациональна и обеспечивает отображение и ввод символов 
на многих языках как в консоли, так в системе X Window. Множество документов, man-страницы и системные
сообщения переведены на многие языки, и их (языков) число растет. В процессе установки Debian просит 
пользователя выбрать язык инсталляции ( и даже иногда его местную вариацию).
<p>
Если Ваша установленная система не поддерживает все нужные Вам языковые особенности,
или Вам нужно изменить язык или установить другую раскладку клавиатуры для Вашего языка,
смотрите  <ref id="l10n">.

<sect id="kernel-details">Debian и ядро
<p>
Смотрите <ref id="kernel">.

<sect1 id="non-debian-kernel">Компиляция ядра, полученного не из Debian

<p><!--Yes.  But you have-->
Необходимо понимать политку Debian в отношении заголовочных файлов (headers).

<p>Библиотеки языка C в Debian собраны с самым свежим <strong>стабильным</strong>
релизом заголовков <strong>ядра</strong>.

<p>Например, релиз Debian 1.2 использовал версию заголовков 5.4.13.
Эта практика отличается от той, что в пакетах исходных текстов ядра Linux, распространяемых на всех FTP-архивах Linux,
где используются самые свежие версии заголовочных файлов.  Заголовочные файлы ядра распространяются вместе с ядром
и находятся в каталоге <file>/usr/include/linux/include/</file>.

<p>Если Вам нужно скомпилировать программу с более новыми заголовочными файлами, чем те, что 
предоставляются пакетом <package/libc6-dev/, то Вы должны добавить 
опцию <tt>-I/usr/src/linux/include/</tt> к Вашей командной строке при компиляции.
Например, это важно при сборке пакета демона автомонтирования (пакет  <package/amd/). Когда новые ядра изменяют
некоторые внутренние особенности работы с NFS, программе <prgn>amd</prgn> нужно знать об этом.
Это и требует включения самых последних заголовочных файлов.

<sect1 id="customkernel">Инструменты для построения ядер, настроенных пользователем

<p>Пользователям, желающим собрать настроенное ими ядро, предлагается скачать 
пакет <package/kernel-package/.  Данный пакет содержит скрипт для построения пакета с ядром и 
обеспечивает такую возможность посредством запуска команды:
<example>
# make-kpkg kernel_image
</example>
в каталоге верхнего уровня исходных текстов ядра. При помощи следующей команды можно получить 
справку:
<example>
# make-kpkg --help
</example>
также доступную на man-странице <manref name="make-kpkg" section="8"> и <ref id="kernel">.

<p>Пользователи должны кроме этого скачать исходный код наиболее свежего ядра
(или же ядра, которое им требуется) с любого предпочитаемого ими архивного сайта Linux
в случае недоступности пакета kernel-source-<var>версия</var> (где <var>версия</var> обозначает версию ядра).
Загрузочный скипт <file>initrd</file> в Debian требует специального патча к ядру, называющийся 
<prgn>initrd</prgn>; смотрите <url id="&bug-initrd;">.

<p>Подробные инструкции по использованию пакета <package/kernel-package/
даны в файле <file>/usr/share/doc/kernel-package/README.gz</file>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">Альтернативные системные загрузчики
<p>
Для использования альтернативных системных загрузчиков вроде <package/grub/ или
<package/loadlin/, скопируйте скомпилированное ядро <file>bzimage</file> в требуемое конкретным 
загрузчиком место (например, в <file>/boot/grub</file> или на раздел MS-DOS).
</sect1>

<sect1 id="custombootdisk">Загрузочные дискеты, настроенные пользователем

<p>Задача создания загрузочных дискет, настроенных под потребности пользователя, весьма упрощается
при использовании <!-- FIXME: boot-floppies is no package in Woody but an installation program
 Is this Potato specific? --> пакета <package/boot-floppies/, обычно находящегося в секции <tt>admin</tt> 
архива Debian. Скрипты командного интерпертатора в этом пакете производят загрузочные дискеты в формате
программы <prgn>syslinux</prgn>. Они представляют собой дискеты в формате MS-DOS с главной
загрузочной записью,  измененной таким образом, что они непосредственно загружают Linux  
(или другую операционную систему, определенную в файле <file>syslinux.cfg</file> на дискете).
Другие скрипты этого пакета производят аварийные корневые диски, а также могут 
сделать копию базовых дисков.

<p>Вы найдете больше информации об этом в файле <file>/usr/doc/boot-floppies/README</file> 
после установки пакета <package/boot-floppies/.

<sect1 id="modules">Специальное положение о том, как работать с модулями

<p>Пакет <package/modconf/ в Debian предоставляет скрипт командного интерпретатора
(<file>/usr/sbin/modconf</file>), который можно использовать для настройки конфигурации модулей.
Этот скрипт имеет меню-интерфейс, через который пользователь опрашивается об особенностях загружаемых
драйверов устройств в системе. Указанная пользователем информация используется для настройки файла
<file>/etc/modules.conf</file> (который содержит список алиасов и другие аргументы, используемые в сочетании
с различными модулями), при этом анализируются файлы из каталога <file>/etc/modutils/</file> и файл
<file>/etc/modules</file> (содержащий список модулей, требуемых своей загрузки при старте системы).

<p>Подобно файлам <file>Configure.help</file>, призванным помочь в создании
пользовательских ядер, пакет <package/modconf/ поставляется с набором файлов справки
(в каталоге <file>/usr/share/modconf/</file>), которые предоставляют подробную информацию
о соответствующих аргументах каждого модуля. Примеры смотрите в <ref id="kernel-modules">.

<sect1 id="removeoldkernel">Удаление из системы старого пакета с ядром

<p>Скрипт <prgn>kernel-image-<var>NNN</var>.prerm</prgn> (запускаемый перед удалением пакета с ядром - прим. переводчика)
проверяет на совпадение ядро, которое сейчас работает, с ядром, которое Вы пытаетесь удалить из системы. 
Таким образом, Вы можете безопасно удалять ненужные пакеты с ядром, используя данную команду:
<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(Конечно же, замените <var>NNN</var> на номер версии и ревизии Вашего ядра.)
</sect>
