<!-- CVS revision of this document "$Revision: 1.3 $"  -->
<!-- CVS revision of original english document "1.38"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="vcs">Version Control Systems

<sect id="cvs">Concurrent Versions System (CVS)
<p>
Check <file>/usr/share/doc/cvs/html-cvsclient</file>, 
<file>/usr/share/doc/cvs/html-info</file>,
<file>/usr/share/doc/cvsbook</file> with <prgn>lynx</prgn> or run
<tt>info cvs</tt> and <tt>man cvs</tt> for detailed information.

<sect1 id="cvs-inst">Installing a CVS server
<p>
The following setup will allow commits to the CVS repository only by a
member of the "src" group, and administration of CVS only by a member of
the "staff" group, thus reducing the chance of shooting oneself.
<example>
# cd <var>/var/lib</var>; umask 002; mkdir <var>cvs</var> # [Woody] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=<var>/var/lib/cvs</var>
# cd $CVSROOT
# chown root:src .  # "staff" to restrict more for starting project.
# chmod 3775 .             # If above uses "staff", use 2775
# cvs -d <var>/var/lib/cvs</var> init # safer to specify -d here explicitly!
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect1>

<sect1 id="cvs-examples">CVS session examples
<p>
The following will set up shell environments for CVS repository access.

<sect2>Anonymous CVS (download only)
<p>
Read-only remote access:
<example>
$ export CVSROOT=:pserver:<var>anonymous@cvs.sf.net:/cvsroot/qref</var>
$ cvs login
$ cvs -z3 co <var>qref</var>
</example>
</sect2>

<sect2>Use local CVS server
<p>
Local access from a shell on the same machine:
<example>
$ export CVSROOT=<var>/var/lib/cvs</var>
</example>
</sect2>

<sect2>Use remote CVS pserver
<p>
Remote access without SSH (use RSH protocol capability in 
<prgn>cvs</prgn>):
<example>
$ export CVSROOT=:pserver:<var>account@cvs.foobar.com:/var/lib/cvs</var>
$ cvs login
</example>
This is prone to eavesdropping attack.
</sect2>

<sect2>Use remote CVS through <prgn>ssh</prgn>
<p>
Remote access with SSH:
<example>
$ export CVSROOT=:ext:<var>account@cvs.foobar.com:/var/lib/cvs</var>
</example>
or for SourceForge:
<example>
$ export CVSROOT=:ext:<var>account@cvs.sf.net:/cvsroot/qref</var>
</example>
You can also use RSA authentication (<ref id="ssh-rsa">), which
eliminates the password prompt.
</sect2>

<sect2>Create a new CVS archive
<p>
For,
<example>
ITEM              VALUE               MEANING
source tree:      ~/<var>project-x</var>         All source codes
Project name:     <var>project-x</var>           Name for this project
Vendor Tag:       <var>Main-branch</var>         Tag for the entire branch
Release Tag:      <var>Release-initial</var>     Tag for a specific release
</example>
Then,
<example>
$ cd ~/<var>project-x</var>                # dive into source directory
 ... create a source tree ...
$ cvs import -m <var>"Start project-x" project-x Main-branch Release-initial</var>
$ cd ..; rm -R ~/<var>project-x</var>
</example>
</sect2>

<sect2>Work with CVS
<p>
To work with <var>project-x</var> using the local CVS repository:
<example>
$ cd                            # move to the work area
$ cvs co <var>project-x</var>              # get sources from CVS to local
$ cd <var>project-x</var>
 ... make changes to the content ...
$ cvs diff -u                   # similar to diff -u repository/ local/
$ cvs up -C <var>modified_file</var>       # undo changes to a file
$ cvs ci -m "<var>Describe change</var>"   # save local sources to CVS
$ vi <var>newfile_added</var>
$ cvs add <var>newfile_added</var>
$ cvs ci -m "<var>Added newfile_added</var>"
$ cvs up                        # merge latest version from CVS
 ... to create all newly created subdirectories from CVS, use 
 ... "cvs up -d -P" instead
 ... watch out for lines starting with "C <var>filename</var>"
 ... unmodified code is moved to `.#<var>filename</var>.version'
 ... search for "&lt;&lt;&lt;&lt;&lt;&lt;&lt;" and "&gt;&gt;&gt;&gt;&gt;&gt;&gt;" in <var>filename</var>
$ cvs tag <var>Release-1</var>             # add release tag
 ... edit further ...
$ cvs tag -d <var>Release-1</var>          # remove release tag
$ cvs ci -m "<var>more comments</var>"
$ cvs tag <var>Release-1</var>             # re-add release tag
$ cd                            # move back to the work area
$ cvs co -r <var>Release-initial</var> -d <var>old</var> <var>project-x</var>
 ... get original version to <var>old</var> directory
$ cd old
$ cvs tag -b <var>Release-initial-bugfixes</var> # create branch (-b) tag
 ... now you can work on the old version (Tag=sticky)
$ cvs update -d -P              # don't create empty directories
 ... source tree now has sticky tag "Release-initial-bugfixes"
 ... work on this branch
$ cvs up -d -P # sync with files modified by others on this branch
$ cvs ci -m "<var>check into this branch</var>"
$ cvs update -kk -A -d -P
 ... remove sticky tag and forget contents
 ... update from main trunk without keyword expansion
$ cvs update -kk -d -P -j <var>Release-initial-bugfixes</var>
 ... Merge from <var>Release-initial-bugfixes</var> branch into the main 
 ... trunk without keyword expansion.  Fix conflicts with editor.
$ cvs ci -m "<var>merge Release-initial-bugfixes</var>"
$ cd
$ tar -cvzf <var>old-project-x.tar.gz</var> <var>old</var>  # make archive, -j for bz2
$ cvs release -d <var>old</var>            # remove local source (optional)
</example>
Nice options to remember (use as first argument(s) to <prgn>cvs</prgn>):
<example>
-n      dry run, no effect
-t      display messages showing steps of cvs activity
</example>
</sect2>

<sect2>Export files from CVS
<p>
To get the latest version from CVS, use "tomorrow":
<example>
$ cvs ex -D tomorrow <var>module_name</var>
</example>
</sect2>

<sect2>Administer CVS
<p>
Add alias to a project (local server):
<example>
$ su - admin           # a member of staff
$ export CVSROOT=<var>/var/lib/cvs</var>
$ cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "<var>px</var> -a <var>project-x</var>" &gt;&gt;modules
$ cvs ci -m "<var>Now px is an alias for project-x</var>"
$ cvs release -d .
$ exit                 # or Ctrl-D to get back from su
$ cvs co -d <var>project</var> <var>px</var> 
 ... check out <var>project-x</var> (alias:<var>px</var>) from CVS to directory project
$ cd project
 ... make changes to the content ...
</example>
</sect2>

<sect1 id="cvs-trouble">Troubleshooting CVS

<sect2>File permissions in repository
<p>
CVS will not overwrite the current repository file but replaces it with
another one.  Thus, <em>write permission to the repository directory</em>
is critical. For every new repository creation, run the following to
ensure this condition if needed.
<example>
# cd <var>/var/lib/cvs</var>
# chown -R root:src <var>repository</var>
# chmod -R ug+rwX   <var>repository</var>
# chmod    2775     <var>repository</var>  # if needed, this and subdirectory
</example>
</sect2>

<sect2>Execution bit
<p>
A file's execution bit is retained when checked out.  Whenever you
see execution permission problems in checked-out files, change
permissions of the file in the CVS repository with the following command.
<example>
# chmod ugo-x <var>filename</var>
</example>
</sect2>

</sect1>

<sect1 id="cvs-short">CVS commands
<p>
Here are CVS commands with their shortcuts.
<example>
{add|ad|new} [-k kflag] [-m 'message'] files...
{admin|adm|rcs} [rcs-options] files...
{annotate|ann} [options] [files...]
{checkout|co|get} [options] modules...
{commit|ci|com}   [-lnR]  [-m  'log_message'  |  -f  file] \
        [-r revision] [files...]
{diff|di|dif} [-kl] [rcsdiff_options] [[-r rev1 | -D date1] \
        [-r rev2 |  -D date2]] [files...]
{export|ex|exp} [-flNn] -r rev|-D date [-d dir] [-k kflag] module...
{history|hi|his} [-report] [-flags] [-options args] [files...]
{import|im|imp} [-options] repository vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] rlog-options [files...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...
{release|re|rel} [-d] directories...
{remove|rm|delete} [-lR] [files...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  tag  |  -D  date] \
         symbolic_tag modules...
{status|st|stat} [-lR] [-v] [files...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r tag | -D date]  [-f] \
         symbolic_tag [files...]
{update|up|upd} [-AdflPpR] [-d] [-r tag|-D date] files...
</example>
</sect1>

<sect id="svn">Subversion
<p>
Subversion is a next-generation version control system that is intended
to replace CVS.  The developers currently consider it to be in the
"alpha" stage, but it is probably stable enough for most uses.  At the
time of this writing, Subversion is only available in Debian <tt>unstable</tt>.
<sect1 id="svn-inst">Installing a Subversion server
<p>
The <package>subversion-server</package> meta-package depends on the
packages needed (<package>libapache2-dav-svn</package> and
<package>subversion-tools</package>) to set up a server.
<sect2>Setting up a repository
<p>
Currently, the <package>subversion</package> package does not set up a
repository, so one must be set up manually.  One possible location for a
repository is in <file>/var/local/repos</file>.
<p>
Create the directory:
<example>
# mkdir -p /var/local/repos
</example>
Create the repository database:
<example>
# svnadmin create /var/local/repos
</example>
Make the repository writable by the WWW server:
<example>
# chown -R www-data:www-data /var/local/repos
</example>
</sect2>
<sect2>Configuring Apache2
<p>
To allow access to the repository via user authentication, add (or uncomment)
the following in <file>/etc/apache2/mods-available/dav_svn.conf</file>:
<example>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/local/repos
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt/Location&gt
</example>
Then, create a user authentication file with the command:
<example>
htpasswd2 -c /etc/subversion/passwd some-username
</example>
Restart Apache2, and your new Subversion repository will be accessible
with the URL http://<var>hostname</var>/repos.
</sect2>
</sect1>
<sect1 id="svn-cvs">Moving a CVS repository to Subversion
</sect1>
<sect1 id="svn-usage">Subversion usage examples
<p>
The following sections teach you how to use different commands in
Subversion.

<sect2>Create a new Subversion archive
<p>
To create a new Subversion archive, type the following:
<example>
$ cd ~/<var>your-project</var>         # go to your source directory
$ svn import http://localhost/repos <var>your-project</var> \
  <var>project-name</var> -m "initial project import"
</example>
<p>
This creates a directory named <var>project-name</var> in your
Subversion repository which contains your project files. Look at
http://localhost/repos/ to see if it's there.
</sect2>

<sect2>Working with Subversion
<p>
Working with <var>project-y</var> using Subversion:
<example>
$ cd                            # move to the work area
$ svn co http://localhost/repos/<var>project-y</var>  # Check out sources
$ cd <var>project-y</var>
 ... do some work ...
$ svn diff                      # similar to diff -u repository/ local/  
$ svn revert <var>modified_file</var>      # undo changes to a file
$ svn ci -m "<var>Describe changes</var>"  # check in your changes to the repository
$ vi <var>newfile_added</var>
$ svn add <var>newfile_added</var>
$ svn add <var>new_dir</var>               # recursively add all files in new_dir
$ svn add -N <var>new_dir2</var>           # nonrecursively add the directory
$ svn ci -m "Added <var>newfile_added</var>, <var>new_dir</var>, <var>new_dir2</var>"
$ svn up                        # merge in latest version from repository
$ svn log                       # shows all changes committed
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>project-y-branch</var> \
      -m "creating my branch of <var>project-y</var>"  # branching <var>project-y</var>
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>proj-y_release1.0</var> \
      -m "<var>project-y</var> 1.0 release"    # added release tag
 ... note that branching and tagging are the same. The only difference
 ... is that branches get committed whereas tags do not.

 ... make changes to branch ...

$ # merge branched copy back to main copy
$ svn merge http://localhost/repos/<var>project-y</var> \
   http://localhost/repos/<var>project-y-branch</var>
$ svn co -r 4 http://localhost/repos/<var>project-y</var> # get revision 4
</example>

</sect2>

</sect1>
</sect>
</chapt>
