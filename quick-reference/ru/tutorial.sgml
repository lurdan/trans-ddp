<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.76"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="tutorial">Руководство по &debian; 
<p>
<!-- new content -->
Эта секция поможет новичкам ориентироваться в мире &debian;.
Если Вы уже хотя бы немного использовали Unix-подобные операционные системы,
то, вероятно, знакомы со всем тем, о чем я здесь пишу. Пожалуйста, используйте
эту секцию для проверки своих знаний. 

<sect id="first">Введение
<p>
<!-- new content -->
После установки системы &debian; на Ваш ПК Вам нужно изучить несколько полезных
вещей.  Я предлагаю это сделать в форме экспресс-тренировки.

<sect1 id="login-root">Вход в систему как пользователь root
<p>
<!-- new content -->
Сразу после перезагрузки системы Вам представляется либо графический экран входа
в систему, либо текстовый - в зависимости от изначального выбора пакетов 
при установке. Для простоты, если Вы видите графический экран для входа,
нажмите Ctrl-Alt-F1, чтобы перейти к текстовому экрану входа в систему.
<footnote>
Клавиши Левый-Ctrl, Левый-Alt, и F1 нажимаются одновременно.
</footnote>
<p>
Предположим, что имя Вашей системы - <tt><var>foo</var></tt>,
тогда приглашение на вход будет таким:
<example>
<var>foo</var> login:
</example>
Наберите <tt>root</tt>, нажмите клавишу Enter и введите пароль, который Вы указывали 
в процессе установки.  В системе &debian; согласно традиций Unix пароль чувствителен к регистру.
После этого система выводит приветствие и представляет Вам приглашение командой строки
пользователя root, ожидая ввода.
<footnote>
Заметьте, приветствие может быть другим, если Вы редактировали файл <file>/etc/motd</file>.
</footnote>
<example>
<var>foo</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
Теперь Вы готовы к тому, чтобы заниматься системным администрованием 
через командую строку root. Учетная запись root также называется 
суперпользовательской или привелегированной. Используя эту учетную
запись,  Вы можете:
<list compact>
<item>Читать, записывать и удалять любые файлы в системе, независимо от установленных на них прав доступа
<item>Устанавливать владельцов и права доступа на любой файл в системе
<item>Устанавливать пароль любому непривелегированному пользователю в системе
<item>Регистрироваться в системе под любой учетной записью без ввода соответствующего пароля
</list>
<p>
Если Вам нужно дать кому-либо часть полномочий root, не стоит этого делать,
разделяя с ним пароль учетной записи root. Используйте для этого программы типа <manref name="sudo"
section="8">.
<p>
В Unix cчитается хорошей привычкой регистрироваться в системе, используя
непривелегированную учетную запись, даже если Вы собираетесь выполнять
некую административную работу. Используйте команды <tt>sudo</tt>, <tt>super</tt>,
или <tt>su -c</tt> для получения дозированных привилегий root, когда это необходимо.
Смотрите <ref id="sudo">.
<footnote>
Нужно сказать, что я работал под root чаще, чем это требовалось, 
так как это было проще, да и я был небрежен в этом отношении.
</footnote>

<sect1 id="newbiefix">Установка минимальной среды окружения для новичка
<p>
<!-- new content -->
Я думаю, что изучение компьютерной системы схоже с изучением нового иностранного
языка. И хотя учебники достаточно полезны, Вам нужно попрактивать с подручными инструментами.
В этом контексте я считаю, что хорошей идей будет установка нескольких дополнительных пакетов
типа <package>mc</package>, <package>vim</package>, <package>lynx</package>, 
<package>doc-linux-text</package> и <package>debian-policy</package>.

<footnote>
Также будет неплохо установить пакеты <package>gpm</package>, <package>emacs21</package>
и <package>doc-linux-html</package>. Смотрите <ref id="gpm"> и <ref id="edit">.
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
</example>
Если эти пакеты уже имеются в системе, то ничего не будет установлено.

<sect1 id="newuser">Добавление пользовательской учетной записи
<p>
<!-- new content -->
В процессе установки Вы обычно создаете учетную запись непривилегированногого 
пользователя, который будет получать электронную почту, адресованную root.
<footnote>
Я стараюсь задавать имя этого пользователя как <tt>admin</tt>, но 
оно может быть произвольным.
</footnote>
Если Вы не хотите использовать эту специальную учетную запись для последующего
обучения, Вам нужно создать еще одну пользовательскую учетную запись.
<p>
Предположим, что Вы захотели, чтобы ее имя было  <tt><var>penguin</var></tt>.
Тогда следущая команда:
<example>
root@<var>foo</var>:root# adduser <var>penguin</var>
... ответьте на все вопросы
</example>
создаст ее.
<footnote>
Возможно, Вы захотите добавить этого пользователя <tt><var>penguin</var></tt> в 
группу <tt>adm</tt>, чтобы разрешить чтение многих журналов событий (лог-файлов)
в каталоге <file>/var/log/</file>. Смотрите также <manref name="passwd" section="5">, <manref
name="group" section="5">, <manref name="shadow" section="5">, <manref
name="group" section="5">, <manref name="vipw" section="8">  и <manref
name="vigr" section="8">.
За официальным описанием пользователей и групп смотрите свежую версию документа  <url id="&f-users-and-groups;"
name="Пользователи и Группы">.
</footnote>
Перед тем, как идти дальше, мы должны сперва изучить еще несколько вещей.

<sect1 id="sw-console">Переключение между виртуальными консолями
<p>
<!-- modified old content -->
В системе &debian; по умолчанию существует шесть независимых
превдотерминалов, т.е. Вы можете использовать текстовый консольный экран VGA Вашего
персонального компьютера как 6 переключаемых терминалов VT-100. Переключение между
терминалами осуществляется одновременным нажатием клавиши левый-Alt и одной из
функциональных F1&ndash;F6. Каждый псевдотерминал позволяет независимую регистрацию в системе.
Это является проявлением такой важной черты Unix, как многопользовательность.
<p>
<!-- new content -->
Если Вы случайно нажали Alt-F7 на системе с работающей системой X Window
и видите графический экран, то для возврата к текстовым консолям нажмите 
Ctrl-Alt-F1. Для тренировки просто попытайтесь попереключаться на другую консоль
и возвращаться назад.

<sect1 id="shutdown">Как завершить работу системы
<p>
<!-- heavily modified content -->
Как любая современная операционная система, где файловые операции используют 
кэширование данных в памяти, система &debian; нуждается в соответствующей процедуре
завершения работы системы перед тем, как питание может быть безопасно выключено 
без повреждения целосности файлов. Используйте следующую команду в командой строке
root для завершения работы системы:
<example>
# shutdown -h now
</example>
Эта команда используется в нормальном многопользовательском режиме. Если же Вы в однопользовательском 
режиме, то в командной строке root используйте следующую команду:
<example>
# poweroff -i -f
</example>
Также Вы можете нажать  Ctrl-Alt-Delete для завершения работы системы.
<footnote>
Левая клавиша Ctrl, левая клавиша Alt и клавиша Delete нажимаются вместе, когда Вы находитесь
в консоли. В системе с настройками по умолчанию это приведет к перезагрузке.
Вам нужно изменить файл <file>/etc/inittab</file>, чтобы использовать 
опцию <tt>-h</tt> команды <prgn>shutdown</prgn>, как это было описано в разделе <ref id="post-inst">.
</footnote>
<p>
Подождите, пока система не отобразит сообщение "System halted", и только тогда 
выключайте питание. Если функции APM или ACPI надлежащим образом включены как в BIOS, так и в Linux,
то система выключит питание самостоятельно. Подробности смотрите в <ref id="apm">.

<sect1 id="playtime">Время поразвлечься
<p>
<!-- new content -->
Теперь Вы готовы без риска поиграть с системой &debian;, так как используете 
учетную запись непривилегированного пользователя <tt><var>penguin</var></tt>.
<footnote>
Это потому, что система &debian; даже после установки по умолчанию
настроена с такими правами доступа к файлам, которые предотвращают повреждение системы
непривилегированным пользователем. Конечно, все же могут существовать
некоторые дыры, которые могут использованы (для взлома системы - прим. переводчика), так что
те, кому эти вопросы небезразличны, должны вместо чтения этой секции изучить 
документ <url id="&securing-debian-howto;" name="Руководство по безопасности Debian">.
</footnote>
<p>
Давайте войдем в систему как пользователь <tt><var>penguin</var></tt>.   
Если Вы сейчас работаете как root, нажмите Ctrl-D 
<footnote>
Левая клавиша Ctrl и клавиша d нажимаются вместе. При этом нет необходимости
нажимать клавишу Shift, хотя эти управляющие символы даются в форме с верхним регистром 
буквы "D".
</footnote>
в командой строке, чтобы закрыть командный интерпретатор root'а и выйти на приглашение к входу в систему.
Введите Ваше только что созданное имя пользователя <tt><var>penguin</var></tt> и его пароль.
<footnote>
Если Вы ввели <tt>root</tt> вместо <tt><var>penguin</var></tt> и указали соответствующий
пароль, то Вы получите доступ к учетной записи <tt>root</tt>. Эта процедура будет нужна 
для получения прав <tt>root</tt>.
</footnote>
Вам будет показано следующее приглашение ко вводу команд.
<example>
<var>penguin</var>@<var>foo</var>:<var>penguin</var>$ 
</example>
<p>
С этого момента для простоты даваемые примеры будут использовать упрощенное
приглашение ко вводу команд. Я буду использовать:
<list compact>
<item><tt>#</tt> : для обозначения ввода команд от имени root 
<item><tt>$</tt> : для обозначения ввода команд от имени непривилегированного пользователя
</list>
<p>
Мы начнем изучение системы &debian; сначало по-простому через <ref id="mc">, а позже 
по-настоящему через <ref id="unixlike">. 

<sect id="mc">Midnight Commander (MC)
<p>
<!-- old content -->

Midnight Commander (MC) - это "Швейцарский армейский нож" от проекта GNU, применяемый в
консоли Linux и прочих терминальных средах. Он дает новичку опыт работы в консоли через
меню-подобный интерфейс, который гораздо проще изучить, чем стандартные команды Unix. 
<!-- New content -->
<p>
Используйте эту программу для изучения системы &debian;. Это самый лучший способ для изучения.
Пожалуйста, исследуйте следующие несколько ключевых мест, используя клавиши управления
курсором и Enter:
<list compact>
<item><file>/etc</file> и его подкаталоги.
<item><file>/var/log</file> и его подкаталоги.
<item><file>/usr/share/doc</file> и его подкаталоги.
<item><file>/sbin</file> и <file>/bin</file>
</list>

<sect1 id="mc-enhance">Улучшим MC
<p>
<!-- modified old content -->
Чтобы MC изменял рабочий каталог при выходе из него, Вам нужно
изменить файл <file>~/.bashrc</file> (или <file>/etc/bash.bashrc</file>, 
вызываемый из <file>.bashrc</file>) образом, описанным на соответствующей
man-странице <manref name="mc" section="1"> касательно опции <tt>-P</tt>.
<footnote>
Если Вы пока не поняли точно, что я имею в виду, можно сделать это позже.
</footnote>

<sect1 id="mc-start">Запуск MC
<p>
<!-- modified old content -->
<example>
$ mc
</example>
MC выполняет все операции с файлами через его меню, требуя от пользователя
минимум усилий. Для получения справки просто нажмите F1. Вы можете поиграть
с MC путем нажатий клавиш управления курсором и функциональных клавиш.
<footnote>
Находясь в терминалах типа <prgn>kon</prgn> или <prgn>kterm</prgn> для японского
языка, которые имеют проблемы с некоторыми графическими символами, поэтому добавьте 
опцию <tt>-a</tt> при запуске MC, чтобы разрешить эти проблемы.
</footnote>

<sect1 id="mc-fm">Файловый менеджер в MC
<p>
<!-- old content -->
По умолчанию отображаются две панели каталога со списками файлов. Еще один полезный
режим - это когда правое окно отображает информацию о режиме доступа к файлу и пр.
Далее описаны несколько важных клавишных комбинаций. С демоном <prgn>gpm</prgn>
можно также использовать мышь. (Обязательно нажмите клавишу Shift, чтобы 
получить нормальное поведение операций cut и paste в MC.)
<list compact>
<item>F1: Меню справки
<item>F3: Встроенный просмотрщик файлов
<item>F4: Встроенный редактор
<item>F9:  Вывести выпадающее меню
<item>F10: Выход из Midnight Commander
<item>Tab: Переход между панелями
<item>Insert: Пометить файл для операций с множеством файлов, например, для копирования
<item>Del: Удалить файл (будьте осторожны &mdash; установите MC в безопасный режим удаления)
<item>Клавиши управления курсором: понятно из названия
</list>

<sect1 id="mc-cl">Особенности командной строки в MC
<p>
<!-- old content -->
<list compact>
<item>Любая команда <prgn>cd</prgn> изменяет каталог, отображаемый на выбранной панели.
<item>Ctrl-Enter или Alt-Enter копирует имя файла в командную строку. Используйте это для 
команд <prgn>cp</prgn> или <prgn>mv</prgn> совместно с редактированием командной строки.
<item>Alt-Tab покажет список выбора командного интерпретатора с возможными именами файлов.
<item>Можно задать стартовые каталоги для обеих панелей через аргументы MC; например так:
 <tt>mc /etc /root</tt>.
<item>Esc + <var>цифра</var> == F<var>n</var> (т.е.,
      Esc + `1' = F1, и так далее;
      Esc + `0' = F10)
<item>Клавиша Esc == Клавише Alt (= Meta,
      M-); т.е., ввод Esc + `c' соответствует Alt-C.
<!-- control characters are referred with the upper case. -->
</list>

<sect1 id="mcedit">Редактор в MC
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
Встроенный редактор имеет интересную систему "вырезать-вставить". Нажатие F3
помечает начало выделения текста, повторное нажатие помечает конец выделения
и высвечивает выбранный текст. Теперь Вы можете передвигать Ваш курсор.
И если нажмете F6, то выделенная область будет перенесена в позицию курсора.
Если же Вы нажмете F5, то выделенная область будет скопирована в позицию курсора.
F2 сохраняет файл, F10 завершает работу редактора. Большинство курсорных клавиш
работают так, как Вы интуитивно преполагаете.
<p>
Этот редактор может быть запущен непосредственно для работы с файлом:
<example>
$ mc -e имя_файла_для_правки
$ mcedit имя_файла_для_правки
</example>
<p>
Данный редактор не является мультиоконным, но можно использовать множество линукс-консолей
для достижения похожего эффекта. Чтобы копировать между окнами, для переключения между
виртуальными консолями используйте клавиши Alt-F<var>n</var>,  
а для переноса части файла в другой используйте "Файл-&gt;Вставить файл" или "Файл-&gt;Копировать в файл"

<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I see .. but for now I do this not to hack LaTeX
-->
<p>
Встроенный редактор можно заменить любым внешним по Вашему выбору.
<p>
Также многие программы используют переменную окружения <tt>EDITOR</tt>
или <tt>VISUAL</tt> для определения, какой редактор использовать.
Если Вам неудобно в <prgn>vim</prgn>, установите эти переменные на <tt>mcedit</tt>,
добавив следующие строки в файл <file>~/.bashrc</file>:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
По возможности я рекомендую устанавливать эти переменные на <tt>vim</tt>.
Использование редактора <prgn>vim</prgn> предпочтительнее потому, что
он (а точнее vi) всегда существует на любой Linux/Unix системе.
<footnote>
Н самом деле, программы, которые есть везде, - это <prgn>vi</prgn> или <prgn>nvi</prgn>.
Для новичков же я предлагаю <prgn>vim</prgn>, так как он предоставляет справку по клавише F1,
оставаясь при этом достаточно простым и очень мощным.
</footnote>

<sect1 id="mc-view">Программа просмотра в MC
<p>
<!-- almost old content -->
Представляет собой очень интеллектуальную программу. Это великолепный инструмент для поиска слов 
в документах. Я использую эту возможность для файлов в каталоге <file>/usr/share/doc</file>. Это самый
быстрый способ просмотреть множество информации по Линукс. Программа просмотра может быть непосредственно
запущена таким образом:
<example>
$ mc -v имя_файла_для_просмотра
</example>

<sect1 id="ma-auto">Возможности MC по автоматическому запуску программ 
<p>
<!-- almost old content, tar.gz and deb are new -->
Нажмите клавишу Enter на файле и соответствующая программа будет 
обрабатывать содержимое файла. Это очень удобная возможность MC.
<example>
выполняемый файл:   Выполняет команду
файл  man, html-страницы:  Направляет содержимое в программу просмотра
файл tar.gz, deb:  Отображает содержимое файла как подкаталог
</example>
Чтобы позволить функционировать этим возможностям просмотра, просматриваемые файлы
не должны быть выполняемыми. Изменить их статус можно или через программу 
<prgn>chmod</prgn> или через меню MC.

<sect1 id="mc-ftp">Виртуальная FTP-файловая система MC
<p>
<!-- old content -->
MC можно использовать для доступа через Интернет к файлам, используя протокол FTP. 
Перейдите в меню, нажав F9, затем нажмите 'p' для активации виртуальной файловой системы FTP
(в моей версии MC работает клавиша 'F' - прим. переводчика) . Введите URL в форме
<tt>имя_пользователя:пароль@имя_хоста.имя_домена</tt>, после чего будет осуществлена 
выборка удаленного каталога, который будет представлен как локальный. 
<p>
<!-- new content -->
Попробуйте в качестве URL указать <tt>&ftp-debian;</tt> и просмотреть файловый архив &debian;.
Смотрите <ref id="ftparchives"> относительно того, как они (архивы) организованы.

<sect id="unixlike">Традиционная для Unix рабочая среда
<p>
<!-- new content -->
Хотя MC позволяет делать Вам практически все, очень важно изучить, как 
использовать инстументы командной строки, вызываемые из приглашения командного
интерпретатора и познакомиться с рабочей средой, традиционной для Unix.
<footnote>
В этой части руководства в качестве командного интерпретатора используется 
<prgn>bash</prgn>. О том, какие еще бывают командные интерпретаторы, смотрите в
<ref id="shell">.
</footnote>

<sect1 id="sp-keys">Специальные комбинации клавиш
<p>
<!-- practically new content -->
В традиционной unix-среде существует несколько комбинаций клавиш, которые 
имеют специальный смысл.
<footnote>
На нормальной текстовой консоли Linux только левая клавиша Ctrl и левая клавиша Alt
работают так, как ожидается.
</footnote>
<list compact>
<item>Ctrl-U: Удалить строку перед курсором.
<item>Ctrl-H: Удалить символ перед курсором.
<item>Ctrl-D: Завершить ввод. (при применении в командном интерпретаторе - выход из него)
<item>Ctrl-C: Завершить выполняющуюся программу.
<item>Ctrl-Z: Временно остановить программу. (поместить ее в фоновое задание, смотрите <ref id="cmd-back">)
<item>Ctrl-S: Остановить вывод на экран.
<footnote>
Вы можете запретить эту возможность, используя <manref name="stty" section="1">.
</footnote>
<item>Ctrl-Q: Продолжить вывод на экран.
</list>
<p>
Командный интерпретатор по умолчанию, <prgn>bash</prgn>, 
имеет возможности по хранению истории команд командной строки
и tab-completion для повышения интерактивности.

<list compact>
<item>стрелка вверх:  начинает поиск в истории команд.
<item>Ctrl-R:  начинает инкрементальный поиск в истории команд.
<item>TAB: Завершает ввод имени файла в командной строке.
<item>Ctrl-V TAB: Ввод символа табуляции TAB в командую строку без expansion.
</list>
<p>
Запомните еще несколько важных комбинаций клавиш:
<list compact>
<item>Ctrl-Alt-Del:  Перезагрузка/останов системы, смотрите <ref id="post-inst">.
<item>Левая клавиша мыши совместно с передвижением мыши: выделение и копирование текста в буфер обмена.
<item>Нажатие средней кнопки мыши: Вставить текст из буфера обмена в позицию курсора.
<item>Meta-клавиша (в терминологии Emacs) назначена по традиции на левую клавишу Alt.
      Некоторые системы могут быть настроены использовать Windows-клавишу в качестве Meta-клавиши.
</list>

Чтобы использовать мышь в текстовой консоли Linux, Вам нужно иметь запущенный демон <prgn>gpm</prgn>.
<footnote>
В среде X Window мышь в программе xterm работает так же.
</footnote>
Смотрите <ref id="gpm">.

<sect1 id="unixcmds">Основные команды Unix
<p>
<!-- new content -->
Давайте изучим основные команды Unix.
<footnote>
Здесь я использую имя "Unix" в самом общем смысле. Любой клон Unix обычно
предлагает эквивалентные команды. Система &debian; - не исключение.
Не расстраивайтесь, если некоторые команды не работают так, как Вы хотите.
И не обязательно выполнять данные примеры в указанном порядке.
</footnote>
Выполните все следующие команды от имени непривелегированного пользователя
<tt><var>penguin</var></tt>:
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>Отобразить имя текущего/рабочего каталога.
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>Отобразить имя текущего пользователя.
 </list>
<item><tt>file <var>foo</var></tt>
 <list compact>
 <item>Отобразить тип файла <var>foo</var>.
 </list>
<item><tt>type -p <var>имя_команды</var></tt>
 <list compact>
 <item>Отобразить месторасположение файла команды <tt><var>имя_команды</var></tt>.
 <item>Это же делает команда <tt>which <var>имя_команды</var></tt>.
 </list>
<item><tt>type <var>имя_команды</var></tt>
 <list compact>
 <item>Отобразить информацию по команде <tt><var>имя_команды</var></tt>.
 </list>
<item><tt>apropos <var>ключевое_слово</var></tt>
 <list compact>
 <item>Найти команды, связанные с <tt><var>ключевым_словом</var></tt>.
 <item>Это же делает команда <tt>man -k <var>ключевое_слово</var></tt>.
 </list>
<item><tt>whatis <var>имя_команды</var></tt>
 <list compact>
 <item>Отобразить однострочное пояснение по команде <tt><var>имя_команды</var></tt>.
 </list>
<item><tt>man -a <var>имя_команды</var></tt>
 <list compact>
 <item>Отобразить краткое пояснение по команде <tt><var>имя_команды</var></tt>. (Unix-стиль)
 </list>
<item><tt>info <var>имя_команды</var></tt>
 <list compact>
 <item>Отобразить более полное объяснение по команде <tt><var>имя_команды</var></tt>.  (стиль GNU)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>Вывести содержимое каталога. (нескрытые файлы  и каталоги)
  <footnote>
В Unix есть традиция скрывать имена файлов, которые начинаются с "<tt>.</tt>". Это, как правило,
файлы, которые содержат конфигурационную информацию и пользовательские настройки.
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>Вывести содержимое каталога. (все файлы и каталоги)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>Вывести содержимое каталога. (почти все файлы и каталоги, т.е. пропускаются файлы "<file>..</file>" 
  и "<file>.</file>")
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>Вывести все содержимое каталога с подробной информацией. Смотрите <ref id="file-system">.
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>Выводит все подкаталоги каталоги в текущем каталоге.
 </list>
<item><tt>lsof <var>foo</var></tt>
 <list compact>
 <item>Вывести состояние файла <tt><var>foo</var></tt> с точки зрения - открыт он или нет.
 </list>
<item><tt>mkdir <var>foo</var></tt>
 <list compact>
 <item>Создать новый каталог  <tt><var>foo</var></tt> в текущем каталоге.
 </list>
<item><tt>rmdir <var>foo</var></tt>
 <list compact>
 <item>Удалить каталог <tt><var>foo</var></tt> в текущем каталоге.
 </list>
<item><tt>cd <var>foo</var></tt>
 <list compact>
 <item>Перейти в каталог <file><var>foo</var></file>, находящийся в текущем каталоге
 или описанный в переменной <tt>CDPATH</tt>. Смотрите описание команды <prgn>cd</prgn> 
 в <manref name="builtins" section="7">.
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>Перейти в корневой каталог.
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>Перейти в домашний каталог текущего пользователя.
 </list>
<item><tt>cd /<var>foo</var></tt>
 <list compact>
 <item>Перейти в каталог по полному пути <file>/<var>foo</var></file>.
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>Перейти в родительский каталог.
 </list>
<item><tt>cd ~<var>foo</var></tt>
 <list compact>
 <item>Перейти в домашний каталог пользователя <tt><var>foo</var></tt>.
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>Перейти в предыдущий каталог.
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>Отобразить содержимое файла <file>/etc/motd</file>, используя программу постраничного вывода по умолчанию.
   Смотрите <ref id="cmd-stdin">.
  <footnote>
Функцию постраничного вывода по умолчанию в системе &debian; выполняет программа <prgn>more</prgn>, 
которая не может листать текст назад. Установив пакет <package>less</package> командой 
<tt>apt-get install less</tt>, <prgn>less</prgn> станет программой постраничного вывода 
по умолчанию и Вы сможете листать текст назад, используя клавишу управления курсором.   
  </footnote>
 </list>
<item><tt>touch <var>junkfile</var></tt>
 <list compact>
 <item>Создать пустой файл <file><var>junkfile</var></file>.
 </list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Копировать существующий файл <file><var>foo</var></file> в новый файл <file><var>bar</var></file>.
 </list>
<item><tt>rm <var>junkfile</var></tt>
 <list compact>
 <item>Удалить файл <file><var>junkfile</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Переименовать существующий файл <file><var>foo</var></file> в новый файл <file><var>bar</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
 <list compact>
 <item>Переместить существующий файл <file><var>foo</var></file> в новое месторасположение
  под новым именем <file><var>bar/baz</var></file>. Каталог <file><var>bar/</var></file> должен существовать.
 </list>
<item><tt>chmod 600 <var>foo</var></tt>
 <list compact>
 <item> Сделать существующий файл <file><var>foo</var></file> недоступным
 для чтения и записи для всех пользователей, кроме владельца, и запретить выполнение для 
 всех пользователей.
 </list>
<item><tt>chmod 644 <var>foo</var></tt>
 <list compact>
 <item>Разрешить чтение и запретить запись в существующий файл <file><var>foo</var></file> 
       всем пользователям, кроме владельца, выполнение запрещено всем.
 </list>
<item><tt>chmod 755 <var>foo</var></tt>
 <list compact>
 <item>Разрешить чтение и запретить запись в существующий файл <file><var>foo</var></file> всем пользователям,
       кроме владельца, выполнение файла разрешено всем пользователям.    
 </list>
<item><tt>top</tt>
 <list compact>
 <item>Показать информацию о процессах на весь экран. Используйте "q" для выхода.
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>Показать информацию о всех выполняющихся процессах в стиле вывода системы BSD.
   Смотрите <ref id="cmd-pipe">.
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>Показать информацию о всех выполняющихся процессах в стиле вывода системы Unix System-V.
 </list>
<item><tt>ps aux | grep -e "[e]xim"</tt>
 <list compact>
 <item> Показать все выполняющиеся процессы <prgn>exim</prgn>. Регулярные выражения для поиска
 можно изучить на man-странице <manref name="grep" section="1">, получить которую можно, набрав
 <tt>man grep</tt>. 
</list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item> Показать информацию о всех выполняющихся процессах, используя вывод в стиле "ASCII art".
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>Убить процесс по его идентификатору процесса: <var>1234</var>.
 Смотрите <ref id="kill">.
 </list>
<item><tt>grep -e "<var>образец</var>" *.html</tt>
 <list compact>
 <item>Найти "<var>образец</var>" во всех файлах, заканчивающихся на <tt>.html</tt> в текущем каталоге 
       и показать их всех.
 </list>
<item><tt>gzip <var>foo</var></tt>
 <list compact>
 <item>Сжать файл <file><var>foo</var></file> и создать файл <file><var>foo</var>.gz</file>, используя 
       кодирование Lempel-Ziv (LZ77).
 </list>
<item><tt>gunzip <var>foo</var>.gz</tt>
 <list compact>
 <item>Разжать файл <file><var>foo</var>.gz</file> для создания файла <file><var>foo</var></file>.
 </list>
<item><tt>bzip2 <var>foo</var></tt>
 <list compact>
 <item>Сжать файл <file><var>foo</var></file> и создать файл <file><var>foo</var>.bz2</file>, используя 
 алгоритм "Burrows-Wheeler block sorting text compression algorithm" и Huffman-кодирование. (Обеспечивает лучшее
 сжатие, чем <prgn>gzip</prgn>)
 </list>
<item><tt>bunzip2 <var>foo</var>.bz2</tt>
 <list compact>
 <item>Разжать файл <file><var>foo</var>.bz2</file> для создания файла <file><var>foo</var></file>.
 </list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
 <list compact>
 <item>Извлечь файлы из архива <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
 <list compact>
 <item>Извлечь файлы из архива <file><var>foo</var>.tar.gz</file>, сжатого gzip.
 </list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
 <list compact>
 <item>Извлечь файлы из архива <file><var>foo</var>.tar.bz2</file>.
  <footnote>
Здесь используется опция <tt>--bzip2</tt> вместо новой короткой опции <tt>-j</tt>,
чтобы команда работала со старыми версиями программы <prgn>tar</prgn> в Potato.
  </footnote>
 </list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
 <list compact>
 <item>Архивировать содержимое каталога <file><var>bar</var>/</file> в архивный файл
       <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
 <list compact>
 <item>Архивировать содержимое каталога <file><var>bar</var>/</file> в сжатый архивный
     файл <file><var>foo</var>.tar.gz</file>.
 </list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
 <list compact>
 <item>Архивировать содержимое каталога <file><var>bar</var>/</file> в сжатый архивный файл 
  <file><var>foo</var>.tar.bz2</file>.
  <footnote>
Опция <tt>--bzip2</tt> здесь также используется для совместимости.
  </footnote>
 </list>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>Отобразить содержимое сжатого файла <file>README.gz</file>, используя
       программу постраничного вывода по умолчанию.
 </list>
<item><tt>zcat README.gz &gt; foo</tt>
 <list compact>
 <item>Создать файл <file>foo</file> с разжатым содержимым файла <file>README.gz</file>.
 </list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
 <list compact>
 <item>Добавить разжатое содержимое файла <file>README.gz</file> в конец файла <file>foo</file>. (Если 
       файл не существует, то сначало создать его.)
 </list>
<item><tt>find . -name <var>шаблон</var></tt>
 <list compact>
 <item>Искать имена файлов, соответствующие шаблону <tt><var>шаблон</var></tt>. 
  (медленно)
 </list>
<item><tt>locate -d . <var>шаблон</var></tt>
 <list compact>
 <item>Искать имена файлов, соответствующие шаблону <tt><var>шаблон</var></tt>.
       (Работает быстрее благодаря использованию регулярно генерируемой базы данных)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
Пожалуйста, походите по каталогам и изучите систему, используя ранее описанные команды,
для тренировки. Если у Вас есть вопросы по любой из консольных команд, будьте добры
прочесть соответствующую man-страницу. Например, данные команды хороши для 
старта: 
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
Также неплохо запустить <prgn>vim</prgn> и нажать клавишу F1. Вам нужно
прочесть не менее 35 строк. Затем пройдите онлайновый курс обучения, передвинув курсор
к <tt>|tutor|</tt> и нажав Ctrl-]. Смотрите <ref id="edit"> для дополнительного изучения редакторов.
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
Пожалуйста заметьте, что многие Unix-команды, включая из GNU и BSD,
будут показывать краткую справочную информацию, если Вы вызовете их одним
из следующих способов (или, в некоторых случаях, без аргументов вовсе):
<example>
$ <var>имя_команды</var> --help
$ <var>имя_команды</var> -h
</example>
<p>
Для самоподготовки также посмотрите примеры из <ref id="tips">.

<sect1 id="cmd-exec">Выполнение команд
<p>
<!-- new content -->
Теперь Вы имеете представление о том, как использовать систему &debian;. 
Давайте внимательно взглянем на механизм выполнения команд в системе &debian;.
<footnote>
Здесь я для новичков несколько упрощаю действительность. Для точного описания 
смотрите <manref name="bash" section="1">.
</footnote>

<sect1 id="cmd-simple">Простая команда 
<p>
<!-- new content -->
Простая команда - это последовательность, состоящая из: 
<enumlist compact>
<item>необязательных присвоений переменных
<item>имени команды
<item>необязательных аргументов
<item>необязательных перенаправлений (<tt>&gt;</tt> , <tt>&gt;&gt;</tt> ,
<tt>&lt;</tt> , <tt>&lt;&lt;</tt> и пр.)
<item>необязательного оператор контроля (<tt>&amp;&amp;</tt> , <tt>||</tt> ;
&lt;newline&gt; , <tt>;</tt> , <tt>&amp;</tt> , <tt>(</tt> , <tt>)</tt>
)
</enumlist>
<p>
Для более сложных команд с кавычками и заменами смотрите <ref id="clprocess">.

<sect1 id="cmd-env">Выполнение команды и переменные окружения
<p>
<!-- new content -->
Рассмотрим следующую типовую последовательность команд:
<footnote>
Чтобы получить данный результат, Вам нужно установить французскую локаль, подробности
смотрите в <ref id="locales">. В данный момент это не существенно для нашего
руководства, просто это сделано, чтобы показать возможные эффекты.
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
Здесь выполняется программа <prgn>date</prgn>.
Переменная окружения <tt>LC_ALL</tt>:
<list compact>
<item>для первой команды не установлена (равна значению по умолчанию в системе; тоже самое, что и <tt>C</tt>)
<item>для второй команды установлена в <tt>fr_FR</tt> (французская локаль)
</list>
Обычно при выполнении команд определение переменных окружения отсутствует.
Для выше приведенного примера Вы можете сделать и так:
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
Как Вы видете, вывод команды зависит от переменной окружения. 
Если же  Вы хотите, чтобы переменная окружения наследовалась дочерними 
процессами (например, когда Вы запускаете скрипт на языке командного
интерпретатора), Вам нужно "экспортировать" ее таким образом: 
<example>
$ export LC_ALL
</example>

<sect1 id="cmd-path">Путь поиска команды
<p>
<!-- new content -->
Когда Вы даете команду командному интерпретатору, он ищет ее в
списке каталогов, содержащихся в переменной окружения <tt>PATH</tt>.
Значение этой переменной окружения называется путем поиска командного интерпретатора.
<p>
В системе &debian; по умолчанию переменная окружения <tt>PATH</tt> у пользовательской
учетной записи не включает каталог <file>/sbin</file>. Таким образом, если Вы хотите 
запускать любые команды вроде <prgn>ifconfig</prgn> из каталога <file>/sbin</file>
(без указания полного пути к команде - прим. переводчика), Вам нужно дополнить
значение переменной <tt>PATH</tt> каталогом <file>/sbin</file>. Эта переменная
обычно устанавливается в стартовом файле <file>~/.bash_profile</file>, подробнее <ref id="bashconf">.
 

<sect1 id="cmd-opt">Опции командной строки
<p>
<!-- new content -->
Некоторые команды принимают аргументы. Аргументы, начинающиеся с <tt>-</tt> или
<tt>--</tt>, называются опциями и управляют поведением команды.
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
Здесь аргумент командной строки <tt>-R</tt> изменяет поведение команды <prgn>date</prgn>
для вывода строки даты, соответствующей документу RFC-2822.

<sect1 id="cmd-wild">Шаблоны имени файла (wildcards) командного интерпретатора 
<p>
<!-- new content -->
Часто Вам нужно, чтобы команда работала с группой файлов без набора
всех их имен. Для описания группы файлов используются <strong>шаблоны</strong> имени файла
командного интерпретатора:
<list compact>
<item><tt>*</tt>
<list compact>
<item>Соответствует любой группе из нуля и более символов.
<item>Не соответствует имени файла с "<tt>.</tt>" в начале.
</list>
<item><tt>?</tt>
<list compact>
<item>Соответствует ровно одному символу.
</list>
<item><tt>[...]</tt>
<list compact>
<item>Соответствует ровно одному символу из тех, что заключены в скобки.
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>Соответствует ровно одному символу из тех, что между <tt>a</tt> и <tt>z</tt>.
</list>
<item><tt>[^...]</tt>
<list compact>
<item>Соответствует ровно одному символу, если он не среди тех, что перечислены в скобках (символ "^" - спецсимвол и
здесь на соответствие не проверяется).
</list>
</list>
<p>
Для примера попробуйте следующие команды и поразмышляйте над полученными результатами:
<example>
$ mkdir junk; cd junk; $ touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rmdir junk
</example>

<sect1 id="cmd-return">Код возврата команды
<p>
Каждая команда возвращает свой статус завершения как код возврата.
<list compact>
<item>код возврата равен нулю, если команда завершилась успешно.
<item>код возврата отличен от нуля, если команда завершилась с ошибкой.
</list>
Этот код возврата сразу после завершения команды может быть получен через переменную
командного интерпретатора <tt>$?</tt>.
<p>
Пожалуйста заметьте, что когда код возврата используется в логическом 
контексте командного интерпретатора, <strong>успешное завершение</strong> обрабатывается
как логическая <strong>ИСТИНА</strong>. Это некоторым образом нелогично,
так как <strong>успешное завершение</strong> соответствует значению  <strong>нуль</strong>.
<p>
Смотрите также <ref id="shell-cond">.

<sect1 id="cmd-typical">Типовые последовательности команд
<p>
<!-- new content in this whole sect1 ind sect2s -->
Постарайтесь запомнить следующие распространенные способы запуска команд.
А после этого посмотрите части <ref id="shell-param">, <ref id="shell-redirect">, 
<ref id="shell-cond"> и <ref id="clprocess">.

<sect2 id="cmd-back"><tt>команда &amp;</tt>
<p>
<prgn>команда</prgn> выполняется в дочернем командном интерпретаторе в <strong>фоновом режиме</strong>.
Задания в фоновом режиме позволяют пользователям запустить множество программ через один единственный командный
интерпретатор.
<p>
Управление фоновыми процессаами осуществляется через встроенные команды:
<prgn>jobs</prgn>, <prgn>fg</prgn>, <prgn>bg</prgn> и <prgn>stop</prgn>.
Пожалуйста изучите man-страницу <manref name="bash" section="1"> в части описаний "SIGNALS",
"JOB CONTROL" и "SHELL BUILTIN COMMANDS".
<footnote>
Система &debian; является мультизадачной операционной системой.
</footnote>
 
<sect2 id="cmd-pipe"><tt>команда1 | команда2</tt>
<p>
Стандартный поток вывода команды <prgn>команда1</prgn> направляется
в стандартный поток ввода команды <prgn>команда2</prgn>. Обе команды
могут выполняться <strong>одновременно</strong>. Этот механизм называется
программным каналом.

<sect2 id="cmd-list"><tt>команда1 ; команда2</tt>
<p>
Команды <prgn>команда1</prgn> и <prgn>команда2</prgn>
выполняются <strong>последовательно</strong>.
 
<sect2 id="cmd-and"><tt>команда1 &amp;&amp; команда2</tt>
<p>
Выполняется команда <prgn>команда1</prgn>. Если она завершается успешно,
за ней <strong>последовательно</strong> выполняется команда <prgn>команда2</prgn>.
Код возврата будет успешным, если обе команды <prgn>команда1</prgn> <strong>и</strong>
команда <prgn>команда2</prgn> завершились успешно.
 
<sect2 id="cmd-or"><tt>команда1 || команда2</tt>
<p>
Выполнятеся команда <prgn>команда1</prgn>. Если она завершается с ошибкой,
<strong>последовательно</strong> запускается команда <prgn>команда2</prgn>.
Код возврата будет успешным, если хотя бы одна из команд завершилась успешно.

<sect2 id="cmd-stdout"><tt>команда &gt; <var>foo</var></tt>
<p>
Перенаправить стандартный поток вывода команды <prgn>команда</prgn>
в файл <tt><var>foo</var></tt> (с перезаписью файла, если он существует)

<sect2 id="cmd-stdout2"><tt>команда &gt;&gt; <var>foo</var></tt>
<p>
Перенаправить стандартный поток вывода команды <prgn>команда</prgn>
в файл <tt><var>foo</var></tt>. (данные добавляются в конец файла)

<sect2 id="cmd-stderr"><tt>команда &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
Перенаправить потоки стандартного вывода и стандартного вывода ошибок
команды <prgn>команда</prgn> в файл <tt><var>foo</var></tt>. 

<sect2 id="cmd-stdin"><tt>команда &lt; <var>foo</var></tt>
<p>
Содержимое файла <tt><var>foo</var></tt> направляется в стандартный
поток ввода команды <prgn>команда</prgn>. Попробуйте следующее:
<example>
$ &lt;/etc/motd pager
 ... (приветствие)
$ pager &lt;/etc/motd
 ... (приветствие)
$ pager /etc/motd
 ... (приветствие)
$ cat /etc/motd | pager
 ... (приветствие)
</example>
Хотя все 4 конструкции покажут одно и то же, последний пример запускает
дополнительную команду <prgn>cat</prgn> и тем самым без причины расходует ресурсы.

<sect1 id="cmd-alias">Псевдоним команды
<p>
<!-- new content -->
Вы можете установить псевдоним для часто используемой команды. Например:
<example>
$ alias la='ls -la'
</example>
Теперь <prgn>la</prgn> работает как сокращенная форма <tt>ls -la</tt>, которая
выводит список всех файлов в полном формате  (лучший вариант был предложен
на кулере: alias ls='logout' - прим. переводчика ;-) )

<p>
Вы можете определить точный путь или подлинность команды, используя команду
<prgn>type</prgn>. Например:
<example>
$ type ls
ls is hashed (/bin/ls)       информация о ls хэширована (/bin/ls)
$ type la
la is aliased to `ls -la'    la - псевдоним `ls -la'
$ type echo 
echo is a shell builtin      echo - встроенная команда командного интерпретатора
$ type file
file is /usr/bin/file        команда file = /usr/bin/file
</example>
Здесь недавно выполнялся поиск команды <prgn>ls</prgn>, а команда <prgn>file</prgn>
искалась в первый раз, поэтому команда <prgn>ls</prgn> помечена как "hashed",
т.е. командный интерпретатор имеет внутренную запись для быстрого ответа на
запрос о месторасположении файла <prgn>ls</prgn>.

<sect id="text-process">Традиционная для Unix обработка текста
<p>
Существует несколько стандартных инструментов по обработке текста, которые
очень часто используются на unix-подобных системах.
<list compact>
<item>Неиспользующие регулярные выражения:
<list compact>
<item><prgn>head</prgn> выводит начало файлов.
<item><prgn>tail</prgn> выводит конец файлов.
<item><prgn>sort</prgn> сортирует строки текстовых файлов.
<item><prgn>uniq</prgn> удаляет строки-дубликаты из сортированного файла.
<item><prgn>tr</prgn> выполняет замену или удаление символов.
<item><prgn>diff</prgn> сравнивает построчно файлы.
</list>
<item>Использующие базовые регулярные выражения (БРВ):
<list compact>
<item><prgn>grep</prgn> определяет соответствие текста с шаблоном.
<item><prgn>ed</prgn> - примитивный строковый редактор.
<item><prgn>sed</prgn> - потоковый редактор.
<item><prgn>vi</prgn> - экранный редактор.
<item><prgn>emacs</prgn> - экранный редактор.
</list>
<item>Использующие расширенные регулярные выражения (РРВ):
<list compact>
<item><prgn>egrep</prgn> определяет соответствие текста с шаблоном.
<item><prgn>awk</prgn> выполняем простую обработку текста.
 Смотрите <ref id="awk">.
<item><prgn>perl</prgn> выполняет всевозможную обработку текста. 
 Смотрите <ref id="perl">.
</list>
</list>
Смотрите <ref id="perl-i">, <ref id="scrp-snip"> и <ref id="perl-mad"> 
на предмет примеров скриптов.


<sect1 id="regex">Регулярные выражения
<p>
Регулярные выражения используются во многих инструментах обработки текста.
Они очень похожи на шаблоны имен файлов командного интерпретатора (смотрите <ref id="cmd-wild">),
но они не только сложнее, но и мощнее. 
<p>
Регулярное выражение описывает шаблон соответствия и составляется из
символов текста и <strong>метасимволов</strong>. Метасимвол - это простой
символ со специальным смыслом. Существует два основных стиля регулярных выражений,
БРВ и РРВ, в зависимости от текстовых инструментов, описанных в <ref id="text-process">. 
<p>
Для РРВ <strong>метасимволы</strong> включают "<tt> \ . [ ] ^ &dollar; * + ? ( ) { } | </tt>".
Регулярное выражение означает:
<list compact>
<item><tt>c</tt>
<list compact>
<item>соответствие неметасимволу "<tt>c</tt>".
</list>
<item><tt>\c</tt>
<list compact>
<item>соответствие символу, определяемому escape-последовательностью "<tt>c</tt>", 
      или, если "<tt>c</tt>" не escape-последовательность, то просто символу "<tt>c</tt>".
</list>
<item><tt>.</tt>
<list compact>
<item>соответствие любому символу, включая символ новой строки.
</list>
<item><tt>^</tt>
<list compact>
<item>соответствие началу строки.
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>соответствие концу строки.
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>соответствие началу слова.
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>соответствие концу слова.
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>соответствие любому символу из списка "<tt>abc...</tt>".
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>отсутствие соответствия любому символу из списка "<tt>abc...</tt>".
</list>
<item><tt>r*</tt>
<list compact>
<item>соответствие регулярному выражению "<tt>r</tt>", повторенному ноль или большее количество раз.
</list>
<item><tt>r+</tt>
<list compact>
<item>соответствие регулярному выражению "<tt>r</tt>", повторенному один или большее количество раз.
</list>
<item><tt>r?</tt>
<list compact>
<item>соответствие регулярному выражению "<tt>r</tt>", повторенному ноль или один раз.
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>соответствие регулярному выражению "<tt>r1</tt>" либо регулярному выражению "<tt>r2</tt>".
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>соответствие регулярному выражению "<tt>r1</tt>" либо "<tt>r2</tt>"; конструкция
обрабатывается как регулярное выражение, <strong>заключенное</strong> в скобки.
</list>
</list>
<p>
В БРВ <strong>метасимволы</strong> "<tt> + ? ( ) { } | </tt>" теряют
свое особое значение, взамен используйте те же символы с обратным слешем
впереди "<tt>\+ \? \( \) \{ \} \| </tt>". Поэтому  конструкция с скобками
<tt>(r1|r2)</tt>, записанная с использованием БРВ, должна быть в виде <tt>\(r1|r2\)</tt>.
Однако программа <prgn>emacs</prgn>, использующая БРВ, обрабатывает символы "<tt> + ?</tt>"
как <strong>метасимволы</strong>. То есть нет необходимости предворять их обратным слешем. 
Смотрите <ref id="replaceex">, чтобы узнать, как используются конструкции со скобками.

<p>
Например, программа <prgn>grep</prgn> может быть использована для выполнения поиска текста
с использованием регулярных выражений:
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">Выражения подстановки
<p>
В выражениях подстановки следующие символы имеют особое значение:
<list>
<item><tt>&amp;</tt> 
<list compact>
<item>означает, какое регулярное выражение совпало.
(в программе <prgn>emacs</prgn> используйте конструкцию <tt>\&amp;</tt>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>означает совпавшее регулярное выражение, <strong>заключенное в скобки</strong>, по номеру <var>n</var>
</list>
</list>
Для выражений подстановки языка Perl используется конструкция 
<tt>&dollar;<var>n</var></tt> вместо <tt>\<var>n</var></tt> и
символ <tt>&amp;</tt> не имеет особого значения.
<p>
Например:
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
Здесь обратите дополнительное внимание на стиль регулярных 
выражений, <strong>заключенных в скобки</strong>, и на то, 
как совпавшие строки используются в процессе замены текста у 
разных инструментов.
<p>
Эти регулярные выражения могут быть использованы для перемещения курсора и
также для действий по замене текста в редакторах.
<p>
Пожалуйста, прочтите все связанные man-страницы для изучения этих команд.


<sect id="unixfile">Традиционная файловая система Unix
<p>
<!-- 
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
В системах GNU/Linux и других Unix-подобных операционных системах <strong>файлы</strong>
размещаются в <strong>каталогах</strong>. 
<footnote>
<strong>Каталоги</strong> на некоторых системах называются <strong>папками</strong>. 
</footnote>

Все <strong>файлы</strong> и <strong>каталоги</strong> образуют одно большое дерево,
иерархическую файловую структуру, корень которой <file>/</file>.
<p>
Эти файлы и каталоги могут располагаться на нескольких устройствах. Команда 
<manref name="mount" section="8"> занимается подключением файловой системы,
найденной на некотором устройстве в единое дерево файлов. И наоборот, команда
<manref name="unmount" section="8"> отсоединит файловую систему устройства из
дерева файлов.

<sect1 id="file-basics">Основы файлов Unix 
<p>
<!-- new content -->
Вот несколько основых положений:
<list compact>
<item>Имена файлов являются зависимыми от регистра. То есть,
файл <file>MYFILE</file> и файл <file>MyFile</file> являются <strong>различными</strong>
файлами.

<item>На корневой каталог (root) обычно ссылаются по имени <file>/</file>.
Не путайте этот "root" с пользователем root.  Смотрите <ref id="login-root">. 

<item>Каждый каталог имеет имя, которое может состоят из любых букв или символов,
<strong>кроме</strong> символа <file>/</file>. 
<footnote>
Хотя Вы и <strong>можете</strong> использовать почти любые буквы или символы в
имени файла, на практике это плохая идея. Лучше избегать использовать  
символы, которые часто имеют специальное значение в командой строке, включая
пробелы, символы табуляции, перевода строки и другие спецсимволы:
<tt>{ } ( ) [ ] ' ` " \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> .
<p>
Если Вы хотите отделить слова в имени, лучше используйте точку, дефис или 
подчеркивание. Вы можете также начинать каждое слово с большой буквы: <tt>ВотТак</tt>.
</footnote>
Корневой каталог является исключением, его имя - <file>/</file> (произносится как "слеш"
или "корневой каталог") и не может быть переименовано.

<item>На каждый файл или каталог можно сослаться по <strong>полному имени файла</strong>,
<strong>абсолютному имени файла</strong> или через <strong>путь</strong>, указав
последовательность каталогов, через которые нужно пройти, чтобы достичь файла. Все три 
термина являются синонимами. Все абсолютные имена начинаются с каталога <file>/</file>
и существует символ <file>/</file> между каждым каталогом или именем файла. Первый символ
<file>/</file> - это имя каталога, а все последующие являются просто разделителями,
чтобы отделить части имени файла друг от друга.
<p>
Чтобы не запутаться, посмотрите на следующий пример:
<example>
/usr/share/keytables/us.map.gz
</example>
Это полное имя файла, иногда некоторые называют его <strong>путем</strong>.
Однако, на файл можно сослаться просто по его имени <file>us.map.gz</file>.
<footnote> 
Существует также еще одно использование слова <strong>путь</strong>. Смотрите
<ref id="cmd-path">. В общем, значение слова обычно становится понятным из контекста,
в котором оно используется.
</footnote>

<item>Корневой каталог имеет множество ответвлений (подкаталогов - прим. переводчика), такие
как <file>/etc</file> или <file>/usr</file>. Эти подкаталоги в свою очередь
содержат еще подкаталоги, такие как <file>/etc/init.d</file> или <file>/usr/local</file> соответственно.
Все это вместе называется <strong>деревом каталогов</strong>. 
<p>
Вы можете считать, что абсолютное имя файла - это как маршрут из начала
дерева (<file>/</file>) к концу некоей ветви этого дерева (файлу). Вы также 
могли слышать, что о дереве каталогов говорят как о <strong>семейном</strong>
дереве: так подкаталоги имеют <strong>родителей</strong>, а путь показывает
полное происхождение файла. 
<p>
Существуют также относительные пути, которые начинаются с места, отличного от
корневого каталога. Вам нужно запомнить, что каталог <file>../</file> ссылается
на родительский каталог.

<item>Не существует каталога, который бы соответствовал физическому устройству, например, Вашему 
жесткому диску. В этом отличие Unix от операционных систем CP/M, DOS и Windows, где все пути начинаются 
с имени устройства, например, <tt>C:\</tt>. Смотрите <ref id="file-system">.
</list>

<p>
Хорошо описанные примеры по иерархии файлов есть в документе <url id="&f-fhs;"
 name="Стандарт на иерархию файловой системы">.
Вам же для начала нужно запомнить следующие факты:
<list compact>
<item><file>/</file>
<list compact>
<item>Просто символ <file>/</file> обозначает корневой каталог.
<p>
</list>
<item><file>/etc</file>
<list compact>
<item>Здесь размещаются конфигурационные файлы системы.
</list>
<item><file>/var/log</file>
<list compact>
<item>Здесь размещаются системные лог-файлы (журналы событий - прим. переводчика).
</list>
<item><file>/home</file>
<list compact>
<item>Здесь размещаются домашние каталоги все непривелегированных пользователей.
</list>
</list>

<sect1 id="file-system">Концепция файловой системы в &debian;
<p>
<!-- old content modified with fs.h reference -->
По традициям Unix система &debian; имеет файловую систему, ниже которой
находятся физические данные жестких дисков и других устройств хранения
информации, а также в унифицированном виде реализованы механизмы
взаимодействия с оборудованием, таким как консольные экраны,
удаленные последовательные консоли.

<p>
Каждый файл, каталог, именованный канал или физическое устройство в системе
&debian; имеет структуру данных, называющуюся <strong>индексным дескриптором</strong>
(inode), который описывает связанные атрибуты, такие как владелец файла,
группа, которая владеет файлом, время последнего доступа к файлу и пр. Точное описание
структуры <tt>inode</tt> в системе &debian; GNU/Linux смотрите в документе <url id="&f-inode-def;">. 

<p>
Это унифицированное представление физических устройств является очень мощной особенностью,
так как это позволяет нам использовать одну и ту же команду для выполнения однотипных действий
на множестве достаточно разнотипных устройств.
<p>
Все Ваши файлы могут размещаться на одном диске, или на 20 дисках: причем 
некоторые из них подключены к другим компьютерам где-то в сети. И хотя Вы не можете
просто так взглянуть на дерево каталогов, почти все команды работают точно также вне
зависимости от того, на каком физическом устройстве реально размещаются файлы. 
  

<sect1 id="file-perm">Права доступа к файлам и каталогам
<p>
<!-- old content -->
Права доступа к файлу и каталогу определяются
индивидуально для каждой из трех следущих категорий пользователей:
<list compact>
<item>для <strong>пользователя</strong>, который владеет этим файлом (u), 
<item>для пользователей из <strong>группы</strong>, владеющей данным файлом (g) и
<item>для всех <strong>остальных</strong> пользователей(o).
</list>
<p>
Для файла соответствующие права доступа позволяют соответственно:
<list compact>
<item><strong>право чтения</strong> (r): изучить содержимое файла
<item><strong>право записи</strong> (w): изменять файл
<item><strong>право выполнения</strong> (x): выполнять файл как команду.
</list>
<p>
Для каталога права доступа позволяют соответственно:
<list compact>
<item><strong>право чтения</strong> (r): получать список содержимого каталога
<item><strong>право записи</strong> (w): добавлять или удалять файлы в каталог
<item><strong>право выполнения</strong> (x): получать доступ к файлам.
</list>
Здесь право <strong>выполнения</strong> для каталога означает не только
возможность чтения файлов в каталоге, но и возможность просмотра 
их атрибутов, таких как размер и время модификации.
<p>
Чтобы отобразить информацию о правах доступа (и многую другую) на файлы и каталоги
используется программа <prgn>ls</prgn>. Смотрите <manref name="ls" section="1">.  
Когда программа <prgn>ls</prgn> запускается с опцией <tt>-l</tt>, она показывает
следующую информацию в указанном порядке:
<list compact>
<item><strong>тип файла</strong> (первый символ)
 <list compact>
 <item><tt>-</tt>: обычный файл
 <item><tt>d</tt>: каталог
 <item><tt>l</tt>: символическая ссылка
 <item><tt>c</tt>: файл символьного устройства
 <item><tt>b</tt>: файл блочного устройства
 <item><tt>p</tt>: именованный канал
 <item><tt>s</tt>: сокет
 </list>
<item><strong>Права</strong> доступа к файлу (следующие девять символов, объединенных 
в три группы прав для владельца, группы и прочих пользователей по три символа в каждой группе 
в порядке право-на-чтение право-на-запись право-на-выполнение) 
<item>количество <strong>ссылок</strong> на файл
<item>имя <strong>пользователя</strong>, владеющего файлом
<item>имя <strong>группы</strong>, владеющей файлом
<item><strong>размер</strong> файла в символах (байтах)
<item><strong>дата и время</strong> файла (mtime)
<item><strong>имя</strong> файла.
</list>
<p>
Чтобы изменить владельца файла, используется программа <prgn>chown</prgn>,
запущенная от имени учетной записи root. Чтобы изменить группу файла, используется
программа <prgn>chgrp</prgn>, запущенная от имени учетной записи владельца файла или root.
Для изменения прав доступа к файлу или каталогу используется программа <prgn>chmod</prgn>,
запущенная от имени пользователя-владельца файла/каталога или от имени пользователя root. 
Основной синтаксис работы с файлом-примером <file>foo</file> следующий:
<example>
# chown <var>новый_владелец</var> foo
# chgrp <var>новая_группа</var> foo 
# chmod  [ugoa][+-=][rwx][,...] foo 
</example>
Подробности смотрите в соответствующих man-страницах <manref name="chown" section="1">,
<manref name="chgrp" section="1"> и <manref name="chmod" section="1">.

<p>
Например, чтобы для некоторого дерева каталогов задать владельцем пользователя
<var>foo</var> и сделать группу <var>bar</var>, владеющей этим деревом, выполните
следующие команды от имени пользователя root:
<example>
# cd /некий/каталог/
# chown -R <var>foo</var>:<var>bar</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
Существует три бита специальных прав:
<list compact>
<item><strong>set user ID</strong> (в выводе ls выводится как s или S в позиции права выполнения для владельца),
<item><strong>set group ID</strong> (в выводе ls выводится как s или S в позиции права выполнения для группы), 
<item><strong>sticky bit</strong> (в выводе ls выводится как t или T в позиции права выполнения для прочих).
</list>
В выводе команде <prgn>ls -l</prgn> бит специального права выводится заглавной буквой (S или T),
если бит выполнения, который он скрыл собой, не установлен, и наоборот.

<p>
Установка бита <strong>set user ID</strong> на выполняемый файл позволяет
пользователю выполнить этот файл от имени владельца файла (например, <strong>root</strong>)
Подобным образом, установка бита <strong>set group ID</strong> на выполняемый файл позволяет
выполнить данный файл от имени группы, владеющей этим файлом, 
например, от имени группы <strong>root</strong>).
Так как эти установки могут создать серъезную дыру
в безопасности системы, устанавливайте эти биты очень внимательно.

<p>
Установка бита <strong>set group ID</strong> на каталог включает
схему создания файлов как системах BSD, где все файлы созданные в данном 
каталоге будут принадлежать группе <strong>group</strong>, владеющей
этим каталогом.
<p>
Установка бита <strong>sticky bit</strong> на каталог предотвращает 
удаление файлов в каталоге пользователями, ими не владеющими.
Для защиты содержимого файла в каталоге, в который разрешена запись всем,
например, <file>/tmp</file>, или в каталоге, в который разрешена запись
некоторой группе, нужно не только снять право <strong>записи</strong> в файл,
но и установить бит <strong>sticky bit</strong> на каталог. В противном случае
любой пользователь, имеющий право записи в этот каталог, может удалить этот файл
и создать новый с тем же именем (и с любым содержимым - прим. переводчика)

<p>
Вот несколько интересных примеров прав на файлы:
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
В командах <manref name="chmod" section="1"> существует альтернативный
числовой способ описания прав на файлы. Этот числовой способ использует
трех-четырехзначные восьмеричные (основание системы счисления = 8) числа.
Каждая цифра соответствует:
<list compact>
<item>Первая необязательная цифра: сумма атрибута <strong>set user ID</strong> (вес = 4),
       атрибута <strong>set group ID</strong> (вес = 2) и <strong>sticky bit</strong> (вес = 1)
<item>Вторая цифра: сумма  атрибута <strong>чтение</strong> (вес = 4), атрибута 
      <strong>запись</strong> (вес = 2) и атрибута <strong>выполнения</strong> (вес = 1), относящиеся
      к списку прав <strong>пользователя</strong>
<item>Третья цифра: то же самое для <strong>группы</strong>
<item>Четвертая цифра: то же самое для <strong>прочих пользователей</strong>
</list>
<p>
Это выглядит сложновато, но на самом деле все очень просто. Если вы посмотрите на
первые несколько столбцов (2-10) вывода команды <tt>ls -l</tt> и проинтерпретируете
их как двоичное (с основанием = 2) представление прав на файл ("-" означает "0", а "r", "w", "x"
означает "1"), то полученное число, переведенное в восьмеричную систему счисления
будет являться восьмеричным представлением прав на файл.
<footnote>
Конечно, это метод работает только для права, представленного тремя цифрами. 
</footnote>
Попробуйте для примера:
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
Маска прав на файл по умолчанию может быть установлена встроенной командой 
командного интерпретатора <prgn>umask</prgn>. Смотрите страницу <manref name="builtins" section="7">.
</sect1>

<sect1 id="timestamp">ВременнЫе метки (Timestamps)
<p>
<!-- old content, minor edit -->
У файла в системе GNU/Linux cуществует три типа временных метки:  
<list compact>
<item><strong>mtime</strong>: время модификации (<tt>ls -l</tt>),
<item><strong>ctime</strong>: время изменения состояния (<tt>ls -lc</tt>) и
<item><strong>atime</strong>: время последнего доступа (<tt>ls -lu</tt>).
</list>
Заметьте, что <strong>ctime</strong> не является временем создания файла.  
<list compact>
<item>Перезапись файла изменит каждую из временных меток <strong>mtime</strong>,
  <strong>ctime</strong> и <strong>atime</strong> файла.
<item>Изменение прав доступа или владельца файла изменит временные метки 
  <strong>ctime</strong> и <strong>atime</strong>.
<item>Чтение файла изменит временную метку <strong>atime</strong>.
</list>
Обратите внимание, что даже простое чтение файла в системе &debian; обычно
приводит к операции записи с файлом для обновления временной метки <strong>atime</strong>
в структуре <strong>inode</strong>. Монтирование файловой системы с 
опцией <tt>noatime</tt> позволит системе не делать эту операцию и приведет
к повышению скорости чтения. Смотрите страницу <manref name="mount" section="8">.
<p>
<!-- new content -->
Используйте команду <manref name="touch" section="1">для изменения временных меток существующих
файлов.
</sect1>

<sect1 id="links">Ссылки
<p>
<!-- old content -->
Существует два способа связать файл <var>foo</var> с другим именем файла 
<var>bar</var>.
<list compact>
<item><strong>жесткая ссылка</strong> - это имя-дубликат для существующего файла
       (<tt>ln <var>foo</var> <var>bar</var></tt>),
<item><strong>символичесая ссылка</strong> или "symlink" - это специальный файл, который указывает на другой файл
по его имени (<tt>ln -s <var>foo</var> <var>bar</var></tt>).
</list>
Смотрите следующий пример на предмет изменения счетчика ссылок и тонкую разницу
в результате команды <prgn>rm</prgn>
<example>
$ echo "Исходное содержимое" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # жесткая ссылка
$ ln -s <var>foo</var> <var>baz</var>  # символическая ссылка
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "Новое содержимое" &gt; <var>foo</var>
$ cat <var>bar</var>
Исходное содержимое
$ cat <var>baz</var>
Новое содержимое
</example>
<!-- minor update below -->
Символическая ссылка всегда имеет номинальные права доступа файла "rwxrwxrwx",
как это было показано в предыдущем примере, и эффективные права доступа 
соответствующие правам доступа файлу, на который ссылка указывает.
<p>
Каталог <file>.</file> является ссылкой на сам каталог, в котором он находится,
то есть счетчик ссылок любого нового каталога начинается с 2. Каталог <file>..</file>
ссылается на родительский каталог, поэтому счетчик ссылок каталога увеличивается
с добавлением новых подкаталогов.

<sect1 id="fifo">Именованные каналы (FIFOs)
<p>
<!-- DDP Debian Tutorial content -->
<p>
Именованный канал - это файл, которые действует как труба. Вы помещаете что-то
в данный файл, и оно выходит с другого конца. Это называется FIFO или 
First-In-First-Out: то, что первым помещено в канал, первым из него и выходит с другой
стороны.
<p>
Если Вы пишите в именованный канал, то процесс, который это делает, не завершается до тех пор,
пока записанная информация не будет прочтена из канала. Если Вы читаете из 
именнованного канала, то процесс, который это делает, будет работать до тех пор,
пока в канале есть информация для чтения. Размер файла
канала всегда нулевой - он не хранит данные, он просто связывает два процесса,
как это делает операция <tt>|</tt> командного интерпретатора. Однако, так как 
этот канал имеет имя, то нет необходимости запускать эти процессы (читающий и пишущий - прим. переводчика)
в одной и тоже командной строке (в отличие от <tt>|</tt> - прим. переводчика) и от имени 
одного и того же пользователя.
<p>
Вы можете изучить, как работает канал, на следующем примере:
<example>
$ cd; mkfifo mypipe
$ echo "hello" &gt;mypipe &amp; # запустим в фоновом режиме
[1] <var>5952</var>
$ ls -l mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
$ cat mypipe
hello
[1]+  Done                    echo hello &gt;mypipe
$ ls mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
$ rm mypipe
</example>

<sect1 id="sockets">Сокеты
<p>
<!-- new content -->
Сокеты очень похожи на именованные каналы (FIFO) и позволяют процессам
обмениваться информацией. В случае с сокетом эти процессы не обязаны
выполняться на одной и тоже машине или быть потомками одного и тоже  
родительского процесса. Это конечная точка в в межпроцессном взаимодействии.
Обмен информации может происходить через сеть между различными компьютерами.

<sect1 id="device">Файлы устройств
<p>
<!-- DDP Debian Tutorial content, modified -->
Файлы устройств ссылаются на физические или виртуальные устройства в Вашей системе,
такие как жесткий диск, видеокарта, экран или клавиатура. Пример виртуальнго устройства -
консоль, представленная файлом устройства <tt>/dev/console</tt>. 
<p>
Существует два типа устройств: 
<list compact>
<item><strong>символьные устройства</strong>
<list compact>
<item>Доступ к ним по одному символу за раз, то есть самый маленький элемент данных, который может быть
записан в устройство или прочитан с устройства - символ (байт).
</list>
<item><strong>блочные устройства</strong>
<list compact>
<item>Доступ к ним осуществляется посредством бОльших элементов, называемых блоками,
      которые могут содержать множество символов. Ваш жесткий диск является блочным устройством.
</list>
</list>
<p>
Вы можете читать или записывать в файл устройства, хотя сам файл
содержит двоичные данные, не очень понятные человеку. Запись данных непосредственно
в такие файлы иногда полезны для решения проблем подключений оборудования.
Например, Вы можете вывести текстовый файл в принтерный файл устройства <file>/dev/lp0</file>
или послать команды модему в соответствующий файл устройства последовательного порта  <file>/dev/ttyS0</file>.
Но делайте это аккуратно, так как это может привести к серъезным последствиям. Будьте осторожны.

<sect2 id="devnull"><file>/dev/null</file> и прочее.
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
Файл <file>/dev/null</file> - это специальный файл устройства, который обрасывает
все то, что Вы в него записываете. Если Вам что-то не нужно, направьте это в <file>/dev/null</file>.
Это в сущности бездонная яма. Если же Вы читаете файл <file>/dev/null</file>, то сразу получите
символ конца файла (EOF).
<p>
Файл <file>/dev/zero</file> очень похож, но только  если Вы читате его, то получите
символ <tt>\0</tt> (это не тоже самое, что ASCII-код цифры ноль). Смотрите <ref id="dummyfile">.

<sect2 id="node">Номер устройства
<p>
<!-- new content -->
Номер устройства отображается при выполнении команды <prgn>ls</prgn>:
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
Здесь 
<list compact>
<item>Файл <file>/dev/hda</file> имеет старший номер устройства 3 и младший номер 
устройства 0. Файл доступен для чтения/записи пользователем из группы <tt>disk</tt>.
<item>Файл <file>/dev/ttyS0</file> имеет старший номер устройства 4 и младший номер устройства 64.
И он доступен для чтения/записи пользователем из группы <tt>dialout</tt> и 
<item>Файл <file>/dev/zero</file> имеет страший номер устройства 1 и младший номер устройства 5.
Доступен для чтения/записи всеми пользователями.
</list>
<p>
В системах постарше процесс установки создавал файлы устройств при помощи 
команды <prgn>/sbin/MAKEDEV</prgn>. Смотрите <manref name="MAKEDEV" section="8">. 
<p>
В более новых системах файловая система в <file>/dev</file> автоматически 
наполняется при помощи файловой системы устройств, как это делается, 
например, в <file>/proc</file>.


<sect1 id="procfs">Файловая система <file>/proc</file>
<p>
<!-- modified heavily, original from Debian Guide -->
Файловая система <file>/proc</file> - это псевдо-файловая система, содержащая информацию 
о системе и работающих процессах.
<p>
Часто пугаются того, что один файл в этой файловой системе <file>/proc/kcore</file>
очень большого размера. Он содержит копию (более или менее) оперативной памяти 
Вашего компьютера и используется для отладки ядра. Поскольку фактически он нигде не
существует, то и не беспокойтесь о его размере.
<p>
Смотрите раздел <ref id="proc-sys"> и страницу <manref name="proc" section="5">.

<sect id="xtuto">Система X Window System
<p>
<!-- practically new content -->
Смотрите <ref id="x">.

<sect1 id="xstart">Запуск системы the X Window System
<p>
Система X Window System может быть запущена автоматически при помощи
специального графического демона входа навроде <prgn>xdm</prgn> или
через ввод команды в консоли: 
<example>
$ exec startx
</example>

<sect1 id="xmenu">Меню в системе X Window System
<p>
Так как среда X может работать со многими оконными менеджерами,
их пользовательские интерфейсы могут отличаться. Пожалуйста запомните,
что нажатие правой кнопки мыши на главном (корневом) окне приводит к
появлению меню. Почти всегда. 

<list compact>
<item>Чтобы получить командную строку, запустите Xterm из меню:
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>Для графического просмотра web-страниц запустите Mozilla из меню:
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>Для графического просмотра PDF-файлов запустите Xpdf из меню:
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
Если Вы не нашли нужный элемент в меню, установите требуемые пакеты. 
Смотрите раздел <ref id="apt-install">.

<sect1 id="xkeys">Клавиатурные комбинации клавиш в системе X Window System
<p>
Запомните следующие важные при работе в системе X Window System комбинации клавиш: 
<list compact>
<item>Ctrl-Alt-F1 по F6:  Переключиться в соответствующий превдотерминал
      (из системы X Window, DOSEMU и т.д.)
<item>Alt-F7:               Вернуться назад в X Window
<item>Ctrl-Alt-минус:       Изменить разрешение экрана в системе X Window ("серый" минус)
<item>Ctrl-Alt-плюс:        Изменить разрешение экрана в системе X Window ("серый" плюс)
<item>Ctrl-Alt-Backspace:   Завершить программу X Server
<item>Alt-X, Alt-C, Alt-V:  Привычные в Windows/Mac клавиатурные комбинации Вырезать, Копировать, Вставить,
нажимаемые с клавишей Ctrl, заменяются на комбинации с клавишей Alt для использования
в некоторых программах, например, Netscape Composer.
</list>

<sect id="cmd-study">Для дальнейшего изучения
<p>
На этот момент я рекомендую Вам прочесть ключевые руководства из раздела
<url id="&tldp-guide;" name="Проекта документации Linux: Руководства">:
<list compact>
<item>"Руководство системного администратора Linux",
<list compact>
<item>Охватывает все аспекты поддержания работающей системы,
работу с учетными записями пользователей, резервное копирование, настройку системы.
<item>пакет: <package>&p-sysadmin-guide;</package>
<item>файл: <url id="&f-sysadmin-guide;">
<item>web: <url id="&w-sysadmin-guide;">
</list>
<item>"Руководство администратора сети в Linux, вторая редакция",
<list compact>
<item>Это единственный справочник по администрированию сети в Linux-среде.
<item>пакет: <package>&p-netadmin-guide;</package>
<item>файл: <url id="&f-netadmin-guide;">
<item>web: <url id="&w-netadmin-guide;">
</list>
<item>"Книга рецептов по Linux",
<list compact>
<item>Содержит более 1,500 полезных рецептов и советов для очень занятого пользователя 
компьютера.
<item>пакет: <package>&p-linuxcookbook;</package>
<item>файл: <url id="&f-linuxcookbook;">
<item>web: <url id="&w-linuxcookbook;">
</list>
</list>
<p>
Дополнительную информацию смотрите в разделе <ref id="support">.
</chapt>
