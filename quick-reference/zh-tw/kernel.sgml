<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.65" -->
<chapt id="kernel">Debian下的Linux核心
<p>
Debian運用自己的方式來編譯核心及相關模組。參閱<ref id="kernel-details">。

<sect id="kernel-compile">核心編譯
<p>
Debian unstable發行版中的<prgn>gcc</prgn>、<prgn>binutils</prgn>和<prgn>modutils</prgn>可用來編譯最新的Linux核心。這方面的官方訊息，參閱<file>&f-kernel-readme;</file>文件的後半部分。

<p>
核心編譯是個很困難的議題，由于目標在不斷的變化，即使是最受人尊敬的開發者也會有不同的見解：
<taglist compact>
<tag>Manoj Srivastava寫到：
<item><tt>--initrd</tt> 需要Debian專用cramfs修正檔。
<tag>Herbert Xu 寫到：
<item>不，它不需要，想使用除CRAMFS以外的文件系統只需在<file>/etc/mkinitrd/mkinitrd.conf</file>中設定MKIMAGE。
</taglist>
<p>
按照Manoj和Kent撰寫的<file>&f-kernel-readme;</file>的指導小心行事，如果要編譯最新版本的核心請確認安裝了最新unstable版<package>kernel-package</package>套件。
<p>
對於單機核心編譯，<tt>initrd</tt>不是必須的。我用它是希望我新編譯的核心與相應的核心一模一樣。如果使用<tt>initrd</tt>，請先閱讀一下<manref name="mkinitrd" section="8">和<manref name="mkinitrd.conf" section="5">。亦可參閱<url id="&bug-initrd;">。

<sect1 id="kernel-debian">Debian標準方式
<p>
關心一下有關<package>kernel-package</package>、<prgn>gcc</prgn>、<prgn>binutils</prgn>和<prgn>modutils</prgn>的錯誤報告。請按有關要求使用較新的版本。
Watch out for bug reports on <package>kernel-package</package>,
<prgn>gcc</prgn>, <prgn>binutils</prgn>, and <prgn>modutils</prgn>.
Use new versions of them as needed.
<p>
在Debian系統中用源碼編譯自定義內核要特別小心。用<prgn>make-kpkg</prgn>的<tt>--append_to_version</tt>選項來創建多重內核鏡像比較安全。
Compiling a custom kernel from source under a Debian system requires special
care.  Use the new <tt>--append_to_version</tt> with
<prgn>make-kpkg</prgn> to build multiple kernel-images.
<example>
# apt-get install debhelper modutils kernel-package libncurses5-dev
# apt-get install kernel-source-<var>2.4.18</var>   # use latest version
# apt-get install fakeroot
# vi /etc/kernel-pkg.conf                # input my name and email
$ cd /usr/src                            # build directory
$ tar --bzip2 -xvf kernel-source-<var>2.4.18</var>.tar.bz2
$ cd kernel-source-<var>2.4.18</var>                # if this is your kernel source
$ cp /boot/config-<var>2.4.18-386</var> .config     # get current config as default
$ make menuconfig                        # customize as one wishes
$ make-kpkg clean                        # must run (per: man make-kpkg)
$ fakeroot make-kpkg --append_to_version -<var>486</var> --initrd \
        --revision=<var>rev.01</var> kernel_image \
        modules_image # modules_image is for pcmcia-cs* etc.
$ cd ..
# dpkg -i kernel-image*.deb pcmcia-cs*.deb # install
</example>
<tt>make-kpkg kernel_image</tt>實際上執行了<tt>make oldconfig</tt>和<tt>make dep</tt>。如果沒使用initrd就不要使用<tt>--initrd</tt>選項。
<p>
如果想加入pcmcia-cs模組或沒有pcmcia，應該在<tt>make menuconfig</tt>後選 "Generalsetup  &mdash;&gt;" 進入 "PCMCIA/CardBus support  &mdash;&gt;"，設定 "&lt;&nbsp;&gt; PCMCIA/CardBus support" 選項（例如，取消復選項）。
<p>
對於SMP機器，參照<manref name="kernel-pkg.conf" section="5">的說明設置CONCURRENCY_LEVEL。
</sect1>

<sect1 id="kernel-classic">經典方式
<p>
從下列位置取得乾淨的原始碼：
<list compact>
<item>Linux:     <url id="&linuxsrc;">
<item>pcmcia-cs: <url id="&pcmciasrc;">
</list>
或使用Debian所附的等價的原始碼：
<example>
# cd /usr/src
# tar xfvz linux-<var>whatever</var>.tar.gz
# rm -rf linux
# ln -s linux-<var>whatever</var> linux
# tar xfvz pcmcia-cs-<var>whatever</var>.tar.gz
# ln -s pcmcia-cs-<var>whatever</var> pcmcia
# cd linux
# make menuconfig
... 配置核心選項 ...
# make dep
# make bzImage
... 編輯lilo/grub ...
... 移動/usr/src/linux/arch/i386/boot/bzImage到boot ...
... /sbin/lilo or whatever you do for grub
# make modules; make modules_install
# cd ../pcmcia
# make config
# make all
# make install
... 添加需要的模組名稱到/etc/modules
... add needed module names to /etc/modules
# shutdown -r now

</example>
</sect1>

<sect1 id="kernel-headers">核心標頭檔
<p>
絕大多數"正常"程序不需要核心標頭檔，事實上如果直接引用它們會出錯。這些程序應該引用那些<strong>編譯<prgn>glibc</prgn></strong>所用的標頭檔，它們位於Debian系統的<file>/usr/include/linux</file>和<file>/usr/include/asm</file>目錄下。
<p>
故不要在<file>/usr/src/linux</file>目錄中建立指向<file>/usr/include/linux</file>和<file>/usr/include/asm</file>的連結，一些過時的文檔曾建議建立它們。
<p>
如果某些核心類應用程序<strong>需要</strong>特定的標頭檔，可修改<file>Makefile</file>(s)，使其包含指向"<file><var>特定標頭檔目錄</var>/include/linux</file>"和"<file><var>特定標頭檔目錄</var>/include/asm</file>"的路徑。
</sect1>

</sect>

<sect id="kernel-modules">模組化的2.4核心
<p>
kerntl-mage-2.4.<var>NN</var>提供了新版的Debian 2.4核心，該版核心模組化程度極高。你必須啟動相關的模組才能獲得想要的核心功能。
<p>
儘管在接下來的部分中提供了許多透過配置<file>/etc/modules</file>來解決問題的範例，但據說，在<file>/etc/modutils/</file>中用一個文件來提供所有的設備別名，就可解決這類有關模組問題，當前的核心有足夠多的別名供你使用。有些模組也可以被硬體偵測工具啟動，例如<package>discover</package>。參閱 <ref id="hdetect-x">。
<p>
參閱 <ref id="modules"> 和 Linux核心源碼目錄中的<file>Documentation/*.txt</file>獲取詳細訊息。

<sect1 id="kernel-pcmcia">PCMCIA
<p>
要使用PCMCIA，需在<file>/etc/modules</file>中包含下列內容：
<example>
# ISA PnP driver
isa-pnp
# Low level PCMCIA driver
# yenta_socket # 我的機器上似乎不需要
</example>
剩下的工作就由PCMCIA腳本（來自<package>pcmcia-cs</package>套件）、<prgn>depmod</prgn>和<prgn>kmod</prgn>負責了。我需要<prgn>isa-pnp</prgn>因為我的筆記本電腦使用的是舊ISA-PCMCIA。較新的筆記本電腦使用CardBus/PCMCIA，不再需要它。
<p>
慷慨的Miquel van Smoorenburg <email>miquels@cistron.nl</email>說：
<p>
“我將筆記中所有有關pcmcia的東西包括cardmgr等一鼓腦全刪了，只裝了支持car dbus的2.4版核心和woody中新的<package>hotplug</package>套件。
<p>
只要你使用的是32-bit卡，你就不需要pcmcia套件；2.4內置了 card services。標準的tulip驅動亦可在dlink卡上正常工作。
<p>
&mdash;Mike。”
<p>
參閱<url id="&pcmcia-howto;" name="Linux PCMCIA HOWTO"> 和 <ref id="trigger-pcmcia">。
</sect1>

<sect1 id="kernel-scsi">SCSI
<p>  <!-- Osamu: maybe test this section? I do not have SCSI :(  
                                     But this is almost sure :)
               I use some of these too now for firewire devices -->
[沒有測試過] 想要驅動 SCSI，請在<file>/etc/modules</file>中包含如下內容：
<example>
# SCSI core
scsi_mod
# SCSI generic driver
sg
# SCSI disk
sd_mod
# All other needed HW modules
...
</example>
可用<prgn>depmod</prgn>來操作上述某些模組。
</sect1>

<sect1 id="kernel-net">網絡功能
<p>
<file>/etc/modules</file>中需要包含如下內容以擴充網絡功能：
<example>
# net/ipv-4
ip_gre
ipip

# net/ipv-4/netfilter
# iptable (in order)
ip_tables
ip_conntrack
ip_conntrack_ftp
iptable_nat
iptable_filter
iptable_mangle
#
ip_nat_ftp
ip_queue
#
ipt_LOG
ipt_MARK
ipt_MASQUERADE
ipt_MIRROR
ipt_REDIRECT
ipt_REJECT
ipt_TCPMSS
ipt_TOS
ipt_limit
ipt_mac
ipt_mark
ipt_multiport
ipt_owner
ipt_state
ipt_tcpmss
ipt_tos
ipt_unclean
#
#ipchains
#ipfwadm
</example>
上述內容並沒有進行最佳化。可用<prgn>depmod</prgn>來操作上述某些模組。
</sect1>

<sect1 id="ext3">EXT3 檔案系統 ( &gt; 2.4.17)
<p>
對預先編譯好的 Kernel-image（&gt; 2.4.17）套件執行下述操作可啟動EXT3日誌式檔案系統：
<example>
# cd /etc; mv fstab fstab.old
# sed 's/ext2/ext3,ext2/g' &lt;fstab.old &gt;fstab
# vi /etc/fstab
... 將root文件系統類型設置成“auto”而非“ext3,ext2”
# cd /etc/mkinitrd
# echo jbd &gt;&gt;modules
# echo ext3 &gt;&gt;modules
# echo ext2 &gt;&gt;modules
# cd /
# apt-get update; apt-get install kernel-image-<var>2.4.17-686-smp</var>
... 安裝最新核心並配置boot（lilo從這兒運行）
# tune2fs -j -i 0 <var>/dev/hda1</var>
# tune2fs -j -i 0 <var>/dev/hda2</var>
... 將所有EXT2 FS轉化成EXT3
# shutdown -r now
</example>
現在就可使用 EXT3 日誌式檔案系統了。在<prgn>fstab</prgn>的“type”中使用<tt>ex3、ext2</tt>的是為了保險起見，如果核心不支持非root分割區採用EXT3還可退回到EXT2。

<p>
如果你已安裝了2.4版核心並且不想再次重裝，執行上述步驟中<prgn>apt-get</prgn>命令之前的步驟就行了。接著：
<example>
# mkinitrd -o /boot/initrd.img-<var>2.4.17-686-smp</var> /lib/modules/<var>2.4.17-686-smp</var>
# lilo
# tune2fs -j -i 0 <var>/dev/hda1</var>
# tune2fs -j -i 0 <var>/dev/hda2</var>
... 將所有EXT2 FS轉化成EXT3
# shutdown -r now
</example>
現在 EXT3 日誌式檔案系統已生效。
<p>
如果沒有設定好<file>/etc/mkinitrd/modules</file>就執行<prgn>mkinitrd</prgn>，最好在系統開機時增加要掛載的模組：
<example>
... 當initrd提示獲取shell時（5秒鐘），輸入RETURN
# insmod jbd
# insmod ext3 # modprobe ext3 may take care of everything
# insmod ext2
# ^D
... 繼續開機
</example>
在系統啟動畫面（<prgn>dmesg</prgn>）中，會出現“cramfs: wrong magic”，別擔心這沒有什麼害處。在Sarge（2002/10）中已解決了這個問題。參閱<url id="&bug-ext3;">和<url id="&howtoext3;" name="EXT3 File System mini-HOWTO">，或者是<file>&f-howtoext3;</file>獲得有關詳情。
<p>
啟動 EXT3 功能會造成某些系統發生嚴重的核心鎖死的情況，不過我沒遇到過這種問題（我的核心是2.4.17）。
</sect1>

<sect1 id="ss-rtl8139">2.4版核心對Realtek RTL-8139的支援
<p>
不知什麼原因，RTL-8139 的模組已不再叫 rtl8139，現在它叫 8139too。從2.2版核心升級到2.4版時，請記得在<file>/etc/modules</file>中做對應的修改。
</sect1>

<sect1 id="parport">並列埠支援
<p>
對於<package>kernel-image-2.4.*</package>，並列埠的支援已被模組化，要啟動可執行：
<example>
# modprobe lp
# echo lp >> /etc/modules
</example>
參閱Linux核心源碼目錄中的<file>Documentation/parport.txt</file>。

</sect1>
</sect>

<sect id="proc-sys">透過 proc 檔案系統調整核心
<p>
透過proc檔案系統，可在運行的狀態下進行調整Linux核心動作。
<p>
有關 <file>/proc</file> 檔案系統下修改核心參數的基礎知識，可參閱Linux源碼中的<file>Documentation/sysctl/*</file>文件。
<p>
調整核心參數的例子，可參考<file>/etc/init.d/networking</file>和<ref id="killecn">。
<p>
參閱 <manref name="sysctl.conf" section="5"> 了解如何透過 <file>/etc/init.d/procps.sh</file> 和 <file>/proc</file>檔案系統來設定核心啟動組態。<file>/etc/rcS.d/S30procps.sh</file> 在執行時會呼叫 <file>/etc/init.d/procps.sh</file> script。

<sect1 id="many-files">開啟太多檔案
<p>
Linux核心有時會報告 “Too many open files”，原因是<tt>file-max</tt>預設值（8096）太小。要解決這個問題，請用 root 身份執行下列命令：
<example>
# echo "65536"  &gt; /proc/sys/fs/file-max  # for 2.2 and 2.4 kernel
# echo "131072" &gt; /proc/sys/fs/inode-max # for 2.2 kernel only
</example>
或者修改加入底下的敘述到 <file>/etc/sysctl.conf</file>：
<example>
file-max=65536   # for 2.2 and 2.4 kernel
inode-max=131072 # for 2.2 kernel only
</example>

<sect1 id="bdflush">清除磁碟緩衝區時間
<p>
透過proc檔案系統來修改清除磁碟緩衝區時間。下面的操作將預設的5秒時間間隔縮短到1秒。
<example>
# echo "40 0 0 0 100 30000 60 0 0"  &gt; /proc/sys/vm/bdflush
</example>
這可能對文件I/O效能產生一些負面影響。但它能保證文件內容是最近1秒的，比預設的5秒更短。對日誌式檔案系統來說更是如此。
</sect1>

<sect1 id="over-commit">慢速且記憶體小的機器
<p>
對某些記憶體少的舊機器來說，在proc檔案系統中打開 over-commit 功能會很有效果：
<example>
# echo 1 &gt; /proc/sys/vm/overcommit_memory
</example> 
</sect1>

</sect>

<sect id="udev">核心 2.6 和 udev
<p>
udev 是取代 <file>/dev</file> 的動態配置的檔案系統。裝置名稱可以取較短的名稱。而 2.4 核心中的 devfs 已經淘汰了。
<p>
安裝 Debian 新版的 <package>kernel-image-2.6.<var>NN</var></package> 和 <package>udev</package> 就能啟動該功能了。
</sect>

</chapt>
