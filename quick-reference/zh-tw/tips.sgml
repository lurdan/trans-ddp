<!-- CVS revision of this document "$Revision: 1.4 $"  -->
<!-- CVS revision of original english document "1.63"  -->

<chapt id="tips"> &debian;技巧


<sect id="booting">啟動系統
<p>
參閱 LDP <url id="&bootprompt-howto;" name="BootPrompt-HOWTO">獲得有關系統提示的詳細資訊。

<sect1 id="crackroot">「我忘了root密碼！」(1)
<p>
只要能存取控制台 (console) 鍵盤，不需要 root 密碼就可以啟動系統登入到 root 帳號。（假設 BIOS 或 <prgn>lilo</prgn> 之類的啟動引導器在啟動時不需要密碼。）
<p>
整個過程不需要另外的開機軟碟或對 BIOS 設定進行修改。在此，「Linux」只有是一個標簽，它代表啟動 Debian 預設值安裝的 Linux 核心。
<p>
在 <prgn>lilo</prgn> 啟動螢幕中，一但出現<tt>boot:</tt>（對某些系統而言，必須按下shift鍵以阻止自動啟動），就輸入：
<example>
boot: Linux init=/bin/sh
</example>
它會指示系統啟動核心後執行 <file>/bin/sh</file> 而不是 <prgn>init</prgn>。現在你已獲得 root 特權和 root shell。由於目前的<file>/</file>是以唯讀方式掛載，而其它的硬碟分區均未掛載，故你必須完成下列步驟才能獲得一個有適當功\能的系統。
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
（如果在 <file>/etc/passwd</file> 檔案中所有使用者的第二個網域的資料為「x」，就表明系統使用了影子密碼，必隅虓編輯<file>/etc/shadow</file>。）要刪除root密碼，請編輯密碼檔案中第二個資料網域，將它設定為空白。重啟系統不用密碼就能登入到 root。當系統啟動進入 runlevel 1 時，Debian（至少是Potato以後的版本）需要密碼，一些較老的版本則不需要。
<p>
在 <file>/bin</file> 下裝一個小編輯器是個好習慣，因為有時 <file>/usr</file> 是無法存取的（參閱<ref id="bin-editor">）。
<p>
如果安裝 <package>sash</package> 套服軟體，當系統無法啟動時，還可執行：
<example>
boot: Linux init=/bin/sash
</example>
當 <file>/bin/sh</file> 無法使用時，<prgn>sash</prgn> 可作為 <prgn>sh</prgn> 的交談式替代品，它是靜態連結，內建了許多標準工具（在系統提示符下輸入「help」可獲得參考清單）。
</sect1>

<sect1 id="crackroot2">「我忘了root密碼！」(2)
<p>
從急救 boot/root 磁碟啟動系統。假設 <file><var>/dev/hda3</var></file>
是原始 root 分區，可用下面的方法編輯密碼檔案，與上述方法一樣容易。
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
與上面的方法相比，該方法的好處在於不需要知道 <prgn>lilo</prgn> 
密碼（如果有的話）。但如果系統沒有預先設定為從軟式磁碟機或 CD 啟動，就需要存取
BIOS 的權限。
</sect1>

<sect1 id="dead-lilo">無法啟動系統
<p>
沒在安裝過程中製作開機軟碟？沒關係。如果 <prgn>lilo</prgn> 損壞了，從 
Debian 安裝套件中拿出開機軟碟，用它來啟動系統。假設你的 root 分割區在 
<file><var>/dev/hda12</var></file>，你想進入runlevel 3，在啟動提示符後輸入：
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
接下來，系統使用軟式磁碟機上的核心啟動，你可登入到一個幾乎擁有全部功\能的系統了。
（可能有少量特性或模組無法使用。）
<p>
如果系統崩潰，亦可參閱<ref id="un-bootable">。
<p>
如果想做張自訂開機軟碟，參閱急救磁碟 (rescue disk) 中的 
<prgn>readme.txt</prgn> 文件。
</sect1>

<sect1 id="no-x-start">「我不想直接啟動到 X！」
<p>
玩 <tt>unstable/sid</tt> 很有趣，但在啟動進程中執行不穩定的<prgn>xdm</prgn>、
<prgn>gdm</prgn>、<prgn>kdm</prgn>和<prgn>wdm</prgn>會讓你焦頭爛額。
<p>
首先，在啟動提示符後輸入如下指令獲得 root shell：
<example>
boot: <var>Linux</var> vga=normal s
</example>
其中，<var>Linux</var>代表你要啟動的核心對映，「vga=normal」告訴lilo在普通VGA螢幕下執行，「s」（或「S」）是傳給<prgn>init</prgn>的參數，告訴它進入單使用者模式。在提示符後輸入root密碼。
<p>
有多種方法禁用X啟動deaemons：
<list>
<item>run <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6</tt>
<item>insert "exit 0" at the start of all <file>/etc/init.d/<var>?</var>dm</file> files.
<item>rename all <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> files to <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>remove all <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> files.
<item>run <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
其中，<file>rc<var>2</var>.d</file>必須與<file>/etc/inittab</file>中指定的runlevel一致。<file><var>?</var>dm</file>表示所有的<prgn>xdm</prgn>、<prgn>gdm</prgn>、<prgn>kdm</prgn>和<prgn>wdm</prgn>。
<p>
在Debian下只有第一種方法「最正確」。最後一種方法比較簡單但只適用於&debian;，而且還需要使用<prgn>dpkg-reconfigure</prgn>重新設定一次。其它方法都是通用的中止daemons的方法。
<p>
你仍可在任何控制台 (console) shell中輸入<prgn>startx</prgn>啟動 X。
</sect1>

<sect1 id="bootprompt">其它用於啟動提示的技巧
<p>
使用 <prgn>lilo</prgn> 啟動提示，可指定系統啟動到特定的 runlevel 和組態。
詳情參閱<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP)。
<p>
如果希望系統啟動到runlevel 4，可以<prgn>lilo</prgn>啟動提示後輸入：
<example>
boot: Linux 4
</example>
<p>
如果希望系統啟動到正常功\能的單使用者模式，而且你知道 root 密碼，可在 
<prgn>lilo</prgn>啟動提示後輸入下列任一參數。
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
如果希望系統以少於實際記憶體數的記憶體啟動（也就是說機器有 64MB 
記憶體，只分配 48MB 給系統使用），在<prgn>lilo</prgn>啟動提示符後輸入：
<example>
boot: Linux mem=48M
</example>
注意，不要指定大於實際記憶體數的記憶體，否則核心會崩潰。如果你有多於 
64MB 的記憶體，如 128MB ，應在系統啟動時執行 <tt>mem=128M</tt> 或在
<file>/etc/lilo.conf</file> 中添加類似的指令行，否則舊核心或使用舊 BIOS 
的主板將無法使用大於64MB的記憶體。
</sect1>

<sect1 id="bootgrub">如何設定啟動參數（GRUB）
<p>
GRUB 是 GNU Hurd 計畫開發的新型啟動管理器，比 Lilo 
更靈活，不過啟動參數也與之稍有不同。
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
請注意 Hurd 中的裝置名稱：
<example>
HURD/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,1)             /dev/hda1           C: (usually)
 (hd0,4)             /dev/hda4           F: (usually)
 (hd1,4)             /dev/hdb4           ?
</example>
詳情參閱 <file>&f-grub;</file> 和 <file>&f-grub-doc;</file>。
</sect>

<sect>活動記錄

<sect1 id="script">記錄shell活動
<p>
比起普通的個人電腦環境，Unix環境的系統管理包括了更多細致的工作。必須掌握所有基本的群組態方法以便進行系統故障恢復。基於X的GUI群組態工具看上去又好又方便，但不適用於緊急狀況。
<p>
記錄 shell 活動是個好習慣，特別是 root 使用者。
<p>
Emacs：使用<tt>M-x shell</tt>在快取區中開始記錄，使用<tt>C-x C-w</tt>將快取區中的記錄寫入檔案。
<p>
Shell：使用<prgn>screen</prgn>指令和「^A H」，參閱<ref id="screen">或<prgn>script</prgn>指令：
<example>
$ script
Script started, file is typescript
 ... do whatever ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
還可使用下面的方法：
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>記錄 X 操作
<p>
如果需要 X 套用程式的操作記錄圖，內含 xterm ，可使用<prgn>gimp</prgn>（GUI）。它可以對每個視窗或整個螢幕拍攝快照。還可以使用 <prgn>xwd</prgn>（<package>xbase-clients</package>）、<prgn>import</prgn>（<package>imagemagick</package>）或 <prgn>scrot</prgn>（<package>scrot</package>）。
</sect1>


</sect>

<sect id="archiving">拷貝及建立子目錄
<sect1>拷貝整個子目錄的基本指令
<p>
如果想重新整理檔案群組織結構，可使用下面的方法移動檔案及檔案連結：
<example>
標準方法：
# cp -a /source/directory /dest/directory # requires GNU cp
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
如果包括硬連結，則需要更嚴謹的方法：
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
如果是遠端操作：
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
如果沒有連結檔案：
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
其中，<prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn>，<prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>。
<p>
下面的有關拷貝整個子目錄的訊息由 Manoj Srivastava &lt;srivasta@debian.org&gt;發表於debian-user@lists.debian.org。
</sect1>

<sect1><prgn>cp</prgn>
<p>
傳統上，<prgn>cp</prgn>並不能真正完成這個工作，因為它既沒對符號連結進行區別對待，又不能儲存硬連結。另一件需要注意的事就是稀疏檔案（有洞的檔案）。
<p>
GNU <prgn>cp</prgn>克服了這缺陷，然而對於非 GNU 系統，<prgn>cp</prgn>仍存在問題。而且使用<prgn>cp</prgn>無法生成小巧輕便的文文件案包。
<example>
&percnt; cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
Tar 克服了<prgn>cp</prgn>在處理符號連結時出現的問題，然而，<prgn>cpio</prgn>可以處理特殊檔案，傳統的<prgn>tar</prgn>卻不行。
<p>                                                             
對於某個有多重硬連結的檔案，<prgn>tar</prgn>的處理方法是只將其中一個連結拷貝到磁帶上，所以日後你只能找回拷貝中所保留那個的連結所指的檔案；<prgn>cpio</prgn>會為每個連結做一個拷貝，日後你可以找回任意一個連結所指的檔案。
<p>
在 Potato 和 Woody 中，操作<file>.bz2</file>檔案的<prgn>tar</prgn>指令參數有所變化，所以請在腳本中使用<tt>--bzip2</tt>而不要簡寫為<tt>-I</tt>（Potato）或<tt>-j</tt>（Woody）。  
</sect1>

<sect1><prgn>pax</prgn>
<p>
全新的，符合POSIX（IEEE Std 1003.2-1992, pages 380&ndash;388 (section 4.48) and pages
936&ndash;940 (section E.4.48)）標準的，眾望所歸的，輕便的文文件案包交互工具。<prgn>pax</prgn>可以讀、寫以及列出文文件案包的成員，並能拷貝檔案目錄層次。<prgn>pax</prgn>的操作獨立於特定的文文件案包格式，支援各種各樣不同的文文件案包格式。
<p>
<prgn>pax</prgn>工具剛剛成形，還很新。
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 or
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn>從<prgn>cpio</prgn>或<prgn>tar</prgn>文文件案包提取/放入檔案。該文文件案包可以是硬碟上的另一個檔案，也可以是磁帶或管道。
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn>更善於處理<prgn>cpio</prgn>格式的文文件案包。通常它比cpio要快，且提供了更多磁帶選項，並且能更友好的處理有訛誤的輸入資料。它支援交談式處理多卷文文件案包。用<prgn>afio</prgn>製作壓縮文文件案包比壓縮<prgn>tar</prgn>或<prgn>cpio</prgn>文文件案包更安全。在備份處理腳本中<prgn>afio</prgn>是更佳的「文文件案處理引擎」。
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
對所有的磁帶備份我都使用<prgn>afio</prgn>。
</sect1>
</sect>

<sect id="diff-backup">差異備份與資料同步
<p>
要進行差異備份和資料同步可使用下列幾種方法：
<list>
<item><package>rcs</package>：備份並進行歷史記錄，只支援文本。
<item><package>rdiff-backup</package>：備份並進行歷史記錄。支援連結。
<item><package>pdumpfs</package>：對檔案系統進行備份和歷史記錄。支援連結。
<item><package>rsync</package>：單路同步。
<item><package>unison</package>：雙路同步。
<item><package>cvs</package>：多路同步伺服器備份並進行歷史記錄，只支援文本，技術成熟。參閱<ref id="cvs">。
<item><package>arch</package>：多路同步伺服器備份並進行歷史記錄，但內含「處於工作中的目錄」。
<item><package>subversion</package>：多路同步伺服器備份並進行歷史記錄，專用於Apache。 
</list>
有關將這些方法與文文件案包操作結合套用的討論參閱<ref id="archiving">，有關自動進行備份的討論參閱<ref id="cronjob">。
<p>
我只講解三個較容易使用的工具。

<sect1 id="rdiff-backup">使用rdiff進行差異備份
<p>
<package>Rdiff-backup</package>提供了簡單好用的方法對任何檔案內含連結進行歷史差異備份。例如要對<file>~/</file>目錄下的所有檔案備份到<file>/mnt/backup</file>：
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
從該文文件案包中取出 3 天前的舊資料恢復到<file>~/old</file>目錄：
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
參閱<manref name="rdiff-backup" section="1">。

<sect1 id="pdumpfs-backup">使用<package>pdumpfs</package>進行每日備份
<p>
<package>pdumpfs</package>是一種簡單的每日備份系統，與Plan9的<prgn>dumpfs</prgn>一樣，它每天都儲存系統快照。任何時候都可以用它來恢復到某天的系統狀態。請使用<prgn>pdumpfs</prgn>和<prgn>cron</prgn>來備份你的home目錄。
<p>
在目的地目錄中，<prgn>pdumpfs</prgn>以<tt>YYYY/MM/DD</tt>的方式v虒s組織系統快照。第一次執行時，它將所有來來源檔案拷貝到快照目錄。從每二次執行起，<prgn>pdumpfs</prgn>只有拷貝更新的或開新檔案的檔案，對於沒有改變的檔案用硬連結方式指向前一天的系統快照，以此來節省硬碟空間。
<example>
$ pdumpfs <var>src-dir</var> <var>dest-dir</var> [<var>dest-basename</var>]
</example>
See <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">使用 RCS 進行定期差異備份
<p>
<package>Changetrack</package>會定期對 RCS 文文件案包中基於文本格式的群組態檔案的變化進行記錄。參閱<manref name="changetrack" section="1">。
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>

<sect>系統凍結恢復
<sect1>中止一個進程
<p>
執行<prgn>top</prgn>看看什麼進程的活動有異常。按「P」以cpu使用率排序，「M」以記憶體使用率排序，「k」可以中止一個進程。還有一種方法，使用 BSD 風格的<tt>ps aux | less</tt>或 System V 風格的<tt>ps -efH | less</tt>。System V 風格的排列會顯示父進程 ID 
<tt>PPID</tt>，這對中止發生錯誤的（死掉的）子進程十分有用。
<p>
知道了進程的 ID ，就可使用<prgn>kill</prgn>中止（或發信號給）某個進程，<prgn>killall</prgn>的作用正如其名一樣。經常使用的信號有：
<example>
 1: HUP，重啟daemon
15: TERM，普通中止
 9: KILL，強令中止
</example>

</sect1>

<sect1>ALT-SysRq
<p>
核心編譯選項「Magic SysRq key」提供系統強心針。在i386機器上按下 <tt>ALT-SysRq</tt> 群組合鍵後，試試按下列各鍵<tt>r 0 k
e i s u b</tt>，奇跡產生了：
<p>
Un'r'aw讓鍵盤從 X 崩潰中重生。將控制台 (console) loglevel改為'0'以減少錯誤訊息。sa'k'（system attention key）中止目前的虛擬控制台 (console) 的所有進程。t'e'rminate中止目前的終端設備除init外的所有進程。k'i'll中止除 init 外的所有進程。
<p>
'S'ync，'u'mount和re'b'oot幫你逃離真正的險境。
<p>
本文寫作之時，Debian 預設值安裝的核心並未將這個選項編譯進去，需要重新編譯核心激活該功\能。詳情參閱<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>或<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>。

</sect1>
</sect>


<sect>記住這些可愛的小指令

<sect1>Pager
<p>
<prgn>less</prgn>就是pager（檔案內容瀏覽器）。按「h」可獲得幫助。它比<prgn>more</prgn>更有用。在shell啟動腳本中執行<tt>eval $(lesspipe)</tt>或<tt>eval $(lessfile)</tt>可以讓<prgn>less</prgn>活力四射。詳情參閱<file>&f-lessopen;</file>。使用<tt>-R</tt>選項可輸出生癖字元and enables ANSI color escape sequences.參閱<manref name="less" section="1">。
<p>
對於某些編碼系統（EUC）<prgn>w3m</prgn>可能是更好的選擇。

<sect1>釋放記憶體
<p>
<prgn>free</prgn>和<prgn>top</prgn>能讓你了解記憶體資來源的許多有用訊息。別擔心「Mem:」行中「used」的大小，看看它下面的數字（本例的數字是38792）。
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
實體記憶體的準確大小可通過<tt>grep '^Memory'
/var/log/dmesg</tt>得到，本例將顯示「Memory: 256984k/262144k available (1652k kernel code, 412k reserved, 2944k data, 152k init)」。
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
約有5MB記憶體系統不能使用，因為核心需要它。
</sect1>

<sect1>設定時間（BIOS）
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
設定系統時間和硬體時間為MM/DD hh:mm, CCYY。顯示時間為近端時間而硬體時間v洏垗TC。

<sect1>設定時間（NTP）
<p>
參考：<url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">。
<p>
<sect2>擁有永久Internet連接的系統設定時間
<p>
設定系統小時鐘通過遠端伺服器自動對時：
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
如果你的系統擁有永久的 Internet 連接，應該將該指令加入<file>/etc/cron.daily</file>。

<sect2>偶爾進行 Internet 連接的系統設定時間
<p>
使用 <package>chrony</package> 套件軟體。
</sect1>

<sect1>如何禁用螢幕保護程式
<p>
對於 Linux 控制台 (console) ：
<example>
# setterm -powersave off
</example>
<p>
啟動 kon2（kanji）控制台 (console) 可執行：
<example>
# kon -SaveTime 0
</example>
<p>
執行 X 可執行：
<example>
# xset s off
 或
# xset -dpms
 或
# xscreensaver-command -prefs
</example>
參閱相關的幫助頁面。
</sect1>

<sect1 id="getent">查詢系統管理資料程式庫
<p>
Glibc提供了<manref name="getent" section="1">查詢管理資料程式庫的各類項目。例如passwd、group、hosts、services、protocols、networks。
<example compact>
getent database [key ...]
</example>

<sect1>禁用聲音（響鈴）
<p>
最直接的方法是拔掉 PC 喇叭 ;-)，對於Bash shell可執行：
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>控制台 (console) 上的錯誤訊息
<p>
不想看螢幕顯示的錯誤訊息，喜好設定的方法是檢查<file>/etc/init.d/klogd</file>，在該腳本中設定<tt>KLOGD="-c <var>3</var>"</tt>然後執行<tt>/etc/init.d/klogd restart</tt>。另一種方法是執行<tt>dmesg -n<var>3</var></tt>。
<p>
這兒是各種錯誤層級的含義：
<list compact>
<item>0: KERN_EMERG,   系統無法使用
<item>1: KERN_ALERT,   必須立即執行
<item>2: KERN_CRIT,    緊急狀態
<item>3: KERN_ERR,     錯誤狀態
<item>4: KERN_WARNING, 警告狀態 
<item>5: KERN_NOTICE,  正常狀態且十分重要
<item>6: KERN_INFO,    報告
<item>7: KERN_DEBUG,   debug-level訊息
</list>
<p>
如果你很厭惡詳細而無用的錯誤訊息，可以試試這個小補丁<file>shutup-abit-bp6</file>（位元於<url id="&examples;" name="樣例腳本子目錄">）。
<p>
另一個該看看的地方是<file>/etc/syslog.conf</file>;，檢查一下是否有訊息記錄被送出到了控制台 (console) 設備。
</sect1>

<sect1>正確設定控制台 (console) 檔案類型
<p>
在類Unix系統中，存取控制台 (console) 螢幕通常要呼叫程式庫例程，這就為使用者提供了一種獨立於終端設備的方式v荍齔膠r元的螢幕更新過程。參閱<manref name="ncurses" section="3X">和<manref name="terminfo" section="5">。
<p>
在&debian;系統中，有大量預定義項目：
<example>
$ toe | less                  # 所有項目
$ toe /etc/terminfo/ | less   # 使用者可再群組態的項目
</example>
你的選擇可彙出到環境變量 <tt>TERM</tt>。
<p>
當登入到遠端 Debian 系統時，如果 xterm 的 terminfo 項目在非 Debian 的 xterm 中失效，請將終端設備檔案類型改為支援較少特性的版本如「xterm-r6」。
參閱<file>&f-libncurse;</file>。「dumb」是terminfo的最小公分母。
</sect1>

<sect1>恢復控制台 (console) 的健壯性
<p>
如果執行<tt>$ cat <var>some-binary-file</var></tt>後螢幕一片混亂（指令的返回值與你的輸入大相徑庭）：
<example>
$ reset
</example>
</sect1>

<sect1>將 DOS 下的文字檔案轉換為Unix檔案類型
<p>
將 DOS 文字檔案（行尾=^M^J）轉換成Unix文字檔案（行尾=^J）。
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1>正規表達式的置換
<p>
將所有檔案<var>FILES</var> ...中的所有<var>FROM_REGEX</var>字段取代成<var>TO_REGEX</var>字段。
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_REGEX</var>/g;' <var>FILES</var> ...
</example>
<tt>-i</tt>表示「就地編輯」，<tt>-p</tt>表示「在<var>FILES</var>...各檔案中循環」。如果置換很復雜，應使用參數<tt>-i.bak</tt>而非<tt>-i</tt>，這有助於發生錯誤恢復；它會將每個原始檔案儲存為以<tt>.bak</tt>為後綴的備份檔案。
</sect1>

<sect1>使用腳本來編輯檔案
<p>
下面的腳本將刪除 5-10 行以及 16-20 行。
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
在此，<prgn>ed</prgn>指令與<prgn>vi</prgn>指令模式下的是一樣的，從外部編輯檔案的方式使它易於腳本化。
</sect1>

<sect1>提取來來源檔案修改部分合併到更新包
<p>
下面的操作將根據檔案位元置，提取來來源檔案的修改部分並建立統一的 diff 檔案 <var>file.patch0</var> 或 <var>file.patch1</var>：
<example>
$ diff -u <var>file.old</var> <var>file.new1</var> &gt; <var>file.patch0</var>
$ diff -u <var>old/file</var> <var>new1/file</var> &gt; <var>file.patch1</var>
</example>
diff 檔案（也稱補丁檔案）通常用於送出程式更新。收到的補丁檔案可使用下面的方法更新另一個<var>檔案</var>：
<example>
$ patch -p0 <var>file</var> &lt; <var>file.patch0</var>
$ patch -p1 <var>file</var> &lt; <var>file.patch1</var>
</example>
如果有3個版本的來源代碼，使用<prgn>diff3</prgn>來合併效率更高：
<example>
$ diff3 -m <var>file.mine</var> <var>file.old</var> <var>file.yours</var> &gt; <var>file</var>
</example>
</sect1>

<sect1>分割大檔案
<p>
<example>
$ split -b 650m <var>file</var>   # 將大檔案分塊成多個650MB的小檔案
$ cat x* ><var>largefile</var>    # 將所有小檔案合併成一個大檔案
</example>
</sect1>

<sect1>從文本格式的表格中抽取資料
<p>
假設有一個文字檔案名為<file>DPL</file>，其中存放著所有前 &debian; 計畫領導人的名字和他們的上臺日期，表格格式是以空格做為分隔的。
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   January 1998
Wichert Akkerman  January 1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr March   2003
</example>
AWK經常用於從這類資料中提取資料。
<example>
$ awk '{ print $3 }' &lt;DPL                   # month started
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' &lt;DPL          # DPL called Ian
Ian     Murdock   August  1993
Ian     Jackson   January 1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # When Perens started
April 1996
</example>
</sect1>


<sect1>精巧的管道指令輔助腳本
<p>
下列腳本做為管道的一部分十分有用。
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # find all files in /usr excluding some files
xargs -n 1 <var>command</var>   # run command for all items from stdin
xargs -n 1 echo |    # split white-space-separated items into lines
xargs echo      |    # merge all lines into a line
grep -e <var>pattern</var>|     # extract lines containing <var>pattern</var>
cut -d: -f3 -|
        # extract third field separated by : (passwd file etc.)
awk '{ print $3 }' | # extract third field separated by whitespaces
awk -F'\t' '{ print $3 }' |
       # extract third field separated by tab
col -bx |            # remove backspace and expand tabs to spaces
expand -|            # expand tabs
sort -u|             # sort and remove duplicates

tr '\n' ' '|         # concatenate lines into one line
tr '\r' ''|          # remove CR
tr 'A-Z' 'a-z'|      # convert uppercase to lowercase
sed 's/^/# /'|       # make each line a comment
sed 's/\<var>.ext</var>//g'|    # remove <var>.ext</var>
sed  -n -e 2p|       # print the second line 
head -n 2 -|         # print the first 2 lines
tail -n 2 -|         # print the last 2 lines
</example>
</sect1>

<sect1>短小的Perl腳本
<p>
任何Awk腳本均可使用Perl重寫，例如
<example>
awk '($2=="1957") { print $3 }' |
</example>
可以使用下列任意一行現實：
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
其實上面各行中所有perl參數中的空格均可去掉，這得益於Perl的數字字串自動轉換功\能。
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
有關指令行參數的訊息可參閱<manref name="perlrun" section="1">，在<url id="&perlgolf;">有更多令人著魔的Perl腳本，你會感興趣的。
</sect1>

<sect1>從網頁上取得文本或信件清單文文件案
<p>
下面的操作將網頁轉化為文字檔案。從網上拷貝群組態檔案時十分有用。
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>textfile</var>
</example>
<prgn>links</prgn>和<prgn>w3m</prgn>也可以這麼用，只是生成的文本樣式可能略有不同。
<p>
如果是信件清單文文件案，可使用<prgn>munpack</prgn>從文本獲得mime內容。
</sect1>

<sect1>列印網頁
<p>
下面的操作將網頁內容列印成PostScript檔案或送出到印表機。
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
參閱<ref id="lprlpd">。還可使用<prgn>a2ps</prgn>和<prgn>mpage</prgn>套服軟體生成PostScript檔案。
</sect1>

<sect1>列印幫助頁面
<p>
下面的操作將幫助頁面列印成PostScript檔案或送出到印表機。
<example>
$ man -Tps <var>some-man-page</var> | lpr
$ man -Tps <var>some-man-page</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>合併兩個Postscript或PDF檔案
<p>
可以將兩個Postscript檔案或PDF檔案合併。
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>
 
<sect1>指令耗時
<p>
顯示某進程的耗時
<example>
# time <var>some-command</var> &gt;/dev/null
real    0m0.035s       # time on wall clock (elapsed real time)
user    0m0.000s       # time in user mode
sys     0m0.020s       # time in kernel mode
</example>
</sect1>

<sect1><prgn>nice</prgn>指令
<p>
使用<prgn>nice</prgn>（來自GNU <package>shellutils</package>套服軟體）可設定指令啟動時的nice值。<prgn>renice</prgn>（<package>bsdutils</package>）或<prgn>top</prgn>可以重設進程的nice值。nice值為19代表最慢的（優先等級最低的）進程；負值就「not-nice」，如-20代表非常快的（優先等級高的）進程。只有Supervisor可以設定負nice值。
<example>
# nice  -19 <var>top</var>                                         # very nice
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # very fast
</example>
有時歲N搌槃ice值對系統弊大於利，所以使用該指令要小心。
</sect1>

<sect1 id="cronjob">日程安排（<prgn>cron</prgn>，<prgn>at</prgn>）
<p>
在Linux下使用<prgn>cron</prgn>和<prgn>at</prgn>進行工作日程安排。參閱<manref name="at" section="1">、<manref name="crontab" section="5">、<manref name="crontab" section="8">。
<p> 
執行指令<tt>crontab -e</tt>建立或編輯crontab檔案，為規律事務（按周期循環的事務）安排日程。下面的一個crontab檔案樣例：
<example>
# use /bin/sh to run commands, no matter what /etc/passwd says
SHELL=/bin/sh
# mail any output to `paul', no matter whose crontab this is
MAILTO=paul
# Min Hour DayOfMonth Month DayOfWeek command (Day... are OR'ed)
# run at 00:05, every day
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# run at 14:15 on the first of every month -- output mailed to paul
15 14 1  * *   $HOME/bin/monthly
# run at 22:00 on weekdays(1-5), annoy Joe. &percnt; for newline, last &percnt; for cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Where are your kids?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# run at 03:40 on the first Monday of each month
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
執行<prgn>at</prgn>指令為偶然工作（只執行一次的工作）安排日程：
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">用<prgn>screen</prgn>來定製控制台 (console) 
<p>
The <prgn>screen</prgn>程式容許在<strong>單一</strong>的物理終端設備或終端設備類比視窗執行<strong>多個</strong>偽終端設備，每個偽終端設備都擁有自己的交談式shell。即便可以使用Linux偽終端設備或多個xterm視窗，研究一下如何設定<prgn>screen</prgn><strong>豐富的特性</strong>仍很有益，這些特性內含：
<list compact>
<item>回溯歷史顯示， 
<item>拷貝和貼上，
<item>輸出到日誌，
<item>圖形入口， 
<item>將終端設備與整個<prgn>screen</prgn>階段作業<strong>分離</strong>，稍後再連接。
</list>

<sect2>遠端存取作業方式
<p>
If you frequently log on to a Linux machine
如果你經常從遠端終端設備登入到Linux機器或使用VT100終端設備程式，<prgn>screen</prgn>的<strong>detach</strong>（分離）特性將簡化你的生活。
<p>
<enumlist compact>
<item>通過拔號連接登入，執行了一個非常復雜的<prgn>screen</prgn>會談，開啟舊檔了好幾個視窗，有編輯器和其它一些程式。
<item>突然你需要離開終端設備一下，但你並不想掛斷連線中止工作。
<item>輸入<tt>^A d</tt><strong>離開</strong>階段作業，然後登出系統。（或是更簡單些，輸入<tt>^A DD</tt>離開階段作業並自動登出系統）
<item>當你回來時，需要再次登入，可輸入指令<tt>screen -r</tt>，<prgn>screen</prgn>會如魔法般地重新連線上所有開啟舊檔的視窗。
</enumlist>

<sect2>典型的<prgn>screen</prgn>指令
<p>
一但開啟舊檔了<prgn>screen</prgn>程式，除了指令按鍵（預設值為<tt>^A</tt>）所有的鍵盤輸入都被送到目前的視窗，所有的<prgn>screen</prgn>指令均按特定方式輸入：<tt>^A</tt>加一個單鍵指令[加一些參數]的。常用的指令有：
<example>
^A ?     顯示說明螢幕（顯示指令集）
^A c     建立並切換到新增視窗
^A n     跳到下一個視窗
^A p     跳到上一個視窗
^A <var>0</var>     跳到<var>0</var>號視窗
^A w     顯示視窗清單
^A a     將Ctrl-A做為鍵盤輸入送出到目前的視窗
^A h     對目前的視窗做硬拷貝寫入到檔案
^A H     開始/中止將目前的視窗vぁ饇O錄到檔案
^A ^X    鎖定終端設備（密碼保護）
^A d     從終端設備分離螢幕階段作業
^A DD    分離螢幕階段作業並結束登入
</example>
以上只是<prgn>screen</prgn>指令的一個很小的子集。只要是你認為<prgn>screen</prgn>能幹的事，沒準它真就可以！詳情參閱<manref name="screen" section="1">。

<sect2><prgn>screen</prgn>階段作業中的退格鍵和Ctrl-H
<p>
在執行<prgn>screen</prgn>時，如果發現退格鍵和/或Ctrl-H無法正常工作，可編輯<file>/etc/screenrc</file>，找到這行：
<example compact>
bindkey -k kb stuff "\177"
</example>
將這注釋掉（例如在句首添加「#」）。

<sect2>X下與<prgn>screen</prgn>等價的程式
<p>
找找<prgn>xmove</prgn>。參閱<manref name="xmove" section="1">。

</sect1>

<sect1>網路測試基礎
<p>
安裝<package>netkit-ping</package>、<package>traceroute</package>、<package>dnsutils</package>、<package>ipchains</package>（適用於2.2版核心）、<package>iptables</package>（適用於2.4版核心）和<package>net-tools</package>套服軟體，然後執行：
<example>
$ ping <var>yahoo.com</var>            # 檢查Internet連接
$ traceroute <var>yahoo.com</var>      # 追蹤IP封包
$ ifconfig                  # 檢查主電腦設定
$ route -n                  # 檢查路由設定
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # 檢查<var>dns-server.com</var>的<var>host.dom</var> DNS記錄
      # 尋找<var>{mx|any}</var>記錄
$ ipchains  -L -n |less     # 檢查包過濾(2.2 kernel)
$ iptables -L -n |less      # 檢查包過濾(2.4 kernel)
$ netstat -a                # 尋找系統上所有開啟舊檔的連接埠
$ netstat -l --inet         # 尋找系統監聽的連接埠
$ netstat -ln --tcp         # 尋找系統監聽的TCP連接埠（連接埠數字）
</example>
</sect1>

<sect1>從近端快取池中清理（flush）信件
<p>
從近端快取池中清理信件：
<example>
# exim -q    # 清理待讀信件
# exim -qf   # 清理所有信件
# exim -qff  # 清理凍結信件
</example>
<tt>-qff</tt>選項用在<file>/etc/ppp/ip-up.d/exim</file>腳本中效果更好。
</sect1>

<sect1>刪除近端快取池中的凍結信件
<p>
刪除近端快取池中的凍結信件並返回發生錯誤訊息：
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>再分發mbox中的信件
<p>
如果home目錄沒有空間繼續處理信件，就需要對磁碟空間進行擴容，擴容完成後需要手動分發<file>/var/mail/<var>username</var></file>目錄中的信件到home目錄中的分類信箱，執行：
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>username</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>清理檔案內容
<p>
要清理某些檔案如日誌檔案的內容，千萬不要使用<tt>rm</tt>刪除檔案然後再建立一個新的空檔案，因為在兩次操作的間隔，系統可能需要存取該檔案。下面是清理檔案內容的安全方法：
<example>
$ :&gt;<var>file-to-be-cleared</var>
</example>
</sect1>

<sect1>空檔案
<p>
下面的指令可以建立空檔案：
<example>
$ dd if=/dev/zero    of=<var>filename</var> bs=1k count=5 # 5KB of zero content
$ dd if=/dev/urandom of=<var>filename</var> bs=1m count=7 # 7MB of random content
$ touch <var>filename</var> #  create 0B file (if file exists, updates mtime)
</example>
例如，最實用的使用方式是從&debian;啟動軟式磁碟機的shell中執行下列指令將硬碟<file>/dev/hda</file>的內容完全清理。
<example>
# dd if=/dev/urandom of=/dev/hda ; dd if=/dev/zero of=/dev/hda
</example>

</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
<prgn>chroot</prgn>程式，<manref name="chroot" section="8">，不需要重啟系統，就可以在單獨的系統上同時執行多個不同的GNU/Linux環境。
<p>
還可以在較快主電腦的chroot下執行某些需耗大量系統資來源記憶體的程式如<prgn>apt-get</prgn>和<prgn>dselect</prgn>，並將較慢子機的硬碟通過NFS方式掛載到主電腦，開放讀/寫權限，在主電腦上以chroot方式操作子機。

<sect2 id="chroot-debian">用<prgn>chroot</prgn>來執行不同版本的&debian;
<p>
在Woody中使用<prgn>debootstrap</prgn>指令很容易構造chroot &debian;體系。例如，在一臺擁有快速Internet連接的機器的<var>/sid-root</var>下建立一個Sid chroot：
<example>
main # cd / ; mkdir <var>/sid-root</var>
main # debootstrap sid <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... watch it download the whole system
main # echo "proc-sid <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount proc-sid <var>/sid-root</var>/proc -t proc
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # apt-setup # set-up /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # point the source to unstable
chroot # dselect  # you may use aptitude, install mc and vim :-)
</example>
<p>
現在你就擁有了一個全功\能&debian;子系統，可以盡情v禸?而不必擔心主&debian;受到不利影響。
<p>
該<prgn>debootstrap</prgn>套用技巧還可以實現在沒有&debian;安裝盤的情況下，從另一個GNU/Linux發行版下安裝&debian;。參閱<url id="&setup-chroot;">。

<sect2 id="chroot-console">設定<prgn>chroot</prgn>登入
<p>
輸入<tt>chroot <var>/sid-root</var> /bin/bash</tt>非常簡單，但這將沿用目前的的所有環境變量，你可能並不希望這樣並且有時還會出問題。更好的方法是，在別的虛擬終端設備上執行另一個登入進程，登入到chroot目錄。
<p>
在&debian;系統中預設值從<tt>tty1</tt>到<tt>tty6</tt>執行Linux控制台 (console) ，<tt>tty7</tt>執行 X Window系統，在本例中，我們將<tt>tty8</tt>設定成chroot控制台 (console) 。按照<ref
id="chroot-debian">中的描述建立好chroot系統後，就可以在主系統的root shell中輸入：
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8"  >> /etc/inittab
main # init q    # reload init
</example>

<sect2 id="chroot-x">群組態<prgn>chroot</prgn>下的X
<p>
想在 chroot 下安全地執行最新版的 X 和 GNOME 嗎？完全可以！下面的例子將實現在虛擬終端設備<tt>vt9</tt>下執行 GDM。
<p>
首先，按照<ref id="chroot-debian">中描述的方法安裝好chroot系統，從主系統的root下拷貝關鍵群組態檔案到chroot系統。
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # or use chroot console
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # do s/vt7/vt9/ in [servers] section
chroot # /etc/init.d/gdm start
</example>
在此，編輯<file>/etc/gdm/gdm.conf</file>，使其在<tt>vt7</tt>到<tt>vt9</tt>上建立虛擬終端設備。
<p>
現在可以很容易地能過切換Linux虛擬終端設備來實現在主系統的X環境和chroot系統的X環境之間轉換，例如使用Ctrl-Alt-F7和Ctrl-Alt-F9。酷吧！
<p>
[FIXME] 在chroot系統下gdm的init腳本中添加一條注釋和一條連結。

<sect2 id="chroot-dist">使用<prgn>chroot</prgn>來執行其它發行版
<p>
很容易建立一個包括其它發行版的 chroot 環境。使用其它發行版的安裝程式將它們安裝到單獨的硬碟分區中。例如root分區位元於<file><var>/dev/hda9</var></file>。
<example>
main # cd / ; mkdir <var>/other-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/other-dist</var>
main # chroot <var>/other-dist</var> /bin/bash
</example>
接下來的工作與<ref id="chroot-debian">、<ref id="chroot-console">和<ref id="chroot-x">中描述的內容基本相似。

<sect2 id="chroot-build">使用<prgn>chroot</prgn>來編譯套服軟體
<p>
這兒有一個很特殊的chroot套服軟體<package>pbuilder</package>，它構造一個chroot系統並在其中編譯套服軟體。該體系可用於檢查套服軟體編譯時關聯關係是否正確，並確保編譯生成的套服軟體中沒有不必要的或錯誤的關聯關係。

</sect1>

<sect1>怎樣檢查硬連結
<p>
檢查兩個檔案是否是指向同一個檔案的兩個硬連結：
<example> 
$ ls -li <var>file1</var> <var>file2</var>
</example>
 
<sect1><prgn>mount</prgn>硬碟上的映象檔案
<p>
如果 <file><var>file.img</var></file> 檔案是硬碟內容的對映檔案，而且原始硬碟的群組態參數為 <var>xxxx</var> = (bytes/sector) * (sectors/cylinder)，那麼，下面的指令將其掛載到<file>/mnt</file>：
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
注意絕大部分的硬碟都是 512 bytes/sector。

<sect1>Samba
<p>
取得 Windows 檔案的基本方法：
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # mount Windows files to Linux
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # list the shares on a computer
</example>
<p>
可從 Linux 檢查 Samba 網路上的芳鄰：
<example>
# smbclient -N -L <var>ip_address_of_your_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>外來檔案系統的操作工具
<p>
Linux 核心支援多種外來檔案系統，想存取它們只需將其掛載到合適的檔案系統下就行了。
對某些檔案系統，還提供專門工具不需要掛載，只依靠使用者空間的程式，不需要核心提
供檔案系統支援，就能完整存取。
<list compact>
<item><package>mtools</package>: for MSDOS filesystem (MS-DOS, Windows)
<item><package>cpmtools</package>: for CP-M filesystem
<item><package>hfsutils</package>: for HFS filesystem (native Macintosh)
<item><package>hfsplus</package>: for HFS+ filesystem (modern Macintosh)
</list>
對於建立和檢查 MS-DOS FAT 檔案系統 <package>dosfstools</package> 非常有用。
</sect1>

</sect>

</chapt>

