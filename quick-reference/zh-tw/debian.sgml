<!-- CVS revision of this document "$Revision: 1.9 $"  -->
<!-- CVS revision of original english document "1.124" -->


<chapt id="package">Debian 套件管理系統

<p>
進階級套件管理工具 <prgn>aptitude</prgn> 是首選的 APT 前端程式。它會紀錄額外安裝的軟體並解決惱人的相依性問題。<prgn>aptitude</prgn>也會移除掉不被已安裝軟體需要的套件。它內建了一個套件過濾器，但比較難上手。
<p>
<prgn>synaptic</prgn> 是目前首選的以 Gtk 為 toolkit 的視窗化 APT 前端程式。它的套件過濾器就比<prgn>aptitude</prgn>來的友善且簡單多了。更多的功能和支援請參閱<url id="&debtags;" name="Debian Package Tags">。
<p>
為了減少 &debian; 檔案庫 (repository) 的網路負擔並加速您的下載速度，您可以考慮從 &debian; 鏡射站台下載。
<p>
如果您的區網內需要安裝重複的套件到多台電腦上，請在使用 APT 下載套件時，考慮使用 <prgn>squid</prgn> 設定本地端的 HTTP proxy。必要的話，設定<tt>http_proxy</tt>環境變數或加入 <tt>http</tt> 設定到<file>/etc/apt/apt.conf</file>。
<p>
儘管 <manref name="apt_preferences" section="5"> 的 pinning 功能十分強大，但造成的影響是難以偵錯和管理。除非熟悉該工具才考慮採用。
<p>
<![%f-ref;[在 <ref id="chroot"> 中所敘述的方法非常適合於]]><![%q-ref;[chroot 適合於]]>需要同時結合系統的穩定性和使用最新版軟體的情況。
<p>
本章是基於 Woody 之後的系統所撰寫的，有些資訊只適用於 Sarge 或更新的系統。

<sect id="pkg-intro">介紹
<p>
如果你沒精力閱讀完所有的開發文件，那麼先看看本章的內容，然後就開始體驗 Debian <tt>testing</tt>/<tt>unstable</tt> 的威力吧 :-)

<sect1>主要的套件管理工具
<p>
<example>
dpkg      &ndash; 安裝 &debian; 套件的工具
apt-get   &ndash; APT 安裝套件的指令
aptitude  &ndash; 進階級的文字介面的 APT 前端工具
synaptic  &ndash; 圖形介面的 APT 前端工具
dselect   &ndash; 使用選單介面的套件管理工具 
tasksel   &ndash; 安裝 task
</example>
這些工具並非是為了取代對方而產生的，相反的，他們甚至能共用彼此。例如說 <prgn>dselect</prgn> 能搭配使用 APT 和 <prgn>dpkg</prgn>來安裝套件。
<p>
APT 使用 <file>/var/lib/apt/lists/*</file> 來追蹤可用的套件，而 <prgn>dpkg</prgn> 則是使用 <file>/var/lib/dpkg/available</file> 。如果直接用 <prgn>aptitude</prgn> 或類似工具來安裝套件的話，別忘了要使用 dselect 的 <tt>[U]pdate</tt> 選項，或在執行 <tt>dselect update</tt> 來更新 <file>/var/lib/dpkg/available</file> 。
<p>
在處理套件相依性的方式上， <prgn>apt-get</prgn> 會自動搜尋下載相依的套件，但不會額外安裝該軟體推薦或建議的套件。
<p>
相反地，<prgn>aptitude</prgn> 可以設定成是否要額外安裝 "推薦" 或 "建議" 的套件。
<p>
<prgn>dselect</prgn> 在套件的選擇方面提供了選單方式的操作，會列出該軟體推薦或建議的套件並個別決定是否要安裝。
<![%f-ref;[請參閱 <ref id="depends"> 。]]>
</sect1>

<sect1>方便的工具
<p>
<example>
dpkg-reconfigure  - 重新設定一個已經安裝的套件
                    (如果它是使用 debconf 的話)
dpkg-source       - 管理套件源碼檔案
dpkg-buildpackage - 自動重新編建套件檔案
apt-cache         - check package archive in local cache
</example>
</sect1>
</sect>

<sect id="apt-install">體驗 &debian; 套件管理
<p>

<sect1 id="setup-apt">設定 APT
<p>
參閱<ref id="testing-transition">來設定<file>sources.list</file>。
<footnote>
如果您的系統以<tt>testing</tt> 或 <tt>unstable</tt>為主，您可以移除<file>/etc/apt/sources.list</file> 和 <file>/etc/apt/preferences</file>中的 <tt>stable</tt>敘述，因為<tt>testing</tt>初使是拷貝自<tt>stable</tt>。
</footnote>

 <![%f-ref;[
 請參考
<ref id="install">, <ref id="woody">和 <ref id="bin-editor">.
 ]]>

<sect1 id="tasksel">tasks 安裝 
<p>
您可以安裝一個許多軟體集合的套件來規畫特定用途的 &debian; 系統。而該集合就叫作 "Task"。
<p>
安裝 tasks 最簡單的方法就是在安裝系統過程中，執行 <prgn>tasksel</prgn>。請記得先執行<example>dselect update</example>。
<p>
建議使用 <prgn>aptitude</prgn> 來安裝 tasks，而這也是它的特色之一。它能在您選擇好 tasks 並準備安裝之前再額外刪除掉您不需要的軟體。
</sect1>

<sect1 id="aptitude"><prgn>aptitude</prgn>
<p>
<prgn>aptitude</prgn> 是一套全新的套件安裝系統，類似於 <prgn>dselect</prgn>，不同的是針對 APT 重新設計的。
它也能當作 <prgn>apt-get</prgn> 另一個指令介面且完全相容 <prgn>apt-get</prgn>的參數喔。請參閱 <manref name="aptitude" section="1"> 和 <file>&f-aptitude-readme;</file>。
<p>
從您開始安裝軟體，建議使用<prgn>aptitude</prgn>來代替所有的安裝工具，不然會失去了<prgn>aptitude</prgn>所建立的套件追蹤清單。這會使您無法移除多餘的套件。
<p>
<prgn>aptitude</prgn> 的功能鍵如下(大部分為小寫)：
<example>
Keystroke   Action
F10         Menu
?           Help for keystroke (complete listing)
u           Update package archive information
           Mark the package to be upgraded or newly installed
-           Mark the package to be removed (keep config)
_           Mark the package to be purged (remove config)
=           Place the package on hold
U           Mark all upgradable packages to be upgraded
g           Download and install selected packages
q           Quit current screen and save changes
x           Quit current screen and discard changes
Enter       View information about a package
C           View a package's changelog
l           Change the limit for the displayed packages
/           Search for the first match
\           Repeat the last search
</example>
如同<prgn>apt-get</prgn>，<prgn>aptitude</prgn>在安裝軟體時也會解決掉惱人的相依性問題。
<prgn>aptitude</prgn> 也能設定成是否要安裝軟體額外推薦或建議的軟體。 
利用主畫面選單上的<tt>F10 -> Options -> Dependency handling</tt>來改變預設的安裝策略。
<p>
<prgn>aptitude</prgn> 的其他功能：
<list compact>
<item><prgn>aptitude</prgn> 能存取所有版本的套件。
<item><prgn>aptitude</prgn> 的動作會紀錄在<file>&f-aptitude-log;</file>。
<item><prgn>aptitude</prgn> 能輕鬆地追蹤本地端建立的套件並列在 "Obsolete and Locally Created Packages"。
<item><prgn>aptitude</prgn> 內建強大的收尋引擎並過濾顯示的套件。
<prgn>mutt</prgn>的使用者會很容易上手，因為 expression 的文法是來自於 mutt。請參閱 <file>&f-aptitude-readme;</file> 的 "SEARCHING, LIMITING, AND EXPRESSIONS"。
<item><prgn>aptitude</prgn>內建 <prgn>su</prgn> 的功能所以一般使用者皆可以執行直到安裝或移除軟體時再取得管理者的權限。
</list>
</sect1>

<sect1 id="dselect"><prgn>dselect</prgn>
<p>
從 Stable 發行到現在為止(包含Potato)，<prgn>dselect</prgn>是主要的套件維護工具。當 Sarge 發行後，您可以考慮使用 <prgn>aptitude</prgn> 來取代。
<p>
當你啟動程式時， <prgn>dselect</prgn> 會自動選取所有 "Required" 、 "Important" 和 "Standard" 分類的套件。
<p>
雖然<prgn>dselect</prgn> 的使用介面有點怪，但大部分的人都已經習慣了。有四主要的指令 (都是大寫的指令！)：
<example>
按鍵        動作
Q           離開。確認目前所選取的並離開程式。
            (override dependencies)
R           回復 (Revert)！ I did not mean it.
D           不管你 (Damn it)！我不管 dselect 怎麼想的。照我的做就是了！
U           都照建議 (sUggested) 的來做
</example>
使用 <tt>D</tt> 和 <tt>Q</tt> 可以選擇有衝突的選項。要小心地使用這些指令。
<p>
在 <file>/etc/dpkg/dselect.cfg</file> 中加上一行 "expert" 選項以減少干擾。
<p>
對於速度慢的機器，可以在其它速度快的機器上執行 <prgn>dselect</prgn> 先選好套件，然後用 <tt>apt-get install</tt> 來安裝。
</sect1>

<sect1 id="aptitude-track">使用 APT 來維持 &debian; 發行版本
<p>
請編輯<file>/etc/apt/preferences</file>並加入以下的說明來維持系統為 <tt>testing</tt> 版本：
 <example>
Package: *
Pin: release a=testing
Pin-Priority: 800

Package: *
Pin: release a=stable
Pin-Priority: 600
</example>
要注意的是追蹤<tt>testing</tt>版本會有延誤安裝安全性修正軟體的副作用。這樣的軟體是因為上傳到<tt>unstable</tt>並移植到<tt>testing</tt>的這段期間所造成的延誤。
<p>
更多且複雜的範例請參考 <manref name="apt_preferences" section="5">，允許您做更多的事情，例如安裝 <tt>unstable</tt> 的套件還能把系統維持在<tt>testing</tt>。
<p>
關於限制替定軟體在特定的版本的範例可以在 <url id="&examples;" name="examples subdirectory"> 找到 <file>preferences.testing</file> 和 <file>preferences.unstable</file>。
<p>
如果您混用不同的發行版本，例如 <tt>testing</tt> 和 <tt>stable</tt> 或 <tt>unstable</tt> 和 <tt>stable</tt>，您終究會安裝到<tt>testing</tt>或<tt>unstable</tt>版本的核心軟體，例如<package>libc6</package>，而這樣的行為無法保證系統無臭蟲存在。您必須特別小心。
<p>
另外一個例子，<file>preferences.stable</file>會強制降級所有的軟體到<tt>stable</tt>。
<p>
&debian; 不支援將某個 <strong>套件</strong>降級到先前的發行版本。但新版的套件出問題時，重裝舊版的套件是被允許的。您可以在本地端的 <file>/var/cache/apt/archives/</file> 或遠地端的 <url id="&snapshothome;"> 找到先前發行的版本。請參考 <ref id="rescue-dpkg">。
<p>
&debian; 也不支援將某個 <strong>發行版本</strong> 降級到先前的版本且這樣做往往會造成很多問題。如果您願意冒險的話，也是值得嘗試看看。
</sect1>

<sect1 id="apt-commands"><prgn>aptitude</prgn>，<prgn>apt-get</prgn>和<prgn>apt-cache</prgn> 命令
<p>
當像之前的例子一樣跟隨著 <tt>testing</tt>，您可以下列的指令來管理系統。
<list>
<item><tt>aptitude upgrade</tt> (或
      <tt>apt-get upgrade</tt> 或
      <tt>aptitude dist-upgrade</tt> 或
      <tt>apt-get dist-upgrade</tt>)
<p>
這樣會跟隨<tt>testing</tt>版本 &mdash;
他們會安裝目前<tt>testing</tt>版本上可提供升級的套件以及其相依的軟體。
<footnote>
<tt>upgrade</tt>與<tt>dist-upgrade</tt>不同的地方是對於那些升級套件的相依性問題的處理方式。請參閱<manref name="apt-get" section="8">來了解更多細節。
<p>
<tt>aptitude upgrade</tt> 和 <tt>aptitude dist-upgrade</tt> 是<prgn>aptitude</prgn> 的組合指令。按下 <tt>e</tt>可以全螢幕顯示。
</footnote>
<item><tt>apt-get dselect-upgrade</tt>
 <p>這會跟隨<tt>testing</tt>版本 &mdash;
上述指令升級的方法是依照<prgn>dselect</prgn>的處理方式來決定的。
<item><tt>aptitude -R -G install <var>package</var></tt> (或
      <tt>apt-get install <var>package</var></tt>)
 <p>這樣會從<tt>testing</tt>版本安裝軟體以及其相依的軟體。
<item><tt>aptitude -r -G install <var>package</var></tt>
 <p>這樣會從<tt>testing</tt>版本安裝軟體以及其相依和推薦的軟體。
<item><tt>aptitude -r -g install <var>package</var></tt>
 <p>這樣會從<tt>testing</tt>版本安裝軟體以及其相依和推薦或建議的軟體。
<item><tt>aptitude install <var>package</var>/unstable</tt>
 <p>由 <tt>unstable</tt> distribution 安裝 <var>package</var> ，並由 <tt>testing</tt> distribution 安裝相依的套件。
<item><tt>aptitude install -t unstable <var>package</var></tt>
 <p>將 <tt>unstable</tt> 的 Pin-Priority 設為 990，會由 <tt>unstable</tt> distribution 安裝 <var>package</var>，也從 <tt>unstable</tt> distribution 安裝相依的套件。
<item><tt>apt-cache policy <var>foo bar ...</var></tt>
 <p>檢查 <var>foo bar ...</var> 套件的狀態。
<item><tt>aptitude show <var>foo bar ...</var> | less</tt>
(或 <tt>apt-cache show <var>foo bar ...</var> | less</tt>)
 <p>檢查 <var>foo bar ...</var> 套件的資料。
<item><tt>aptitude install <var>foo=2.2.4-1</var></tt>
 <p>安裝 <var>foo</var> 套件的特定版本 <var>2.2.4-1</var> 。
<item><tt>aptitude install <var>foo bar-</var></tt>
 <p>安裝 <var>foo</var> 套件，並移除 <var>bar</var> 套件
<item><tt>aptitude remove <var>bar</var></tt>
 <p>移除 <var>bar</var> 套件但不刪除設定檔。
<item><tt>aptitude purge <var>bar</var></tt>
 <p>移除 <var>bar</var> 並刪除其設定檔。
</list>
在上面的例子中，在<prgn>apt-get</prgn> 中使用 <tt>-u</tt> 選項會列出所有要升級的套件列表，並在動作前請示使用者。下面的作法也會使 <prgn>apt-get</prgn>完成上述的動作：
<example>
$ cat &gt;&gt; /etc/apt/apt.conf &lt;&lt; .
// 總是列出要升級的套件 (-u)
APT::Get::Show-Upgraded "true";
.
</example>
<p>
搭配 <tt>--no-act</tt> 來模擬這些安裝，移除...套件等動作。

<sect id="survival">Debian 生存指令
<p>
掌握了這些知識，就能讓你享受無窮盡的"升級"了 :-)

<sect1 id="bug-check">檢查 Debian 中的 bugs 並尋求幫助
<P>
如你使用某個套件出現問題，在尋求幫助或發送錯誤報告之前請確認查看過下列網站（ <prgn>lynx</prgn> 、 <prgn>links</prgn> 和 <prgn>w3m</prgn> 都很好用）：
<example>
$ lynx &bugs;
$ lynx &bugs;<var>package-name</var>  # 如果你知道套件名稱
$ lynx &bugs;<var>bugnumber</var>     # 如果你知道錯誤序號
</example>
在 Google (www.google.com) 中使用關鍵字 "site:debian.org" 搜索。
<p>
如有疑問，可閱讀說明文件。設定 <tt>CDPATH</tt> 如下：
<example>
export CDPATH=.:/usr/local:/usr/share/doc
</example>
並輸入
<example>
$ cd <var>packagename</var>
$ pager README.Debian # 如果存在的話
$ mc 
</example>
<![%f-ref;[
在 <ref id="support"> 有更多的參考資料。
]]>
</sect1>

<sect1 id="apt-trouble">APT 升級的錯誤排除方法
<p>
在升級 <tt>unstable</tt>或<tt>testing</tt> 時可能會遇到在 <ref id="upgrade-system"> 所描述的套件相依性問題。在大多數情況下，是因為將要升級的套件所相依性套件不存在。這個問題可用下面的方法來解決：
<example>
# aptitude dist-upgrade
</example>
如果這也沒辦法的話，就重複使用下列之一的方法至到問題自動解決：
<example>
# aptitude -f upgrade         # 即使遇到錯誤也繼續升級
... 或
# aptitude -f dist-upgrade    # 即使遇到錯誤也繼續 dist-upgrade
</example>
<p>
有些升級用的 script 的確有問題，所以會持續出現狀況。通常要解決這個狀況，你最好能檢查一下這些討厭套件中的 <file>/var/lib/dpkg/info/<var>packagename</var>.{post-,pre-}{install,removal}</file> script ，並執行：
<example>
# dpkg --configure -a    # 設定所有部分安裝的套件
</example>
<p>
如果 script 抱怨它找不到設定檔的話，在 <file>/etc/</file> 中找找對應的設定檔。如果你找到的是個有 <tt>.dpkg-new</tt> 的副檔名（或是類似的東西），就把它的後綴去除掉（用 <prgn>mv</prgn> ）。
<p>
在安裝 <tt>unstable</tt>或<tt>testing</tt> 系統時也可能遇到相依性問題。可用這個方法巧妙的解決：
<example>
# aptitude -f install <var>package</var> # override broken dependencies
</example>
<p>
要修正這些問題，另一個可用的方法是使用 <package>equivs</package> 套件。請參閱 <file>&f-equivs;</file><![%f-ref;[ 和 <ref id="equivs">]]> 。
</sect1>

<sect1 id="rescue-dpkg">使用 <prgn>dpkg</prgn> 來救援
<p>
如果你在使用 APT 遇到死胡同，那麼可以從 &debian; 鏡射站台下載套件並使用<prgn>dpkg</prgn>來安裝。如果您還沒連上網路，可以鎖住 <file>/var/cache/apt/archives/</file> 的快取檔案。
<example>
# dpkg -i fetchmail_6.2.5-4_i386.deb
</example>
如果您嘗試安裝套件卻因為相依性問題失敗的話，請搭配<tt>--ignore-depends</tt><tt>--force-depends</tt>或其他參數來執行<prgn>dpkg</prgn>。<manref name="dpkg" section="8">有更詳盡的介紹。
</sect1>

<sect1 id="recover-status">回復套件的選取狀態的資料
<p>
不論是什麼原因，如果 <file>/var/lib/dpkg/status</file> 亂掉了的話，則 &debian; 系統會失去套件的選取狀態的資料，這是很糟糕的事。到 <file>/var/lib/dpkg/status-old</file> 或 <file>/var/backups/dpkg.status.*</file> 找找看舊的 <file>/var/lib/dpkg/status</file> 檔。
<p>
因為 <file>/var/backups/</file> 這個目錄中有很多重要的系統資料，所以把它放到分開的分割區會是個不錯的主意。
<p>
如果連舊的 <file>/var/lib/dpkg/status</file> 檔也找不到了，你仍可以從 <file>/usr/share/doc/</file> 目錄來回復這些資料。
<example>
# ls /usr/share/doc | \
  grep -v [A-Z] | \
  grep -v '^texmf$' | \
  grep -v '^debian$' | \
  awk '{print $1 " install"}' | \
  dpkg --set-selections
# dselect --expert # 重新安裝系統，如果需要的話去除一些選取
</example>

<sect1 id="rescue-var">在 <file>/var</file> 崩潰後救援系統
<p>
因為 <file>/var</file> 目錄下包含了常被更動的資料，如 mail ，所以比較容易會有損壞。
把它放到獨立的分割區可以減少風險。如果災難發生了，你必需重建 <file>/var</file> 以回復 &debian; 系統。

<p>
從相同或較舊版本的最簡化的 &debian; 系統中取得 <file>/var</file> 目錄內容的架構，例如 <file><url id="&var-tar-gz;" name="var.tar.gz"></file>，將它放入受損系統的根目錄，然後
<example>
# cd /
# mv var var-old      # 如果還留下有用的資料的話
# tar xvzf var.tar.gz # 使用 Woody 架構的檔案
# aptitude            # 或是用 dselect
</example>
上述步驟應可使系統恢復工作。使用 <ref id="recover-status"> 中描述的技術來加快套件選取資料的恢復。
([FIXME] ：這個流程需要更多的實驗來驗證。)
</sect1>

<sect1 id="un-bootable">把套件安裝到一個無法開機的系統
<p>
用 Debian 救援磁片/CD 或是一個多重開機的 Linux 系統的其它分割區來開機進入 Linux 。<![%f-ref;[請參閱 <ref id="booting"> 。]]>在 <file>/target</file> 掛上這個無法開機的系統，並使用 <prgn>dpkg</prgn> 的 chroot 安裝模式。
<example>
# dpkg --root /target -i <var>packagefile.deb</var>
</example>
然後設定並解決問題。
<p>
By the way, if a broken <prgn>lilo</prgn> is all that prevents booting, you can boot using 
a standard Debian rescue disk. At boot prompt, assuming the root partition of 
your Linux installation is in <file>/dev/hda12</file> and you want runlevel 3, enter:
<example>
boot: rescue root=/dev/<var>hda12</var> 3
</example>
Then you are booted into an almost fully functional system with the kernel on
floppy disk. (There may be minor glitches due to lack of kernel features or modules.) 
</sect1>

<sect1>如果 <prgn>dpkg</prgn> 指令壞了怎麼辦
<p>
如果 <prgn>dpkg</prgn> 有問題，就不能安裝任何 <tt>.deb</tt> 檔了。下列的流程可幫助你來修復這個情況。（在第一行中，你可以把 "links" 換成你喜歡的瀏覽器指令。）
<example>
$ links http://<var>http.us.debian.org</var>/debian/pool/main/d/dpkg/
  ... 下載正確的 dpkg_<var>version</var>_<var>arch</var>.deb
$ su
password: *****
# ar x dpkg_<var>version</var>_<var>arch</var>.deb
# mv data.tar.gz /data.tar.gz
# cd /
# tar xzfv data.tar.gz
</example>
如果是 <tt>i386</tt> 的話，也可以用 <tt>http://packages.debian.org/dpkg</tt> 。
</sect1>

</sect>

<sect id="debian-package">Debian 神技之指令
<p>
經過這些指令的<strong>啟示</strong>，你將可由無休止的升級地獄中解放出來，到達 Debian <strong>涅盤</strong>。 :-)

<sect1 id="info-file">檔案中的資訊
<p>
在已安裝的套件中尋找特定檔案樣板所屬的套件：
<example>
$ dpkg {-S|--search} pattern
</example>
或者搜尋 &debian; 檔案庫中類似的：
<example>
$ wget http://ftp.us.debian.org/debian/dists/<var>sarge</var>/<var>Contents-i386.gz</var>
$ zgrep -e pattern <var>Contents-i386.gz</var>
</example>
或是使用特殊的套件命令：
<example>
# aptitude install dlocate  
                 # conflicts with slocate (secure version of locate)
$ dlocate <var>filename</var>         # dpkg -L 和 dpkg -S 的快速版
...
# aptitude install auto-apt # on-demand package installation tool
# auto-apt update          # 建立 auto-apt 的 db 檔
$ auto-apt search <var>pattern</var>  
                # 尋找符合某個 pattern 的套件，不論是否安裝
</example>
</sect1>

<sect1 id="info-package">套件的資訊
<p>
從套件 archive 中尋找並顯示資訊。編輯 <file>/etc/apt/sources.list</file> 以確定 APT 指向適合的 archive(s)。如果想了解 <tt>testing</tt>/<tt>unstable</tt> 中的相對應套件與當前系統安裝的套件有何差別，使用 <tt>apt-cache policy</tt>&mdash;會好得多。
<example>
# apt-get   check           # 更新暫存區並檢查損壞的套件
$ apt-cache search  <var>pattern</var> # 搜尋套件的文字敘述
$ apt-cache policy  <var>package</var> # 套件的 priority/dists 資訊
$ apt-cache show -a <var>package</var> # show description of package in all dists
$ apt-cache showsrc <var>package</var> # show description of matching source package
$ apt-cache showpkg <var>package</var> # 套件的除錯資訊
# dpkg  --audit|-C          # search for partially installed packages
$ dpkg {-s|--status} <var>package</var> ... # 已安裝套件的敘述
$ dpkg -l <var>package</var> ...       # 已安裝套件的狀態 (一行一個)
$ dpkg -L <var>package</var> ...       # 列出套件安裝的檔案
</example>
<!-- Erase this when manual page gets fixed.  FIXME -->
<tt>apt-cache showsrc</tt> 在 Woody release 時沒有文件，但是會動 :)
<p>
你也可以在下列的地方找到套件資訊 (我用 <tt>mc</tt> 來瀏覽) ：
<example>
/var/lib/apt/lists/*
/var/lib/dpkg/available
</example>
比較下面的檔案可以正確的了解最近幾個安裝的過程對系統造成了那些改變。
<example>
/var/lib/dpkg/status
/var/backups/dpkg.status*
</example>

</sect1>

<sect1 id="apt-get-auto">Unattended installation with APT
<p>
For an unattended installation，請在 <file>/etc/apt/apt.conf</file> 加入一行：
<example>
Dpkg::Options {"--force-confold";}
</example>
這等同於執行 <tt>aptitude -y install <var>packagename</var></tt> 或 <tt>apt-get -q -y install <var>packagename</var></tt>。因為這個作法是對所有的提示都回答 "yes" 的，所以可能會造成問題，請小心使用。參閱 <manref name="apt.conf" section="5"> 和 <manref name="dpkg" section="1"> 。
<p>
你可以在稍後用 <ref id="reconfigure"> 的方法重新設定特定的套件。

<sect1 id="reconfigure">重新設定已安裝的套件
<p>
使用下面的指令來重新設定任何已安裝的套件。
<example>
# dpkg-reconfigure --priority=<var>medium</var> <var>package</var> [...]
# dpkg-reconfigure --all   # 重新設定所有的套件
# dpkg-reconfigure locales # 產生額外的 locales
# dpkg-reconfigure --p=<var>low</var> xserver-xfree86 # 重新設定 X server
</example>
如果你要永久設定 <prgn>debconf</prgn> 為對話窗模式，請對 <prgn>debconf</prgn> 進行重設定。
<p>
有些程式是用做特殊設定的 scripts 。
<footnote>
Some <prgn>*config</prgn> scripts are disappearing in the newer Sarge 
releases and the package configuration functionality are moved to
the <prgn>debconf</prgn> system.
</footnote>
<example>
apt-setup     - 建立 /etc/apt/sources.list
install-mbr   - 安裝 Master Boot Record manager
tzconfig      - 設定本地時區
gpmconfig     - 設定 gpm mouse daemon
sambaconfig   - 在 Potato 時設定 Samba (Woody 時使用 debconf)
eximconfig    - 設定 Exim (MTA)
texconfig     - 設定 teTeX
apacheconfig  - 設定 Apache (httpd)
cvsconfig     - 設定 CVS
sndconfig     - 設定音效系統
...
update-alternatives - 設定預設的指令， e.g., vim as vi
update-rc.d         - System-V init script management
update-menus        - Debian 選單系統
...
</example>
</sect1>

<sect1 id="remove">移除和清除套件
<p>
移除套件但保留它的設定檔：
<example>
# aptitude remove <var>package</var> ...
# dpkg   --remove <var>package</var> ...
</example>
移除套件並清除所有的設定檔：
<example>
# aptitude  purge  <var>package</var> ...
# dpkg    --purge  <var>package</var> ...
</example>
</sect1>

<sect1 id="hold">維持舊的套件
<p>
舉例來說，下面的指令可以在 <prgn>dselect</prgn> 和 <tt>aptitude install <var>package</var></tt> 時維持 <package>libc6</package> 和 <package>libc6-dev</package> 的版本：
<example>
# echo -e "libc6 hold\nlibc6-dev hold" | dpkg --set-selections
</example>
但這個方法擋不住 <tt>aptitude install <var>package</var></tt> 。如果要在 <tt>aptitude  upgrade <var>package</var></tt> 或 <tt>aptitude dist-upgrade</tt> 時自動降級來維持版本的話，在 <file>/etc/apt/preferences</file> 中加入：
<example>
Package: libc6
Pin: release a=stable
Pin-Priority: 2000
</example>
在這裡的 "<tt>Package:</tt>" 不能用類似 "<tt>libc6*</tt>" 的用法。如果你要所有有關 <package>glibc</package> 的二進位套件都維持同步的話，你需要明確地把它們都列出來。
<p>
下面的指令可以列出被維持住的套件：
<example>
dpkg --get-selections "*"|grep -e "hold$"
</example>
</sect1>

<sect1 id="mixedsys"> <tt>stable</tt>/<tt>testing</tt>/<tt>unstable</tt> 混合系統
<p>
<prgn>apt-show-versions</prgn> 能以 distribution 來列出可用的套件版本。
<example>
$ apt-show-versions | fgrep /testing | wc
... 在 testing 中的套件數目
$ apt-show-versions -u
... 列出可升級的套件
$ aptitude install `apt-show-versions -u -b | fgrep /unstable`
... 將所有 unstalbe 的套件升級至各自最新的版本
</example>
</sect1>

<sect1 id="cache">刪除暫存的套件檔
<p>
用 APT 安裝的套件會在 <file>/var/cache/apt/archives/</file> 留下暫存的套件檔。這些檔案是可以刪除的。
<example>
# aptitude autoclean # 只刪除無用的套件檔
# aptitude clean     # 刪除所有的暫存套件檔
</example>
</sect1>


<sect1 id="record">記錄/複製系統設定
<p>
要把套件選取狀態複製到本地端：
<example>
$ dpkg --get-selections "*" &gt;<var>myselections</var>   # 或使用 \*
</example>
<tt>"*"</tt> 使 <tt><var>myselections</var></tt> 也包含標記為 "purge" 的套件。
<p>
你可將這個檔案傳到另一台電腦，並用下列的方法把它安裝起來：
<example>
# dselect update
# dpkg --set-selections &lt;<var>myselections</var>
# apt-get -u dselect-upgrade    # <var>或</var> dselect install
</example>
</sect1>

<sect1 id="port">把套件引入 <tt>stable</tt> 系統
<p>
將 <tt>stable</tt> 系統進行部分升級，並在些環境下以重編建的方式來使用套件，這個方法是可以期待的。這個方法可以避免因相依性而對大量套件升級。首先，將下列來源加入 <file>/etc/apt/sources.list</file> ：
<example>
deb-src &http-us;debian testing \
 main contrib non-free
deb-src &http-non-us;debian-non-US testing/non-US \
 main contrib non-free
deb-src &http-us;debian unstable \
 main contrib non-free
deb-src &http-non-us;debian-non-US unstable/non-US \
 main contrib non-free
</example>
因為螢幕輸出的限制，上面 <tt>deb-src</tt> 中每一項都分成了2行，實際上在 <file>sources.list</file> 中它們都應該是單行。
<p>
然後取得源碼套件並編建出本地端的套件：
<example>
$ apt-get update  # 更新源碼套件的搜尋列表
$ apt-get source <var>package</var>
$ dpkg-source -x <var>package.dsc</var>
$ cd <var>package-version</var>
  ... 檢查必需的套件 ( 在 .dsc 檔中的 Build-depends) 並也一起安裝。
      你也需要 "fakeroot" 套件。

$ dpkg-buildpackage -rfakeroot 

  ... 或是 (no sig)
$ dpkg-buildpackage -rfakeroot -us -uc # 如果需要的話，再使用 "debsign" 

  ... 然後就安裝吧
$ su -c "dpkg -i <var>packagefile.deb</var>"
</example>
通常，你會需要安裝一些以 "-dev" 結尾的套件以滿足相依性的要求。 <prgn>debsign</prgn> 在 <package>devscripts</package> 套件中。 <prgn>auto-apt</prgn> 可以輕鬆解決相依性的問題。請使用 <prgn>fakeroot</prgn> 以避免不必要的 root 帳號使用。
<p>
在 Woody 中，這些相依性可被簡化。例如編譯 <package>pine</package> 源碼套件：
<example>
# apt-get build-dep pine
# apt-get source -b pine
</example>
</sect1>

<sect1 id="local">本地端的套件 archive
<p>
為了要建立相容於 APT 和 <prgn>dselect</prgn> 系統的本地端套件，需要建立 <file>Packages</file> 檔，而且套件檔需要被放在特別的檔案目錄樹中。
<p>
可以用下列的方法來建立類似官方 Debian archive 的本地端  <tt>deb</tt> repository ：
<example>
# aptitude install dpkg-dev
# cd <var>/usr/local</var>
# install -d <var>pool</var> # 套件實體是放在這裡
# install -d dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>
# ls -1 <var>pool</var> | sed 's/_.*$/ <var>priority</var> <var>section</var>/' | uniq &gt; <var>override</var>
# editor <var>override</var> # 調整 <var>priority</var> 和 <var>section</var>
# dpkg-scanpackages <var>pool</var> <var>override</var> <var>/usr/local</var>/ \
   &gt; dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>/Packages
# cat &gt; dists/<var>unstable</var>/<var>main</var>/Release &lt;&lt; EOF
Archive: <var>unstable</var>
Version: <var>3.0</var>
Component: <var>main</var>
Origin: <var>Local</var>
Label: <var>Local</var>
Architecture: <var>i386</var>
EOF
# echo "deb file:<var>/usr/local</var> <var>unstable</var> <var>main</var>" \
   &gt;&gt; /etc/apt/sources.list
</example>
<p>
不然，你也可以用一個快速但骯髒的方法來建立本地端的 <tt>deb</tt> repository ：
<example>
# aptitude install dpkg-dev
# mkdir <var>/usr/local/debian</var>
# mv <var>/some/where/package.deb</var> <var>/usr/local/debian</var>
# dpkg-scanpackages <var>/usr/local/debian</var> /dev/null | \
  gzip - &gt; <var>/usr/local/debian</var>/Packages.gz
#  echo "deb file:<var>/usr/local/debian</var> ./" &gt;&gt; /etc/apt/sources.list
</example>
<p>
把這些目錄開放給 HTTP 或 FTP 存取，並在 <file>/etc/apt/sources.list</file> 中設定相對應的位址，就可以遠端存取這些 archives 了。

<sect1 id="alien">轉換或安裝外來的二進位套件
<p>
<package>alien</package> 可將 Red Hat <tt>rpm</tt> ， Stampede <tt>slp</tt> ， Slackware <tt>tgz</tt> 和 Solaris <tt>pkg</tt> 的二進位套件檔案格式轉成  &debian; 的 <tt>deb</tt> 套件。如果你不要使用你已安裝在系統中的套件，而想裝來自其他 Linux distribution 的套件的話，你可以使用 <prgn>alien</prgn> 來將其轉成你喜愛的套件格式並安裝。 <package>alien</package> 也支援 LSB 套件。
</sect1>

<sect1 id="auto-apt">Automatically install command
<p>
<prgn>auto-apt</prgn> is an on-demand package installation tool.
<example>
$ sudo auto-apt update
 ... update database
$ auto-apt -x -y run
Entering auto-apt mode: /bin/bash
Exit the command to leave auto-apt mode.
$ less /usr/share/doc/med-bio/copyright # access non-existing file
 ...  Install the package which provide this file.
 ... Also install dependencies
</example>
</sect1>

<sect1 id="debsums">驗證已安裝的套件檔
<p>
<prgn>debsums</prgn> 以 MD5 偵錯碼的方式來驗證已安裝的套件檔。有些套件並沒有可用的 MD5 偵錯碼。有個可能的暫時性的修正方法提供給系統管理員：
<example>
# cat >>/etc/apt/apt.conf.d/90debsums
DPkg::Post-Install-Pkgs {"xargs /usr/bin/debsums -sg";};
^D
</example>
per Joerg Wendland <email>joergland@debian.org</email> (untested).

<![%f-ref;[
<sect1 id="spy"><file>sources.list</file> 最佳化
<p>
簡而言之，像我這樣住得離美國很遠的人，用什麼奇特的方法建出來的最佳化 <file>sources.list</file> 其實並沒什麼顯著的效果。還是用 <prgn>apt-setup</prgn> 手動選個靠近的站台吧。
<p>
<prgn>apt-spy</prgn> 會依 latency 和頻寬來自動產生 <file>sources.list</file> 檔。 <prgn>netselect-apt</prgn> 會建立更完整的 <file>sources.list</file> ，但在選站台時用的是比較差的方法 (比較 ping 的時間) 。
<example>
# aptitude install apt-spy
# cd /etc/apt ; mv sources.list sources.list.org
# apt-spy -d testing -l sources.apt
</example>
</sect1>

]]>


</sect>

<sect id="pecuriarities">Debian 其它特別之處

<sect1 id="dpkg-divert"><prgn>dpkg-divert</prgn> 指令
<p>
<!-- copied from manual page -->
檔案移轉是強迫 <prgn>dpkg</prgn> 把某個檔案安裝在一個<strong>被轉移過的</strong>位置，而非預設的位置。當 &debian; 套件的 scripts 發生衝突時，可用<strong>移轉</strong>來將檔案移開。系統管理者也可以用移轉來多載套件的設定檔，或是用在當安裝套件新版本時，包括有些沒被標記為 conffiles 而需要被 <prgn>dpkg</prgn> 所保留的檔案。<![%f-ref;[（參閱 <ref id="conffile"> ）]]>。
<example>
# dpkg-divert [--add]  <var>filename</var> # 加入 "diversion"
# dpkg-divert --remove <var>filename</var> # 刪除 "diversion"
</example>
平時不要請使用 <prgn>dpkg-divert</prgn> ，除非是必要的情況下。
</sect1>

<sect1 id="equivs"><package>equivs</package> 套件
<p>
如果你從源碼來編譯程式，最好是能將它做成本地的 Debian 套件 (<tt>*.deb</tt>)。最後的手段是使用 <tt>equivs</tt> 。
<example>
Package: equivs
Priority: extra
Section: admin
Description: Circumventing Debian package dependencies
 This is a dummy package which can be used to create Debian
 packages, which only contain dependency information.
</example>
</sect1>

<sect1 id="alternatives">Alternative 指令
<p>
如果想用 <prgn>vi</prgn> 來執行 <prgn>vim</prgn> ，請用 <prgn>update-alternatives</prgn> ：
<example>
# update-alternatives --display vi
...
# update-alternatives --config vi
  Selection    Command
-----------------------------------------------
      1        /usr/bin/elvis-tiny
      2        /usr/bin/vim
*+    3        /usr/bin/nvi

Enter to keep the default[*], or type selection number: 2
</example>
在 Debian alternatives 系統中的項目都以符號連結的方式放在 <file>/etc/alternatives/</file> 。
<p>
想設定你喜歡的 X 視窗環境的話，請用 <prgn>update-alternatives</prgn> 來修改 <file>/usr/bin/x-session-manager</file> 和 <file>/usr/bin/x-window-manager</file> 。<![%f-ref;[詳請請參閱 <ref id="custom-x"> 。]]>
<p>
<file>/bin/sh</file> 則就直接符號連結至 <file>/bin/bash</file> 或 <file>/bin/dash</file> 。如果要相容於舊有且 bash 化的 script 的話，用 <file>/bin/bash</file> 會比較好點，但用 <file>/bin/dash</file> 可強迫訓練你與 POSIX 相容。升級至 2.4 Linux kernel 時傾向於將其設定至 <file>/bin/dash</file> 。
</sect1>

<sect1 id="sys-v">Runlevel 
<p>
大部分的&debian;套件在安裝後是被設定在 runlevel 2 到 5 時會自動執行。
因此，&debian; 系統的 runlevel 2,3,4,5是沒有差別的，而 &debian; 是保留給系統管理者來設定。
<![%f-ref;[
<ref id="custombootscripts">說明如何自定 runlevels。
]]>
<![%q-ref;[
自定 runlevels。
]]>
這樣的 runlevels 系統是與其他有名的 GNU/Linux 發行版本完全不同。
您或許想取消 runlevel 2 上的<prgn>xdm</prgn> 或 <prgn>gdm</prgn> 在開機後自動執行 X display 管理器。您也可以試著修改 runlevel 3 的設定。
<p>
<![%f-ref;[
<ref id="runlevels"> 有更多 Runlevl 的資訊。
]]>

<sect1 id="disables">停止 daemon 服務程式
<p>
&debian; distribution 非常注重系統安全，許多 daemon 伺服程式都定位在最高安全等級，因而在預設的安裝狀態下，系統只啟動最少的可用的服務程式。
<p>
如果你不確定你執行了什麼服務程式（像 Exim ， DHCP …）的話，執行 <tt>ps aux</tt> 或檢查一下 <file>/etc/init.d/*</file> 和 <file>/etc/inetd.conf</file> 的內容。同時也<![%f-ref;[使用 <ref id="loginctrl"> 的方法]]>確認一下 <file>/etc/hosts.deny</file> 。而 <prgn>pidof</prgn> 指令也是很有用的（請參閱 <manref name="pidof" section="8">）。
<p>
在最近的 &debian; 版本中，預設 X11 是不允許（遠端） TCP/IP 連接的。<![%f-ref;[請參閱 <ref id="xtcp"> 。]]>經由 SSH 來 X forwarding 也是禁止的。<![%f-ref;[請參閱 <ref id="xssh"> 。]]>
</sect1>
</sect>

</chapt>

