<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.88" -->


<chapt id="package">Debian 套件管理系統

<p>
為了減少 &debian; 檔案庫 (repository) 的網路負擔，請在使用 APT 下載套件時，確認一下是否使用 <prgn>squid</prgn> 設定了本地端的 HTTP proxy，如果需要的話，也請在 <file>/etc/apt/apt.conf</file> 中設定 <tt>http</tt> 的值。這樣可大幅的改善網路升級的效能，尤其是當 LAN 中有多台 Debian 機器同時升級時。
<p>
儘管 <manref name="apt_preferences" section="5"> 的 pinning 功能十分強大，但它並不能解決所有的相依性問題，因為相依性的需求總傾向於拉進其它較新版本的基本套件。
<p>
<![%f-ref;[在 <ref id="chroot"> 中所敘述的方法非常適合於]]><![%q-ref;[chroot 的方法非常適合於]]>需要同時結合系統的穩定性和使用最新版軟體的情況。
<p>
本章是基於 Woody 系統所撰寫的，但大部分資訊均適用於 Potato 系統 (除了 <manref name="apt_preferences" section="5"> 和 <file>/etc/apt/preferences</file> 的相關主題之外) 。

<sect id="pkg-intro">介紹
<p>
如果你沒精力閱讀完所有的開發文件，那麼先看看本章的內容，然後就開始體驗 Debian <tt>testing</tt>/<tt>unstable</tt> 的威力吧 :-)

<sect1>主要的工具
<p>
<example>
dselect   &ndash; 使用選單介面的套件管理工具 (最上層)
dpkg      &ndash; 安裝套件 (以套件檔為中心)
apt-get   &ndash; 安裝套件 (以套件存檔區 (archive) 為中心, CLI APT)
tasksel   &ndash; 安裝 task (一組套件)
aptitude  &ndash; 安裝套件 (套件 &amp; task, 使用 ncurses 的 APT 工具)
deity     &ndash; 另一個使用 ncurses 的 APT 工具
synaptic, gsynaptic &ndash; 可供替代的圖形介面 APT 工具
</example>
這些並不是同級的工具。 <prgn>dselect</prgn> 運行於 APT (命令列指令是 <prgn>apt-get</prgn> ) 和 <prgn>dpkg</prgn> 之上。
<p>
APT 使用 <file>/var/lib/apt/lists/*</file> 來追蹤可用的套件，而 <prgn>dpkg</prgn> 則是使用 <file>/var/lib/dpkg/available</file> 。如果直接用 <prgn>apt-get</prgn> 或類似工具如 <prgn>aptitude</prgn> 來安裝套件的話，別忘了要使用 dselect 的 <tt>[U]pdate</tt> 選項，或在執行 <tt>dselect update</tt> 、 <tt>tasksel</tt> 或 <tt>dpkg -l</tt> 前，以命令列執行 "<tt>dselect update</tt>" 來更新 <file>/var/lib/dpkg/available</file> 。
<p>
在處理套件相依性的方式上， <prgn>apt-get</prgn> 會自動搜尋下載 <strong>depends</strong> 的套件，但不會理睬 <strong>recommends</strong> 和 <strong>suggests</strong> 的套件，而 <prgn>dselect</prgn> 在套件的選擇方面提供了選單方式的操作，對 <strong>depends</strong> 、 <strong>recommends</strong> 和 <strong>suggests</strong> 三種套件均給出選取的提示。 <prgn>aptitude</prgn> 則提供了選項能自動下載安裝所有 <strong>depends</strong> 、 <strong>recommends</strong> 和 <strong>suggests</strong> 的套件。<![%f-ref;[請參閱 <ref id="depends"> 。]]>
</sect1>

<sect1>方便的工具
<p>
<example>
apt-cache         - 檢查本地端暫存的套件 archive 。
dpkg-reconfigure  - 重新設定一個已經安裝的套件
                    (如果它是使用 debconf 的話)
dpkg-source       - 管理套件源碼檔案
dpkg-buildpackage - 自動重新編建套件檔案
...
</example>
</sect1>
</sect>

<sect id="apt-install">&debian; 套件管理的基礎
<p>
你可以用 <em>task</em> 的方式來安裝一整組的套件，還可以使用下列所介紹的套件管理工具來個別安裝套件或升級系統。<![%f-ref;[也請參考 <ref id="install"> ， <ref id="woody"> 和 <ref id="bin-editor"> 。]]>

<sect1 id="tasksel">用 <prgn>tasksel</prgn> 或 <prgn>aptitude</prgn> 來安裝 <em>task</em> 
<p>
<prgn>tasksel</prgn> 是 <strong>Debian Task 安裝工具</strong>，它在系統安裝的過程中作為一種"<tt>簡易</tt>"的安裝方式。
<p>
如果你希望安裝由多個套件所共同組成的常見功能，最好的辦法就是使用這種方式來安裝。使用如下的命令：
<example>
# dselect update
# tasksel
</example>
<p>
<prgn>aptitude</prgn> 也可以使用 <em>task</em>。用它不僅可以選擇 <em>tasks</em> 還可以對 <em>task</em> 以選單的方式來去除選取個別的套件。
</sect1>

<sect1 id="setup-apt">設定 APT 系統
<p>
如果你要用這裡所說的混合系統的話，可能會造成一些套件相依性的衝突。最好不要用混合的系統。接下來是給喜歡實驗的人應知道的風險。
<!--
Yes. This is sloppy fix but better than nothing.  I saw many newbie
confused.
-->
<p>
為了要在跟隨 <tt>testing</tt> distribution 時作出有選擇性的升級，可以用 <ref id="woody-transition"> 中描述的方法來設定 APT 系統 (&gt;Woody)，使用 <manref name="apt_preferences" section="5"> 的功能。
<p>
首先，在 <file>/etc/apt/sources.list</file> 中加入 <tt>stable</tt> 、 <tt>testing</tt> 和 <tt>unstable</tt> 的來源，接著編輯 <file>/etc/apt/preferences</file> 以設定合適的 Pin-Priority 。
<footnote>
我留下這段敘述是為了維持和其他部分的一致性。如果你真的使用 <tt>testing</tt> 或 <tt>unstable</tt> 的話，你實際上應該移除 <file>/etc/apt/sources.list</file> 和 <file>/etc/apt/preferences</file> 中的 <tt>stable</tt> 來源。這是因為 <tt>testing</tt> 剛開始即為 <tt>stable</tt> 的複本。
</footnote>
<example>
Package: *
Pin: release a=stable
Pin-Priority: 500

Package: *
Pin: release a=testing
Pin-Priority: 600

Package: *
Pin: release a=unstable
Pin-Priority: 50
</example>


<sect1 id="dselect"><prgn>dselect</prgn>
<p>
當你啟動程式時， <prgn>dselect</prgn> 會自動選取所有 "Required" 、 "Important" 和 "Standard" 分類的套件。在 Potato 系統中，某些大型的應用程式像 teTeX 和 Emacs 屬於這些套件中，而在初次安裝系統時最好手動取消對它們的選取 (輸入 `_') 。在 Woody 中，這些程式則被移入 "Optional" 的套件分類。
<p>
<prgn>dselect</prgn> 的使用介面有點怪。有四個不太明確的指令 (都是大寫的指令！)：
<example>
按鍵        動作
Q           離開。確認目前所選取的並離開程式。
            (override dependencies)
R           回復 (Revert)！ I did not mean it.
D           不管你 (Damn it)！我不管 dselect 怎麼想的。照我的做就是了！
U           都照建議 (sUggested) 的來做
</example>
使用 <tt>D</tt> 和 <tt>Q</tt> 可以選擇有衝突的選項。要小心地用這些指令。目前 <prgn>dselect</prgn> 是一個成熟的選單式工具，在對 <strong>suggests</strong> 和 <strong>recommends</strong> 套件分類的選擇控制方面，它提供相當棒的細微操作能力。
<p>
在 <file>/etc/dpkg/dselect.cfg</file> 中加上一行 "expert" 選項以減少干擾。對於速度慢的機器，可以在其它速度快的機器上執行 <prgn>dselect</prgn> 先選好套件，然後用 <tt>apt-get install</tt> 來安裝。
<p>
對於 Pin-Priority 沒有提到的套件， <prgn>dselect</prgn> 不會理它們。
</sect1>

<sect1 id="aptitude"><prgn>aptitude</prgn>
<p>
<prgn>aptitude</prgn> 是一個類似 <prgn>dselect</prgn> 的新選單式套件安裝工具。也可以作為命令列工具 <prgn>apt-get</prgn> 的另一種選擇。請參閱 <manref name="aptitude" section="1"> 。
<p>
<prgn>aptitude</prgn> 用單一按鍵指令，通常是小寫字母。
<example>
按鍵        動作
F10         選單
?           按鍵說明
u           更新套件 archive 資訊
g           下載並安裝選取的套件
q           退出目前畫面並儲存修改
x           退出目前畫面並放棄修改
Enter       瀏覽某套件的相關訊息
</example>
<prgn>aptitude</prgn> 提供了選項可自動選取所有 <strong>depends</strong> 、 <strong>recommends</strong> 和 <strong>suggests</strong> 分類的套件。可在 <tt>F10 -> Options -> Dependency handling</tt> 選單中設定。
<p>
<prgn>aptitude</prgn> 可存取套件的所有版本。
</sect1>

<sect1 id="apt-commands"><prgn>apt-cache</prgn> 和 <prgn>apt-get</prgn> 命令
<p>
當像之前的例子一樣跟隨著 <tt>testing</tt>，我們可以下列的指令來管理系統。
<list>
<item><tt>apt-get -u upgrade</tt>
 <p>跟隨 <tt>testing</tt> distribution ，當安裝 <tt>testing</tt> 的套件時，會升級系統中所有與其相依的套件。
<item><tt>apt-get -u dist-upgrade</tt>
 <p>跟隨 <tt>testing</tt> distribution ，當安裝和分析 <tt>testing</tt> 相依的套件時，會升級系統中所有與其相依的套件。
<item><tt>apt-get -u dselect-upgrade</tt>
 <p>跟隨 <tt>testing</tt> distribution ，跟據 <prgn>dselect</prgn> 的選取來升級系統中所有的套件。
<item><tt>apt-get -u install <var>package</var></tt>
 <p>由 <tt>testing</tt> distribution 來安裝 <var>package</var> 和所有與其相依的套件。
<item><tt>apt-get -u install <var>package</var>/unstable</tt>
 <p>由 <tt>unstable</tt> distribution 安裝 <var>package</var> ，並由 <tt>testing</tt> distribution 安裝相依的套件。
<item><tt>apt-get -u install -t unstable <var>package</var></tt>
 <p>將 <tt>unstable</tt> 的 Pin-Priority 設為 990，會由 <tt>unstable</tt> distribution 安裝 <var>package</var>，也從 <tt>unstable</tt> distribution 安裝相依的套件。
<item><tt>apt-cache policy <var>foo bar ...</var></tt>
 <p>檢查 <var>foo bar ...</var> 套件的狀態。
<item><tt>apt-cache show <var>foo bar ...</var> | less</tt>
 <p>檢查 <var>foo bar ...</var> 套件的資料。
<item><tt>apt-get install <var>foo=2.2.4-1</var></tt>
 <p>安裝 <var>foo</var> 套件的特定版本 <var>2.2.4-1</var> 。
<item><tt>apt-get -u install <var>foo bar-</var></tt>
 <p>安裝 <var>foo</var> 套件，並移除 <var>bar</var> 套件
<item><tt>apt-get remove <var>bar</var></tt>
 <p>移除 <var>bar</var> 套件，但完整保留設定的檔案。
<item><tt>apt-get remove --purge <var>bar</var></tt>
 <p>移除 <var>bar</var> 套件，也把所有的設定檔移除。
</list>
在上面的例子中，在<prgn>apt-get</prgn> 中使用 <tt>-u</tt> 選項會列出所有要升級的套件列表，並在動作前請示使用者。下面的作法會使 <tt>-u</tt> 選項變成預設的動作：
<example>
$ cat &gt;&gt; /etc/apt/apt.conf &lt;&lt; .
// 總是列出要升級的套件 (-u)
APT::Get::Show-Upgraded "true";
.
</example>
<p>
使用 <tt>-s</tt> 選項則只是做個模擬升級的動作，而不是真正做了升級。

<sect1 id="apt-tracking">跟隨一個 &debian; distribution 的風格
<p>
根據你想要跟隨的 &debian; 風格，你可以修改 <ref id="setup-apt"> 中的 <file>/etc/apt/preferences</file> 範例來符合你的需求：
<example>
跟隨 stable ：            將 testing 的 Pin-Priority 改為 50
跟隨 testing ：           保持之前的設定
跟隨 testing(unstable) ： 將 unstable 的 Pin-Priority 改為 500
跟隨 unstable(testing) ： 將 unstalbe 的 Pin-Priority 改為 800
</example>
A guideline for the choice of Pin-Priority is to move from the top to bottom
in the above table as the time moves from a time immediately after a
distribution release to a time of freeze for the next release.
<p>
注意：
跟隨 &debian; 的 <tt>testing</tt> 風格會有的副作用是安全修正會很慢。
<p>
先提醒你，如果你在 &debian; 的 <tt>stable</tt> 中混合使用 <tt>testing</tt> ，或在 <tt>stable</tt> 中混合使用 <tt>unstable</tt> 的話，將會不經意地從 <tt>testing</tt> 或 <tt>unstable</tt> 中拉入可能有問題的關鍵套件。
<p>
在 <url id="&examples;" name="examples subdirectory"> 中的 <file>preferences.testing</file> 和 <file>preferences.unstable</file> ，有些範例是在 <file>/etc/apt/preferences</file> 中設定，可將某些關鍵的套件鎖定在較成熟的版本，即使是在跟隨一些非必要套件的較不成熟的版本時。另一方面， <file>preferences.stable</file> 可強迫所有的套件都降級至 <tt>stable</tt> 。

<sect1 id="apt-stable">將所有套件降級至 <tt>stable</tt>
<p>
要把所有的套件降級至 <tt>stable</tt>，請依下列來編輯 <file>/etc/apt/preferences</file> 檔：
<example>
Package: *
Pin: release a=stable
Pin-Priority: 1001
</example>
然後執行 "<tt>apt-get upgrade</tt>" ，因為 Pin-priority &gt; 1000 的原因，所以會強制降級。警告你，這會在相依性上造成點小問題。

<sect1 id="apt-preferences"><file>/etc/apt/preferences</file> 概觀
<p>
在 <ref id="setup-apt"> 中的 <file>/etc/apt/preferences</file> 範例中，第一行的 "Package: *" 表示這一段的指令會作用在所有套件上。你可以把 "*" 換成某個套件名稱來為某個特定的套件設定 Pin-Priority 。
<p>
在第二行中， "Pin: release a=stable" 的意思是 <prgn>apt-get</prgn> 會從在其 <file>Release</file> 檔中有 "Archive: stable" 的 archive 來下載 <file>Packages.gz</file> 檔。
<p>
在最後一行中的 "Pin-Priority: 500" 則是指定 Pin-Priority 為 500 。
<p>
如果多個套件同名的話，系統通常會安裝具有最高 Pin-Priority 的套件。  
<p>
在這裡， Pin-Priority 的意思是：
<list>
<item>1001 以上： 可降級的優先權。
 <p>如果 Pin-Priority 在這個範圍的話，是允許將套件降級的。
<item>100 到 1000 ：標準的優先權。
 <p>不允許將套件降級。有幾個關鍵的 Pin-Priority 值是：
<list>
<item>990 ： 當指定了 <manref name="apt-get" section="8"> 選項中的 <tt>--target-release</tt> 或 <tt>-t</tt> 時所使用的優先權。
<item>500 ： 所有預設套件檔的優先權。
<item>100 ： 目前已安裝的套件檔的優先權。
</list>
<item>0 到 99 ：非自動優先權。（只有尚未安裝而且也沒有其他可用的版本的時候，才會安裝）
<item>小於 0 ：絕不會用這個版本的套件。
</list>
如果把 <file>/etc/apt/apt.conf</file> 如下設定，則會有和 <tt>--target-release</tt> 一樣的效果。
<example>
# echo 'APT::Default-Release "testing";' &gt;&gt; /etc/apt/apt.conf
</example>
命令列選項 <tt>--target-release</tt> 和 <file>/etc/apt/apt.conf</file> 中的設定會取代 <file>/etc/apt/preferences</file> 中的設定。在把玩 <file>/etc/apt/preferences</file> 的時候小心兩者衝突。

<sect id="survival">Debian 生存指令
<p>
掌握了這些知識，就能讓你享受<strong>無窮盡</strong>的"升級"了 :-)

<sect1 id="bug-check">檢查 Debian 中的 bugs 並尋求幫助
<P>
如你使用某個套件出現問題，在尋求幫助或發送錯誤報告之前請確認查看過下列網站（ <prgn>lynx</prgn> 、 <prgn>links</prgn> 和 <prgn>w3m</prgn> 都很好用）：
<example>
$ lynx &bugs;
$ lynx &bugs;<var>package-name</var>  # 如果你知道套件名稱
$ lynx &bugs;<var>bugnumber</var>     # 如果你知道錯誤序號
</example>
在 Google (www.google.com) 中使用關鍵字 "site:debian.org" 搜索。
<p>
如有疑問，可閱讀說明文件。設定 <tt>CDPATH</tt> 如下：
<example>
export CDPATH=.:/usr/local:/usr/share/doc
</example>
並輸入
<example>
$ cd <var>packagename</var>
$ pager README.Debian # 如果存在的話
$ mc 
</example>
<![%f-ref;[
在 <ref id="support"> 有更多的參考資料。
]]>
</sect1>

<sect1 id="apt-trouble">APT 升級的錯誤排除方法
<p>
在升級 <tt>unstable</tt>/<tt>testing</tt> 時可能會遇到在 <ref id="upgrade-system"> 所描述的套件相依性問題。在大多數情況下，是因為無法滿足你將要升級的套件所需要的相依性問題。這個問題可用下面的方法來解決：
<example>
# apt-get dist-upgrade
</example>
如果這也沒辦法的話，就重複使用下列之一的方法至到問題自動解決：
<example>
# apt-get upgrade -f         # 即使遇到錯誤也繼續升級
... 或
# apt-get dist-upgrade -f    # 即使遇到錯誤也繼續 dist-upgrade
</example>
<p>
有些升級用的 script 的確有問題，所以會持續出現狀況。通常要解決這個狀況，你最好能檢查一下這些討厭套件中的 <file>/var/lib/dpkg/info/<var>packagename</var>.{post-,pre-}{install,removal}</file> script ，並執行：
<example>
# dpkg --configure -a    # 設定所有部分安裝的套件
</example>
<p>
如果 script 抱怨它找不到設定檔的話，在 <file>/etc</file> 中找找對應的設定檔。如果你找到的是個有 <tt>.new</tt> 的副檔名（或是類似的東西），就把它的後綴去除掉（用 <prgn>mv</prgn> ）。
<p>
在安裝 <tt>unstable</tt>/<tt>testing</tt> 系統時也可能遇到相依性問題。可用這個方法巧妙的解決：
<example>
# apt-get install -f <var>package</var> # override broken dependencies
</example>
<p>
要修正這些問題，另一個可用的方法是使用 <package>equivs</package> 套件。請參閱 <file>&f-equivs;</file><![%f-ref;[ 和 <ref id="equivs">]]> 。
</sect1>

<sect1 id="rescue-dpkg">使用 <prgn>dpkg</prgn> 來救援
<p>
在一個受損的系統上，想要針對崩潰的 <prgn>dselect</prgn> (APT) 進行回復的話，可以不透過 APT 而使用 <prgn>dpkg</prgn> 來達成：
<example>
# cd /var/cache/apt/archives
# dpkg -i libc6* libdb2* perl*
# dpkg -i apt* dpkg* debconf*
# dpkg -i *  # 直到沒有錯誤發生
</example>
如果套件遺失的話，則可由 <url id="&mirror-site;" name="mirror sites"> 取得：
<example>
# mc            # 使用 "FTP link" 指向 Debian FTP 伺服器
</example>
現在，在 HTTP/FTP 伺服器上的實際套件可能不是在傳統的 <file>/dist</file> 目錄，而是在新的 <file>/pool</file> 目錄下。<![%f-ref;[（請參閱 <ref id="pools"> 。）]]>
<p>
然後，用下面的方法安裝：
<example>
# dpkg -i /var/cache/apt/archives/<var>packagefile.deb</var>
</example>
對於有問題的相依性，可以修正它，或是用：
<example>
# dpkg --ignore-depends=<var>package1</var>,... -i <var>packagefile.deb</var>
# dpkg --force-depends -i <var>packagefile.deb</var>
# dpkg --force-depends --purge <var>package</var>
# dpkg --force-confmiss -i <var>packagefile.deb</var> # Install missing conffile
</example>
</sect1>

<sect1 id="recover-status">回復套件的選取狀態的資料
<p>
不論是什麼原因，如果 <file>/var/lib/dpkg/status</file> 亂掉了的話，則 &debian; 系統會失去套件的選取狀態的資料，這是很糟糕的事。到 <file>/var/lib/dpkg/status-old</file> 或 <file>/var/backups/dpkg.status.*</file> 找找看舊的 <file>/var/lib/dpkg/status</file> 檔。
<p>
因為 <file>/var/backups/</file> 這個目錄中有很多重要的系統資料，所以把它放到分開的分割區會是個不錯的主意。
<p>
如果連舊的 <file>/var/lib/dpkg/status</file> 檔也找不到了，你仍可以從 <file>/usr/share/doc/</file> 目錄來回復這些資料。
<example>
# ls /usr/share/doc | \
  grep -v [A-Z] | \
  grep -v '^texmf$' | \
  grep -v '^debian$' | \
  awk '{print $1 " install"}' | \
  dpkg --set-selections
# dselect --expert # 重新安裝系統，如果需要的話去除一些選取
</example>

<sect1 id="rescue-var">在 <file>/var</file> 崩潰後救援系統
<p>
因為 <file>/var</file> 目錄下包含了常被更動的資料，如 mail ，所以比較容易會有損壞。
把它放到獨立的分割區可以減少風險。如果災難發生了，你必需重建 <file>/var</file> 以回復 &debian; 系統。
<p>
從相同或較舊版本的最簡化的 &debian; 系統中取得 <file>/var</file> 目錄內容的架構，例如 <file><url id="&var-tar-gz;" name="var.tar.gz"></file>，將它放入受損系統的根目錄，然後
<example>
# cd /
# mv var var-old      # 如果還留下有用的資料的話
# tar xvzf var.tar.gz # 使用 Woody 架構的檔案
# aptitude            # 或是用 dselect
</example>
上述步驟應可使系統恢復工作。使用 <ref id="recover-status"> 中描述的技術來加快套件選取資料的恢復。
([FIXME] ：這個流程需要更多的實驗來驗證。)
</sect1>

<sect1 id="un-bootable">把套件安裝到一個無法開機的系統
<p>
用 Debian 救援磁片/CD 或是一個多重開機的 Linux 系統的其它分割區來開機進入 Linux 。<![%f-ref;[請參閱 <ref id="booting"> 。]]>在 <file>/target</file> 掛上這個無法開機的系統，並使用 <prgn>dpkg</prgn> 的 chroot 安裝模式。
<example>
# dpkg --root /target -i <var>packagefile.deb</var>
</example>
然後設定並解決問題。
<p>
By the way, if a broken <prgn>lilo</prgn> is all that prevents booting, you can boot using 
a standard Debian rescue disk. At boot prompt, assuming the root partition of 
your Linux installation is in <file>/dev/hda12</file> and you want runlevel 3, enter:
<example>
boot: rescue root=/dev/<var>hda12</var> 3
</example>
Then you are booted into an almost fully functional system with the kernel on
floppy disk. (There may be minor glitches due to lack of kernel features or modules.) 
</sect1>

<sect1>如果 <prgn>dpkg</prgn> 指令壞了怎麼辦
<p>
如果 <prgn>dpkg</prgn> 有問題，就不能安裝任何 <tt>.deb</tt> 檔了。下列的流程可幫助你來修復這個情況。（在第一行中，你可以把 "links" 換成你喜歡的瀏覽器指令。）
<example>
$ links http://<var>http.us.debian.org</var>/debian/pool/main/d/dpkg/
  ... 下載正確的 dpkg_<var>version</var>_<var>arch</var>.deb
$ su
password: *****
# ar x dpkg_<var>version</var>_<var>arch</var>.deb
# mv data.tar.gz /data.tar.gz
# cd /
# tar xzfv data.tar.gz
</example>
如果是 <tt>i386</tt> 的話，也可以用 <tt>http://packages.debian.org/dpkg</tt> 。
</sect1>

</sect>

<sect id="debian-package">Debian 神技之指令
<p>
經過這些指令的<strong>啟示</strong>，你將可由無休止的升級地獄中解放出來，到達 Debian <strong>涅盤</strong>。 :-)

<sect1 id="info-file">檔案中的資訊
<p>
尋找特定檔案所屬的套件：
<example>
$ dpkg {-S|--search} pattern # 在已安裝套件中尋找某個 pattern
$ zgrep -e pattern <var>/local/copy/of/debian/woody/Contents-i386.gz</var>
             # 在 debian archive 中尋找符合某個檔名 pattern 的檔案
</example>
或是使用特殊的套件命令：
<example>
# apt-get install dlocate  
                 # conflicts with slocate (secure version of locate)
$ dlocate <var>filename</var>         # dpkg -L 和 dpkg -S 的快速版
...
# apt-get install auto-apt # on-demand package installation tool
# auto-apt update          # 建立 auto-apt 的 db 檔
$ auto-apt search <var>pattern</var>  
                # 尋找符合某個 pattern 的套件，不論是否安裝
</example>
</sect1>

<sect1 id="info-package">套件的資訊
<p>
從套件 archive 中尋找並顯示資訊。編輯 <file>/etc/apt/sources.list</file> 以確定 APT 指向適合的 archive(s)。如果想了解 <tt>testing</tt>/<tt>unstable</tt> 中的相對應套件與當前系統安裝的套件有何差別，使用 <tt>apt-cache policy</tt>&mdash;會好得多。
<example>
# apt-get   check           # 更新暫存區並檢查損壞的套件
$ apt-cache search  <var>pattern</var> # 搜尋套件的文字敘述
$ apt-cache policy  <var>package</var> # 套件的 priority/dists 資訊
$ apt-cache show -a <var>package</var> # show description of package in all dists
$ apt-cache showsrc <var>package</var> # show description of matching source package
$ apt-cache showpkg <var>package</var> # 套件的除錯資訊
# dpkg  --audit|-C          # search for partially installed packages
$ dpkg {-s|--status} <var>package</var> ... # 已安裝套件的敘述
$ dpkg -l <var>package</var> ...       # 已安裝套件的狀態 (一行一個)
$ dpkg -L <var>package</var> ...       # 列出套件安裝的檔案
</example>
<!-- Erase this when manual page gets fixed.  FIXME -->
<tt>apt-cache showsrc</tt> 在 Woody release 時沒有文件，但是會動 :)
<p>
你也可以在下列的地方找到套件資訊 (我用 <tt>mc</tt> 來瀏覽) ：
<example>
/var/lib/apt/lists/*
/var/lib/dpkg/available
</example>
比較下面的檔案可以正確的了解最近幾個安裝的過程對系統造成了那些改變。
<example>
/var/lib/dpkg/status
/var/backups/dpkg.status*
</example>

</sect1>

<sect1 id="apt-get-auto">Unattended installation with APT
<p>
For an unattended installation，請在 <file>/etc/apt/apt.conf</file> 加入一行：
<example>
Dpkg::Options {"--force-confold";}
</example>
這等同於執行 <tt>apt-get -q -y <var>packagename</var></tt> 。因為這個作法是對所有的提示都回答 "yes" 的，所以可能會造成問題，請小心使用。參閱 <manref name="apt.conf" section="5"> 和 <manref name="dpkg" section="1"> 。
<p>
你可以在稍後用 <ref id="reconfigure"> 的方法重新設定特定的套件。

<sect1 id="reconfigure">重新設定已安裝的套件
<p>
使用下面的指令來重新設定任何已安裝的套件。
<example>
# dpkg-reconfigure --priority=<var>medium</var> <var>package</var> [...]
# dpkg-reconfigure --all   # 重新設定所有的套件
# dpkg-reconfigure locales # 產生額外的 locales
# dpkg-reconfigure --p=<var>low</var> xserver-xfree86 # 重新設定 X server
</example>
如果你要永久設定 <prgn>debconf</prgn> 為對話窗模式，請對 <prgn>debconf</prgn> 進行重設定。
<p>
有些程式是用做特殊設定的 scripts 。
<example>
apt-setup     - 建立 /etc/apt/sources.list
install-mbr   - 安裝 Master Boot Record manager
tzconfig      - 設定本地時區
gpmconfig     - 設定 gpm mouse daemon
sambaconfig   - 在 Potato 時設定 Samba (Woody 時使用 debconf)
eximconfig    - 設定 Exim (MTA)
texconfig     - 設定 teTeX
apacheconfig  - 設定 Apache (httpd)
cvsconfig     - 設定 CVS
sndconfig     - 設定音效系統
...
update-alternatives - 設定預設的指令， e.g., vim as vi
update-rc.d         - System-V init script management
update-menus        - Debian 選單系統
...
</example>
</sect1>

<sect1 id="remove">移除和清除套件
<p>
移除套件但保留它的設定檔：
<example>
# apt-get remove <var>package</var> ...
# dpkg  --remove <var>package</var> ...
</example>
移除套件並清除所有的設定檔：
<example>
# apt-get remove --purge <var>package</var> ...
# dpkg    --purge        <var>package</var> ...
</example>
</sect1>

<sect1 id="hold">維持舊的套件
<p>
舉例來說，下面的指令可以在 <prgn>dselect</prgn> 和 <tt>apt-get -u upgrade <var>package</var></tt> 時維持 <package>libc6</package> 和 <package>libc6-dev</package> 的版本：
<example>
# echo -e "libc6 hold\nlibc6-dev hold" | dpkg --set-selections
</example>
但這個方法擋不住 <tt>apt-get -u install <var>package</var></tt> 。如果要在 <tt>apt-get -u upgrade <var>package</var></tt> 或 <tt>apt-get -u dist-upgrade</tt> 時自動降級來維持版本的話，在 <file>/etc/apt/preferences</file> 中加入：
<example>
Package: libc6
Pin: release a=stable
Pin-Priority: 2000
</example>
在這裡的 "<tt>Package:</tt>" 不能用類似 "<tt>libc6*</tt>" 的用法。如果你要所有有關 <package>glibc</package> 的二進位套件都維持同步的話，你需要明確地把它們都列出來。
<p>
下面的指令可以列出被維持住的套件：
<example>
dpkg --get-selections "*"|grep -e "hold$"
</example>
</sect1>

<sect1 id="mixedsys"> <tt>stable</tt>/<tt>testing</tt>/<tt>unstable</tt> 混合系統
<p>
<prgn>apt-show-versions</prgn> 能以 distribution 來列出可用的套件版本。
<example>
$ apt-show-versions | fgrep /testing | wc
... 在 testing 中的套件數目
$ apt-show-versions -u
... 列出可升級的套件
$ apt-get install `apt-show-versions -u -b | fgrep /unstable`
... 將所有 unstalbe 的套件升級至各自最新的版本
</example>
</sect1>

<sect1 id="cache">刪除暫存的套件檔
<p>
用 APT 安裝的套件會在 <file>/var/cache/apt/archives</file> 留下暫存的套件檔。這些檔案是可以刪除的。
<example>
# apt-get autoclean # 只刪除無用的套件檔
# apt-get clean     # 刪除所有的暫存套件檔
</example>
</sect1>


<sect1 id="record">記錄/複製系統設定
<p>
要把套件選取狀態複製到本地端：
<example>
$ dpkg --get-selections "*" &gt;<var>myselections</var>   # 或使用 \*
</example>
<tt>"*"</tt> 使 <tt><var>myselections</var></tt> 也包含標記為 "purge" 的套件。
<p>
你可將這個檔案傳到另一台電腦，並用下列的方法把它安裝起來：
<example>
# dselect update
# dpkg --set-selections &lt;<var>myselections</var>
# apt-get -u dselect-upgrade    # <var>或</var> dselect install
</example>
</sect1>

<sect1 id="port">把套件引入 <tt>stable</tt> 系統
<p>
將 <tt>stable</tt> 系統進行部分升級，並在些環境下以重編建的方式來使用套件，這個方法是可以期待的。這個方法可以避免因相依性而對大量套件升級。首先，將下列來源加入 <file>/etc/apt/sources.list</file> ：
<example>
deb-src &http-us;debian testing \
 main contrib non-free
deb-src &http-non-us;debian-non-US testing/non-US \
 main contrib non-free
deb-src &http-us;debian unstable \
 main contrib non-free
deb-src &http-non-us;debian-non-US unstable/non-US \
 main contrib non-free
</example>
因為螢幕輸出的限制，上面 <tt>deb-src</tt> 中每一項都分成了2行，實際上在 <file>sources.list</file> 中它們都應該是單行。
<p>
然後取得源碼套件並編建出本地端的套件：
<example>
$ apt-get update  # 更新源碼套件的搜尋列表
$ apt-get source <var>package</var>
$ dpkg-source -x <var>package.dsc</var>
$ cd <var>package-version</var>
  ... 檢查必需的套件 ( 在 .dsc 檔中的 Build-depends) 並也一起安裝。
      你也需要 "fakeroot" 套件。

$ dpkg-buildpackage -rfakeroot 

  ... 或是 (no sig)
$ dpkg-buildpackage -rfakeroot -us -uc # 如果需要的話，再使用 "debsign" 

  ... 然後就安裝吧
$ su -c "dpkg -i <var>packagefile.deb</var>"
</example>
通常，你會需要安裝一些以 "-dev" 結尾的套件以滿足相依性的要求。 <prgn>debsign</prgn> 在 <package>devscripts</package> 套件中。 <prgn>auto-apt</prgn> 可以輕鬆解決相依性的問題。請使用 <prgn>fakeroot</prgn> 以避免不必要的 root 帳號使用。
<p>
在 Woody 中，這些相依性可被簡化。例如編譯 <package>pine</package> 源碼套件：
<example>
# apt-get build-dep pine
# apt-get source -b pine
</example>
</sect1>

<sect1 id="local">本地端的套件 archive
<p>
為了要建立相容於 APT 和 <prgn>dselect</prgn> 系統的本地端套件，需要建立 <file>Packages</file> 檔，而且套件檔需要被放在特別的檔案目錄樹中。
<p>
可以用下列的方法來建立類似官方 Debian archive 的本地端  <tt>deb</tt> repository ：
<example>
# apt-get install dpkg-dev
# cd <var>/usr/local</var>
# install -d <var>pool</var> # 套件實體是放在這裡
# install -d dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>
# ls -1 <var>pool</var> | sed 's/_.*$/ <var>priority</var> <var>section</var>/' | uniq &gt; <var>override</var>
# editor <var>override</var> # 調整 <var>priority</var> 和 <var>section</var>
# dpkg-scanpackages <var>pool</var> <var>override</var> <var>/usr/local</var>/ \
   &gt; dists/<var>unstable</var>/<var>main</var>/binary-<var>i386</var>/Packages
# cat &gt; dists/<var>unstable</var>/<var>main</var>/Release &lt;&lt; EOF
Archive: <var>unstable</var>
Version: <var>3.0</var>
Component: <var>main</var>
Origin: <var>Local</var>
Label: <var>Local</var>
Architecture: <var>i386</var>
EOF
# echo "deb file:<var>/usr/local</var> <var>unstable</var> <var>main</var>" \
   &gt;&gt; /etc/apt/sources.list
</example>
<p>
不然，你也可以用一個快速但骯髒的方法來建立本地端的 <tt>deb</tt> repository ：
<example>
# apt-get install dpkg-dev
# mkdir <var>/usr/local/debian</var>
# mv <var>/some/where/package.deb</var> <var>/usr/local/debian</var>
# dpkg-scanpackages <var>/usr/local/debian</var> /dev/null | \
  gzip - &gt; <var>/usr/local/debian</var>/Packages.gz
#  echo "deb file:<var>/usr/local/debian</var> ./" &gt;&gt; /etc/apt/sources.list
</example>
<p>
把這些目錄開放給 HTTP 或 FTP 存取，並在 <file>/etc/apt/sources.list</file> 中設定相對應的位址，就可以遠端存取這些 archives 了。

<sect1 id="alien">轉換或安裝外來的二進位套件
<p>
<package>alien</package> 可將 Redhat <tt>rpm</tt> ， Stampede <tt>slp</tt> ， Slackware <tt>tgz</tt> 和 Solaris <tt>pkg</tt> 的二進位套件檔案格式轉成  &debian; 的 <tt>deb</tt> 套件。如果你不要使用你已安裝在系統中的套件，而想裝來自其他 Linux distribution 的套件的話，你可以使用 <prgn>alien</prgn> 來將其轉成你喜愛的套件格式並安裝。 <package>alien</package> 也支援 LSB 套件。
</sect1>

<sect1 id="debsums">驗證已安裝的套件檔
<p>
<prgn>debsums</prgn> 以 MD5 偵錯碼的方式來驗證已安裝的套件檔。有些套件並沒有可用的 MD5 偵錯碼。有個可能的暫時性的修正方法提供給系統管理員：
<example>
# cat >>/etc/apt/apt.conf.d/90debsums
DPkg::Post-Install-Pkgs {"xargs /usr/bin/debsums -sg";};
^D
</example>
per Joerg Wendland <email>joergland@debian.org</email> (untested).

<![%f-ref;[
<sect1 id="spy"><file>sources.list</file> 最佳化
<p>
簡而言之，像我這樣住得離美國很遠的人，用什麼奇特的方法建出來的最佳化 <file>sources.list</file> 其實並沒什麼顯著的效果。還是用 <prgn>apt-setup</prgn> 手動選個靠近的站台吧。
<p>
<prgn>apt-spy</prgn> 會依 latency 和頻寬來自動產生 <file>sources.list</file> 檔。 <prgn>netselect-apt</prgn> 會建立更完整的 <file>sources.list</file> ，但在選站台時用的是比較差的方法 (比較 ping 的時間) 。
<example>
# apt-get install apt-spy
# cd /etc/apt ; mv sources.list sources.list.org
# apt-spy -d testing -l sources.apt
</example>
</sect1>

]]>


</sect>

<sect id="pecuriarities">Debian 其它特別之處

<sect1 id="dpkg-divert"><prgn>dpkg-divert</prgn> 指令
<p>
<!-- copied from manual page -->
檔案<strong>移轉</strong> 是強迫 <prgn>dpkg</prgn> 把某個檔案安裝在一個<strong>被轉移過的</strong>位置，而非預設的位置。當 &debian; 套件的 scripts 發生衝突時，可用<strong>移轉</strong>來將檔案移開。系統管理者也可以用移轉來多載套件的設定檔，或是用在當安裝套件新版本時，包括有些沒被標記為 <strong>conffiles</strong> 而需要被 <prgn>dpkg</prgn> 所保留的檔案。<![%f-ref;[（參閱 <ref id="conffile"> ）]]>。
<example>
# dpkg-divert [--add]  <var>filename</var> # 加入 "diversion"
# dpkg-divert --remove <var>filename</var> # 刪除 "diversion"
</example>
平時不要請使用 <prgn>dpkg-divert</prgn> ，除非是必要的情況下。
</sect1>

<sect1 id="equivs"><package>equivs</package> 套件
<p>
如果你從源碼來編譯程式，最好是能將它做成本地的 Debian 套件 (<tt>*.deb</tt>)。最後的手段是使用 <tt>equivs</tt> 。
<example>
Package: equivs
Priority: extra
Section: admin
Description: Circumventing Debian package dependencies
 This is a dummy package which can be used to create Debian
 packages, which only contain dependency information.
</example>
</sect1>

<sect1 id="alternatives">Alternative 指令
<p>
如果想用 <prgn>vi</prgn> 來執行 <prgn>vim</prgn> ，請用 <prgn>update-alternatives</prgn> ：
<example>
# update-alternatives --display vi
...
# update-alternatives --config vi
  Selection    Command
-----------------------------------------------
      1        /usr/bin/elvis-tiny
      2        /usr/bin/vim
*+    3        /usr/bin/nvi

Enter to keep the default[*], or type selection number: 2
</example>
在 Debian alternatives 系統中的項目都以符號連結的方式放在 <file>/etc/alternatives</file> 。
<p>
想設定你喜歡的 X 視窗環境的話，請用 <prgn>update-alternatives</prgn> 來修改 <file>/usr/bin/x-session-manager</file> 和 <file>/usr/bin/x-window-manager</file> 。<![%f-ref;[詳請請參閱 <ref id="custom-x"> 。]]>
<p>
<file>/bin/sh</file> 則就直接符號連結至 <file>/bin/bash</file> 或 <file>/bin/dash</file> 。如果要相容於舊有且 bash 化的 script 的話，用 <file>/bin/bash</file> 會比較好點，但用 <file>/bin/dash</file> 可強迫訓練你與 POSIX 相容。升級至 2.4 Linux kernel 時傾向於將其設定至 <file>/bin/dash</file> 。
</sect1>

<sect1 id="sys-v">System-V <prgn>init</prgn> 和 runlevels
<p>
開機時預設的 runlevel 可在 <file>/etc/inittab</file> 中設定。
<p>
不同於其他的 distributions ， Debian 將管理 runlevel 的責任全放在系統管理者身上。在 Debian 上管理 System-V 風格的 <prgn>init</prgn> 是傾向於使用 <prgn>update-rc.d</prgn> 的 scripts 。
<p>
想要在 runlevel 1,2,3 時以 20 的 sequencing priority number (normal) 來執行 <file>/etc/init.d/<var>name</var></file> ，而在 runlevel 4,5 停止的話，可執行下面指令：
<example>
# update-rc.d <var>name</var> start 20 1 2 3 . stop 20 4 5 .
</example>
想要移除在 <prgn>init.d</prgn> 中的某個 script 的符號連結的話，可執行下面的指令：
<example>
# update-rc.d -f <var>name</var> remove
</example>
在編輯 runlevels 時我偷吃點步。我用 <prgn>mc</prgn> 的 shell 提示符號中用 Alt-Enter 來複製連結，並用 <prgn>mv</prgn> 指令來手動編輯。舉個例子：
<example>
# mv S99xdm K99xdm # 停止 xdm (X display manager)
</example>
我甚至會用點撇步來停掉 daemon ，就是在 <prgn>init.d</prgn> script 的開頭加上 <tt>exit 0</tt> 。
These are <tt>conffiles</tt> after all.
</sect1>

<sect1 id="disables">停止 daemon 服務程式
<p>
&debian; distribution 非常注重系統安全，並期望系統管理員能擔此重任。它將系統的易用性放在了第二位，許多 daemon 伺服程式都定位在最高安全等級，因而在預設的安裝狀態下，系統只啟動最少的（甚至沒有）可用的服務程式。
<p>
如果你不確定你執行了什麼服務程式（像 Exim ， DHCP …）的話，執行 <tt>ps aux</tt> 或檢查一下 <file>/etc/init.d/*</file> 和 <file>/etc/inetd.conf</file> 的內容。同時也<![%f-ref;[使用 <ref id="loginctrl"> 的方法]]>確認一下 <file>/etc/hosts.deny</file> 。而 <prgn>pidof</prgn> 指令也是很有用的（請參閱 <manref name="pidof" section="8">）。
<p>
在最近的 &debian; 版本中，預設 X11 是不允許（遠端） TCP/IP 連接的。<![%f-ref;[請參閱 <ref id="xtcp"> 。]]>經由 SSH 來 X forwarding 也是禁止的。<![%f-ref;[請參閱 <ref id="xssh"> 。]]>
</sect1>
</sect>

</chapt>

