<!-- CVS revision of this document "$Revision: 1.6 $"  -->
<!-- CVS revision of original english document "1.48" -->


<chapt id="system">Debian 基礎

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
本章講述非開發人員需要掌握的 Debian 系統基礎知識。相關知識的權威參考，請參閱：
<p>
<list compact>
<item>Debian Policy Manual
<item>Debian Packaging Manual (Potato)
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
<p>
</list>
列表請參閱 <ref id="references">.

<p>
如果你想查閱簡要的 "how-to" 文件，可直接跳到 <ref id="package"> 或其它相關章節。
<p>
本章的內容取自 "Debian FAQ"，經過較大的改編，以適合於一般的 Debian 系統管理者上手。

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">Debian archives

<sect1 id="dirtree">目錄結構

<p>&debian; 套件可經由 FTP 或 HTTP 在 <url id="&mirror-site;" name="Debian mirror site"> 其中之一的目錄樹中取得。

<p>
下列目錄存在於任何 Debian 映射站台的 <file>debian/</file> 目錄下：
<taglist>
  <tag><file>dists/</file>:
    <item>本目錄包含 "distributions"，此處是獲得 Debian releases 和 pre-releases 的套件的正規途徑。有些舊套件及 <file>Packages.gz</file> 檔仍在其中。
  <tag><file>pool/</file>:
    <item>所有 Debian releases 及 pre-releases 的套件的新的實體位址。
  <tag><file>tools/</file>:
    <item>一些DOS下的小工具，用於建立開機磁片，分割硬碟，壓縮/解壓縮和啟動 Linux。
  <tag><file>doc/</file>:
    <item>Debian 的基本文件，如 FAQ、錯誤報告、系統使用說明等。
  <tag><file>indices/</file>:
    <item>維護人員文件和重載文件。
  <tag><file>project/</file>:
    <item>大部分為開發人員的資源，例如：
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>本目錄包含了處於開發中的套件和工具，它們均處於 alpha 測試階段。用戶不應使用這些軟件，因為即使是經驗豐富的用戶也會被搞得一團糟。
      <tag><file>project/orphaned/</file>:
        <item>已不再有人維護的套件，它們已從 distribution 中孤立出來。
    </taglist>
</taglist>

<sect1 id="dists">Debian distributions

<p>
通常在 <file>dists</file> 目錄下有三個 Debian distributions。它們是 <tt>stable</tt> distribution，<tt>testing</tt> distribution，和 <tt>unstable</tt> distribution。有時還有一個 <tt>frozen</tt> distribution。每個 distribution 均定義成一個符號鏈接指向 <file>dists</file> 目錄中相應的開發代號 (codename) 目錄。

<sect1 id="stable">The <tt>stable</tt> distribution

<p>
<tt>stable</tt> distribution 套件的入口，&stabledebian;，被登記到 <file>stable</file> (符號鏈接指向 <file>&stablecodenamedir;/</file> 目錄)：
<list>
  <item><file>stable/main/</file>：
  本目錄包含的套件均是最新 Debian 系統發布版的正式組成部分。

  <p>這些軟件包均遵循 <url name="Debian Free Software Guidelines (DFSG)" id="&social-contract;#guidelines"> (它位於 <file>&f-social-contract;</file> 需安裝 <package>&p-social-contract;</package>)，它們均可以自由使用和散布。

  <item><file>stable/non-free/</file>：本目錄包含的套件受到一定限制，發行者需注意並遵循特殊版權要求。

  <p>
  例如，有些套件的許可證條款 (licenses) 禁止其用於商業的 distribution。有些雖可以再散布，但本身是共享軟件而非自由軟件。以任何方式再發行這些套件時（例如使用光碟）必須認真閱讀有關的許可證條款及與所有者協商。

  <item><file>stable/contrib/</file>：本目錄包含的套件均遵循 DFSG-free 原則，本身也是<strong>自由散佈</strong>的，但這些套件卻相依於位於 non-free 目錄而<strong>不具有</strong>自由散佈屬性的套件。

</list>
現在，除了上述的目錄外，新上傳的套件的實體儲存位置為 <file>pool</file> 目錄 (<ref id="pools">)。

<p>現階段 <tt>stable</tt> 發行版錯誤報告位於 <url id="&stable-problems;" name="Stable Problems"> 頁面。


<sect1 id="testing">The <tt>testing</tt> distribution

<p><tt>testing</tt> distribution 的套件入口，&testingdebian;，在 <tt>unstable</tt> 中通過某種程度的測試後會登記到 <file>testing</file> (符號鏈接指向 <file>&testingcodenamedir;/</file>) 目錄。現在，除了上述目錄，新上載的套件的實體儲存位置為 <file>pool</file> 目錄 (<ref id="pools">)。在 <file>testing/</file> 下同樣有 <file>main</file> ， <file>contrib</file> ，和 <file>non-free</file> 子目錄，它們的作用與 <file>stable/</file> 中的一樣。

<p>
這些套件必須可以同時運行於所有架構，並且沒有相依性問題影響到其安裝。比起在 <tt>unstable</tt> 中的對應版本，它們必需有更少的 release-critical 錯誤。這個種方式，我們將 <tt>testing</tt> 視為更接近發布的候選版本。有關 testing 機制的更多資訊請參閱 <url id="&testing-notes;">。

<p>
<tt>testing</tt> distribution 的最新消息發佈在下列站台：
<list compact>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="other bugs and bug-squashing party notes">
</list>

<sect1 id="unstable">The <tt>unstable</tt> distribution

<p>
<tt>unstable</tt> distribution 的套件入口，總是被命名為 "Sid"，被登記到 <file>unstable</file> (符號鏈接指向 <file>sid/</file>) 目錄，上傳至 Debian archive 的套件在被移至 <file>testing/</file> 前就一直放在這兒。新上傳的套件的實體儲存位置為 <file>pool</file> 目錄 (<ref id="pools">)。在 <file>unstable/</file> 下同樣有 <file>main</file> ， <file>contrib</file> 和 <file>non-free</file> 子目錄， 它們的作用與 <file>stable/</file> 中相同。

<p>
<tt>unstable</tt> distribution 反映了系統最新的開發進展。歡迎廣大用戶使用並測試這些套件，同時也提醒你們這些套件還不完善。使用 <tt>unstable</tt> distribution 的好處就是你可以獲得 &debian; 軟體專案 &mdash; 的最新更新，不過新東西也會出新問題，你得好壞兼收 :-)

<p><tt>unstable</tt> distribution 的最新錯誤報告見於 <url id="&unstable-problems;" name="Unstable Problems"> 頁面。

<!-- Above was enough
<sect1 id="sid">The Sid distribution

<p>Sid or <tt>unstable</tt> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <tt>testing</tt>,
in order to be released in <tt>stable</tt> later on. Sid contains packages
for both released and unreleased architectures.

<p>The name "Sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">The <tt>frozen</tt> distribution

<p>當 <tt>testing</tt> distribution 足夠成熟了，它便成為 frozen，表示這個版本不再加入新程式，只進行除錯工作。如果需要的話， <file>dists</file> 目錄中會建立新的 testing 目錄樹，並給予新的開發代號。 frozen distribution 再經過幾個月的測試、更新、再凍結也稱之為“循環測試”。(最近的 Woody 發佈進程沒有建立 <file>frozen/</file> 的符號鏈接，所以 <tt>frozen</tt> 並不算 distribution，僅是 <tt>testing</tt> distribution 的一個開發階段。)

<p>
我們將 frozen distribution 中可能延遲套件或整個版本發佈的錯誤都記錄在案，一但錯誤總數低於可接受的最大值，frozen distribution 就晉升成 stable，而新版本發布了，前一個 stable distribution 成為過期版 (obsolete) （並被移至相對應的目錄）。

<sect1 id="codenames">Debian distribution 開發代號 (codenames)

<p>存在於 <file>dists</file> 目錄下的實體目錄名稱，例如 <file>&stablecodenamedir;/</file> 和 <file>&testingcodenamedir;/</file> ，就是 "開發代號 (codenames)"。當某個 &debian; distribution 處於開發階段，它並沒有版本號碼，取而代之的是開發代號。使用開發代號的目的在於簡化建立 &debian; distributions 映射站台的工作（如果真實目錄例如 <file>unstable</file> 突然改名為 <file>stable/</file> ，許多文件都沒必要再次下載）。

<p>現在，<tt>stable</tt> 是一個指向 <tt>&stablecodename;</tt> 的符號鏈接，<tt>testing</tt> 是指向 <tt>&testingcodename;</tt> 的符號鏈接。也就是說 <tt>&stablecodename;</tt> 是當前的 stable distribution， <tt>&testingcodename;</tt> 是當前的 testing distribution。

<p><file>unstable/</file> distribution 是指向 <file>sid/</file> 的永久符號鏈接，即 unstable distribution 總是稱為 Sid 。 <!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">已用過的開發代號

<p>已使用過的開發代號有：
"Buzz" 用在 release 1.1 ， 
"Rex" 用在 release 1.2 ， 
"Bo" 用在releases 1.3.x ， 
"Hamm" 用在 release 2.0 ， 
"Slink" 用在 release 2.1 ， 
"Potato" 用在 release 2.2 ， 
"Woody" 用在 release 3.0 和 
"Sarge" 用在 release 3.1.

<sect1 id="sourceforcodenames">開發代號的來源


<p>到目前為止它們均出自 Pixar 的電影 <em>玩具總動員 (Toy Story)</em> 。
<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) 是個太空人，
  <item><strong>Rex</strong> 是隻暴龍，
  <item><strong>Bo</strong> (Bo Peep) 是個放羊的女孩，
  <item><strong>Hamm</strong> 是個小豬撲滿，
  <item><strong>Slink</strong> (Slinky Dog) 是隻玩具狗，
  <item><strong>Potato</strong> 當然就是 Potato Head 先生，
  <item><strong>Woody</strong> 是個牛仔，
  <item><strong>Sarge</strong> 是綠色塑膠玩具士兵的首領，
  <item><strong>Etch</strong> (Etch-a-Sketch) 是blackboard，
  <item><strong>Sid</strong> 是隔壁的男孩，那個玩具終結者。
</list>
<!--
  more info in http://www.pixar.com/feature/toystory/toystory.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools"><file>pool</file> 目錄

<p>過去，套件均放在 <file>dists</file> 目錄下相應的 distribution 子目錄中。這種做法產生了許多問題，例如映射站台進行新版本發佈時大量頻寬被消耗。

<p>現在套件均依原本的套件名稱分類放進一個巨大的池子 "pool"。為了方便管理， pool 目錄下按屬性再分類 (<tt>main</tt> ， <tt>contrib</tt> ，和 <tt>non-free</tt>)，分類下面再按原本的套件名稱的英文字首字母歸檔。這些目錄包含的文件有：運行於各種系統架構的二進位套件，和生成這些二進制套件的源碼套件。

<p>你可以執行命令 <tt>apt-cache showsrc <var>mypackagename</var></tt> ，查看 "Directory:" 行獲知每個套件的存放位置。例如：<package>apache</package> 套件存放在 <file>pool/main/a/apache/</file> 。因為 <tt>lib*</tt> 的套件數量龐大，它們以特殊的方式歸檔：例如，<package>libpaper</package> 套件存放在 <file>pool/main/libp/libpaper/</file>。

<p>諸如 <prgn>apt</prgn> 等命令訪問的索引文件仍位於 <file>dists</file> 目錄中。而且，直到本文寫作之時，舊的 distributions 套件還沒轉到 pool 目錄，所以你將看到路徑中的 "Directory" 標頭欄中包含有 distribution 名稱如 <tt>potato</tt> 或 <tt>woody</tt>。

<p>通常，你大可不必注意這些事情，新版的 <prgn>apt</prgn> 和舊版 <prgn>dpkg-ftp</prgn> (參閱 <ref id="howtocurrent">) 會自動處理它們。想了解更多資訊，參閱 <url id="&pool-faq;" name="RFC: implementation of package pools">。

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history"> sid 的歷史記錄

<p>過去 Sid 並不存在， Debian archive 組織有一個主要的工作流程：它假設當前 <tt>unstable</tt> 中建立了某個軟體開發項目，它會在整個 distribution 形成一個新的 <file>stable/</file> 時發佈。但是因為很多軟體不是用這個方式在開發，所以一但軟體要發佈時，就必需把整個目錄都搬移到 stable 下。因為在搬移目錄時會用掉大量的頻寬，所以這個流程就顯得很不切實際。

<!-- 翻譯沒把握 -->
<p>經過幾年的研究摸索，archive 管理員提出一個方案，將未發佈的二進位檔放在一個名為 <tt>sid</tt> 的特定目錄。由於這些軟體尚未發佈，從那時起，它們就被加入到 <tt>unstable</tt> 目錄樹。當它們首次發布時，將會建立一個從當前 <tt>stable</tt> 指向 <tt>sid</tt> 的鏈接。這個方案的確會使使用者覺得困惑。

<p>有了套件 pool 的幫助（參閱 <ref id="pools">），在 <tt>woody</tt> distribution 開發過程中，二進位套件均按一定規範存放於 pool 目錄，而與 distribution 無關，當發佈新版本時，就不會再出現大量頻寬被消耗的問題。（不過，開發過程還是會用掉大量頻寬）。

<sect1 id="incoming">在 <file>incoming</file> 中的上傳套件
<p>
上載的套件在經確認它們是由 Debian 開發者上載的後，會先存放於 <url id="&incoming;"> （對於那些無維護者上載（Non-Maintainer Upload (NMU)）的套件則放入 <file>DELAYED</file> 子目錄）。會有一天，它們將從 <file>incoming/</file> 移入 <file>unstable/</file>。
<p>
在緊急情況下，你可能會等不及它們移入 <file>unstable/</file> 而直接從 <file>incoming.</file> 中下載安裝。
</sect1>

<sect1 id="snapshot">找回舊套件
<p>
最新的 Debian distribution 存放在任何一個 <url id="&mirror-site;" name="Debian mirror site"> 的 <file>debian</file> 目錄下。舊版本的 Debian 如 Slink 存放在 <url id="&archivehome;"> 或 Debian 映射站台的 <file>debian-archive</file> 目錄下。
<p>
舊的 <tt>testing</tt> 和 <tt>unstable</tt> 套件存放在 <url id="&snapshothome;">。
</sect1>

<sect1 id="archsections">Architecture sections
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>在每個主要目錄樹下（<file>dists/stable/main</file> 、 <file>dists/stable/contrib</file> 、 <file>dists/stable/non-free</file> 、 <file>dists/unstable/main/</file> 等）按晶片架構又分了子目錄，每個子目錄中存放著在該晶片架構下編譯的二進位套件。

<list>
  <item><file>binary-all/</file>，存放與架構無關的套件，如 Perl script、純文件等。
  <item><file>binary-<var>platform</var>/</file>，存放運行於該平台的二進制套件。
</list>

<p>請注意，<tt>testing</tt> 和 <tt>unstable</tt> 的二進位套件不再存放在這些目錄中，而是放在最上層 <tt>pool</tt> 目錄中。但為了向下相容，所以在目錄中仍保留有索引文件（<file>Packages</file> 和 <file>Packages.gz</file>）。

<p>要獲得實際上的二進制架構技術支持，請參閱各發行版的發佈記錄（Release Notes）。它們放發佈記錄站台 <url id="&stable-release;" name="stable"> 和 <url id="&testing-release;" name="testing">。

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->


<sect1 id="source">源碼

<p>Debian 系統中包含了所有東西的源碼，不僅如此，許可證條款規定系統中所有的程式<strong>必須</strong>和其源碼一起發行，或提供源碼。

<p>通常源碼發佈在 <file>source</file> 目錄，該目錄同時處於所有特定平台的目錄中，或是把更新的源碼放在 <file>pool</file> 目錄中（參閱 <ref id="pools">）。對於不太熟悉 Debian archive 目錄結構的用戶，想獲得源碼可以試試 <tt>apt-get source <var>mypackagename</var></tt> 命令。

<p>有些套件，如著名的 <package>pine</package>，由於許可證限制，只提供源碼套件。（最近，<package>pine-tracker</package> 套件提供了一個簡易的安裝方式。）參閱 <ref id="port"> 和 <ref id="packaging"> 教你如何手動編建一個套件。

<p><file>contrib</file> 和 <file>non-free</file> 目錄中的套件可能不提供源碼，因為它們不算正式 Debian 系統的一部分。


<sect id="pkg-basics">Debian 套件管理系統


<sect1 id="package-basics">Debian 套件概觀

<p>套件通常包含了實現一系列相關命令或特性的所有必需的檔案。Debian 套件有兩種類型：
<list>
  <item><strong>Binary packages</strong>（二進位套件），它包含可執行檔、設定檔、 man/info 頁面、版權聲明和其它文件。這些套件以 Debian 特定的格式散佈（參閱 <ref id="deb-format">）；它們通常使用 <tt>.deb</tt> 的延伸檔名來散佈。這種二進位套件可使用 Debian 工具 <tt>dpkg</tt> 解開，詳情見相關的 manual 頁面。

  <item><strong>Source packages</strong>（源碼套件），其中包含一個 <tt>.dsc</tt> 檔用於描述源碼套件（包括下列檔案的名稱），一個 <tt>.orig.tar.gz</tt> 格式的檔案包含了原本未經修改的源碼，以及一個 <tt>.diff.gz</tt> 文件包含了該套件為了符合 Debian 格式對源碼所做的修改。<tt>dpkg-source</tt> 工具可用於包裝和解開 Debian 源碼套件，詳情可參閱相關 manual 頁面。
</list>

<p>使用套件管理系統來安裝套件時會用到由套件維護者精心設計的"相依資訊"。這些相依資訊記錄在每個套件的 <tt>control</tt> 文件中。例如，包含 GNU C 編譯器 (<package/gcc/) 的套件"相依"於包含連結器 (linker) 和組譯器 (assembler) 的 <package/binutils/ 套件。如果用戶試圖在沒有安裝 <package/binutils/ 的情況下安裝 <package/gcc/，軟件包管理系統（dpkg）就會發一條錯誤信息，告訴你需要安裝 <package/binutils/，並停止安裝 <package/gcc/ 。（不過，倔強的用戶可以對這個信息視而不見，參閱 <manref name="dpkg" section="8"> )。）更多資訊請參閱下面的 <ref id="depends"> 。

<p>Debian 套件管理工具可用來：
<list>
  <item>操作和管理套件或套件的局部內容，
  <item>分割套件以助於那些使用有限容量的儲存工具如軟碟傳輸的用戶，
  <item>幫助開發者打包套件，
  <item>幫助用戶從遠端 Debian archive 站台安裝套件。
</list>


<sect1 id="deb-format">Debian <!--binary--> 套件格式

<p>Debian 的"套件"，或是 Debian 保存壓縮檔 (archive) 包含了和特定程式或一組相關的程式有關的可執行檔，函式庫，和文件。通常，Debian 保存壓縮檔是以 <tt>.deb</tt> 做為結尾。

<p>The internals of this Debian binary package format are described in the
<manref name="deb" section="5"> manual page. Because this internal format is
subject to change (between major releases of &debian;), always use
<manref name="dpkg-deb" section="8"> for manipulating <tt>.deb</tt>
files.

<!-- Below added by Osamu Not sure but should be right -->

<p>Through at least the Woody distribution, all Debian archive files
have been manipulable by the standard Unix commands <prgn>ar</prgn> and
<prgn>tar</prgn>, even when <prgn>dpkg</prgn> commands are not available.

<sect1 id="pkgname">Naming conventions for Debian package filenames
<!--
Why are Debian package filenames so long? 
-->
<p>The Debian <!--binary--> package filenames conform to the following convention:
<example>
<var>foo</var>_<var>VersionNumber</var>-<var>DebianRevisionNumber</var>.deb
</example>
where <var>foo</var> represents the package name. As a check,
one can determine the package name associated with a particular Debian archive
file (<tt>.deb</tt> file) in one of these ways:
<list>
  <item>inspect the "Packages" file in the directory where it was stored
  at a Debian <!--FTP--> archive site.  This file contains a stanza describing
  each package; the first field in each stanza is the formal package name.
  
  <item>use the command <tt>dpkg --info <var>foo_VVV-RRR</var>.deb</tt> (where
  <var>VVV</var> and <var>RRR</var> are the version and revision of the
  package in question, respectively).  This displays, among other things, the
  package name corresponding to the archive file being unpacked.
</list>

<p>The <var>VVV</var> component is the version number specified by the
upstream developer.  There are no standards governing version numbers, so they
may have formats as different as "19990513" and "1.3.8pre1".

<p>The <var>RRR</var> component is the Debian revision number, and is
specified by the Debian developer (or an individual user if he chooses
to build the package himself).  This number corresponds to the revision
level of the Debian package; thus, a new revision level usually signifies
changes in the Debian makefile (<file>debian/rules</file>), the Debian control
file (<file>debian/control</file>), the installation or removal scripts
(<file>debian/p*</file>), or the configuration files used with the package.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Preservation of the local configuration
<!--
What is a Debian conffile
-->
<p>Preservation of user-configurable files is enabled through &debian;'s
"conffiles" mechanism.  User configuration files (usually placed in
<file>/etc/</file>) are specified in the <file>conffiles</file> within the Debian
package system.  The package management system guarantees not to overwrite
these files when the package is upgraded.
<p>
When it is possible to configure the system without modifying files that belong
to various &debian; packages, it is usually a good idea not to modify them
even if they are "conffiles".  This ensures faster and smoother upgrade
operations.
<!--
<p>Conffiles is a list of configuration files (usually placed in <file>/etc</file>)
that the package management system will not overwrite when the package is
upgraded. This ensures that local values for the contents of these files
will be preserved, and is a critical feature enabling the in-place upgrade
of packages on a running system.
-->
<p>To determine exactly which files are preserved during an upgrade, run:
<example>
dpkg --status <var>package</var>
</example>
and look under "Conffiles:".

<p>
Specifics regarding the contents of a Debian <file>conffiles</file> file are
provided in the Debian Policy Manual, section 11.7 (see <ref id="references">).

<sect1 id="maintscripts">Debian maintenance scripts
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian maintenance scripts
are executable scripts which are automatically run before
or after a package is installed. Along with a file named <file>control</file>,
all of these files are part of the "control" section of a Debian archive file.

<p>The individual files are:
<taglist>
<tag/preinst/
  <item>This script executes before its package is unpacked from its
  Debian archive (<tt/.deb/) file. Many "preinst" scripts stop services for
  packages which are being upgraded until their installation or upgrade is
  completed (following the successful execution of the "postinst" script).

<tag/postinst/
  <item>This script typically completes any required configuration of a
  package once it has been unpacked from its Debian
  archive (<tt/.deb/) file. Often, "postinst" scripts ask the user for input,
  and/or warn the user that if he accepts default values, he should remember
  to go back and reconfigure the package as the situation warrants.
  Many "postinst" scripts then execute any commands necessary to start or
  restart a service once a new package has been installed or upgraded.

<tag/prerm/
  <item>This script typically stops any daemons which are associated with
  a package.  It is executed before the removal of files associated with
  the package.

<tag/postrm/
  <item>This script typically modifies links or other files associated with
  a package, and/or removes files created by it. (Also see
  <ref id="virtual">.)
</taglist>

<p>Currently all of the control files can be found in the directory
<file>/var/lib/dpkg/info</file>. The files relevant to package <tt>foo</tt>
begin with the name "foo" and have file extensions of "preinst", "postinst",
etc., as appropriate.  The file <file>foo.list</file> in that directory
lists all of the files that were installed with the package <tt>foo</tt>.
(Note that the location of these files is a <prgn>dpkg</prgn> internal, and may be
subject to change.)

<sect1 id="priority">Package priorities
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Each Debian package is assigned a <strong>priority</strong> by the distribution
maintainers, as an aid to the package management system.  The priorities are:

<list>
  <item><strong>Required</strong> packages are necessary for the proper
    functioning of the system.
    <p>This includes all tools that are necessary to repair system defects.
    You must not remove these packages or your system may become totally
    broken and you may not even be able to use <prgn>dpkg</prgn> to 
    restore things.  Systems with only the Required packages are probably
    inadequate for most purposes, but they do have enough functionality to
    allow the sysadmin to boot and install more software.
  <item><strong>Important</strong> packages should be found on any Unix-like
    system.
    <p>Other packages without which the system will not run well or be usable 
    will carry this priority. This does <strong>not</strong> include Emacs or
    X11 or TeX or any other large applications. These packages only constitute
    the bare infrastructure.
  <item><strong>Standard</strong> packages are standard on any Linux system,
    including a reasonably small but not too limited character-mode system.
    <p>This is what will install by default if users do not select anything
    else. "Standard" does not include many large applications, but it does
    include Emacs (this is more a piece of infrastructure than an application)
    and a reasonable subset of TeX and LaTeX (if this turns out to be possible
    without X).
  <item><strong>Optional</strong> packages include all those that you might
    reasonably want to install even if you are unfamiliar with them, and if
    you don't have specialized requirements.
    <p>This includes X11, a full TeX distribution, and lots of applications.
  <item><strong>Extra</strong> packages either conflict with others
    with higher priorities, have little use to users who are unfamiliar
    with them, or have specialized requirements that make them
    unsuitable for "Optional".
</list>

<sect1 id="virtual">Virtual packages

<p>A virtual package is a generic name that applies to any one of a group
of packages, all of which provide similar basic functionality. For example,
both the <prgn>tin</prgn> and <prgn>trn</prgn> programs are news readers, and either
one should therefore satisfy any dependency of a program that requires a news
reader on a system in order to work or to be useful. They are therefore both
said to provide the "virtual package" called <package>news-reader</package>.

<p>Similarly, <prgn>exim</prgn> and <prgn>sendmail</prgn> both provide the
functionality of a mail transport agent.  They are therefore said to
provide the virtual package <package>mail-transport-agent</package>.
If either one is installed, then any program depending on the
installation of a mail transport agent will be satisfied by
the existence of this virtual package.

<p>Debian has a mechanism so that, if more than one package which
provides the same virtual package is installed on a system, the system
administrator can set one as the preferred package. The relevant command
is <prgn>update-alternatives</prgn>, and is described further in
<ref id="alternatives">.

<sect1 id="depends">Package dependencies
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>The Debian package system has a range of package "dependencies"
which are designed to indicate (in a single flag) the level at which
Program A can operate independently of the existence of Program B on
a given system:
<list>
  <item>Package A <strong>depends</strong> on Package B if B absolutely must be
  installed in order to run A.  In some cases, A depends not only on B, but on
  a specific version of B.  In this case, the version dependency is usually a
  lower limit, in the sense that A depends on any version of B more recent
  than some specified version.
  <item>Package A <strong>recommends</strong> Package B if the package maintainer
    judges that most users would not want A without also having the
    functionality provided by B.
  <item>Package A <strong>suggests</strong> Package B if B contains files that
    are related to (and usually enhance) the functionality of A.
  <item>Package A <strong>conflicts</strong> with Package B when A will not
    operate if B is installed on the system.  Most often, conflicts are
    cases where A contains files which are an improvement over those in B.
    "Conflicts" status is often combined with "replaces".
  <item>Package A <strong>replaces</strong> Package B when files installed
    by B are removed and (in some cases) overwritten by files in A.
  <item>Package A <strong>provides</strong> Package B when all of the files and
    functionality of B are incorporated into A.  This mechanism provides
    a way for users with constrained disk space to get only that part of
    package A which they really need.
</list>

<p>More detailed information on the use of each these terms can be found
in the <em>Packaging Manual</em> and the <em>Policy Manual</em>.

<p>Note that <prgn>dselect</prgn> has more fine-grained 
control over packages specified by <strong>recommends</strong> and 
<strong>suggests</strong> than <prgn>apt-get</prgn>, which simply pulls all 
the packages specified by <strong>depends</strong> and leaves all
the packages specified by <strong>recommends</strong> and <strong>suggests</strong>.  Both programs in modern 
form use APT as their back end.

<sect1 id="pre-depends">The meaning of "pre-depends"

<p>"Pre-depends" is a special dependency. In the case of an ordinary package,
<prgn>dpkg</prgn> will unpack its archive file (i.e., its <tt>.deb</tt> file)
independently of whether or not the files on which it depends exist on the
system.  Unpacking basically means that <prgn>dpkg</prgn> will extract
the files from the archive file that were meant to be installed on your
filesystem, and put them in place.  If those packages <strong>depend</strong> on
the existence of some other packages on your system, <prgn>dpkg</prgn> will
refuse to complete the installation (by executing its "configure" action)
until the other packages are installed.

<p>However, there are some packages that <prgn>dpkg</prgn> will refuse even to
unpack until certain dependencies are resolved.  Such packages are said to
"pre-depend" on the presence of some other package(s).  The Debian project
provided this mechanism to support the safe upgrading of systems from
<tt>a.out</tt> format to ELF format, where the <strong>order</strong> in which
packages were unpacked was critical. There are other large upgrade situations
where this method is useful, e.g., for packages with "required" priority and
their libc dependency.

<p>Once again, more detailed information about this can be found in the
<em>Packaging Manual</em>.

<sect1 id="pkgstatus">Package status
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Package status can be "unknown", "install", "remove", "purge", or 
"hold".
These "want" flags indicate what the user wanted to do with a package (either
by making choices in the "Select" section of <prgn>dselect</prgn>, or by
directly invoking <prgn>dpkg</prgn>).

<p>Their meanings are:
<list compact>
  <item><strong>unknown</strong>  - the user has never indicated whether he
                wants the package.
  <item><strong>install</strong>  - the user wants the package installed or
                upgraded.
  <item><strong>remove</strong>   - the user wants the package removed, but
                does not want to remove any existing configuration files.
  <item><strong>purge</strong>    - the user wants the package to be
                removed completely, including its configuration files.
  <item><strong>hold</strong>     - the user wants this package not to be
                processed, i.e., he wants to keep the current version with the current
                status, whatever that is.
</list>

<sect1 id="puttingonhold">Holding back packages from an upgrade
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>There are two mechanisms for holding back packages from an upgrade, 
through <prgn>dpkg</prgn>, or, beginning with Woody, through APT.

<p>With <prgn>dpkg</prgn>, first export the list of package selections:
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
Then edit the resulting file <file><var>selections.txt</var></file>, changing the line
containing the package you wish to hold, e.g. <package/libc6/, from this:
<example>
libc6                       install
</example>
to this:
<example>
libc6                       hold
</example>
Save the file, and reload it into <prgn>dpkg</prgn> database with:
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
Or, if you know the package name to hold, simply run:
<example>
echo libc6 hold | dpkg --set-selections
</example>
This procedure holds packages at the install process of each package file.

<p>The same effect can be obtained through <prgn>dselect</prgn>. Simply enter
the [S]elect screen, find the package you wish to hold in its present state,
and press the `=' key (or `H'). The changes will take effect immediately after
you exit the [S]elect screen.

<p>The APT system in the Woody distribution has a new alternative mechanism
for holding packages during the archive retrieval process using
<tt>Pin-Priority</tt>.  See the manual page <manref name="apt_preferences"
section="5">, along with <url id="&apt-howto;"> or the
<package>&p-apt-howto;</package> package; <ref id="apt-preferences"> also
contains a brief explanation.

<sect1 id="sourcepkgs">Source packages

<p>
Source packages are distributed in a directory called <file>source</file>, and
you can either download them manually, or use
<example>
apt-get source <var>foo</var>
</example>
to fetch them (see the <manref name="apt-get" section="8"> manual page on how
to set up APT for doing that).


<sect1 id="sourcebuild">Building binary packages from a source package

<p>For a package <tt><var>foo</var></tt>, you will need all of <file><var>foo_*</var>.dsc</file>,
<file><var>foo_*</var>.tar.gz</file> and <file><var>foo_*.diff</var>.gz</file> to compile the source
(note: there is no <tt>.diff.gz</tt> for a Debian native package).

<p>Once you have them, if you have the <package/dpkg-dev/ package installed,
the command
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
will extract the package into a directory called 
<tt><var>foo-version</var></tt>.

<p>Issue the following command to build the binary package:
<example>
$ cd foo-version
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
Then,
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
to install the newly built package. See <ref id="port">.

<!-- Woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Creating new Debian packages

<p>For detailed information on creating new packages, read the <em>New
Maintainers' Guide</em>, available in the <package/maint-guide/ package, or at <url
id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Upgrading a Debian system

<p>One of Debian's goals is to provide a consistent upgrade path and a secure
upgrade process, and we always do our best to make a new release smoothly
upgradable from the previous ones.  Packages will alert the user when there
are important notices during the upgrade process, and will often provide a
solution to a possible problem.

<p>You should also read the Release Notes, the document that describes the
details of specific upgrades, shipped on all Debian CDs, and available on
the WWW at <url id="&stable-release;"> or <url id="&testing-release;">.

<p>
A practical guide to upgrades is provided in <ref id="package">.  This section 
describes the fundamental details.

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Methods for upgrading a Debian system

<p>One can always simply execute an anonymous FTP or <prgn>wget</prgn> call to
a Debian archive, peruse the directories until one finds a desired file, fetch
it, and finally install it using <prgn>dpkg</prgn>.  (Note that
<prgn>dpkg</prgn> will install upgrade files in place, even on a running
system.)  Sometimes, however, a revised package will require the installation
of a newly revised version of another package, in which case the installation
will fail until/unless the other package is installed.

<p>Many people find this manual approach much too time-consuming, since Debian
evolves so quickly&mdash;typically, a dozen or more new packages are
uploaded every week.  This number is larger just before a new major release.
To deal with this avalanche, many people prefer to use an automated program
for upgrading.  Several specialized package management tools are available for
this purpose.

<sect1 id="pkgtools">Package management tools overview

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>The Debian package management system has two objectives: the manipulation 
of the package file itself and the retrieval of package files from 
the Debian archive.  <prgn>dpkg</prgn> performs the former task, APT and
<prgn>dselect</prgn> the latter.

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>This is the main program for manipulating package files; read
<manref name="dpkg" section="8"> for a full description.
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> comes with several primitive supplemental programs.

<list>
<item><prgn>dpkg-deb</prgn>: Manipulate <tt>.deb</tt> files. 
 <manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>: An older package file retrieval command. 
 <manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>: An older package file retrieval command. 
 <manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>: Splits a large package into smaller files. 
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> and <prgn>dpkg-mountable</prgn> have been superseded
by the introduction of the APT system.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT (the Advanced Packaging Tool) is an advanced interface to the Debian
packaging system consisting of several programs whose names typically begin
with "apt-". 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn> and <prgn>apt-cdrom</prgn> 
are the command-line tools for handling packages.  These also function 
as the user's "back end" programs to other tools, such as <prgn/dselect/ 
and <prgn/aptitude/.

<p>For more information, install the <package/apt/ package and read
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (Woody), and
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>An alternative source of information is the
<url id="&apt-howto;" name="APT HOWTO">.
This can be installed by <package/apt-howto/ at
<file>&f-apt-howto;</file>.

<p><tt>apt-get upgrade</tt> and <tt>apt-get dist-upgrade</tt>
pull only the packages listed under "Depends:" and overlook all 
the packages listed under "Recommends:" and "Suggests:".
To avoid this, use <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>This program is a menu-driven user interface to the Debian package management
system. It is particularly useful for first-time installations and
large-scale upgrades.  See <ref id="dselect">.

<p>For more information, install the <package/install-doc/ package and read
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> or
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single-user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <prgn>start-stop-daemon</prgn> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Upgrading a running system

<p>The kernel (filesystem) in &debian; systems supports replacing files even
while they're being used.

<p>We also provide a program called <prgn/start-stop-daemon/ which is used
to start daemons at boot time or to stop daemons when the kernel runlevel is
changed (e.g., from multiuser to single-user or to "halt"). The same program
is used by installation scripts when a new package containing a daemon is
installed, to stop running daemons, and to restart them as necessary.

<p>Note that the Debian system does not require 
use of the single-user mode to upgrade a running system.

<sect1 id="savedebs">Downloaded and cached <tt>.deb</tt> archive files

<p>If you have manually downloaded package files to your disk (which is not
absolutely necessary, see above for the description of <prgn>dpkg-ftp</prgn>
or APT), then after you have installed the packages, you can remove the
<tt>.deb</tt> files from your system.

<p>If APT is used, these files are cached in the
<file>/var/cache/apt/archives</file> directory.  You may erase them after
installation (<tt>apt-get clean</tt>) or copy them to another machine's
<file>/var/cache/apt/archives</file> directory to save downloading during
subsequent installations.

<sect1 id="keepingalog">Record-keeping for upgrades

<p><prgn/dpkg/ keeps a record of the packages that have been unpacked,
configured, removed, and/or purged, but does not (currently) keep a log
of terminal activity that occurred while a package was being so manipulated.

<p>The simplest way to work around this is to run your
<prgn>dpkg</prgn>, <prgn>dselect</prgn>, <prgn>apt-get</prgn>, etc.,
sessions within the <manref name="script" section="1"> program.

<sect id="boot">The Debian boot process

<sect1 id="init">The <prgn>init</prgn> program

<p>Like all Unices, Debian boots up by executing the program <prgn>init</prgn>.
The configuration file for <prgn>init</prgn> (which is <file>/etc/inittab</file>)
specifies that the first script to be executed should be
<file>/etc/init.d/rcS</file>.  This script runs all of the scripts in
<file>/etc/rcS.d/</file> by sourcing or forking a subprocess depending on their
file extension to perform initialization such as checking and mounting file
systems, loading modules, starting the network services, setting the clock,
etc.  Then, for compatibility, it also runs
the files (except those with a `.' in the filename) in <file>/etc/rc.boot/</file>.
Any scripts in the latter directory are usually reserved for system
administrator use, and using them in packages is deprecated.  See <ref
id="init-hints"> for more info.

<sect1 id="runlevels">Runlevels

<p>After completing the boot process, <prgn>init</prgn> executes all start
scripts in a directory specified by the default runlevel (this runlevel
is given by the entry for <tt>id</tt> in <file>/etc/inittab</file>).
Like most <!-- all? SGK --> System V compatible Unices, Linux has 7 runlevels:
<list compact>
  <item>0 (halt the system),
  <item>1 (single-user mode),
  <item>2 through 5 (various multiuser modes), and
  <item>6 (reboot the system).
</list>
<p>
Debian systems come with <tt>id=2</tt>, which indicates that the default
runlevel will be 2 when the multiuser state is entered, and the
scripts in <file>/etc/rc2.d/</file> will be run.

<p>In fact, the scripts in any of the directories <file>/etc/rc<var>N</var>.d/</file>
are just symbolic links back to scripts in <file>/etc/init.d/</file>.  However,
the <strong>names</strong> of the files in each of the <file>/etc/rc<var>N</var>.d/</file>
directories are selected to indicate the <strong>way</strong> the scripts in
<file>/etc/init.d/</file> will be run.  Specifically, before entering any
runlevel, all the scripts beginning with `K' are run; these scripts kill
services.  Then all the scripts beginning with `S' are run; these scripts
start services.  The two-digit number following the `K' or `S' indicates
the order in which the script is run.  Lower-numbered scripts are executed
first.

<p>This approach works because the scripts in <file>/etc/init.d/</file> all
take an argument which can be either "start", "stop", "reload", "restart"
or "force-reload" and will then do the task indicated by the argument.
These scripts can be used even after a system has been booted, to control
various processes.

<p>For example, with the argument "reload" the command
<example>
# /etc/init.d/sendmail reload
</example>
sends the sendmail daemon a signal to reread its configuration file.

<sect1 id="custombootscripts">Customizing the boot process
<p>
Debian does not use a BSD-style
<tt>rc.local</tt> directory to customize the boot process; instead it provides
the following mechanism for customization.

<p>Suppose a system needs to execute script <tt>foo</tt> on startup,
or on entry to a particular (System V) runlevel.  Then the system
administrator should:
<enumlist>
  <item>Enter the script <tt>foo</tt> into the directory
    <file>/etc/init.d/</file>.
  <item>Run the Debian command <prgn>update-rc.d</prgn> with appropriate
    arguments, to set up links between the (command-line-specified)
    directories <tt>rc<var>?</var>.d</tt> and <file>/etc/init.d/foo</file>.
    Here, <var>?</var> is a number from 0 through 6 that corresponds to one of
    the System V runlevels.
  <item>Reboot the system.
</enumlist>

<p>The command <prgn>update-rc.d</prgn> will set up links between files in the
directories <tt>rc<var>?</var>.d</tt> and the script in
<file>/etc/init.d/</file>.  Each link will begin with an `S' or a `K',
followed by a number, followed by the name of the script.  When the system
enters a runlevel <var>N</var>, scripts beginning with `K' in
<file>/etc/rc<var>N</var>.d/</file> are executed with <tt>stop</tt> as
their argument, followed by those beginning with `S' in
<file>/etc/rc<var>N</var>.d/</file>  with <tt>start</tt> as their argument.

<p>One might, for example, cause the script <tt>foo</tt> to execute at
boot-up, by putting it in <file>/etc/init.d/</file> and installing the links
with <tt>update-rc.d foo defaults 19</tt>.  The argument <tt>defaults</tt>
refers to the default runlevels, which are 2 through 5.  The argument
<tt>19</tt> ensures that <tt>foo</tt> is called before any scripts containing
numbers 20 or larger.

<sect id="diverse">Supporting diversity
<p>
Debian offers several avenues to accommodate any wishes of the system 
administrator without breaking the system. 
<list>
<item><prgn>dpkg-divert</prgn>, see <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, see <ref id="equivs">.
<item><prgn>update-alternative</prgn>, see <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> can accommodate many boot loaders. 
      See <manref name="make-kpkg" section="1"> and <ref id="kernel-debian">.
</list>
Any files under <file>/usr/local/</file> belong to the system administrator 
and &debian; will not touch them. Most (or all) files under <file>/etc</file> are 
<tt>conffiles</tt> and &debian; will not overwrite them upon upgrade unless 
the system administrator requests so explicitly.

<sect id="i18n">Internationalization
<p>
The &debian; system is internationalized and provides support for character
display and entry in many languages, both within the console and under X. Many
documents, manual pages, and system messages have been translated into a
growing number of languages. During installation, Debian prompts the user to
choose an installation language (and sometimes a local language variant).
<p>
If your installed system does not support all the language features you need,
or if you need to change languages or install a different keyboard to support
your language, see <ref id="l10n">.

<sect id="kernel-details">Debian and the kernel
<p>
See <ref id="kernel">.

<sect1 id="non-debian-kernel">Compiling a kernel from non-Debian source

<p><!--Yes.  But you have-->
One has to understand the Debian policy with respect to headers.

<p>The Debian C libraries are built with the most recent <strong>stable</strong>
releases of the <strong>kernel</strong> headers.

<p>For example, the Debian-1.2 release used version 5.4.13 of the headers.
This practice contrasts with the Linux kernel source packages distributed
at all Linux FTP archive sites, which use even more recent versions of
the headers.  The kernel headers distributed with the kernel source are
located in <file>/usr/include/linux/include/</file>.

<p>If you need to compile a program with kernel headers that are newer
than those provided by <package/libc6-dev/, then you must add
<tt>-I/usr/src/linux/include/</tt> to your command line when compiling.
This came up at one point, for example, with the packaging of the
automounter daemon (<package/amd/).  When new kernels changed some
internals dealing with NFS, <prgn>amd</prgn> needed to know about them.
This required the inclusion of the latest kernel headers.

<sect1 id="customkernel">Tools to build custom kernels

<p>Users who wish to (or must) build a custom kernel are encouraged to
download the package <package/kernel-package/.  This package contains
the script to build the kernel package, and provides the capability to
create a Debian kernel-image package just by running the command
<example>
# make-kpkg kernel_image
</example>
in the top-level kernel source directory.
Help is available by executing the command
<example>
# make-kpkg --help
</example>
and through the manual page <manref name="make-kpkg" section="8">
and <ref id="kernel">.

<p>Users must separately download the source code for the most recent
kernel (or the kernel of their choice) from their favorite Linux archive
site, unless a kernel-source-<var>version</var> package is available 
(where <var>version</var> stands for the kernel version).  The Debian
<file>initrd</file> boot script requires a special kernel patch called
<prgn>initrd</prgn>; see <url id="&bug-initrd;">.

<p>Detailed instructions for using the <package/kernel-package/ package
are given in the file <file>/usr/share/doc/kernel-package/README.gz</file>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">Alternative boot loaders
<p>
To employ alternative boot loaders such as <package/grub/ or
<package/loadlin/, copy the compiled Linux kernel <file>bzimage</file> to
other locations (e.g., to <file>/boot/grub</file> or to an MS-DOS partition).
</sect1>

<sect1 id="custombootdisk">Custom boot floppies

<p>The task of making a custom boot floppy is greatly aided by the Debian
<!-- FIXME: boot-floppies is no package in Woody but an installation program
 Is this Potato specific? -->
package <package/boot-floppies/, normally found in the <tt>admin</tt> section
of the Debian FTP archive.  Shell scripts in this package produce boot
floppies in <prgn>syslinux</prgn> format.  These are MS-DOS formatted floppies
whose master boot records have been altered so that they directly boot Linux 
(or whatever other operating system has been defined in the
<file>syslinux.cfg</file> file on the floppy). Other scripts in this package
produce emergency root disks and can even reproduce the base disks.

<p>You will find more information about this in the
<file>/usr/doc/boot-floppies/README</file> file after installing the
<package/boot-floppies/ package.

<sect1 id="modules">Special provisions for dealing with modules

<p>Debian's <package/modconf/ package provides a shell script
(<file>/usr/sbin/modconf</file>) which can be used to customize the
configuration of modules.  This script presents a menu-based interface,
prompting the user for particulars on the loadable device drivers in his
system.  The responses are used to customize the file
<file>/etc/modules.conf</file> (which lists aliases, and other arguments that
must be used in conjunction with various modules) through files in
<file>/etc/modutils/</file>, and <file>/etc/modules</file> (which lists the
modules that must be loaded at boot time).

<p>Like the (new) <file>Configure.help</file> files that are now available to support
the construction of custom kernels, the <package/modconf/ package comes with a
series of help files (in <file>/usr/share/modconf/</file>) which provide
detailed information on appropriate arguments for each of the modules.
See <ref id="kernel-modules"> for examples.

<sect1 id="removeoldkernel">De-installing an old kernel package

<p>The <prgn>kernel-image-<var>NNN</var>.prerm</prgn> script checks to see whether
the kernel you are currently running is the same as the kernel you are trying
to de-install.  Therefore you can safely remove unwanted kernel image packages
using this command:

<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(Replace <var>NNN</var> with your kernel version and revision number, of
course.)
</sect>
