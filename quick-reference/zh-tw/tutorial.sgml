<!-- CVS revision of this document "$Revision: 1.12 $"  -->
<!-- CVS revision of original english document "1.94"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="tutorial">&debian;指南
<p>
<!-- new content -->
本章為那些初涉 &debian; 世界的新手指出了基本方向。如果你接觸 Unix-like 系統已有一段時間，就能了解我底下說明的部份。請將此文件當成實戰測試吧。

<sect id="first">準備開始
<p>
<!-- new content -->
從安裝 &debian; 到電腦之後，您需要學會一些技巧才能活用它。讓我們給您一些簡單的練習。

<sect1 id="login-root">用 root 登入 shell 提示符號
<p>
<!-- new content -->
在開機的過程中，您會看到圖形或文字介面的登入畫面(基於安裝的套件)。為了簡化說明，如果您看到的是圖形登入介面，請按下 Ctrl-Alt-F1
<footnote>
同時按下鍵盤左邊的 Ctrl, Alt 以及 F1。
</footnote>
切換到文字介面的登入模式。
<p>
假設您的主機名稱為  <tt><var>foo</var></tt>，那麼登入提示符號則類似：
<example>
<var>foo</var> login:
</example>
輸入 <tt>root</tt>，按下 Enter 後並輸入安裝過程設定的密碼。&debian; 系統跟 Unix 一樣，密碼是分辨大小寫的。接下來系統會出現一個問候訊息並留下 root 提示符號等您輸入指令。
<footnote>
如果您編輯 <file>/etc/motd</file>，則問候訊息就會不同。
</footnote>
<example>
<var>foo</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
透過 root 命令提示符號，您就準備進行系統管理了。root 帳號稱為超級使用者(superuser)或特權使用者(privileged user)。使用 root 帳號，您可以達成：
<list compact>
<item>讀、寫和移除任何系統上的檔案而不需考慮權限
<item>能夠設定系統上任何檔案的擁有者和權限
<item>設定任何系統非特權使用者的密碼
<item>登入到任何帳號而無需輸入密碼
</list>
<p>
分享 root 密碼來取得 root 帳號是非常不好的方法。請使用如 <manref name="sudo" section="8"> 的軟體就是一個較好的方式來分享管理者權限。
<p>
先登入非特權帳號再進行管理動作是值得學習的 Unix 習慣。等需要 root 權限時再使用 <tt>sudo</tt>，<tt>super</tt>或<tt>su -c</tt>來取得特定的功能。請參閱 <ref id="sudo">。
<footnote>
我必須說明我常常使用超級使用者帳號，只因為它是很容易且我比較不拘小節。
</footnote>

<sect1 id="newbiefix">針對新手設定的最精簡環境
<p>
<!-- new content -->
我認為學習電腦系統就像是學習一套外國語言。雖然學習指南很有幫助，但您需要去練習並使用這些工具。這個情況下，我建議額外安裝一些套件來輔助，例如 <package>mc</package>, <package>vim</package>, <package>lynx</package>, <package>doc-linux-text</package> 和 <package>debian-policy</package>。
<footnote>
安裝 <package>gpm</package>, <package>emacs21</package> 和 <package>doc-linux-html</package> 也是不錯的選擇喔，請參閱 <ref id="gpm"> and <ref id="edit">。
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
</example>
如果您已經安裝這些套件，則執行上述指令就不會重新安裝。

<sect1 id="newuser">增加帳號
<p>
<!-- new content -->
系統安裝完畢，通常會添加一個普通用戶帳號，而該帳號會收到寄給 root 的信件。
<footnote>
我傾向將此帳號命名為 <tt>admin</tt>，當然也可以是任何有權威性的名字。
</footnote>
如果您不想使用這個特殊帳號來練習以下的指令則必須建立一個新的使用者帳號。
<p>
如果新的帳號為 <tt><var>penguin</var></tt>，請輸入：
<example>
root@<var>foo</var>:root# adduser <var>penguin</var>
... 回答完所有的問題
</example>
就會建立該帳號了。  
<footnote>
您可以將 <tt><var>penguin</var></tt> 加入到 <tt>adm</tt> 群組中以便讀取 <file>/var/log/</file> 中的紀錄檔。請參閱 <manref name="passwd" section="5">, <manref
name="group" section="5">, <manref name="shadow" section="5">, <manref
name="group" section="5">, <manref name="vipw" section="8"> 和 <manref
name="vigr" section="8">。對於使用者帳號和群組的官方定義，請參考最近的 <url id="&f-users-and-groups;" name="Users and Groups">。
</footnote>
在進行下面的步驟前，我們先學習一些基礎。

<sect1 id="sw-console">切換虛擬主控台
<p>
<!-- modified old content -->
在未調整過的 &debian; 系統中，總共有六個獨立的虛擬終端機。也就是說您可以在文字介面的主控台中使用六個可切換的 VT-100 終端機。按下左邊的 Alt 加上 F1&ndash;F6 可以切換到另外一個終端機。每一個虛擬終端機允許不同的帳號登入且不受其他終端機影響。多人環境是 Unix 偉大的設計且容易讓人上癮。
<p>
<!-- new content -->
如果您不小心在執行 X 視窗系統的機器按下 Alt-F7，則主控台螢幕會切換到視窗介面，按下 Ctrl-Alt-F1 就能回到文字主控台。試著練習切換不同的主控台並跳回到原來這一個來習慣這些特性。

<sect1 id="shutdown">如何關機
<p>
<!-- heavily modified content -->
和其他現代的作業系統一樣，系統檔案會快取到記憶體中，在切斷電源之前 &debian; 系統需要完成特定的關機程序才能維持檔案的完整性。使用 root 提示命令列來執行以下的關機指令：
<example>
# shutdown -h now
</example>
這是多用戶模式下的關機命令。如果是單一使用者模式，請執行以下的命令：
<example>
# poweroff -i -f
</example>
您也能按下 Ctrl-Alt-Delete 來關機。
<footnote>
請在主控台同時按下 Ctrl,Alt(位在鍵盤的左邊) 以及 Delete 鍵。預設的情況是會重新開機。如同 <ref id="post-inst"> 說明的，編輯 <file>/etc/inittab</file> 檔案中的 <prgn>shutdown</prgn>並加入 <tt>-h</tt> 就能關機。
</footnote>
<p>
等待螢幕上顯示 "System halted" 之後切斷電源。如果在BIOS和Linux中開啟了 APM 或 ACPI ，系統會自動切斷電源。詳情參閱<ref id="apm">。

<sect1 id="playtime">把玩時間
<p>
<!-- new content -->
現在您可以大膽地使用 &debian; 系統而不用擔心任何危險，因為您使用的是非特權帳號：<tt><var>penguin</var></tt>。
<footnote>
&debian; 系統會這樣做的原因是因為在安裝系統後，良好的檔案權限可以防止非特權用戶破壞系統。當然，依然有許多存在的漏洞被發現，但這些問題應該是留給適合 <url id="&securing-debian-howto;" name="Securing Debian Manual"> 的使用者而非閱讀此章節的人。
</footnote>
<p>
我們來試著登入 <tt><var>penguin</var></tt>，如果您在 root 命令提示列，請按下 Ctrl-D
<footnote>
同時按下左Ctrl鍵和D。不需要按 Shift 即使是控制字元被標示成大寫的 "control D"。
</footnote>
結束 root 的動作回到登入提示符號。現在請輸入新建立的帳號 <tt><var>penguin</var></tt> 及密碼。
<footnote>
如果您將 <tt><var>penguin</var></tt> 換成 <tt>root</tt> 登入，就會取得 <tt>root</tt> 權限。如果您要重新取得 <tt>root</tt> 權限請執行這個動作。
</footnote>
您就會顯示以下的提示命令列。
<example>
<var>penguin</var>@<var>foo</var>:<var>penguin</var>$ 
</example>
<p>
從現在開始，底下的範皆使用簡化的命令提示列來說明。我將會使用
<list compact>
<item><tt>#</tt> : root 命令提示列
<item><tt>$</tt> : 非特權帳號的命令提示列
</list>
<p>
我們將以最簡單的方式 <ref id="mc"> 和適當的方法 <ref id="unixlike"> 來學習 &debian; 系統。

<sect id="mc">Midnight Commander (MC)
<p>
<!-- old content -->
Midnight Commander (MC)是 Linux 主控台和其它終端環境中的 GNU "瑞士軍刀"。對於新手來說，選單式的控制會比傳統 Unix 指令好上手多了。
<!-- New content -->
<p>
使用這個指令來流覽 &debian; 系統。這是最好的方式來學習。請使用方向鍵和 Enter 鍵來流覽主要的檔案系統。
<list compact>
<item><file>/etc</file> 以及子目錄。
<item><file>/var/log</file> 以及子目錄。
<item><file>/usr/share/doc</file> 以及子目錄。
<item><file>/sbin</file> 和 <file>/bin</file>
</list>

<sect1 id="mc-enhance">加強您的 MC
<p>
<!-- modified old content -->
為了使 MC 在離開時改變工作目錄，您需要修改 <file>~/.bashrc</file> (或 <file>/etc/bash.bashrc</file>, 由 <file>.bashrc</file> 呼叫)，使用 <tt>-P</tt> 選項，就像在說明頁面 <manref name="mc" section="1"> 中的敘述。 
<footnote>
如果您不清楚我說明的，可以先跳過。
</footnote>

<sect1 id="mc-start">啟動 MC
<p>
<!-- modified old content -->
<example>
$ mc
</example>
在 MC 中可使用選單來完成所有的檔案操作，只需要使用者小小的嚐試一下就行了。按下 F1 顯示說明視窗。您可以搭配方向鍵和功能鍵來使用 MC。
<footnote>
如果是在像 <prgn>kon</prgn> 和 <prgn>Kterm</prgn> for Japanese 等使用某些圖形特性的終端的話，則在命令列中加上 <tt>-a</tt> 可以預防 MC 出現一些問題。
</footnote>

<sect1 id="mc-fm">MC 的檔案管理功能
<p>
<!-- old content -->
預設狀態是兩個目錄面板列出檔案列表。另一種好用的模式是將右邊視窗設定為 "information" ，以查看檔案存取權限等資訊。下面是一些基本的按鍵。如果 <prgn>gpm</prgn> daemon 在運作的話，你還可以使用滑鼠。 (在 MC 中進行剪下和貼上操作時別忘了按下 shift 鍵。)
<list compact>
<item>F1: 說明選單
<item>F3: 內建的檔案檢視器
<item>F4: 內建的編輯器
<item>F9: 啟動下拉選單
<item>F10: 離開 Midnight Commander
<item>Tab: 在兩個視窗間移動
<item>Insert: 標記檔案以方便多檔案的操作，如複製
<item>Del: 刪除檔案 (小心&mdash;以 MC 設定為安全刪除模式。)
<item>方向鍵：就是方向鍵
</list>

<sect1 id="mc-cl">MC 的命令列技巧
<p>
<!-- old content -->
<list compact>
<item>任何 <prgn>cd</prgn> 命令會改變所選畫面的目錄。
<item>Ctrl-Enter 或 Alt-Enter 會將檔案名稱複製到命令列上。配合 <prgn>cp</prgn> 或 <prgn>mv</prgn> 命令使用來做命令列的編輯。
<item>Alt-Tab 會顯示出 shell 的檔名擴展以供選擇。
<item>可指定 MC 兩個目錄視窗的起始目錄；例如 <tt>mc /etc /root</tt> 。
<item>Esc + <var>數字鍵</var> == F<var>n</var> (也就是說，
      Esc + `1' = F1 等等。
      Esc + `0' = F10)
<item>Esc 鍵       == Alt 鍵 (= Meta ， M-) ；也就是說，輸入 Esc + `c' 就等於 Alt-c
<!-- control characters are referred with the upper case. -->
</list>

<sect1 id="mcedit">MC 的編輯器
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
內建編輯器的剪下－貼上方式很有意思。按 F3 標記起始點，再次按 F3 標記終止點，而中間的選取部分會高亮度顯示。然後你可以移動游標到某處按下 F6 ，被選取部分就會移到該處。如果你按下的是 F5 ，選中部分就會複製到該處。 F2 會儲存檔案， F10 是退出，所有方向鍵的作用則和它們的名字一樣直觀。
<p>
可用編輯器直接打開某個檔案：
<example>
$ mc -e filename_to_edit
$ mcedit filename_to_edit
</example>
<p>
雖然它不是多視窗編輯器，但你可利用多個 Linux 主控台來達成相同的效果。要在視窗間進行複製動作，可使用 Alt-F<var>n</var> 來切換虛擬主控台，然後使用 "File-&gt;Insert file" 或 "File-&gt;Copy to file" 將一個檔案中的內容複製到另一個檔案。
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I 參閱 .. but for now I do this not to hack LaTeX
-->
<p>
可指定任何外部編輯器來取代內建的編輯器。
<p>
許多程式使用環境變數 <tt>EDITOR</tt> 或 <tt>VISUAL</tt> 來決定使用哪個編輯器。如果你用不慣 <prgn>vim</prgn>，可在 <file>~/.bashrc</file> 中加上幾行來指定使用 <tt>mcedit</tt> ：
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
我推薦設定為 <tt>vim</tt> 。習慣 vi(m) 是件好事，因為在 Linux/Unix 世界裡你總找得到它們。
<footnote>
事實上，<prgn>vi</prgn> 或 <prgn>nvi</prgn> 是您在那都能取得的。我推薦新手使用 <prgn>vim</prgn> 是因為按下 F1 就能看到說明文件且類似於前者並提供更強大的功能。
<p>
如果您不熟悉 <prgn>vim</prgn> 或不喜歡用，那麼您可繼續使用 <prgn>mcedit</prgn> 來處理大部份系統維護的工作。自從 <prgn>mcedit</prgn>是以 8-bit 編碼且傻瓜(指不理會檔案編碼)，用它來修改未知編碼的檔案是比較方便的。<prgn>mcedit</prgn>無法正確顯示 UTF-8 的檔案。
</footnote>

<sect1 id="mc-view">MC 的檢視器
<p>
<!-- almost old content -->
非常聰明的檢視器。它是在文件中搜索詞句的利器。我總是用它在 <file>/usr/share/doc</file> 目錄下找檔案，用它來瀏覽大量的 Linux 資料是最快的方法。檢視器可以像這樣直接啟動：
<example>
$ mc -v filename_to_view
</example>

<sect1 id="ma-auto">MC 自動啟動特性
<p>
<!-- almost old content, tar.gz and deb are new -->
在檔案上按 Enter，會啟動相關的程式來處理該檔案。這是 MC 的一個極方便的特性。
<example>
executable:        執行命令
man, html file:    將檔案內容導向 (Pipe) 至檢視軟體
tar, gz, rpm file: 像子目錄般的瀏覽其內容
</example>
為了使這些文件特性生效，不要將可閱讀的檔案設成可執行檔。可使用 MC 的檔案選單或使用 <prgn>chmod</prgn> 來改變檔案屬性。

<sect1 id="mc-ftp">MC 的FTP虛擬檔案系統
<p>
<!-- old content -->
MC 可通過 FTP 來存取網路上的檔案。按 F9 轉到選單列，輸入 `p' 啟動 FTP 虛擬檔案系統。以 <tt>username:passwd@hostname.domainname</tt> 格式輸入 URL ，遠端的目錄就會像本地端目錄一樣顯示出來。
<p>
<!-- new content -->
試著流覽 <tt>&ftp-debian;</tt> 中的 &debian; 檔案。請參閱 <ref id="ftparchives"> 了解這些是如何組織起來的。

<sect id="unixlike">Unix-like 工作環境
<p>
<!-- new content -->
雖然 MC 能幫助你完成許多事情，但是學會如何從 shell 命令列執行指令並熟習 Unix-like 環境是非常重要的。
<footnote>
在本章節中，shell 指的是 <prgn>bash</prgn>。想要伸入了解各個 shell 的差異，請參閱 <ref id="shell">。
</footnote>

<sect1 id="sp-keys">特殊的組合鍵
<p>
<!-- practically new content -->
在 Unix-like 環境中，有許多組合鍵有特別的意義。
<footnote>
在正常的 Linux 文字主控台下，只有左邊的 Ctrl 和 Alt 是有用的。
</footnote>
<list compact>
<item>Ctrl-U: 清除一行中游標之前的文字。
<item>Ctrl-H: 移除游標前的一個字元。
<item>Ctrl-D: 結束輸入。(如果您在 shell 下，就會跳出該 shell)
<item>Ctrl-C: 終止正在執行的程式。
<item>Ctrl-Z: 暫時停止程式。 (將該工作放到背景，參閱 <ref id="cmd-back">)
<item>Ctrl-S: 停止輸出到畫面上。(類似 Scorll Lock)
<footnote>
您可以利用 <manref name="stty" section="1"> 來關閉這個終端機功能。
</footnote>
<item>Ctrl-Q: 回復輸出到畫面上。
</list>
<p>
預設的 shell 是 <prgn>bash</prgn> ，它能記住使用過的命令 (history-editing) 和命令列擴展 (tab-completion) 的功能來輔助互動式的使用。
<list compact>
<item>up-arrow:  開始收尋過去的命令。
<item>Ctrl-R:  開始漸進示收尋過去的命令。
<item>TAB: 擴展要輸入的檔案到命令列上。
<item>Ctrl-V TAB: 輸入 TAB，而不是命令列擴展
</list>
<p>
其他重要的組合鍵：
<list compact>
<item>Ctrl-Alt-Del:  重新啟動/關閉系統，參閱 <ref id="post-inst">。
<item>Left-click-and-drag mouse: 選取並拷貝至剪貼簿。
<item>Click middle mouse button: 將剪貼簿內容貼至游標處。
<item>Meta-key (只針對 Emacs) 是設定在左邊的 Alt。有些系統會使用 Windows-key 當 Meta-key。
</list>
為了在 Linux 文字主控台中使用滑鼠，您必須使用 <prgn>gpm</prgn> 服務。
<footnote>
在 X 系統環境下，滑鼠的功能跟 Xterm 軟體一樣。
In the X Window environment, the mouse functions in the same way with
the Xterm program.
</footnote>
參閱 <ref id="gpm">。

<sect1 id="unixcmds">基本的 Unix 指令
<p>
<!-- new content -->
我們來學一些基本的 Unix 指令吧。
<footnote>
我在這邊使用 "Unix" 當作通解。任何的 Unix 系列的作業系統通常有提供一樣的指令。&debian; 也不例外。別擔心，如果有些指令不能運作，這些範例將不會在這邊出現。
</footnote>
試著由非特權帳號<tt><var>penguin</var></tt>來執行下列的指令：
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>顯示目前的工作目錄。
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>顯示目前的使用者
 </list>
<item><tt>file <var>foo</var></tt>
 <list compact>
 <item>顯示<var>foo</var>檔案的型別。
 </list>
<item><tt>type -p <var>commandname</var></tt>
 <list compact>
 <item>顯示執行檔<tt><var>commandname</var></tt>的檔案路徑。
 <item><tt>which <var>commandname</var></tt> 也是相同功能。
 <footnote>
 如果在 shell 使用 <tt>alias</tt>，則輸出的結果就不相同。
 </footnote>
 </list>
<item><tt>type <var>commandname</var></tt>
 <list compact>
 <item>顯示執行檔 <tt><var>commandname</var></tt> 的資訊。
 </list>
<item><tt>apropos <var>key-word</var></tt>
 <list compact>
 <item>找出與 <tt><var>key-word</var></tt> 有關的說明文件。
 <item><tt>man -k <var>key-word</var></tt> 也具有相同功能。
 </list>
<item><tt>whatis <var>commandname</var></tt>
 <list compact>
 <item>顯示指令<tt><var>commandname</var></tt>的單行敘述。
 </list>
<item><tt>man -a <var>commandname</var></tt>
 <list compact>
 <item>顯示指令 <tt><var>commandname</var></tt>的說明 (Unix 風格)
 </list>
<item><tt>info <var>commandname</var></tt>
 <list compact>
 <item>顯示指令 <tt><var>commandname</var></tt> 較豐富的說明  (GNU 風格)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>列出目錄的內容。 (非點開頭的檔案和目錄)
  <footnote>
Unix 有個傳統是將檔案名稱以 "<tt>.</tt>" 開頭為隱藏檔。這些檔案通常是紀錄設定資訊和使用者偏好設定。
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>列出目錄的內容。 (所有的檔案和目錄)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>列出目錄的內容。 (幾乎所有的檔案和目錄，也就是略過 "<file>..</file>" 和 "<file>.</file>")
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>列出目錄下所有的檔案和細節資訊。參閱 <ref id="file-system">。
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>列出目前目錄下所有的目錄。
 </list>
<item><tt>lsof <var>foo</var></tt>
 <list compact>
 <item>列出以開檔的 <tt><var>foo</var></tt> 狀態。
 </list>
<item><tt>mkdir <var>foo</var></tt>
 <list compact>
 <item>在目前的目錄下產生新目錄: <tt><var>foo</var></tt>。
 </list>
<item><tt>rmdir <var>foo</var></tt>
 <list compact>
 <item>在目前的目錄下移除目錄: <tt><var>foo</var></tt>。
 </list>
<item><tt>cd <var>foo</var></tt>
 <list compact>
 <item>切換目錄到目前目錄下的 <file><var>foo</var></file> 或是<tt>CDPATH</tt>變數所定義的目錄下的目錄。參閱文件<manref name="builtins" section="7"> 中的 <prgn>cd</prgn>。
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>切換到根目錄。
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>切換到使用者的家目錄。
 </list>
<item><tt>cd /<var>foo</var></tt>
 <list compact>
 <item>切換到絕對路徑為<file>/<var>foo</var></file>的目錄。
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>切換到上一層目錄。
 </list>
<item><tt>cd ~<var>foo</var></tt>
 <list compact>
 <item>切換到家目錄中的 <tt><var>foo</var></tt> 目錄。
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>切換到先前的目錄。
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>使用預設的 pager 顯示 <file>/etc/motd</file> 的內容。參閱 <ref id="cmd-stdin">。
  <footnote>
全新精簡的 &debian; 系統預設的 pager 為 <prgn>more</prgn>，但不能上下捲動。執行 <tt>apt-get install less</tt> 來安裝 <package>less</package> 就會變成預設的 pager 且您可以使用方向鍵來捲動上下頁。
  </footnote>
 </list>
<item><tt>touch <var>junkfile</var></tt>
 <list compact>
 <item>建立一個空檔案：<file><var>junkfile</var></file>。
 </list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>複製一已存在的檔案：<file><var>foo</var></file> 並命名成：<file><var>bar</var></file>。
 </list>
<item><tt>rm <var>junkfile</var></tt>
 <list compact>
 <item>移除 <file><var>junkfile</var></file> 檔案。
 </list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>更名一已存在的 <file><var>foo</var></file> 檔案成 <file><var>bar</var></file> 檔名。
 </list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
 <list compact>
 <item>移動一已存在的 <file><var>foo</var></file> 檔案到新的位置且更名成 <file><var>bar/baz</var></file>。<file><var>bar</var></file> 目錄必須存在。
 </list>
<item><tt>chmod 600 <var>foo</var></tt>
 <list compact>
 <item>設定一已存在的檔案：<file><var>foo</var></file> 的權限為其他帳號皆不可讀和寫。(任何人皆不可執行)
 </list>
<item><tt>chmod 644 <var>foo</var></tt>
 <list compact>
 <item>設定一已存在的檔案：<file><var>foo</var></file> 的權限為其他帳號皆可讀但不可寫入。(任何人皆不可執行)
 </list>
<item><tt>chmod 755 <var>foo</var></tt>
 <list compact>
 <item>定一已存在的檔案：<file><var>foo</var></file> 的權限為其他帳號皆可讀但不可寫入。(任何人皆可執行)
 </list>
<item><tt>top</tt>
 <list compact>
 <item>全螢幕顯示程序的資料。輸入 "q" 終止。
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>使用 BSD 風格顯示全程序的資料。參閱 <ref id="cmd-pipe">。
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>使用 Unix system-V 風格顯示全程序的資料。
 </list>
<item><tt>ps aux | grep -e "[e]xim4*"</tt>
 <list compact>
 <item>顯示全部 <prgn>exim</prgn> 或 <prgn>exim4</prgn> 程序。執行 <tt>man grep</tt> 來閱讀 <manref name="grep" section="1"> 學習正規式表示法。
 <footnote>
正規式表示法中的 <tt>[</tt> 和 <tt>]</tt> 可使 <prgn>grep</prgn> 避免收尋到自己。至於表示法中的 <tt>4*</tt> 代表符合四個字元的次數大於零來使<prgn>grep</prgn>匹配<prgn>exim</prgn>和<prgn>exim4</prgn>。雖然 <tt>*</tt>皆可用在 shell filename wild card 和正規表示法，但兩者的意義是不同的。
 </footnote>
 </list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item>使用 ASCII art 輸出顯示全程序的資料。
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>砍掉 pid 為 <var>1234</var> 的程序。參閱 <ref id="kill">。
 </list>
<item><tt>grep -e "<var>pattern</var>" *.html</tt>
 <list compact>
 <item>收尋並顯示目錄下所有副檔名為 <tt>.html</tt> 的 "<var>原型</var>"。
 </list>
<item><tt>gzip <var>foo</var></tt>
 <list compact>
 <item>使用 Lempel-Ziv coding (LZ77) 壓縮 <file><var>foo</var></file> 成 <file><var>foo</var>.gz</file>。
 </list>
<item><tt>gunzip <var>foo</var>.gz</tt>
 <list compact>
 <item>解壓縮 <file><var>foo</var>.gz</file> 產生 <file><var>foo</var></file>。
 </list>
<item><tt>bzip2 <var>foo</var></tt>
 <list compact>
 <item>使用 Burrows-Wheeler block sorting text compression algorithm 和 Huffman coding (比 <prgn>gzip</prgn> 壓縮率更高) 來壓縮 <file><var>foo</var></file> 成 <file><var>foo</var>.bz2</file>
 </list>
<item><tt>bunzip2 <var>foo</var>.bz2</tt>
 <list compact>
 <item>解壓縮 <file><var>foo</var>.bz2</file> 產生 <file><var>foo</var></file>。
 </list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
 <list compact>
 <item>解開 <file><var>foo</var>.tar</file> 保存檔。
 </list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
 <list compact>
 <item>解開 gzip 壓縮檔：<file><var>foo</var>.tar.gz</file>。
 </list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
 <list compact>
 <item>解開 bzip2 壓縮檔：<file><var>foo</var>.tar.bz2</file>。
  <footnote>
在這裡用 <tt>--bzip2</tt> 來替代較短的 <tt>-j</tt> 來保證 Potato 中舊版的 <prgn>tar</prgn> 能正常工作。
  </footnote>
 </list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
 <list compact>
 <item>打包目錄 <file><var>bar</var>/</file> 成 <file><var>foo</var>.tar</file> 保存檔。
 </list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
 <list compact>
 <item>壓縮和打包目錄 <file><var>bar</var>/</file> 到 <file><var>foo</var>.tar.gz</file> 保存檔。
 </list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
 <list compact>
 <item>壓縮和打包目錄 <file><var>bar</var>/</file> 到 <file><var>foo</var>.tar.bz2</file> 保存檔。
  <footnote>
同樣地，<tt>--bzip2</tt>是確保相同性。
  </footnote>
 </list>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>使用預設的 pager 來顯示壓縮檔 <file>README.gz</file> 的內容。
 </list>
<item><tt>zcat README.gz &gt; foo</tt>
 <list compact>
 <item>建立 <file>foo</file> 檔案而內容為已解壓縮的 <file>README.gz</file>。
 </list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
 <list compact>
 <item>附加已解壓縮的 <file>README.gz</file>的內容到 <file>foo</file> 檔案。(如果該檔案不存在，請先建立。)
 </list>
<item><tt>find . -name <var>pattern</var></tt>
 <list compact>
 <item>使用 shell <tt><var>原型</var></tt> 收尋相符的檔名。(速度較慢)
 </list>
<item><tt>locate -d . <var>pattern</var></tt>
 <list compact>
 <item>使用 shell <tt><var>原型</var></tt> 收尋相符的檔名。(使用定期產生的資料庫，較快)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
請先使用上述的指令當作測試來探勘系統目錄。如果您有任何指令上的問題，請閱讀說明文件。比如說，這些指令是好的出發點：
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
現在使用 <prgn>vim</prgn> 的好機會，請按下 F1。您應該會看到至少前 35 行。然後實作線上測驗，將游標移至 <tt>|tutor|</tt> 並按下 Ctrl-]。參閱 <ref id="edit"> 了解更多編輯器。
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
請注意，許多從 GNU 和 BSD 來的 Unix-like 指令皆有簡潔的說明，您可以使用以下其一的方法叫出來(有些情況是不用加任何參數)：
<example>
$ <var>commandname</var> --help
$ <var>commandname</var> -h
</example>
<p>
也順便練習一下<ref id="tips">的範例來練功吧。

<sect1 id="cmd-exec">The command execution
<p>
<!-- new content -->
相信您現在比較清楚如何使用 &debian; 系統了。我們來探勘 &debian; 中更進階的指令技巧。
<footnote>
在這裡，我省略了一些東西，這對於新手比較好入手。詳細說明請參閱 See <manref name="bash" section="1">。
</footnote>

<sect1 id="cmd-simple">簡單的命令
<p>
<!-- new content -->
一個簡單的指令是以下的排列
<enumlist compact>
<item>變數宣告 (額外的)
<item>指令名稱
<item>參數 (額外的)
<item>導向 (額外的：<tt>&gt;</tt> , <tt>&gt;&gt;</tt> ,<tt>&lt;</tt> , <tt>&lt;&lt;</tt> ...等)
<item>控制運算子 (額外的：<tt>&amp;&amp;</tt> , <tt>||</tt> ;&lt;newline&gt; , <tt>;</tt> , <tt>&amp;</tt> , <tt>(</tt> , <tt>)</tt>)
</enumlist>
<p>
對於置換和引用，參閱 <ref id="clprocess">。

<sect1 id="cmd-env">指令執行和環境變數
<p>
<!-- new content -->
典型的指令執行是使用下述的 shell 指令列：
<footnote>
要完成下列的輸出，您必須安裝 French locale，參閱 <ref id="locales">。這並不是該指南的基本。這只是為了說明它另一個結果。
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
在這裡，<prgn>date</prgn>是前景工作。至於環境變數 <tt>LC_ALL</tt> 是指：
<list compact>
<item>第一個指令未設定 (系統預設是跟 <tt>C</tt> 一樣) <tt>LC_ALL</tt>
<item>第二個指令將 <tt>LC_ALL</tt> 設成 <tt>fr_FR</tt> (French locale)
</list>
大部份的指令在執行時不會比環境變數更早執行。對於上面的範例來說，你也可以這樣做：
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
當你看到這裡時，輸出的結果是受到環境變數的影響而產生 French 的文字。如果您想要環境變數也影響到子程序(舉例來說，當使用 shell script)，您必須 "export" 它：
<example>
$ export LC_ALL
</example>


<sect1 id="cmd-path">指令收尋路徑
<p>
<!-- new content -->
當您在 shell 輸入指令時，shell 會 <tt>PATH</tt> 這個環境變數中列舉的目錄來找指令。<tt>PATH</tt> 同時也是 shell 的收尋路徑。
<p>
在預設安裝的 &debian; 下，使用者的<tt>PATH</tt> 不會包含<file>/sbin/</file>。所以當您需要從 <file>/sbin/</file> 執行一些像 <prgn>ifconfig</prgn>的指令時，您必須修改 <tt>PATH</tt> 的值並包含該路徑。<tt>PATH</tt>通常是設定在 <file>~/.bash_profile</file> 之中，參閱 <ref id="bashconf">。

<sect1 id="cmd-opt">命令列參數
<p>
<!-- new content -->
部份的指令需要額外的參數才能執行，這些參數通常是以 <tt>-</tt> 或 <tt>--</tt> 開頭並透過指令來呼叫。
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
這裡的參數 <tt>-R</tt> 會改變 <prgn>date</prgn> 的輸出結果而變成 RFC-2822 相容的字串。

<sect1 id="cmd-wild">Shell wildcards
<p>
<!-- new content -->
有時候您希望能同時處理相同類別的檔案但不想一個一個輸入時，shell <strong>wildcards</strong>的 "檔名原型擴展" 就能解決這樣的問題。
<list compact>
<item><tt>*</tt>
<list compact>
<item>符合任何 0 個或更多個的字元。
<item>這不符合檔名以 "<tt>.</tt>" 開頭的檔案。
</list>
<item><tt>?</tt>
<list compact>
<item>只符合一個字元。
</list>
<item><tt>[...]</tt>
<list compact>
<item>只符合括號中的一個字元。
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>只符合<tt>a</tt> 和 <tt>z</tt> 中的一個字元。
</list>
<item><tt>[^...]</tt>
<list compact>
<item>符合括號中沒有列舉的一個字元("^"並不包含)。
</list>
</list>
<p>
舉例來說，思考一下底下的範例：
<example>
$ mkdir junk; cd junk; touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rm -rf junk
</example>

<sect1 id="cmd-return">指令的傳回值
<p>
每個指令會回傳 exit 狀態當成回傳值。
<list compact>
<item>如果指令成功執行完成的話，則回傳值 = 0。
<item>如果指令因錯誤終止，則回傳值不為 0。
</list>
執行後的回傳值可經由 <tt>$?</tt> 環境變數來存取。
<example>
$ [ 1 = 1 ] ; echo $?
0
$ [ 1 = 2 ] ; echo $?
1
</example>
請注意，shell 使用邏輯計算回傳值時，<strong>success</strong>的話就當成邏輯 <strong>TRUE</strong>。這並不是那麼直覺，因為<strong>success</strong>有代表 <strong>zero</strong> 的意思。
<p>
參閱 <ref id="shell-cond">。

<sect1 id="cmd-typical">標準的指令順序
<p>
<!-- new content in this whole sect1 and sect2s -->
我們試著記憶底下的 shell 指令用法。閱讀過這些用法後也請參考 <ref id="shell-param">, <ref id="shell-redirect">, <ref id="shell-cond"> 和 <ref id="clprocess">。

<sect2 id="cmd-back"><tt>command &amp;</tt>
<p>
該 <prgn>command</prgn> 指令是在 <strong>背景</strong>中的子 shell 執行。背景的工作允許使用者在一個 shell 中執行多個程式。
<p>
背景程序的管理包含了 shell 本身的 <prgn>jobs</prgn>, <prgn>fg</prgn>, <prgn>bg</prgn> 和 <prgn>kill</prgn>。請閱讀 <manref name="bash" section="1"> 中的 "SIGNALS",  "JOB CONTROL" 和 "SHELL BUILTIN COMMANDS"。
<footnote>
&debian; 系統是多工的系統。
</footnote>
 
<sect2 id="cmd-pipe"><tt>command1 | command2</tt>
<p>
<prgn>command1</prgn> 的 standard output 是餵給 <prgn>command2</prgn> 的stand input。兩個指令可以<strong>同時</strong>執行。這就叫作 <strong>pipeline</strong>。

<sect2 id="cmd-list"><tt>command1 ; command2</tt>
<p>
<prgn>command1</prgn> 和 <prgn>command2</prgn> 是按照順序地執行。
 
<sect2 id="cmd-and"><tt>command1 &amp;&amp; command2</tt>
<p>
<prgn>command1</prgn> 先被執行。如果成功的話，則<prgn>command2</prgn>也會<strong>依序</strong>的執行。<prgn>command1</prgn> <strong>和</strong><prgn>command2</prgn>皆成功執行，則傳回 success。
 
<sect2 id="cmd-or"><tt>command1 || command2</tt>
<p>
<prgn>command1</prgn> 先被執行。如果不成功的話，則<prgn>command2</prgn>還是會<strong>依序</strong>的執行。<prgn>command1</prgn> <strong>或</strong><prgn>command2</prgn>其一成功執行的話，則傳回 success。

<sect2 id="cmd-stdout"><tt>command &gt; <var>foo</var></tt>
<p>
將<prgn>command</prgn>的結果重導到<tt><var>foo</var></tt>檔案。(會覆寫)

<sect2 id="cmd-stdout2"><tt>command &gt;&gt; <var>foo</var></tt>
<p>
將<prgn>command</prgn>的結果重導到<tt><var>foo</var></tt>檔案。(會附加)

<sect2 id="cmd-stderr"><tt>command &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
將<prgn>command</prgn>的 standard output 和 standard error 重導到<tt><var>foo</var></tt>檔案。

<sect2 id="cmd-stdin"><tt>command &lt; <var>foo</var></tt>
<p>
將<prgn>command</prgn>的 standard input 導到<tt><var>foo</var></tt>檔案。試試看以下的例子：
<example>
$ &lt;/etc/motd pager
 ... (the greetings)
$ pager &lt;/etc/motd
 ... (the greetings)
$ pager /etc/motd
 ... (the greetings)
$ cat /etc/motd | pager
 ... (the greetings)
</example>
雖然四個用法皆顯示同樣的結果，但最後的例子會再跑一次 <prgn>cat</prgn> 指令，這會多浪費一些資源。

<sect1 id="cmd-alias">指令別名
<p>
<!-- new content -->
您可以為常用的指令設定別名。例如：
<example>
$ alias la='ls -la'
</example>
現在，<prgn>la</prgn> 會以長清單格式來列出所有的檔案，也就是 <tt>ls -la</tt> 的縮寫。
<p>
您可以使用 <prgn>type</prgn> 指令來辨識真正的路徑。例如：
<example>
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
</example>
這裡的 <prgn>ls</prgn> 是最近被查詢到的，然而 <prgn>file</prgn> 並沒有，因此 <prgn>ls</prgn> 是 "hashed"，也就是說 shell 有一個紀錄可以快速找到 <prgn>ls</prgn> 的位置。

<sect id="text-process">Unix-like 文字處理
<p>
在 Unix-like 系統上有一些常用的標準文字處理工具。
<list compact>
<item>不支援正規表示法的：
<list compact>
<item><prgn>head</prgn> 輸出檔案的第一行。
<item><prgn>tail</prgn> 輸出檔案的最後一行。
<item><prgn>sort</prgn> 排序文字檔行列。
<item><prgn>uniq</prgn> 刪除已排序的檔案中重複的資料。
<item><prgn>tr</prgn> 轉譯或刪除文字。
<item><prgn>diff</prgn> 行與行的檔案比較。
</list>
<item>支援基本的正規表示法 (BRE)：
<list compact>
<item><prgn>grep</prgn> 依照收尋原型來收尋文字。
<item><prgn>ed</prgn> 是個最原始基本的編輯器。
<item><prgn>sed</prgn> 是串流資料編輯器。
<item><prgn>vi</prgn> 是全螢幕編輯器。
<item><prgn>emacs</prgn> 是全螢幕編輯器。
</list>
<item>支援擴充的正規表示法(ERE)：
<list compact>
<item><prgn>egrep</prgn> 依照收尋原型來收尋文字。
<item><prgn>awk</prgn> 支援簡單的文字處理。參閱 <ref id="awk">。
<item><prgn>perl</prgn> 幾乎所有的文字處理皆能達成。參閱 <ref id="perl">。
</list>
</list>
參閱 <ref id="perl-i">, <ref id="scrp-snip"> 和 <ref id="perl-mad"> 取得更多 script 範例。


<sect1 id="regex">正規表示法
<p>
正規表示法是用在許多文字處理的工具上。有點類似 shell wildcards (參閱 <ref id="cmd-wild">)，但卻更複雜與強大。
<p>
正規表示法可用文字或<strong>metacharacters</strong>來描述比對原型。metacharacter 是具有特殊意義的字元。有兩種主要的類別：BRE 和 ERE，端看您使用的文字工具(<ref id="text-process">)決定。
<p>
對 EREs 來說，<strong>metacharacters</strong> 包含 "<tt> \ . [ ] ^ &dollar; * + ? ( ) { } | </tt>"。這個表示法意思是：
<list compact>
<item><tt>c</tt>
<list compact>
<item>符合非 metacharacter "<tt>c</tt>"。
</list>
<item><tt>\c</tt>
<list compact>
<item>符合字母 "<tt>c</tt>"。
</list>
<item><tt>.</tt>
<list compact>
<item>符合包含換行的任何字元。
</list>
<item><tt>^</tt>
<list compact>
<item>符合字串的第一個字元。
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>符合字串的最後一個字元。
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>符合文字的開頭。
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>符合文字的結尾。
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>這個字元列表符合 "<tt>abc...</tt>" 中任何一個字元。
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>這個字元列表符合非 "<tt>abc...</tt>" 中任何一個字元。
</list>
<item><tt>r*</tt>
<list compact>
<item>符合 "<tt>r</tt>" 這個敘述 0 次以上的文字。
</list>
<item><tt>r+</tt>
<list compact>
<item>符合 "<tt>r</tt>" 這個敘述 1 次以上的文字。
</list>
<item><tt>r?</tt>
<list compact>
<item>符合 "<tt>r</tt>" 這個敘述 0 或 1 次的文字。
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>符合"<tt>r1</tt>" 或 "<tt>r2</tt>" 敘述之一的文字。
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>符合"<tt>r1</tt>" 或 "<tt>r2</tt>" 敘述之一的文字並以 <strong>bracketed</strong> 表示法處理。
</list>
</list>
<p>
在 BREs 裡，<strong>metacharacters</strong>："<tt> + ? ( ) { } | </tt>" 是無作用的，取而代之的是倒斜線的 "<tt>\+ \? \( \) \{ \} \| </tt>"。所以說，使用 BREs 時，<tt>(r1|r2)</tt> 必須像 <tt>\(r1|r2\)</tt> 用倒斜線隔開。雖然 <prgn>emacs</prgn> 也支援 BRE，但改用 "<tt> + ? </tt>" 來當作<strong>metacharacters</strong>。所以不需要使用雙引號來隔開。參閱 <ref id="replaceex"> 了解這些<strong>metacharacters</strong>組合怎麼使用。
<p>
舉例來說，<prgn>grep</prgn> 可以使用正規表示法來收尋文字：
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">置換表示法
<p>
在置換表示法中，底下的字元有特別的意義：
<list>
<item><tt>&amp;</tt> 
<list compact>
<item>顯示符合正規表示法的字串。(<prgn>emacs</prgn>下請用 <tt>\&amp;</tt>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>顯示第 n 個符合正規表示法的字串。  
</list>
</list>
如要使用 Perl 置換字串，請改用 <tt>&dollar;<var>n</var></tt> 代替<tt>\<var>n</var></tt>和<tt>&amp;</tt>。因為後兩各在 Perl 中是無意義的。
<p>
舉例說明：
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
請特別注意各處理工具在置換時所使用的<strong>分隔</strong>符號，以及軟體如何用正規表示法比對這些文字的方式。
<p>
在編輯器中使用這些表示法也可以用來移動游標和置換文字。
<p>
請閱讀以上這些指令相關的說明文件。

<sect id="unixfile">Unix-like 檔案系統
<p>
<!-- 
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
在 GNU/Linux 和其他 Unix-like 的系統上，<strong>檔案</strong>是有組織地放置在<strong>目錄</strong>下。
<footnote>
在某些系統上，<strong>目錄</strong>(diretory) 也被稱為 <strong>資料夾</strong>(folder)。 
</footnote>
全部的<strong>檔案</strong>和<strong>目錄</strong>被整理放在一個階乘和樹狀的<file>根目錄</file>(/)。
<p>
這些檔案和目錄可以放在不同的硬體裝置上。<manref name="mount" section="8"> 指令能掛載硬體裝置並加入到這巨大的檔案樹系統上。反過來說，<manref name="umount" section="8">則可以卸載這些裝置。

<sect1 id="file-basics">Unix 檔案基礎
<p>
<!-- new content -->
以下是一些基礎觀念：
<list compact>
<item> 檔案是大小寫相異。也就是說 <file>MYFILE</file> 和 <file>MyFile</file>是<strong>不同</strong>的檔案
<item>根目錄以 <file>/</file> 表示。可別把 "root" 跟 root 帳號搞混了喔。參閱 <ref id="login-root">。
<item>每個目錄皆可用字母或符號來命名，但就是不能用 <file>/</file>。
<footnote>
您<strong>可以</strong>用任意的字母或符號來命名檔案，但實際上這不是好的命名方式。最好能避免使用一些特殊意義的字元，比如 spaces, tabs, newlines 和其他特殊意義的字元：<tt>{ } ( ) [ ] ' ` &quot; \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt>。
<p>
如果您想要分隔檔名中的字串，逗號(,)，連字符號(-)和底線(_)是比較推薦的。您也可以用大寫，像是這樣：<tt>LikeThis</tt>。
</footnote>
根目錄是一個例外，它的檔名：<file>/</file>(叫做 "斜線" 或 "根目錄")且不能更名。
<item>每個檔案或目錄皆設計成 <strong>fully-qualified filename</strong>, <strong>absolute filename</strong>或<strong>path</strong>，必須有順序地輸入路徑才能切換到最後的目錄。以上三者是同等的意思。全部的絕對路徑以 <file>/</file> 開頭且每個檔案或目錄的路徑都包含 <file>/</file> 符號。第一個 <file>/</file>是目錄的名稱，其餘的皆為分隔符號以便區分檔名的每個部份。
<p>
以上的說明容易造成混淆。請看一下底下的範例：
<example>
/usr/share/keytables/us.map.gz
</example>
這是一個完整的檔案名稱，有些人也稱作 <strong>path</strong>。但大部分都只用 <file>us.map.gz</file> 來當作檔名。
<footnote> 
關於 <strong>path</strong> 也有不同的用法。參閱 <ref id="cmd-path">。透過上述的解釋應該就可了解。
</footnote>

<item>root 目錄有幾個分支，例如 <file>/etc/</file> and <file>/usr/</file>。這些子目錄底下有更多的子目錄，例如 <file>/etc/init.d/</file> 和 <file>/usr/local/</file>。總括來說，這就叫做 <strong>目錄樹</strong>(directory tree)。
<p>
您可以想像一個絕對路徑是從該樹的根(<file>/</file>)延伸到最後的分支(檔案)。您也曾聽過別人稱為<strong>家族</strong>樹，所以每個子目錄都有其<strong>父母或祖先</strong>，而路徑就是檔案完整的起源。
<p>
至於相對路徑並不是以 root(/) 目錄開頭。您必須牢記 <file>../</file> 代表上一層的目錄。

<item>至於硬體裝置是沒有任何目錄對應的。這跟 CP/M, DOS, 和 Windows 中的所有檔案是以硬體裝置(例如，<tt>C:\</tt>)開頭的檔名不同。請參閱<ref id="file-system">。
</list>

<p>
有興趣的話可以參閱<url id="&f-fhs;" name="Filesystem Hierarchy Standard">，該文件詳細說明了階層式檔案系統的細節。您要記住的是底下這些目錄的用途：
<list compact>
<item><file>/</file>
<list compact>
<item><file>/</file> 代表 root 目錄。
<p>
</list>
<item><file>/etc/</file>
<list compact>
<item>所有的系統設定檔案皆放在該目錄下。
</list>
<item><file>/var/log/</file>
<list compact>
<item>所有的系統日誌檔皆放在該目錄下。
</list>
<item><file>/home/</file>
<list compact>
<item>該目錄包含了非特權帳號的所有家目錄。
</list>
</list>

<sect1 id="file-system">&debian; 的檔案系統
<p>
<!-- old content modified with fs.h reference -->
同於 Unix，&debian; 系統提供了一個檔案系統，能夠統一化所有硬碟，儲存媒體，主控台或透過串列埠遠端存取硬體的動作。
<p>
&debian; 系統中每個檔案，目錄，named pipe 或硬體裝置都有一個<strong>inode</strong> 的資料結構，記載該檔案的相關屬性，例如:使用者所擁有 (擁有者)，屬於那一個群組，最後存取的時間等。參閱 <url id="&f-inode-def;"> 了解 &debian; GNU/Linux 系統中的 <tt>inode</tt>結構的意義。
<p>
將硬體統一化成檔案的表示法是非常有用的，這允許我們可以使用相同的方法來存取完全不同的硬體。
<p>
全部的檔案可以存放在一個硬碟，或者 20 個硬碟，有些硬碟甚至是分散在網路上不同的電腦。您無法想像在查詢檔案或目錄時，所有的指令都能正常運作且不用理會真正的檔案是放在哪一個實體裝置上。

<sect1 id="file-perm">檔案和目錄的存取權限
<p>
<!-- old content -->
檔案和目錄的存取權限對下面三種使用者分別定義：
<list compact>
<item>檔案擁有者 <strong>user</strong> (u) ，
<item>檔案所屬群組的使用者 <strong>group</strong> (g) 和
<item>所有使用者 <strong>other</strong> (o) 。
</list>
<p>
對檔案來說，每個權限分別對應到一些可做的動作：
<list compact>
<item>讀取<strong>read</strong> (r)：查看檔案的內容
<item>寫入<strong>write</strong> (w)：對檔案作修改
<item>執行<strong>execute</strong> (x)：把檔案當作指令來執行
</list>
<p>
對目錄來說，每個權限分別對應到一些可做的動作：
<list compact>
<item>讀取<strong>read</strong> (r)：列出目錄的內容
<item>寫入<strong>write</strong> (w)：在目錄中加入或刪除檔案
<item>執行<strong>execute</strong> (x)：存取目錄中的檔案
</list>
在這裡， 目錄的<strong>執行</strong>權限不只代表允許讀取目錄內的檔案，也代表允許看到它們的屬性，像是檔案大小和更動時間等。
<p>
使用 <prgn>ls</prgn> 來顯示檔案和目錄的權限資訊 (和更多其他的資訊). 請參閱 <manref name="ls" section="1"> 。當使用 <prgn>ls</prgn> 的 <tt>-l</tt> 選項，則會依下列順序來顯示相關資訊：
<list compact>
<item><strong>檔案型態</strong> (第一字元)
 <list compact>
 <item><tt>-</tt>: 一般檔案
 <item><tt>d</tt>: 目錄
 <item><tt>l</tt>: 符號連結
 <item><tt>c</tt>: 字元狀置節點
 <item><tt>b</tt>: 區塊狀置節點
 <item><tt>p</tt>: 命名的管線
 <item><tt>s</tt>: 通訊端
 </list>
<item>檔案的存取<strong>權限</strong> (之後九個字元，依序是擁有者，群組，其他，各三個字元)
<item>檔案的<strong>硬連結個數</strong>
<item>檔案<strong>擁有者</strong>名稱
<item>檔案所屬<strong>群組</strong>名稱
<item>檔案<strong>大小</strong> (以 bytes 為單位)
<item>檔案的<strong>目期和時間</strong> (mtime)
<item>檔案的<strong>名稱</strong>。
</list>
<p>
在 root 帳號下可使用 <prgn>chown</prgn> 改變檔案的擁有者。要改變檔案的所屬群組，可以用檔案擁有者或 root 的身份來執行 <prgn>chgrp</prgn>。要改變目錄的存取權限，可以用檔案擁有者或 root 的身份來執行 <prgn>chmod</prgn>。控制<file>foo</file>檔案的語法是：
<example>
# chown <var>newowner</var> foo
# chgrp <var>newgroup</var> foo 
# chmod  [ugoa][+-=][rwx][,...] foo 
</example>
請參閱 <manref name="chown" section="1">, <manref name="chgrp" section="1"> 和 <manref name="chmod" section="1"> 以取得更多資訊。

<p>
舉例來說，如果要改變目錄的擁有者為 <var>foo</var> 以及群組為 <var>bar</var>，請用 root 帳號執行以下指令：
<example>
# cd /some/location/
# chown -R <var>foo</var>:<var>bar</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
有 3 個更特殊的權限位元：
<list compact>
<item><strong>set user ID</strong> (s 或 S 取代擁有者的 x)，
<item><strong>set group ID</strong> (s 或 S 取代群組的 x) 和
<item><strong>sticky bit</strong> (t 或 T 取代其他使用者的 x) 。
</list>
在這裡，如果設定這些特殊權限設定後蓋住了原本顯示的執行權限的話，則 <prgn>ls -l</prgn> 的輸出就會用大寫來表示。
<p>
在可執行檔上設定 <strong>set user ID</strong> 的話，會以這個檔案擁有者的身份 (如 <strong>root</strong>) 來執行這個可執行檔。同樣地，在可執行檔上設定 <strong>set group ID</strong> 的話，會以這個檔案的群組身份 (如 <strong>root</strong>) 來執行這個可執行檔。因為這些設定會導致安全性上的問題，要打開它們的話要格外小心。
<p>
在目錄上設定 <strong>set group ID</strong> 的話，會使用類似 BSD 的檔案建立規則，也就是在此目錄中建立的檔案都會屬於此目錄的<strong>群組</strong>。
<p>
在目錄上設定e <strong>sticky bit</strong> 可以防止非檔案擁有者來刪除此目錄中的檔案。在一些大家可以寫入的目錄，如 <file>/tmp</file> 或是在允許群組寫入的目錄下，為了要保持檔案內容的安全，不只要關上檔案的<strong>寫入</strong>權限，還要在目錄上設定 <strong>sticky bit</strong> 。不然的話，任何擁有目錄寫入權限的人都可以刪除檔案，並且建立一個新的同名檔案。
<p>
這裡有些關於檔案權限的有趣例子。
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
另外的辦法是使用數字並搭配 <manref name="chmod" section="1"> 來設定檔案權限。數字模式使用 3 到 4 數字寬的八進制數字。每個數字皆有其代表意義：
<list compact>
<item>第一個選擇性數字：<strong>set user ID</strong> (=4), <strong>set group ID</strong> (=2) 和 <strong>sticky bit</strong> (=1) 的總合。
<item>第二個數字：針對 <strong>user</strong> 的 <strong>read</strong> (=4), <strong>write</strong> (=2) 和 <strong>execute</strong> (=1) 權限的總合。
<item>第三個數字：同上，但針對於 <strong>group</strong>。
<item>第四個數字：同上，但針對 <strong>other</strong>。
</list>
<p>
這聽起來很複雜，但其實是相當簡單的。如果您觀察<tt>ls -l</tt>的結果就能發現前面幾行(2-10)是代表檔案權限(請用二進制，"-"表示 "0"，"rwx"表示"1")。這些數字如果用八進制來代表檔案權限的話，相信您一定能夠了解。
<footnote>
當然，這各方法只適用於 3 個數字寬的表示法。
</footnote>
舉個例子，比如：
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
預設的檔案權限遮罩可使用 shell 內建的 <prgn>umask</prgn> 來設定。參閱<manref name="builtins" section="7">。
</sect1>

<sect1 id="timestamp">時間戳記
<p>
<!-- old content, minor edit -->
在 GNU/Linux 檔案中，有三個時間戳記：
<list compact>
<item><strong>mtime</strong>：修改時間 (<tt>ls -l</tt>) ，
<item><strong>ctime</strong>：狀態改變時間 (<tt>ls -lc</tt>) 和
<item><strong>atime</strong>：最後存取時間 (<tt>ls -lu</tt>) 。
</list>
注意， <strong>ctime</strong> 並不是檔案建立時間。
<list compact>
<item>覆寫檔案會改變檔案的 <strong>mtime</strong> ， <strong>ctime</strong> 和 <strong>atime</strong> 全部的時間戳記。
<item>改變檔案權限或擁有者的話，會改變檔案的 <strong>ctime</strong> 和 <strong>atime</strong> 時間戳記。
<item>讀取檔案會改變檔案的 <strong>atime</strong> 時間戳記。
</list>
要注意的是，在 GNU/Linux 系統中，即使只是簡單的讀取檔案，通常也會為了要更新 <strong>inode</strong> 中的 <strong>atime</strong> 而導致寫入的動作。如果以 <tt>noatime</tt> 選項來掛上檔案系統的話，就可以略過這個動作而使讀取的動作加快。請參閱 <manref name="mount" section="8"> 。
<p>
<!-- new content -->
使用 <manref name="touch" section="1"> 中的指令來改變檔案的時間戳記。
</sect1>

<sect1 id="links">連結
<p>
<!-- old content -->
有兩種方法可以把一個叫 <var>foo</var> 的檔案關連到另一個檔名 <var>bar</var> 。
<list compact>
<item><strong>硬式連結 (hard link)</strong> 是現存檔案的一個別名 (<tt>ln <var>foo</var> <var>bar</var></tt>) ，
<item><strong>符號連結 (symbolic link)</strong> ，或是 "symlink" ，是一個特殊的檔案，它指向另一個檔案的名稱 (<tt>ln -s <var>foo</var> <var>bar</var></tt>) 。
</list>
下面的例子顯示了在使用 <prgn>rm</prgn> 指令後，連結數的改變和一些微妙的差異。
<example>
$ echo "Original Content" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # 硬式連結
$ ln -s <var>foo</var> <var>baz</var>  # 符號連結
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "New Content" &gt; <var>foo</var>
$ cat <var>bar</var>
Original Content
$ cat <var>baz</var>
New Content
</example>
<!-- minor update below -->
就像上面的例子所顯示的，符號連結的一般檔案存取權限為 "rwxrwxrwx" ，而實際的存取權限均由它們所指向的檔案來決定。
<p>
<file>.</file> 目錄是連結到其所出現的目錄，所以任何新目錄的連結數都是由 2 起跳的。而 <file>..</file> 目錄是連結到其所上層目錄，所以目錄的連結數會隨著子目錄數目而增加。

<sect1 id="fifo">Named pipes (FIFOs)
<p>
<!-- DDP Debian Tutorial content -->
<p>
named pipe 是類似管線的檔案。您可以輸入資料到這個檔案，然後他會輸出到別的地方。因此他也就作 FIFO(First-In-First-Out)：第一個送入管線的資料也是第一個送出管線的資料。
<p>
如果寫入 named pipe 時，寫入的程序並不會中斷直到該管線讀入為止。如果讀取 named pipe，讀取的程序會一直等待直到資料讀取完畢才停止。管線的大小永遠是零，因為它並不儲存資料，它主要是連結兩個程序，就像 shell 的 <tt>|</tt>。但是，自從管線被命名之後，兩個程序不需要在同一行執行或同一個使用者執行。
<p>
試著執行以下的例子：
<example>
$ cd; mkfifo mypipe
$ echo "hello" &gt;mypipe &amp; # put into background
[1] <var>5952</var>
$ ls -l mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
$ cat mypipe
hello
[1]+  Done                    echo hello &gt;mypipe
$ ls mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
$ rm mypipe
</example>

<sect1 id="sockets">Sockets
<p>
<!-- new content -->
socket 有點類似 named pipe (FIFO) 且允許程序與程序之間可以交換資料。針對 socket 來說，這些程序不需要在同一個時間執行或者同一個父程序產生的子程序。這是 inter process communication 的 ENDPOINT。網路上不同的主機透過 socket 也能夠互換資料。

<sect1 id="device">Device files
<p>
<!-- DDP Debian Tutorial content, modified -->
任何的硬體或虛擬裝置，例如硬碟，顯示卡，螢幕或鍵盤等，皆視為裝置檔案。<tt>/dev/console</tt>，主控台是最常見的虛擬裝置。
<p>
裝置有兩種型別：
<list compact>
<item><strong>character device</strong>
<list compact>
<item>一次存取一個字元。就是說存取該裝置最小的資料單位元是字元(byte)。
</list>
<item><strong>block 裝置</strong>
<list compact>
<item>一次存取較大單位的裝置稱為 block。硬碟就是一個 block 裝置。
</list>
</list>
<p>
您可以讀寫裝置檔案，即使是這些檔案可能採用二進制而讓人難以理解。直接寫入資料到這些檔案有時候是測試硬體是否已經連線的好方法。例如，您可以列印文字檔到印表機裝置：<file>/dev/lp0</file>或送指令到連接數據機的串列埠上：<file>/dev/ttyS0</file>。但請小心操作，也許會造成重大的損壞。所以要特別小心。

<sect2 id="devnull"><file>/dev/null</file> 類別
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> 是一個特別的裝置檔案，它會捨棄所有寫入的資料。如果您不需要某些資料，直接丟到 <file>/dev/null</file>。它基本上就是個黑洞。如果您讀取<file>/dev/null</file>，您會馬上得到 end-of-file (EOF) 字元。
<p>
<file>/dev/zero</file> 也是一樣，差別在於讀取時會得到<tt>\0</tt>字元(不是數字 0 喔)。參閱 <ref id="dummyfile">。

<sect2 id="node">裝置節點編號
<p>
<!-- new content -->
執行 <prgn>ls</prgn> 您就可以得到裝置節點的號碼：
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
請看底下說明：
<list compact>
<item><file>/dev/hda</file> 的主要裝置號碼：3，次要號碼是：0。只有<tt>disk</tt>群組中的使用者可以讀寫它。
<item><file>/dev/ttyS0</file> 的主要裝置號碼：4，次要號碼是：64。只有<tt>dialout</tt>群組中的使用者可以讀寫它。
<item><file>/dev/zero</file> 的主要裝置號碼：1，次要號碼是：5。任何帳號皆可讀寫它。
</list>
<p>
在舊式的系統上，安裝過程會使用 <prgn>/sbin/MAKEDEV</prgn> 建立裝置節點。參閱 <manref name="MAKEDEV" section="8">。
<p>
較新的系統上，<file>/dev</file> 下的檔案系統是經由類似 <file>/proc</file> 的檔案系統自動產生。

<sect1 id="procfs"><file>/proc</file> 檔案系統
<p>
<!-- modified heavily, original from Debian Guide -->
<file>/proc</file> 檔案系統是虛擬的檔案系統，紀錄著系統資訊和執行中的程式。
<p>
許多人常常因為 <file>/proc/kcore</file> 太大而傷腦筋。該檔案的大小跟您電腦安裝的記憶體一樣大。它主要用來進行核心偵錯，但本身並不存在任何地方，所以請別擔心它的容量大小。
<p>
參閱 <ref id="proc-sys"> 和 <manref name="proc" section="5">。

<sect id="xtuto">X Window 系統
<p>
<!-- practically new content -->
請參閱 <ref id="x">。

<sect1 id="xstart">啟動 X Window System
<p>X Window 系統會跟著 <prgn>xdm</prgn>-like 等圖形登入軟體執行時啟動，或者在主控台輸入：
<example>
$ exec startx
</example>

<sect1 id="xmenu">X Window 系統的選單功能
<p>
自從 X 環境提供了許多的視窗管理器之後，他們的使用者介面都有些許的差異。請牢記按下右鍵會帶出系統選單。該功能一直都有。
<list compact>
<item>要取得 shell 命令列，點選選單中的 Xterm：
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>至於圖形化的網頁瀏覽器，點選選單中的 Mozilla：
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>至於圖形化的 PDF 瀏覽器，點選選單中的 Xpdf：
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
如果您找不到 menu，請安裝相關的套件。參閱 <ref id="apt-install">。

<sect1 id="xkeys">X Window 系統的鍵盤順序
<p>
底下是執行 X Window 系統時重要的組合控制鍵。
<list compact>
<item>Ctrl-Alt-F1 到 F6:  切換到其他的虛擬終端機 (從 X window, DOSEMU 等)
<item>Alt-F7:               返回 X window 畫面
<item>Ctrl-Alt-minus:       降低 X window 的解析度 (這裡的 minus(-) 是指數字鍵上的減號)
<item>Ctrl-Alt-plus:        提高 X window 的解析度 (這裡的 plus(+) 是指數字鍵上的加減號)
<item>Ctrl-Alt-Backspace:   終止 X Server
<item>Alt-X, Alt-C, Alt-V:  同於 Windows/Mac 上的剪下，複製，貼上。在某些程式如 Netscape Composer 需改用 Alt 來代替 Ctrl。
</list>

<sect id="cmd-study">後續的學習指南
<p>
現在，我推薦您閱讀 <url id="&tldp-guide;" name="The Linux Documentation Project: Guides"> 網站上主要的引導書籍：
<list compact>
<item>"The Linux System Administrators' Guide",
<list compact>
<item>此書包含了如何讓系統永不停機，使用者帳號管理，備份，系統設定等觀念。
<item>套件：<package>&p-sysadmin-guide;</package>
<item>檔案： <url id="&f-sysadmin-guide;">
<item>網址：<url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition",
<list compact>
<item>這是一本駕馭 Linux 網路管理的參考手冊。
<item>套件： <package>&p-netadmin-guide;</package>
<item>檔案： <url id="&f-netadmin-guide;">
<item>網址： <url id="&w-netadmin-guide;">
</list>
 <item><em>Linux: Rute User's Tutorial and Exposition</em>
 <list compact>
  <item>管理 GNU/Linux 系統的精裝版線上書籍。
  <item>作者： Paul Sheer
  <item>由 Prentice Hall 發行
  <item>套件: <package>&p-rutebook;</package> (從 <tt>non-free</tt>)
  <item>檔案: <file>&f-rutebook;</file>
  <!--
  <item>網站: <url id="&rutehome;">
  -->
 </list>
</list>
<p>
參閱 <ref id="support"> 取得更多的學習資源。
</chapt>

