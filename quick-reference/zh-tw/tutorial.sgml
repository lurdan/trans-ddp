<!-- CVS revision of this document "$Revision: 1.1 $"  -->
<!-- CVS revision of original english document "1.35" -->

<chapt id="tutorial">&debian; 教程

<p>
本章為那些初涉 Linux 世界的新手指出了一個基本的方向。如果你接觸 Linux 已有一段時
間，可以當成是一次實戰測驗。

<sect>資訊來源
<p>
到 <url id="&debiandoc;"
name="Debian Documentation Project (DDP)"> 看看，
那兒有最權威的 Debian 參考資料。其中的許多文件通常都安裝在
<file>/usr/share/doc/</file>。也可以到 
<file>/usr/share/doc-base/</file> 看看，
那裡提供了系統之中文件的指引。
在 <file>~/.bash_profile</file> 中加入 
<tt>export CDPATH=.:/usr/share/doc:/usr/src/local</tt>，
這樣可以使讀取這些文件目錄更容易些。
<p>
在 <url id="&linuxdoc;" name="Linux Documentation Project (LDP)"> 中有最權威的 
Linux 通用參考資料。 LDP 的資料通常安裝在 <file>/usr/share/doc/HOWTO/</file> 目錄下。
<p>
瀏覽本地或遠端 FTP 站點的文件，可在 Midnight Commander 中按下 <tt>F9</tt> (參閱 <ref id="mc">)。
</sect>

<sect>Linux 控制台 (console)

<sect1 id="login">登入
<p>
在一般 Linux 系統中，會有 6 個獨立的偽終端 (pseudo-terminals)。同時按下
<tt>Left-Alt</tt> 鍵和 <tt>F1</tt>&ndash;<tt>F6</tt> 鍵可在這些偽終端間切換。每個偽
終端均需分別登入。多使用者環境是 Unix 重要的特性，而且一用就上癮。
<p>
使用一般使用者帳號工作是使用 Unix 的好習慣。不得不承認，我過去常僅僅為圖個方便而
濫用超級使用者帳號 (root)。
<p>
現在，我通常使用一般的帳號，再利用 <tt>sudo</tt> 、 <tt>super</tt> 或 <tt>su
-c</tt> 來獲得有限的 root 權限。
</sect1>

<sect1 id="newuser">增加使用者帳號
<p>
系統安裝完畢後，我通常會新增一個一般使用者帳號。如果使用者名稱為 "penguin"，則
<example>
# adduser penguin
</example>
就會建立帳號。
<p>
我使用 <tt>vigr</tt> 命令來編輯 <file>/etc/group</file> ：
<example>
adm:x:4:admin
src:x:40:admin, debian, ...
...
</example>
在系統預設安裝狀態下， <tt>adm</tt> 群組成員可以讀取在 <file>/var/log</file> 下
的許多記錄檔，並且可以使用 <prgn>xconsole</prgn> 。 <tt>staff</tt> 群組擁有
<file>/home</file>，使其成員適合於進行使用者帳號維護的工作，而 <tt>src</tt> 群組
擁有 <file>/usr/src</file> ，可以用來編譯核心等等。有關使用者及群組的規範描述可
參閱最新的 <url id="&f-users-and-groups;" name="users-and-groups"> 文件。
<p>
我個人使用 <tt>adm</tt> 群組來管理那些具有管理員職責和 exclusive <prgn>su</prgn> 
特權的使用者 (參閱 <ref id="wheel">)，而將 CVS 用戶放在 <tt>src</tt> 群組 (參閱
<ref id="cvs">)。
<p>
用 <prgn>adduser</prgn> ， <prgn>addgroup</prgn> ， <prgn>vipw</prgn> ，
<tt>vipw -s</tt> ， <prgn>vigr</prgn> ，以及 <tt>vigr -s</tt> 檢查一下使
用者及群組是否配置得當。
</sect1>

<sect1>如何關機
<p>
和任何現代的 OS 一樣，檔案會暫存於記憶體中，
所以在安全切斷電源之前 Linux 需要完成適當的關機程序。這裡是多用戶模式下使用的命令：
<example>
# shutdown -h now
</example>
這是單一使用者模式下使用的命令：
<example>
# poweroff -i -f
</example>
等待螢幕上顯示 "System halted" 文字之後切斷電源。
如果 BIOS 和 Linux 開啟了 APM ，系統會自動切斷電源。詳情參閱 <ref id="apm">。
</sect1>

<sect1>命令列編輯
<p>
預設的 shell 是 <prgn>bash</prgn> ，它能記住使用過的命令 (history-editing)。
只需按上下鍵就會出現之前的命令，然後就可以用游標 (cursor) 來輸入。
其它需要牢記的重要按鍵有：
<example>
Ctrl-U:                    清除一行中游標之前的文字
Ctrl-D:                    結束輸入
Left-click-and-drag mouse: 選取並拷貝至剪貼簿 (gpm)
Click middle mouse button: 將剪貼簿內容貼至游標處 (gpm)
</example>
<p>
在一般的 Linux console 中，只有左邊的 Ctrl 和 Alt 鍵有作用。
</sect1>

<sect1>執行命令
<p>
Typical command execution uses a shell line sequence like the following:
<example>
$ LC_ALL=fr ls -la
</example>
Here, the program <prgn>ls</prgn> is executed in the foreground job with the
environment variable <tt>LC_ALL</tt> set to <tt>fr</tt> for a French locale and
the command-line argument set to <tt>-la</tt> for listing everything in
detail.  If the command line is postfixed by the <tt>&amp;</tt> sign then
the command is executed in a background job.  Background jobs
allow users to run multiple programs in a single shell.
<p>
Command execution can be managed with the following keystrokes.
<example>
Ctrl-C:                  Terminate program
Ctrl-Z:                  Temporarily stop program
Ctrl-S:                  Halt output to screen
Ctrl-Q:                  Reactivate output to screen
Ctrl-Alt-Del:            Reboot/halt system (see /etc/inittab)
</example>
For the management of program execution, see 
<manref name="bash" section="1"> for <tt>jobs</tt>, <tt>fg</tt>,
<tt>bg</tt>, and <tt>stop</tt>.
</sect1>

<sect1>Very basic commands to remember
<p>
The following are very basic Unix commands:
<example>
ls, ls -al, ls -d, pwd, cd, cd ~user, cd -, 
cat /etc/passwd, less, bg, fg, kill, killall, 
uname -a, type <var>commandname</var>, sync, netstat,
ping, traceroute, top, vi, ps aux, tar, zcat, 
grep, ifconfig, ...
</example>
<p>
Check their meaning by entering the commands at a command prompt or by
entering <tt>man</tt> or <tt>info</tt> plus the command name. Many Linux commands will
display brief help information if you invoke them in one of the following
ways:
<example>
$ commandname --help
$ commandname -h
</example>
<tt>whatis <em>commandname</em></tt> gives a one-line summary of any command on
the system for which there is a manual entry.
</sect1>

<sect1>X Window System
<p>
To start the X Window System from the console:
<!-- Osamu: formal name here per request in "man 7 X" manpage -->
<example>
# exec startx
</example>
Right-clicking the root window will bring up menu selections.
</sect1>

<sect1>Important keyboard commands
<p>
Some important keystrokes to remember for the Linux console (<tt>plus</tt>,
<tt>minus</tt> refer to the keys on the numeric keypad):
<example>
Alt-F1 thru F6:       Switch to other pseudo-terminals
Ctrl-Alt-F1 thru F6:  Switch to other pseudo-terminals
                      (from an X window, DOSEMU, etc.)
Alt-F7:               Switch back to X window
Ctrl-Alt-minus:       Change screen resolution in X window
Ctrl-Alt-plus:        Change screen resolution opposite way in X window
Ctrl-Alt-Backspace:   Terminate the X11 server program
Alt-X, Alt-C, Alt-V:  Usual Windows/Mac Cut, Copy, Paste keys 
        combinations with Ctrl- keys are replaced by these Alt- keys
        in some programs such as Netscape Composer.
</example>
</sect1>
</sect>

<sect id="mc">Midnight Commander (MC)
<p>
Midnight Commander (MC) is a GNU "Swiss army knife" for the Linux console and
other terminal environments.  

<sect1>Install MC
<p>
<example>
# apt-get install mc
</example>
Then modify <file>~/.bashrc</file> (or <file>/etc/bash.bashrc</file>, 
called from <file>.bashrc</file>), as detailed in its manual page,
<manref name="mc" section="1">, under the <tt>-P</tt> option.
This enables MC to change working directory upon exit.
<p>
If one is in a terminal, such as <prgn>kon</prgn> and <prgn>Kterm</prgn> for
Japanese, that utilizes certain graphics characters, adding <tt>-a</tt> to
MC's command line may help prevent problems.
</sect1>

<sect1>Start MC
<p>
<example>
$ mc
</example>
MC takes care of all file operations through its menu, requiring minimal 
user effort.
</sect1>

<sect1>File manager
<p>
The default is two directory panels containing file lists.  Another useful
mode is to set the right window to "information" to see file access privilege
information, etc. Following are some essential keystrokes. With the
<prgn>gpm</prgn> daemon
running, one can use a mouse, too.  (Make sure to press the shift key to
obtain the normal behavior of cut and paste in MC.)
<list compact>
<item><tt>F1</tt>: Help menu
<item><tt>F3</tt>: Internal file viewer
<item><tt>F4</tt>: Internal editor
<item><tt>F9</tt>:  Activate pulldown menu
<item><tt>F10</tt>: Exit Midnight Commander
<item><tt>Tab</tt>: Move between two windows
<item><tt>Insert</tt>: Mark file for a multiple-file operation such as copy
<item><tt>Del</tt>: Delete file (be careful&mdash;set MC to safe delete mode.)
<item>Cursor keys: Self-explanatory
</list>
</sect1>

<sect1>Command-line tricks
<p>
<list>
<item>Any <prgn>cd</prgn> command will change the directory shown on the selected screen.
<item>Ctrl-Enter or Alt-Enter will copy a filename to the command line. Use
this with the <prgn>cp</prgn> or <prgn>mv</prgn> command together with command-line editing.
<item><tt>Alt-Tab</tt> will show shell filename expansion choices.
<item>One can specify the starting directory for both windows as arguments to
MC; for example, <tt>mc /etc /root</tt>.
<item><tt>Esc</tt> + <var>numberkey</var> == <tt>F<var>n</var></tt> (i.e.,
      <tt>Esc</tt> + <tt>1</tt> = <tt>F1</tt>, etc.;
      <tt>Esc</tt> + <tt>0</tt> = <tt>F10</tt>)
<item><tt>Esc</tt> key       == <tt>Alt</tt> key (= <tt>Meta</tt>,
  <tt>M-</tt>); i.e., type <tt>Esc</tt> + <tt>c</tt> for <tt>Alt-c</tt>
</list>
</sect1>

<sect1 id="mcedit">Editor
<p>
The internal editor has an interesting cut-and-paste scheme. Pressing
<tt>F3</tt> marks the start of a selection, a second <tt>F3</tt> marks
the end of selection and highlights the selection. Then you can move
your cursor. If you press <tt>F6</tt>, the selected area will be moved
to the cursor location. If you press <tt>F5</tt>, the selected area will
be copied and inserted at the cursor location.  <tt>F2</tt> will save
the file. <tt>F10</tt> will get you out. Most cursor keys work
intuitively.
<p>
This editor can be directly started on a file:
<example>
$ mc -e filename_to_edit
$ mcedit filename_to_edit
</example>
<p>
This is not a multiwindow editor, but one can use multiple Linux consoles
to achieve the same effect. To copy between windows, use <tt>Alt-F<var>n</var></tt> keys to switch
virtual consoles and use "File-&gt;Insert file" or "File-&gt;Copy to file"
to move a portion of a file to another file.
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)
-->
<p>
This internal editor can be replaced with any external editor of choice.
<p>
Also, many programs use environment variables <tt>EDITOR</tt> or 
<tt>VISUAL</tt> to decide which editor to use.  If you are uncomfortable
with <prgn>vim</prgn>, set these to <tt>mcedit</tt> by adding these lines to
<file>~/.bashrc</file>:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
I do recommend setting these to <tt>vim</tt> if possible.  Getting used to 
vi(m) commands is the right thing to do, since they are always there in 
the Linux/Unix world.
</sect1>

<sect1>Viewer
<p>
Very smart viewer. This is a great tool for searching words in documents.  I
always use this for files in the <file>/usr/share/doc</file> directory. This is the fastest
way to browse through masses of Linux information. This viewer can be directly
started like so:
<example>
$ mc -v filename_to_view
</example>
(Note that some packages violate policy and still store their documents under
<file>/usr/doc</file>.)
</sect1>

<sect1>Auto-start features
<p>
Press <tt>Enter</tt> on a file, and the appropriate program will
handle the content of the file. This is a very convenient MC feature.
<example>
executable:        Execute command
man, html file:    Pipe content to viewer software
tar, gz, rpm file: Browse its contents as if subdirectory
</example>
In order to allow these viewer/virtual file features to function, viewable
files should not be set as executable. Change their status using the
<prgn>chmod</prgn> command or via the MC file menu.
</sect1>

<sect1>FTP virtual filesystem
<p>
MC can be used to access files over the Internet using FTP. Go to the menu
by pressing <tt>F9</tt>, then type <tt>p</tt> to activate the FTP virtual filesystem. Enter
a URL in the form <tt>username:passwd@hostname.domainname</tt>, which will retrieve a
remote directory that appears like a local one.
</sect1>

</sect>

<sect id="file-system">Basics of the GNU/Linux filesystem
<p>
Each file and directory on a GNU/Linux system is associated with a user who
owns it (owner) and a group that it belongs to.  All the file
information is stored in a data structure called an <strong>inode</strong>.

<sect1 id="file-perm">File and directory access permissions
<p>
File and directory access permissions are defined separately for 
the following three categories of affected users:
<list compact>
<item>the <strong>user</strong> who owns the file (u), 
<item>other users in the <strong>group</strong>  which the file belongs
to (g), and
<item>all <strong>other</strong> users (o).
</list>
<p>
For a file, each corresponding permission allows:
<list compact>
<item><strong>read</strong> (r): to examine contents of the file
<item><strong>write</strong> (w): to modify the file
<item><strong>execute</strong> (x): to run the file as a command
</list>
<p>
For a directory, each corresponding permission allows:
<list compact>
<item><strong>read</strong> (r): to list contents of the directory
<item><strong>write</strong> (w): to add or remove files in the directory
<item><strong>execute</strong> (x): to access files in the directory
</list>
Here, <strong>execute</strong> permission on the directory means not 
only to allow reading of files in its directory but also to allow 
viewing their attributes, such as the size and the modification time.
<p>
To display permission information (and more) for files and directories, 
<prgn>ls</prgn> is used.  See <manref name="ls" section="1">.  
When <prgn>ls</prgn> invoked with the <tt>-l</tt> option, it displays 
the following information in the order given:
<list compact>
<item>the <strong>type of file</strong> (first character)
 <list compact>
 <item>-: normal file
 <item>d: directory
 <item>l: symlink
 <item>c: character device node
 <item>b: block device node
 </list>
<item>the file's access <strong>permissions</strong> (the next 9
 characters, consisting of 3 characters each for user, group, and other
 in this order)
<item>the <strong>number of hard links</strong> to the file 
<item>the name of the <strong>user</strong> who owns the file
<item>the name of the <strong>group</strong> which the file belongs to
<item>the <strong>size</strong> of the file in characters (bytes)
<item>the <strong>date and time</strong> of the file (mtime)
<item>the <strong>name</strong> of the file.
</list>
<p>
To change the owner of the file, <prgn>chown</prgn> is used from the
root account.  See <manref name="chown" section="1">.  To change the
group of the file, <prgn>chgrp</prgn> is used from the file's owner or
root account.  See <manref name="chgrp" section="1">.  To change file
and directory access permissions, <prgn>chmod</prgn> is used from the
file's owner or root account.  See <manref name="chmod" section="1">.
<p>
For example, in order to make a directory tree to be owned by a user
<var>foo</var> and shared by a group <var>bar</var>, issue the following
commands from the root account: 
<example>
# cd /some/location/
# chown -R <var>foo</var>:<var>bar</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
There are three more special permission bits:
<list compact>
<item><strong>set user ID</strong> (s or S instead of user's x), 
<item><strong>set group ID</strong> (s or S instead of group's x), and
<item><strong>sticky bit</strong> (t or T instead of other's x).
</list>
Here the output of <prgn>ls -l</prgn> for these bits is capitalized if 
execution bits hidden by these outputs are unset.
<p>
Setting <strong>set user ID</strong> on an executable file allows a user
to execute the executable file with the owner ID of the file (for
example <strong>root</strong>). Similarly,
setting <strong>set group ID</strong> on an executable file allows a
user to execute the executable file with the group ID of the file (for
example <strong>root</strong>). Because these settings can
cause security risks, enabling them requires extra caution.
<p>
Setting <strong>set group ID</strong> on a directory enables the
BSD-like file creation scheme where all files created in the directory
belong to the <strong>group</strong> of the directory.  
<p>
Setting the <strong>sticky bit</strong> on a directory prevents a file in
the directory from being removed by a user who is not the owner of the file.
In order to secure the contents of a file in world-writable directories
such as <file>/tmp</file> or in group-writable directories, one must not
only set <strong>write</strong> permission off for the file but also set
the <strong>sticky bit</strong> on the directory.  Otherwise, the file can
be removed and a new file can be created with the same name by any user
who has write access to the directory.
<p>
Here are a few interesting examples of the file permissions.
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
</sect1>

<sect1 id="timestamp">Timestamps
<p>
There are three types of timestamps for a GNU/Linux file:
<list compact>
<item><strong>mtime</strong>: the modification time (<tt>ls -l</tt>),
<item><strong>ctime</strong>: the status change time (<tt>ls -lc</tt>), and
<item><strong>atime</strong>: the last access time  (<tt>ls -lu</tt>).
</list>
Note that <strong>ctime</strong> is not file creation time.  
<list compact>
<item>Overwriting a file will change all of <strong>mtime</strong>,
  <strong>ctime</strong>, and <strong>atime</strong> of the file.
<item>Changing permission or owner of a file will change
  <strong>ctime</strong> and <strong>atime</strong> of the file.
<item>Reading a file will change <strong>atime</strong> of the file.
</list>
Note that even simply reading a file on GNU/Linux system will normally
cause a file write operation to update <strong>atime</strong>
information in the <strong>inode</strong>.  Mounting a filesystem with
the <tt>noatime</tt> option will let the system skip this operation and will
result in faster file access for the read.  See <manref name="mount"
section="8">.
</sect1>

<sect1 id="links">Links
<p>
There are two methods of associating a file <var>foo</var> with a different 
filename <var>bar</var>.
<list compact>
<item>a <strong>hard link</strong> is a duplicate name for an existing file
 (<tt>ln <var>foo</var> <var>bar</var></tt>),
<item>a <strong>symbolic link</strong>, or "symlink", is a special file that
  points to another file by name
 (<tt>ln -s <var>foo</var> <var>bar</var></tt>).
</list>
See the following example for the changes in link counts and the subtle 
differences in the result of the <prgn>rm</prgn> command.
<example>
$ echo "Original Content" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # hard link
$ ln -s <var>foo</var> <var>baz</var>  # symlink
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "New Content" &gt; <var>foo</var>
$ cat <var>bar</var>
Original Content
$ cat <var>baz</var>
New Content
</example>
A symlink has nominal file access permissions of "rwxrwxrwx", as shown in
the above example, with the effective access permissions dictated by the
permissions of the file that it points to.

<p>
The <file>.</file> directory links to the directory that it appears in, thus
the link count of any new directory starts at 2.  The <file>..</file> directory
links to the parent directory, thus the link count of the directory increases
with the addition of new subdirectories.
</sect1>
</sect>


<sect>Further study
<p>
There are many good entry-level Unix references out there.  O'Reilly's books
are usually safe bets for good guidebooks in any computer topic. 
The LDP document <url id="&tips-howto;" name="The Linux Tips HOWTO"> is
another resource to check. See <ref id="support"> for more resources.

</sect>

</chapt>

