<!-- CVS revision of this document "$Revision: 1.1 $"  -->
<!-- CVS revision of original english document "1.18" -->

<chapt id="gnupg">GnuPG

<p>
參考資料：
<list compact>
<item><manref name="gpg" section="1">. 
<item><file>&dochome;gnupg/README.gz</file>
<item><file>&dochome;gnupg-doc/GNU_Privacy_Handbook/</file> 中的
  <em>GNU privacy handbook</em>
 (安裝 <package>gnupg-doc</package> 套件)
</list>

<sect>安裝 GnuPG
<p>
<example>
# gpg --gen-key                   # 產生新的 key
# gpg --gen-revoke <var>my_user_ID</var>     # 產生 <var>my_user_ID</var> 的廢止用 key
# host -l pgp.net | grep www|less # 指出 pgp keyservers
</example>
目前，較好的 keyservers 有：
<example>
keyserver wwwkeys.eu.pgp.net
keyserver wwwkeys.pgp.net
</example>
必須注意<strong>不能建立 2 個以上的 sub-keys</strong>，如果你這樣做，pgp.net 上
的 keyservers 會<strong>廢除</strong>（corrupt）你的 key。使用新版的 
<package>gnupg</package> (>1.2.1-2) 來處理這些廢除的 subkeys。參閱 <url
id="&gpg-subkeys;">。

<p>
同樣地，在 <file>$HOME/.gnupg/options</file> 中只能指定一個 keyserver。

<p>
所以，下面的設定是不行的：

<example>
keyserver search.keyserver.net
keyserver pgp.ai.mit.edu
</example>

</sect>

<sect>使用 GnuPG
<p>
檔案處理：
<example>
$ gpg  [options]  <var>command  [args]</var>
$ gpg {--armor|-a} {--sign|-s} <var>file</var> # 將 file 簽名，存至文字檔 <var>file</var>.asc
$ gpg --clearsign <var>file</var>              # clear-sign 訊息
$ gpg --clearsign --not-dash-escaped <var>patchfile</var>  # clear-sign patchfile
$ gpg --verify <var>file</var>                 # 驗證 clear-signed <var>file</var>
$ gpg -o <var>file.sig</var> {-b|--detach-sig} <var>file</var> # 建立 detached 簽章
$ gpg --verify <var>file.sig</var> <var>file</var>        # 用 <var>file.sig</var> 驗證 <var>file</var>
$ gpg -o <var>crypt_file</var> {--recipient|-r} <var>name</var> {--encrypt|-e} <var>file</var> 
        # public-key encryption intended for name
$ gpg -o <var>crypt_file</var> {--symmetric|-c} <var>file</var> # 對稱式加密
$ gpg -o <var>file</var> --decrypt crypt_file  # 解密
</example>
</sect>

<sect>管理 GnuPG
<p>
Key 管理：
<example>
$ gpg --edit-key <var>user_ID</var>               # "help"，互動式的說明
$ gpg -o <var>file</var> --exports                # 將所有的 key 匯出至 <var>file</var> 
$ gpg --imports <var>file</var>                   # 匯入 <var>file</var> 中所有的 key
$ gpg --send-keys <var>user_ID</var>              # 將 <var>user_ID</var> 的 key 傳送到 keyserver
$ gpg --recv-keys <var>user_ID</var>              # 從 keyserver 接收 <var>user_ID</var> 的 key
$ gpg --list-keys <var>user_ID</var>              # 列出 <var>user_ID</var> 的 key
$ gpg --list-sigs <var>user_ID</var>              # 列出 <var>user_ID</var> 的 sig.
$ gpg --check-sigs <var>user_ID</var>             # 檢查 <var>user_ID</var> 的 sig.
$ gpg --fingerprint <var>user_ID</var>            # 檢查 <var>user_ID</var> 的 fingerprint
$ gpg --list-sigs | grep '^sig' | grep '[User id not found]' \
  | awk '{print $2}' | sort -u | xargs gpg --recv-keys # 取得未知的 keys
  # 將所有未知的 sigs 更新 key 。
</example>
Trust code:
<example>
-         No ownertrust assigned / not yet calculated.
e         計算信任度失敗。
q         計算所需的資訊不足。
n         永不信任這把 key。
m         Marginally trusted.
f         完全信任 (Fully trusted)。
u         極度信任 (Ultimately trusted)。
</example>
下面的命令會將我的 key "<var>A8061F32</var>" 上傳至多個 key servers：
<example>
$ for xx in us es cz de dk uk ch net.uk earth.net.uk; \
$ do gpg --keyserver wwwkeys.$xx.pgp.net  --send-keys <var>A8061F32</var>; done
</example>
</sect>

<sect>在應用程式中使用 GnuPG
<p>
<sect1>在 Mutt 中使用 GnuPG
<p>
在 <file>~/.muttrc</file> 中加入下列的內容，則如果你在 index 選單中輸入 
`<tt>S</tt>' 的話，將會自動啟動一個低速的 GnuPG。
<example>
macro index S ":toggle pgp_verify_sig\n"
set pgp_verify_sig=no
</example>

<sect1 id="vimgpg">在 Vim 中使用 GnuPG
<p>
將 <url id="&examples;" name="examples subdirectory"> 中的 <file>vimgpg</file> 
文件的內容加到 <file>~/.vimrc</file> 就可以自然的執行 GnuPG。

</chapt>
