<!-- CVS revision of this document "$Revision: 1.6 $"  -->
<!-- CVS revision of original english document "1.34"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->
<!-- DON't TOUCH GROFF SECTION!!! -->


<chapt id="program">Programação
<p>
Não use "test" como o nome de um arquivo de teste executável. O
<prgn>test</prgn> é um comando interno de shell.

<sect>Onde começar
<p>
Referências:
<list compact>
<item>Documentos e exemplos sob o <file>&dochome;<var>pacotes</var></file>
<item><url id="&uno-jclark;" name="Unix / Informação sobre Programação">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
Muitos documentos informativos longos podem ser obtidos como brochuras do 
<url id="&gnuhome;" name="GNU">.
<p>
As próximas quatro seções contêm scripts de exemplo em diferentes 
linguagens para criar um arquivo texto de informação de uma conta para ser
adicionado no <file>/etc/passwd</file> usando um processador de arquivo de lote
como o programa <prgn>newusers</prgn>. Cada script requer como entrada um
arquivo com linhas na forma <tt>prenome sobrenome senha</tt>.  (Os
diretórios home do usuário real não serão criados através desses scripts.)
</sect>

<sect id="shell">Shell
<p>
Ler scripts shell é a <strong>melhor</strong> maneira de entender como um
sistema similar ao Unix funciona.  Aqui, dou alguns apontamentos e lembretes de
programação shell.

<sect1 id="bash">Bash &ndash o shell interativo padrão do <strong>GNU</strong>
<p>
Referências sobre o Bash:
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>o <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
do LDP como informção inicial.
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (Instale o pacote <package>bash-doc</package> para ver os arquivos de exemplo.)
<item><em>Learning the bash Shell</em>, segunda edição (O'Reilly)
</list>
<p>
Programa de exemplo curto (cria entradas de conta para o <prgn>newusers</prgn> a
partir da entrada padrão):
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">Shells POSIX
<p>
Vários pacotes fornecem um shell POSIX no &debian;:
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Prioridade: opcional
  <item>Tamanho instalado: 176
  <item>O menor de todos e muito mais rápido &mdash; o melhor para primeira
  inicialização
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Prioridade: opcional
  <item>Tamanho instalado: 180
  <item>Menor e muito mais rápido &mdash; bom para primeira inicialização
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essencial: sim
  <item>Prioridade: requerido
  <item>Tamanho instalado: 580
  <item>Maior e com mais recursos &mdash; muitas extensões implementadas
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Prioridade: opcional
  <item>Tamanho instalado: 408
  <item>Similar do ksh AT&amp;T completo
 </list>
</list>
<p>
Se você estiver escrevendo um script shell para portabilidade, é melhor
escrevê-lo como um script shell POSIX.  Use o <file>/bin/sh</file> ligado ao 
<prgn>ash</prgn> ou (<prgn>dash</prgn>) para testar sua compatibilidade POSIX. 
Evite escrever scripts com um <strong>bashismo</strong> ou o
<strong>zshismo</strong> que parece assemelhar-se à sintaxe de
<prgn>csh</prgn>. Por exemplo, evite:
<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>arquivo</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>

<sect1 id="shell-param">Parâmetros shell
<p>
Há vários <strong>parâmetros especiais</strong> a lembrar:
<example compact>
$0      = nome do shell ou do script shell
$1      = primeiro(1) argumento do shell
 ...
$9      = nono(9) argumento do shell
$#      = número de parâmetros posicionais
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = estado de saída do comando mais recente
$$      = PID desse script shell
$!      = PID do trabalho em background iniciado mais recentemente
</example>
<p>
<strong>Expansões de parâmetros</strong> básicas a lembrar:
<example compact>
    Forma       Se <var>var</var> está def.(*)  Se <var>var</var> não está def.(*)
${<var>var</var>:-<var>string</var>}  $<var>var</var>                <var>string</var>
${<var>var</var>:+<var>string</var>}  <var>string</var>              null
${<var>var</var>:=<var>string</var>}  $<var>var</var>                <var>string</var> 
                                    (e executa <var>var</var>=<var>string</var>)
${<var>var</var>:?<var>string</var>}  $<var>var</var>                (echo <var>string</var> e então sai)
</example>
Aqui, os dois pontos `:' em todos esses operadores são atualmente opcionais.
<list compact>
<item>Com `:' = operador de teste para "existe" e "não nulo".
<item>Sem `:' = operador de teste somente para "existe".
</list>
<p>
<strong>Substituições de parâmetros</strong> básicas a lembrar:
<example compact>
    Forma        Resultado
${<var>var</var>&percnt;<var>sufixo</var>}    Remove menor padrão <var>sufixo</var>
${<var>var</var>&percnt;&percnt;<var>sufixo</var>}   Remove maior padrão <var>sufixo</var> 
${<var>var</var>#<var>prefixo</var>}   Remove menor padrão <var>prefixo</var> 
${<var>var</var>##<var>prefixo</var>}  Remove maior padrão <var>prefixo</var> 
</example>

<sect1 id="shell-redirect">Redirecionamento shell
<p>
<strong>Redirecionamentos</strong> básicos a lembrar (aqui o [n] é um número
opcional): 
<example compact>
[n]&gt; <var>arquivo</var>   Redireciona a saída padrão (ou n) para o <var>arquivo</var>.
[n]&gt;&gt; <var>arquivo</var>  Adiciona a saída padrão (ou n) ao <var>arquivo</var>.
[n]&lt; <var>arquivo</var>   Redireciona a entrada padrão (ou n) a partir do <var>arquivo</var>.
[n1]&gt;&amp;n2       Redireciona a saída padrão (ou n1) para n2.
&gt; <var>arquivo</var> &gt;&2  Redireciona as saídas padrão e de erro para o <var>arquivo</var>.
| <var>comando</var>      Faz um pipe da saída padrão para o <var>comando</var>.
&gt;&2 | <var>comando</var>  Faz um pipe das saídas padrão e de erro para o <var>comando</var>.
</example>

<sect1 id="shell-cond">Condicionais de shell
<p>
Cada comando retorna um <strong>estado de saída</strong> que pode ser usado para
a expressão condicional :
<list compact>
<item>Successo: 0 (Verdadeiro)
<item>Erro: 1 - 255 (Falso)
</list>
Note que o uso do valor 0 aqui para significar "verdadeiro" difere da convenção
normal de outras áreas da computação. Além disso, `[' é o equivalente do comando
<prgn>test</prgn>, que avalia seus argumentos até o `]' como uma expressão
condicional. 
<p>
As <strong>sentenças condicionais</strong> básicas a lembrar são:
<example compact>
<var>comando</var> && <var>se_sucesso_executa_esse_comando_também</var>
<var>command</var> || <var>se_insucesso_executa_esse_comando_também</var>

if [ <var>expressão_condicional</var> ]; then  
 <var>se_sucesso_executa_esse_comando</var>
else
 <var>se_insucesso_executa_esse_comando</var>
fi
</example>
<p>
Os operadores de comparação de <strong>arquivos</strong> nas expressões
condicionais são:
<example compact>
-e <var>arquivo</var>            Verdadeiro se o <var>arquivo</var> existe.
-d <var>arquivo</var>            Verdadeiro se o <var>arquivo</var> existe e é um diretório.
-f <var>arquivo</var>            Verdadeiro se o <var>arquivo</var> existe e é um arquivo regular.
-w <var>arquivo</var>            Verdadeiro se o <var>arquivo</var> existe e é gravável.
-x <var>arquivo</var>            Verdadeiro se o <var>arquivo</var> existe e é executável.
<var>arquivo1</var> -nt <var>arquivo2</var> Verdadeiro se o <var>arquivo1</var> é mais novo que o <var>arquivo2</var>. (modificação)
<var>arquivo1</var> -ot <var>arquivo2</var> Verdadeiro se o <var>arquivo1</var> é mais antigo que o <var>arquivo2</var>. (modificação)
<var>arquivo1</var> -ef <var>arquivo2</var> Verdadeiro se eles são o mesmo dispositivo e número de inode.
</example>
<p>
Os operadores de comparação de <strong>cadeias de caracteres</strong> em
expressões condicionais são:
<example compact>
     -z <var>str</var>    Verdadeiro se o comprimento de <var>str</var> é zero.
     -n <var>str</var>    Verdadeiro se o comprimento de <var>str</var> não é zero.
<var>str1</var> == <var>str2</var>   Verdadeiro se as <var>str</var> são iguais.
<var>str1</var> = <var>str2</var>    Verdadeiro se as <var>str</var> são iguais.
    ( "=" deve ser usado no lugar de "==" para conformidade POSIX estrita )
<var>str1</var> != <var>str2</var>   Verdadeiro se as cadeias de caracteres não são iguais.
<var>str1</var> &lt;  <var>str2</var>   Verdadeiro se <var>str1</var> é ordenada antes de <var>str2</var> (depende do locale).
<var>str1</var> &gt;  <var>str2</var>   Verdadeiro se <var>str1</var> é ordenada depois de <var>str2</var> (depende do locale).
</example>
<p>
Os operadores de comparação <strong>aritmética</strong> inteira nas expressões
condicionais são <tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>, 
<tt>-le</tt>, <tt>-gt</tt>, ou <tt>-ge</tt>.
</sect1>

<sect1 id="clprocess">Processamento de linha de comando
<p>
O shell processa um script como a seguir:
<list compact>
<item>divide em <strong>tokens</strong> através dos metacaracteres: ESPAÇO, TAB, NOVALINHA, ;, (, ), &lt;, &gt;, |, &amp;
<item>verifica a <strong>palavra-chave</strong> se não estiver entre "..." ou '...' (loop)
<item>expande <strong>alias</strong> se não estiver entre "..." ou '...' (loop)
<item>expande <strong>chaves</strong>, A{b|c} -> Ab Ac, se não estiver entre "..." ou '...'
<item>expande <strong>til</strong>, ~<var>user</var> -> $HOME/$USER, se não
  estiver entre "..." or '...'
<item>expande <strong>parâmetro</strong>, $<var>PARAMETER</var>, se não estiver entre '...'
<item>expande <strong>substituição de comando</strong>, $(<var>comando</var>),
  se não estiver entre '...'
<item>divide em <strong>palavras</strong> com $IFS se não estiver entre "..." ou '...'
<item>expande <strong>pathname</strong> *?[] se não estiver entre "..." ou '...'
<item>procura o <strong>comando</strong>
<list compact>
<item>função
<item>comando interno
<item>arquivo em $PATH
</list>
<item>loop
</list>
<p>
As aspas simples dentro de aspas duplas não têm efeito.

</sect1>

</sect>

<sect>Awk
<p>
Referências sobre o Awk:
<list compact>
<item><em>Effective awk Programming</em>, terceira edição (O'Reilly)
<item><em>Sed &amp; awk</em>, segunda edição (O'Reilly)
<item><manref name="mawk" section="1"> e <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
Programa de exemplo curto (cria entrada para o comando <prgn>newusers</prgn>):
<example>
#!/usr/bin/awk -f
# Script para criar um arquivo adequado para usar no comando 'newusers',
# a partir de um arquivo consistindo de identificações de usuários e senhas na forma:
# Prenome Sobrenome senha
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
         startuid = ARGV[1]
         delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
           "...where startUID is the starting userid " \
           "to add, and file is \n" \
           "an input file in form firstname last name password\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Starting UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
         user, passwd, uid, gid, first, last, user \
         )
}
</example>
<p>
Há dois pacotes que fornecem um <package>awk</package> POSIX no &debian;:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Prioridade: requerido
  <item>Tamanho instalado: 228
  <item>Menor e muito mais rápido &mdash; bom para instalação padrão
  <item>Existem limites na compilação
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Prioridade: opcional
  <item>Tamanho instalado: 1708
  <item>Maior e com muitos recursos &mdash; muitas extensões implementadas
  <list compact>
   <item>versão de UNIX System V Release 4
   <item>awk da Bell Labs
   <item>específico GNU
  </list>
 </list>
</list>
</sect>

<sect>Perl
<p>
Este é <strong>o</strong> interpretador em um sistema similar ao Unix.
<p>
Referências sobre o Perl:
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, terceira edição (O'Reilly)
</list>
<p>
Programa de exemplo curto (cria entrada para o comando <prgn>newusers</prgn>):
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Para instalar o módulo Perl <var>nome_módulo</var>:
<example>
# perl -MCPAN -e 'install <var>nome_módulo</var>'
</example>
 
</sect>

<sect>Python
<p>
Esse é um interpretador orientado a objeto muito bom.
<p>
Referências sobre o Python:
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
</list>
<p>
Programa de exemplo curto (cria entrada para o comando <prgn>newusers</prgn>):
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input file name. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirstname lastname password\n"
                 return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crashes with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>Make
<p>
Referências sobre o Make:
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, segunda edição (O'Reilly)
</list>
<p>
Variáveis automáticas simples:
<p>
Sintaxe de regra:
<example>
<var>Alvo</var>: [ <var>Pré-requisito</var> ... ]
 [TAB]  <var>comando1</var>
 [TAB]  -<var>comando2</var> # ignora erros
 [TAB]  @<var>comando3</var> # suprime o eco
</example>
Aqui, <tt>[TAB]</tt> é um código TAB.
Cada linha é interpretada pelo shell depois de fazer a substituição de variável. 
Use <tt>\</tt> no fim de uma linha para continuar o script.
Use <tt>$$</tt> para entrar <tt>$</tt> para valores de ambiente para um script shell.
<p>
Equivalentes de regras implícitas:
<example>
.c:   header.h == &percnt;  : &percnt;.c header.h
.o.c: header.h == &percnt;.c: &percnt;.o header.h
</example>
Variáveis automáticas para regras anteriores:
<example>
foo.o: new1.c new2.c old1.c new3.c
$@ == foo.o                         (objetivo)
$< == new1.c                        (o primeiro)
$? == new1.c new2.c new3.c          (os mais novos)
$^ == new1.c new2.c old1.c new3.c (todos)
$* == `&percnt;' padrão correspondente no padrão objetivo.
</example>
Referências variáveis:
<example>
foo1 := bar    # Expansão única
foo2  = bar    # Expansão recursiva
foo3 += bar    # Adiciona
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir diretorio/nomearquivo.ext) # Extrai "diretorio"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Execute <tt>make -p -f/dev/null</tt> para ver as regras internas automáticas. 
</sect>

<sect>C
<p>
Preparação:
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
Referências para o C:
<list compact>
<item><tt>info libc</tt> (referência de função da biblioteca C)
<item><manref name="gcc" section="1">
<item><manref name="nome_de_cada_função_da_biblioteca_C" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 
 segunda edição (Prentice Hall).
</list>
<p>

<sect1>Programa C simples (<prgn>gcc</prgn>)
<p>
Um exemplo simples para compilar <prgn>example.c</prgn> com uma biblioteca
<prgn>libm</prgn> em um executável <prgn>run_example</prgn>:
<example>
$ cat &gt; example.c 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* evita buffer overflow */
        y[10] = '\0'; /* preenche para ter certeza que string termina com '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}

$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
        1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
        2, 3.082, ./run_exam, 1234567890qwerty
</example>
Aqui, a opção <tt>-l<strong>m</strong></tt> é necessária para ligar a biblioteca
<tt>lib<strong>m</strong></tt> para o sqrt().  A biblioteca real está no
<file>/lib</file> com o nome de arquivo <file>libm.so.6</file>, que é um link
simbólico para o <file>libm-2.1.3.so</file>.
<p>
Veja o último parâmetro no texto de saída.  Há mais de 10 caracteres 
apesar de <tt>&percnt;10s</tt> ser especificado.  
<p>
O uso de funções que realizam operações de apontadores sem verificações de limite,
como o <prgn>sprintf</prgn> e o <prgn>strcpy</prgn>, está ultrapassado pois não
elas evitam as vulnerabilidades causadas por buffer overflow que leva aos efeitos
acima.  Ao invés disso, use <prgn>snprintf</prgn> e <prgn>strncpy</prgn>.
</sect1>

<sect1>Depurando

<sect2>Depurando com o <prgn>gdb</prgn>
<p>
Preparação:
<example>
# apt-get install gdb
</example>
<p>
Referências sobre o <prgn>gdb</prgn>:
<list compact>
<item><tt>info gdb</tt> (tutorial)
<item><manref name="gdb" section="1">
</list>
<p>
Use o <prgn>gdb</prgn> para depurar um programa compilado com a opção <tt>-g</tt>.  
Muitos comandos podem ser abreviados. A expansão de tab funciona como no shell.
<example>
$ gdb programa
(gdb) b 1                # define ponto de parada na linha 1
(gdb) run <var>arg1 arg2 arg3</var> # executa o programa
(gdb) next               # próxima linha
...
(gdb) step               # avança um passo
...
(gdb) p parm             # imprime parm 
...
(gdb) p parm=12          # define o valor para 12
</example>
<p>
Para depurar a partir do Emacs, consulte o <ref id="editkey">.
</sect2>

<sect2 id="ss-ldd">Verificar dependências de bibliotecas
<p>
Use o <prgn>ldd</prgn> para determinar as dependências de bibliotecas de um
programa: 
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
Para o <prgn>ls</prgn> funcionar em um ambiente usando <prgn>chroot</prgn>, as
bibliotecas acima precisam estar disponíveis no ambiente <prgn>chroot</prgn>.
<p>
Os seguintes comandos também serão úteis:
<list compact>
<item><prgn>strace</prgn>: rastrea chamadas de sistema e sinais
<item><prgn>ltrace</prgn>: rastrea chamadas de biblioteca
</list>
</sect2>
 
<sect2>Depurando com ferramentas de detecção de fuga de memória
<p>
Há várias ferramentas de detecção de fuga de memória disponíveis no &debian;.
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (não empacotado, obtenha-o em
 <url id="&memwatch-home;" name="GNU memwatch">.)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> da
  <url id="&parasofthome;" name="Parasoft">. (não livre, comercial)
</list>
<p>
Verifique também as <url id="&mallocdebughome;" 
  name="Ferramentas de Depuração para Alocação Dinâmica de Armazenamento e
  Gerenciamento de Memória">.

<sect1>Flex &ndash; um Lex melhor
<p>
O <prgn>flex</prgn> é um gerador de analisador léxico rápido.
<p>
Referências sobre o <prgn>flex</prgn>:
<list compact>
<item><tt>info flex</tt> (tutorial)
<item><manref name="flex" section="1">
</list>
<p>
Você precisa fornecer suas próprias funções <prgn>main()</prgn> e
<prgn>yywrap()</prgn>, ou seu <prgn>programa.l</prgn> deve parecer assim para
compilar sem uma biblioteca (<prgn>yywrap</prgn> é um macro; <tt>&percnt;option
main</tt> ativa <tt>&percnt;option noyywrap</tt> implicitamente):
<example>
&percnt;option main
&percnt;&percnt;
.|\n     ECHO ;
&percnt;&percnt;
</example>
Alternativamente, você pode compilar com a opção -<tt>lfl</tt> do ligador no fim
da sua linha de comando <prgn>cc</prgn> (como o ATT-Lex com <tt>-ll</tt>). Não é
necessário <tt>&percnt;option</tt> nesse caso.
</sect1>

<sect1>Bison &ndash; um Yacc melhor
<p>
Há alguns pacotes que fornecem um gerador de analisador LALR compatível com Yacc
no &debian;:
<p>
<list compact>
 <item><package>bison</package>: Gerador de analisador LALR  GNU
 <item><package>byacc</package>:  O gerador de analisador LALR Berkeley
 <item><package>byyacc</package>: Gerador de analisador reverso baseado no byacc
</list>
<p>
Referências sobre o <prgn>bison</prgn>:
<list compact>
<item><tt>info bison</tt> (tutorial)
<item><manref name="bison" section="1">
</list>
<p>
Você precisa fornecer suas próprias funções <prgn>main()</prgn> e <prgn>yyerror()</prgn>.
A função <prgn>main()</prgn> chama a <prgn>yyparse()</prgn> que chama a 
<prgn>yylex()</prgn>, geralmente criada com o FleX.
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
O <prgn>autoconf</prgn> é uma ferramenta para produzir scripts shell que
configuram automaticamente pacotes de código fonte de software para adaptá-lo às
muitas formas de sistemas similares ao UNIX usando o sistema de criação GNU
inteiro. 
<p>
O <prgn>autoconf</prgn> produz o script de configuração
<prgn>configure</prgn>. O <prgn>configure</prgn> cria automaticamente um
<prgn>Makefile</prgn> e um <prgn>Makefile.am</prgn> personalizados.
 
<sect2>Compilar e instalar um programa
<p>
O &debian; não mexe em arquivos no <file>/usr/local</file> (veja 
<ref id="diverse">). Então se você compilar um programa a partir da fonte,
instale-o no <file>/usr/local</file>, assim ele não interferirá com o &debian;.
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # isso coloca os arquivos no sistema
</example>

<sect2>Desinstalar um programa
<p>
Se você ainda tiver a fonte e o programa usar o
<prgn>autoconf</prgn>/<prgn>automake</prgn> e se você puder lembrar-se de como o
configurou:
<example>
$ ./configure <var>todas-as-opções-que-você-deu</var>
# make uninstall
</example>
<p>
Por outro lado, se você tem certeza absoluta de que o processo de instalação
põe arquivos somente sob o <file>/usr/local</file> e não há nada importante lá,
você pode apagar todo seu conteúdo com:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
Se você não tiver certeza de onde os arquivos foram instalados, deve pensar em
usar o <package>checkinstall</package> que fornece uma maneira limpa para a
desinstalação. 
</sect1>

</sect>

<sect>Preparação de documentos
<p>

<sect1>Processamento de texto <tt>roff</tt>
<p>
Tradicionalmente, o <tt>roff</tt> é o principal sistema de processamento de
 texto do Unix.
<p>
Veja <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7">, e
"<tt>info groff</tt>".
<p>
Há um bom tutorial sobre macros <prgn>-me</prgn>.
Se você tiver o groff (1.18 ou mais novo), encontre o <file>&f-meintro;</file> e
faça o seguinte:
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
O seguinte fará um arquivo texto completamente plano:
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
Para imprimir, use a saída PostScript.
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>




<sect1>SGML
<p>
Preparação:
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
Referências sobre o <prgn>debiandoc-sgml</prgn>:
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em>DocBook: The Definitive Guide</em>, por Walsh e Muellner (O'Reilly)
</list>
<p>
O SGML possibilita o gerenciamento de vários formatos de um documento. Um
sistema SGML fácil é o Debiandoc, que é usado aqui. Ele requer pequenas
adaptações dos arquivos texto originais para os seguintes caracteres:
<example>
&lt;   &amp;lt;
&gt;   &amp;gt;
"&nbsp;" "&amp;nbsp;"  (espaço inquebrável)
&amp;   &amp;amp;
&percnt;   &amp;percnt;
&copy;   &amp;copy;
&ndash;   &amp;ndash;
&mdash;   &amp;mdash;
</example>
Para marcar uma seção como um comentário não imprimível, entre:
<example>
&lt;!-- Indique o problema aqui ... --&gt;
</example>
Para marcar uma seção com um comentário alterável, entre:
<example>
&lt;![ &percnt;FIXME; [ Indique o problema aqui ... ]]&gt;
</example>
Em SGML, a <em>primeira definição</em> de uma entidade vence.  Por exemplo:
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Dado 1"&gt; ]]&gt;
&lt;!entity param "Dado 2"&gt;
&amp;param;
</example>
Isso finaliza como "Dado 1".  Se a primeira linha tiver "IGNORE" ao invés de
"INCLUDE", isso finaliza como "Dado 2" (a segunda linha é uma sentença
condicional). Além disso, a repetição de frases pode ser definida antes
separadamente do contexto.
<example>
&lt;!entity <var>quem-e-esse</var> "meu"&gt;
Olá &amp;<var>quem-e-esse</var>; amigo.
Esse é  &amp;<var>quem-e-esse</var>; livro.
</example>
Isso resulta no seguinte:
<example>
Olá meu amigo.
Esse é meu livro.
</example>
Veja o exemplo curto de SGML <file>sample.sgml</file> nos 
<url id="&examples;" name="exemplos">.
<p>
Quando os documentos SGML ficam maiores, algumas vezes o TeX pode causar erros.
Você precisa aumentar o tamanho do pool no <file>/etc/texmf/texmf.cnf</file> (ou
mais apropriadamente, edite o <file>/etc/texmf/texmf.d/95NonPath</file> e  
execute <prgn>update-texmf</prgn>) para resolver isso.
</sect>

<sect id="packaging">Empacotamento
<p>
Preparação:
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
        &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # se for Potato
</example>
Referências sobre empacotamento:
<list compact>
 <item><ref id="pkg-basics"> (básico)
 <item>Guia dos Novos Desenvolvedores Debian (tutorial)
 <item><manref name="dh-make" section="1">
 <item>Referência dos Desenvolvedores Debian (prática melhor)
 <item>Manual de Políticas Debian (oficial)
 <item>Manual de Empacotamento (Potato) 
</list>

<sect1 id="pack-binary">Empacotando um binário simples
<p>
Método curto e grosso para empacotar um binário simples de Joey Hess.
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mypackage
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: my little package
 Don't expect much.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">Empacotando com ferramentas
<p>
Use o <prgn>dh_make</prgn> do pacote <package>dh-make</package> para criar
um pacote inicial.  Então, continue de acordo com as instruções de <manref
name="dh-make" section="1">.
Ele usa o <prgn>debhelper</prgn> no <prgn>debian/rules</prgn>.
<p>
Uma alternativa mais antiga é usar o <prgn>deb-make</prgn> do pacote
<package>debmake</package>.  Ele não usa os scripts <prgn>debhelper</prgn>
e depende apenas do shell.
<p>
Se quiser exemplos de pacotes de várias fontes, veja o "mc" (<tt>dpkg-source -x
mc_4.5.54.dsc</tt>), que usa o "sys-build.mk" de Adam Heath
(<email>doogie@debian.org</email>), e a "glibc" (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>), que usa outro sistema do falecido Joel Klecker
(<email>espy@debian.org</email>).

</sect>

</chapt>
