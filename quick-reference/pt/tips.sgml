<!-- CVS revision of this document "$Revision: 1.2 $"  -->
<!-- CVS revision of the original english document "1.46" -->

<chapt id="tips"> Dicas &debian;


<sect>Iniciando o sistema
<p>
Consulte o <url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> do LDP
para obter informações detalhadas sobre o prompt de inicialização.

<sect1 id="crackroot">"Eu esqueci a senha do root !" (1)
<p>
É possível iniciar um sistema e logar com o conta do root sem conhecer a
senha do root se você tiver acessso ao teclado do console. (Isto assume
que não há requerimentos de senhas da BIOS e de um carregador de
inicialização como o <prgn>lilo</prgn> que o impediriam de iniciar o
sistema.)
<p>
Este é um procedimento que não requer  discos de inicialização externos
e nenhuma mudança nas configurações de inicialização. Aqui, "Linux" é o
<p>
Na tela de inicialização do <prgn>lilo</prgn>, assim que <tt>boot:</tt>
aparecer (você deve pressionar a tecla shift neste momento em alguns
sistemas para prevenir a inicialização automática), digite :
<example>
boot: Linux init=/bin/sh
</example>
Isso faz com que o sistema inicie o kernel e execute <file>/bin/sh</file>
ao invés de seu padrão <prgn>init</prgn>. Agora você ganhou privilégios de
root e um shell de root. Uma vez que o <file>/</file> estará atualmente
montado como somente-leitura e muitas partições de disco ainda não foram
montadas, você deve fazer o seguinte para conseguir um sistema
razoavelmente funcional.
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(Caso o segundo campo de dados em <file>/etc/passwd</file> seja "x" para
cada nome de usuário, seu sistema usa senhas shadow e você deve editar o
arquivo <file>/etc/shadow</file>.) Para desabilitar a senha do root, edite
o segundo campo de dados no arquivo de senhas de que maneira a deixá-lo
vazio. Agora o sistema pode ser reiniciado e você pode logar como root
sem uma senha. Quando inicia no nível de execução 1, o Debian (pelo menos
depois do Potato) requer uma senha, o que algumas distribuições mais
antigas não requerem.
<p>
É uma boa idéia ter um editor mínimo em <file>/bin</file> caso o
<file>/usr</file> não esteja acessível (consulte <ref id="bin-editor">).
<p>
Considere também instalar o pacote <package>sash</package>. Quando o
sistema ficar em um estado não-inicializável, execute :
<example>
boot: Linux init=/bin/sash
</example>
O <prgn>sash</prgn> funciona como um substituo interativo para o
<prgn>sh</prgn> mesmo quando o <file>/bin/sh</file> está inutilizável.
Ele é estaticamente ligado e inclui muitos utilitários padrão embutidos
(tecle "help" no prompt para uma lista de referência).
</sect1>

<sect1 id="crackroot2">"Eu esqueci a senha do root !" (2)
<p>
Inicie a partir de qualquer conjunto de disco de boot/root. Caso
<file><var>/dev/hda3</var></file> seja a partição raíz original, os
comandos a seguir irãp lhe permitir editar o arquivo de senhas tão
facilmente quanto da maneira citada acima.
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
A vantagem deste método em relação ao método anterior é que você não
precisa conhecer a senha do <prgn>lilo</prgn> (caso exista). Mas para usar
este método você deve ser capaz de acessar o setup da BIOS e permitir o
sistema iniciar a partir de um disquete ou de um CD, caso isto já não
esteja configurado.
</sect1>

<sect1 id="dead-lilo">Não posso iniciar o sistema
<p>
Sem problemas, mesmo caso  você não tenha se preocupado em criar um disco
de inicialização durante a instalação. Caso o <prgn>lilo</prgn> esteja
quebrado, pegue o disco de inicialização do conjunto de instalação Debian
e inicie seu sistema a partir do mesmo. No prompt de inicialização,
assumindo que a partição raíz de sua instalação Linux esteja em
<file><var>/dev/hda12</var></file> e você queira o nível de execução 3,
digite :
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
Você irá iniciar então em um sistema quase que complementamente funcional
usando o kernel no disquete. (Podem exisitir problemas menores devido a
falta de recursos ou módulos do kernel.)
<p>
Caso você precisa de um disquete de inicialização personalizado, siga as
instruções de <prgn>readme.txt</prgn> no disco de recuperação.
</sect1>

<sect1 id="no-x-start">"Deixe-me desabilitar o X na inicialização !"
<p>
Acompanhar a <tt>unstable/sid</tt> é divertido, mas o um <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn> e <prgn>wdm</prgn> iniciados durante
o processo de inicialização podem lhe deixar mal.
<p>
Primeiro obtenha o shell de root informando o seguinte no prompt de
inicialização :
<example>
boot: <var>Linux</var> vga=normal s
</example>
Aqui, <var>Linux</var> é o rótulo para a imagem de kernel através da qual
você está inicializando, "vga=normal" irá ceticar-se de que o lilo execute
em vídeo VGA comum e "s" (ou "S") é o parâmetro passado ao
<prgn>init</prgn> para inovar o modo monousuário. Informe a senha de root
no prompt.
<p>
Existem algumas maneiras de desabilitar todos os daemons X que iniciam :
<list>
<item>execute <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6</tt>
<item>insira "exit 0" no início de todos os arquivos <file>/etc/init.d/<var>?</var>dm</file>.
<item>renomeie todos os arquivos <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> para <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>remova todos os arquivos <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>.
<item>execute <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Aqui, <file>rc<var>2</var>.d</file> deve corresponder ao nível de execução
especificado em <file>/etc/inittab</file>. Também, 
<file><var>?</var>dm</file> significa todos os <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn> e <prgn>wdm</prgn>.
<p>
Somente o primeiro é "a verdadeira maneira" no &debian;. O último é fácil
mas funciona somente no &debian; e reuer que você configure-o novamente
posteriormente usando <prgn>dpkg-reconfigure</prgn>.
Os outros são métodos genéricos para desabilitar daemons.
<p>
Você ainda pode iniciar o X através do comando <prgn>startx</prgn> a
partir de qualquer console shell.
</sect1>

<sect1 id="bootprompt">Outros truques de inicialização com o prompt de inicialização
<p>
O sistema pode ser iniciado em um nível de execução e configuração
particulares usando o prompt de inicialização do <prgn>lilo</prgn>.
Detalhes são dados no 
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Caso você queira iniciar o sistema no nível de execução 4, use o
seguinte no prompt de inicialização do <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Caso você queira iniciar o sistema em modo monousuário funcionando
normalmente e você conhece a senha de root, um dos exemplos a seguir no
prompt de inicialização do <prgn>lilo</prgn> irão funcionar.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Caso você queira iniciar o sistema com uma quantidade de memória inferior
a quantidade de memória que o sistema possui fisicamente (digamos, 48MB
para um sistema com 64MB), use o seguinte no prompt de inicialização do
<prgn>lilo</prgn> :
<example>
boot: Linux mem=48M
</example>
Certifique-se de não especificar mais do que a quantidade de memória que
você possui fisicamente ou o kernel irá travar. Se você possui mais de
64MB de memória, por exemplo, 128MB, a menos que você inclua uma linha
adicional similar em <file>/etc/lilo.conf</file>, kernels antigos e/ou
placas-mãe com uma BIOS antiga não utilizarão a memória acima de 64MB.
</sect1>

<sect1 id="bootgrub">Como eu defino parâmetros de inicialização (GRUB)
<p>
O GRUB é um novo gerenciador de inicialização do projeto Hurd e é muito
mais flexível do que o Lilo, mas possui uma forma diferente de lidar com
os parâmetros de inicialização.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Aqui, você deve conhecer os nomes de dispositivos Hurd :
<example>
HURD/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,1)             /dev/hda1           C: (usually)
 (hd0,4)             /dev/hda4           F: (usually)
 (hd1,4)             /dev/hdb4           ?
</example>
Consulte <file>&f-grub;</file> e <file>&f-grub-doc;</file> para maiores detalhes.
</sect>

<sect>Gravando atividades

<sect1 id="script">Gravando atividades shell
<p>
Administração de sistema involve tarefas muito mais elaboradas em um
ambiente Unix do que em um computador pessoal comum. Certifique-se de
conhecer os meios mais básicos de configuração caso você precise recuperar
um sistema com problemas. Ferramentas de configuração baseados em X-Window
possuem uma boa aparência e são convenientes mas geralmente não podem ser
utilizadas neste tipo de situação.
<p>
Neste contexto, gravar atividades shell é uma boa prática, especialmente
como root.
<p>
Emacs: Use <tt>M-x shell</tt> para iniciar gravando em um buffer, e use
<tt>C-x C-w</tt> para gravar o conteúdo do buffer para um arquivo.
<p>
Shell: Use o comando <prgn>screen</prgn> com "^A H" como descrito em 
<ref id="screen"> ou o comando <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 ... faça qualquer coisa ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
O comando a seguir pode ser usado ao invés do <prgn>script</prgn> :
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>Gravando atividades no X
<p>
Caso você precise gravar a imagem gráfica de uma aplicação X, incluíndo
um display xterm, use o <prgn>gimp</prgn> (GUI).  Ele pode capturar cada
janela ou a tela toda. Alternativas são o <prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>) ou <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>


</sect>

<sect id="archiving">Copie e arquive um subdiretório inteiro
<sect1>Comandos básicos para copiar um subdiretório inteiro
<p>
Caso você precise rearranjar a estrutra de arquivos, mova o conteúdo
incluíndo ligações de arquivos usando :
<example>
Método padrão :
# cp -a /diretório/fonte /diretório/destino # requer o GNU cp
# (cd /diretório/fonte &amp;&amp; tar cf - . ) | \
        (cd /diretório/destino &amp;&amp; tar xvfp - )
Caso uma ligação direta esteja envolvida, um método pedântico é necessário :
# cd /caminho/para/diretório/antigo
# find . -depth -print0 | afio -p -xv -0a /ponto/montagem/do/novo/diretório
Caso remoto :
# (cd /diretório/fonte &amp;&amp; tar cf - . ) | \
        ssh usuário@máquina.domínio (cd /diretório/destino &amp;&amp; tar xvfp - )
Caso não existam arquivos ligados :
# scp -pr usuário1@máquina1.domínio:/diretório/fonte \
          usuário2@máquina2.domínio:/diretório/destino
</example>
Aqui, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> e <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
A comparação informativa a seguir sobre copiar um subdiretório inteiro
foi apresentada por Manoj Srivastava &lt;srivasta@debian.org&gt; na lista
de discussão debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Tradicionalmente, o <prgn>cp</prgn> não era um candidato para esta tarefa
uma vez que ele não desreferenciava ligações simbólicas ou preservava
ligações diretas. Outra coisa a considerar eram arquivos esparsos
(arquivos com buracos).
<p>
O <prgn>cp</prgn> GNU superou estas limitações; porém, em um sistema
não-GNU, o <prgn>cp</prgn> poderia continuar a ter problemas.
Adicionalmente, você não pode gerar arquivos pequenos e portáveis usando
o <prgn>cp</prgn>.
<example>
&percnt; cp -a . novodiretório
</example>

<sect1><prgn>tar</prgn>
<p>
O Tar superou alguns dos problemas que o <prgn>cp</prgn> tinha com
ligações simbólicas. Porém, apesar do <prgn>cpio</prgn> lidar com arquivos
especiais, o <prgn>tar</prgn> tradicional não o faz.
<p>								
Uma maneira <prgn>tar</prgn> de lidar com mútiplas ligações diretas para
um arquivo coloca somente uma cópia da ligação na fita, mas o nome anexado
a esta cópia é o <em>único</em> que você pode usar para recuperar o
arquivo; a maneira <prgn>cpio</prgn> como uma cópia para cada ligação, mas
você pode recuperá-lo usando quaisquer dos nomes.
<p>
O comando <prgn>tar</prgn> mudou sua opção para arquivos <file>.bz2</file>
entre o Potato e o Woody, portanto, use  <tt>--bzip2</tt> em scripts ao
invés de sua forma abreviada <tt>-I</tt> (Potato) ou <tt>-j</tt> (Woody).
</sect1>

<sect1><prgn>pax</prgn>
<p>
O novo cantante e dançante Utilitário de Troca de Arquivos Portável,
compatível com os padrões POSIX (IEEE Std 1003.2-1992, páginas
380&ndash;388 (seção 4.48) e páginas 936&ndash;940 (seção E.4.48)). O
<prgn>pax</prgn> irá ler, gravar e listar os membros de um arquivo e irá
copiar hierarquias de diretórios. A operação do <prgn>pax</prgn> é
independente do formato específico do arquivo e suporta uma grande
variedade de formatos de arquivo.
<p>
As implementções do <prgn>pax</prgn> ainda são novas e incompletas.
<example>
# apt-get install pax
$ pax -rw -p e . novodiretório
 ou
$ find . -depth  | pax -rw -p e  novodiretório
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
Copia arquivo em ou de um arquivo <prgn>cpio</prgn> ou <prgn>tar</prgn>.
O arquivo pode ser outro arquivo no disco, uma fita magnética ou um pipe.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd novo-diretório
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
O <prgn>afio</prgn> é uma maneira melhor de lidar com arquivo no formato
<prgn>cpio</prgn>. Ele é geralmente mais rápido do que o cpio, oferece
opções de fita magnética mais diversas e lida de maneira graciosa com
corrupção de dados de entrada. Ele suporta arquvo em múltiplos volumes
durante a operação interativa.
O <prgn>afio</prgn> pode criar arquivos comprimidos os quais são muito
mais seguros do que arquivo comprimidos <prgn>tar</prgn> ou
<prgn>cpio</prgn>. O <prgn>afio</prgn> é melhor usado como uma "engine
de arquivo" em um script de backup.
<example>
$ find . -depth -print0 | afio -px -0a novo-diretório
</example>
Todos os meus backups em fita utilizam o <prgn>afio</prgn>. 
</sect1>
</sect>

<sect id="diff-backup">Backups diferenciais e sincronização de dados
<p>
Backups diferenciais e sincronização de dados podem ser implementados
com diversos métodos :
<list>
<item><package>rcs</package>:  backup e histórico, somente texto
<item><package>rdiff-backup</package>:  backup e histórico. ligação simbólica OK.
<item><package>rsync</package>:  sincronização 1-way
<item><package>unison</package>:  sincronização 2-way
<item><package>cvs</package>:  sincronização multi-way com servidor backup
 e histórico, somente texto, maduro. Consulte <ref id="cvs">.
<item><package>arch</package>: sincronização multi-way com servidor backup
 e histórico, não existe algo como um "diretório de trabalho".
<item><package>subversion</package>: sincronização multi-way com servidor
 backup e histórico, Apache.
</list>
A combinação de um desses com o método descrito em 
<ref id="archiving"> é o job regular automatizado descrito em
<ref id="cronjob"> farão um bom sistema de backup.
<p>
Explicarei dois utilitários de fácil uso.

<sect1 id="rdiff-backup">Backup diferencial com rdiff
<p>
O <package>Rdiff-backup</package> oferece backup legal e simples para
quaisquer tipos de arquivos incluíndo ligações simbólicas. Para fazer
backup da maioria dos <file>~/</file> para <file>/mnt/backup</file>:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
Para restaurar dados de 3 dias atrás do arquivo para <file>~/old</file>:
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
Consulte <manref name="rdiff-backup" section="1">.
</sect1>

<sect1 id="backup">Backup diferencial regular com RCS
<p>
O <package>Changetrack</package> irá gravar regularmente as mudanças nos
arquivos de configurações baseados em texto em arquivos RCS. 
Consulte <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>Recuperação de sistema paralizado
<sect1>Matar um processo
<p>
Execute o <prgn>top</prgn> para ver qual processo é agindo de forma
engraçada. Pressione `P' para ordenar por uso de cpu, `M' para ordenar
por memória e `k' para matar um processo. Alternativamente, o comando
estilo BSD <tt>ps aux | less</tt> ou estilo System V <tt>ps -efH | less</tt>
podem ser usados. A sintaxe estilo System V exibe o IP <tt>PPID</tt> do
processo pai o qual pode ser usado para matar os filhos zumbis (defunct).
<p>
Use o <prgn>kill</prgn> para matar (ou enviar um sinal para) um processo
pelo ID do processo, <prgn>killall</prgn> para fazer o mesmo por nome de
comando do processo. Sinais frequentemente usados :
<example>
 1: HUP,  reinicia daemon
15: TERM, kill normal
 9: KILL, kill forçado
</example>

</sect1>

<sect1>ALT-SysRq
<p>
Garantia contra mal-funcionamento do sistema é fornecido pela opção de
compilação de kernel "Magic SysRq key".
Pressionar <tt>ALT-SysRq</tt> em um i386, seguido por uma das teclas
<tt>r 0 k e i s u b</tt>, faz a mágica.
<p>
Un`r'aw restaura o teclado após coisas como X travarem. Mudar o nível de
log do console para `0' reduz mensagens de erros. sa`k' (tecla de
administração de sistema) mata todos os processos no console virtual
atual. t`e'rminate mata todos os processos no terminal atual exceto o
init. k`i'll mata todos os processos exceto o init.
<p>
`S'ync, `u'mount e re`b'oot são para se livar de situaçãoes realmente
ruins.
<p>
Os kernels de instalação padrão Debian não são compilados com essa opção
no momento em que este documento é escrito. Recompile o kernel para ativar
esta função. Informações detalhadas pode ser encontrada em
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>
ou <file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>


<sect>Belos pequenos comandos para se lembrar

<sect1>Paginador
<p>
O <prgn>less</prgn> é o paginador (navgador de conteúdo de arquivo).
Pressione `h' para ajuda. Ele pode fazer muito mais do que do que o
<prgn>more</prgn>. O <prgn>less</prgn>  pode ser supercarregado executando
<tt>eval $(lesspipe)</tt> ou <tt>eval $(lessfile)</tt> no script de
inicialização do shell. Veja mais em <file>&f-lessopen;</file>. A opção
<tt>-R</tt> permite saída de caracteres raw e habilita sequência de escape
de cores ANSI. Consulte <manref name="less" section="1">.
<p>
O <prgn>w3m</prgn> pode ser um paginador alternativo útil para alguns
sistemas de códigos (EUC).

<sect1>Memória livre
<p>
O <prgn>free</prgn> e o <prgn>top</prgn> oferecem boa informação sobre
recursos do sistema. Não se preocupe sobre o tamanho de "used" na linha
"Mem:", e ao invés leia a abaixo dessa (38792 no exemplo abaixo).
<example>
$ free -k # para uma máquina de 256MB
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
A quantidade exata de memória física pode ser confirmada com o comando
<tt>grep '^Memory' /var/log/dmesg</tt>, o qual nesse caso exibe
"Memory: 256984k/262144k available (1652k kernel code, 412k reserved,
2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Aproximadamente 5MB de memória não pode ser usada pelo sistema devido ao
kernel utilizá-la.
</sect1>

<sect1>Definir a hora (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Isto irá definir a hora do sistema e de hardware para MM/DD hh:mm, CCYY.
Horas são exibidas em tempo local mas a hora de hardware usa UTC.

<sect1>Definir a hora (NTP)
<p>
Referência : <url id="&time-howto;" name="HOWTO Geranciando Data e Hora precisos">.
<p>
<sect2>Definir a hora com conexão Internet permanente
<p>
Definir o relógio do sistema para corrigir a hora automaticamente através
de um servidor remoto :
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>servidor</var>
</example>
É bom ter esse comando em <file>/etc/cron.daily</file> caso seu sistema
possua uma conexão Internet permanente.

<sect2>Definir a hora com uma conexão Internet esporádica
<p>
Use o pacote <package>chrony</package>.
</sect1>

<sect1>Como desabilitar a proteção de tela
<p>
No console Linux :
<example>
# setterm -powersave off
</example>
<p>
Inicie o console kon2(kanji) com :
<example>
# kon -SaveTime 0
</example>
<p>
Executando o X :
<example>
# xset s off
 ou
# xset -dpms
 ou
# xscreensaver-command -prefs
</example>
Leia as páginas de manual correspondentes.
</sect1>

<sect1 id="getent">Procurar na base de dados administrativa
<p>
A Glibc oferece o <manref name="getent" section="1"> para procurar
entradas na base de dados administrativas, por exemplo, passwd, group,
hosts, services, protocols ou networks.
<example compact>
getent base_de_dados [chave ...]
</example>

<sect1>Desabilitar o som (beep)
<p>
Sempre é possível desconetcra o alto-falante do PC ;-) Para o shell Bash :
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Mensagens de erro na tela do console
<p>
Para poder acabar com as mensagens de erro na tela, o primeiro lugar a
checar é <file>/etc/init.d/klogd</file>. Defina
<tt>KLOGD="-c <var>3</var>"</tt> nesse script e execute 
<tt>/etc/init.d/klogd restart</tt>. Um método alternativo é executar 
<tt>dmesg -n<var>3</var></tt>.
<p>
Aqui níveis de erro significam :
<list compact>
<item>0: KERN_EMERG,   sistema está inutilizável
<item>1: KERN_ALERT,   ação deve ser tomada imediatamente
<item>2: KERN_CRIT,    condições críticas
<item>3: KERN_ERR,     condições de erro
<item>4: KERN_WARNING, condições de aviso
<item>5: KERN_NOTICE,  normal mas em condições significantes
<item>6: KERN_INFO,    informacional
<item>7: KERN_DEBUG,   mensagens em nível de depuração
</list>
<p>
Caso uma mensagem de erro sem utilidade lhe incomode muito, considere
fazer um patch para o kernel trivial como o <file>shutup-abit-bp6</file>
(disponível no<url id="&examples;" name="subdiretório de exemplos">).
<p>
Outro lugar a olhar pode ser o <file>/etc/syslog.conf</file>; cheque-o
para ver se algum mensagem é logada para um dispositivo console.
</sect1>

<sect1>Definir o console para o tipo correto
<p>
Telas de console em sistema Unix-like são normalmente acessadas usando as
rotinas da biblioteca (n)curses. Estas fornecem ao usuário um método
independente de terminal para atualizar caracteres de tela com razoável
otimização. Consule <manref name="ncurses" section="3X"> e
<manref name="terminfo" section="5">.
<p>
Em um sistema &debian;, existem uma porção de entradas pré-definidas :
<example>
$ toe | less                  # todas as entradas
$ toe /etc/terminfo/ | less   # entradas reconfiguráveis pelo usuário
</example>
Exportar sua seleção como a variável de ambiente <tt>TERM</tt>.
<p>
Caso a entrada terminfo para o xterm não funcione com um xterm não-Debian,
mude seu tipo de terminal de "xterm" para uma das versões limitadas em
recursos como "xterm-r6" quando você logar em um sistema Debian
remotamente. Consulte <file>&f-libncurse;</file> para maiores informações.
"dumb" é o menor denominador comum para terminfo.
</sect1>

<sect1>Voltar o console novamente ao estador normal
<p>
Quando a tela fica cheia de caracteres estranhos depois de um comando
<tt>$ cat <var>algum-arquivo-binário</var></tt> (você pode não ser capaz
de ver o comando digitado enquanto você digita) :
<example>
$ reset
</example>
</sect1>

<sect1>Converte um arquivo texto DOS para o estilo Unix
<p>
Converter um arquivo texto DOS (fim-de-linha = <tt>^M^J</tt>) para um
arquivo texto Unix (fim-de-linha = <tt>^J</tt>).
<example>
# apt-get install sysutils
$ dos2unix <var>arquivo_dos</var>
</example>
</sect1>

<sect1>Substituição de expressões regulares
<p>
Substutua todas as instâncias de <var>DE_REGEX</var> por
<var>PARA_REGEX</var> em todos os arquivos <var>ARQUIVOS</var> ...:
<example>
$ perl -i -p -e 's/<var>DE_REGEX</var>/<var>PARA_REGEX</var>/g;' <var>ARQUIVOS</var> ...
</example>
<tt>-i</tt> é para edição "in-place", <tt>-p</tt> é para "loop implícito
sobre <var>ARQUIVOS</var> ...". Caso a substituição seja complexa, você
pode tornar a recuperação de erros mais fácil usando o parâmetro
<tt>-i.bak</tt> ao invés de <tt>-i</tt>; isso irá manter cada arquivo
original, adicionando <tt>.bak</tt> como uma extensão de arquivo.
</sect1>

<sect1>Extrair diferenças e juntar atualizações para os arquivos fonte
<p>
Seguir um dos procedimentos abaixo irá extrair as diferenças do arquivo
fonte e criar arquivos diff unificados <var>arquivo.patch0</var> ou
<var>arquivo.patch1</var> dependendo da localização do arquivo :
<example>
$ diff -u <var>arquivo.antigo</var> <var>arquivo.novo1</var> &gt; <var>arquivo.patch0</var>
$ diff -u <var>antigo/arquivo</var> <var>novo1/arquivo</var> &gt; <var>arquivo.patch1</var>
</example>
O arquivo diff (alternativamente chamado de arquivo patch) é usado para
enviar atualizações de programas. Recebendo parcialmente aplicará esta
atualização em outro <var>arquivo</var> usando :
<example>
$ patch -p0 <var>arquivo</var> &lt; <var>arquivo.patch0</var>
$ patch -p1 <var>arquivo</var> &lt; <var>arquivo.patch1</var>
</example>
Caso você possua todas as 3 versões dos códigos-fonte, você pode juntá-las
mais efetivamente usando o <prgn>diff3</prgn>:
<example>
$ diff3 -m <var>meu.arquivo</var> <var>arquivo.antigo</var> <var>seu.arquivo</var> &gt; <var>arquivo</var>
</example>
</sect1>

<sect1>Converter um arquivo grande em arquivos pequenos
<p>
<example>
$ split -b 650m <var>arquivo</var>   # divide o arquivo em pedaços de 650 MB
$ cat x* ><var>arquivogrande</var>   # junta arquivos em 1 grande arquivo
</example>
</sect1>

<sect1>Pequenos scripts para ligar comandos
<p>
Os scripts a seguir farão coisas legais como parte de um pipe.
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # encontra todos os arquivo em /usr excluíndo alguns arquivos
xargs -n 1 <var>comando</var>   # executa o comando para todos os itens de stdin
xargs -n 1 echo|     # divide itens separados-por-espaços-em-barnco em linhas
grep -e <var>padrão</var>|      # extrai linhas contendo <var>padrão</var>
cut -d: -f3 -|       # extrai o terceiro campo separado por :  
                     # (arquivo passwd, etc.)
col -bx |            # remove espaços em branco e expande tabs para espaços
expand -|            # expande tabs
sort -u|             # ordena e remove duplicados
tr '\n' ' '|         # concatena linhas em uma linha
tr '\r' ''|          # remove CR
tr 'A-Z' 'a-z'|      # converte maiúsculas em minúsculas
sed 's/^/# /'|       # torna cada linha um comentário
sed 's/\<var>.ext</var>//g'|    # remove <var>.ext</var>
sed  -n -e 2p|       # imprime a segunda linha 
head -n 2 -|         # imprime as primeiras 2 linhas
tail -n 2 -|         # imprime as últimas 2 linhas
</example>
</sect1>

<sect1>Obter texto ou arquivo de lista de discussão de uma página Web
<p>
O comando a seguir irá ler uma página Wb em um arquivo texto.
Muito útil quando copiando configurações da Web.
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>arquivotexto</var>
</example>
O <prgn>links</prgn> e o <prgn>w3m</prgn> podem ser usados aqui também,
com pequenas diferenças na renderização.
<p>
Caso esteja lidando com um arquivo de lista de discussão, use o
<prgn>munpack</prgn> para obter conteúdos mime do texto.
</sect1>

<sect1>Imprima de forma bonita uma página Web
<p>
O comando a seguir irá imprimir uma página Web em um arquivo/impressora
Postscript :
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Consulte <ref id="lprlpd">.  Confire também os pacotes <prgn>a2ps</prgn> e
<prgn>mpage</prgn> para criar arquivos Postscript.
</sect1>

<sect1>Imprima de forma bonita uma página de manual
<p>
O comando a seguir irá imprimir uma página de manual em um
arquivo/impressora Postscript :
<example>
$ man -Tps <var>alguma-página-de-manual</var> | lpr
$ man -Tps <var>alguma-página-de-manual</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Junte dois arquivos Postscript ou PDF
<p>
Você pode juntar arquivos Postscript ou PDF.
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>arquivo.ps</var> -f <var>arquivo1.ps</var> <var>arquivo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>arquivo.pdf</var> -f <var>arquivo1.pdf</var> <var>arquivo2.pdf</var>
</example>
</sect1>
 
<sect1>Conte o tempo de um comando
<p>
Exiba o tempo usado por um processo.
<example>
# time <var>algum-comando</var> &gt;/dev/null
real    0m0.035s       # conte no relógio de parede (tempo real decorrido)
user    0m0.000s       # conte em modo de usuário
sys     0m0.020s       # conte em modo kernel
</example>
</sect1>

<sect1>Comando <prgn>nice</prgn>
<p>
Use o <prgn>nice</prgn> (do pacote GNU <package>shellutils</package>) para
definir um valor de nice de um comando quando inciá-lo. O
<prgn>renice</prgn> (<package>bsdutils</package>) ou o <prgn>top</prgn>
pode fazer o renice de um processo. Um valor nice de 19 representa o
processo mais lento (a menor prioridade); valores negativos são
"não-nice", com -20 sendo um processo bem rápido (alta prioridade).
Somente o superusuário pode definir valores de nice negativos.
<example>
# nice  -19 <var>top</var>                                         # muito "nice"
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # muito rápido
</example>
Algumas vezes um valor de nice extermo traz mais problemas do que
melhorias para o sistema. Use esse comando com cuidado.
</sect1>

<sect1 id="cronjob">Agendar atividade (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Use o <prgn>cron</prgn> e o <prgn>at</prgn> para agendar tarefas sob o
Linux. Consulte <manref name="at" section="1">,
<manref name="crontab" section="5"> e <manref name="crontab" section="8">.
<p> 
Execute o comando <tt>crontab -e</tt> para criar ou editar um arquivo
crontab para configurar eventos regularmente agendados. Exemplo de um
arquivo crontab :
<example>
# use /bin/sh para executar comandos, não importando o que o /etc/passwd diga
SHELL=/bin/sh
# envie por mail qualquer saída para `paul', não importando de quem seja esse crontab
MAILTO=paul
# Min Hora DiaDoMês Mês DiaDaSemana comando (Dia... são OU)
# executa às 00:05, todos os dias
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# executa às 14:15 no primeiro dia de cada mês -- saída enviada para paul
15 14 1  * *   $HOME/bin/monthly
# executa às 22:00 em finas de semana(1-5), saída para Joe. &percnt; para nova linha, último &percnt; para cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Onde estão suas crianças?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "executa 23 minutos depois de 0am, 2am, 4am ..., em 1 de Fevereiro"
5  4 *   * sun echo "executa às 04:05 todo domingo"
# executa às 03:40 na primeira Segunda-feira de cada mês
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && comando -argumentos
</example>
Execute o comando <prgn>at</prgn> para agendar um job para ser executado
apenas uma vez :
<example>
$ echo '<var>comando -argumentos</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Mudança de console com <prgn>screen</prgn>
<p>
O programa <prgn>screen</prgn> lhe permite executar
<strong>múltiplos</strong> terminais virtuais, cada um com seu próprio
shell interativo, em um <strong>único</strong> terminal físico ou janela
de emulação de terminal. Mesmo caso você use consoles virtuais Linux ou
múltiplas janelas xterm, vale a pena explorar o <prgn>screen</prgn> devido
a seu abundante <strong>conjunto de recursos</strong>, os quais incluem
<list compact>
<item>histórico scrollback, 
<item>copiar-e-colar, 
<item>logging de saída, 
<item>entrada dígrafo e 
<item>a habilidade de <strong>detachar</strong> em sessão
<prgn>screen</prgn> inteira de seu terminal e reatachá-la posteriormente.
</list>

<sect2>Cenários de acesso remoto
<p>
Caso você frquentemente logue em uma máquina Linux de um terminal remoto
ou usando um programa de terminal VT100, o <prgn>screen</prgn> irá tornar
sua vida mais fácil com o recurso de <strong>detach</strong>.
<p>
<enumlist compact>
<item>Você está
logado através de uma conexão discada e está excutando uma sessão 
<prgn>screen</prgn> complexa com editores e outros programas abertos em
diversas janelas.
<item>Em certo momento você precisa deixar seu terminal, mas você não
quer perder seu trabalho desconectando.
<item>Simplesmente digite <tt>^A d</tt> para <strong>detachar</strong> a
sessão e então faça o logout. (Ou, ainda mais rápido, digitre
<tt>^A DD</tt> para fazer com que o <prgn>screen</prgn> detache e faça o
logout dele mesmo.) 
<item>Quando você logar novamente posteriormente, digite o comando
<tt>screen -r</tt> e o <prgn>screen</prgn> irá magicamente
<strong>reatachar</strong> todas as janelas que você deixou abertas. 
</enumlist>

<sect2>Comandos <prgn>screen</prgn> típicos
<p>
Uma vez que você inicia o <prgn>screen</prgn>, toda a entrada de teclado é
enviada para sua janela atual exceto as teclas de comando, por padrão
<tt>^A</tt>. Todos os comandos <prgn>screen</prgn> são informados
digitando <tt>^A</tt> mais uma única tecla [mais quaisquer parâmetros]. 
Comandos úteis :
<example>
^A ?     exibe uma tela de ajuda (exibe os mapeamentos de teclas)
^A c     cria uma nova janela e muda para ela
^A n     vai para a próxima janela
^A p     vai para a janela anteriorw
^A <var>0</var>     vai para a janela número <var>0</var>
^A w     exibe uma lista de janelas
^A a     envia um Ctrl-A para a janale atual como entrada de teclado
^A h     grava uma cópia "hard" da janela atual para arquivo 
^A H     inicia/finaliza logar a janela atual para arquivo
^A ^X    trava o terminal (protegido por senha)
^A d     detacha a sessão screen do terminal
^A DD    detacha a sessão screen e faz um logout
</example>
Isto é somente um pequeno subconjunto dos comandos e recursos do
<prgn>screen</prgn>. Caso exista alguma coisa que você queira que o
<prgn>screen</prgn> eja capaz de fazer, as chances são que que possa
fazê-lo ! Consulte <manref name="screen" section="1"> para maiores
detalhes.

<sect2>Backspace e/ou Ctrl-H em sessão <prgn>screen</prgn>
<p>
Se você achar que o backspace e/ou o Ctrl-H não funciona corretamente
quando você está executando o <prgn>screen</prgn>, edite
<file>/etc/screenrc</file>, encontre a linha contendo
<example compact>
bindkey -k kb stuff "\177"
</example>
e comente-a (ou seja, adicionei "#" como o primeiro caracter). 

<sect2>Programa equivalente ao <prgn>screen</prgn> para X
<p>
Confira o <prgn>xmove</prgn>.  Consulte <manref name="xmove" section="1">.

</sect1>

<sect1>Testes de rede básicos
<p>
Instale os pacotes
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (para kernel 2.2),
<package>iptables</package> (para kernel 2.4) e
<package>net-tools</package> e :
<example>
$ ping <var>yahoo.com</var>            # checa a conexão Internet
$ traceroute <var>yahoo.com</var>      # traça pacotes IP
$ ifconfig                  # checa configuração do host
$ route -n                  # checa configuração de roteamento
$ dig <var>[@servidor-dns.com] host.domínio [{a|mx|any}]</var> |less
      # checa os registros DNS de <var>host.domínio</var> usando <var>servidor-dns.com</var> 
      # para um registro a <var>{mx|any}</var>
$ ipchains  -L -n |less     # checa o filtro de pacotes (kernel 2.2)
$ iptables -L -n |less      # checa o filtro de pacotes (kernel 2.4)
$ netstat -a                # encontra todas as portas abertas
$ netstat -l --inet         # encontra as portas em escuta
$ netstat -ln --tcp         # encontra todas as portas TCP em escuta (numérico)
</example>
</sect1>

<sect1>Fazer flush em mensagens do spool local
<p>
Para fazer um flush das mensagens do spool local :
<example>
# exim -q    # faz flush em mensagens aguardando
# exim -qf   # faz flush em todas as mensagens
# exim -qff  # faz flush até mesmo em mensagens congeladas
</example>
<tt>-qff</tt> pode ser melhor como uma opção no script
<file>/etc/ppp/ip-up.d/exim</file>.
</sect1>

<sect1>Remover mensagens congeladas do spool local
<p>
Para remover mensagens congeladas do spool local com uma mensagem de erro
de entrega :
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Reentregar contéudo mbox
<p>
Você precisa entregar manualmente mensagens para caixas de mensagens
ordenadas caso seu diretório home fiquei lotado e o procmail falhe. Depois
de liberar espaço em disco no diretório home, execute :
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>nomedeusuário</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>Limpar contéudo de arquivo
<p>
Para limpar o conteúdo de um arquivo como um arquivo de log, não use o
<tt>rm</tt> para apagar o arquvo e então criar um novo arquivo vazio
porque o arquivo pode estar sendo acessado no intervalo entre os comandos.
O comando a seguir é uma maneira mais segura de limpar o conteúdo de um
arquivo :
<example>
$ :&gt;<var>file-to-be-cleared</var>
</example>
</sect1>

<sect1>Arquivo Dummy
<p>
Os comandos a seguir criarão arquivos dummy ou vazios :
<example>
$ dd if=/dev/zero    of=<var>nomedearquivo</var> bs=1k count=5 # 5KB de conteúdo zero
$ dd if=/dev/urandom of=<var>nomedearquivo</var> bs=1m count=7 # 7MB de conteúdo randômico
$ touch <var>nomedearquivo</var> #  cria arquivo de 0B (caso o arquivo exista, atualiza seu mtime)
</example>
</sect1>

<sect1><prgn>chroot</prgn>
<p>
Suponha que você tenha instalado um distribuição Linux inteira (esta pode
ser outra versão do &debian; ou até mesmo uma distribuição Red Hat) em
<file><var>/dev/hda1</var></file> e você está executando outro sistema
Linux instalado em <file><var>/dev/hda2</var></file>. Você pode executar o
sistema em <file><var>/dev/hda1</var></file> sem reiniciar o sistema em
execução em <file><var>/dev/hda2</var></file> compartilhando o mesmo
kernel.
<example>
# mount <var>/dev/hda1 /mnt/target</var>
 ... supondo que <var>/dev/hda1</var> contenha um sistema inteiro
# chroot /mnt/target
 ... Agora o conteúdo de <var>/dev/hda1</var> é visto como o diretório raíz.
# mount proc /proc              # só para se certificar
 ... execute os comandos dentro de <var>/dev/hda1</var>
</example>
Isto permite com que a as versões stable/testing/unstable do &debian;
sejam executada na mesma máquina. Adicionalmente, é possível executar um
programa que consuma muita memória como o <prgn>dselect</prgn>
executando-o em uma máquina host enquanto montando via NFS uma máquina
satélite para o host como leitura/gravação e apontando o
<prgn>chroot</prgn> para o sistema satélite.
<p>
Um sistema <prgn>chroot</prgn> pode ser facilmente criado pelo comando
<prgn>debootstrap</prgn> no Woody.
<example>
# mkdir <var>potatochroot</var>
# debootstrap potato <var>potatochroot</var>
# chroot <var>potatochroot</var>
# apt-setup # configura o /etc/apt/sources.list
</example>
<p>
Existe um pacote chroot mais especializado, o
<package>pbuilder</package>, que constrói um sistema chroot e compila um
pacote dentro do chroot. Esse é um sistema ideal para ser usado para
checar se as dependências de compliação de um pacote estão corretas e
para se certificar que dependências de compliação desnecessárias ou
incorretas não existirão no pacote gerado.
<p>
See <url id="&setup-chroot;">
</sect1>

<sect1>Como checar ligações diretas (hard)
<p>
Você pode checar se 2 arquivos são o mesmo arquivo com 2 ligações diretas
usando :
<example> 
$ ls -li <var>arquivo1</var> <var>arquivo2</var>
</example>
 
<sect1><prgn>mountar</prgn> arquivo de uma imagem de disco rígido
<p>
Se <file><var>arquivo.img</var></file> contém uma imagem de um disco
rígido e o disco rígido original possuía uma configuração de disco que
tinha <var>xxxx</var> = (bytes/sector) * (sectors/cylinder),
então o comando a seguir irá montá-la em <file>/mnt</file>:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>arquivo.img</var> /mnt
</example>
Note que a maioria dos discos rígidos possuem 512 bytes/sector.

<sect1>Samba
<p>
O básico para obter arquivos do Windows :
<example>
# mount -t smbfs -o <var>username=meunome,uid=my_uid,gid=my_gid</var> \
        <var>//servidor/compartilhamento /mnt/smb</var>  # monta arquivos para o Linux
# smbmount <var>//servidor/compartilhamento /mnt/smb</var> \
        -o "<var>username=meunome,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # lista os compartilhamentos em um computador
</example>
<p>
Vizinhos Samba podem ser checados a partir do Linux usando :
<example>
# smbclient -N -L <var>endereço_IP_de_seu_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

</sect>

</chapt>

