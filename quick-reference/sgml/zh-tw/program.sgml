<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.75" -->
<!-- DON't TOUCH GROFF SECTION!!! -->

<chapt id="program">程式設計
<p>
不要把測試用的執行檔名稱取成 "test" 。 <prgn>test</prgn> 是一個 shell 的內建指令。

<sect>從哪兒開始
<p>
參考資料：
<list compact>
<item>在 <file>&dochome;<var>package</var></file> 中的文件和範例
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
從 <url id="&gnuhome;" name="GNU"> 可以獲得更多可印成紙本的豐富文件。
<p>
接下來的四個小節包含了用不同程式語言所寫的簡單 script ，其功能是建立一個文字檔，其內容可提供給像 <prgn>newusers</prgn> 之類的批次執行程式來使用，其功能是用來加入 <file>/etc/passwd</file> 的帳號資料。每個 script 都需要一個輸入檔，其每行都是像 <tt>first_name last_name password</tt> 這樣的格式。 (這些 script 會建立實際的使用者 home 目錄。)
</sect>

<sect id="shell">Shell
<p>
了解 Unix-like 系統如何工作的<strong>最好</strong>方法就是閱讀 shell script。在此，我們對 shell 編程做個簡單的重點提示。從錯誤中學習，請參閱 <url id="&shell-mistakes;" name="Shell Mistakes"> 。

<sect1 id="bash">Bash &ndash; <strong>GNU</strong> 標準互動式 shell
<p>
Bash 的參考資料：
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>the LDP <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
是初學者的資訊來源。
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (安裝 <package>bash-doc</package> 套件可以看到更多的範例檔。)
<item><em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
</list>
<p>
簡短的程式範例 (從標準輸入讀取輸入，可提供 <prgn>newusers</prgn> 來建立帳號資訊) ：
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">POSIX shells
<p>
&debian; 中有幾個套件提供了 POSIX shell ：
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 176
  <item>目前為止最小而且最快的 &ndash; 用來開機初始的最佳選擇
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 180
  <item>較小並且較快的 &ndash; 用來開機初始的好選擇
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essential: yes
  <item>Priority: required
  <item>Installed-Size: 580
  <item>較大並且功能完整 &ndash; 實作了很多擴充功能
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 408
  <item>完整 AT&amp;T ksh 的外觀和風格
 </list>
</list>
<p>
如果你想編寫具有可攜性的 shell script ，最好能寫成 POSIX shell script。可將 <file>/bin/sh</file> 鏈接到 <prgn>ash</prgn> (或 <prgn>dash</prgn>) 來測試和 POSIX 的相容性。最好能避免寫出包含 "bashisms" 或 "zshisms" 的 script 。例如，應避免下面的用法：
<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>file</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>
<p>
在這份文件中的敘述只適用於 POSIX 的 shell ，而不適用於 <prgn>csh</prgn> 式的 shell ，包括 <prgn>tcsh</prgn> 。


<sect1 id="shell-param">Shell 參數
<p>
有幾個<strong>特別的參數</strong>是應該要記得的：
<example compact>
$0      = shell 的名稱或 shell script 的名稱
$1      = 第一個 shell 參數
 ...
$9      = 第九個 shell 參數
$#      = 參數的個數
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = 最近執行命令的退出狀態
$$      = 目前 shell script 的 PID
$!      = 最近啟動的背景執行工作的 PID
</example>
<p>
要記住的基本<strong>延伸參數</strong>：
<example compact>
    從           如果 <var>var</var> 設定的話    如果 <var>var</var> 沒有設定的話
${<var>var</var>:-<var>string</var>}  $<var>var</var>                <var>string</var>
${<var>var</var>:+<var>string</var>}  <var>string</var>              null
${<var>var</var>:=<var>string</var>}  $<var>var</var>                <var>string</var> 
                                    (並且執行 <var>var</var>=<var>string</var>)
${<var>var</var>:?<var>string</var>}  $<var>var</var>                (echo <var>string</var> and then exit)
</example>
在這裡，這些操作中的冒號 `:' 都是選擇性的。
<list compact>
<item>有 `:' = 操作中測試 "存在" 和 "非空" 。
<item>沒有 `:' = 操作中只測試 "存在" 。
</list>
<p>
需要記住的基本<strong>參數代換</strong>：
<example compact>
    從            結果
${<var>var</var>&percnt;<var>suffix</var>}   移除最小符合 <var>suffix</var> 的後綴形式
${<var>var</var>&percnt;&percnt;<var>suffix</var>}  移除最大符合 <var>suffix</var> 的後綴形式
${<var>var</var>#<var>prefix</var>}   移除最小符合 <var>prefix</var> 的前綴形式
${<var>var</var>##<var>prefix</var>}  移除最大符合 <var>prefix</var> 的前綴形式
</example>

<sect1 id="shell-redirect">Shell 重導 (redirection)
<p>
需要記住的基本<strong>重導 (redirection) </strong>用法 (在此 [<var>n</var>] 是可指定的數字，代表檔案描述子 (file descriptor))：
<example compact>
[<var>n</var>]&gt; <var>file</var>      將 stdout (或 <var>n</var>) 重導至 <var>file</var> 。
[<var>n</var>]&gt;&gt; <var>file</var>     將 stdout (或 <var>n</var>) 附加至 <var>file</var> 。
[<var>n</var>]&lt; <var>file</var>      由 <var>file</var> 重導至 stdin (或 <var>n</var>)。
[<var>n1</var>]&gt;&amp;<var>n2</var>       將 stdout (或 <var>n1</var>) 重導至 <var>n2</var> 。
2&gt; <var>file</var> &gt;&2    將 stdout 和 stderr 重導至 <var>file</var> 。
 &gt; <var>file</var> 2&gt;&1   將 stdout 和 stderr 重導至 <var>file</var> 。
| <var>command</var>      將 stdout 通過管線 (pipe) 傳遞給 <var>command</var>。
2&gt;&1 | <var>command</var> 將 stdout 和 stderr 通過 pipe 傳遞給 <var>command</var>。
</example>
在這裡，
<list compact>
<item>stdin: 標準輸入 (檔案描述子 = 0)
<item>stdout: 標準輸出 (檔案描述子 = 1)
<item>stderr: 標準錯誤 (檔案描述子 = 2)
</list>
<p>
shell 允許你用其內建的 <prgn>exec</prgn> ，以任意的檔案描述子來開啟檔案。
<example>
$ echo Hello &gt;foo
$ exec 3&lt;foo 4&gt;bar  # open files
$ cat &lt;&amp;3 &gt;&amp;4       # redirect stdin to 3, stdout to 4
$ exec 3&lt;&amp;- 4&gt;&amp;-    # close files
$ cat bar
Hello
</example>
在這裡的 <var>n</var><tt>&lt;&amp;-</tt> 和 <var>n</var><tt>&gt;&amp;-</tt> 是關閉檔案描述子 <var>n</var> 。


<sect1 id="shell-cond">Shell 條件式
<p>
每個命令均可回傳一個<strong>退出狀態</strong>，而這個狀態值可用於條件判斷式：
<list compact>
<item>成功： 0 (真值)
<item>錯誤： 1&ndash;255 (偽值)
</list>
注意此處的用法，回傳值 0 用來表示“真值，與計算機其它領域中常見的表示是不同的。另外 `[' 等同於使用 <prgn>test</prgn> 命令，並會將與 `]' 間的文字當成參數，所以相當於一個條件判斷式。
<p>
需要記住的基本<strong>條件式慣用法</strong>：
<example compact>
<var>command</var> && <var>"如果前指令成功的話，也要執行這個指令"</var> || true
<var>command</var> || <var>"如果前指令失敗的話，就執行這個指令"</var>

if [ <var>條件判斷式</var> ]; then  
 <var>"如果前指令成功的話，也要執行這個指令"</var>
else
 <var>"如果前指令失敗的話，就執行這個指令"</var>
fi
</example>
在這裡的 <tt>|| true</tt> 是需要的，以確保如果是用 <tt>-e</tt> 的選項在執行這行時，不會意外地結束程式。
<p>
在條件判斷式中的<strong>檔案</strong>比較有：
<example compact>
-e <var>file</var>         如果 <var>file</var> 存在則為真。
-d <var>file</var>         如果 <var>file</var> 存在且為一目錄則為真。
-f <var>file</var>         如果 <var>file</var> 存在且為一般檔案則為真。
-w <var>file</var>         如果 <var>file</var> 存在且可寫入則為真。
-x <var>file</var>         如果 <var>file</var> 存在且可執行則為真。
<var>file1</var> -nt <var>file2</var> 如果 <var>file1</var> 比 <var>file2</var> 新的話則為真。 (modification)
<var>file1</var> -ot <var>file2</var> 如果 <var>file1</var> 比 <var>file2</var> 舊的話則為真。 (modification)
<var>file1</var> -ef <var>file2</var> 如果兩者的 device 和 inode 號碼都相同則為真。
</example>
<p>
在條件判斷式中的<strong>字串</strong>比較有：
<example compact>
     -z <var>str</var>    如果 <var>str</var> 的長度是零則為真。
     -n <var>str</var>    如果 <var>str</var> 的長度非零則為真。
<var>str1</var> == <var>str2</var>   如果字串相等則為真。
<var>str1</var> =  <var>str2</var>   如果字串相等則為真。
    (為了嚴格遵守和 POSIX 相容性，應用 "==" 來取代 "=") 
<var>str1</var> != <var>str2</var>   如果字串不相等則為真。
<var>str1</var> &lt;  <var>str2</var>   如果 <var>str1</var> 的排列順序在 <var>str2</var> 之前則為真 (和 locale 相關) 。
<var>str1</var> &gt;  <var>str2</var>   如果 <var>str1</var> 的排列順序在 <var>str2</var> 之後則為真 (和 locale 相關) 。
</example>
<p>
在條件判斷式中的整數<strong>算術</strong>比較有 <tt>-eq</tt> 、 <tt>-ne</tt> 、 <tt>-lt</tt> 、 <tt>-le</tt> 、 <tt>-gt</tt> 和 <tt>-ge</tt> 。
</sect1>

<sect1 id="clprocess">命令列操作
<p>
Shell 會用下列的方法來處理 script ：
<list compact>
<item>以中介字元來切分 <strong>tokens</strong> ，有： SPACE 、 TAB 、 NEWLINE 、 ; 、 ( 、 ) 、 &lt; 、 &gt; 、 | 、 &amp 
<item>如果不在 "..." 或 '...' 內的話，會檢查<strong>關鍵字</strong> (loop)
<item>如果不在 "..." 或 '...' 內的話，會展開<strong>alias (別名)</strong> (loop)
<item>如果不在 "..." 或 '...' 內的話，會展開<strong>大括號</strong>， <tt>a{1,2}</tt> -> <tt>a1 a2</tt>
<item>如果不在 "..." 或 '...' 內的話，會展開<strong>tilde</strong> ， ~<var>user</var> -> <var>user</var> 的家目錄
<item>如果不在 '...' 內的話，會展開<strong>參數</strong>， $<var>PARAMETER</var>
<item>如果不在 '...' 內的話，會展開<strong>命令取代式</strong>， $(<var>command</var>)
<item>如果不在 "..." 或 '...' 內的話，會以 $IFS 來切分<strong>文字</strong>
<item>如果不在 "..." 或 '...' 內的話，會展開<strong>路徑名稱</strong>中的 *?[]  
<item>搜尋<strong>命令</strong>
<list compact>
<item>函式
<item>內建
<item>$PATH 中的檔案
</list>
<item>loop
</list>
<p>
在單引號中的雙引號是沒有作用的。
<p>
Executing <tt>set -x</tt> in the shell or invoking the shell with
<tt>-x</tt> option make the shell to print all of commands executed.
This is quite handy for debugging.
</sect1>

</sect>

<sect id="awk">Awk
<p>
Awk 的參考資料：
<list compact>
<item><em>Effective awk Programming</em>, 3rd edition (O'Reilly)
<item><em>Sed &amp; awk</em>, 2nd edition (O'Reilly)
<item><manref name="mawk" section="1"> 和 <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
簡短的程式範例 (從標準輸入讀取輸入，可提供 <prgn>newusers</prgn> 來建立帳號資訊) ：
<example>
#!/usr/bin/awk -f
# Script to create a file suitable for use in the 'newusers' command,
# from a file consisting of user IDs and passwords in the form:
# first_name last_name password
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
          "  where:\n" \ 
          "    startUID is the starting userid to add, and\n" \
          "    file is an input file in form:\n" \
          "      first_name last_name password\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Starting UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
在 &debian; 中提供 POSIX <package>awk</package> 的套件：
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priority: required
  <item>Installed-Size: 228
  <item>較小並且快得多 &mdash; 適合於預設安裝
  <item>Compile-time limits exist
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 1708
  <item>較大並且功能多 &mdash; 實作很多延伸功能
  <list compact>
   <item>System V Release 4 version of UNIX
   <item>Bell Labs awk
   <item>GNU-specific
  </list>
 </list>
</list>
</sect>

<sect id="perl">Perl
<p>
這是 Unix-like 環境中最重要的直譯器。
<p>
Perl 的參考資料：
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3rd edition (O'Reilly)
<item><url id="&perlhome;" name="The Perl Directory">
</list>
<p>
簡短的程式範例 (從標準輸入讀取輸入，可提供 <prgn>newusers</prgn> 來建立帳號資訊) ：
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
安裝 Perl 模組 (model) <var>module_name</var>:
<example>
# perl -MCPAN -e 'install <var>module_name</var>'
</example>
 
</sect>

<sect id="python">Python
<p>
這是一個不錯的物件導向直譯器
<p>
Python 的參考資料：
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
<item><url id="&pythonhome;" name="Python Programming Language">
</list>
<p>
簡短的程式範例 (從標準輸入讀取輸入，可提供 <prgn>newusers</prgn> 來建立帳號資訊) ：
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input filename. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirst_name last_name password\n"
                return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crashes with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect id="make">Make
<p>
Make 的參考資料：
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2nd edition (O'Reilly)
</list>
<p>
簡單自動變數：
<p>
規則 (rule) 的語法：
<example>
<var>target</var>: [ <var>prerequisites</var> ... ]
 [TAB]  <var>command1</var>
 [TAB]  -<var>command2</var> # 忽略錯誤
 [TAB]  @<var>command3</var> # 抑制 echo
</example>
這裡的 <tt>[TAB]</tt> 就是一個 TAB 。在 <prgn>make</prgn> 完成變數代換後，將會用 shell 逐行執行。在行尾使用 <tt>\</tt> 可以續行。使用 <tt>$$</tt> 可在 shell script 的環境中輸入 <tt>$</tt> 。
<p>
適用於 <var>target</var> 和 <var>prerequisites</var> 的<strong>隱含規則 (Implicit rules)</strong>，如下的例子：
<example>
&percnt;: &percnt;.c header.h
</example>
或，
<example>
&percnt;.o: &percnt;.c header.h
</example>
在此， <var>target</var> 包含了 <tt>&percnt;</tt> (exactly one of them)， <tt>&percnt;</tt> 可匹配實際的目標檔名中任何的非空子串。 <var>prerequisites</var> 同樣也使用 <tt>&percnt;</tt> 來顯示它們的名稱是如何關聯到實際的目標檔名的。
<p>
<strong>後綴規則 (Suffix rules)</strong> 是用來定義 <prgn>make</prgn> 隱含規則的<strong>過時</strong>方法。GNU <prgn>make</prgn> 為了相容性的考量仍支持它，但只要可能的話就應該使用與之等價的規則：
<example>
舊的後綴規則    --&gt; 新的規則
.c:             --&gt; &percnt;  : &percnt;.c
.c.o:           --&gt; &percnt;.o: &percnt;.c
</example>
規則中的自動變數：
<example>
foo.o: new1.c new2.c old1.c new3.c
$@ == foo.o                         (目標)
$< == new1.c                        (第一個)
$? == new1.c new2.c new3.c          (有更新的)
$^ == new1.c new2.c old1.c new3.c   (所有的)
$* == 在 target 中 `&percnt;' 所匹配的文字。
</example>
變數參考：
<example>
foo1 := bar    # 舊時的 expansion
foo2  = bar    # 遞迴的 expansion
foo3 += bar    # 附加
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # 取出 "directory"
 $(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
執行 <tt>make -p -f/dev/null</tt> 可查看內部自動規則。
</sect>

<sect id="c">C
<p>
準備工作：
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
C 的參考資料：
<list compact>
<item><tt>info libc</tt> (C 函式庫函式參考資料)
<item><manref name="gcc" section="1">
<item><manref name="each_C_library_function_name" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>,
 2nd edition (Prentice Hall). <url id="&kandr-c;">
<item>ISO C standard. <url id="&iso-c;">

</list>
<p>

<sect1>簡單的 C 程式 (<prgn>gcc</prgn>)
<p>
一個簡單的範例，將 <file>example.c</file> 和 <file>libm</file> 函式庫一起編譯，產生執行檔 <prgn>run_example</prgn> ：
<example>
$ cat &gt; example.c &lt;&lt; EOF
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* prevent buffer overflow */
        y[10] = '\0'; /* fill to make sure string ends with '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
        1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
        2, 3.082, ./run_exam, 1234567890qwerty
</example>
在這裡，因為用到了 <prgn>sqrt()</prgn> ，所以必需要用 <tt>-l<strong>m</strong></tt> 來連結 <file>lib<strong>m</strong></file> 函式庫。實際上的函式庫是位於 <file>/lib/</file> 中的 <file>libm.so.6</file> ，而這是個符號連結至 <file>libm-2.1.3.so</file> 。
<p>
請注意輸出文字的最後一個參數。即使已經指定了 <tt>&percnt;10s</tt> ，仍會超過 10 個字元。
<p>
不建議使用沒有邊界檢查的記憶體指標操作，如 <prgn>sprintf</prgn> 和 <prgn>strcpy</prgn> 。為預防暫存溢位的問題，請以 <prgn>snprintf</prgn> 和 <prgn>strncpy</prgn> 來取代。
</sect1>

<sect1>除錯

<sect2>用 <prgn>gdb</prgn> 來除錯
<p>
準備工作：
<example>
# apt-get install gdb
</example>
<p>
<prgn>gdb</prgn> 參考資料：
<list compact>
<item><tt>info gdb</tt> (tutorial)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>
<p>
使用 <prgn>gdb</prgn> 的 <tt>-g</tt> 選項可以用來除錯已編譯的程式。很多命令都可以縮寫。 Tab expansion 的功能和在 shell 時一樣。
<example>
$ gdb program
(gdb) b 1                # 在第一行設中斷點
(gdb) run <var>arg1 arg2 arg3</var> # 執行程式
(gdb) next               # 下一行
...
(gdb) step               # 單步前進
...
(gdb) p parm             # 印出 parm 
...
(gdb) p parm=12          # 設定其值為 12
</example>
<p>
在 Emacs 下做除錯的工作，請參閱 <ref id="editkey">。
<p>
由於編譯好的軟體會被拆解成數個套件安裝到 &debian; 系統，大部分的 debugging symbols 是被移除的。為了讓 <prgn>gdb</prgn> 能有效地除錯 &debian; 套件，相關的套件在重新編譯時需要注意下列項目：
<list compact>
<item>編輯 <file>debian/control</file> 來分解套件 
<url id="&policy-version;" name="version">. 
<item>檢查建立套件的 scripts 並使用 <tt>CFLAGS=-g -Wall</tt> 來編譯軟體。
<item>設定 <tt>DEB_BUILD_OPTIONS=nostrip,noopt</tt> 環境變數來建立 &debian; 套件。
</list>
請參閱 <url name="Policy 10.1" id="&strip-symbols;"> 了解更多資訊。
</sect2>

<sect2 id="ss-ldd">檢查函式庫相依關係
<p>
使用 <prgn>ldd</prgn> 可查看程式相依的函式庫：
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
所以在 <prgn>chroot</prgn> 的環境下要使用 <prgn>ls</prgn>，上列的函式庫在你的 <prgn>chroot</prgn> 的環境中都必需可用才行。
<p>
下面的命令也很有用：
<list compact>
<item><prgn>strace</prgn>: 追蹤系統呼叫和訊息 (signal)
<item><prgn>ltrace</prgn>: 追蹤函式庫呼叫
</list>
</sect2>
 
<sect2>用記憶體漏失偵測工具來進行除錯
<p>
&debian; 中有幾個記憶體漏失偵測工具。
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (沒有包成套件，可在 <url id="&memwatch-home;" name="memwatch"> 取得。)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> from <url id="&parasofthome;" name="Parasoft"> 。 (非自由軟體，商業用途要付費)
</list>
<p>
也可參閱 <url id="&mallocdebughome;" name="Debugging Tools for Dynamic Storage Allocation and Memory Management"> 。

<sect1>Flex &ndash; 更好的 Lex
<p>
<prgn>flex</prgn> 是一個快速的字詞分析產生器。
<p>
<prgn>flex</prgn> 的參考資料：
<list compact>
<item><tt>info flex</tt> (tutorial)
<item><manref name="flex" section="1">
</list>
<p>
需要提供你自己的 <prgn>main()</prgn> 和 <prgn>yywrap()</prgn> ，或者你的 <prgn>program.l</prgn> 在不用 library 時應該看起來看像這樣 (<prgn>yywrap</prgn>是一個巨集；<tt>&percnt;option main</tt> 隱含地打開了 <tt>&percnt;option noyywrap</tt>)：
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
另外，還可以在 <prgn>cc</prgn> 命令列末尾加上 <tt>-lfl</tt> 連接器的選項來進行編譯 (就像 AT&amp;T-Lex 使用 <tt>-ll</tt> 一樣)，此時就不需要 <tt>&percnt;option</tt> 了。
</sect1>

<sect1>Bison &ndash; 更好的 Yacc
<p>
&debian; 中有幾個套件提供了與 Yacc 兼容的 LALR 文法分析生成器：
<p>
<list compact>
 <item><package>bison</package>: GNU LALR 文法分析產生器
 <item><package>byacc</package>: The Berkeley LALR 文法分析產生器
 <item><package>btyacc</package>: Backtracking parser generator ，以 <package>byacc</package> 為基礎
</list>
<p>
<prgn>bison</prgn> 的參考資料：
<list compact>
<item><tt>info bison</tt> (tutorial)
<item><manref name="bison" section="1">
</list>
<p>
需要提供自己的 <prgn>main()</prgn> 和 <prgn>yyerror()</prgn> 。 <prgn>main()</prgn> 呼叫 <prgn>yyparse()</prgn> ，而 <prgn>yyparse()</prgn> 呼叫 <prgn>yylex()</prgn> ，通常由 FleX 建立。
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> 一個 shell script 生成工具，由它生成的 script 能自動設定軟體的源碼套件，以適用於各種使用完整 GNU build 系統的 UNIX-like 系統。
<p>
<prgn>autoconf</prgn> 會產生設定 script 的 <prgn>configure</prgn>。
<prgn>configure</prgn> 使用 <prgn>Makefile.in</prgn> 模版來自動建立適合的 <prgn>Makefile</prgn>。

<sect2>編譯和安裝程式
<p>
&debian; 不會改動 <file>/usr/local/</file> 下的文件 (參閱 <ref id="diverse">)。所以如果是從源碼來編譯程式，並將其安裝到 <file>/usr/local/</file> 下，就不會影響到 &debian;。
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # 這會把檔案放到系統中
</example>

<sect2>反安裝程式
<p>
如果你仍保有源碼，而且是用 <prgn>autoconf</prgn>/<prgn>automake</prgn> ，你也記得是如何進行設定的話：
<example>
$ ./configure <var>all-of-the-options-you-gave-it</var>
# make uninstall
</example>
<p>
另一種方法是，如果可以確定安裝過程將檔案都放在 <file>/usr/local/</file> ，並且該目錄下沒有什麼別的重要文件的話，可用下面的命令將其全部刪除：
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
如果不能確定文件安裝到什麼位置，最好使用 <package>checkinstall</package> ，可提供明確用來反安裝的路徑。
</sect1>

</sect>
<sect id="cgi">Web
<p>
基本的交談性動態網頁可以利用下列方式來實現：
<list compact>
<item>查詢(query)使用 HTML 格式呈現在使用者的瀏覽器上。
<item>填寫和點選網頁上的項目會送出編碼後的參數到網址。
<footnote>
這裡的 <tt>%nn</tt> 是將字元編碼成 16進位。
<tt>nn</tt>.
</footnote>
從瀏覽器到網頁伺服器的過程，例如：
<list compact>
<item><tt>http://www.foo.dom/cgi-bin/program.pl?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.foo.dom/cgi-bin/program.py?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.foo.dom/program.php?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
</list>
<item>網頁伺服器上的 CGI 程式 (任何形式的檔案 <prgn>program.*</prgn>) 會收到解碼後的參數 "<tt>VAR1=VAL1 VAR2=VAL2 VAR3=VAL3</tt>" 來當成環境變數 "<tt>QUERY_STRING</tt>" 並執行。
<item>CGI 程式的 <tt>stdout</tt> 將會送給使用者的瀏覽器以呈現出交談性的動態網頁。
</list>
為了安全性的考量，最好能避免手動分析這些 CGI 參數。有一些 Perl(參閱<ref id="perl">)和 Python(參閱<ref id="python">)能達成這些功能。<url id="&phphome;" name="PHP"> 已經內建這些函式。如果需要儲存 client 端的資料，請使用 cookies。處理 client 端的資料，通常是使用 javascript。
<p>
更多的資訊請閱讀 <url id="http://hoohoo.ncsa.uiuc.edu/cgi/" name="The Common
Gateway Interface">, <url id="&apachehome;" name="The Apache Software 
Foundation">, 和 <url id="&javascripthome;" name="JavaScript">。
<p>
在瀏覽器上利用已編碼的網址 <tt>&google-eg;</tt> 在 Google 上查詢 "CGI tutorial" 來查閱 CGI script 對於 Google 伺服器的處理是不錯的辦法喔。
<!--
http://www.google.com/search?hl=en&ie=UTF-8&q=CGI+tutorial
http://stein.cshl.org/WWW/CGI/
http://stein.cshl.org/WWW/docs/handout.html
http://stein.cshl.org/WWW/software/mailmerge/
-->

<sect id="doc-prep">文件準備
<p>

<sect1 id="roff"><tt>roff</tt> 排版
<p>
傳統上， <tt>roff</tt> 是主要的 Unix 文字處理系統。
<p>
參閱 <manref name="roff" section="7"> ，
<manref name="groff" section="7"> ，
<manref name="groff" section="1"> ，
<manref name="grotty" section="1"> ，
<manref name="troff" section="1"> ，
<manref name="groff_mdoc" section="7"> ，
<manref name="groff_man" section="7"> ，
<manref name="groff_ms" section="7"> ，
<manref name="groff_me" section="7"> ，
<manref name="groff_mm" section="7"> 和 <tt>info groff</tt> 。
<p>
在 <prgn>-me</prgn> 巨集中有份不錯的教程。如果你是用 <package>groff</package> (1.18 以上版本)，找到 <file>&f-meintro;</file> 並做下面的動作：
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
下面的作法將產生一份完整的純文字檔案：
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
如果要列印的話，就用 PostScript 輸出。
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>




<sect1 id="sgml">SGML
<p>
準備工作：
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
<package>debiandoc-sgml</package> 的參考資料：
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em><url name="DocBook: The Definitive Guide"
      id="&f-docbook-defguide;"></em>, by Walsh and Muellner, (O'Reilly)
      (package <package>&p-docbook-defguide;</package>)
</list>
<p>
SGML 能夠管理一份文件的多種格式。 Debiandoc 是個較簡單的 SGML 系統，本文件就是用它來編寫。只需將原本的文字檔對下列字元進行少許轉換：
<!-- nbsp bug in PDF ? -->
<list compact>
<item>"&lt;" --&gt; <tt>&amp;lt;</tt>
<item>"&gt;" --&gt; <tt>&amp;gt;</tt>
<item>"&nbsp;" --&gt; <tt>&amp;nbsp;</tt>  (不可斷行的空白)
<item>"&amp;" --&gt; <tt>&amp;amp;</tt>
<item>"&percnt;" --&gt; <tt>&amp;percnt;</tt>
<item>"(c)" --&gt; <tt>&amp;copy;</tt>
<item>"&ndash;" --&gt; <tt>&amp;ndash;</tt>
<item>"&mdash;" --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
要把一段文字變成不輸出的註解的話，請輸入：
<example>
&lt;!-- State issue here ... --&gt;
</example>
要把一段文字變成可選擇是否輸出的註解的話，請輸入：
<example>
&lt;![ &percnt;FIXME; [ State issue here ... ]]&gt;
</example>
在 SGML 中，只有<em>首次定義 (first definition) </em>是有效的。例如：
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
最後結果是 "Data 1" 。如果第一行是用 "IGNORE" 而不是 "INCLUDE" ，則結果是 "Data 2" (第二行是條件判斷式) 。而且，重覆出現的文字可提前在文件中定義。
<example>
&lt;!entity <var>whoisthis</var> "my"&gt;
Hello &amp;<var>whoisthis</var>; friend.
This is &amp;<var>whoisthis</var>; book.
</example>
結果如下：
<example>
Hello my friend.
This is my book.
</example>
可參閱 <url id="&examples;" name="examples"> 目錄中簡短的 SGML 範例文件 <file>sample.sgml</file> 。
<p>
當 SGML 文件不斷增大後，有時以 Tex 做為後端文字處理會出現問題，請參閱 <ref id="texlatex"> 。

<sect1 id="texlatex">TeX/LaTeX
<p>
事前準備：
<example>
# tasksel # 請選擇 Miscellaneous  --&gt; TeX/LaTeX environment
</example>
LaTeX 的參考手冊：
<list compact>
<item><url id="&tetex-howto;" name="The teTeX HOWTO: The Linux-teTeX Local Guide">
<item><manref name="tex" section="1">
<item><manref name="latex" section="1">
<item><em>The TeXbook</em>, by Donald E. Knuth, (Addison-Wesley)
      <footnote>
	可以到 <url id="&texbooksource;"> 取得書中的 Tex 原始碼。<url id="&texbookmacros;">內建大部分所必須的巨集。加入<tt>\input manmac \proofmodefalse</tt>來註解掉第七到第十的內容，就可以使用<prgn>tex</prgn>來編譯該文件了。
        <p>
	建議買下此書(以及 Donald E. Knuth 其他的書籍)來替代線上的版本，即使是 Tex 原碼對於 TeX 輸入是很棒的範例。
      </footnote>
<item><em>LaTeX - A Document Preparation System</em>, by Leslie Lamport,
      (Addison-Wesley)
<item><em>The LaTeX Companion</em>, by Goossens, Mittelbach, Samarin,
      (Addison-Wesley)
</list>
<p>
TeX 是一個強大的寫作環境。許多 SGML 處理程式使用它來當作後端文字處理器。<package>lyx</package>、<package>lyx-xforms</package>或<package>lyx-qt</package>內附的 Lyx 以及 GNU TeXmacs 內附的<package>texmacs</package>提供了相當不錯的 WYSIWYG 編輯環境。

使用者大多採用 Emacs 和 Vim 當作撰寫 LaTeX 原始碼的編輯器。
<p>
下列有許多線上參考資料：
<list compact>
<item><url id="&f-tetex-doc;" name="teTeX - A Documentation Guide">
      (<package>&p-tetex-doc;</package> package)
<!-- translators please add the following documents: 
1) "The Not So Short Introduction to LaTeX2e"
(&f-tetex-doc; links to an English copy on harddisk (slightly outdated))
There exist many translations (and MUCH more documents in ../):
ftp://ftp.dante.de/tex-archive/info/lshort/
2) ftp://ftp.dante.de/tex-archive/info/<your-language>

PS: I (Jens) don't like the following references (too short, external)
-->
<item><url id="&pfaffbenhome;" name="A Quick Introduction to LaTeX">
<item><url id="&latexlyx;" name="A Simple Guide to Latex/Lyx">
<item><url id="&latexbasic;" name="Word Processing Using LaTeX">
<item><url id="&local-guide;" name="Local User Guide to teTeX/LaTeX">
</list>
當文件越來越大時，編譯 TeX 有時候會出錯。使用者必須編輯<file>/etc/texmf/texmf.cnf</file> (或者適當地修改 <file>/etc/texmf/texmf.d/95NonPath</file>並執行<prgn>update-texmf</prgn>)加大 pool size 來修正該問題。

<sect1 id="literate">文學編程
<p>
和在編程時寫文件不同的，文學編程者是在寫文件時編程。這個方法確保程式有個良好的文件。
<p>
要對文學編程有更多了解，請參閱 <url id="&literatehome;" name="Literate Programming"> 。

<sect2 id="noweb">Noweb
<p>
準備工作：
<example>
# apt-get install nowebm
</example>
Noweb 的參考資料：
<list compact>
<item><url id="&nowebhome;" name="Noweb --- A Simple, Extensible Tool for Literate Programming">
<item><manref name="noweb" section="1">
</list>
<p>
這是個 WEB-like 的文學編程工具，可更容易地提供擴充性和與語言無關性，
<footnote>
This WEB has <strong>nothing</strong> to do with World Wide Web。WEB (用 PASCAL) 和 CWEB (用 C/C++) 是傳統的文學編程工具。
</footnote>
When <prgn>noweb</prgn> is invoked, it writes the program source code to
the output files mentioned in the noweb file, and it writes a TeX file
for typeset documentation.
<p>
&debian; 中的 <package>ifupdown</package> 套件是個好例子。
<example>
$ apt-get source ifupdown
$ cd ifupdown*
$ make ifupdown.pdf ifupdown.ps
</example>

<sect2 id="doxygen">Doxygen
<p>
準備工作：
<example>
# apt-get install doxygen doxygen-doc doxygen-gui
</example>
Doxygen 的參考資料 (也是用 <prgn>doxygen</prgn> 建立的！)：
<list compact>
<item><url id="&doxygenhome;" name="Homepage">
<item><url id="/usr/share/doc/doxygen-doc/html/index.html">
</list>
<p>
它可以由 C++ 、 C 、 Java 、 IDL 和一些 PHP 和 C# 程式產生 HTML 、 RTF 、 Unix manual pages 、 PostScript 和 PDF (使用 LaTeX) 文件。Doxygen 相容於 JavaDoc (1.1) 、 Qt-Doc 、 KDOC 並被特別設計為用在使用到 Troll Tech's <url id="&qthome;" name="Qt"> toolkit 的專案中。它可以建立 include 相依圖， 合作圖表，和圖型化的類別繼承圖，即使在沒有被文件化的程式。它的輸出是類似 Qt 的文件。

<sect id="packaging">包裝套件
<p>
準備工作：
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
                  &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # 如果是 Potato
</example>
包裝套件的參考資料：
<list compact>
 <item><ref id="pkg-basics"> (basics)
 <item>Debian New Maintainers' Guide (tutorial)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (best practice)
 <item>Debian Policy Manual (authoritative)
 <item>Packaging Manual (Potato) 
</list>

<sect1 id="pack-binary">包裝一個單一二進位套件
<p>
Joey Hess 的單一二進位套件快速粗糙的打包法：
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mypackage
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: my little package
 Don't expect much.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">使用工具來進行包裝工作
<p>
使用 <package>dh-make</package> 套件中的 <prgn>dh_make</prgn> 來建立一個基本的套件。接著按照 <manref name="dh-make" section="1"> 中描述的方法進行。會用到 <prgn>debian/rules</prgn> 中的 <prgn>debhelper</prgn> 。
<p>
一個較舊的方法是使用 <package>debmake</package> 套件中的 <prgn>deb-make</prgn> 。不需要 <prgn>debhelper</prgn> script，只需要 shell 就行了。但請不要再使用這樣的方法了。
<p>
有關多重源碼套件 (multiple-source) 的例子，參閱 "mc" （<tt>dpkg-source -x mc_4.5.54.dsc</tt>) ，其中用到 Adam Heath(<email>doogie@debian.org</email>) 的 "sys-build.mk" 以及 "glibc" (<tt>dpkg-source -x glibc_2.2.4-1.dsc</tt>) ，它使用到已故的 Joel Klecker(<email>espy@debian.org</email>) 所寫的另一個系統。
</sect>

</chapt>
