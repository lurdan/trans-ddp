<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.87"  -->
<chapt id="system">Debian 基礎

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
這一章節是針對非開發者說明 Debian 系統的原理。想要了解更細微詳盡的訊息，請參閱：
<p>
<list compact>
<item>Debian Policy Manual
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
<p>
</list>
以上文件均列在 <ref id="references">。

<p>
如果您在尋找比較淺顯易懂的 "how-to"，請直接跳到 <ref id="package"> 或其他相關的章節。
<p>
本節的寫作是基於 "Debian FAQ" 改寫，適合當作一般 Debian 系統管理者的起步文件。

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">Debian archives

<sect1 id="dirtree">目錄結構

<p>每個被包裝好的 &debian; 套件可以從其中一個 <url id="&mirror-site;" name="Debian mirror site"> 映射站台透過 FTP 或 HTTP 取得。

<p>以下的目錄皆可在 Debian 映射站台中的 <file>debian</file> 目錄找到：
<taglist>
  <tag><file>dists/</file>：
    <item>該目錄存放 "distributions"，主要是用來取得不同發行版本的套件。有些舊套件和<file>Contents-*.gz</file> 和 <file>Packages.gz</file> 仍然存放在這裡。
  <tag><file>pool/</file>：
    <item>所有 Debian releases 及 pre-releases 的套件的新的實體位址。
  <tag><file>tools/</file>：
    <item>建立開機片，分割硬碟，解/壓縮檔案，啟動 Linux 的 DOS 工具程式
  <tag><file>doc/</file>：
    <item>問與答，臭蟲回報等基本 Debian 文件。
  <tag><file>indices/</file>：
    <item>Maintainers file 和 override 檔案。
  <tag><file>project/</file>：
    <item>大多為開發者的資源，例如：
    <taglist>
      <tag><file>project/experimental/</file>：
        <item>該目錄存放的套件都是開發中且為 alpha 測試階段。使用者不應抓取這裡的套件，因為這些套件是危險且會對系統造成傷害。
      <tag><file>project/orphaned/</file>：
        <item>維護者不再維護且從發行版本移除的"孤兒"軟體放在該目錄。
    </taglist>
</taglist>

<sect1 id="dists">Debian distributions

<p>
<tt>stable</tt> distribution 套件的入口，&stabledebian;，被登記到 <file>stable</file> (符號鏈接指向 <file>&stablecodenamedir;/</file> 目錄)：

<sect1 id="stable"><tt>stable</tt> 發行版本

<p><tt>stable</tt>版本(&stabledebian;)的<file>stable</file>(連結到<file>&stablecodenamedir;/</file>)目錄下紀錄了不同的套件總件：
<list>
  <item><file>stable/main/</file>：
  該目錄包含了最近發行的 &debian; 系統的套件版本。

  <p>這些套件均遵循 <url name="Debian Free Software Guidelines (DFSG)" id="&social-contract;#guidelines"> (它位於 <file>&f-social-contract;</file> 需安裝 <package>&p-social-contract;</package>)，它們均可以自由使用和散布。

  <item><file>stable/non-free/</file>：
  經過 DFSG 的驗證而無法稱為 free 的套件皆放在該目錄下。  
  <p>
  例如，有些套件的許可證條款 (licenses) 禁止其用於商業的 distribution。有些雖可以再散布，但本身是共享套件而非自由套件。

  <item><file>stable/contrib/</file>：這部份的軟體本身是 DFSG-free 但由於某些原因使得必須依賴<strong>非</strong> DFSG-free 的軟體才能安裝使用。
</list>
除了上述的目錄外，目前的實體套件存在的路徑為 <file>pool</file> 目錄(<ref id="pools">)。

<p>現階段 <tt>stable</tt> 版本的臭蟲報告均列在 <url id="&stable-problems;" name="Stable Problems"> 網頁上。

<sect1 id="testing">The <tt>testing</tt> distribution

<p><tt>testing</tt> distribution 的套件入口，&testingdebian;，在 <tt>unstable</tt> 中通過某種程度的測試後會登記到 <file>testing</file> (符號鏈接指向 <file>&testingcodenamedir;/</file>) 目錄。目前的實體套件存在的路徑為 <file>pool</file> 目錄 (<ref id="pools">)。在 <file>testing/</file> 下同樣有 <file>main</file> ， <file>contrib</file> ，和 <file>non-free</file> 子目錄，它們的作用與 <file>stable/</file> 中的一樣。

<p>
這些套件必須可以同時運行於所有架構並且能正常安裝。比起在 <tt>unstable</tt> 中的對應版本，它們必需有更少的 release-critical 錯誤。這個種方式，我們將 <tt>testing</tt> 視為更接近發行的候選版本。有關 testing 機制的更多資訊請參閱 <url id="&testing-notes;">。

<p><tt>testing</tt> distribution 的最新消息發佈在下列站台：
<list compact>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="other bugs and bug-squashing party notes">
</list>

<sect1 id="unstable">The <tt>unstable</tt> distribution
<p>
<tt>unstable</tt> distribution 的套件入口，總是被命名為 "Sid"，被登記到 <file>unstable</file> (符號鏈接指向 <file>sid/</file>) 目錄，上傳至 Debian archive 的套件在被移至 <file>testing/</file> 前就一直放在這兒。目前的實體套件存在的路徑為 <file>pool</file> 目錄 (<ref id="pools">)。在 <file>unstable/</file> 下同樣有 <file>main</file> ， <file>contrib</file> 和 <file>non-free</file> 子目錄， 它們的作用與 <file>stable/</file> 中相同。

<p>
<tt>unstable</tt> distribution 反映了系統最新的開發進展。歡迎廣大用戶使用並測試這些套件，同時也提醒你們這些套件還不完善。使用 <tt>unstable</tt> distribution 的好處就是你可以獲得 &debian; 軟體專案 &mdash; 的最新更新，不過新東西也會出新問題，你得好壞兼收 :-)

<p><tt>unstable</tt> distribution 的最新臭蟲報告見於 <url id="&unstable-problems;" name="Unstable Problems"> 網頁上。

<!-- Above was enough
<sect1 id="sid">The Sid distribution

<p>Sid or <tt>unstable</tt> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <tt>testing</tt>,
in order to be released in <tt>stable</tt> later on. Sid contains packages
for both released and unreleased architectures.

<p>The name "Sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">The <tt>frozen</tt> distribution
<p>當 <tt>testing</tt> distribution 足夠成熟了，它便成為 frozen，表示這個版本不再加入新程式，只進行除錯工作。如果需要的話， <file>dists</file> 目錄中會建立新的 testing 目錄樹，並給予新的開發代號。 frozen distribution 再經過幾個月的測試、更新、再凍結也稱之為“循環測試”

<p>我們將 frozen distribution 中可能延遲套件或整個版本發佈的錯誤都記錄在案，一但錯誤總數低於可接受的最大值，frozen distribution 就晉升成 <tt>stable</tt>，而新版本發布了，前一個 stable distribution 成為過期版 (obsolete) （並被移至相對應的目錄）。

<sect1 id="codenames">Debian distribution 開發代號 (codenames)

<p>存在於 <file>dists</file> 目錄下的實體目錄名稱，例如 <file>&stablecodenamedir;/</file> 和 <file>&testingcodenamedir;/</file> ，就是 "開發代號 (codenames)"。當某個 &debian; distribution 處於開發階段，它並沒有版本號碼，取而代之的是開發代號。使用開發代號的目的在於簡化建立 &debian; distributions 映射站台的工作（例如 <file>unstable</file>的實體目錄突然改名為 <file>stable/</file> ，許多文件都沒必要再次下載）。

<p>現在，<tt>stable</tt> 是一個指向 <tt>&stablecodename;</tt> 的符號鏈接，<tt>testing</tt> 是指向 <tt>&testingcodename;</tt> 的符號鏈接。也就是說 <tt>&stablecodename;</tt> 是當前的 stable distribution， <tt>&testingcodename;</tt> 是當前的 testing distribution。

<p><file>unstable/</file> distribution 是指向 <file>sid/</file> 的永久符號鏈接，即 unstable distribution 總是稱為 Sid 。 <!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">已用過的開發代號

<p>已使用過的開發代號有：
"Buzz" 用在 release 1.1 ， 
"Rex" 用在 release 1.2 ， 
"Bo" 用在releases 1.3.x ， 
"Hamm" 用在 release 2.0 ， 
"Slink" 用在 release 2.1 ， 
"Potato" 用在 release 2.2 ， 
"Woody" 用在 release 3.0 和 
"Sarge" 用在 release 3.1 。

<sect1 id="sourceforcodenames">開發代號的來源

<p>到目前為止它們均出自 Pixar 的電影 <em>玩具總動員 (Toy Story)</em> 。
<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) 是個太空人，
  <item><strong>Rex</strong> 是隻暴龍，
  <item><strong>Bo</strong> (Bo Peep) 是個放羊的女孩，
  <item><strong>Hamm</strong> 是個小豬撲滿，
  <item><strong>Slink</strong> (Slinky Dog) 是隻玩具狗，
  <item><strong>Potato</strong> 當然就是 Potato Head 先生，
  <item><strong>Woody</strong> 是個牛仔，
  <item><strong>Sarge</strong> 是綠色塑膠玩具士兵的首領，
  <item><strong>Etch</strong> (Etch-a-Sketch) 是玩具黑板，
  <item><strong>Sid</strong> 是隔壁的男孩，那個玩具終結者。
</list>
<!--
  more info in http://www.pixar.com/featurefilms/ts/index.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools"><file>pool</file> 目錄

<p>過去，套件均放在 <file>dists</file> 目錄下相應的 distribution 子目錄中。這種做法產生了許多問題，例如映射站台進行新版本發佈時大量頻寬被消耗。

<p>現在套件均依原本的套件名稱分類放進一個巨大的池子 "pool"。為了方便管理， pool 目錄下按屬性再分類 (<tt>main</tt> ， <tt>contrib</tt> ，和 <tt>non-free</tt>)，分類下面再按原本的套件名稱的英文字首字母歸檔。這些目錄包含的文件有：運行於各種系統架構的二進位套件，和生成這些二進制套件的源碼套件。

<p>你可以執行命令 <tt>apt-cache showsrc <var>mypackagename</var></tt> ，查看 "Directory:" 行獲知每個套件的存放位置。例如：<package>apache</package> 套件存放在 <file>pool/main/a/apache/</file> 。因為 <tt>lib*</tt> 的套件數量龐大，它們以特殊的方式歸檔：例如，<package>libpaper</package> 套件存放在 <file>pool/main/libp/libpaper/</file>。

<p>諸如 <prgn>apt</prgn> 等命令訪問的索引文件仍位於 <file>dists</file> 目錄中。

<p>通常，你大可不必注意這些事情，新版的 <prgn>apt</prgn> 和舊版 <prgn>dpkg-ftp</prgn> 會自動處理它們。想了解更多資訊，參閱 <url id="&pool-faq;" name="RFC: implementation of package pools">。

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history"> sid 的歷史記錄

<p>過去 Sid 並不存在， Debian archive 組織有一個主要的工作流程：它假設當前 <tt>unstable</tt> 中建立了某個軟體開發項目，它會在整個 distribution 形成一個新的 <file>stable/</file> 時發佈。但是因為很多軟體不是用這個方式在開發，所以一但軟體要發佈時，就必需把整個目錄都搬移到 stable 下。因為在搬移目錄時會用掉大量的頻寬，所以這個流程就顯得很不切實際。

<!-- 翻譯沒把握 -->
<p>經過幾年的研究摸索，archive 管理員提出一個方案，將未發佈的二進位檔放在一個名為 <tt>sid</tt> 的特定目錄。當它們首次發布時，將會建立一個從目前 <tt>stable</tt> 指向 <tt>sid</tt> 的鏈接，從現在起，他們會建立在<file>unstable/</file>的目錄下。這個方案的確會使用者覺得困惑。

<p>有了套件 pool 的幫助（參閱 <ref id="pools">），在 <tt>woody</tt> distribution 開發過程中，二進位套件均按一定規範存放於 pool 目錄，而與 distribution 無關，當發佈新版本時，就不會再出現大量頻寬被消耗的問題。（不過，開發過程還是會用掉大量頻寬）。

<sect1 id="incoming">在 <file>incoming</file> 中的上傳套件
<p>
上載的套件在經確認它們是由 Debian 開發者上載的後，會先存放於 <url id="&incoming;"> （對於那些無維護者上載（Non-Maintainer Upload (NMU)）的套件則放入 <file>DELAYED</file> 子目錄）。會有一天，它們將從 <file>incoming/</file> 移入 <file>unstable/</file>。
<p>
在緊急情況下，你可能會等不及它們移入 <file>unstable/</file> 而直接從 <file>incoming.</file> 中下載安裝。
</sect1>

<sect1 id="snapshot">找回舊套件
<p>
最新的 Debian distribution 存放在任何一個 <url id="&mirror-site;" name="Debian mirror site"> 的 <file>debian</file> 目錄下。舊版本的 Debian 如 Slink 存放在 <url id="&archivehome;"> 或 Debian 映射站台的 <file>debian-archive</file> 目錄下。
<p>
舊的 <tt>testing</tt> 和 <tt>unstable</tt> 套件存放在 <url id="&snapshothome;">。
</sect1>

<sect1 id="archsections">Architecture sections
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>在每個主要目錄樹下（<file>dists/stable/main</file> 、 <file>dists/stable/contrib</file> 、 <file>dists/stable/non-free</file> 、 <file>dists/unstable/main</file> 等）按晶片架構又分了子目錄，每個子目錄中存放著在該晶片架構下編譯的二進位套件。

<list>
  <item><file>binary-all/</file>，存放與架構無關的套件，如 Perl script、純文件等。
  <item><file>binary-<var>platform</var>/</file>，存放運行於該平台的二進制套件。
</list>

<p>請注意，二進位套件不再存放在這些目錄中，而是放在最上層 <tt>pool</tt> 目錄中。但為了向下相容，所以在目錄中仍保留有索引文件（<file>Packages</file> 和 <file>Packages.gz</file>）。

<p>要獲得實際上的二進制架構技術支持，請參閱各發行版的發佈記錄（Release Notes）。它們放發佈記錄站台 <url id="&stable-release;" name="stable"> 和 <url id="&testing-release;" name="testing">。

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->


<sect1 id="source">源碼

<p>Debian 系統中包含了所有東西的源碼，不僅如此，許可證條款規定系統中所有的程式<strong>必須</strong>和其源碼一起發行，或提供源碼。

<p>通常源碼發佈在 <file>source</file> 目錄，該目錄同時處於所有特定平台的目錄中，或是把更新的源碼放在 <file>pool</file> 目錄中（參閱 <ref id="pools">）。對於不太熟悉 Debian archive 目錄結構的用戶，想獲得源碼可以試試 <tt>apt-get source <var>mypackagename</var></tt> 命令。

<p>有些套件，如著名的 <package>pine</package>，由於許可證限制，只提供源碼套件。（最近，<package>pine-tracker</package> 套件提供了一個簡易的安裝方式。）參閱 <ref id="port"> 和 <ref id="packaging"> 教你如何手動編建一個套件。

<p><file>contrib</file> 和 <file>non-free</file> 目錄中的套件可能不提供源碼，因為它們不算正式 Debian 系統的一部分。


<sect id="pkg-basics">Debian 套件管理系統


<sect1 id="package-basics">Debian 套件概觀

<p>套件通常包含了實現一系列相關命令或特性的所有必需的檔案。Debian 套件有兩種類型：
<list>
  <item><strong>Binary packages</strong>（二進位套件），它包含可執行檔、設定檔、 man/info 頁面、版權聲明和其它文件。這些套件以 Debian 特定的格式散佈（參閱 <ref id="deb-format">）；它們通常使用 <tt>.deb</tt> 的延伸檔名來散佈。這種二進位套件可使用 Debian 工具 <tt>dpkg</tt> 解開，詳情見相關的 manual 頁面。

  <item><strong>Source packages</strong>（源碼套件），其中包含一個 <tt>.dsc</tt> 檔用於描述源碼套件（包括下列檔案的名稱），一個 <tt>.orig.tar.gz</tt> 格式的檔案包含了原本未經修改的源碼，以及一個 <tt>.diff.gz</tt> 文件包含了該套件為了符合 Debian 格式對源碼所做的修改。<tt>dpkg-source</tt> 工具可用於包裝和解開 Debian 源碼套件，詳情可參閱相關 manual 頁面。
</list>

<p>使用套件管理系統來安裝套件時會用到由套件維護者建立的"相依資訊"。這些相依資訊記錄在每個套件的 <tt>control</tt> 文件中。例如，包含 GNU C 編譯器 (<package>gcc</package>) 的套件"相依"於包含連結器 (linker) 和組譯器 (assembler) 的 <package>binutils</package>套件。如果用戶試圖在沒有安裝 <package>binutils</package> 的情況下安裝 <package>gcc</package>，套件管理系統（dpkg）就會顯示錯誤信息，告訴你需要安裝 <package>binutils</package>，並停止安裝 <package>gcc</package> 。（不過，倔強的用戶可以對這個信息視而不見，參閱 <manref name="dpkg" section="8"> )。）更多資訊請參閱下面的 <ref id="depends"> 。

<p>Debian 套件管理工具可用來：
<list>
  <item>操作和管理套件或套件的局部內容，
  <item>分割套件以助於那些使用有限容量的儲存工具如軟碟傳輸的用戶，
  <item>幫助開發者打包套件，
  <item>幫助用戶從遠端 Debian archive 站台安裝套件。
</list>

<sect1 id="deb-format">Debian <!--binary--> 套件格式
<p>Debian 的"套件"，或是 Debian 保存壓縮檔 (archive) 包含了與特定程式或一組相關的程式有關的可執行檔，函式庫，和文件。通常，Debian 保存壓縮檔是以 <tt>.deb</tt> 做為結尾。
<footnote>
<!-- Below added by Osamu based on a message posted by Colin Watson -->
<p><prgn>debian-installer</prgn> 專案介紹了一種副檔名為 <tt>.udeb</tt> 的套件格式。簡單來說，它是一種簡化型<tt>.deb</tt>，因為不用遵循 Debian policy。沒有納入文件且只使用在 <prgn>debian-installer</prgn>，Debian installer一開始是針對 Sarge 發行而設計的。<tt>.deb</tt> 與 <tt>.udeb</tt> 檔案格式是相同的。<prgn>udpkg</prgn> 是用來處理 <tt>.udeb</tt> 套件，但功能上比 <prgn>dpkg</prgn> 要來的少且支援較少的相依資訊。兩者的差別在於 Debian 檔案維護者並不喜歡這些檔案庫裡的 <tt>.deb</tt>s 不遵循套件政策，所以才選擇不一樣的副檔名以免使用者不經意地安裝這些套件到系統上。<tt>.udeb</tt>s 是用在安裝系統時建立的限制型 Debian 的初始 ramdisk。

<tt>.udeb</tt>s
are used in an initial ramdisk during the base install only to create a
very restricted Debian system.
</footnote>

<p>Debian 二進制套件的格式說明請參閱 <manref name="deb" section="5"> 的說明文件。由於 deb 的內容是可變的(不同於各個主要 &debian; 版本)，所以請使用 <manref name="dpkg-deb" section="1"> 來控管 <tt>.deb</tt> 檔案。

<!-- Below added by Osamu Not sure but should be right -->

<p>至少從 Sarge 開始，所有的 Debian 套件檔皆可以透過傳統的 Unix 指令 <prgn>ar</prgn> 和 <prgn>tar</prgn> 來控制，即使是 <prgn>dpkg</prgn> 不存在也沒關係。

<sect1 id="pkgname">Debian 套件檔名的命名
<!--
Why are Debian package filenames so long? 
-->
<p>Debian <!--binary--> 套件檔案名稱是採用以下的規則來命名的：
<example>
<var>foo</var>_<var>ver</var>-<var>rev</var>_<var>arch</var>.deb
</example>
通常，<var>foo</var> 是套件名稱，
<var>ver</var> 是原作釋出的版本 (the upstream version number)，
<var>rev</var> 是 Debian 釋出的版本，以及
<var>arch</var> 是目的硬體架構。
檔案是很容易更改，這是當然的喔。
您可以執行以下指令來查詢該套件<var>檔案名稱</var>的資訊：
<example>dpkg --info <var>filename</var></example>

<p>Debian 釋出版本是由 Debian 開發者決定或製作該套件的人。
釋出版本的改變就表示套件有些許的變化。

<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">保留本機設定檔
<!--
What is a Debian conffile
-->
<p>
能被系統管理者修改的檔案都放在 <file>/etc/</file> 目錄下。
再升級套件時，&debian; 政策控制了所有的本機設定檔更新動作。
<p>
如果預設的設定檔是套件本身所有，則該檔案稱為 "conffile"。
從套件安裝後，如果 conffiles 曾被系統管理者修改過，則套件管理系統將不會更新這些 conffiles，除非系統管理者願意。換句話說，如果 conffile 都未曾修改，則在升級套件的同時也會一併更新 conffile。
對大部份的情況來說，這是值得期許的，因為方便降低 conffiles 的變更程度。

<p>要列出套件的 conffiles，請執行下述的指令：
<example>
dpkg --status <var>package</var>
</example>
檔案清單則列在 "Conffiles:" 這一行。

<p>
您可以閱讀 Debian Policy Manual 中的 "Configuration files" 部份來取得更多資訊。(參閱 <ref id="references">)

<sect1 id="maintscripts">Debian maintenance scripts
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian maintenance scripts 是一些在安裝前後自動執行的 scripts。連同 <file>control</file> 檔案，這些檔案是一個 Debian 檔案中的 "control" 段落的部份之一。

<p>各個檔案說明：
<taglist>
<tag/preinst/
  <item>該 script 在 Debian 壓縮檔 (<tt/.deb/) 被解開前才被執行。許多的 "preinst" scripts 將會停止服務直到套件升級或安裝完成 (完成之後，接下來就是 "postinst" script)。

<tag>postinst
  <item>該 script 用在 Debian 壓縮檔 (<tt>.deb</tt>) 被解開後完成設定套件的手續。"postinst" 通常用來等待使用者輸入或提醒使用者，假如他接受預設的設定值，記得重新設定套件。許多的 "postinst" scripts 負責在套件安裝或升級後重新啟動服務。

<tag>prerm
  <item>該 script 負責停止與套件關聯的daemon服務。它在刪除套件關聯的文件之前執行。 

<tag>postrm
  <item>該 script 負責修改套件連結或文件關聯或刪除由它建立的檔案。（參閱 <ref id="virtual">）。
</taglist>

<p>目前所有的 control 檔案可以在 <file>/var/lib/dpkg/info</file> 目錄下找到。這些檔案關聯於套件 <tt>foo</tt> 開頭名稱為 "foo" 以及擁有 "preinst", "postinst"...等延伸檔案。該目錄下的 <file>foo.list</file> 紀錄了套件 <tt>foo</tt> 安裝到系統上的所有檔案。(要注意的是這些檔案的位置是 <prgn>dpkg</prgn> 內部運作之一且易被改變的。)

<sect1 id="priority">套件的優先等級
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>每個Debian套件均被維護者指定了一個<strong>優先等級</strong>，作為套件管理系統的一個輔助參數，優先等級有：

<list>
  <item><strong>Required</strong>該級別套件是保証系統正常運作所必須的。
    <p>包含所有必要的系統修護工具。不要刪除這些套件，否則整個系統將受到損壞，甚至無法使用<prgn>dpkg</prgn>恢復。只安裝 Required 級別套件的系統不一定能滿足所有的用途，但它可以正常開機，讓系統管理者安裝想要的軟體。
  <item><strong>Important</strong> 在任何 Unix-like 系統上均安裝有該級別套件。
    <p>系統若缺少這類套件，將會運行困難或不好操作。該級別套件並<strong>不</strong>包括Emacs或X11或TeX或其它大型應用程式，它們只是一些實現系統底層功能的程式。
  <item><strong>Standard</strong> 該級別套件是任何Linux系統的標準，它們組成一個小而精的文字模式的系統。
    <p>系統預設安裝就包括了它們。"Standard" 級別套件不包括許多大型應用程式，但它包括 Emacs（它比其它應用程式更低階）和Tex及LaTeX的精巧版（不支援X）。
  <item><strong>Optional</strong> 該級別套件包括那些你可能想安裝的套件，即使對它們並不熟悉或沒有特定的需求。
    <p>它們包括X11，TeX完整發布版和許多應用程式。 
  <item><strong>Extra</strong> 該級別套件可能與其它較高級別套件衝突，僅當你知道其用途時才會使用它們，或者它們有特定的需求，這些都使它們不適合定為 "Optional" 級別。

</list>
<p>請注意套件描述中的 "Priority: required", "Section: base" and "Essential: yes" 這幾個的差異性。"Section: base" 是指該套件在建立新系統時一定要安裝的。大部份這類型的套件皆有 "required" 級別(Priority: required)或至少 "important" 級別(Priority: import)。且多數被標示成 "Essential: yes"。"Essential: yes" 是指套件管理系統在處理該套件時，必需加入額外的 "暴力" 參數，例如使用 <prgn>dpkg</prgn> 來移除這類型的套件。舉個例子，<package>libc6</package>, <package>mawk</package> 和 <package>makedev</package> 皆為 "Priority: required" 和 "Section: base" 但並非 "Essential: yes"。

<sect1 id="virtual">虛擬套件

<p>虛擬套件是一個統稱，指的一組具有相近功能的套件。舉個例子，<prgn>tin</prgn> 和 <prgn>trn</prgn> 都是新聞閱讀軟體，當系統中某個程式需要使用新聞閱讀器工作時就會產會一個關聯關係，它們必須滿足這個關聯，我們也稱之為它們提供了一個叫做 <package>news-reader</package> 的 "虛擬套件"。

<p>又像是，<package>exim</package>, <package>sendmail</package> 和 <package>postfix</package>都提供郵件傳輸代理的功能。也可稱之為提供 <package>mail-transport-agent</package> 虛擬套件。如果安裝了其中之一，那麼任何與 mail-transport-agent 有關聯的程式會因為這個虛擬套件的存在而滿足相依性。

<p>Debian 有個類似的機制，如果系統中提供相同的虛擬套件，系統管理員可以指定一個為首選軟體。相關的指令是 <prgn>update-alternatives</prgn>，更詳細的描述參閱 <ref id="alternatives">。

<sect1 id="depends">套件相依性
<p>Debian套件管理系統有一套套件“依賴性”定義（用一個標誌）用來描述套件需要安裝其他的軟體才能正常工作或作的更好。
<list>
  <item>套件 A<strong>依賴</strong>（depends）套件 B：要運行A必須安裝B。在有些情況下，A不僅依賴B，還要求B的特定版本。版本依賴通常有最低版限制，A更依賴於B的最新版而非某個特定版本。
  <item>套件 A<strong>推薦</strong>（recommends）套件B：套件維護者認為所有用戶都不會喜歡缺少某些功能的A，而這些功能需要B來提供。
  <item>套件 A<strong>建議</strong>（suggests）套件B：B中某些檔案與A的功能相關或<strong>加強</strong>A的功能。
  <item>套件A與套件B<strong>衝突</strong>（conflicts）：如果系統中安裝了B那麼A無法運行。“Conflicts”常和“replaces”同時出現。
  <item>套件A<strong>替換</strong>（replaces）套件B：B安裝的文件被A中的文件移除和覆蓋了。
  <item>套件A<strong>提供</strong>（provides）套件B：A中包含了B中的所有文件和功能。
</list>
<p>各個保留字使用方法的更詳細的訊息請參閱Packaging Manual和the Policy Manual。

<p>注意，<prgn>aptitude</prgn>和<prgn>dselect</prgn>可以對<strong>recommends</strong>和<strong>suggests</strong>類套件進行更細部的控制，<file>apt-get</file>只會簡單的下載安裝<strong>depends</strong>類套件而不管<strong>recommends</strong>和<strong>suggests</strong>>類套件。這兩個程式均正式使用APT作為後端程式。

<sect1 id="pre-depends">何為“pre-depends”
<p>“pre-depends”是一種特殊關聯關系。對於一個普通套件，不管系統中是否存在它的相依套件，<prgn>dpkg</prgn>都會將它解包。(解包主要指<prgn>dpkg</prgn>從套件中取出安裝文件並放到正確的位置)。如果套件 <strong>Pre-Depends</strong> 到其他套件，則這些被 Pre-Depends 的套件會要安裝比的套件先被解包和設定。

<footnote>
Debina提供這種機制是為了支援系統從<tt>a.out</tt>格式向ELF格式安全升級，在該過程中套件的解包<strong>順序</strong>攸關重要。對於某些重大升級這種機制也很有用。
</footnote>

這個相依性的用途是為了提供最小風險的升級。

<sect1 id="pkgstatus">套件狀態
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p>套件有各種狀態：“unknown”，“install”，“remove”，“purge”和“hold”。這些“希望” 標記描述了用戶打算如何操作這些套件（既可以使用<prgn>dselect</prgn>的 "Select"，也可以直接使用<prgn>dpkg</prgn>）。

<p>它們的意思是：
<list compact>
  <item><strong>unknown</strong>  - 用戶並沒描述他想對套件進行什麼操作。
  <item><strong>install</strong>  - 用戶希望對套件進行安裝或升級。
  <item><strong>remove</strong>   - 用戶希望刪除套件，但不想刪除任何設定檔。
  <item><strong>purge</strong>    - 用戶希望完全刪除套件，包括設定檔。
  <item><strong>hold</strong>     - 用戶希望套件保持現狀，例如，用戶希望保持當前的版本，當前的狀態，當前的一切。
</list>

<sect1 id="puttingonhold">阻止套件升級
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>有兩種方法阻止套件升級，使用<prgn>dpkg</prgn>，或者在Woody中使用APT。

<p>使用<prgn>dpkg</prgn>，首先導出套件選擇列表：
<example>
dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
接著編輯文件<file><var>selections.txt</var></file>，修改想要保留的軟體所在的行，例如<package>libc6</package>，則將：
<example>
libc6                       install
</example>
改成：
<example>
libc6                       hold
</example>
儲存設定，將它裝入<prgn>dpkg</prgn>資料庫：
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
或者，如果你知道要保留的套件名稱，執行：
<example>
echo libc6 hold | dpkg --set-selections
</example>
這個命令將在每個套件安裝過程中保持該套件不變。

<p>使用<prgn>dselect</prgn>也可以達到同樣的效果。進入[S]elect畫面，找到想阻止其升級的套件，按“=”鍵（或者“H”）。更改在你退出[S]elect畫面後立即生效。

<p>Woody中的APT系統有一個新機制來阻止套件升級，在下載升級檔進程中使用<tt>Pin-Priority</tt>。參閱幫助頁面<manref name="apt_preferences" section="5">，或閱讀<url id="&apt-howto;">或<package>&p-apt-howto;</package>套件。

<sect1 id="sourcepkgs">原始碼套件

<p>原始碼套件發布在<tt>source</tt>目錄中，既可以手動下載可以使用
<example>
apt-get source <var>foo</var>
</example>
來抓取它們（參閱<manref name="apt-get" section="8">幫助頁面）。

<sect1 id="sourcebuild">編譯原始碼套件

<p>對於<tt><var>foo</var></tt>套件，從原始碼編譯需要<file><var>foo_*</var>.dsc</file>、<file><var>foo_*</var>.tar.gz</file>和<file><var>foo_*.diff</var>.gz</file>檔案（注意，對於由Debian開發的套件，沒有<tt>.diff.gz</tt>檔案）。

<p>當你得全了這些檔案，如果你這安裝了<package>dpkg-dev</package>套件，執行：
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
它將套件解壓到一個名為<tt><var>foo-version</var></tt>的目錄。

<p>使用下列命令建立二進制套件：
<example>
$ cd foo-version
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
然後：
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
安裝新編譯的套件。參閱<ref id="port">。

<!-- Woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">新建Debian套件

<p>建立新套件的詳細訊息，參閱New Maintainers' Guide，該文檔在<package>maint-guide</package>套件中，或瀏覽<url id="&maint-guide;" name="&urlname;">。
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Debian系統升級

<p>Debian的設計目標之一就是提供一個一致的升級途徑和安全的升級過程，我們致力於舊版本的平順升級，套件在升級過程中會將重要訊息提醒管理者，並提供一個可能的解決方案。你也應該閱讀發布手記（Release Notes），該文檔描述了升級的詳細情況，它存在所有的Debian光碟中，也可以通過網站訪問<url id="&stable-release;">或<url id="&testing-release;">。

<p><ref id="package">提供了升級的實用指南，本節只作基礎細節的介紹。

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>它是操作套件檔案的主要工具；參閱<manref name="dpkg" section="8">獲得完整訊息。
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn>由幾個原始的輔助程式演化而來。

<list>
<item>dpkg-deb：控制<tt>.deb</tt>檔案。<manref name="dpkg-deb" section="1">
<item>dpkg-ftp：一個舊的套件取得命令。<manref name="dpkg-ftp" section="1">
<item>dpkg-mountable：一個舊的套件取得命令。<manref name="dpkg-mountable" section="1">
<item>dpkg-split：將大套件分割成小的檔案。<manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn>和<prgn>dpkg-mountable</prgn>已被新的APT系統取代。

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT（the Advanced Packaging Tool）是Debian套件管理系統的進階介面，由幾個名字以 "apt-" 開頭的程式組成。<prgn>apt-get</prgn>、<prgn>apt-cache</prgn>和<prgn>apt-cdrom</prgn>是處理套件的命令列工具，它們也是其它程式的後端程式，如<prgn>dselect</prgn>和<prgn>aptitude</prgn>。現在，<prgn>aptitude</prgn>是目前首選的系統管理工具。

<p>更多訊息，可安裝<package>apt</package>和<package>aptitude</package>套件後閱讀<manref name="aptitude" section="8">、
<manref name="apt-get" section="8">、
<manref name="apt-cache" section="8">、
<manref name="apt-cdrom" section="8">、
<manref name="apt.conf" section="5">、
<manref name="sources.list" section="5">、
<manref name="apt_preferences" section="5">。

<p>另一個資源是<url id="&apt-howto;" name="APT HOWTO">，如果安裝了<package>apt-howto</package>包，可在<file>&f-apt-howto;</file>中找到它。

<p><tt>apt-get upgrade</tt>和<tt>apt-get dist-upgrade</tt>只抓取"Depends"類套件，它忽略"Recommend"和"Suggests"類套件，不想這樣的話，可使用<prgn>dselect</prgn>。

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>這個程式是Debian套件管理系統中以選單驅動的用戶介面。特別適用於首次安裝和大幅度升級。參閱<ref id="dselect">。

<p>更多訊息，請參閱<url id="&dselect-beginner;" name="dselect Documentation for Beginners">。

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single-user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <prgn>start-stop-daemon</prgn> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">在運行中的系統升級

<p>&debian;系統的核心（文件系統）支持替換使用中文件。當升級新套件時如果該套件中包含daemon安裝，則會在該 RunLevel 設定好並重新啟動它們。Debian系統不需要切換到 single-user 模式就能升級運行中的系統了

<sect1 id="savedebs">下載和快取<tt>.deb</tt>檔案

<p>如果你手動下載套件到磁碟（這完全沒有必要，請閱讀上面有關<prgn>dpkg-ftp</prgn>或APT的內容），當你完成套件安裝工作後，可以從系統中刪除<tt>.deb</tt>檔案。

<p>如果是使用APT，這些文件會快取在<file>/var/cache/apt/archives/</file>目錄中。你可以在完成安裝後刪除它們（<tt>apt-get clean</tt>）或者將它們拷貝到另一個機器的<file>/var/cache/apt/archives/</file>目錄中以備以後的安裝。

<sect1 id="keepingalog">升級記錄

<p><prgn>dpkg</prgn>會對套件的解開、配置、刪除、完全刪除進行記錄，但不能（目前是這樣）記錄在套件操作的過程中終端機發生的事情。

<p>最簡單的解決方法是在執行<prgn>dpkg</prgn>、<prgn>dselect</prgn>、<prgn>apt-get</prgn>等工具的對話中加入<manref name="script" section="1">程式。

<sect id="boot">Debian 開機程序

<sect1 id="init"><prgn>init</prgn> 程式

<p>如同所有的Unix一樣，Debian啟動要執行init程式。<tt>init</tt>的設定檔（<tt>/etc/inittab</tt>）中指定的第一個執行 script 應該是<tt>/etc/init.d/rcS</tt>。

<p>而接下來的程序就看 <package>sysv-rc</package> 或 <package>file-rc</package> 套件的安排。假設 <package>sysv-rc</package> 已安裝了(<package>file-rc</package>包含自己的 <file>/etc/init.d/rcS</file> script 並使用該檔案取代 rc 目錄下的軟連結來控制那一個 RunLevel 該啟動那一個服務。)

<p><package>sysv-rc</package>套件中的  <file>/etc/init.d/rcS</file> 會執行 <file>/etc/rcS.d/</file> 所有的 script，為了進行初使化的動作，例如檢查和掛載檔案系統，載入模組，啟動網路服務，設定系統時間...等。然後，也會執行<file>/etc/rc.boot/</file>下的檔案(除了以 '.' 開頭的檔案)也確保相容性。後者的目錄通常是留給系統管理員使用的但並不是很贊成使用它。更多訊息參閱 Debian Policy 說明文件中的 <ref id="init-hints">和<url id="&sysvinit;" name="System run levels and init.d scripts">。

<p>Debian 不使用 BSD 風格的 <tt>rc.local</tt> 目錄。

<sect1 id="runlevels">Runlevels

<p>完成系統啟動進程後，<tt>init</tt>執行預設的 RunLevel。該 RunLevel 由<tt>/etc/inittab</tt>中的<tt>id</tt>指定。Debian 使用 <tt>id=2</tt>。
<p>Debian 使用以下的 RunLevel：
<list compact>
  <item>1（單人模式 single-user mode），
  <item>2（各種多人模式 multi-user modes），
  <item>0（關閉系統），
  <item>6（重啟系統）。
</list>
RunLevel 7, 8 和 9 也可以使用，但當套件安裝時，對應他們的 rc 目錄並不會產生。
<p>
<prgn>telinit</prgn>可用來切換 RunLevel。
<p>
當切換 RunLevel 時，<file>/etc/rc<var>runlevel</var>.d/</file>目錄下的 script 都會被執行。這些 script 檔名的第一個字母決定該 script 執行的方式：script 以 <tt>K</tt> 開頭的會夾帶 <tt>stop</tt> 參數執行。script 以 <tt>S</tt> 開頭的會夾帶 <tt>start</tt> 參數執行；script 以字母順序來執行，所以 "stop" 會提早 "start" scripts 執行，而跟隨 <tt>K</tt> 或 <tt>S</tt> 後的兩個數字決定這些 script 執行順序。
<p>
實際上，任意目錄<file>/etc/rc<var>runlevel</var>.d/</file>中的script都是指向<file>/etc/init.d/</file>的軟連結。這些 scripts 都接受參數"restart" and "force-reload"；後者是為了在系統開機後重新啟動服務或強迫他們重讀設定檔。

<p>例如：
<example>
# /etc/init.d/exim4 force-reload
</example>

<sect1 id="custombootscripts">自訂 RunLevel
<p>
自訂 RunLevel 是系統管理者工作。底下的建議適用大部份的服務。
Customizing runlevels is an advanced system administration task.
The following advice holds for most services.
<p>
加入<var>service</var>到 RunLevel <var>R</var>中的方法是建立<file>../init.d/<var>service</var></file>的軟連結在<file>/etc/rc<var>R</var>.d/S<var>xy</var><var>service</var></file>。<var>xy</var>數字必須該套件安裝時被指定的數字。
<p>
更改這個軟連結從開頭是<tt>S</tt>成<tt>K</tt>就能取消這個服務，而所填的數字是 100 減去 <var>xy</var>。
<p>
改用 RunLevel 編輯器 <prgn>sysv-rc-conf</prgn> 或 <prgn>ksysv</prgn>會是比較方便的辦法。
<p>
移除特定 RunLevel 目錄下的服務的 <tt>S</tt> 軟連結也是可行的辦法。這樣作並非取消該服務但卻變成一個"懸浮"狀態直到<package>sysv-rc</package>init 系統有關連到。更改 RunLevel 後，該服務並不會變成"啟動"或"關閉"的狀態，而是看它先前的設定來決定，不論現在是運行中或不是。注意，雖然該服務現在是 "懸浮" 狀態，但當它升級後就會啟動，不管在升級是否在運行或沒有。這是眾所皆知的 Debian 系統的缺點。注意，您也需要保留該服務的 RunLevel 0和6 的 <tt>K</tt>軟連結。
如果您刪除該服務所有的軟連結，再升級套件後會回復所有的軟連結到預設的狀態。
<p>
強烈建議不要更動<file>/etc/rcS.d/</file>中的任何軟連結。

<sect id="diverse">多樣性支援
<p>
Debian提供幾種途徑，在不破壞系統的前提下滿足系統管理員各種要求。
<list>
<item><prgn>dpkg-divert</prgn>，參閱<ref id="dpkg-divert">。
<item><prgn>equivs</prgn>，參閱<ref id="equivs">。
<item><prgn>update-alternative</prgn>，參閱<ref id="alternatives">。
<item><prgn>make-kpkg</prgn>可以支援多種啟動載入器。參閱<manref name="make-kpkg" section="1">和<ref id="kernel-compile">。 
</list>
<file>/usr/local/</file>目錄下的所有檔案均屬於系統管理者，&debian;不會更動它們。<file>/etc</file>下的大部分（或全部）檔案屬於<tt>conffiles</tt>，
<!-- mtab is an exception -->
&debian;不會在升級後覆蓋它們，除非系統管理員明確要求覆蓋。

<sect id="i18n">國際化
<p>
&debian;系統是國際化產品，不論是在主控台下還是在X下，它都提供多種語言的字元顯示和輸入支援。許多檔案、說明文件以及系統訊息都被翻譯成各種語言。在安裝過程中，Debian提示用戶選擇安裝語言（有時是當地語言的變異）。
<p>
如果你安裝的系統提供的語言特性支援不能滿足你的需要，或者你要改變當前語言或安裝別的鍵盤以適應你的語言，參閱<ref id="l10n">。

<sect id="kernel-details">Debian和系統核心
<p>
參閱 <ref id="kernel">。

<sect1 id="non-debian-kernel">編譯非 Debian 核心的原碼

<p><!--Yes.  But you have-->
首先你必須了解Debian policy並遵守標頭文件的規定。

<p>Debian C libraries是依據<strong>核心</strong>標頭文件最新<strong>stable</strong>發布版建立的。

<p>例如，Debian 1.2發布版使用版本號為5.4.13的頭文件。它基於所有Linux FTP檔案站點發布的Linux核心源碼包，這些源碼包使用了最新的標頭檔。跟隨核心源碼發布的核心標頭檔位於<file>/usr/include/linux/include/</file>。

<p>如果你編譯某個程序所用的核心標頭檔案比<package>libc6-dev</package>提供的標頭檔案還新，在編譯時你必須在命令行中加上<tt>-I/usr/src/linux/include/</tt>。這些情況是存在的，例如，對於automounter daemon（<package>amd</package>）套件而言，當新核心改變了對NFS的內部操作方式，<prgn>amd</prgn>需要知道這些改變。這時就需要引用新的核心標頭檔案。

<sect1 id="customkernel">自定核心建立工具

<p>對於希望（或必須）使用自定核心的用戶，推薦下載<package>kernel-package</package>套件。該套件包含了建立核心套件的 script。有了它，新建Debian核心套件只需在核心源碼的根目錄執行
<example>
# make-kpkg kernel_image
</example>
在核心源碼所在目錄的頂層，執行下述命令可獲得相關幫助
<example>
# make-kpkg --help
</example>
或閱讀<manref name="make-kpkg" section="1">幫助手冊以及<ref id="kernel">。

<p>如果所需的kernel-source-<var>version</var>（version代表核心版本號）套件不存在，用戶就得從Linux檔案站點分別下載最新的（或需要的）核心源碼。Debian的<file>initrd</file>啟動 script 需要一個專門的核心修正才能正確呼叫<prgn>initrd</prgn>；參閱<url id="&bug-initrd;">。

<p>有關<package>kernel-package</package>套件的用法詳述見於<tt>/usr/doc/kernel-package/README.gz</tt>。 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="modules">模組處理措施

<p>Debian的<package>modconf</package>套件提供了一個shell script（<file>/usr/sbin/modconf</file>），它可以用來自定核心模組設定。該 script 使用選單界面，用戶透過它給出系統中可掛載設備驅動的有關細節，它再將這些細節訊息生成<file>/etc/modules.conf</file>檔案（其中列出了別名aliases和其它參數，用於連接各種模組），該設定檔案用來掛載<file>/etc/modutils/</file>目錄下和<file>/etc/modules</file>（其中列出了需要在系統啟動時掛載的模組）目錄的相關模組。

<p>新版的<file>Configure.help</file>提供建立自定核心的步驟和幫助，同樣，<package>modconf</package>套件中也有一系列幫助檔案（位於<file>/usr/share/modconf/</file>目錄下），告訴你如何對模組設定合適的參數。

<sect1 id="removeoldkernel">移除舊版核心套件

<p><tt>kernel-image-<var>NNN</var>.prerm</tt>script 可用來檢查目前運行中的核心版本，以確定是否與你要移除的核心版本相同。因此你可以使用如下命令刪除不想要的核心套件：
<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

（當然，要將<var>NNN</var>替換成你的核心版本和修訂版本。）
</sect>
