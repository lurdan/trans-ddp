<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.119"  -->

<chapt id="tips"> &debian;技巧


<sect id="booting">啟動系統
<p>
參閱 LDP <url id="&bootprompt-howto;" name="BootPrompt-HOWTO">獲得有關系統提示的詳細資訊。

<sect1 id="crackroot">「我忘了root密碼！」(1)
<p>
只要能存取控制台 (console) 鍵盤，不需要 root 密碼就可以啟動系統登入到 root 帳號。（假設 BIOS 或 <prgn>lilo</prgn> 之類的啟動引導器在啟動時不需要密碼。）
<p>
整個過程不需要另外的開機軟碟或對 BIOS 設定進行修改。在此，「Linux」只有是一個標簽，它代表啟動 Debian 預設值安裝的 Linux 核心。
<p>
在 <prgn>lilo</prgn> 啟動螢幕中，一但出現<tt>boot:</tt>（對某些系統而言，必須按下shift鍵以阻止自動啟動以及當 <prgn>lilo</prgn> 使用 framebuffer 時，您必須按下 "TAB" 來查詢所輸入的參數），就輸入：
<example>
boot: Linux init=/bin/sh
</example>
它會指示系統啟動核心後執行 <file>/bin/sh</file> 而不是 <prgn>init</prgn>。現在你已獲得 root 特權和 root shell。由於目前的<file>/</file>是以唯讀方式掛載，而其它的硬碟分區均未掛載，故你必須完成下列步驟才能獲得一個有適當功\能的系統。
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
（如果在 <file>/etc/passwd</file> 檔案中所有使用者的第二個網域的資料為「x」，就表明系統使用了影子密碼，必隅虓編輯<file>/etc/shadow</file>。）要刪除root密碼，請編輯密碼檔案中第二個資料網域，將它設定為空白。重啟系統不用密碼就能登入到 root。當系統啟動進入 runlevel 1 時，Debian（至少是Potato以後的版本）需要密碼，一些較老的版本則不需要。
<p>
在 <file>/bin/</file> 下裝一個小編輯器是個好習慣，因為有時 <file>/usr</file> 是無法存取的（參閱<ref id="bin-editor">）。
<p>
如果安裝 <package>sash</package> 套服軟體，當系統無法啟動時，還可執行：
<example>
boot: Linux init=/bin/sash
</example>
當 <file>/bin/sh</file> 無法使用時，<prgn>sash</prgn> 可作為 <prgn>sh</prgn> 的交談式替代品，它是靜態連結，內建了許多標準工具（在系統提示符下輸入「help」可獲得參考清單）。
</sect1>

<sect1 id="crackroot2">「我忘了root密碼！」(2)
<p>
從急救 boot/root 磁碟啟動系統。假設 <file><var>/dev/hda3</var></file>
是原始 root 分區，可用下面的方法編輯密碼檔案，與上述方法一樣容易。
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
與上面的方法相比，該方法的好處在於不需要知道 <prgn>lilo</prgn> 
密碼（如果有的話）。但如果系統沒有預先設定為從軟式磁碟機或 CD 啟動，就需要存取
BIOS 的權限。
</sect1>

<sect1 id="dead-lilo">無法啟動系統
<p>
沒在安裝過程中製作開機軟碟？沒關係。如果 <prgn>lilo</prgn> 損壞了，從 
Debian 安裝套件中拿出開機軟碟，用它來啟動系統。假設你的 root 分割區在 
<file><var>/dev/hda12</var></file>，你想進入runlevel 3，在啟動提示符後輸入：
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
接下來，系統使用軟式磁碟機上的核心啟動，你可登入到一個幾乎擁有全部功\能的系統了。
（可能有少量特性或模組無法使用。）
<p>
如果系統已經崩潰，亦可參閱<ref id="un-bootable">。
<p>
如果想做張自訂開機軟碟，參閱急救磁碟 (rescue disk) 中的 
<file>readme.txt</file> 文件。
</sect1>

<sect1 id="no-x-start">「我不想直接啟動到 X！」
<p>
玩 <tt>unstable/sid</tt> 很有趣，但在啟動進程中執行不穩定的<prgn>xdm</prgn>、
<prgn>gdm</prgn>、<prgn>kdm</prgn>或<prgn>wdm</prgn>會讓你焦頭爛額。
<p>
首先，在啟動提示符後輸入如下指令獲得 root shell：
<example>
boot: <var>Linux</var> vga=normal s
</example>
其中，<var>Linux</var>代表你要啟動的核心對映，「vga=normal」告訴<prgn>lilo</prgn>在普通VGA螢幕下執行，「s」（或「S」）是傳給<prgn>init</prgn>的參數，告訴它進入單使用者模式。在提示符後輸入root密碼。
<p>
有多種方法禁用X啟動deaemons：
<list>
<item>run <tt>update-rc.d -f <var>?</var>dm remove</tt> ; <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6 .</tt>
<item>insert "exit 0" at the start of all <file>/etc/init.d/<var>?</var>dm</file> files.
<item>rename all <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> files to <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>remove all <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> files.
<item>run <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
其中，<file>rc<var>2</var>.d</file> 的檔案的編號必須與<file>/etc/inittab</file>中指定的runlevel一致。<file><var>?</var>dm</file>表示您需要多次執行這些命令來選擇<prgn>xdm</prgn>、<prgn>gdm</prgn>、<prgn>kdm</prgn>和<prgn>wdm</prgn>。
<p>
在Debian下只有第一種方法「最正確」。最後一種方法比較簡單但只適用於&debian;，而且還需要使用<prgn>dpkg-reconfigure</prgn>重新設定 display manager。其它方法都是通用的中止daemons的方法。
<p>
你仍可在任何控制台 (console) shell中輸入<prgn>startx</prgn>啟動 X。
</sect1>

<sect1 id="bootprompt">其它用於啟動提示的技巧
<p>
使用 <prgn>lilo</prgn> 啟動提示，可指定系統啟動到特定的 runlevel 和組態。
詳情參閱<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP)。
<p>
如果希望系統啟動到runlevel 4，可以<prgn>lilo</prgn>啟動提示後輸入：
<example>
boot: Linux 4
</example>
<p>
如果希望系統啟動到正常功\能的單使用者模式，而且你知道 root 密碼，可在 
<prgn>lilo</prgn>啟動提示後輸入下列任一參數。
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
如果希望系統以少於實際記憶體數的記憶體啟動（也就是說機器有 64MB 
記憶體，只分配 48MB 給系統使用），在<prgn>lilo</prgn>啟動提示符後輸入：
<example>
boot: Linux mem=48M
</example>
注意，不要指定大於實際記憶體數的記憶體，否則核心會崩潰。如果你有多於 
64MB 的記憶體，如 128MB ，應在系統啟動時執行 <tt>mem=128M</tt> 或在
<file>/etc/lilo.conf</file> 中添加類似的指令行，否則舊核心或使用舊 BIOS 
的主板將無法使用大於64MB的記憶體。
</sect1>

<sect1 id="bootgrub">設定 GRUB 啟動參數
<p>
GRUB 是 Hurd 計畫開發的新型啟動管理器，比 Lilo 更靈活，不過啟動參數也與之稍有不同。
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
請注意 Hurd 中的裝置名稱：
<example>
HURD/GRUB           Linux               MS-DOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,0)             /dev/hda1           C: (usually)
 (hd0,3)             /dev/hda4           F: (usually)
 (hd1,3)             /dev/hdb4           ?
</example>
詳情參閱 <file>&f-grub;</file> 和 <file>&f-grub-doc;</file>。
</sect>

<sect>活動記錄

<sect1 id="script">記錄shell活動
<p>
比起普通的個人電腦環境，Unix環境的系統管理包括了更多細致的工作。必須掌握所有基本的群組態方法以便進行系統故障恢復。基於X11的GUI群組態工具看上去又好又方便，但不適用於緊急狀況。
<p>
記錄 shell 活動是個好習慣，特別是 root 使用者。
<p>
Emacs：使用<tt>M-x shell</tt>在快取區中開始記錄，使用<tt>C-x C-w</tt>將快取區中的記錄寫入檔案。
<p>
Shell：使用<prgn>screen</prgn>指令和「^A H」，參閱<ref id="screen">或使用<prgn>script</prgn>指令：
<example>
$ script
Script started, file is typescript
 ... do whatever ...
 Ctrl-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
還可使用下面的方法：
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>記錄 X 操作
<p>
如果需要 X 套用程式的操作記錄圖，內含 <prgn>xterm</prgn> ，可使用<prgn>gimp</prgn>（GUI）。它可以對每個視窗或整個螢幕拍攝快照。還可以使用 <prgn>xwd</prgn>（<package>xbase-clients</package>）、<prgn>import</prgn>（<package>imagemagick</package>）和 <prgn>scrot</prgn>（<package>scrot</package>）。
</sect1>


</sect>

<sect id="archiving">拷貝及建立子目錄
<p>
這些複製和存檔指令提供了備份整個系統和檔案的基礎。<url id="&examples;" name="the example scripts"> 的 <prgn>backup</prgn> 指令為一個簡單的備份 scripit 範例。

<sect1>拷貝整個子目錄的基本指令
<p>
如果想重新整理檔案群組織結構，可使用下面的方法移動檔案及檔案連結：
<example>
標準方法：
# cp -a /source/directory /dest/directory # requires GNU cp
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
如果包括硬連結，則需要更嚴謹的方法：
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
如果是遠端操作：
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
如果沒有連結檔案：
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
<p>
下面的有關拷貝整個子目錄的訊息由 Manoj Srivastava<email>srivasta@debian.org</email> &lt;srivasta@debian.org&gt;發表於debian-user@lists.debian.org。
</sect1>

<sect1><prgn>cp</prgn>
<p>
傳統上，<prgn>cp</prgn>並不能真正完成這個工作，因為它既沒對符號連結進行區別對待，又不能儲存硬連結。另一件需要注意的事就是稀疏檔案（有洞的檔案）。
<p>
GNU <prgn>cp</prgn>克服了這缺陷，然而對於非 GNU 系統，<prgn>cp</prgn>仍存在問題。而且使用<prgn>cp</prgn>無法生成小巧輕便的文文件案包。
<example>
&percnt; cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
Tar 克服了<prgn>cp</prgn>在處理符號連結時出現的問題，然而，<prgn>cpio</prgn>可以處理特殊檔案，傳統的<prgn>tar</prgn>卻不行。
<p>                                                             
對於某個有多重硬連結的檔案，<prgn>tar</prgn>的處理方法是只將其中一個連結拷貝到磁帶上，所以日後你只能找回拷貝中所保留那個的連結所指的檔案；<prgn>cpio</prgn>會為每個連結做一個拷貝，日後你可以找回任意一個連結所指的檔案。
<p>
在 Potato 和 Woody 中，操作<file>.bz2</file>檔案的<prgn>tar</prgn>指令參數有所變化，所以請在script中使用<tt>--bzip2</tt>而不要簡寫為<tt>-I</tt>（Potato）或<tt>-j</tt>（Woody）。  
</sect1>

<sect1><prgn>pax</prgn>
<p>
全新的，符合POSIX（IEEE Std 1003.2-1992, pages 380&ndash;388 (section 4.48) and pages
936&ndash;940 (section E.4.48)）標準的，眾望所歸的，輕便的文文件案包交互工具。<prgn>pax</prgn>可以讀、寫以及列出文文件案包的成員，並能拷貝檔案目錄層次。<prgn>pax</prgn>的操作獨立於特定的文文件案包格式，支援各種各樣不同的文文件案包格式。
<p>
<prgn>pax</prgn>工具剛剛成形，還很新。
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 or
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn>從<prgn>cpio</prgn>或<prgn>tar</prgn>文文件案包提取/放入檔案。該文文件案包可以是硬碟上的另一個檔案，也可以是磁帶或管道。
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn>更善於處理<prgn>cpio</prgn>格式的文文件案包。通常它比<prgn>cpio</prgn>要快，且提供了更多磁帶選項，並且能更友好的處理有訛誤的輸入資料。它支援交談式處理多卷文文件案包。用<prgn>afio</prgn>製作壓縮文文件案包比壓縮<prgn>tar</prgn>或<prgn>cpio</prgn>文文件案包更安全。在備份處理script中<prgn>afio</prgn>是更佳的「文文件案處理引擎」。
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
對所有的磁帶備份我都使用<prgn>afio</prgn>。
</sect1>
</sect>

<sect id="diff-backup">差異備份與資料同步
<p>
要進行差異備份和資料同步可使用下列幾種方法：
<list>
<item><package>rcs</package>：備份並進行歷史記錄，只支援文本。
<item><package>rdiff-backup</package>：備份並進行歷史記錄。支援連結。
<item><package>pdumpfs</package>：對檔案系統進行備份和歷史記錄。支援連結。
<item><package>rsync</package>：單路同步。
<item><package>unison</package>：雙路同步。
<item><package>cvs</package>：多路同步伺服器備份並進行歷史記錄，只支援文本，技術成熟。參閱<ref id="cvs">。
<item><package>arch</package>：多路同步伺服器備份並進行歷史記錄，但內含「處於工作中的目錄」。
<item><package>subversion</package>：多路同步伺服器備份並進行歷史記錄，專用於Apache。 
</list>
有關將這些方法與文文件案包操作結合套用的討論參閱<ref id="archiving">，有關自動進行備份的討論參閱<ref id="cronjob">。
<p>
我只講解三個較容易使用的工具。

<sect1 id="rdiff-backup">使用rdiff進行差異備份
<p>
<package>rdiff-backup</package>提供了簡單好用的方法對任何檔案內含連結進行歷史差異備份。例如要對<file>~/</file>目錄下的所有檔案備份到<file>/mnt/backup</file>：
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
從該文文件案包中取出三天前的舊資料恢復到<file>~/old</file>目錄：
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
參閱<manref name="rdiff-backup" section="1">。

<sect1 id="pdumpfs-backup">使用<package>pdumpfs</package>進行每日備份
<p>
<package>pdumpfs</package>是一種簡單的每日備份系統，與Plan9的<prgn>dumpfs</prgn>一樣，它每天都儲存系統快照。任何時候都可以用它來恢復到某天的系統狀態。請使用<prgn>pdumpfs</prgn>和<prgn>cron</prgn>來備份你的home目錄。
<p>
在目的地目錄中，<prgn>pdumpfs</prgn>以<tt>YYYY/MM/DD</tt>的方式建立系統快照。第一次執行時，它將所有來來源檔案拷貝到快照目錄。從每二次執行起，<prgn>pdumpfs</prgn>只有拷貝更新的或開新檔案的檔案，對於沒有改變的檔案用硬連結方式指向前一天的系統快照，以此來節省硬碟空間。
<example>
$ pdumpfs <var>src-dir</var> <var>dest-dir</var> [<var>dest-basename</var>]
</example>
See <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">使用 RCS 進行定期差異備份
<p>
<package>Changetrack</package>會定期對 RCS 文文件案包中基於文本格式的群組態檔案的變化進行記錄。參閱<manref name="changetrack" section="1">。
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>

<sect>系統凍結恢復
<sect1 id="kill">中止一個進程
<p>
執行<prgn>top</prgn>看看什麼進程的活動有異常。按「P」以CPU使用率排序，「M」以記憶體使用率排序，「k」可以中止一個進程。還有一種方法，使用 BSD 風格的<tt>ps aux | less</tt>或 System-V 風格的<tt>ps -efH | less</tt>。System V 風格的排列會顯示父進程 ID 
<tt>PPID</tt>，這對中止發生錯誤的（死掉的）子進程十分有用。
<p>
知道了進程的 ID ，就可使用<prgn>kill</prgn>中止（或發信號給）某個進程，<prgn>killall</prgn>的作用正如其名一樣。經常使用的信號有：
<example>
 1: HUP，重啟daemon
15: TERM，普通中止
 9: KILL，強令中止
</example>

</sect1>

<sect1>Alt-SysRq
<p>
核心編譯選項「Magic SysRq key」提供系統強心針。在i386機器上按下 Alt-SysRq 群組合鍵後，試試按下列各鍵<tt>r 0 k
e i s u b</tt>，奇跡產生了：
<p>
Un'r'aw讓鍵盤從 X 崩潰中重生。將控制台 (console) loglevel改為'0'以減少錯誤訊息。sa'k'（system attention key）中止目前的虛擬控制台 (console) 的所有進程。t'e'rminate中止目前的終端設備除<prgn>init</prgn>外的所有進程。k'i'll中止除 <prgn>init</prgn> 外的所有進程。
<p>
'S'ync，'u'mount和re'b'oot幫你逃離真正的險境。
<p>
詳情參閱<file>/usr/share/doc/kernel-doc-<var>version</var>/Documentation/sysrq.txt.gz</file>或<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>。

</sect1>
</sect>


<sect id="nifty">記住這些可愛的小指令

<sect1>Pager
<p>
<prgn>less</prgn>就是預設的 pager（檔案內容瀏覽器）。按「h」可獲得幫助。它比<prgn>more</prgn>更有用。在shell啟動script中執行<tt>eval $(lesspipe)</tt>或<tt>eval $(lessfile)</tt>可以讓<prgn>less</prgn>活力四射。詳情參閱<file>&f-lessopen;</file>。使用<tt>-R</tt>選項可輸出生癖字元and enables ANSI color escape sequences.參閱<manref name="less" section="1">。
<p>
對於某些編碼系統（EUC）<prgn>w3m</prgn>可能是更好的選擇。

<sect1>釋放記憶體
<p>
<prgn>free</prgn>和<prgn>top</prgn>能讓你了解記憶體資來源的許多有用訊息。別擔心「Mem:」行中「used」的大小，看看它下面的數字（本例的數字是38792）。
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
實體記憶體的準確大小可通過<tt>grep '^Memory'
/var/log/dmesg</tt>得到，本例將顯示「Memory: 256984k/262144k available (1652k kernel code, 412k reserved, 2944k data, 152k init)」。
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
約有5MB記憶體系統不能使用，因為核心需要它。
</sect1>

<sect1>設定時間（BIOS）
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
設定系統時間和硬體時間為MM/DD hh:mm, CCYY。顯示時間為本地端時間而硬體時間使用的格式為 UTC。
<p>
如果硬體(BIOS)時間設定程 GMT，請修改 <file>/etc/default/rcS</file> 中的設定成<tt>UTC=yes</tt>。

<sect1>設定時間（NTP）
<p>
參考：<url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">。
<p>
<sect2>擁有永久Internet連接的系統設定時間
<p>
設定系統小時鐘通過遠端伺服器自動對時：
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
如果你的系統擁有永久的 Internet 連接，應該將該指令加入<file>/etc/cron.daily/</file>。

<sect2>偶爾進行 Internet 連接的系統設定時間
<p>
使用 <package>chrony</package> 套件軟體。
</sect1>

<sect1 id="setterm">如何控制 console 的特色，例如螢幕保護程式
<p>
執行下列指令來取消螢幕保護程式：
<p>
對於 Linux console：
<example>
# setterm -powersave off
</example>
<p>
啟動 kon2（kanji）console 執行：
<example>
# kon -SaveTime 0
</example>
<p>
執行 X 可執行：
<example>
# xset s off
 或
# xset -dpms
 或
# xscreensaver-command -prefs
</example>
參閱相關的幫助頁面來管理其餘的 console 功能。請參閱 <manref name="stty" section="1"> 來改變終端機顯示的行數。
</sect1>

<sect1 id="getent">查詢系統管理資料程式庫
<p>
Glibc提供了<manref name="getent" section="1">查詢管理資料程式庫的各類項目。例如passwd、group、hosts、services、protocols、networks。
<example compact>
getent database [key ...]
</example>

<sect1>禁用聲音（響鈴）
<p>
最直接的方法是拔掉 PC 喇叭 ;-)，對於Bash shell可執行：
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>控制台 (console) 上的錯誤訊息
<p>
不想看螢幕顯示的錯誤訊息，喜好設定的方法是檢查<file>/etc/init.d/klogd</file>，在該script中設定<tt>KLOGD="-c <var>3</var>"</tt>然後執行<tt>/etc/init.d/klogd restart</tt>。另一種方法是執行<tt>dmesg -n<var>3</var></tt>。
<p>
這兒是各種錯誤層級的含義：
<list compact>
<item>0: KERN_EMERG,   系統無法使用
<item>1: KERN_ALERT,   必須立即執行
<item>2: KERN_CRIT,    緊急狀態
<item>3: KERN_ERR,     錯誤狀態
<item>4: KERN_WARNING, 警告狀態 
<item>5: KERN_NOTICE,  正常狀態且十分重要
<item>6: KERN_INFO,    報告
<item>7: KERN_DEBUG,   debug-level訊息
</list>
<p>
如果你很厭惡詳細而無用的錯誤訊息，可以試試這個小補丁<file>shutup-abit-bp6</file>（位元於<url id="&examples;" name="樣例script子目錄">）。
<p>
另一個該看看的地方是<file>/etc/syslog.conf</file>;，檢查一下是否有訊息記錄被送出到了控制台 (console) 設備。
</sect1>

<sect1>正確設定控制台 (console) 檔案類型
<p>
在類Unix系統中，console 螢幕通常要呼叫程式庫例程，這就為使用者提供了一種獨立於終端設備的方式來更新螢幕上的文字，這是合理化的最佳選擇。參閱<manref name="ncurses" section="3X">和<manref name="terminfo" section="5">。
<p>
在&debian;系統中，有大量預定義項目：
<example>
$ toe | less                  # 所有項目
$ toe /etc/terminfo/ | less   # 使用者可再群組態的項目
</example>
選擇好之後請設定 <tt>TERM</tt> 這個環境變數。
<p>
當登入到遠端 Debian 系統時，如果 <prgn>xterm</prgn> 的 terminfo 項目在非 Debian 的 <prgn>xterm</prgn> 中失效，請將終端設備檔案類型改為支援較少特性的版本如「xterm-r6」。
參閱<file>&f-libncurse;</file>。「dumb」是terminfo的最小公分母。
</sect1>

<sect1>恢復 console 到穩定狀態
<p>
如果執行<tt>cat <var>some-binary-file</var></tt>後螢幕一片混亂（指令的返回值與你的輸入大相徑庭）：
<example>
$ reset
</example>
</sect1>

<sect1 id="dos2unix">將 DOS 下的文字檔案轉換為Unix檔案類型
<p>
將 DOS 文字檔案（行尾=^M^J）轉換成Unix文字檔案（行尾=^J）。
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1 id="recode">利用 <prgn>recode</prgn> 來轉換文字檔
<p>
底下示範轉換文字檔在 DOS，Mac和Unix底下斷行的方法：
<example>
$ recode /cl../cr &lt;<var>dos.txt</var> &gt;<var>mac.txt</var>
$ recode /cr.. &lt;<var>mac.txt</var> &gt;<var>unix.txt</var>
$ recode ../cl &lt;<var>unix.txt</var> &gt;<var>dos.txt</var>
</example>
<prgn>recode</prgn>依據不同字元集和介面來轉換檔案：
<example>
$ recode <var>charset1</var>/<var>surface1</var>..<var>charset2</var>/<var>surface2</var> \
  &lt;<var>input.txt</var> &gt;<var>output.txt</var>
</example>
一般常使用的字元集轉換(請參閱<ref id="base-locale">)
<footnote>
<prgn>recode</prgn> 比<prgn>iconv</prgn>允許更多方便的別名。
</footnote>
:
<list compact>
<item><tt>us</tt> &mdash; ASCII (7 bits)
<item><tt>l1</tt> &mdash;  ISO Latin-1 (ISO-8859-1, Western Europe, 8 bits)
<item><tt>EUCJP</tt> &mdash; EUC-JP for Japanese (Unix)
<item><tt>SJIS</tt> &mdash; Shift-JIS for Japanese (Microsoft)
<item><tt>ISO2022JP</tt> &mdash; Mail encoding for Japanese (7 bits)
<item><tt>u2</tt> &mdash; UCS-2 (Universal Character Set, 2 bytes)
<item><tt>u8</tt> &mdash; UTF-8 (Universal Transformation Format, 8 bits)
</list>
一般常用的介面為
<footnote>
行尾表示法：
<list compact>
<item>Carriage return means ASCII 13, ASCII 0xD, ^M, and \r .
<item>Line feed means ASCII 10, ASCII 0xA, ^J, and \n .
</list>
</footnote>
：
<list compact>
<item><tt>/cr</tt> &mdash; Carriage return as end of line (Mac text)
<item><tt>/cl</tt> &mdash; Carriage return line feed as end of line (DOS text)
<item><tt>/</tt> &mdash; Line feed as end of line (Unix text)
<item><tt>/d1</tt> &mdash; Human readable bytewise decimal dump
<item><tt>/x1</tt> &mdash; Human readable bytewise hexidecimal dump
<item><tt>/64</tt> &mdash; Base64 encoded text
<item><tt>/QP</tt> &mdash; Quoted-Printable encoded text
</list>
相關的資訊請參閱<tt>info recode</tt>。
<p>
也有一些特別的轉換工具：
<list compact>
<item>字元集轉換：
<list compact>
<item><prgn>iconv</prgn> &mdash; locale encoding conversions
<item><prgn>konwert</prgn> &mdash; fancy encoding conversions
</list>
<item>二進制檔案轉換：
<list compact>
<item><prgn>uuencode</prgn> 和 <prgn>uudecode</prgn> &mdash; Unix 上有的。
<item><prgn>mimencode</prgn> &mdash; 使用在 Mail。
</list>
</list>
</sect1>
<sect1 id="perl-i">Regular-expression substitution

<p>
將所有檔案<var>FILES</var> ...中的所有<var>FROM_REGEX</var>字段取代成<var>TO_TEXT</var>字段。
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_TEXT</var>/g;' <var>FILES</var> ...
</example>
<tt>-i</tt>表示「就地編輯」，<tt>-p</tt>表示「在<var>FILES</var>...各檔案中循環」。如果置換很復雜，應使用參數<tt>-i.bak</tt>而非<tt>-i</tt>，這有助於發生錯誤恢復；它會將每個原始檔案儲存為以<tt>.bak</tt>為後綴的備份檔案。
</sect1>

<sect1>使用 script 來編輯檔案
<p>
下面的script將刪除 5&ndash;10 行以及 16&ndash;20 行。
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
在此，<prgn>ed</prgn>指令與<prgn>vi</prgn>指令模式下的是一樣的，從外部編輯檔案的方式使它易於script化。
</sect1>

<sect1>提取來源檔案修改部分合併到更新包
<p>
下面的操作將根據檔案位元置，提取來源檔案的修改部分並建立統一的 diff 檔案 <var>file.patch0</var> 或 <var>file.patch1</var>：
<example>
$ diff -u <var>file.old</var> <var>file.new</var> &gt; <var>file.patch0</var>
$ diff -u <var>old/file</var> <var>new/file</var> &gt; <var>file.patch1</var>
</example>
diff 檔案（也稱修正檔案）通常用於送出程式更新。收到的修正檔案可使用下面的方法更新另一個<var>檔案</var>：
<example>
$ patch -p0 <var>file</var> &lt; <var>file.patch0</var>
$ patch -p1 <var>file</var> &lt; <var>file.patch1</var>
</example>
如果有三個版本的來源代碼，使用<prgn>diff3</prgn>來合併效率更高：
<example>
$ diff3 -m <var>file.mine</var> <var>file.old</var> <var>file.yours</var> &gt; <var>file</var>
</example>
</sect1>

<sect1>分割大檔案
<p>
<example>
$ split -b 650m <var>file</var>   # 將大檔案分塊成多個650MB的小檔案
$ cat x* &gt<var>largefile</var>    # 將所有小檔案合併成一個大檔案
</example>
</sect1>

<sect1>從文字檔格式的表格中抽取資料
<p>
假設有一個文字檔案名為<file>DPL</file>，其中存放著所有前 &debian; 計畫領導人的名字和他們的上臺日期，表格格式是以空格做為分隔的。
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   January 1998
Wichert Akkerman  January 1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr March   2003
</example>
<!-- FIXME: Update me -->
AWK經常用於從這類檔案中提取資料。
<example>
$ awk '{ print $3 }' &lt;DPL                   # month started
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' &lt;DPL          # DPL called Ian
Ian     Murdock   August  1993
Ian     Jackson   January 1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # When Perens started
April 1996
</example>
<p>
Shells 像是 Bash 也可以用來分析這類型的檔案：
<example>
$ while read first last month year; do 
    echo $month
  done &lt;DPL
... same output as the first Awk example
</example>
這裡， <prgn>read</prgn> 內建的指令使用 $IFS (internal field separators) 裡的字元來將行拆成多個文字。
<p>
如果你改變 IFS 成 ":"，你就能使用 shell 來分析 <file>/etc/passwd</file> ：
<example>
$ oldIFS="$IFS"   # save old value
$ IFS=":"
$ while read user password uid gid rest_of_line; do
    if [ "$user" = "osamu" ]; then 
      echo "$user's ID is $uid"
    fi
  done < /etc/passwd
osamu's ID is 1001
$ IFS="$oldIFS"   # restore old value
</example>
(在 Awk 中，使用 <tt>FS=":"</tt>就能達成相同的功能。)
<p> 
IFS也能用來拆解參數的展開、指令交換、算數運算。這些功能如果夾在單引號或雙引號之內的話，將會失效。預設的 IFS 是 &lt;space&gt;, &lt;tab&gt;, and &lt;newline&gt; 的組合。
<p>
請小心這個 IFS 陷阱。尤其當 shell 轉譯<strong>讀入</strong>的script時，可能會出現奇怪的問題。
<example>
$ IFS=":,"                        # use ":" and "," as IFS
$ echo IFS=$IFS,   IFS="$IFS"     # echo is a Bash built-in
IFS=  , IFS=:,
$ date -R                         # just a command output
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # sub shell --&gt; input to main shell
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # reset IFS to the default
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>
</sect1>


<sect1 id="scrp-snip">精巧的管道指令輔助script
<p>
下列script做為管道的一部分十分有用。
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # find all files in /usr excluding some files
xargs -n 1 <var>command</var>   # run command for all items from stdin
xargs -n 1 echo |    # split white-space-separated items into lines
xargs echo      |    # merge all lines into a line
grep -e <var>pattern</var>|     # extract lines containing <var>pattern</var>
cut -d: -f3 -|
        # extract third field separated by : (passwd file etc.)
awk '{ print $3 }' | # extract third field separated by whitespaces
awk -F'\t' '{ print $3 }' |
        # extract third field separated by tab
col -bx |            # remove backspace and expand tabs to spaces
expand -|            # expand tabs
sort -u|             # sort and remove duplicates

tr '\n' ' '|         # concatenate lines into one line
tr '\r' ''|          # remove CR
tr 'A-Z' 'a-z'|      # convert uppercase to lowercase
sed 's/^/# /'|       # make each line a comment
sed 's/\<var>.ext</var>//g'|    # remove <var>.ext</var>
sed  -n -e 2p|       # print the second line 
head -n 2 -|         # print the first 2 lines
tail -n 2 -|         # print the last 2 lines
</example>
</sect1>

<sect1>查看每個檔案的輕巧 script
<p>
The following ways of looping over each file matching 
<tt>*.<var>ext</var></tt> ensures proper handling of 
funny file names such as ones with spaces and performs equivalent process:
<list>
<item>Shell loop (這個範例是<tt>PS2=" "</tt>的多行風格。要打成一行的話，您必須在每一行末加入分號。)
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>command</var> "$<var>x</var>"
  fi
done
</example>
<item><prgn>find</prgn> and <prgn>xargs</prgn> combination:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>command</var>
</example>
<item><prgn>find</prgn> with <tt>-exec</tt> option with a command:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>command</var> '{}' \;
</example>
<item><prgn>find</prgn> with <tt>-exec</tt> option with a short shell script:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>command</var> '{}' && echo 'successful'" \;
</example>
</list>
</sect1>

<sect1 id="perl-mad">輕巧的 Perl Script
<p>
雖然 Awk scripts 透過<manref name="a2p" section="1">就能自動轉換成 Perl，對於只有一行的 Awk Script 到 Perl Script，直接手動修改是最方便的了。例如：
<example>
awk '($2=="1957") { print $3 }' |
</example>
同等於下列任意一行：
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
其實上面各行中所有<prgn>perl</prgn>參數中的空格均可去掉，這得益於Perl的數字字串自動轉換功能。
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
有關指令行參數的訊息可參閱<manref name="perlrun" section="1">，在<url id="&perlgolf;">有更多令人著魔的Perl script，你會感興趣的。
</sect1>

<sect1>從網頁上取得文件或通信清單(mailing list)
<p>
下面的操作將網頁轉化為文字檔案。從網上拷貝設定檔案時十分有用。
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>textfile</var>
</example>
<prgn>links</prgn>和<prgn>w3m</prgn>也可以這麼用，只是生成的文本樣式可能略有不同。
<p>
如果是信件清單文文件案，可使用<prgn>munpack</prgn>從文本獲得mime內容。
</sect1>

<sect1>列印網頁
<p>
下面的操作將網頁內容列印成PostScript檔案或送出到印表機。
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
參閱<ref id="lprlpd">。還可使用<prgn>a2ps</prgn>和<prgn>mpage</prgn>套服軟體生成PostScript檔案。
</sect1>

<sect1>列印幫助頁面
<p>
下面的操作將幫助頁面列印成PostScript檔案或送出到印表機。
<example>
$ man -Tps <var>some-manpage</var> | lpr
$ man -Tps <var>some-manpage</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>合併兩個Postscript或PDF檔案
<p>
可以將兩個Postscript檔案或PDF檔案合併。
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>
 
<sect1>指令耗時
<p>
顯示某進程的耗時
<example>
# time <var>some-command</var> &gt;/dev/null
real    0m0.035s       # time on wall clock (elapsed real time)
user    0m0.000s       # time in user mode
sys     0m0.020s       # time in kernel mode
</example>
</sect1>

<sect1><prgn>nice</prgn>指令
<p>
使用<prgn>nice</prgn>（來自GNU <package>shellutils</package>套服軟體）可設定指令啟動時的nice值。<prgn>renice</prgn>（<package>bsdutils</package>）和<prgn>top</prgn>可以重設進程的nice值。nice值為19代表最慢的（優先等級最低的）進程；負值就「not-nice」，如-20代表非常快的（優先等級高的）進程。只有Supervisor可以設定負nice值。
<example>
# nice  -19 <var>top</var>                                         # very nice
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # very fast
</example>
有時過度的nice值對系統弊大於利，所以使用該指令要小心。
</sect1>

<sect1 id="cronjob">日程安排（<prgn>cron</prgn>，<prgn>at</prgn>）
<p>
在Linux下使用<prgn>cron</prgn>和<prgn>at</prgn>進行工作日程安排。參閱<manref name="at" section="1">、<manref name="crontab" section="5">、<manref name="crontab" section="8">。
<p> 
執行指令<tt>crontab -e</tt>建立或編輯crontab檔案，為規律事務（按周期循環的事務）安排日程。下面的一個crontab檔案樣例：
<example>
# use /bin/sh to run commands, no matter what /etc/passwd says
SHELL=/bin/sh
# mail any output to `paul', no matter whose crontab this is
MAILTO=paul
# Min Hour DayOfMonth Month DayOfWeek command (Day... are OR'ed)
# run at 00:05, every day
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# run at 14:15 on the first of every month -- output mailed to paul
15 14 1  * *   $HOME/bin/monthly
# run at 22:00 on weekdays(1-5), annoy Joe. &percnt; for newline, last &percnt; for cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Where are your kids?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# run at 03:40 on the first Monday of each month
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
執行<prgn>at</prgn>指令為偶然工作（只執行一次的工作）安排日程：
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">用<prgn>screen</prgn>來切換 console
<p>
The <prgn>screen</prgn>程式容許在單一的物理終端設備或終端設備類比視窗執行多個偽終端設備，每個偽終端設備都擁有自己的交談式shell。即便可以使用Linux偽終端設備或多個<prgn>xterm</prgn>視窗，研究一下如何設定<prgn>screen</prgn>豐富的特性仍很有益，這些特性內含：
<list compact>
<item>回溯歷史顯示， 
<item>拷貝和貼上，
<item>輸出到日誌，
<item>圖形入口， 
<item>將終端設備與整個<prgn>screen</prgn>階段作業<strong>分離</strong>，稍後再連接。
</list>

<sect2>遠端存取作業方式
<p>
If you frequently log on to a Linux machine
如果你經常從遠端終端設備登入到Linux機器或使用VT100終端設備程式，<prgn>screen</prgn>的<strong>detach</strong>（分離）特性將簡化你的生活。
<p>
<enumlist compact>
<item>通過拔號連接登入，執行了一個非常復雜的<prgn>screen</prgn>會談，開啟舊檔了好幾個視窗，有編輯器和其它一些程式。
<item>突然你需要離開終端設備一下，但你並不想掛斷連線中止工作。
<item>輸入<tt>^A d</tt><strong>離開</strong>階段作業，然後登出系統。（或是更簡單些，輸入<tt>^A DD</tt>離開階段作業並自動登出系統）
<item>當你回來時，需要再次登入，可輸入指令<tt>screen -r</tt>，<prgn>screen</prgn>會如魔法般地重新連線上所有開啟舊檔的視窗。
</enumlist>

<sect2>典型的<prgn>screen</prgn>指令
<p>
一但開啟舊檔了<prgn>screen</prgn>程式，除了指令按鍵（預設值為<tt>^A</tt>）所有的鍵盤輸入都被送到目前的視窗，所有的<prgn>screen</prgn>指令均按特定方式輸入：<tt>^A</tt>加一個單鍵指令[加一些參數]的。常用的指令有：
<example>
^A ?     顯示說明螢幕（顯示指令集）
^A c     建立並切換到新增視窗
^A n     跳到下一個視窗
^A p     跳到上一個視窗
^A <var>0</var>     跳到<var>0</var>號視窗
^A w     顯示視窗清單
^A a     將Ctrl-A做為鍵盤輸入送出到目前的視窗
^A h     對目前的視窗做硬拷貝寫入到檔案
^A H     開始/中止將目前的視窗v饇O錄到檔案
^A ^X    鎖定終端設備（密碼保護）
^A d     從終端設備分離螢幕階段作業
^A DD    分離螢幕階段作業並結束登入
</example>
以上只是<prgn>screen</prgn>指令的一個很小的子集。只要是你認為<prgn>screen</prgn>能幹的事，沒準它真就可以！詳情參閱<manref name="screen" section="1">。

<sect2><prgn>screen</prgn>階段作業中的退格鍵和Ctrl-H
<p>
在執行<prgn>screen</prgn>時，如果發現退格鍵和/或Ctrl-H無法正常工作，可編輯<file>/etc/screenrc</file>，找到這行：
<example compact>
bindkey -k kb stuff "\177"
</example>
將這注釋掉（例如在句首添加「#」）。

</sect1>

<sect1 id="net-test">網路測試基礎
<p>
安裝<package>netkit-ping</package>、<package>traceroute</package>、<package>dnsutils</package>、<package>ipchains</package>（適用於2.2版核心）、<package>iptables</package>（適用於2.4版核心）和<package>net-tools</package>套服軟體，然後執行：
<example>
$ ping <var>yahoo.com</var>            # 檢查Internet連接
$ traceroute <var>yahoo.com</var>      # 追蹤IP封包
$ ifconfig                  # 檢查主電腦設定
$ route -n                  # 檢查路由設定
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # 檢查<var>dns-server.com</var>的<var>host.dom</var> DNS記錄
      # 尋找<var>{a|mx|any}</var>記錄
$ ipchains -L -n |less     # 檢查包過濾(2.2 kernel)
$ iptables -L -n |less      # 檢查包過濾(2.4 kernel)
$ netstat -a                # 尋找系統上所有開啟舊檔的連接埠
$ netstat -l --inet         # 尋找系統監聽的連接埠
$ netstat -ln --tcp         # 尋找系統監聽的TCP連接埠（連接埠數字）
</example>
</sect1>

<sect1 id="flush-mail">清理（flush）本地端的 Mail 佇列
<p>
想要：清理（flush）本地端的 Mail 佇列
<example>
# exim4 -q    # 清理待讀信件
# exim4 -qf   # 清理所有信件
# exim4 -qff  # 清理凍結信件
</example>
<tt>-qff</tt>選項用在<file>/etc/ppp/ip-up.d/exim</file>script中效果更好。在 Woody 和更舊的版本中，改用<prgn>exim</prgn>來取代<prgn>exim4</prgn>。
</sect1>

<sect1 id="remove-mail">刪除已凍結的信件
<p>
刪除本地端凍結信件並返回發生錯誤訊息：
<example>
# exim4 -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
在 Woody 和更舊的版本中，改用<prgn>exim</prgn>來取代<prgn>exim4</prgn>。
</sect1>

<sect1>重新寄送<file>mbox</file>中的信件
<p>
如果home目錄沒有空間造成<prgn>procmail</prgn>不能處理信件，就需要對磁碟空間進行擴容，擴容完成後需要手動分發<file>/var/mail/<var>username</var></file>目錄中的信件到home目錄中的分類信箱，執行：
<example>
# /etc/init.d/exim4 stop
# formail -s procmail &lt;/var/mail/<var>username</var>
# /etc/init.d/exim4 start
</example>
在 Woody 和更舊的版本中，改用<prgn>exim</prgn>來取代<prgn>exim4</prgn>。
</sect1>

<sect1>清理檔案內容
<p>
要清理某些檔案如日誌檔案的內容，千萬不要使用<tt>rm</tt>刪除檔案然後再建立一個新的空檔案，因為在兩次操作的間隔，系統可能需要存取該檔案。下面是清理檔案內容的安全方法：
<example>
$ :&gt;<var>file-to-be-cleared</var>
</example>
</sect1>

<sect1 id="dummyfile">空檔案
<p>
下面的指令可以建立空檔案：
<example>
$ dd if=/dev/zero    of=<var>filename</var> bs=1k count=5 # 5KB of zero content
$ dd if=/dev/urandom of=<var>filename</var> bs=1M count=7 # 7MB of random content
$ touch <var>filename</var> #  create 0B file (if file exists, updates mtime)
</example>
例如，最實用的使用方式是從&debian;啟動軟式磁碟機的shell中執行下列指令將硬碟<file>/dev/hda</file>的內容完全清理。
<example>
# dd if=/dev/urandom of=/dev/hda; dd if=/dev/zero of=/dev/hda
</example>

</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
<prgn>chroot</prgn>程式，<manref name="chroot" section="8">，不需要重啟系統，就可以在單獨的系統上同時執行多個不同的GNU/Linux環境。
<p>
還可以在較快主電腦的chroot下執行某些需耗大量系統資來源記憶體的程式如<prgn>apt-get</prgn>或<prgn>dselect</prgn>，並將較慢子機的硬碟通過NFS方式掛載到主電腦，開放讀/寫權限，在主電腦上以chroot方式操作子機。

<sect2 id="chroot-debian">用<prgn>chroot</prgn>來執行不同版本的&debian;
<p>
在Sarge中使用<prgn>debootstrap</prgn>指令很容易建構chroot &debian;環境。在Sarge後續版本，你可改用<prgn>cdebootstrap</prgn>和適當參數來替代。例如，在一臺擁有快速Internet連接的機器的<var>/sid-root</var>下建立一個Sid chroot：
<example>
main # cd /; mkdir <var>/sid-root</var>
main # debootstrap sid <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... watch it download the whole system
main # echo "proc <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount <var>/sid-root</var>/proc
main # mount /dev/ <var>/sid-root</var>/dev -o bind
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # cd /dev; /sbin/MAKEDEV generic; cd -
chroot # apt-setup # set-up /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # point the source to unstable
chroot # dselect  # you may use aptitude, install mc and vim :-)
</example>
<p>
現在你就擁有了一個全功能&debian;子系統，可以盡情測試而不必擔心主&debian;受到不利影響。
<p>
該<prgn>debootstrap</prgn>套用技巧還可以實現在沒有&debian;安裝盤的情況下，從另一個GNU/Linux發行版下安裝&debian;。參閱<url id="&setup-chroot;">。

<sect2 id="chroot-console">設定<prgn>chroot</prgn>登入
<p>
輸入<tt>chroot <var>/sid-root</var> /bin/bash</tt>非常簡單，但這將沿用目前的的所有環境變量，你可能並不希望這樣並且有時還會出問題。更好的方法是，在別的虛擬終端設備上執行另一個登入進程，登入到chroot目錄。
<p>
在&debian;系統中預設值從<tt>tty1</tt>到<tt>tty6</tt>執行Linux console，<tt>tty7</tt>執行 X Window系統，在本例中，我們將<tt>tty8</tt>設定成chroot console。按照<ref id="chroot-debian">中的描述建立好chroot系統後，就可以在主系統的root shell中輸入：
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8" >> /etc/inittab
main # init q    # reload init
</example>

<sect2 id="chroot-x">群組態<prgn>chroot</prgn>下的X
<p>
想在 chroot 下安全地執行最新版的 X 和 GNOME 嗎？完全可以！下面的例子將實現在虛擬終端設備<tt>vt9</tt>下執行 GDM。
<p>
首先，按照<ref id="chroot-debian">中描述的方法安裝好chroot系統，從主系統的root下拷貝關鍵群組態檔案到chroot系統。
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # or use chroot console
chroot # cd /dev; /sbin/MAKEDEV generic; cd -
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # do s/vt7/vt9/ in [servers] section
chroot # /etc/init.d/gdm start
</example>
在此，編輯<file>/etc/gdm/gdm.conf</file>來改變第一個虛擬終端裝置，使其在<tt>vt7</tt>到<tt>vt9</tt>上建立虛擬終端設備。
<p>
現在可以很容易地能過切換Linux虛擬終端設備來實現在主系統的X環境和chroot系統的X環境之間轉換，例如使用Ctrl-Alt-F7和Ctrl-Alt-F9。酷吧！
<p>
[FIXME] 在chroot系統下<prgn>gdm</prgn>的initscript中添加一條注釋和一條連結。

<sect2 id="chroot-dist">使用<prgn>chroot</prgn>來執行其它發行版
<p>
很容易建立一個其它發行版的 chroot 環境。使用其它發行版的安裝程式將它們安裝到單獨的硬碟分區中。例如root分區位元於<file><var>/dev/hda9</var></file>：
<example>
main # cd /; mkdir <var>/other-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/other-dist</var>
main # chroot <var>/other-dist</var> /bin/bash
</example>
然後，執行<ref id="chroot-debian">、<ref id="chroot-console">和<ref id="chroot-x">中描述的內容。

<sect2 id="chroot-build">使用<prgn>chroot</prgn>來編譯軟體
<p>
這兒有一個很特殊的chroot套服軟體<package>pbuilder</package>，它構造一個chroot系統並在其中編譯套服軟體。該體系可用於檢查套服軟體編譯時關聯關係是否正確，並確保編譯生成的套服軟體中沒有不必要的或錯誤的關聯關係。

</sect1>

<sect1>怎樣檢查 hard links
<p>
<!-- two hard links?, one would be suffiecient? -->
檢查兩個檔案是否是指向同一個檔案的兩個硬連結：
<example> 
$ ls -li <var>file1</var> <var>file2</var>
</example>
 
<sect1><prgn>mount</prgn>硬碟上的映象檔案
<p>
如果 <file><var>file.img</var></file> 檔案是硬碟內容的對映檔案，而且原始硬碟的群組態參數為 <var>xxxx</var> = (bytes/sector) * (sectors/cylinder)，那麼，下面的指令將其掛載到<file>/mnt</file>：
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
注意絕大部分的硬碟都是 512 bytes/sector。

<sect1 id="smbmount">Samba
<p>
取得 Windows 檔案的基本方法：
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # mount Windows files to Linux
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # list the shares on a computer
</example>
<p>
可從 Linux 檢查 Samba 網路上的芳鄰：
<example>
# smbclient -N -L <var>ip_address_of_your_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>外來檔案系統的操作工具
<p>
Linux 核心支援多種外來檔案系統，想存取它們只需將其掛載到合適的檔案系統下就行了。
對某些檔案系統，還提供專門工具不需要掛載，只依靠使用者空間的程式，不需要核心提供檔案系統支援，就能完整存取。
<list compact>
<item><package>mtools</package>: for MSDOS filesystem (MS-DOS, Windows)
<item><package>cpmtools</package>: for CP/M filesystem
<item><package>hfsutils</package>: for HFS filesystem (native Macintosh)
<item><package>hfsplus</package>: for HFS+ filesystem (modern Macintosh)
</list>
對於建立和檢查 MS-DOS FAT 檔案系統 <package>dosfstools</package> 非常有用。
</sect1>

</sect>

<sect id="oops">打錯字的情況
<p>
這裡示範幾個危險的動作。當使用特權帳號：<tt>root</tt>時，負面影響的程度是相當嚴重。

<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>
<!-- 
I know using quotes here are irregular but it is hard to read without it. 
-->
在命令列操作萬用檔名(*號)如"<tt>rm -rf .*</tt>"可能會造成嚴重的錯誤，因為"<tt>.*</tt>"會參考到"<tt>.</tt>" 和 "<tt>..</tt>"。幸運地，在&debian;上的"<tt>rm</tt>"版本會很聰明地檢查檔名並取消移除"<tt>.</tt>" and "<tt>..</tt>"。但這並非永遠如此。試試看底下的例子來了解萬用檔名的用法。
<p>
<list compact>
<item>"<tt>echo *</tt>":列出現在目錄下所有非 . 開頭的目錄與檔案。
<item>"<tt>echo .[^.]*</tt>":列出該目錄下所有 . 開頭的檔案和目錄
<item>"<tt>echo .*</tt>":列出上層所有的檔案和目錄以及該上層目錄。<!-- FIXME: wrong in Etch -->
</list>

<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
由於您愚蠢地移除掉 <file>/etc/passwd</file> 是會造成相當嚴重的損失。&debian;系統會慣例性地備份重要檔案到<file>/var/backups/</file>。當你回存這些檔案時，請記得更改適當的權限。
<example>
# cp /var/backups/passwd /etc/passwd
# chmod 644 /etc/passwd
</example>
請參閱 <ref id="recover-status">。

</chapt>

