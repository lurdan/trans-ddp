<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.41" -->

<chapt id="vcs">版本控制系統

<sect id="cvs">Concurrent Versions System (CVS)
<p>
有關的詳細訊息可使用 <prgn>lynx</prgn> 查閱 <file>/usr/share/doc/cvs/html-cvsclient</file> ， <file>/usr/share/doc/cvs/html-info</file>，<file>/usr/share/doc/cvsbook</file> 或執行 <tt>info cvs</tt> 及 <tt>man cvs</tt>。

<sect1 id="cvs-inst">安裝 CVS 伺服器
<p>
以下設定的步驟，僅允許 "src" 群組的成員存取 CVS 檔案庫，並且僅 "staff" 群組的成員才可管理 CVS，這樣做可以降低管理者不小心犯錯的機會。
<example>
# cd <var>/var/lib</var>; umask 002; mkdir <var>cvs</var> # [Woody] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=<var>/var/lib/cvs</var>
# cd $CVSROOT
# chown root:src .  # "staff" to restrict more for starting project.
# chmod 3775 .             # 如果上面使用 "staff"，則這裡用 2775
# cvs -d <var>/var/lib/cvs</var> init # 在此明確指定 -d 會更安全！
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect1>

<sect1 id="cvs-examples">CVS session 範例
<p>
下面是設定 shell 環境以便存取 CVS 檔案庫 (repository)。

<sect2>匿名 CVS (僅能下載)
<p>
遠端唯讀存取：
<example>
$ export CVSROOT=:pserver:<var>anonymous@cvs.sf.net:/cvsroot/qref</var>
$ cvs login
$ cvs -z3 co <var>qref</var>
</example>
</sect2>

<sect2>使用本地 CVS 伺服器
<p>
透過同一台機器上的 shell 進行本地端存取：
<example>
$ export CVSROOT=<var>/var/lib/cvs</var>
</example>
</sect2>

<sect2>使用遠端 CVS pserver
<p>
不使用 SSH (在 <prgn>cvs</prgn> 中使用 RSH 協議) 遠程存取：
<example>
$ export CVSROOT=:pserver:<var>account@cvs.foobar.com:/var/lib/cvs</var>
$ cvs login
</example>
這個方法有被竊聽攻擊的疑慮。
</sect2>

<sect2>透過 <prgn>ssh</prgn> 使用遠端 CVS
<p>
透過 SSH 進行遠端存取：
<example>
$ export CVSROOT=:ext:<var>account@cvs.foobar.com:/var/lib/cvs</var>
</example>
或以 SourceForge 為例：
<example>
$ export CVSROOT=:ext:<var>account@cvs.sf.net:/cvsroot/qref</var>
</example>
你亦可使用 RSA 認證 (<ref id="ssh-rsa">)，它不需要密碼提示。
</sect2>

<sect2>建立新的 CVS 庫存 (archive)
<p>
想要建立如下的檔案，
<example>
ITEM              VALUE               MEANING
source tree:      ~/<var>project-x</var>         所有的源碼
Project name:     <var>project-x</var>           專案名稱
Vendor Tag:       <var>Main-branch</var>         整個分支的標記 (Tag)
Release Tag:      <var>Release-initial</var>     特定分支的標記
</example>
則，
<example>
$ cd ~/<var>project-x</var>                # 進源碼目錄
 ... 建立源碼樹 ...
$ cvs import -m <var>"Start project-x" project-x Main-branch Release-initial</var>
$ cd ..; rm -R ~/<var>project-x</var>
</example>
</sect2>

<sect2>使用 CVS
<p>
使用本地端 CVS 檔案庫來進行 <var>project-x</var>：
<example>
$ cd                            # 轉到工作區
$ cvs co <var>project-x</var>              # 從 CVS 下載源碼到本地端
$ cd <var>project-x</var>
 ... 修改內容 ...
$ cvs diff -u                   # 相當於 diff -u repository/ local/
$ cvs up -C <var>modified_file</var>       # 取消對文件的修改
$ cvs ci -m "<var>Describe change</var>"   # 將本地端源碼存到 CVS 上
$ vi <var>newfile_added</var>
$ cvs add <var>newfile_added</var>
$ cvs ci -m "<var>Added newfile_added</var>"
$ cvs up                        # 從 CVS 合併最新版本
 ... 要從 CVS 建立所有新建立的子目錄的話，請改用 "cvs up -d -P"
 ... 注意以 "C <var>filename</var>" 作開頭的行
 ... 沒有變動的碼會移至 `.#<var>filename</var>.version'
 ... 在 <var>filename</var> 中搜尋 "&lt;&lt;&lt;&lt;&lt;&lt;&lt;" 和 "&gt;&gt;&gt;&gt;&gt;&gt;&gt;"
$ cvs tag <var>Release-1</var>             # 添加 release tag
 ... 繼續編輯 ...
$ cvs tag -d <var>Release-1</var>          # 移除 release tag
$ cvs ci -m "<var>more comments</var>"
$ cvs tag <var>Release-1</var>             # 重新加入 release tag
$ cd                            # 返回工作區
$ cvs co -r <var>Release-initial</var> -d <var>old</var> <var>project-x</var>
 ... 取得原版本並放入 <var>old</var> 目錄
$ cd old
$ cvs tag -b <var>Release-initial-bugfixes</var> # 建立 branch (-b) tag
 ... 現在你可以對舊版本做修改了 (Tag=sticky)
$ cvs update -d -P
 ... 源碼樹現在有 "Release-initial-bugfixes" 的 sticky tag
 ... 對分支做修改
$ cvs up -d -P # 將在這個分支版本上被他人修改的檔案同步化
$ cvs ci -m "<var>check into this branch</var>"
$ cvs update -kk -A -d -P
 ... 移除 sticky tag 並取消內容
 ... update from main trunk without keyword expansion
$ cvs update -kk -d -P -j <var>Release-initial-bugfixes</var>
 ... 將 <var>Release-initial-bugfixes</var> 的分支合併至主要版本
 ... trunk without keyword expansion.  Fix conflicts with editor.
$ cvs ci -m "<var>merge Release-initial-bugfixes</var>"
$ cd
$ tar -cvzf <var>old-project-x.tar.gz</var> <var>old</var>  # 建立壓縮備份， -j 可使用 bz2 格式
$ cvs release -d <var>old</var>            # 移除本地端源碼（可選）
</example>
應該記住的幾個選項（用作 <prgn>cvs</prgn> 命令行的第一個參數）：
<example>
-n      dry run, no effect
-t      display messages showing steps of cvs activity
</example>
</sect2>

<sect2>從 CVS 匯出 (export) 檔案
<p>
要從 CVS 獲得最新版本，用 "tomorrow" ：
<example>
$ cvs ex -D tomorrow <var>module_name</var>
</example>
</sect2>

<sect2>管理 CVS
<p>
為專案加上別名 (alias)（本地伺服器）：
<example>
$ su - admin           # staff 成員之一
$ export CVSROOT=<var>/var/lib/cvs</var>
$ cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "<var>px</var> -a <var>project-x</var>" &gt;&gt;modules
$ cvs ci -m "<var>Now px is an alias for project-x</var>"
$ cvs release -d .
$ exit                 # 或 Ctrl-D 自 su 返回
$ cvs co -d <var>project</var> <var>px</var> 
 ... 自 CVS 中匯出 <var>project-x</var> (別名： <var>px</var>) 至 direcotry 專案
$ cd project
 ... 修改內容 ...
</example>
</sect2>

<sect1 id="cvs-trouble">CVS 常見問題解決方法

<sect2>容器庫中的檔案權限
<p>
CVS 不會覆蓋當前容器中的文件，而是用另一個文件替換它。因此，<em>對檔案庫目錄的寫入權限</em>是很重要的權限。所以如果需要的話，在新建檔案庫時請執行下面的命令，以確保權限的設定。
<example>
# cd <var>/var/lib/cvs</var>
# chown -R root:src <var>repository</var>
# chmod -R ug+rwX   <var>repository</var>
# chmod    2775     <var>repository</var>  # 如果需要的話，對子目錄也做同樣的設定
</example>
</sect2>

<sect2>可執行權限 (Execution bit)
<p>
當文件被別人匯出後會保留可執行權限。任何時候當你匯出的文件遇到執行權限的問題，可用下面的命令在 CVS 檔案庫中修改文件的權限。
<example>
# chmod ugo-x <var>filename</var>
</example>
</sect2>

</sect1>

<sect1 id="cvs-short">CVS 命令
<p>
這裡是一些 CVS 命令和他們的捷徑的用法。
<example>
{add|ad|new} [-k kflag] [-m 'message'] files...
{admin|adm|rcs} [rcs-options] files...
{annotate|ann} [options] [files...]
{checkout|co|get} [options] modules...
{commit|ci|com}   [-lnR]  [-m  'log_message'  |  -f  file] \
        [-r revision] [files...]
{diff|di|dif} [-kl] [rcsdiff_options] [[-r rev1 | -D date1] \
        [-r rev2 |  -D date2]] [files...]
{export|ex|exp} [-flNn] -r rev|-D date [-d dir] [-k kflag] module...
{history|hi|his} [-report] [-flags] [-options args] [files...]
{import|im|imp} [-options] repository vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] rlog-options [files...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...
{release|re|rel} [-d] directories...
{remove|rm|delete} [-lR] [files...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  tag  |  -D  date] \
         symbolic_tag modules...
{status|st|stat} [-lR] [-v] [files...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r tag | -D date]  [-f] \
         symbolic_tag [files...]
{update|up|upd} [-AdflPpR] [-d] [-r tag|-D date] files...
</example>
</sect1>

<sect id="svn">Subversion
<p>
Subversion 是下一代版本控制系統，它將替代 CVS。當前開發者稱它還處於 "alpha" 階段，但對大多數用戶而言它已足夠穩定了。到本文檔寫作之時，Subversion 僅在 Debian
<tt>unstable</tt> 中可用。
<sect1 id="svn-inst">安裝 Subversion 伺服器
<p>
<package>subversion</package> meta-package 依賴一些相依的套件 (<package>libapache2-svn</package> 和 <package>subversion-tools</package>) 來設定伺服器。
<sect2>設立檔案庫
<p>
當前，<package>subversion</package> 無法建立檔案庫，所以使用者需要手動創建它們。通常會在 <file>/var/local/repos</file> 下建立檔案庫。
<p>
創建目錄：
<example>
# mkdir -p /var/local/repos
</example>
建立檔案資料庫：
<example>
# svnadmin create /var/local/repos
</example>
將容器的寫權限賦給 www server：
<example>
# chown -R www-data:www-data /var/local/repos
</example>
</sect2>
<sect2>設定 Apache2
<p>
想要用使用者認證來授權存取檔案庫，則添加（或去除注釋）下列內容到 <file>/etc/apache2/mods-available/dav_svn.conf</file> ：
<example>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/local/repos
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt/Location&gt
</example>
接著，使用下面的命令建立使用者認證檔：
<example>
htpasswd2 -c /etc/subversion/passwd some-username
</example>
重新啟動 Apache2，就可以使用 URL http://<var>hostname</var>/repos 來存取新的 subversion 檔案庫了。
</sect2>
</sect1>
<sect1 id="svn-cvs">將 CVS 檔案庫轉移到 Subversion
</sect1>
<sect1 id="svn-usage">Subversion 使用範例
<p>
下面的小節將教你如何在 Subversion 下使用各種命令。

<sect2>建立新的 Subversion 保存檔(archive)
<p>
要建立新的 Subversion 保存檔，請輸入下面的命令：
<example>
$ cd ~/<var>your-project</var>         # 進入你的源碼目錄
$ svn import http://localhost/repos <var>your-project</var> \
  <var>project-name</var> -m "initial project import"
</example>
<p>
這將在你的 Subversion 檔案庫下建立一個名為 <var>project-name</var> 的目錄，用來存放你的專案文件。查看 http://localhost/repos/ 它是否在那兒？
</sect2>

<sect2>使用 Subversion
<p>
用 Subversion 來管理 <var>project-y</var>：
<example>
$ cd                            # 進入工作區域
$ svn co http://localhost/repos/<var>project-y</var>  # 匯出源碼
$ cd <var>project-y</var>
 ... 完成一些工作 ...
$ svn diff                      # 相當於 diff -u repository/ local/  
$ svn revert <var>modified_file</var>      # 取消對文件所做的修改
$ svn ci -m "<var>Describe changes</var>"  # 將你做的修改匯入至檔案庫中
$ vi <var>newfile_added</var>
$ svn add <var>newfile_added</var>
$ svn add <var>new_dir</var>               # 將 new_dir 中的所有文件遞迴地加入檔案庫中
$ svn add -N <var>new_dir2</var>           # 將 new_dir2 中的文件非遞迴地加入檔案庫中
$ svn ci -m "Added <var>newfile_added</var>, <var>new_dir</var>, <var>new_dir2</var>"
$ svn up                        # 從檔案庫中合併最新的版本
$ svn log                       # 顯示所有已提交的修改記錄
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>project-y-branch</var> \
      -m "creating my branch of <var>project-y</var>"  # 建立 <var>project-y</var> 的分支版本
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>proj-y_release1.0</var> \
      -m "<var>project-y</var> 1.0 release"    # 加入 release tag
 ... 注意，分支 (branching) 和標記 (tagging) 是相同的。唯一的不同在分支會提交 (committed) 而標記不會。

 ... 對分支版本做修改 ...

$ # 將分支版本回存至主要版本
$ svn merge http://localhost/repos/<var>project-y</var> \
   http://localhost/repos/<var>project-y-branch</var>
$ svn co -r 4 http://localhost/repos/<var>project-y</var> # 取得第四版本
</example>

</sect2>

</sect1>
</sect>
</chapt>
