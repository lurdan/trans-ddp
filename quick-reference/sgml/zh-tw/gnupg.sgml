<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.22" -->

<chapt id="gnupg">GnuPG

<p>
參考資料：
<list compact>
<item><manref name="gpg" section="1">. 
<item><file>&dochome;gnupg/README.gz</file>
<item><file>&dochome;gnupg-doc/GNU_Privacy_Handbook/</file> 中的 <em>GNU privacy handbook</em> (安裝 <package>gnupg-doc</package> 套件)
</list>

<sect>安裝 GnuPG
<p>
<example>
# gpg --gen-key                   # 產生新的 key
# gpg --gen-revoke <var>my_user_ID</var>     # 產生 <var>my_user_ID</var> 的廢止用 key
# host -l pgp.net | grep www|less # 指出 pgp keyservers
</example>
加入一個預設的穩定 keyserver 到<file>$HOME/.gnupg/gpg.conf</file>檔案內：
<example>
keyserver hkp://subkeys.pgp.net
</example>
必須注意<strong>不能</strong>建立 2 個以上的 sub-keys，如果你這樣做，pgp.net 上的 keyservers 會<strong>廢除</strong>（corrupt）你的 key。使用新版的 <package>gnupg</package> (>1.2.1-2) 來處理這些廢除的 subkeys。參閱 <url id="&gpg-subkeys;">。
<p>
</sect>

<sect>使用 GnuPG
<p>
檔案處理：
<example>
$ gpg  [options]  <var>command  [args]</var>
$ gpg {--armor|-a} {--sign|-s} <var>file</var> # 將 file 簽名，存至文字檔 <var>file</var>.asc
$ gpg --clearsign <var>file</var>              # clear-sign 訊息
$ gpg --clearsign --not-dash-escaped <var>patchfile</var>  # clear-sign patchfile
$ gpg --verify <var>file</var>                 # 驗證 clear-signed <var>file</var>
$ gpg -o <var>file.sig</var> {-b|--detach-sig} <var>file</var> # 建立 detached 簽章
$ gpg --verify <var>file.sig</var> <var>file</var>        # 用 <var>file.sig</var> 驗證 <var>file</var>
$ gpg -o <var>crypt_file</var> {--recipient|-r} <var>name</var> {--encrypt|-e} <var>file</var> 
        # public-key encryption intended for name
$ gpg -o <var>crypt_file</var> {--symmetric|-c} <var>file</var> # 對稱式加密
$ gpg -o <var>file</var> --decrypt crypt_file  # 解密
</example>
</sect>

<sect>管理 GnuPG
<p>
Key 管理：
<example>
$ gpg --edit-key <var>user_ID</var>               # "help"，互動式的說明
$ gpg -o <var>file</var> --exports                # 將所有的 key 匯出至 <var>file</var> 
$ gpg --imports <var>file</var>                   # 匯入 <var>file</var> 中所有的 key
$ gpg --send-keys <var>user_ID</var>              # 將 <var>user_ID</var> 的 key 傳送到 keyserver
$ gpg --recv-keys <var>user_ID</var>              # 從 keyserver 接收 <var>user_ID</var> 的 key
$ gpg --list-keys <var>user_ID</var>              # 列出 <var>user_ID</var> 的 key
$ gpg --list-sigs <var>user_ID</var>              # 列出 <var>user_ID</var> 的 sig.
$ gpg --check-sigs <var>user_ID</var>             # 檢查 <var>user_ID</var> 的 sig.
$ gpg --fingerprint <var>user_ID</var>            # 檢查 <var>user_ID</var> 的 fingerprint
$ gpg --list-sigs | grep '^sig' | grep '[User id not found]' \
  | awk '{print $2}' | sort -u | xargs gpg --recv-keys # 取得未知的 keys
  # 將所有未知的 sigs 更新 key 。
$ gpg --refresh-keys                   # 更新本地端的 keyrin。
</example>
Trust code:
<example>
-         No ownertrust assigned / not yet calculated.
e         計算信任度失敗。
q         計算所需的資訊不足。
n         永不信任這把 key。
m         Marginally trusted.
f         完全信任 (Fully trusted)。
u         極度信任 (Ultimately trusted)。
</example>
下面的命令會將我的 key "<var>A8061F32</var>" 上傳到熱門的 key servers <tt>hkp://subkeys.pgp.net</tt>：
<example>
$ gpg --keyserver hkp://subkeys.pgp.net --send-keys <var>A8061F32</var>
</example>
</sect>

<sect>在應用程式中使用 GnuPG
<p>
<sect1>在 Mutt 中使用 GnuPG
<p>
在 <file>~/.muttrc</file> 中加入下列的內容，則如果你在 index 選單中輸入 `<tt>S</tt>' 的話，將會自動啟動一個低速的 GnuPG。
<example>
macro index S ":toggle pgp_verify_sig\n"
set pgp_verify_sig=no
</example>

<sect1 id="vimgpg">在 Vim 中使用 GnuPG
<p>
將 <url id="&examples;" name="examples subdirectory"> 中的 <file>_vimrc</file> 文件的內容加到 <file>~/.vimrc</file> 就可以自然的執行 GnuPG。

</chapt>
