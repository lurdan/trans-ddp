<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.38"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="vcs">Sistemas de Controle de Versão

<sect id="cvs">Concurrent Versions System (CVS) (Sistema de Versões
Concorrentes)
<p>
Confira <file>/usr/share/doc/cvs/html-cvsclient</file>, 
<file>/usr/share/doc/cvs/html-info</file>,
<file>/usr/share/doc/cvsbook</file> com <prgn>lynx</prgn> ou rode
<tt>info cvs</tt> e <tt>man cvs</tt> para informações detalhadas.

<sect1 id="cvs-inst">Instalando um servidor CVS
<p>
A configuração a seguir permitirá que apenas membros do grupo "src"
submetam ao repositório CVS e apenas membros do grupo "staff"
administrem o cvs, com isto reduzindo a probabilidade de que alguém 
atire no próprio pé.
<example>
# cd <var>/var/lib</var>; umask 002 ; sudo mkdir <var>cvs</var> # [Woody] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=<var>/var/lib/cvs</var>
# cd $CVSROOT
# chown root:src .  # "staff" para maior restrição a projetos novos.
# chmod 3775 .             # Se usou "staff" acima, use 2775 aqui.
# cvs -d <var>/var/lib/cvs</var> init # é mais seguro especificar -d explicitamente aqui!
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect1>

<sect1 id="cvs-examples">Exemplos de sessão CVS
<p>
O que se segue configurará um ambiente shell para acesso ao repositório
CVS.

<sect2>CVS Anônimo (apenas para baixar)
<p>
Acesso remoto somente-leitura:
<example>
$ export CVSROOT=:pserver:<var>anonymous@cvs.sf.net:/cvsroot/qref</var>
$ cvs login
$ cvs -z3 co <var>qref</var>
</example>
</sect2>

<sect2>Uso de servidor CVS local
<p>
Acesso local a partir de uma shell na mesma máquina:
<example>
$ export CVSROOT=<var>/var/lib/cvs</var>
</example>
</sect2>

<sect2>Uso de servidor CVS remoto pserver
<p>
Acesso remoto sem SSH (uso da implementação do protocolo RSH no 
<prgn>cvs</prgn>):
<example>
$ export CVSROOT=:pserver:<var>account@cvs.foobar.com:/var/lib/cvs</var>
$ cvs login
</example>
Este uso é vulnerável a uma tocaia (eavesdropping attack).
</sect2>

<sect2>Uso do CVS remoto via <prgn>ssh</prgn>
<p>
Acesso remoto com SSH:
<example>
$ export CVSROOT=:ext:<var>account@cvs.foobar.com:/var/lib/cvs</var>
</example>
ou para o SourceForge:
<example>
$ export CVSROOT=:ext:<var>account@cvs.sf.net:/cvsroot/qref</var>
</example>
Você pode usar autenticação RSA (<ref id="ssh-rsa">) também. Isto elimina
a espera pela senha (prompt password).
</sect2>

<sect2>Criar um arquivo CVS novo
<p>
Para,
<example>
ITEM              VALOR                    SIGNIFICADO
source tree:      ~/<var>project-x</var>              Todos os códigos-fonte
Project name:     <var>project-x</var>                Nome do projeto
Vendor Tag:       <var>Main-branch</var>              marcador para toda a ramificação
Release Tag:      <var>Release-initial</var>          marcador para um lançamento específico
</example>
Então,
<example>
$ cd ~/<var>projeto-x</var>                 # acesse o diretório fonte
 ... crie a árvore dos fontes ...
$ cvs import -m <var>"Início projeto-x" projeto-x Main-branch Release-initial</var>
$ cd ..; rm -R ~/<var>projeto-x</var>
</example>
</sect2>

<sect2>Trabalhar com CVS
<p>
Trabalhar com <var>projeto-x</var> usando o repositório CVS local:
<example>
$ cd                            # acesse a área de trabalho
$ cvs co <var>projeto-x</var>              # pegue os fontes do CVS para local
$ cd <var>projeto-x</var>
 ... faça mudanças no conteúdo ...
$ cvs diff -u                   # similar ao diff -u repository/ local/
$ cvs up -C <var>arquivo_modificado</var>       # desfaz mudanças em um arquivo
$ cvs ci -m "<var>Descreva modificação</var>"   # salve os fontes locais para o CVS
$ vi <var>arquivonovo_adicionado</var>
$ cvs add <var>arquivonovo_adicionado</var>
$ cvs ci -m "<var>Adicionado arquivonovo_adicionado</var>"
$ cvs up                        # mescle a última versão a partir do CVS
 ... para criar todos os subdiretórios recém criados do CVS, use 
 ... ao invés "cvs up -d -P"
 ... atente para linhas que iniciam com "C <var>nomearquivo</var>"
 ... código não alterado é movido para `.#<var>nomearquivo</var>.versão'
 ... procure "&lt;&lt;&lt;&lt;&lt;&lt;&lt;" e "&gt;&gt;&gt;&gt;&gt;&gt;&gt;" em <var>nomearquivo</var>
$ cvs tag <var>Release-1</var>             # adicione marcador de lançamento
 ... edite mais ...
$ cvs tag -d <var>Release-1</var>          # remova marcador de lançamento
$ cvs ci -m "<var>mais comentários</var>"
$ cvs tag <var>Release-1</var>             # readicione marcador de lançamento
$ cd                            # volte à área de trabalho
$ cvs co -r <var>Release-inicial</var> -d <var>antigo</var> <var>projeto-x</var>
 ... mova a versão original para diretório <var>antigo</var>
$ cd antigo
$ cvs tag -b <var>Release-initial-bugfixes</var> # crie marcador de ramificação (-b)
 ... agora você pode trabalhar na versão antiga (Tag=sticky)
$ cvs update -d -P                         # não cria diretórios vazios
 ... a árvore dos fontes agora tem o marcador de fixação (sticky tag) "Release-initial-bugfixes"
 ... trabalhe nesta ramificação
$ cvs up -d -P # sincronize com arquivos modificados por outros nesta ramificação
$ cvs ci -m "<var>check nesta ramificação </var>"
$ cvs update -kk -A -d -P
 ... remova o marcador de fixação e esqueça do conteúdo
 ... atualize a partir do tronco principal sem expansão de palavra-chave
$ cvs update -kk -d -P -j <var>Release-initial-bugfixes</var>
 ... Mescle a ramificação <var>Release-initial-bugfixes</var> com o tronco
 ... principal sem expansão de palavra-chave. Corrija conflitos com o editor
$ cvs ci -m "<var>mesclando Release-initial-bugfixes</var>"
$ cd
$ tar -cvzf <var>antigo-projeto-x.tar.gz</var> <var>antigo</var>  # arquive, -j para bz2
$ cvs release -d <var>antigo</var>           # remova fonte local (opcional)
</example>
Opções legais que convém lembrar (use-a(s) como primeiro(s) argumento(s)
 para <prgn>cvs</prgn>):
<example>
-n      simula as ações, sem executá-las realmente
-t      exibe mensagens que mostram os passos da atividade do CVS
</example>
</sect2>

<sect2>Exportar arquivos a partir do CVS
<p>
Para obter a última versão do CVS, use "tomorrow":
<example>
$ cvs ex -D tomorrow <var>nome_módulo</var>
</example>
</sect2>

<sect2>Administrar o CVS
<p>
Adicione apelidos a um projeto (servidor local):
<example>
$ su - admin           # um membro do staff
$ export CVSROOT=<var>/var/lib/cvs</var>
$ cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "<var>px</var> -a <var>projeto-x</var>" &gt;&gt;modules
$ cvs ci -m "<var>Agora px é um apelido para projeto-x</var>"
$ cvs release -d .
$ exit                 # ou Ctrl-D para voltar a partir de su
$ cvs co -d <var>projeto</var> <var>px</var> 
 ... baixa <var>projeto-x</var> (alias:<var>px</var>) a partir do CVS 
 ... para o diretório do projeto
$ cd projeto
 ... faça mudanças no conteúdo ...
</example>
</sect2>

<sect1 id="cvs-trouble">Resolvendo problemas do CVS

<sect2>Permissões de arquivo no repositório
<p>
CVS não sobrescreverá o atual arquivo do repositório, antes o substituirá
por outro. Assim, <em>permissão de escrita no diretório do repositório</em>
é algo crítico. Para cada novo repositório criado, se necessário
 rode os seguintes comandos para ter certeza desta condição.
<example>
# cd <var>/var/lib/cvs</var>
# chown -R root:src <var>repository</var>
# chmod -R ug+rwX   <var>repository</var>
# chmod    2775     <var>repository</var>  # se necessário, também o subdiretório
</example>
</sect2>

<sect2>Bit de execução
<p>
O bit de execução de um arquivo é mantido quando baixado. Sempre que 
encontrar problemas com permissão de execução em arquivos baixados, mude
 as permissões do arquivo no repositório CVS com o seguinte comando.
<example>
# chmod ugo-x <var>nomedoarquivo</var>
</example>
</sect2>

</sect1>

<sect1 id="cvs-short">Comandos CVS
<p>
Aqui estão os comandos CVS com suas abreviações
<example>
{add|ad|new} [-k kflag] [-m 'mensagem'] arquivos...
{admin|adm|rcs} [opções-rcs] arquivos...
{annotate|ann} [opções] [arquivos...]
{checkout|co|get} [opções] módulos...
{commit|ci|com}   [-lnR]  [-m  'mensagem_log'  |  -f  arquivo] \
        [-r revisão] [arquivos...]
{diff|di|dif} [-kl] [opções_rcsdiff] [[-r rev1 | -D data1] \
        [-r rev2 |  -D data2]] [arquivos...]
{export|ex|exp} [-flNn] -r rev|-D data [-d dir] [-k kflag] módulo...
{history|hi|his} [-report] [-flags] [-options args] [arquivos...]
{import|im|imp} [-options] repositório vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] opções-rlog [arquivos...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] módulos...
{release|re|rel} [-d] diretórios...
{remove|rm|delete} [-lR] [arquivos...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  marcador  |  -D  data] \
         marcador_simbólico módulos...
{status|st|stat} [-lR] [-v] [arquivos...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r marcador | -D data]  [-f] \
         marcador_simbólico [arquivos...]
{update|up|upd} [-AdflPpR] [-d] [-r marcador|-D data] arquivos...
</example>
</sect1>

<sect id="svn">Subversion
<p>
Subversion é a próxima geração em sistemas de controle de versão. E
pretende-se que substitua o CVS. Os desenvolvedores o consideram
atualmente em estágio "alpha", embora provavelmente seja estável para
muitos usos. Quando este texto foi escrito, Subversion estava disponível
na Debian <tt>unstable</tt> apenas.
<sect1 id="svn-inst">Instalando um servidor Subversion
<p>
O meta-pacote <package>subversion-server</package> depende dos pacotes
<package>libapache2-dav-svn</package> e 
<package>subversion-tools</package>) para configurar um servidor.
<sect2>Configurando um repositório
<p>
Atualmente, o pacote <package>subversion</package> não configura
automaticamente um repositório. Isto deve ser feito manualmente. Uma
localização possível para o repositório é em <file>/var/local/repos</file>.
<p>
Crie o diretório:
<example>
# mkdir -p /var/local/repos
</example>
Crie o banco de dados do repositório:
<example>
# svnadmin create /var/local/repos
</example>
Torne o repositório passível de escrita pelo servidor WWW:
<example>
# chown -R www-data:www-data /var/local/repos
</example>
</sect2>
<sect2>Configurando Apache2
<p>
Para permitir acesso ao repositório via autenticação de usuário, adicione
(ou descomente) o seguinte a
<file>/etc/apache2/mods-available/dav_svn.conf</file>:
<example>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/local/repos
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt/Location&gt
</example>
Então, crie o arquivo de autenticação do usuário com o comando:
<example>
htpasswd2 -c /etc/subversion/passwd algum-nome-de-usuario
</example>
Reinicie Apache2, e seu novo repositório Subversion será acessível através
da URL http://<var>hostname</var>/repos.
</sect2>
</sect1>
<sect1 id="svn-cvs">Movendo um repositório CVS para Subversion
</sect1>
<sect1 id="svn-usage">Exemplos de uso do Subversion
<p>
As seções seguintes ensinam como usar diferentes comandos em Subversion.

<sect2>Criar um novo repositório Subversion
<p>
Para criar um novo repositório Subversion, digite o seguinte:
<example>
$ cd ~/<var>seu-projeto</var>          # vá para seu diretório fonte
$ svn import http://localhost/repos <var>seu-projeto</var> \
  <var>nome-do-projeto</var> -m "importação inicial do projeto"
</example>
<p>
Isso cria um diretório chamado <var>nome-do-projeto</var> em seu
repositório Subversion que contém os arquivos de seu projeto. Olhe em
http://localhost/repos e veja se estão lá.
</sect2>

<sect2>Trabalhando com Subversion
<p>
Trabalhando com <var>projeto-y</var> usando Subversion:
<example>
$ cd                              # vá para a área de trabalho
$ svn co http://localhost/repos/<var>projeto-y</var>  # Importe os fontes
$ cd <var>projeto-y</var>
 ... faça alguma coisa ...
$ svn diff                        # similar a diff -u repositório/ local/
$ svn revert <var>arquivo_modificado</var>   # desfaz mudanças em um arquivo   
$ svn ci -m "<var>Descreva alterações</var>" # exporte suas alterações ao repositório
$ vi <var>arquivonovo_adicionado</var>
$ svn add <var>arquivonovo_adicionado</var>
$ svn add <var>novo_dir</var>                # adiciona recursivamente todos arquivos em novo_dir
$ svn add -N <var>novo_dir2</var>            # adiciona o diretório não recursivamente
$ svn ci -m "Adicionado <var>arquivonovo_adicionado</var>, <var>novo_dir</var>, <var>novo_dir2</var>
$ svn up                          # mescla com última versão do repositório
$ svn log                         # exibe todas as mudanças enviadas
$ svn copy http://localhost/repos/<var>projeto-y</var> \
      http://localhost/repos/<var>projeto-y-ramo</var> \
      -m "criando nova ramificação do <var>projeto-y</var>" # ramificando <var>projeto-y</var>
$ svn copy http://localhost/repos/<var>projeto-y</var> \
      http://localhost/repos/<var>proj-y_versão1.0</var> \
      -m "<var>projeto-y</var> versão 1.0"   # adicionado marcador de lançamento
 ... note que a ramificação e marcação são os mesmos. A única diferença
 ... é que ramos (branches) são enviados (committed) enquanto
 ... marcadores (tags) não são.

 ... faça modificações no ramo ...

$ # mesclar cópia ramificada de volta na cópia principal
$ svn merge http://localhost/repos/<var>projeto-y</var> \
   http://localhost/repos/<var>projeto-y-ramo</var>
$ svn co -r 4 http://localhost/repos/<var>projeto-y</var> # importa revisão 4
</example>

</sect2>

</sect1>
</sect>
</chapt>
