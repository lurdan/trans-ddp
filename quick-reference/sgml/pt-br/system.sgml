<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.62"  -->

<chapt id="system">Fundamentos Debian

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
Este capítulo fornece informação fundamental sobre o sistema Debian para
não-desenvolvedores. Para informação oficial, consulte :
<p>
<list compact>
<item>Manual de Políticas Debian
<item>Referência do Desenvolvedor Debian
<item>Guia do Novo Desenvolvedor Debian
</list>
listados em <ref id="references">.

<p>
Caso você esteja procurando por explicações "como-fazer" menos
detalhadas, pule diretamente para <ref id="package"> ou para outros
capítulos relevantes.
<p>
Este capítulo é baseado em documentos obtidos da "FAQ Debian", altamente
reorganizados para permitir que o administrador de sistemas Debian comum
possa começar.

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">Os repositórios Debian

<sect1 id="dirtree">Estruturas de diretório

<p>O software que foi empacotado para o &debian; está disponível em uma
das diversas árvores de diretórios em cada
<url id="&mirror-site;" 
     name="site espelho Debian">
através de FTP ou HTTP.

<p>Os seguintes diretórios podem ser encontrados em cada site espelho
Debian sob o diretório <tt>debian</tt> :
<taglist>
  <tag><file>dists/</file>:
    <item>Este diretório contém as "distribuições" e era a maneira
    canônica de acessar pacotes atuais disponíveis nas distribuições
    e pré-distribuições Debian. Alguns pacotes antigos, 
    arquivos <file>Contents-*.gz</file>, e
    arquivos <file>Packages.gz</file> ainda estão aqui.
  <tag><file>pool/</file>:
    <item>A nova localização física para todos os pacotes das
    distribuições e pré-distribuições Debian.
  <tag><file>tools/</file>:
    <item>Utilitários DOS para criação de discos de partida,
    particionamento de seu disco, compactação/descompactação de arquivos e
    inicialização do Linux.
  <tag><file>doc/</file>:
    <item>A documentação básica do Debian, como o FAQ, instruções do sistema
          de relatos de bugs, etc.
  <tag><file>indices/</file>:
    <item>O arquivo Maintainers e os arquivos override.
  <tag><file>project/</file>:
    <item>em sua maioria materiais somente para desenvolvedores, como :
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>Este diretório contém pacotes e ferramentas que ainda estão
        sendo desenvolvidos, e ainda estão em estágio alpha. Os usuários
        não deveriam estar usando pacotes daqui porque os mesmos podem
        ser perigosos e causarem danos mesmo para os mais experientes.
      <tag><file>project/orphaned/</file>:
        <item>Pacotes que foram abandonados por seus antigos mantenedores
        e retirados da distribuição.
    </taglist>
</taglist>

<sect1 id="dists">Distribuições Debian

<p>Nomalmente existem três distribuições Debian no diretório
<file>dists</file>. Elas são nomeadas a distribuição <tt>stable</tt>, a distribuição
<tt>testing</tt> e a distribuição <tt>unstable</tt>. Algumas vezes existe também uma
distribuição <tt>frozen</tt>. Cada distribuição é
definida como uma ligação simbólica para a diretório real com um 
codinome no diretório <file>dists</file>.

<sect1 id="stable">A distribuição <tt>stable</tt>

<p>As entradas de pacotes para a distribuição <tt>stable</tt>,
&stabledebian;, são mantidas no diretório <file>stable</file> (ligação
simbólica para <file>&stablecodenamedir;/</file>):
<list>
  <item><file>stable/main/</file>:
  Este diretório contém os pacotes que formalmente constituem a versão
  lançada mais recente do sistema &debian;.

  <p>Estes pacotes todos seguem as <url name="Linhas Guias Debian para
  o Software Livre (DFSG)" id="&social-contract;#guidelines"> (também
  disponível como <file>&f-social-contract;</file> instalado por
  <package>&p-social-contract;</package>) e são todos
  livremente utilizáveis e livremente distribuídos.

  <item><file>stable/non-free/</file>: Este diretório contém pacotes da
  distribuição que são restritos de alguma forma que requer que os
  distribuidores tenham cuidado especial com requerimentos de direitos
  de cópia especificados.

  <p>Por exemplo, alguns pacotes possuem licenças que proíbem sua
  distribuição comercialmente. Outros podem ser redistribuídos mas são
  de fato shareware e não software livre. As licenças de cada um desses
  pacotes devem ser estudadas, e possivelmente negociadas, antes que estes
  pacotes possam ser incluídos em qualquer redistribuição (por exemplo,
  em um CD-ROM).

  <item><file>stable/contrib/</file>: Este diretório contém pacotes que
  atendem aos requerimentos da DFSG e podem ser <strong>livremente
  distribuídos</strong>, mas de alguma forma dependem de um
  pacote que <strong>não</strong> é livremente distribuível  e
  portanto disponível somente na seção non-free.
</list>
Agora, além das localizações acima, os pacotes físicos novos são localizados
sob o diretório <file>pool</file> (<ref id="pools">).

<p>O estado atual dos bugs da distribuição <tt>stable</tt> é relatado
na página web <url id="&stable-problems;" name="Problemas da Stable">.

<sect1 id="testing">A distribuição <tt>testing</tt>

<p>As entradas de pacotes para a distribuição <tt>testing</tt>,
&testingdebian;, são gravadas no diretório <file>testing</file> (ligação
simbólica para <file>&testingcodenamedir;/</file>)  depois que os mesmos
tenham passado por um certo nível de testes na <tt>unstable</tt>. Agora,
além das localizações acima, novos pacotes físicos estão localizados sob o
diretório <file>pool</file> (<ref id="pools">). Existem também os
subdiretótios <file>main</file>, <file>contrib</file>, e
<file>non-free</file> na <file>testing</file>,  que têm as mesmas
funções como na <tt>stable</tt>.

<p>Estes pacotes devem estar sincronizados em todas as arquiteturas onde
eles foram compilados e não devem ter dependências que façam com que não
seja possível instalá-los; eles também têm que possuir menos bugs críticos
ao lançamento do que as versões atualmente na <tt>unstable</tt>. Dessa
forma, esperamos que a <tt>testing</tt> esteja sempre perto de ser uma
candidata ao lançamento. Maiores detalhes sobre o mecanismo da testing
estão disponíveis em <url id="&testing-notes;">.

<p>O último estado da distribuição <tt>testing</tt> está relatado nestes
sites :
<list compact>
<item><url id="&update-excuses;" 
         name="desculpas de atualização">
<item><url id="&testing-problems;" 
         name="problemas da testing">
<item><url id="&release-critical;" 
         name="bugs críticos ao lançamento">
<item><url id="&qa-base-bugs;" 
         name="bugs do sistema básico">
<item><url id="&qa-standard-bugs;" 
         name="bugs em pacotes standard e em tarefas">
<item><url id="&qa-bugs;" 
         name="outros bugs e notas sobre festas de matança de bugs">
</list>

<sect1 id="unstable">A distribuição <tt>unstable</tt>

<p>As entradas de pacotes para a distribuição <tt>unstable</tt>, sempre com o
codinome "Sid", são gravadas no diretório <file>unstable</file> (ligação
simbólica para <file>sid/</file>) depois que é feito o upload dos mesmos
para o repositório Debian, e permanecem por lá até que são movidos
para  <file>testing/</file>. Novos pacotes físicos estão localizados sob o
diretório <file>pool</file> (<ref id="pools">). Existem também subdiretórios
<file>main</file>, <file>contrib</file> e <file>non-free</file> em
<file>unstable/</file>, que têm as mesmas funções como na
<file>stable/</file>.

<p>A distribuição <tt>unstable</tt> contém um snapshot do sistema de
desenvolvimento mais recente. Os usuários podem usar e testar estes
pacotes, mas são alertados de seu estado de preparação. A vantagem de
usar a distribuição <tt>unstable</tt> é que você está sempre em dia
no projeto de software &debian; &mdash; mas se ele quebra, você tem
que arrumar as coisas você mesmo :-)

<p>O estado atual dos bugs da distribuição <tt>unstable</tt> é relatado
na página web <url id="&unstable-problems;" name="Problemas da Unstable">.

<!-- Above was enough
<sect1 id="sid">The "sid" distribution

<p><em>sid</em> or <em>unstable</em> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <em>testing</em>,
in order to be released in <em>stable</em> later on. sid contains packages
for both released and unreleased architectures.

<p>The name "sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">A distribuição <tt>frozen</tt>

<p>Quando a distribuição <tt>testing</tt> está madura o bastante, ela
é congelada, o que significa que nenhum código novo é aceito, somente
correções de bugs, caso necessário. Uma nova árvore testing também é
criada no diretório <file>dists</file> e lhe é atribuído um novo nome. A
distribuição frozen passa por alguns meses de testes, com atualizações
intermitentes e congelamentos profundos chamados "ciclos de testes". 

<p>Mantemos um registro dos bugs na distribuição frozen que podem
atrasar o lançamento de um pacote ou bugs que possam atrasar o lançamento
por completo. Uma vez que essa contagem de bugs seja minimizada até um
valor aceitável, a distribuição frozen se torna estável, é lançada, e a
distribuição stable anterior se torna obsoleta (e é movida para o
repositório).

<sect1 id="codenames">Codinomes das distribuições Debian

<p>Nomes físicos de diretórios no diretório <file>dists/</file>, como
<file>&stablecodenamedir;/</file> e <file>&testingcodenamedir;/</file>, são
somente "codinomes". Quando uma distribuição &debian; está no estágio de
desenvolvimento, ela não possui número de versão e sim um codinome. O
propósito destes codinomes é tornar o espelhamento das distribuições
&debian; mais fácil (caso um diretório como <file>unstable</file> seja de
repente mudado para <file>stable/</file>, o download de uma porção de coisas
teria que ser feito de novo desnecessariamente).

<p>Atualmente, <file>stable</file> é uma ligação simbólica para
<file>&stablecodenamedir;/</file>  e <tt>testing</tt> é uma ligação
simbólica para <file>&testingcodenamedir;/</file>. Isto significa que
<tt>&stablecodename;</tt> é a atual distribuição estável e
<tt>&testingcodename;</tt> é a atual distribuição de testes.

<p><file>unstable</file> é uma ligação simbólica permanente para
<file>sid/</file>, uma vez que Sid é sempre a distribuição instável. <!--
(consulte <ref id="sid">).-->

<sect1 id="oldcodenames">Codinomes usados no passado

<p>Outros codinomes que já foram usados são : 
"Buzz" para a versão 1.1, 
"Rex" para a versão 1.2, 
"Bo" para as versões 1.3.x, 
"Hamm" para a versão 2.0,
"Slink" para a versão 2.1, 
"Potato" para a versão 2.2,
"Woody" para a versão 3.0, 
e "Sarge" para a versão 3.1.

<sect1 id="sourceforcodenames">A origem dos codinomes

<p>Até agora eles foram personagens tirados do filme <em>Toy Story</em>
feito pela Pixar.
<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) era o homem do espaço,
  <item><strong>Rex</strong> era o tiranossauro,
  <item><strong>Bo</strong> (Bo Peep) era a garota que cuidava do rebanho,
  <item><strong>Hamm</strong> era o porquinho cofre,
  <item><strong>Slink</strong> (Slinky Dog) era o cachorro de brinquedo,
  <item><strong>Potato</strong> era, claro, o Sr. Cabeça de Batata,
  <item><strong>Woody</strong> era o cowboy,
  <item><strong>Sarge</strong> era o líder dos Homens do Exército de
  Plástico Verde,  
  <item><strong>Etch</strong> (Etch-a-Sketch) era o blackboard,
  <item><strong>Sid</strong> era o garoto da porta ao lado que destruía os brinquedos.
</list>
<!--
  more info in http://www.pixar.com/featurefilms/ts/index.html
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">O diretório <file>pool</file>

<p>Historicamente, os pacotes eram mantidos em um subdiretório de
<file>dists</file> correspondendo à distribuição que os continha. Isso acabou
trazendo vários problemas, como um alto consumo de banda nos espelhos
quando mudanças maiores eram feitas.

<p>Os pacotes são agoras mantidos em uma grande "piscina" (pool), estruturada de
acordo com o nome do pacote fonte. Para que isso seja gerenciável, a
piscina é subdividida por seções (<tt>main</tt>, <tt>contrib</tt> e
<tt>non-free</tt>) e pela primeira letra do nome do pacote fonte. Estes
diretórios contêm diversos arquivos: os pacotes binários para cada
arquitetura, e os pacotes fontes a partir dos quais os pacotes binários
foram gerados.

<p>Você pode descobrir onde cada pacote é colocado executando um
comando como <tt>apt-cache showsrc <var>nomemeupacote</var></tt> e
olhando na linha "Directory:". Por exemplo, os pacotes do
<package>apache</package> estão armazenados em
<file>pool/main/a/apache/</file>. Como há muitos pacotes <tt>lib*</tt>,
esses são tratados especialmente: por exemplo, os pacotes
<package>libpaper</package> estão armazenados em 
<file>pool/main/libp/libpaper/</file>.

<p>Os diretórios <file>dists</file> ainda são usados pelos arquivos de índice
usados por programas como o <prgn>apt</prgn>. Além disso, no momento que escrevo,
distribuições antigas não foram convertidas para usar piscinas portanto
você verá caminhos contendo nomes de distribuições como <tt>potato</tt> ou
<tt>woody</tt> no campo "Diretório" do cabeçalho.

<p>Normalmente, você não terá que se preocupar com isto, uma vez que o
novo <prgn>apt</prgn> e provavelmente o antigo <tt>dpkg-ftp</tt> (consulte
<ref id="howtocurrent">) irão gerenciar isso sem problemas. Caso você
queira mais informações, veja a <url id="&pool-faq;"
name="RFC: implementation of package pools">.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Notas históricas sobre a Sid

<p>Quando a atual Sid não existia, a <!--FTP removido -->
organização do site do repositório Debian tinha uma grande falha: existia
uma pressuposição de que quando uma arquitetura era criada no
<file>unstable/</file>
atual, ela seria lançada quando esta distribuição virasse a nova
<tt>stable</tt>. Para muitas arquiteturas esse não era o caso, e como
resultado todos aqueles diretórios tiveram de ser movidos na época de
lançamento. Isto era impraticável pois a movimentação comeria muita banda.

<p>Os administradores do repositório resolveram este problema por diversos
anos colocando binários para arquiteturas não lançadas em um diretório
especial chamado <file>sid</file>. Para aquelas arquiteturas ainda não
lançadas, a primeira vez que as mesmas foram lançadas existia uma ligação
do atual <file>stable/</file> para <file>sid/</file>, e a partir de então elas eram
criadas dentro da árvore <file>unstable/</file> como de costume. Este layout
era de certa forma confuso para os usuários.

<p>Com o advento das piscinas de pacotes (consulte <ref id="pools">)
durante o desenvolvimento da distribuição Woody, pacotes binários
começaram a ser armazenados em uma localização canônica na piscina, não
importando a distribuição, assim lançar uma distribuição não mais causava
grade consumo de banda nos espelhos (existe, porém, uma porção de consumo
gradual de banda durante o processo de desenvolvimento).

<sect1 id="incoming">Pacotes enviados para <file>incoming/</file>
<p>
Os pacotes enviados estão primeiro localizados em <url id="&incoming;">
antes de serem checados para assegurar que eles realmente vieram de um
desenvolvedor Debian (e são colocados no subdiretório <file>DELAYED</file> caso
tenham sido enviados por um não-desenvolvedor (Non-Mantainer Upload -
NMU)). Uma vez por dia, eles são movidos
de <file>incoming/</file> para <file>unstable/</file>.
<p>
Em uma emergência, você pode querer instalar pacotes de <file>incoming/</file>
antes que eles atinjam <file>unstable/</file>.
</sect1>

<sect1 id="snapshot">Obtendo um pacote antigo
<p>
<p>Enquanto a maioria das distribuições Debian atuais são mantidas sob o
diretório <file>debian</file> em cada <url id="&mirror-site;" name="site
espelho Debian">, repositórios para
distribuições Debian mais antigas como a Slink são mantidos em <url
id="&archivehome;"> ou sob o diretório <file>debian-archive</file> em cada
site espelho Debian.
<p>
Os pacotes antigos da <tt>testing</tt> e da <tt>unstable</tt> podem ser
encontrados em <url id="&snapshothome;">.

</sect1>

<sect1 id="archsections">Seções de Arquiteturas
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>Dentro de cada árvore maior de diretórios (<file>dists/stable/main</file>,
<file>dists/stable/contrib</file>, <file>dists/stable/non-free</file>, 
<file>dists/unstable/main/</file>, etc.), as entradas do pacote binário
residem em subdiretórios cujos nomes indicam a arquitetura do chip
para o qual eles foram compilados.

<list>
  <item><file>binary-all/</file>, para pacotes que são independentes de
  arquitetura. Estes incluem, por exemplo, scripts Perl ou documentação
  pura.
  <item><file>binary-<var>plataforma</var>/</file>, para pacotes que executam
  em uma plataforma binária particular.
  <!-- Yes I simplified this -->
</list>

<p>Por favor note que os pacotes binários atuais para a <tt>testing</tt> e
<tt>unstable</tt> não mais residem nestes diretórios, mas em um diretório
de alto nível <file>pool</file>. Os arquivos de índice (<file>Packages</file>
e <file>Packages.gz</file>) foram mantidos, porém, para compatibilidade
anterior.

<p>Para conhecer as arquiteturas binárias suportadas atualmente, consulte
as Notas de Lançamento para cada distribuição. Elas podem ser localizadas
nos sites das Notas de Lançamento para a <url id="&stable-release;"
name="stable"> e para a <url id="&testing-release;" name="testing">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">O código-fonte

<p>O código-fonte está incluído para tudo no sistema Debian. Além disso,
os termos das licenças da maioria dos programas no sistema
<strong>requerem</strong> que o código-fonte seja distribuído junto com
os programas, ou que uma oferta para fornecer o código-fonte acompanhe os
programas.

<p>Normalmente o código-fonte é distribuído nos diretórios
<file>source</file>, os quais são paralelos a todos os diretórios de binários
para arquiteturas específicas ou, mais recentemente, no diretório
<tt>pool</tt> (consulte <ref id="pools">). Para obter o código-fonte sem
ter estar familiarizado com a estrutura do repositório Debian <!-- FTP-->,
tente um comando como <tt>apt-get source <var>meunomedepacote</var></tt>.

<p>Alguns pacotes, notavelmente <package>pine</package>, estão somente
disponíveis como pacotes fonte devido a suas limitações de licenciamento.
(Recentemente o pacote <package>pine-tracker</package> foi fornecido para
facilitar a instalação do Pine.) Os procedimentos descritos em
<ref id="port"> e <ref id="packaging"> fornecem meios para construir um
pacote manualmente.

<p>O código-fonte pode ou não estar disponível para pacotes nos diretórios
<file>contrib</file> e <file>non-free</file>, os quais não são formalmente
parte do sistema Debian.

<sect id="pkg-basics">O sistema de gerenciamento de pacotes Debian

<sect1 id="package-basics">Visão Geral dos pacotes Debian

<p>Pacotes geralmente contêm todos os arquivos necessários para
implementar um conjunto de comandos relacionados ou recursos. Existem dois
tipos de pacotes Debian :
<list>
  <item><strong>Pacotes binários</strong>, os quais contém executáveis,
  arquivos de configuração, páginas de manual/info, informação de
  copyright e outra documentação. Estes pacotes são distribuídos em um
  formato de arquivo específico Debian (consulte <ref id="deb-format">);
  eles são normalmente identificados por terem uma extensão de arquivo
  <tt>.deb</tt>. Pacotes binários podem ser desempacotados usando o
  utilitário Debian <tt>dpkg</tt>; detalhes são dados em sua página de
  manual.
  
  <item><strong>Pacotes fonte</strong>, os quais consistem de um arquivo
  <tt>.dsc</tt> descrevendo o pacote fonte (incluindo os nomes dos
  arquivos a seguir), um arquivo <tt>.orig.tar.gz</tt> que contém o fonte
  original não modificado em formato tar e compactado com o gzip, e
  normalmente um arquivo <tt>.diff.gz</tt> que contém as mudanças 
  específicas do Debian feitas em relação ao fonte original. O utilitário
  <tt>dpkg-source</tt> empacota e desempacota arquivos fonte Debian;
  detalhes são fornecidos em sua página de manual.
</list>

<p>A instalação de software pelo sistema de pacotes utiliza "dependências"
que são cuidadosamente especificadas pelos mantenedores dos pacotes. Estas
dependências estão documentadas no arquivo <file>control</file> associado a
cada pacote. Por exemplo, o pacote contendo o compilador GNU C
(<package/gcc/) "depende" do pacote <package/binutils/ que inclui o
ligador e o montador. Caso um usuário tente instalar o <package/gcc/ sem
ter instalado primeiro o <package/binutils/, o sistema de gerenciamento
de pacotes (dpkg) emitirá uma mensagem de erro dizendo que ele precisa
também do <package/binutils/ e parará de instalar o <package/gcc/. (Porém,
esta facilidade pode ser circulada pelo usuário insistente, consulte
<manref name="dpkg" section="8">.) Para detalhes adicionais, consulte
<ref id="depends"> abaixo.

<p>As ferramentas de empacotamento Debian podem ser usadas para :
<list>
  <item>manipular e gerenciar pacotes ou partes de pacotes,
  <item>auxiliar o usuário na separação de pacotes que devem ser
  transmitidos através de uma mídia de tamanho limitado, como disquetes,
  <item>auxiliar desenvolvedores na construção de repositórios de pacotes, e
  <item>auxiliar usuários na instalação de pacotes que se encontram em
  um site repositório Debian<!--FTP-->.
</list>

<sect1 id="deb-format">Formato de pacotes Debian <!--binary-->

<p>Um "pacote" Debian, ou um arquivo Debian, contém os arquivos
executáveis, bibliotecas e documentação associada a um programa em
particular ou a uma suíte ou conjunto de programas relacionados.
Normalmente, um arquivo Debian tem um nome de arquivo finalizando
em <tt>.deb</tt>.
<footnote>
<!-- Below added by Osamu based on a message posted by Colin Watson -->
<p>O projeto <prgn>debian-installer</prgn> introduziu nomes de arquivos de
pacotes que terminam em <tt>.udeb</tt>. Resumidamente, isso é um formato
micro-<tt>.deb</tt> que não precisa seguir a política Debian exatamente,
faltando conteúdos como documentação e é dedicado a ser usado apenas pelo
<prgn>debian-installer</prgn>, o novo instalador Debian que está sendo
desenvolvido para o lançamento do Sarge. Os formatos de arquivo
<tt>.deb</tt> e <tt>.udeb</tt> são idênticos. O programa <prgn>udpkg</prgn>
usado para manipular pacotes <tt>.udeb</tt> tem capacidade mais limitada que
o <prgn>dpkg</prgn> padrão e suporta menos relacionamentos entre pacotes. A
diferença no nome é porque os mantenedores de repositórios Debian não
estavam contentes com <tt>.deb</tt>s no repositório que não seguiam a política, então
um nome diferente foi escolhido para destacar isso e diminuir a
possibilidade das pessoas instalá-los inconscientemente em sistemas reais.
Os <tt>.udeb</tt>s são usados em um ramdisk inicial durante a instalação
básica apenas para criar um sistema Debian muito restrito.
</footnote>

<p>Os detalhes do formato de pacote binário Debian estão descritos na
página de manual <manref name="deb" section="5">. Devido a este formato
interno estar sujeito a mudanças (entre versões maiores do &debian;),
sempre utilize o <manref name="dpkg-deb" section="1"> para manipular
arquivos <tt>.deb</tt>.

<!-- Below added by Osamu XXX Not sure but should be right -->

<p>Pelo menos para a distribuição Sarge, todos os
arquivos Debian são manipuláveis pelos comandos Unix padrões
<prgn>ar</prgn> e <tt>tar</tt>, mesmo quando comandos dpkg não estão
disponíveis.


<sect1 id="pkgname">Convenções de nomenclatura para nomes de arquivos de pacotes Debian
<!--
Why are Debian package file names so long? 
-->
<p>Os nomes de arquivos de pacotes Debian <!--binary--> seguem a seguinte
convenção :
<example>
<var>foo</var>_<var>NúmeroDeVersão</var>-<var>NúmeroDeRevisãoDebian</var>.deb
</example>
onde <var>foo</var> representa o nome do pacote. Como uma checagem, pode-se
determinar o nome do pacote associado a um arquivo Debian em particular
(arquivo <tt>.deb</tt>) em uma das seguintes maneiras :
<list>
  <item>inspecione o arquivo "Packages" no diretório onde o mesmo foi
  armazenado em um site repositório Debian <!--FTP-->. Este arquivo
  contém uma estrofe descrevendo cada pacote; o primeiro campo de cada
  estrofe é o nome formal do pacote.
  
  <item>use o comando <tt>dpkg --info <var>foo_VVV-RRR</var>.deb</tt>
  (onde <var>VVV</var> e <var>RRR</var> são a versão e a revisão do
  pacote em questão, respectivamente).  Isto exibe, entre outras
  coisas, o nome do pacote do arquivo sendo desempacotado.
</list>

<p>O componente <var>VVV</var> é o número de versão especificado pelo
desenvolvedor original (upstream). Não existem padrões ditando números de
versão, portanto eles podem ter formatos tão diferentes como "19990513"
e "1.3.8pre1".

<p>O componente <var>RRR</var> é um número de revisão Debian e é
especificado pelo desenvolvedor Debian (ou um usuário individual caso o
mesmo escolha construir o pacote ele mesmo). Este número corresponde ao
nível de revisão do pacote Debian; portanto, um novo nível de revisão
geralmente significa mudanças no Makefile Debian (<file>debian/rules</file>),
no arquivo de controle Debian (<file>debian/control</file>), nos scripts de
instalação ou remoção (<file>debian/p*</file>) ou nos arquivos de configuração
usados pelo pacote.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Preservação da configuração local
<!--
What is a Debian conffile
-->
<p>A preservação dos arquivos configuráveis pelo usuário é habilitada
através do mecanismo "conffiles" do &debian;. Arquivos de configuração do
usuário (normalmente colocados em <file>/etc/</file>) são especificados
no <file>conffiles</file> dentro do sistema de pacotes Debian. O sistema
de gerenciamento de pacotes garante a não sobreescrita destes arquivos
quando o pacote é atualizado.
<!--
<p>Conffiles is a list of configuration files (usually placed in <tt>/etc</tt>)
that the package management system will not overwrite when the package is
upgraded. This ensures that local values for the contents of these files
will be preserved, and is a critical feature enabling the in-place upgrade
of packages on a running system.
-->
<p>Para determinar exatamente quais arquivos são preservados durante uma
atualização, execute :
  <example>dpkg --status <var>pacote</var></example>
e olhe em "Conffiles:".

<p>
Detalhes sobre o conteúdo de um arquivo <tt>confffiles</tt> Debian são
fornecidos no Manual de Políticas Debian, seção 11.7 (consulte
<ref id="references">).

<sect1 id="maintscripts">Scripts de manutenção Debian
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Os scripts de manutenção Debian são scripts executáveis que são
automaticamente executados antes ou depois que um pacote é instalado.
Junto com um arquivo de nome <file>control</file>, todos esses arquivos
são parte da seção "control" de um arquivo Debian.

<p>Os arquivo individuais são:
<taglist>
<tag/preinst/
  <item>Este script é executado antes que seu pacote seja desempacotado de
  seu arquivo Debian (<tt/.deb/). Muitos scripts "preinst" param serviços
  para os pacotes que estão sendo atualizados até que sua instalação ou
  atualização esteja completa (seguindo a execução com sucesso do script
  "postinst").

<tag/postinst/
  <item>Este script tipicamente completa qualquer configuração requerida
  de um pacote uma vez que o mesmo tenha sido desempacotado de seu arquivo
  Debian (<tt/.deb/). Geralmente, scripts 'postinst' fazem perguntas aos
  usuários e/ou avisam o usuário que caso o mesmo aceite valores padrões
  ele deverá se lembrar de voltar e reconfigurar o pacote conforme a
  necessidade.
  Muitos scripts "postinst" executam então quaisquer comandos necessários
  para iniciar ou reiniciar um serviço uma vez que o novo pacote foi
  instalado ou atualizado.  

<tag/prerm/
  <item>Este script tipicamente pára quaisquer daemons que estão
  associados com um pacote. Ele é executado antes da remoção de arquivos
  associados com um pacote.

<tag/postrm/
  <item>Este script tipicamente modifica ligações ou outros arquivos
  associados com um pacote e/ou remove arquivos criados pelo pacote.
  (Consulte também <ref id="virtual">.)
</taglist>

<p>Atualmente todos os arquivos de controle podem ser encontrados no
<file>/var/lib/dpkg/info</file>. Os arquivos relevantes ao pacote
<tt>foo</tt> iniciam com o nome "foo" e possuem extensões de arquivos
"preinst", "postinst", etc, de acordo. O arquivo <tt>foo.list</tt> neste
diretório lista todos os arquivos que foram instalados com o pacote
<tt>foo</tt>. (Note que a localização destes arquivos é algo interno do
dpkg, e pode estar sujeita a mudanças.)

<sect1 id="priority">Prioridade de pacotes
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->

<p>A cada pacote Debian é atribuído uma <strong>prioridade</strong> pelos
mantenedores da distribuição, como um auxílio ao sistema de gerenciamento
de pacotes. As prioridades são :

<list>
  <item>Pacotes <strong>Required</strong> são necessários para o
    funcionamento correto do sistema.  <p>Isso inclui todas as ferramentas
    necessárias para reparar defeitos no sistema. Você não deve remover esses
    pacotes ou seu sistema pode vir a se tornar completamente quebrado e você
    poderá provavelmente não ser capaz de usar o dpkg para colocar as coisas
    de volta em seus lugares. Sistemas somente com pacotes Required são
    provavelmente inutilizáveis para muitos propósitos, mas possuem
    funcionalidade o suficiente para permitir que o administrador do sistema
    inicie o sistema e instale mais software.
  <item>Pacotes <strong>Important</strong> devem ser encontrados em
    qualquer sistema parecido com Unix.
    <p>Outros pacotes sem os quais o sistema não funcionará bem ou não
    será muito útil se encaixam aqui. Isso <strong>não</strong> inclui o
    Emacs ou X11 ou TeX ou quaisquer outras grandes aplicações. Esses
    pacotes constituem somente a infraestrutura mínima.
  <item>Pacotes <strong>Standard</strong> são padrão em qualquer sistema
    Linux, incluindo um sistema em modo caracter razoavelmente pequeno mas
    não muito limitado.
    <p>Isso é o que será instalado por padrão caso os usuários não
    selecionem mais nada. Isso não inclui muitas grandes aplicações, mas
    inclui o Emacs (ele é mais uma peça da infraestrutura do que uma
    aplicação) e um subconjunto razoável do Tex e LaTeX (caso isso seja
    possível sem o X).
  <item>Pacotes <strong>Optional</strong> incluem todos aqueles pacotes
    que você poderia razoavelmente querer instalar mesmo caso não esteja
    familiarizado com eles e  caso você não possua requerimentos
    especializados.
    <p>Isso inclui X11, uma distribuição completa TeX e uma porção de
    aplicações.
  <item>Pacotes <strong>Extra</strong> são pacotes que conflitam com outros
    pacotes com prioridades mais altas provavelmente, terão pouco uso para
    usuários que não são familiarizados a eles, ou têm requerimentos
    especiais que não os deixam ser encaixados em "Optional".
</list>

<sect1 id="virtual">Pacotes virtuais

<p>Um pacote virtual é um nome genérico que se aplica a qualquer um de 
um grupo de pacotes, todos os quais oferecem funcionalidade básica similar.
Por exemplo, os programas <prgn>tin</prgn> e <prgn>trn</prgn> são leitores de
notícias e devem portanto satisfazer quaisquer dependências de um
programa que requer um leitor de notícias no sistema para que funcione
ou seja útil. É portanto dito que eles fornecem um "pacote virtual"
chamado <package>news-reader</package>.

<p>Similarmente, o <prgn>exim</prgn> e o <prgn>sendmail</prgn> oferecem ambos
a funcionalidade de um agente de transporte de mensagens, É portanto
dito que eles fornecem o pacote virtual <package>mail-transport-agent</package>.
Caso um dos dois esteja instalado, então qualquer programa que depende da
instalação de um agente de transporte de mensagens estará
satisfeito pela existência desse pacote virtual.

<p>O Debian possui um mecanismo que, se mais de um pacote que fornece o
mesmo pacote virtual estiver instalado em um sistema, o administrador do
sistema pode definir um como o pacote preferido. O comando
relevante é <prgn>update-alternatives</prgn> e é descrito mais adiante
em <ref id="alternatives">.

<sect1 id="depends">Dependências de pacotes
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>O sistema de pacotes Debian possui uma faixa de "dependências" de
pacotes que é desenvolvida para indicar (com uma sinalização única) o
nível no qual o Programa A pode operar independentemente da existência do
Programa B em um dado sistema :
<list>
  <item>O Pacote A <strong>depende</strong> do Pacote B se B precisar
  absolutamente estar instalado para que A possa ser executado. Em
  alguns casos, A depende não somente de B, mas de uma versão específica
  de B. Nestes casos, a dependência da versão é normalmente um limite
  mínimo, no sentido de que A depende em qualquer versão de B mais
  recente do que alguma versão especificada.
  <item>O Pacote A <strong>recomenda</strong> o Pacote B caso o mantenedor do
    pacote julgue que a maioria dos usuários não iriam querer A sem também
    ter a funcionalidade fornecida por B.
  <item>O Pacote A <strong>sugere</strong> o Pacote B caso B contenha
    arquivos que estejam relacionados a (e normalmente melhorem) a
    funcionalidade de A.
  <item>O Pacote A <strong>conflita</strong> com o Pacote B quando A não
    funciona caso B esteja instalado no sistema. Na maioria das vezes,
    conflitos são casos onde A contém arquivos que são uma melhora
    daqueles em B. "Conflicts" (conflita) são normalmente combinados com
    "replaces" (substitui).
  <item>O Pacote A <strong>substitui</strong> o Pacote B quando arquivos
    instalados por B são removidos e (em alguns casos) sobrescritos
    por arquivos em A.
  <item>O Pacote A <strong>fornece</strong> o Pacote B quando todos os arquivos
    e as funcionalidades de B estão incorporadas em A. Este mecanismo
    oferece uma maneira para usuários com pouco espaço em disco obterem
    somente aquela parte do pacote A que realmente precisam.
</list>

<p>Informação mais detalhada sobre o uso de cada um desses termos pode
ser encontrada no <em>Manual de Empacotamento</em> e no <em>Manual de
Políticas</em>.

<p>Note que o <prgn>dselect</prgn> possui um controle mais refinado
sobre os pacotes especificados por <strong>recomendações</strong> e
<strong>sugestões</strong> do que o <file>apt-get</file>, o qual
simplesmente pega todos os pacotes especificados como
<strong>dependências</strong> e deixa para trás os pacotes especificados
como <strong>recomendados</strong> e <strong>sugestões</strong>. Ambos
os programas em sua forma moderna usam o APT como motor.

<sect1 id="pre-depends">O significado de Pré-dependências

<p>"Pre-depends" (pré-dependências) é uma dependência especial. No caso de
um pacote comum, o <prgn>dpkg</prgn> irá desempacotar seu arquivo (ou seja,
seu arquivo <tt>.deb</tt>) independentemente dos arquivos dos quais este
depende existirem ou não no sistema. Desempacotar significa que o
<prgn>dpkg</prgn> irá extrair os arquivos de seu arquivo que foi criado para
ser instalado em seu sistema e colocá-los nos lugares. Caso estes pacotes
<strong>dependam</strong> da existência de outros pacotes em seu sistema, o
<prgn>dpkg</prgn> se recusará a completar a instalação (executando sua ação
"configure") até que os outros pacotes sejam instalados.

<p>Porém, para alguns pacotes, o <prgn>dpkg</prgn> se recusará até mesmo a
desempacotá-los até que certas dependências estejam resolvidas. É dito que
tais pacotes "pré-dependem" da presença de outro(s) pacote(s).
O projeto Debian forneceu este mecanismo para suportar a atualização
segura do formato <tt>a.out</tt> para o formato <tt>ELF</tt>, onde a ordem
na qual os pacotes eram desempacotados era crítica. Existem outras situações
de grandes atualizações onde este método é útil, por exemplo, para pacotes
com prioridade "required" e sua dependência libc.

<p>Novamente, informação mais detalhada sobre isso pode ser encontrada no
<em>Manual de Empacotamento</em>.

<sect1 id="pkgstatus">Estado do pacote
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->

<p> O estado do pacote pode ser "unknow", "install", "remove", "purge"
ou "hold".
Estas flags "want" dizem o que o usuário quis fazer com o pacote (como
indicado pelas ações do usuário na seção "Selecionar" do
<prgn>dselect</prgn> ou pelas invocações diretas do <prgn>dpkg</prgn>).

<p>Seus significados são :
<list compact>
  <item><strong>unknown</strong>  - o usuário nunca indicou se ele
     queria o pacote.  
  <item><strong>install</strong>  - o usuário quer o pacote instalado
     ou atualizado.
  <item><strong>remove</strong>   - o usuário quer o pacote removido,
     mas não quer remover quaisquer arquivos de configuração.
  <item><strong>purge</strong>    - o usuário quer que o pacote seja removido
     completamente, incluindo os arquivos de configuração.
  <item><strong>hold</strong>     - o usuário quer que esse pacote não
     seja processado, ou seja, ele quer manter a versão atual no estado
     atual seja este qual for.
</list>

<sect1 id="puttingonhold">Evitando que pacotes sejam atualizados
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>Existem dois mecanismos para evitar que pacotes sejam atualizados :
através do <prgn>dpkg</prgn> ou, começando no Woody, através do APT.

<p>Com o <prgn>dpkg</prgn>, exporte primeiro a lista de seleções de
pacotes :
<example>
  dpkg --get-selections \* &gt; <var>selections.txt</var>
</example>
Edite então o arquivo resultante <file><var>selections.txt</var></file> mudando a
linha contendo o pacote que você desejaria evitar que fosse atualizado,
por exemplo, <package/libc6/, disso:
<example>
libc6                       install
</example>
para isso :
<example>
libc6                       hold
</example>
Salve o arquivo e recarregue-o na base de dados do <prgn>dpkg</prgn>
usando :
<example>
dpkg --set-selections &lt; <var>selections.txt</var>
</example>
Ou, caso você conheça o nome do pacote a ser mantido (hold), simplesmente
execute :
  <example>echo libc6 hold | dpkg --set-selections</example>
Este processo mantém pacotes no processo de instalação de cada arquivo
de pacote.

<p>O mesmo efeito pode ser obtido através do <prgn>dselect</prgn>.
Simplesmente entre na tela [S]elecionar, encontre o pacote que você deseja
manter em seu estado atual e pressione a tecla `=' (ou `H'). As modificações
serão válidas imediatamente depois que você sair da tela [S]elecionar.

<p>O sistema APT na distribuição Woody possui um novo mecanismo alternativo
para manter pacotes durante o processo de obtenção do arquivo usando
<tt>Pin-Prioriry</tt>. Consulte a página de manual <manref
name="apt_preferences" section="5">, e também <url id="&apt-howto;"> ou
o pacote <package>&p-apt-howto;</package>; <ref id="apt-preferences"> também
contém uma explicação breve.

<sect1 id="sourcepkgs">Pacotes fonte

<p>
Pacotes fonte são distribuídos em um diretório chamado <file>source</file>
e você pode fazer o download dos mesmos manualmente ou use
  <example>apt-get source <var>foo</var></example>
para obtê-los (consulte a página de manual <manref name="apt-get"
section="8"> para maiores informações sobre como configurar o APT para
fazer isso).


<sect1 id="sourcebuild">Construindo pacotes binários a partir de um pacote fonte

<p>Para um pacote <tt><var>foo</var></tt>, você precisará de todos os arquivos
<file><var>foo_*</var>.dsc</file>, <file><var>foo_*</var>.tar.gz</file> e
<file><var>foo_*.diff</var>.gz</file> para compilar o fonte
(nota: não existe <tt>.diff.gz</tt> para um pacote nativo Debian).

<p>Uma vez que você os tenha, caso você possua o pacote <package/dpkg-dev/
instalado, o comando
  <example>dpkg-source -x <var>foo_versão-revisão</var>.dsc</example>
irá extrair o pacote em um diretório chamado <tt><var>foo-versão</var></tt>.

<p>Execute os seguintes comandos para criar o pacote binário:
<example>
$ cd foo-versão
$ su -c "apt-get update ; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
E então,
  <example># su -c "dpkg -i ../<var>foo_versão-revisão_arquit</var>.deb"</example>
para instalar o novo pacote construído. Veja <ref id="port">.

<!-- Woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Criando novos pacotes Debian

<p>Para uma descrição mais detalhada, leia o <em>Guia dos Novos
Mantenedores</em>, disponível no pacote <package/maint-guide/ ou em <url
id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Atualizando um sistema Debian

<p>Um dos objetivos do Debian é oferecer um caminho de atualização consistente
e um processo de atualização seguro, e nós sempre fazemos o máximo possível
para que uma nova versão seja facilmente atualizável para quem atualiza da
versão anterior. Pacotes irão alertar o usuário quando existirem notícias
importantes durante o processo de atualização e irão frequentemente oferecer
uma solução para um possível problema.

<p>Você deve também ler as Notas de Lançamento, o documento que descreve
os detalhes de atualizações específicas, fornecido em todos os CDs Debian
e disponível na WWW em <url id="&stable-release;"> ou
<url id="&testing-release;">.

<p>
Um guia prático para atualizações está disponível em <ref id="package">.
Esta seção descreve os detalhes fundamentais.

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Métodos para atualizar um sistema Debian

<p>É possível simplesmente executar uma chamada FTP anônima ou usar o
<prgn>wget</prgn> em um repositório Debian, procurar atentamente até que
seja encontrado o arquivo desejado, fazer o download do mesmo e finalmente
instalá-lo usando o <prgn>dpkg</prgn>. Note que o <prgn>dpkg</prgn> irá
instalar arquivos de atualização em seus lugares, mesmo em um sistema
em execução. Algumas vezes, um pacote revisado irá requerer a instalação
de uma nova versão revisada de outros pacotes e neste caso a instalação
irá falhar até que/a menos que os outros pacotes sejam instalados.

<p>Muitas pessoas acham que este método consome muito tempo, uma vez que o
Debian se desenvolve tão rapidamente &mdash; tipicamente, uma dúzia ou mais
pacotes são disponibilizados toda semana. Este número é maior logo antes de
um lançamento de uma versão maior. Para lidar com esta avalanche, muitas pessoas
preferem usar um programa automatizado para atualizar. Diversas ferramentas de
gerenciamento de pacotes especializadas estão disponíveis para este propósito.

<sect1 id="pkgtools">Visão geral das ferramentas de gerenciamento de pacotes

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>O sistema de gerenciamento de pacotes possui dois objetivos : a
manipulação do arquivo de pacote propriamente dito e obtenção de arquivos de
pacotes do repositório Debian. O <prgn>dpkg</prgn> executa a primeira
tarefa e o APT e o <prgn>dselect</prgn> a última.

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>Este é o principal programa para manipular arquivos de pacotes; leia
<manref name="dpkg" section="8"> para um descrição completa.
<!-- "install dpkg" deleted because it's a required package -->

<p>O <prgn>dpkg</prgn> é fornecido com diversos programas suplementares primitivos.

<list>
<item>dpkg-deb: Manipula arquivos <tt>.deb</tt>. 
 <manref name="dpkg-deb" section="1">
<item>dpkg-ftp: Um antigo comando de obtenção de arquivos de pacotes. 
 <manref name="dpkg-ftp" section="1">
<item>dpkg-mountable: Um antigo comando de obtenção de arquivos de pacotes.
 <manref name="dpkg-mountable" section="1">
<item>dpkg-split: Divide um pacote grande em arquivos menores. 
 <manref name="dpkg-split" section="1">
</list>

O <prgn>dpkg-ftp</prgn> e <prgn>dpkg-mountable</prgn> ficaram obsoletos
com a introdução do sistema APT.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>O APT (Advanced Packaging Tool) é uma avançada interface para o sistema de gerenciamento de
pacotes Debian, consistindo de vários programas cujos nomes tipicamente
começam com "apt-". O <prgn>apt-get</prgn>, <prgn>apt-cache</prgn> e o
<prgn>apt-cdrom</prgn> são ferramentas de linha de comando para gerenciar
pacotes. Eles também funcionam como programas "back-end" do usuário para
outras ferramentas, como o <prgn/dselect/ e o <prgn/aptitude/.

<p>Para maiores informações, instale o pacote <package/apt/ e leia
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (Woody), e
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>Uma fonte alternativa de informação é o
<url id="&apt-howto;" name="APT HOWTO">.
Este pode ser instalado pelo pacote <package/apt-howto/ em
<file>&f-apt-howto;</file>.

<p><tt>apt-get upgrade</tt> e <tt>apt-get dist-upgrade</tt> instalam apenas
os pacotes listados em "Depends:" e ignoram os pacotes listados em
"Recommends:" e "Suggests:". Para evitar isso use o <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>Este programa é uma interface de usuário baseada em menus para o
sistema de gerenciamento de pacotes Debian. Ele é particularmente útil
para primeiras instalações e atualizações em larga escala. Veja <ref
id="dselect">

<p>Para maiores informações, instale o pacote <package/install-doc/ e
leia <file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> ou
<url id="&dselect-beginner;"
name="Documentação para Iniciantes do dselect">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <tt>start-stop-daemon</tt> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Atualizando um sistema em execução

<p>O kernel (sistema de arquivos) em sistemas &debian; suporta a troca de
arquivos mesmo quando estes estão sendo usados.

<p>Oferecemos também um programa chamado <prgn/start-stop-daemon/ que é
usado para iniciar daemons em tempo de inicialização da máquina ou para
parar daemons quando o nível de execução do kernel é mudado (exemplo, de
multiusuário para usuário único ou para halt). O mesmo programa é usado
pelos scripts de instalação quando um novo pacote contendo um daemon é
instalado, para parar daemons em execução, e reiniciá-los quando necessário.

<p>Note que o sistema Debian não requer o uso do modo de usuário único
para atualizar um sistema em execução.

<sect1 id="savedebs">Arquivos <tt>.deb</tt> baixados e em cache

<p>Caso você tenha feito o download de arquivos para seu disco (o que
não é absolutamente necessário, veja acima a descrição de
<prgn>dpkg-ftp</prgn> ou APT), depois de instalar os pacotes você pode
removê-los de seu sistema.

<p>Caso o APT seja usado, esses arquivos são colocados em cache no
diretório <file>/var/cache/apt/archives/</file>.  Você pode apagá-los
depos da instalação (<tt>apt-get clean</tt>) ou copiá-los para o diretório
<file>/var/cache/apt/archives/</file> de outra máquina para economizar
tempo de download durante instalações subseqüentes.

<sect1 id="keepingalog">Mantendo registros para atualizações

<p>O <prgn/dpkg/ mantém um registro dos pacotes que foram desempacotados,
configurados, removidos e/ou expurgados, mas não mantém (atualmente) um
log da atividade do terminal que ocorreu enquanto um pacote esteve sendo
manipulado.

<p>A maneira mais simples de contornar isso é executar suas sessões
<prgn>dpkg</prgn>, <prgn>dselect</prgn>, <prgn>apt-get</prgn>, etc.,
dentro do programa <manref name="script" section="1">.

<sect id="boot">O processo de inicialização Debian

<sect1 id="init">O programa <prgn>init</prgn>

<p>Como todos os Unices, o Debian inicia executando o programa
<prgn>init</prgn>. O arquivo de configuração para o <prgn>init</prgn> (que é
<file>/etc/inittab</file>) especifica que o primeiro script a ser executado
deve ser o <tt>/etc/init.d/rcS</tt>. Esse script executa todos os scripts em
<file>/etc/rcS.d/</file> através do source ou fork de subprocessos,
dependendo de sua extensão de arquivo, para executar a inicialização como a
checagem e a montagem de sistemas de arquivos, carregamento de módulos,
início de serviços de rede, configuração do relógio, etc.
Então, por compatibilidade, ele também executa os arquivos (exceto aqueles com
um `.' em seu nome) em <tt>/etc/rc.boot</tt> . Quaisquer scripts
no diretório posterior são normalmente reservados para o uso do
administrador do sistema e usá-los em pacotes é obsoleto. Veja <ref
id="init-hints"> e <url id="&sysvinit;" name="Níveis de execução de Sistema
e scripts init.d"> no Manual de Políticas Debian para maiores informações.

<sect1 id="runlevels">Níveis de execução

<p>Depois de completar o processo de inicialização, o <prgn>init</prgn>
executa todos os scripts de inicialização em um diretório especificado
pelo nível de execução padrão (este nível de execução é dado pela entrada
para o <tt>id</tt> em <file>/etc/inittab</file>. Como a maioria dos
<!-- todos? SGK --> Unices compatíveis com System V, o Linux possui 7
níveis de execução :
<list compact>
  <item>0 (parar o sistema),
  <item>1 (modo de usuário único),
  <item>2 through 5 (vários modos multiusuário), e
  <item>6 (reinicia o sistema).
</list>
Sistemas Debian vêm com o valor <tt>id=2</tt>, o que indica que o nível de
execução padrão será 2 quando o estado multiusuário for iniciado e que os
scripts em <tt>/etc/rc2.d/</tt> serão executados.

<p>De fato, os scripts em quaisquer dos diretórios em
<file>/etc/rc<var>N</var>.d/</file> são apenas ligações simbólicas que
apontam para scripts em <file>/etc/init.d/</file>. Porém, os
<strong>nomes</strong> dos arquivos em cada um dos diretórios
<file>/etc/rc<var>N</var>.d/</file> são selecionados para indicar a
<strong>maneira</strong> que os scripts em <file>/etc/init.d/</file> serão
executados. Especificamente, antes de entrar em qualquer nível de execução,
todos os scripts iniciados com `K' são executados; esses scripts matam
(param) serviços. Então todos os scripts iniciados com `S' são executados;
esses scripts iniciam serviços.  O número de dois dígitos seguido de `K' ou
`S' indica a ordem na qual o script é executado. Scripts de menor valor
numérico são executados primeiro.

<p>Esse método funciona porque todos os scripts em <file>/etc/init.d/</file>
aceitam um argumento que pode ser "start" (iniciar), "stop" (parar),
"reload" (recarregar), "restart" (reiniciar) ou "force-reload"
(forçar-recarregar) e irão portanto cumprir a tarefa indicada pelo
argumento. Esses scripts podem ser usados mesmo depois que um sistema
tenha sido iniciado para controlar vários processos.

<p>Por exemplo, com o argumento "reload" o comando
  <example># /etc/init.d/exim4 reload</example>
envia ao daemon exim4 um sinal para que o mesmo releia seu arquivo de
configuração.

<sect1 id="custombootscripts">Personalizando o processo de inicialização
<p>
O Debian não utiliza o diretório <tt>rc.local</tt> no estilo BSD para
personalizar o processo de inicialização;  ao invés disso ele fornece o
seguinte mecanismo de personalização.

<p>Suponha que um sistema precisa executar o script <tt>foo</tt> na
inicialização da máquina ou ao entrar em um nível de execução (System V)
em especifíco. O administrador do sistema deverá então :
<enumlist>
  <item>Colocar o script <tt>foo</tt> dentro do diretório
    <file>/etc/init.d/</file>.
  <item>Executar o comando Debian <prgn>update-rc.d</prgn> com os
    argumentos apropriados para criar as ligações entre os
    diretórios (especificados na linha de comando) 
    <tt>rc<var>?</var>.d</tt> e <file>/etc/init.d/foo</file>.
    Aqui, <var>?</var> é um número de 0 a 6 que corresponde a um dos
    níveis de execução System V.
  <item>Reiniciar o sistema.
</enumlist>

<p>O comando <tt>update-rc.d</tt> criará as ligações entre os
arquivos nos diretórios <tt>rc<var>?</var>.d</tt> e o script em
<file>/etc/init.d/</file>. Cada ligação iniciará com um `S' ou um
`K', seguido por um número, seguido pelo nome do script. Quando o sistema
entra em um nível de execução <var>N</var>, scripts que iniciam com `K' em
<file>/etc/rc<var>N</var>.d/</file> são executados com <tt>stop</tt>
como seu argumento, seguido por aqueles começando com `S' em
<file>/etc/rc<var>N</var>.d</file> com <tt>start</tt> como seu
argumento.

<p>Alguém poderia, por exemplo, fazer com que o script <tt>foo</tt> seja
executado na inicialização do sistema colocando-o em
<file>/etc/init.d/</file> e instalando as ligações com o comando
<tt>update-rc.d foo defaults 19</tt>. O argumento <tt>defaults</tt> se
refere aos níveis de execução padrões, que são do nível 2 até o nível
5. O argumento <tt>19</tt> assegura  que <tt>foo</tt> seja chamado antes
de quaisquer scripts contendo números 20 ou superiores.

<sect id="diverse">Suportando diversidades
<p>
O Debian suporta diversas maneiras de acomodar os desejos do administrador
do sistema sem prejudicar o sistema.
<list>
<item><prgn>dpkg-divert</prgn>, veja <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, veja <ref id="equivs">.
<item><prgn>update-alternative</prgn>, veja <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> pode acomodar muitos gerenciadores
  de inicialização. Consulte <manref name="make-kpkg" section="1"> e <ref
  id="kernel-debian">.
</list>
Quaisquer arquivos sob <file>/usr/local/</file> pertencem ao administrador
do sistema e o &debian; não irá tocá-los. A maioria (ou todos) dos
arquivos sob <file>/etc</file> são <tt>conffiles</tt> e o &debian; não irá
sobrescrevê-los em atualizações a menos que o administrador do sistema
explicitamente peça isso.

<sect id="i18n">Internacionalização
<p>O sistema &debian; é internacionalizado e oferece suporte para a
exibição e entrada de caracteres em muitos idiomas, seja no console ou
sob o X. Muitos documentos, páginas de manual e mensagens
do sistema foram traduzidos para um número crescente de idiomas. Durante
a instalação o Debian pede ao usuário para escolher um idioma para ser
usado na instalação (e algumas vezes o variante local do idioma).
<p>
Caso seu sistema instalado não suporte todos os recursos do idioma que
você precisa ou caso você precise mudar entre idiomas ou instalar um
teclado diferente para suportar seu idioma, consulte <ref id="l10n">.

<sect id="kernel-details">Debian e o kernel
<p>
Consulte <ref id="kernel">.

<sect1 id="non-debian-kernel">Compilando um kernel a partir de um fonte não Debian

<p><!--Yes.  But you have-->
Você precisa entender o política Debian em relação a cabeçalhos.

<p>As bibliotecas C Debian são construídas com as versões
<strong>estáveis</strong> mais atuais dos cabeçalhos do
<strong>kernel</strong>.

<p>Por exemplo, a versão Debian-1.2 usou a versão 5.4.13 dos cabeçalhos.
Esta prática contrasta com os pacotes fontes do kernel Linux distribuídos
em todos os repositórios de sites FTP Linux, que usam as versões mais
recentes até mesmo dos cabeçalhos. Os cabeçalhos do kernel distribuídos
com os fontes do kernel estão localizados em
<file>/usr/include/linux/include/</file>.

<p>Caso você precise compilar um programa com cabeçalhos de kernel que
sejam mais novos do que aqueles fornecidos pelo pacote <package/lib6-dev/,
você deve então adicionar <tt>-I/usr/src/linux/include/</tt> a sua linha
de comando quando compilar. Isto ocorreu em um momento, por exemplo, com
o empacotamento do daemon automounter (<package/amd/). Quando novos
kernels mudaram internamente em relação a lidar com NFS, o
<prgn>amd</prgn> precisava saber disso. Para isso foi necessário incluir
os últimos cabeçalhos do kernel.

<sect1 id="customkernel">Ferramentas para construir kernels personalizados

<p>Usuários que desejam (ou precisam) construir um kernel personalizado são
encorajados a fazer o download do pacote <package/kernel-package/. Este
pacote contém o script para construir o pacote do kernel e oferece a
capacidade de criar um pacote kernel-image Debian somente executando o
comando
<example>
# make-kpkg kernel_image
</example>
no diretório de nível principal dos fontes do kernel.
Ajuda é fornecida executando o comando
<example>
# make-kpkg --help
</example>
e através da página de manual <manref name="make-kpkg" section="1">
e <ref id="kernel">.

<p>Os usuários devem fazer o download separadamente do código fonte do
kernel mais atual (ou o kernel de sua escolha) a partir de seu site
repositório Linux favorito, a menos que um pacote
kernel-source-<var>versão</var> esteja disponível (onde <var>versão</var>
significa a versão do kernel). O script de inicialização
<file>initrd</file> Debian requer um patch de kernel especial chamado
<prgn>initrd</prgn>; consulte <url id="&bug-initrd;">.

<p>Informações detalhadas para o uso do pacote <package/kernel-package/
são fornecidas no arquivo <file>/usr/doc/kernel-package/README</file>.

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="modules">Condições especiais para lidar com módulos

<p>O pacote Debian <package/modconf/ oferece um script shell
(<file>/usr/sbin/modconf</file>) que pode ser usado para personalizar a
configuração dos módulos. Este script apresenta uma interface baseada
em menus, perguntando ao usuário por detalhes sobre os controladores de
dispositivos carregáveis em seu sistema. As respostas são usadas para
personalizar o arquivo <file>/etc/modules.conf</file> (que lista
apelidos e outros argumentos que devem ser usados em conjunto com outros
módulos) através de arquivos em <file>/etc/modutils/</file> e
<file>/etc/modules</file> (que listam os módulos que devem ser
carregados em tempo de inicialização da máquina).

<p>Como os (novos) arquivos <file>Configure.help</file> que estão agora disponíveis
para suportar a construção de kernels personalizados, o pacote
<package/modconf/ vem com uma série de arquivos de ajuda (em
<file>/usr/share/modconf/</file>) que oferecem informações detalhadas
para cada um dos módulos. Consulte <ref id="kernel-modules"> para
ver exemplos.

<sect1 id="removeoldkernel">Desinstalação de um kernel antigo

<p>O script <prgn>kernel-image-<var>NNN</var>.prerm</prgn> checa se o
kernel que está em execução atualmente é o mesmo que o kernel que você está
tentando desinstalar. Portanto você pode remover pacotes de imagens kernel
indesejáveis com segurança usando esse comando :

<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>

(É claro, substitua <var>NNN</var> pela versão de seu kernel e seu número
de revisão)
</sect>
