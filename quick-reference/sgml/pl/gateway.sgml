<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.201"  -->

<chapt id="gateway">Konfiguracja sieci

<p>
<!-- I keep above id as gateway to have the same html file name. -->
<!-- Once all translations are in sync, I may change it to network.
-->
Ten rozdział skupia się na administracji siecią w sytemie &debian;. Ogólne
wprowadzenie do sieci w GNU/Linuksie możesz przeczytać w 
<url id="&net-howto;" name="Net-HOWTO">.
<p>
By system &debian; mógł korzystać z internetu, jego interfejsy sieciowe
muszą być obsługiwane przez jądro oraz poprawnie skonfigurowane.
<p>
Pierwszym wymaganiem jest obsługa przez jądro urządzenia sieciowego takiego
jak karta sieciowa, karta Wi-Fi czy modem. By uzyskać tę obsługę, możliwe,
że będziesz musiał przekompilować jądro lub załadować moduły tak jak to
opisano w <ref id="kernel">.
<p>
Konfiguracja sieciowych urządzeń jest opisana poniżej.
Informacje z tego rozdziału zostały zaktualizowane dla Sarge. Spora część
nie dotyczy wcześniejszych wersji.
<!--
I move these to comment, Thomas, please remove once you are ready
<p>
 	 <list compact>
  	 <item>XXX FIXME XXX: Update HW config, Ethernet kernel module
  	 <item>XXX FIXME XXX: Add section to reconfigure network on initial install.
	 </list>
-->
<p>

<sect id="net-basic">Podstawy sieciowe
<p>
Komputer z systemem &debian; może posiadać wiele interfejsów, każdy z innym
adresem IP. Interfejsy mogą być różnego typu, włączając:
<list compact>
<item>Loopback:  <tt>lo</tt>
<item>Ethernet:  <tt>eth0</tt>, <tt>eth1</tt>, ...
<item>Wi-Fi:  <tt>wifi0</tt>, <tt>wifi1</tt>, ...
<footnote>
Zauważ, że interfejs Wi-Fi jest tak właściwie aliasem na interfejs
Ethernet, który umożliwia dostęp do parametrów konfiguracyjnych
specyficznych dla Wi-Fi. Parametry te są kontrolowane programem 
<prgn>iwconfig</prgn>.
</footnote>
<item>Token Ring:  <tt>tr0</tt>, <tt>tr1</tt>, ...
<item>PPP:  <tt>ppp0</tt>, <tt>ppp1</tt>, ...
</list>
Istnieje jeszcze wiele innych urządzeń sieciowych, włączając SLIP, PLIP
(szeregowa i równoległa linia IP), urządzenia "shaper" służące do kontroli
przepustowości na innych interfejsach, 
frame relay, AX.25, X.25, ARCnet, i LocalTalk.
<p>
Każdy interfejs sieciowy podłączony bezpośrednio do internetu (albo sieci
bazującej na IP) jest identyfikowany za pomocą unikalnego 32 bitowego
adresu IP. 
<footnote>
Jest to prawdą gdy używana jest 4 wersja protokołu IP. W IPv6 adresy są 128
bitowe. Zobacz <url id="&ipv6home;">.
</footnote>
Adres IP może być podzielony na część, która określa sieć oraz część
określająca komputer. Jeśli weźmiesz adres IP, ustawisz na 1 wszystkie
bity, które są częścią adresu sieci i na 0 wszystkie bity, które są częścią
adresu komputera, to otrzymasz maskę sieciową danej sieci.

<p>
Dawniej, sieci IP były pogrupowane w klasy, których część sieciowa adresu
była długa na 8, 16 lub 24 bity.
<footnote>
Taki system był mało elastyczny i powodował marnotrastwo wielu adresów IP,
więc dzisiaj sieci IPv4 są dzielone z adresami sieciowymi o różnych
długościach.
</footnote>
<example>
          Adresy IP                      maska sieci     długość
Klasa A   1.0.0.0     - 126.255.255.255  255.0.0.0     =  /8
Klasa B   128.0.0.0   - 191.255.255.255  255.255.0.0   = /16
Klasa C   192.0.0.0   - 223.255.255.255  255.255.255.0 = /24
</example>
Adresy IP spoza tych zakresów są używane do specjalnych celów.
<p>
W każdej klasie istnieją zakresy adresów zarezerwowanych do użycia
w sieciach lokalnych (LAN). Istnieje gwarancja, że te adresy nie będą
w konflikcie z innymi adresami w internecie. (Z tego samego powodu, jeśli
jeden z takich adresów jest przydzielony do komputera, ten komputer nie
może mieć bezpośredniego dostępu do internetu, a tylko poprzez bramkę,
która pracuje jako serwer pośredniczący dla usług lub wykonuje translację
adresów (NAT)). W poniższej tabeli są wyszczególnione te zakresy adresów 
wraz z ich liczbą w każdej klasie.
<example>
          adres sieci                  długość  ile
Klasa A   10.x.x.x                     /8       1
Klasa B   172.16.x.x -  172.31.x.x     /16      16
Klasa C   192.168.0.x - 192.168.255.x  /24      256
</example>

Pierwszy adres w każdej sieci jest równocześnie adresem tej sieci.
Ostatni adres jest adresem rozgłoszeniowym sieci (broadcast).
<footnote>
Adres sieci można otrzymać poprzez mnożenie logiczne jakiegokolwiek adresu 
z sieci z maską sieci. Adres rozgłoszeniowy można otrzymać przez sumowanie
logiczne adresu sieci z dopełnioną jedynkami maską sieci.
</footnote>

Wszystkie inne adresy mogą być przydzielane komputerom w sieci.
Najczęściej pierwszy lub ostatni adres jest przydzielany bramce
internetowej danej sieci.
<p>
Tablica routingu zawiera informacje jądra na temat tego jak przesyłać
pakiety na ich miejsce przeznaczenia. 
Poniżej znajduje się przykładowa tablica routingu z komputera znajdującego
się w sieci lokalnej o adresie 192.168.50.x/24.
Komputer 192.168.50.1 (również w tej sieci) jest routerem dla sieci
korporacyjnej 172.20.x.x/16, a komputer 192.168.50.254 (również w tej
sieci) jest routerem dla internetu.
<!-- I shrunk shell output within 72 characters -->
<example>
# route
Kernel IP routing table
Destination   Gateway        Genmask       Flags Metric Ref Use Iface
127.0.0.0     *              255.0.0.0     U     0      0     2 lo
192.168.50.0  *              255.255.255.0 U     0      0   137 eth0
172.20.0.0    192.168.50.1   255.255.0.0   UG    1      0     7 eth0
default       192.168.50.254 0.0.0.0       UG    1      0    36 eth0
</example>

<list compact>
<item>
Pierwsza linia po nagłówkach mówi, że ruch przeznaczony dla sieci 
<tt>127.x.x.x</tt> będzie przesyłany poprzez <tt>lo</tt>, interfejs zwrotny.
<item>
Druga linia mówi, że ruch przeznaczony dla komputerów z sieci lokalnej
będzie przesyłany przez <tt>eth0</tt>.
<item>
Trzecia linia mówi, że ruch przeznaczony dla sieci korporacyjnej będzie
przesyłany przez bramkę <tt>192.168.50.1</tt> również przez <tt>eth0</tt>.
<item>
Czwarta linia mówi, że ruch przeznaczony dla internetu będzie kierowany
przez bramkę <tt>192.168.50.254</tt> również przez <tt>eth0</tt>.
</list>

Adresy IP w tablicy mogą pojawia się również jako nazwy, które są pobierane
z pliku <file>/etc/networks</file> lub poprzez mechanizm rozwiązujący nazwy
(C Library resolver).
<p>
Dodatkowo, oprócz routingu, jądro może wykonywać translację adresów,
ograniczanie przepustowości czy filtrowanie.
<p>
Zobacz <url id="&net-howto;" name="Net-HOWTO"> i 
<url id="&net-howto-over;" name="other networking HOWTOs"> po więcej
informacji.

<sect id="net-low">Zaawansowana konfiguracja sieci
<p>
Tradycyjne zaawansowane narzędzia do konfiguracji sieci w GNU/Linuksie to
programy <prgn>ifconfig</prgn> i <prgn>route</prgn> znajdujące się
w pakiecie <package>net-tools</package>. Te narzędzia zostały oficjalnie
zastąpione przez <prgn>ip</prgn> z pakietu <package>iproute</package>. 
Program <prgn>ip</prgn> działa z Linuksem 2.2 lub nowszymi i jest bardziej
dostosowany. Jednakże, stare narzędzia nadal działają i są znane większości
użytkowników.

<sect1 id="low-ifconfig">Zaawansowana konfiguracja sieci &ndash;
<prgn>ifconfig</prgn> i <prgn>route</prgn>

<p>
Poniżej ilustracja jak zmienić adres IP interfejsu <tt>eth0</tt> z 
<tt>192.168.0.3</tt> na <tt>192.168.0.111</tt> oraz ustawić <tt>eth0</tt> 
by przesyłane były przez niego dane do sieci <tt>10.0.0.0</tt> poprzez
<tt>192.168.0.1</tt>. Zaczynamy od uruchomienia <prgn>ifconfig</prgn> i 
<prgn>route</prgn> bez żadnych argumentów by wyświetlić aktualny stan
wszystkich interfejsów oraz routing.

<example>
# ifconfig
eth0 Link encap:Ethernet  HWaddr 08:00:46:7A:02:B0
     inet addr:192.168.0.3  Bcast:192.168.0.255  Mask:255.255.255.0
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     RX packets:23363 errors:0 dropped:0 overruns:0 frame:0
     TX packets:21798 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:100
     RX bytes:13479541 (12.8 MiB)  TX bytes:20262643 (19.3 MiB)
     Interrupt:9

lo   Link encap:Local Loopback
     inet addr:127.0.0.1  Mask:255.0.0.0
     UP LOOPBACK RUNNING  MTU:16436  Metric:1
     RX packets:230172 errors:0 dropped:0 overruns:0 frame:0
     TX packets:230172 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:0
     RX bytes:22685256 (21.6 MiB)  TX bytes:22685256 (21.6 MiB)
# route
Kernel IP routing table
Destination  Gateway      Genmask          Flags Metric Ref Use Iface
192.168.0.0  *            255.255.0.0      U     0      0     0 eth0
default      192.168.0.1  255.255.255.255  UG    0      0     0 eth0
</example>
Na początek wyłączamy interfejs.
<example>
# ifconfig eth0 inet down
# ifconfig
lo   Link encap:Local Loopback
  ... (brak pozycji eth0)
# route
  ... (brak wpisów w tabeli routingu)
</example>

Następnie przywracamy go z powrotem z nowym adresem IP i nowym routingiem.
<example>
# ifconfig eth0 inet up 192.168.0.111 \
           netmask 255.255.0.0 broadcast 192.168.255.255
# route add -net 10.0.0.0 netmask 255.0.0.0 gw 192.168.0.1 dev eth0
</example>
Rezultat:
<example>
# ifconfig
eth0 Link encap:Ethernet  HWaddr 08:00:46:7A:02:B0
     inet addr:192.168.0.111  Bcast:192.168.255.255  Mask:255.255.0.0
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     ...

lo   Link encap:Local Loopback
     inet addr:127.0.0.1  Mask:255.0.0.0
     ...
# route
Kernel IP routing table
Destination  Gateway      Genmask      Flags Metric Ref Use Iface
192.168.0.0  *            255.255.0.0  U     0      0     0 eth0
10.0.0.0     192.168.0.1  255.0.0.0    UG    0      0     0 eth0
</example>

<p>
Więcej informacji uzyskasz w <manref name="ifconfig" section="8"> i
<manref name="route" section="8">.

<sect1 id="low-ip">Zaawansowana konfiguracja sieci &ndash; <prgn>ip</prgn>
<p>
Odpowiedniki poprzednich poleceń z wykorzystaniem <prgn>ip</prgn> zamiast 
<prgn>ifconfig</prgn> i <prgn>route</prgn> są:
<list compact>
<item><tt>ip link show</tt>
<item><tt>ip route list</tt>
<item><tt>ip link set eth0 down</tt>
<item><tt>ip addr del dev eth0 local 192.168.0.3</tt>
<item><tt>ip addr add dev eth0 local 192.168.0.111/16 broadcast 192.168.255.255</tt>
<item><tt>ip link set eth0 up</tt>
<item><tt>ip route add dev eth0 to 10.0.0.0/8 src 192.168.0.111 via 192.168.0.1</tt>
</list>

<p>
Program <prgn>ip</prgn> wyświetla składnię swoich poleceń gdy jest
uruchamiany z argumentem <tt>help</tt>.
Przykładowo <tt>ip link help</tt> wyświetli:

<example>
Usage: ip link set DEVICE { up | down | arp { on | off } |
                             dynamic { on | off } |
                             multicast { on | off } | txqueuelen PACKETS |
                             name NEWNAME |
                             address LLADDR | broadcast LLADDR |
                             mtu MTU }
       ip link show [ DEVICE ]
</example>

Zobacz również <manref name="ip" section="8">.

<sect1 id="low-wifi">Konfiguracja interfejsu Wi-Fi
<p>
Dla interfejsów Wi-Fi wraz z <prgn>ifconfig</prgn> lub <prgn>ip</prgn>
używany jest program <prgn>iwconfig</prgn> z pakietu 
<package>wireless-tools</package>.
<p>
Zobacz <manref name="iwconfig" section="8">.
  	 
<sect1 id="low-ppp">Konfiguracja interfejsu PPP
<p>
Jeśli korzystasz z internetu poprzez modem podpięty do wdzwanianej linii
telefonicznej wtedy połączenie jest negocjowane przy pomocy protokołu 
Point-to-Point (PPP). Takie połączenia są dostępne jako interfejsy sieciowe 
<tt>ppp0</tt>, <tt>ppp1</tt> i tak dalej.
<p>
Interfejs PPP jest zarządzany przez demona PPP <prgn>pppd</prgn> z pakietu 
<package>ppp</package>. Z tego powodu dla użytkownika, konfigurować
interfejs PPP znaczy konfigurację <prgn>pppd</prgn>.

<sect2 id="ppp-pppd">Ręczna konfiguracja <prgn>pppd</prgn>

<p>
By zestawić połączenie sieciowe, port komunikacyjny (zazwyczaj port
szeregowy) musi zostać otwarty, polecenia muszą zostać przesłane do
urządzenia łączącego się (zazwyczaj modemu), numer telefoniczny musi zostać
wybrany, tożsamość musi zostać zweryfikowana przez odległy demon PPP,
interfejs PPP musi zostać utworzony i wtedy tablice routingu muszą zostać
odpowiednio zmodyfikowane by ruch był wysyłany przez to połączenie.
<prgn>pppd</prgn> może wykonać to wszystko, a w związku z tym posiada
bardzo długą listę dostępnych opcji. Opcje te zostały opisane w 
<manref name="pppd" section="8">.
<p>
W systemie &debian; globalne opcje ustawia się w pliku 
<file>/etc/ppp/options</file>. Opcje specyficzne dla użytkownika można
ustawić w <file>~/.ppprc</file>. Opcje zależne od portu komunikacyjnego są
przechowywane w <file>/etc/ppp/options.<var>nazwa_portu</var></file>.
Przykładowo, załóżmy, że masz dwa modemy &mdash; wbudowany modem Lucent LT
dostępny przez /dev/LT-modem i zewnętrzny modem dostępny przez /dev/ttyS0.
Stwórz dwa poniższe pliki z opcjami.
<example>
# cat &gt; /etc/ppp/options.LT-modem &lt;&lt;EOF
115200
init "/usr/sbin/chat -f /etc/chatscripts/setup-LT-modem"
EOF
# cat &gt; /etc/ppp/options.ttyS0 &lt;&lt;EOF
115200
init "/usr/sbin/chat -f /etc/chatscripts/setup-ttyS0"
EOF
</example>

To odnosi się do następujących skryptów chat. Najpierw 
<file>/etc/chatscripts/setup-LT-modem</file>.
<example>
ABORT ERROR
'' ATZ
OK 'ATW2X2 S7=70 S11=55'
OK AT
</example>
A teraz <file>/etc/chatscripts/setup-ttyS0</file>.
<example>
ABORT ERROR
'' ATZ
OK 'ATL1M1Q0V1W2X4&amp;C1&amp;D2 S6=4 S7=70 S11=55 S95=63 S109=1 +FCLASS=0'
OK AT
</example>

Zawartość tych plików oczywiście zależy od Twojego sprzętu.
<p>
Opcje mogą również zostać przekazane do <prgn>pppd</prgn> jako argumenty.
<p>
W systemie &debian; <prgn>pppd</prgn> jest zazwyczaj uruchamiany używając
polecenia <prgn>pon</prgn>. Kiedy <prgn>pon</prgn> zostaje użyty, jego
pierwszym argumentem jest nazwa pliku z opcjami znajdującego się w 
<file>/etc/ppp/peers/</file>, który będzie odczytany przez <prgn>pppd</prgn>.
<footnote>
Ta opcja jest załączona używając opcji <tt>call</tt>.
</footnote>

To miejsce gdzie ustawiasz opcje specyficzne na przykład dla konkretnego 
połączenia &mdash; konkretnego dostawcy internetu (ISP).
<p>
Załóżmy przykłado że dojeżdżasz pomiędzy Amsterdamem i Den Haag. W każdym
mieście masz dostęp do dwóch dostawców internetu &mdash; Planet i KPN.
Najpierw utwórz podstawowy plik z opcjami dla każdego dostawcy.
<example>
# cat &gt; /etc/ppp/peers/KPN &lt;&lt;EOF
remotename KPN
noauth
user kpn
noipdefault
ipparam KPN
EOF
# cat &gt; /etc/ppp/peers/Planet &lt;&lt;EOF
remotename Planet
auth
user user3579@planet.nl
noipdefault
mru 1000
mtu 1000
ipparam Planet
EOF
</example>

Te pliki ustawiają różne opcje pomiędzy dostawcami. 
Wspólne opcje mogą być umieszczone w <file>/etc/ppp/options</file> 
lub w jednym z plików związanym z konkretnym interfejsem.
<p>
Teraz stwórz pliki z opcjami dla każdego dostawcy w każdym mieście.
W naszym przykładzie jedyną różnicą w połączeniach do dostawców w różnych
lokalizacjach będzie wymagany skrypt chat. 
(Skrypt chat jest różny ponieważ lokalny dostęp do numeru telefonicznego
jest inny.)
<example>
# cat &gt; /etc/ppp/peers/KPN-Amsterdam &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/KPN-Amsterdam"
file /etc/ppp/peers/KPN
EOF
# cat &gt; /etc/ppp/peers/KPN-DenHaag &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/KPN-DenHaag"
file /etc/ppp/peers/KPN
EOF
# cat &gt; /etc/ppp/peers/Planet-Amsterdam &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/Planet-Amsterdam"
file /etc/ppp/peers/Planet
EOF
# cat &gt; /etc/ppp/peers/Planet-DenHaag &lt;&lt;EOF
connect "/usr/sbin/chat -v -f /etc/chatscripts/Planet-DenHaag"
file /etc/ppp/peers/Planet
EOF
</example>

Każda dyrektywa <tt>file</tt> załącza jeden z plików z opcjami pokazanych
wcześniej. Dyrektywa <tt>connect</tt> określa polecenie z którego skorzysta 
<prgn>pppd</prgn> do nawiązania połączenia. 
Zazwyczaj używa się programu <prgn>chat</prgn> do tego odpowiednio
dostosowując skrypt chat do dostawcy.
Poniżej skrypt chat dla Den Haag; skrypt dla Amsterdamu może być podobny
z wyjątkiem numeru telefonu lub może się znacznie różnić jeśli tam dostawca
oferuje usługi poprzez inną firmę.

<example>
# cat &gt; /etc/chatscripts/KPN-DenHaag &lt;&lt;EOF
ABORT BUSY
ABORT 'NO CARRIER'
ABORT VOICE
ABORT 'NO DIALTONE'
ABORT 'NO DIAL TONE'
ABORT 'NO ANSWER'
ABORT ERROR
OK-AT-OK ATDT <var>0676012321</var>
CONNECT 
EOF
# cat &gt; /etc/chatscripts/Planet-DenHaag &lt;&lt;EOF
ABORT BUSY
ABORT 'NO CARRIER'
ABORT VOICE
ABORT 'NO DIALTONE'
ABORT 'NO DIAL TONE'
ABORT 'NO ANSWER'
ABORT ERROR
OK-AT-OK ATDT <var>0676002505</var>
CONNECT 
EOF
</example>

By móc połączyć się z tymi dostawcami potrzebujesz nazwę klienta oraz hasło
któe <prgn>pppd</prgn> może wykorzystać przy połączeniu.
Te informacje przechowywane są albo w <file>/etc/ppp/pap-secrets</file> 
(jeśli używany jest protokół PAP) albo w <file>/etc/ppp/chap-secrets</file>
(jeśli używany jest protokół CHAP). Mimo, że CHAP jest bardziej bezpieczny
to PAP jest częściej używany. Ponieważ te pliki zawierają poufne
informacje, grupa oraz inni nie powinni mieć uprawnień do czytania czy
zapisywania ich. Format tych plików opisany jest w 
<manref name="pppd" section="8">. Hasło (trzecie pole) jest wybierane na
podstawie nazwy klienta (pierwsze pole) i/lub nazwy serwera (drugie pole).
Podczas łączenia się z dostawcami generalnie nie jest znana nazwa serwera
więc przesyłana jest w zamian nazwa klienta; jest to wykonywane
w powyższych plikach w liniach <tt>user</tt> w <file>peers/KPN</file> 
i <file>peers/Planet</file>.

<example>
# nazwa klienta     nazwa serwera  hasło
kpn                 *              kpn
user3579@planet.nl  *              myfavoritepet
</example>

<sect2 id="ppp-pppconfig">Konfiguracja <prgn>pppd</prgn> używając
<package>pppconfig</package>

<p>
Szybkim sposobem na konfigurację <prgn>pppd</prgn> jest użycie programu 
<prgn>pppconfig</prgn> z pakietu o tej samej nazwie. <prgn>pppconfig</prgn> 
ustawia powyższe pliki po zadaniu użytkownikowi pytań w przyjaznym
interfejsie. 
<p>
Jeśli zamierzasz używać <package>resolvconf</package> upewnij się, że
wybrałeś "None" na ekranie "Configure Nameservers".

<sect2 id="ppp-wvdial">Konfiguracja interfejsu PPP używając 
<package>wvdial</package>

<p>
Innym sposobem na używanie <prgn>pppd</prgn> jest uruchamianie go z 
<prgn>wvdial</prgn> który znajduje się w pakiecie <package>wvdial</package>.
Zamiast uruchamiać <prgn>pppd</prgn> wraz z <prgn>chat</prgn> do negocjacji
i nawiązania połączenia, <prgn>wvdial</prgn> sam wdzwania się i negocjuje
połączenie a następnie uruchamia <prgn>pppd</prgn> do reszty zadań.
Podając tylko numer telefonu, nazwę użytkownika i hasło <prgn>wvdial</prgn> 
radzi sobie z nawiązaniem połączenia w większości przypadków.

<sect id="net-name">Przydzielanie nazwy komputerowi
<p>

<sect1 id="name-host">Nazwa komputera
<p>
System &debian; czasem potrzebuje identyfikacji poprzez nazwę.
Do tych celów <strong>hostname</strong> jest zarządzany przez jądro.
<p>
Skrypt startowy <file>/etc/init.d/hostname.sh</file> ustawia nazwę
komputera podczas uruchamiania systemu (używając polecenia 
<prgn>hostname</prgn>) i przetrzymuje ją w <file>/etc/hostname</file>.
Ten plik powinien zawierać <strong>tylko</strong> nazwę komputera, a nie
jego pełną nazwę domenową.
<p>
By wyświetlić aktualną nazwę komputera uruchom <prgn>hostname</prgn> bez
argumentów.

<sect1 id="name-mail">Nazwa pocztowa (mailname)
<p>
<strong>mailname</strong> danego komputera jest nazwą, której programy
związane z pocztą elektroniczną używają do identyfikacji komputera.
Plik <file>/etc/mailname</file> zawiera tę nazwę zakończoną nową linią.
Nazwa pocztowa jest zazwyczaj jedną z pełnych domenowych nazw komputera
(fully qualified domain name). Zobacz <manref name="mailname" section="5">.
<p>

To co odbiorca wiadomości email wysłanej przez Twój system &debian; widzi 
przy nagłówku <tt>From:</tt> zależy od tego jak serwer oraz klient pocztowy
są skonfigurowane.
Załóżmy, że lokalny użytkownik <tt><var>foo</var></tt> wysyła wiadomość
z komputera o nazwie pocztowej <tt><var>mojkomputer.dom</var></tt>.
W nagłówku <tt>From:</tt> wiadomości wychodzącej będzie:
<list compact>
<item>"<tt>From: <var>foo</var>@<var>mojkomputer.dom</var></tt>"
jeśli klient nie ma ustawionego nagłówka <tt>From:</tt>;
<item>"<tt>From: <var>bar</var>@<var>mojkomputer.dom</var></tt>"
jeśli klient ma ustawiony nagłówek "<tt>From: <var>bar</var></tt>";
<item>"<tt>From: <var>bar</var>@<var>bogus.dom</var></tt>"
jeśli klient ma ustawiony nagłówek "<tt>From: <var>bar</var>@<var>bogus.dom</var></tt>"
</list>

Nawet jeśli klient ma ustawiony nagłówek <tt>From:</tt>, serwer może dodać
nagłówek "<tt>Sender:<var>foo</var>@<var>herman.dom</var></tt>" tak by
zaznaczyć prawdziwe źródło pochodzenia.
<p>
Oczywiście jeśli serwer podejmie próbę podmienienia adresu tak jak zostało
to omówione w <ref id="addr-catchall"> i <ref id="addr-rewrite">, adres
email widoczny dla odbiorcy może być zmieniony na cokolwiek.

<sect id="net-dns">Usługa nazw (DNS)
<p>
Komputery rozpoznawane są przez domenę tak samo jak przez adresy IP.
DNS jest systemem typu klient-serwer, który zamienia nazwy na podstawie
danych z serwerów nazw tak by nazwa była powiązana z adresem IP i innymi
właściwościami komputera.
Biblioteka GNU C <manref name="resolver" section="3"> może również
poszukiwać adresów IP w plikach lub odwoływać się do Network Information 
Services (NIS).
<p>
By zobaczyć jaka nazwa domeny jest powiązana z lokalnym komputerem, użyj
polecenia <prgn>hostname --fqdn</prgn>. Spowoduje to wyświetlenie pierwszej
pełnej nazwy domenowej znalezionej dla lokalnego komputera przez program
rozwiązujący nazwy.
<footnote>
Technicznie, jest to FQDN zwracany przez 
<manref name="gethostbyname" section="2"> dla komputera zwracanego przez
<manref name="gethostname" section="2">.
</footnote>
<p>

<sect1 id="dns-resolver">Resolver

<p>
Odszukiwaniem informacji o tym jaki adres IP jest powiązany z konkretną 
nazwą domeny zajmuje się resolver. Najczęściej używanym resolverem jest 
zbiór funkcji o tej nazwie (<manref name="resolver" section="3">) 
w bibliotece GNU C.

Innym jest FireDNS resolver z pakietu <package>libfiredns</package>.

<p>
To w jaki sposób resolver LIBC rozwiązuje nazwy jest zdefiniowane w lini
<tt>hosts</tt> pliku konfiguracyjnego <file>/etc/nsswitch.conf</file>.
Ta linia zawiera usługi, które powinny być użyte do rozwiązania nazwy: np.
<tt>dns</tt>, <tt>files</tt>, <tt>nis</tt>, <tt>nisplus</tt>.

<footnote>
Przyjmuje się, że to w jaki sposób resolver rozwiązuje nazwy jest również
zdefiniowane w pliku konfiguracyjnym <file>/etc/host.conf</file>.
Linia <tt>order</tt> tego pliku zawiera listę metod, które powinny 
zostać użyte do rozwiązania nazwy:
<tt>bind</tt>, <tt>hosts</tt>, <tt>nis</tt>.
Zobacz <manref name="host.conf" section="5">.
Uważam, że ta linia została zastąpiona przez <tt>hosts</tt>
<file>nsswitch.conf</file>, ale nie jestem pewien.
</footnote>

Zobacz <manref name="nsswitch.conf" section="5">.
Dopóki używana jest usługa <tt>files</tt>, zachowanie resolvera definiuje
również plik konfiguracyjny <file>/etc/hosts</file>.
Zobacz <manref name="hosts" section="5">.
<p>
Wszystkie wymienione pliki są statyczne i mogą być edytowane przy pomocy
ulubionego edytora.
<p>
Dopóiki używana jest usługa <tt>dns</tt>, zachowanie resolvera
definiuje również plik konfiguracyjny <file>/etc/resolv.conf</file>.
Zobacz <manref name="resolv.conf" section="5">.

Jedną z najważniejszych funkcji <file>resolv.conf</file>
jest lista adresów IP serwerów nazw z którymi będzie nawiązywany kontakt
w celu rozwiązania nazwy.
Ta lista często zależy od środowiska sieciowego, a ono może się zmieniać
od czasu do czasu gdy komputer jest uruchomiony.
Takie programy jak <prgn>pppd</prgn> i <prgn>dhclient</prgn>
mają możliwość manipulowania plikiem <file>resolv.conf</file>, poprzez 
dodawanie i usuwanie linii, ale te funkcje nie zawsze działają poprawnie 
i konfliktują ze sobą.
Pakiet <package>resolvconf</package> radzi sobie z tym problemem lepiej 
poprzez standard aktualizowania tego pliku.
Zobacz <ref id="dns-resolvconf">.
<p>

<sect1 id="dns-resolvconf">Zarządzanie informacjami o serwerach nazw &ndash; <package>resolvconf</package>

<p>
Pakiet <package>resolvconf</package> dostarcza standard do dynamicznego
zarządzania informacją o dostępnych serwerach nazw.
Rozwiązuje dawny problem zarządzania dynamiczną listą serwerów nazw dla 
resolvera i buforu DNS.
Resolvconf ustawia się jako pośrednik między programami, które kontrolują 
interfejsy sieciowe i dostarczają informacji o serwerach nazw, a programami, 
które tych informacji potrzebują.
 <p>
<package>resolvconf</package> jest zaprojektowany by działać, bez potrzeby
jakiejkolwiek ręcznej konfiguracji.
Jednakże pakiet ten jest raczej nowy i może wymagać ręcznej interwencji
by działał poprawnie. To będzie z pewnością wymagane jeśli kiedykolwiek
instalowałeś własne pakiety, które aktualizują <file>/etc/resolv.conf</file>:
wtedy będziesz musiał wyłączyć te aktualizacje.
  	 <p>
Szczegóły w <url id="&f-resolvconf;">.

<sect1 id="dns-dnsmasq">Buforowanie rozwiązanych nazw &ndash; 
<package>dnsmasq</package>
<p>
Jeżeli Twój serwer nazw nie musi być autorytatywnym dla domeny to lepiej 
włączyć buforowanie rozwiązywania nazw na przykład przy pomocy 
<package>dnsmasq</package>. Współpracuje dobrze z 
<package>resolvconf</package>.
  	 
<sect1 id="dns-bind-cache">Buforowanie rozwiązanych nazw &ndash;
<package>bind</package>
<p>
Możesz również użyć <package>bind9</package> lub
<package>bind</package>a jako lokalny bufor rozwiązanych nazw.
Również dobrze współpracuje z <package>resolvconf</package>, ale w momencie
pisania tego (październik 2003), trzeba ustawiać go ręcznie.
Instrukcje w <url id="&f-resolvconf;">.

<sect1 id="dns-bind-server">Udostępnianie DNS &ndash; <package>bind</package>
<p>
Jeśli musisz udostępniać autorytatywnych informacji o nazwach dla
domeny, potrzebujesz pełnego serwera nazw, takiego jak <prgn>named</prgn>,
który znajduje się albo w pakiecie <package>bind9</package> albo 
<package>bind</package>.
Dla nowych instalacji zalecany jest <package>bind9</package>.
<p>
By zainstalować <package>bind9</package>, zainstaluj te podstawowe pakiety:
<package>bind9</package>;
<package>dnsutils</package>.
Jeśli chcesz, możesz doinstalować również te pakiety z narzędziami:
<package>bind9-host</package>;
<package>dns-browse</package>;
<package>dnscvsutil</package>;
<package>nslint</package>.
Jeśli chcesz, możesz doinstalować również pakiet z dokumentacją:
<package>bind9-doc</package>.
Jeśli chcesz, możesz doinstalować również pakiety deweloperskie:
<package>libbind-dev</package>;
<package>libnet-dns-perl</package>.
<p>
Zainstaluj <package>bind9</package> lub przekonfiguruj go przy pomocy 
<prgn>dpkg-reconfigure</prgn> by dokonać podstawowych ustawień.
Konfiguracja dokonuje się poprzez edycję pliku <file>named.conf</file>.
W systemie &debian; ten plik znajduje się w <file>/etc/bind/</file> i jest
używany głównie do definicji podstawowych stref DNS; <tt>zawiera</tt> 
dwa inne pliki:
<file>named.conf.local</file>, używany do definicji lokalnych stref, oraz
<file>named.conf.options</file>, używany do ustawień opcji.
Ten drugi jest przetwarzany przez <package>resolvconf</package> by utworzyć
<file>/var/run/bind/named.options</file>, który jest identyczny
z oryginalnym poza opcją <tt>forwarders</tt>, która zawiera listę aktualnie
dostępnych nielokalnych serwerów nazw.
By z niego skorzystać, zmień linię <tt>include</tt> w
<file>named.conf</file> tak by zawierała 
<file>/var/run/bind/named.options</file>.
Zobacz <ref id="dns-resolvconf">.)
<p>
Pliki z danymi wprowadzone w <file>named.conf*</file> bez pełnej ścieżki
będą przetrzymywane w <file>/var/cache/bind/</file>.
To prawidłowe miejsce na przetrzymywanie plików generowanych przez 
<prgn>named</prgn>a: na przykład, plików z danymi dla stref dla których
jest serwerem podrzędnym.
Statyczne pliki z danymi w <file>/etc/bind/</file> są i muszą być wpisane 
w <file>named.conf</file> wraz z pełnymi ścieżkami.
Szczegóły w <url id="&f-bind9;">.

<sect id="net-dhcp">Konfiguracja interfejsów sieciowych z wykorzystaniem DHCP
<p>
Zaawansowana konfiguracja interfejsów sieciowych może być zautomatyzowana
przez Dynamic Host Configuration Protocol (DHCP).
Twój firewall lub router lub dostawca internetu może udostępniać adresy IP
i inne parametry w ten sposób.
<p>
By skorzystać z tych usług musisz zainstalować jeden z następujących
pakietów:
<list compact>
<item><package>dhcp3-client</package> (wersja 3, Internet Software Consortium)
<item><package>dhcpcd</package> (Yoichi Hariguchi i Sergei Viznyuk)
<item><package>pump</package> (Redhat)
</list>
<package>pump</package> jest prosty i popularny.
<package>dhcp3-client</package> jest bardziej skomplikowany, ale również ma
większe możliwości konfiguracyjne.
<footnote>
W październiku 2003 roku dostępny jest również pakiet 
<package>dhcp-client</package>. Zawiera on wersję 2 klienta DHCP ISC, który
został zastąpiony przez wersję 3 z pakietu <package>dhcp3-client</package>.
Opiekunowie zamierzają przechrzcić pewnego dnia 
<package>dhcp3-client</package> na <package>dhcp-client</package>, ale
wygląda na to, że nie stanie się to przed wydaniem Sarge.
</footnote>

<sect id="net-high">Konfiguracja sieci wyższego poziomu w systemie &debian;
<p>
W celu ułatwienia konfiguracji sieci, system &debian; dostarcza
standardowe narzędzia konfiguracyjne wyższego poziomu, na które składają się
programy <prgn>ifup</prgn> i <prgn>ifdown</prgn> oraz plik
<file>/etc/network/interfaces</file>.
<footnote>
Format pliku <file>/etc/network/interfaces</file> dla aktualnej wersji 
<package>ifupdown</package> jest niekompatybilny z formatem używanym we
wcześniejszych wersjach pakietu w Potato.
Skrypt poinstalacyjnych pakietu <package>ifupdown</package> powinien
zaktualizować plik automatycznie, jeśli pojawi się taka konieczność.

<!-- 
However, if you are upgrading from Potato then you should read
<manref name="interfaces" section="5"> and examine
<file>/etc/network/interfaces</file> to make sure that the file
was converted properly.
My intial note was issues over downgrade from Woody to Potato but it is
not needed since Woody is stable already and no more old-stable support
exist for Potato.
-->

</footnote>

Jeśli zdecydujesz się na użycie <package>ifupdown</package> do zarządzania
konfiguracją swojej sieci, <strong>nie</strong> powinieneś jednocześnie
używać poleceń niższego poziomu.
<footnote>
To oznacza również, że nie powinieneś używać innych narzędzi
konfiguracyjnych wyższego poziomu, takich jak <package>whereami</package>,
który korzysta z narzędzi niższego poziomu.
</footnote>
<package>Ifupdown</package> został napisany z myślą, że będzie używany
samodzielnie do konfiguracji i dekonfiguracji interfejsów sieciowych.
<p>
By zaktualizować konfigurację interfejsów:

<example>
# ifdown eth0
# editor /etc/network/interfaces  # dostosuj według potrzeb
# ifup eth0
</example>
<p>

Więcej informacji uzyskasz w <manref name="interfaces" section="5">,
<url id="&f-ifupdown;"> i <manref name="ifup" section="8">.

<sect1 id="high-static">Konfiguracja interfejsu ze statycznym adresem IP
<p>
Załóżmy, że chcesz skonfigurować interfejs Ethernet tak by miał adres 
<tt>192.168.0.123</tt>. Ten adres zaczyna się od <tt>192.168.0</tt>, tak
więc musi znajdować się w sieci lokalnej (LAN).
Załóżmy dodatkowo, że <tt>192.168.0.1</tt> jest adresem bramki sieciowej.
Przeedytuj <file>/etc/network/interfaces</file> tak by zawierał linie
podobne do poniższych:
<example>
iface eth0 inet static
        address 192.168.0.123
        netmask 255.255.255.0
        gateway 192.168.0.1
</example>

Jeśli posiadasz zainstalowany <package>resolvconf</package> możesz dodać
linie określające informacje DNS. Przykłado:
<example>
iface eth0 inet static
        address 192.168.0.123
        netmask 255.255.255.0
        gateway 192.168.0.1
        dns-search extradomena.org
        dns-nameservers 195.238.2.21 195.238.2.22
</example>

Po podniesieniu interfejsu, argumenty opcji <tt>dns-search</tt> i 
<tt>dns-nameservers</tt> są dostępna dla <package>resolvconf</package>, by
mógł je włączyć do <file>resolv.conf</file>.
Argument <tt>extradomena.org</tt> opcji <tt>dns-search</tt> odpowiada
argumentowi opcji <tt>search</tt> w <manref name="resolv.conf" section="5">.
Argumenty <tt>195.238.2.21</tt> i <tt>195.238.2.22</tt> opcji 
<tt>dns-nameservers</tt> odpowiadają argumentom opcji <tt>nameserver</tt> 
w <manref name="resolv.conf" section="5">.
Inne rozpoznawane opcje to <tt>dns-domain</tt> i <tt>dns-sortlist</tt>.
Zobacz <ref id="dns-resolvconf">.

<sect1 id="high-dhcp">Konfiguracja interfejsu z użyciem DHCP
<p>
By skonfigurować interfejs z użyciem DHCP przeedytuj 
<file>/etc/network/interfaces</file> tak by zawierał linijkę podobną do:
<example>
iface eth0 inet dhcp
</example>
Aby to zadziałało musisz mieć zainstalowany jeden z klientów DHCP
wspomnianych w <ref id="net-dhcp">.

<sect1 id="high-wifi">Konfiguracja interfejsu bezprzewodowego Wi-Fi
<p>
Pakiet <package>wireless-tools</package> zawiera skrypt 
<file>/etc/network/if-pre-up.d/wireless-tools</file>, który pozwala na
konfigurowanie sprzętu Wi-Fi (802.11a/b/g) zanim interfejs zostanie
podniesiony. Konfiguracji dokonuje się używając programu <prgn>iwconfig</prgn>;
zobacz <manref name="iwconfig" section="8">.
Dla każdego możliwego parametru polecenia <prgn>iwconfig</prgn> możesz
dołączyć opcję o takiej samej nazwie w <file>/etc/network/interfaces</file> 
poprzedzając ją przedrostkiem "wireless-".
Przykładowo by ustawić  ESSID dla <tt>eth0</tt> na 
<tt>myessid</tt> i klucz szyfrujący na 
<tt>123456789e</tt> przed podniesieniem interfejsu 
<tt>eth0</tt> używając DHCP, przeedytuj 
<file>/etc/network/interfaces</file> tak by zawierał poniższe linie:
<example>
iface eth0 inet dhcp
        wireless-essid myessid
        wireless-key 123456789e
</example>

<sect1 id="high-ppp">Konfiguracja interfejsu PPP
<p>
Programy <prgn>ifup</prgn> i <prgn>ifdown</prgn> używają <prgn>pon</prgn> 
i <prgn>poff</prgn> do dodawania i usuwania interfejsów PPP więc najpierw
przeczytaj <ref id="low-ppp">.
<p>
Załóżmy, że ustawiłeś PPP by działało z połączeniem <tt>mojisp</tt>.
Przeedytuj <file>/etc/network/interfaces</file> tak by zawierał poniższe
linie:
<example>
iface ppp0 inet ppp
        provider mojisp
</example>

Z takim ustawieniem <prgn>ifup ppp0</prgn> uruchomi 
<example>
pon mojisp
</example>
Niestety nie ma w tej chwili możliwości by przekazać dodatkowe opcje dla 
<prgn>pppd</prgn> w liniach dotyczących <tt>ppp</tt> znajdujących się
<file>/etc/network/interfaces</file>.
<footnote>
Zobacz błąd <url id="&bug-iud-pon-args;" name="#196877">.
</footnote>
<p>
Nie jest w tej chwili możliwe użycie <package>ifupdown</package> do
przeprowadzenia pomocniczej konfiguracji interfejsów PPP. Ponieważ 
<prgn>pon</prgn> istnieje zanim <prgn>pppd</prgn> skończy nawiązywanie
połączenia, <prgn>ifup</prgn> uruchamia skrypty <tt>up</tt> zanim interfejs
PPP jest gotowy do użycia.
Dopóki ten błąd
<footnote>
Zobacz błąd <url id="&bug-iud-ppp-wait;" name="#127786">.
</footnote>
nie zostanie poprawiony, wymagane jest konfigurowanie przez edycję plików 
<file>/etc/ppp/ip-up</file> lub <file>/etc/ppp/ip-up.d/</file>.

<sect1 id="high-pppoe">Konfiguracja interfejsu PPPoE
<p>
Wiele dostawców internetu (ISP) używa PPP do negocjacji połączenia nawet
w momencie gdy maszyna klienta podłączona jest poprzez Ethernet lub/i 
sieć ATM. Realizuje się to używając PPP ponad Ethernetem (PPPoE), który
jest techniką pakowaia strumieni PPP w ramkach Ethernetu.
Załóżmy, że Twój dostawca nazywa się <tt><var>mojisp</var></tt>.
Najpierw skonfigurujemy PPP i PPPoE do połączenia <tt><var>mojisp</var></tt>.
Najprostszym sposobem osiągnięcia tego jest instalacja pakietu 
<package>pppoeconf</package> i uruchomienie w konsoli
<prgn>pppoeconf</prgn>. Następnie przeedytuj 
<file>/etc/network/interfaces</file> tak by zawierało poniższe linie:
<example>
iface eth0 inet ppp
        provider <var>mojisp</var>
</example>

<!--
The better one is following but need verification
<example>
mapping eth0
        script /root/bin/echo-ppp0

iface ppp0 inet ppp
        provider <var>myisp</var>
</example>
where,
<example>
# cat &gt; /root/bin/echo-ppp0 &lt;&lt;EOF
# /bin/sh
echo ppp0
EOF
# chmod 755 /root/bin/echo-ppp0
</example>
-->

<p>
Czasami występują problemy z Maksymalną Jednostką Transmisji (MTU)
w połączeniu z PPPoE przez Digital Subscriber Line (DSL).
Szczegóły znajdziesz w <url id="&dsl-howto;" name="DSL-HOWTO">.
<p>
Zauważ, że jeśli Twój modem zawiera router, wtedy modem/router obsługuje
połączenie PPPoE samodzielnie i pojawia się w sieci jako zwykła bramka
Ethernetowa.
 
<sect1 id="high-dual">Konfiguracja wielu interfejsów Ethernet
<p>
Załóżmy, że interfejs <file>eth0</file> jest podłączony do Internetu
z adresem pobieranym poprzez DHCP, a <file>eth1</file> jest podłączony do
sieci lokalnej ze statycznym adresem <tt>192.168.1.1</tt>.
Zmodyfikuj <file>/etc/network/interfaces</file> by zawierało poniższe
wpisy:
<example> 	 
iface eth0 inet dhcp

iface eth1 inet static
	address 192.168.1.1
	netmask 255.255.255.0
</example>

Jeśli na tym komputerze uaktywnisz NAT, tak jak to opisano w 
<ref id="net-router">, będziesz mógł współdzielić połączenie internetowe
ze wszystkimi komputerami z sieci.

<sect1 id="high-virtual">Konfigurowanie interfejsów wirtualnych
<p>
Używając interfejsów wirtualnych możesz skonfigurować jedną kartę Ethernet
by była interfejsem do wielu podsieci. Załóżmy, że Twój komputer jest 
w sieci 192.168.0.x/24. Teraz chcemy podłączyć go do Internetu używając tej
samej karty i adresu publicznego dostarczanego przez DHCP.
Zmodyfikuj <file>/etc/network/interfaces</file> tak by zawierał poniższe
linie:
<example>
iface eth0 inet static
	address 192.168.0.1
	netmask 255.255.255.0
	network 192.168.0.0
	broadcast 192.168.0.255

iface eth0:0 inet dhcp
</example>

Interfejs <tt>eth0:0</tt> jest interfejsem wirtualnym.
Jego rodzicem jest <tt>eth0</tt>.

<sect id="net-reconf"><strong>Re</strong>konfiguracja sieci

<p>
W poniższych rozważaniach ważne jest by czytelnik rozumiał różnicę pomiędzy 
<strong>fizycznym</strong>, a <strong>logicznym</strong> interfejsem.

<footnote>
Taka terminologia jest używana w dokumentacji pakietu 
<package>ifupdown</package>.
</footnote>


Interfejs fizyczny jest tym co do tej pory nazywaliśmy "interfejsem",
a więc rzeczy określane jako <tt>eth0</tt>, <tt>ppp1</tt> i podobnie.

Logiczny interfejs to zbiór wartości, które mogą być przydzielone do
zmienny parametrów interfejsu fizycznego. Jeśli jest to dla Ciebie
niezrozumiałe, zamieniaj podczas czytania wyrażenie 
"skonfigurowany jako interfejs logiczny <tt>X</tt>" na 
"skonfigurowany z profilem interfejsu <tt>X</tt>".
<p>
Definicje <tt>iface</tt> w <file>/etc/network/interfaces</file> są
definicjami logicznych interfejsów, a nie fizycznych.

<footnote>
Zauważ, że interfejsy wymienione w liniach <tt>auto</tt> są fizycznymi,
a nie logicznymi interfejsami.
</footnote>

Jeśli nie zamierzasz nigdy rekonfigurować interfejsów, to możesz zignorować
ten fakt, bo fizyczny interfejs <tt>X</tt> domyślnie będzie skonfigurowany
jako logiczny interfejs <tt>X</tt>.
<p>

Załóżmy jednakże, że Twój komputer to laptop, którego przewozisz między
pracą i domem. Gdy podłączasz go do sieci korporacyjnej lub do sieci
domowej, musisz odpowiedni skonfigurować <tt>eth0</tt>.
<p>
Najpierw zdefiniuj dwa logiczne interfejsy <tt>dom</tt> i <tt>praca</tt>
(zamiast jednego <tt>eth0</tt> jak to robiliśmy wcześniej), które opisują
jak interfejsy powinny być skonfigurowane dla odpowiednich sieci.
<example>
iface dom inet static
	address 192.168.0.123
	netmask 255.255.255.0
	gateway 192.168.0.1
  	 
iface praca inet static
	address 81.201.3.123
	netmask 255.255.0.0
	gateway 81.201.1.1
</example>

Wtedy fizyczny interfejs <tt>eth0</tt> może zostać podniesiony dla sieci
domowej z użyciem odpowiedniej konfiguracji, używając w linii poleceń:

<example>
# ifup eth0=dom
</example>

<p>
By przekonfigurować <tt>eth0</tt> do użycia w pracy, wprowadź polecenia:
<example>
# ifdown eth0
# ifup eth0=praca
</example>

<p>
Zauważ, że przy tak napisanym pliku <file>interfaces</file> 
nie ma możliwości podniesienia <tt>eth0</tt> wpisując samo 
<tt>ifup eth0</tt>.
Powodem jest fakt, że <prgn>ifup</prgn> domyślnie używa fizycznej nazwy
interfejsu jako logicznej, a w tym momencie nie ma zdefiniowanych żadnego
interfejsu logicznego <tt>eth0</tt>.


<sect id="net-magic-reconf">Magiczna rekonfiguracja sieci
<p>
Nazwy logicznych interfejsów mogą być "zmapowane" na inne nazwy podczas
uruchamiania <prgn>ifup</prgn>.
To jak nazwy będą mapowane może być uzależnione od różnych warunków.
Zatem <prgn>ifup</prgn> może być tak skonfigurowany, że będzie podnosił
dany interfejs fizyczny jako odpowiedni interfejs logiczny wybrany
z predefiniowanych alternatyw.
<p>
Mapowanie nazw logicznych interfejsów odbywa się następująco:
<list compact>
<item>Jeśli w linii poleceń <prgn>ifup</prgn> nie podano nazwy logicznego
interfejsu, nazwa fizycznego zostanie użyta jako wstępna nazwa.
<item>Jeśli nazwa logicznego interfejsu pasuje do wzorca użytego w części
<tt>mapping</tt> to jest ona użyta do tworzenia nowej nazwy logicznego
interfejsu. Odbywa się to rekursywnie aż do braku dopasowań.
<item>Jeśli ostatnia nazwa logicznego interfejsu jest etykietą defuuchu
ubterfejsu w <file>/etc/network/interfaces</file>, to fizyczny interfejs
jest podnoszony jako logiczny.
W przeciwnym wypadku <prgn>ifup</prgn> wyświetla komunikat 
"Ignoring unknown interface" i kończy swoje działanie.
</list>
Składnia części <tt>mapping</tt> wygląda następująco:

<example>
mapping <var>wzorzec</var>
	script <var>nazwa-skryptu</var>
	[map <var>dane skryptu</var>]
</example>

Skrypt określony w części <tt>mapping</tt> jest uruchamiany z nazwą
fizycznego interfejsu jako jego argument oraz z zawartością wszystkich
następujących linii "map" podanych na wejście standardowe skryptu.
Skrypt wypisuje rezultat mapowania na swoim standardowym wyjściu tuż przed
zakończeniem.
<p>
Przykładowo poniższy wpis <tt>mapping</tt> sprawi, że <prgn>ifup</prgn>
podniesie interfejs <tt>eth0</tt> jako interfejs logiczny <tt>dom</tt>.
<example>
mapping eth0
	script /usr/local/sbin/echo-home
</example>
gdzie <prgn>/usr/local/sbin/echo-home</prgn> jest:
<example>
#!/bin/sh
echo home
</example>
<p>
Ponieważ mapowanie odbywa się w skrypcie, istnieje możliwość wyboru
logicznego interfejsu na podstawie różnych testów.
Zacznijmy od przykładu. Załóżmy, że masz inne karty sieciowe w domu
i w pracy. Katalog <file>/usr/share/doc/ifupdown/examples/</file> 
zawiera skrypt mapujący, który może być wykorzystany do wyboru logicznego
interfejsu na podstawie adresu MAC. Najpierw zainstaluj skrypt
w odpowiednim katalogu.
<example>
# install -m770 /usr/share/doc/ifupdown/examples/get-mac-address.sh \
/usr/local/sbin/
</example>
Następnie dodaj poniższy wpis do <file>/etc/network/interfaces</file>:
<example>
mapping eth0
	script /usr/local/sbin/get-mac-address.sh
	map 02:23:45:3C:45:3C dom
	map 00:A3:03:63:26:93 praca
</example>
<p>
Bardziej skomplikowane programy mapujące są opisane poniżej w 
<ref id="high-guessnet">,
<ref id="high-ifupdown-roam"> i 
<ref id="high-laptop-net">.

<sect1 id="high-guessnet">guessnet
<p>
Zainstaluj <package>guessnet</package> i dodaj poniższy wpis do 
<file>/etc/network/interfaces</file>:
<example>
mapping eth0
	script guessnet-ifupdown
	map dom
	map praca
</example>

Teraz przy wpisaniu <prgn>ifup eth0</prgn> <prgn>guessnet</prgn> sprawdzi
czy <tt>eth0</tt> może być podniesiony jako <tt>dom</tt> czy jako
<tt>praca</tt>. By to osiągnąć <prgn>guessnet</prgn> używa informacji
przechowywanej w definicjach logicznych interfejsów. Korzysta z żądań ARP
by wykryć bramę sieciową albo z komputera opisanego w linii
<tt>test-peer</tt>.
<p>
<package>guessnet</package> jest w ciągłym rozwoju.

<sect1 id="high-ifupdown-roam">ifupdown-roam
<p>
Pakiet <package>ifupdown-roam</package> zawiera program
<prgn>ifscout</prgn>, którego możliwości mapowania są rozszerzeniem
guessnet. <prgn>ifscout</prgn> wywołuje <prgn>guessnet</prgn> by odszukać
komputery w bezprzewodowej sieci Ethernet, ale potrafi również wykryć
serwery DHCP i bezprzewodowe punkty dostępu. <prgn>ifscout</prgn> jest
skryptem powłoki więc może być dostosowany do Twoich potrzeb.
<p>
Aktualnie (październik 2003) <package>ifupdown-roam</package> nie jest
częścią Debiana. Możliwe, że w chwili gdy to czytasz jest już w archiwach
Debiana; w przeciwnym razie możesz go pobrać z jego 
<!-- <url id="&iudroam-home;" name="the ifupdown-roam home page"> -->
gdzie znajdziesz również informacje na temat instalacji i użytkowania.
  	 
<sect1 id="high-laptop-net">laptop-net
<p>
Pakiet <package>laptop-net</package> stosuje inne podejście do
automatycznej rekonfiguracji sieci. 
Nie korzysta z logicznych interfejsów <package>ifupdown</package>,
a zamiast tego ma swój system "schematów" i "profili".
Mimo to laptop-net nadal używa <package>ifupdown</package> do konfiguracji
fizycznych interfejsów. Więcej informacji znajdziesz w przystępnie
napisanej dokumentacji z pakietu <package>laptop-net-doc</package>.
 	 
<sect id="net-trigger">Wywoływanie rekonfiguracji sieci
<p>
Widzieliśmy już jak można przekonfigurować interfejsy. Rekonfiguracja musi
się odbywać w odpowiednim momencie.

<p>
Tradycyjnie sieć jest konfigurowana podczas sekwencji uruchomieniowej przez 
skrypt inicjalizacyjny <file>/etc/rcS.d/S40networking</file> i jest rzadko
zmieniana. Usługi wykorzystujące sieć są uruchamiane później. Podczas
wyłączania systemu skrypty inicjalizujące są uruchamiane w odwrotnej
kolejności.
<p>
Jednakże aktualnie można zauważyć trend w którym GNU i Linux zmierza do
obsługi sprzętu i wyjątków, które zmieniają się dynamicznie.
Na początku dodano obsługę dla wymienialnych kart PCMCIA; później został
zaimplementowany mechanizm <tt>hotplug</tt>, który umożliwia wymianę
większej ilości sprzętu podczas pracy komputera. 
Zawiera się w tym również sprzęt sieciowy. Zauważ, że usługi, które zależą
od wymienialnego podczas pracy sprzętu muszą być uruchamiane po
włożeniu owego sprzętu, a zatrzymywane po jego wyjęciu. To oznacza, że te
usługi muszą być usunięte spod kontroli systemu inicjalizującego System
V i obsługiwane przez <package>ifupdown</package>.
<p>
Załóżmy przykładowo, że usługa <tt>foo</tt> obsługiwana przez skrypt
inicjalizacyjny <file>/etc/init.d/foo</file> zależy od dynamicznie
rekonfigurowanego interfejsu sieciowego <tt>eth0</tt>.
<list compact>
<item>Najpier usuń <tt>foo</tt> spod kontroli systemu inicjalizującego:
<example>
# update-rc.d -f foo remove
</example>
<item>Następnie umieść <tt>foo</tt> pod kontrolą 
<package>ifupdown</package> dodając w <file>/etc/network/interfaces</file>
przy interfejsie <tt>eth0</tt> opcje <tt>up</tt> i <tt>down</tt>,
które będą wywoływać skrypt inicjalizujący <tt>foo</tt>:
<example>
iface eth0 inet dhcp
	up /etc/init.d/foo start
	down /etc/init.d/foo stop
</example>
</list>

<sect1 id="trigger-auto">Wywoływanie konfiguracji sieci podczas uruchamiania
<p>
Podczas uruchamiania systemu skrypt inicjalizujący 
<prgn>/etc/rcS.d/S40networking</prgn> uruchamia polecenie <prgn>ifup -a</prgn>.
Podnosi to wszystkie fizyczne interfejsy wymienione
w <file>/etc/network/iterfaces</file> z opcją <tt>auto</tt>.
<p>
Na dzień dzisiejszy w wielu przypadkach lepiej jest zarządzać konfiguracją
sieci w sposób dynamiczny. W momencie gdy mechanizmy obsługujące
dynamicznie zmieniający się sprzęt są uruchomione, można dużo łatwiej
traktować sprzęt statyczny jakby był również dynamiczny. 
Uruchamianie można wtedy postrzegać jako kolejne zdarzenie hotplug (zmiany
sprzętu). (Zobacz <ref id="trigger-hotplug">.)
<p>
Jednakże w większości przypadków będziesz chciał podnosić podczas
uruchamiania przynajmniej interfejs zwrotny <tt>lo</tt>. 
W związku z tym upewnij się, że <file>/etc/network/interfaces</file>
zawiera następujący wpis:
<example>
auto lo
face lo inet loopback
</example>
<!--
Above should be separated by some space to show that they are
distinct stanzas
-->
Możesz dopisać inne fizyczne interfejsy jeśli chcesz by również były 
podnoszone podczas uruchamiania systemu. 
<strong>Nigdy</strong> nie wpisuj interfejsów PCMCIA w części <tt>auto</tt>.
<prgn>cardmgr</prgn> PCMCIA jest uruchamiany po uruchomieniu 
<prgn>/etc/rcS.d/S40networking</prgn>.
  	 
<sect1 id="trigger-hotplug">Wywoływanie konfiguracji sieci &ndash;
<package>hotplug</package>
<p>
By otrzymać obsługę hotplug (urządzenia, które mogą być dokładane/usuwane
podczas pracy komputera), zainstaluj pakiet <package>hotplug</package>.
<p>

Sprzęt sieciowy może być dołożony albo podczas uruchamiania albo już po nim
gdy karta (np. karta PCMCIA) jest włożona do komputera albo narzędzie 
<prgn>discover</prgn> zostaje uruchomione i ładuje odpowiednie moduły
sterowników.
<footnote>
Jeśli Twój system uruchamia <prgn>discover</prgn> w pliku 
<file>/etc/rcS.d/S36discover</file>, musisz przenieść go do 
<file>/etc/rcS.d/S40discover</file>. Zobacz błąd 
<url id="&bug-rcs-discover;" name="#208155">.
</footnote>
<p>
Kiedy jądro wykrywa nowe urządzenie, inicjalizuje sterownik, a następnie
uruchamia program <prgn>hotplug</prgn> by je skonfigurować.
Później gdy sprzęt jest usuwany, jądro uruchamia <prgn>hotplug</prgn>
ponownie, ale z innymi zmiennymi środowiskowymi. W systemie &debian;, podczas 
gdy wywoływany jest <prgn>hotplug</prgn>, uruchamia on skrypty z 
<file>/etc/hotplug/</file> i <file>/etc/hotplug.d/</file>. Szczegóły
znajdziesz w <manref name="hotplug" section="8">.
<p>
Nowo włożony sprzęt sieciowy jest konfigurowany przez skrypt 
<file>/etc/hotplug/net.agent</file>.
<footnote>
Może być również konfigurowany przez jakikolwiek inny skrypt umieszczony 
w <file>/etc/hotplug.d/net/</file>.
</footnote>

Załóżmy, że Twoja karta sieciowa PCMCIA została włożona, a co za tym idzie
interfejs <tt>eth0</tt> jest dostępny do wykorzystania. 
<file>/etc/hotplug/net.agent</file> wykonuje następujące polecenie:
<example>
ifup eth0=hotplug
</example>
Jeśli nie dodasz definicji interfejsu logicznego lub mapowania o nazwie
<tt>hotplug</tt> w <file>/etc/network/interfaces</file> to to polecenie nic
nie zdziała. By sprawić, aby to polecenie skonfigurowało <tt>eth0</tt>,
dodaj następujący wpis do <file>/etc/network/interfaces</file>:
<example>
mapping hotplug
	script echo
</example>
Tak jak wyjaśniono to w <ref id="net-reconf"> taki wpis zmapuje pokazane
polecenie, więc odpowiada następującemu:
<example>
ifup eth0=eth0
</example>
<p>

(<strong>Nie</strong> używaj tego typu wpisów mapowania jeśli do kontroli
interfejsu używasz <prgn>ifplugd</prgn> uruchamionego przez 
<prgn>hotplug</prgn>, tak jak to opisano w <ref id="trigger-ifplugd">.)
<p>
Jeśli chcesz jedynie by <tt>eth0</tt> zostało podniesione, użyj 
<prgn>grep</prgn> zamiast <prgn>echo</prgn> jak w przykładzie poniżej:

<example>
mapping hotplug
	script grep
	map eth0
</example>

Więcej wskazówek znajdziesz w <ref id="net-magic-reconf"> i 
<url id="&f-hotplug;">.
  	 
<sect1 id="trigger-ifplugd">Wywoływanie konfiguracji sieci &ndash;
<package>ifplugd</package>
<p>
<package>ifplugd</package> podnosi interfejs w zależności od tego czy
sprzęt jest podłączony do sieci czy nie.
Może on wykryć podłączenie kabla Ethernet lub punkt dostępowy związany
z interfejsem Wi-Fi. Gdy <prgn>ifplugd</prgn> zauważy, że stan połączenia
się zmienił, uruchamia pośredni skrypt, który domyślnie uruchamia 
<prgn>ifup</prgn> lub <prgn>ifdown</prgn> dla danego interfejsu.
<p>
<package>ifplugd</package> dobrze współpracuje z <package>hotplug</package>.
Po włożeniu karty, które powoduje możliwością skorzystania z interfejsu, 
<file>/etc/hotplug.d/net/ifplugd.hotplug</file> uruchamia instancję 
<prgn>ifplugd</prgn> dla tego interfejsu.
Gdy <prgn>ifplugd</prgn> wykryje, że karta jest podłączona do sieci
podnosi interfejs korzystając z <prgn>ifup</prgn>.
  	 
<sect1 id="trigger-waproamd">Wywoływanie konfiguracji sieci &ndash;
<package>waproamd</package>
<p>
By powiązać punkt dostępowy z kartą Wi-Fi możliwe, że zaistnieje
konieczność zaprogramowania jej z odpowiednim kluczem szyfrującym WEP.
Jeśli do kontrolowania <prgn>ifup</prgn> korzystasz z <prgn>ifplugd</prgn> 
tak jak to opisano w <ref id="trigger-ifplugd"> to oczywiste jest, że 
nie możesz ustawić klucza szyfrującego, bo <prgn>ifup</prgn> odpalany jest
już po fakcie. Jednym z możliwych rozwiązań jest zaprogramowanie wszystkich
wymaganych kluczy w nienaruszalnej pamięci karty Wi-Fi. Jeśli jednak
przemieszczasz się pomiędzy wieloma sieciami, to Twoja karta Wi-Fi
prawdopodobnie nie będzie w stanie przechowywać tak wiele kluczy.
<p>
Innym rozwiązaniem jest skorzystanie z <prgn>waproamd</prgn>, który ustawia 
klucz szyfrujący WEP w zależności od tego jaki punkt dostępowy zostanie
wyszukany. 
<p>
<package>waproamd</package> dobrze współpracuje z <package>hotplug</package>.
Gdy karta zostanie włożona, przez co uzyskamy możliwość wykorzystania
interfejsu, <file>/etc/hotplug.d/net/waproamd.hotplug</file> uruchamia
instancję <prgn>waproamd</prgn> dla tego interfejsu.
<prgn>waproamd</prgn> dobrze współpracuje również z <prgn>ifplugd</prgn>.
<p>
Sprawdź plik README z pakietu <package>waproamd</package> by dowiedzieć się
więcej.

<sect1 id="trigger-pcmcia">Konfiguracja sieci i PCMCIA
<p>
W poprzednich wydaniach systemu &debian; standardowym sposobem konfiguracji 
kart sieciowych PCMCIA było wykorzystanie możliwości pakietu 
<package>pcmcia-cs</package>.
Skrypty z <file>/etc/pcmcia/</file> są wykonywane przez <prgn>cardmgr</prgn>, 
daemon, który zarządza 16-bitowymi kartami PCMCIA, po ich włożeniu lub
wyjęciu. 
Niektórzy używają <package>pcmcia-cs</package> w jego domyślnej
konfiguracji, w której <file>/etc/pcmcia/network</file> wywołuje 
<prgn>ifup</prgn> po dodaniu interfejsu i <prgn>ifdown</prgn> po jego
usunięciu. Inni używają specjalnego systemu wywołań niskopoziomowych
poleceń konfiguracyjnych, które są zaimplementowane w 
<file>/etc/pcmcia/network</file> i uaktywnione gdy w 
<file>/etc/pcmcia/network.opts</file> odpowiednie opcje ustawione są na 
<tt>y</tt>. Ten drugi sposób pociąga za sobą wiele problemów. Działa tylko
z 16-bitowymi kartami PCMCIA oraz duplikuje funkcje 
<package>ifupdown</package>.
Z kolei mechanizm <package>pcmcia-cs</package> konfiguracji sieci jest
uważany za przestarzały na rzecz <package>hotplug</package> opisanego w 
<ref id="trigger-hotplug">.
<p>
By wyłączyć wszystkie mechanizmy konfiguracji interfejsów sieciowych w 
<package>pcmcia-cs</package>, dodaj następującą linię:
<example>
exit 0
</example>
na początku pliku <file>/etc/pcmcia/network</file>.
<p>
Zauważ, że nie ma nic złego w używaniu <prgn>cardmgr</prgn>.
Po prostu nie chcemy by wywoływał programy konfiguracji sieci.
Zobacz <ref id="kernel-pcmcia"> i 
<url id="&pcmcia-howto;" name="Linux PCMCIA HOWTO">.
  	 
<sect id="net-service-conf">Konfiguracja usług sieciowych
<p>
Typowa konfiguracja usług sieciowych na komputerze/serwerze domowym
zawiera:
<list compact>
<item>Internet <em>super-server</em> i daemon TCP/IP wrapper,
zobacz <ref id="tcpd">.
<list compact>
	<item><file>/etc/inetd.conf</file>
</list>
<item><package>ssh</package>: OpenSSH bezpieczna powłoka, zobacz 
<ref id="ssh">.
<list compact>
	<item><file>/etc/ssh/ssh_config</file>
	<item><file>/etc/ssh/sshd_config</file>
</list>
<item><package>exim</package>: agent transportu poczty, zobacz
<ref id="name-mail">. 
<!-- fenio - dodać po aktualizacji  i <ref id="mta">. -->
<list compact>
	<item><file>/etc/exim/exim.conf</file>
	<item><file>/etc/mailname</file>
	<item><file>/etc/aliases</file>
	<item><file>/etc/email-addresses</file>
</list>
<item><package>fetchmail</package>: daemon do pobierania wiadomości e-mail
z konta POP3, zobacz <ref id="fetchmail">.
<list compact>
	<item><file>/etc/fetchmailrc</file>
</list>
<item><package>procmail</package>: lokalna dystrybucja wiadomości e-mail
oraz program filtrujący, zobacz <ref id="procmail">.
<list compact>
	<item><file>~/.procmailrc</file>
</list>
<item>Nazwa hosta i DNS (serwer pośredniczący, bufor, ...), 
zobacz <ref id="name-host"> i <ref id="net-dns">.
<list compact>
	<item><file>/etc/host.conf</file>
	<item><file>/etc/hostname</file>
	<item><file>/etc/hosts</file>
	<item><file>/etc/hosts.allow</file>
	<item><file>/etc/hosts.deny</file>
	<item><file>/etc/resolv.conf</file>
	<item><file>/etc/bind/named.conf</file> (przeedytuj)
	<item><file>/etc/bind/db.lan</file> (dodaj dla komputerów z sieci lokalnej)
	<item><file>/etc/bind/db.<var>192.168.0</var></file> (dodaj dla
				komputerów z sieci lokalnej, zwrotny DNS)
</list>
<item>DHCP, zobacz <ref id="net-dhcp">.
<list compact>
	<item><file>/etc/dhcp3/dhclient.conf</file> (DHCP klient)
	<item><file>/etc/default/dhcp3-server</file> (DHCP serwer)
	<item><file>/etc/dhcp3/dhcpd.conf</file> (DHCP serwer)
</list>
<item><package>cvs</package>: zobacz <ref id="cvs">.
<list compact>
	<item><file>/etc/cvs-cron.conf</file>
	<item><file>/etc/cvs-pserver.conf</file>
</list>
<item><package>nfs-kernel-server</package>: sieciowy system plików, zobacz
<ref id="nfs">. (dla systemów uniksowych)
<list compact>
	<item><file>/etc/exports</file>
</list>
<item><package>samba</package>: współdzielenie plików i drukarek w sieciach
Windows, zobacz <ref id="samba"> i <ref id="smbmount">.
<list compact>
	<item><file>/etc/samba/smb.conf</file>
</list>
<item>Daemon systemu drukowania, zobacz <ref id="printer">.
<list compact>
	<item><file>/etc/printcap</file> (dla lpr)
</list>
<item><package>apache</package> i <package>apache2</package>: serwer WWW.
<list compact>
	<item><file>/etc/apache/*</file>
	<item><file>/etc/apache2/*</file>
</list>
<item><package>squid</package>: serwer pośredniczący WWW.
<list compact>
	<item><file>/etc/squid/*</file>
</list>
</list>
  	 
  	 <!--
  	 XXX FIXME XXX:
  	 The network service section needs more detailed contents.
  	 Volunteers are welcomed.
  	 -->
  	 <!-- explain each types under sect1 -->
  	 <!-- equivalent ones under sect2 -->
  	 <!-- avoid duplication with tune.sgml -->
  	 <!-- this needs major rewrite -->
  	 <!-- Keep It Short and Simple (KISS) -->
  	 <!-- Use /bin/sh instead of English -->
  	 
<sect id="net-trouble">Rozwiązywanie problemów związanych z siecią
<p>
Jeśli doświadczysz problemów z siecią, wyniki następujących poleceń to
pierwsze co musisz sprawdzić:

<example>
# ifconfig
# cat /proc/pci
# cat /proc/interrupts
# dmesg | more
</example>

Zobacz również podrozdziały <ref id="net-test">.
  	 <!-- add id="..." to corresponding 3 sect1 tags in tips.sgml -->
  	 <!-- That section should be moved here //JDTH -->
  	 <!-- Yes.  But when you do, do it for all languages and fix
  	  version tracking number if you can -->
<p>
Jeśli masz problemy z konkretnymi stronami, zobacz <ref id="killecn">.

<sect id="net-router">Budowanie bramy sieciowej
<p>
Komputer z systemem &debian; może pełnić funkcję pełnej bramy sieciowej,
która wykonuje zamianę adresów sieciowych (NAT, znany również jako
maskarada), obsługuje pocztę, DHCP, buforowanie DNS, pośredniczenie HTTP,
usługę CVS, udostępnianie NFS lub Samby. Zobacz w <ref id="ipmap">
przykłady takich ustawień.
 	 
<sect1 id="router-netfilter">Konfiguracja netfiltra

<p>
Projekt netfilter/iptables jest podsystemem ściany ogniowej dla
Linuksa 2.4 i nowszych.
Udaj się na stronę <url id="&netfilterhome;" name="Netfilter">, gdzie
opisano i wyjaśniono wiele zagadnień dotyczących konfiguracji sieciowej.

<sect2 id="netfilter-basics">Netfilter - podstawy
<p>
Netfilter przetwarza pakiety przy użyciu pięciu wbudowanych łańcuchów:
PREROUTING, INPUT, FORWARD, OUTPUT i POSTROUTING.
<example>
                decyzja
                routingu
IN ------> PRE ---> ------> FORWARD -----> ----> POST -----> OUT
interfejs  ROUTING  \       śledzenie    /       ROUTING     interfejs
           DNAT     |       połączeń     ^       SNAT
           REDIRECT |                    |      MASQUERADE
                    v                    |
                  INPUT                OUTPUT
                    | filtrowanie        ^ filtrowanie,DNAT
                    v                    |
                    \--&gt; Lokalny Proces--/
                            program przestrzeni użytkownika
</example>

<sect2 id="netfilter-table">Tablice Netfilter 
<p>
Pakiety są przetwarzane w każdym łańcuchu w poszczególnych tablicach.
<list compact>
<item>filter (filtrowanie pakietów, domyślna)
<list compact>
<item>INPUT (tylko dla pakietów wchodzących do hosta)
<item>FORWARD (tylko dla pakietów przekazywanych przez hosta)
<item>OUTPUT (tylko dla lokalnie generowanych pakietów).
</list>
<item>nat (network address translation - translacja adresów sieciowych)
<list compact>
<item>PREROUTING (do zmiany zawartości pakietów podczas ich wejścia)
<item>OUTPUT (do zmiany zawartości pakietów generowanych lokalnie, przed 
routingiem)
<item>POSTROUTING (do zmiany zawartości pakietów, gdy wychodzą one z hosta)
</list>
<item>mangle (network address mangling, sprawne tylko w jądrach nowszych niż
2.4.18)
<list compact>
<item>wszystkie 5 wbudowanych łańcuchów.
</list>
</list>

<sect2 id="netfilter-target">Cele Netfilter
<p>
Reguły ściany ogniowej mają wiele celów (miejsc przeznaczenia):
<list compact>
<item>4 podstawowe cele:
<list compact>
<item>ACCEPT przepuszcza pakiet (zezwala na dostęp).
<item>DROP po cichu odrzuca pakiet (nie informuje o tym nikogo).  
<item>QUEUE przekazuje pakiet programowi działającemu w przestrzeni
  użytkownika (jeśli jest to obsługiwane przez jądro).
<item>RETURN zatrzymuje przetwarzanie danego łańcucha i wznawia
  przetwarzanie w następnej regułce poprzedniego (z którego nastąpiło
  wywołanie) łańcucha.
</list>
<item>rozszerzone cele:
<list compact>
<item>LOG włącza logowanie jądra.
<item>REJECT zwraca informację o błędzie nadawcy i odrzuca pakiet.
<item>SNAT zmienia adres źródłowy pakietu i jest używany tylko w łańcuchu
  POSTROUTING (tablica nat).
<example compact>
--to-source  ipaddr[-ipaddr][:port-port]
</example>
<item>MASQUERADE działa tak samo jak SNAT, ale jest przeznaczona dla połączeń
  z dynamicznie przypisywanym numerem IP (połączenie modemowe) (tablica nat).
<example compact>
--to-ports port[-port]
</example>
<item>DNAT zmienia adres docelowy pakietu, jest używany w łańcuchach
  PREROUTING i OUTPUT oraz w zdefiniowanych przez użytkownika łańcuchach,
  które są wywoływane z dwóch powyższych łańcuchów (tablica nat).
<example compact>
--to-destination ipaddr[-ipaddr][:port-port]
</example>
<item>REDIRECT zmienia adres docelowy tak, by pakiet otrzymał komputer,
  na którym działa ogniomurek (czyli ten komputer).
<example compact>
--to-ports port[-port]
</example>
</list>
</list>

<sect2 id="netfilter-command">Polecenia Netfiltera
<p>
Podstawowe polecenia <prgn>iptables</prgn>:
<example compact>
iptables -N <var>łańcuch</var>                   # tworzy <var>łańcuch</var>

iptables -A <var>łańcuch</var> \                 # dodaje regułkę do <var>łańcuch</var>
         -t <var>tablica</var> \                 # w <var>tablica</var> (filter, nat, mangle)
         -p <var>protokół</var> \                # tcp, udp, icmp lub all
         -s <var>adres-źródłowy[/maska]</var> \
         --sport <var>port[:port]</var> \        # port źródłowy, jeśli -p jest tcp lub udp
         -d <var>adres-docelowy[/maska]</var> \
         --dport <var>port[:port]</var> \        # port docelowy, jeśli -p jest tcp lub udp
         -j <var>cel</var> \                     # co zrobić, jeśli regułka pasuje
         -i <var>interfejs-wejściowy</var> \     # dla INPUT,  FORWARD, PREROUTING
         -o <var>interfejs-wyjściowy</var>       # dla FORWARD, OUTPUT, POSTROUTING
</example>

<sect2 id="ip-masq">Zamiana adresów sieciowych (NAT)

<p>
Komputery w sieci lokalnej mogą mieć dostęp do Internetu przez bramkę
sieciową, która zamienia adresy sieci na adresy używane w Internecie.
<example>
# apt-get install ipmasq
</example>
Zastosuj przykładowe reguły, by zwiększyć zabezpieczenia <prgn>ipmasq</prgn>.
Przeczytaj <url id="&f-ipmasq-strong;">.

W przypadku debianowego kernel-image-2.4 upewnij się, że załadowałeś
odpowiednie moduły. Opis potrzebnej konfiguracji jest w
<ref id="kernel-net">.
<p>
W przypadku debianowego kernel-image-2.2, modyfikuj plik
<file>Z92timeouts.rul</file> w katalogu
<file>/etc/masq/rules</file> tak, jak pokazano poniżej, by zapewnić dłuższe
połączenia ze zdalnymi serwerami (dobre dla dużych listów elektronicznych, itp.):
<example>
# tcp, tcp-fin, udp
# 2hr, 10 sec, 160 sec - domyślnie
# 1 day, 10 min, 10 min - przykład dłuższego czasu życia
$IPCHAINS -M -S 86400 600 600
</example>
Jeśli sieć jest osiągalna przez kartę PCMCIA, <prgn>ipmasq</prgn> 
musi być wystartowane z pliku
<file>/etc/pcmcia/network.opts</file>. Przeczytaj 
<url id="&f-ipmasq;">.
</sect2>


<sect2 id="ip-redirect">Przekierowanie połączeń SMTP (2.4)
<p>
Załóżmy, że masz notebooka, który jest tak skonfigurowany, że używa
różnych środowisk sieciowych i chcesz używać swojego agenta (serwer)
poczty bez potrzeby ciągłej zmiany jego konfiguracji.
<p>
Dodając poniższą regułkę <prgn>iptables</prgn> na bramce sieciowej przekierujesz
połączenia SMTP do komputera pełniącego funkcję bramki.
<example>
# iptables -t nat -A PREROUTING -s 192.168.1.0/24 -j REDIRECT \
           -p tcp --dport smtp --to-port 25 # smtp=25, INPUT is open
</example>
Jeśli oczekujesz dokładniejszych zestawów regułek, rozważ zainstalowanie
pakietu <package>ipmasq</package> i dodanie 
<url id="&examples;" name="M30redirect.def"> do katalogu
<file>/etc/ipmasq/rules/</file>.


<sect1>Zarządzanie wieloma połączeniami z siecią
<p>
[FIXME] Routing rozszerzony (policy routing) (autor: Phil Brutsche
<email>pbrutsch@tux.creighton.edu</email>):
Zobacz <url id="&iproute;" name="iproute manual">, jeśli interesują
Cię szczegóły. Kształtowanie ruchu (tc, ang. Traffic control) może
być równie interesujące.
<p>
Środowisko:
<example>
eth0: 192.168.1.2/24; brama 192.168.1.1
eth1: 10.0.0.2/24; brama 10.0.0.1
Brak maskarady na tym komputerze.
</example>
Magiczne zaklęcia:
<enumlist compact>
<item>ip rule add from 192.168.1.2 lookup 1
<item>ip rule add from 10.0.0.2 lookup 2
<item>ip route add to default via 10.0.0.1 metric 0
<item>ip route add to default via 192.168.1.1 metric 1
<item>ip route add table 1 to 192.168.1.0/24 via eth0
<item>ip route add table 1 to 10.0.0.2/24 via eth1
<item>ip route add table 1 to default via 192.168.1.1
<item>ip route add table 2 to 192.168.1.0/24 via eth0
<item>ip route add table 2 to 10.0.0.2/24 via eth1
<item>ip route add table 2 to default via 10.0.0.2
</enumlist>
<p>
[FIXME] Nigdy tego nie robiłem. Jak ustawić połączenie wdzwaniane jako
połączenie zapasowe szybkiego łącza, używając właściwości automatycznego
łączenia na żądanie? Wyślij łatkę tutaj :)
</sect>


</chapt>
