<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.60"  -->

<chapt id="kernel">Jądro systemu Linux w Debianie
<p>
Debian posiada swoją własną metodę kompilacji jądra i powiązanych z nim modułów.
Zobacz również <ref id="kernel-details">.

<sect id="kernel-compile">Kompilacja jądra
<p>
Użycie <prgn>gcc</prgn>, <prgn>binutils</prgn> i
<prgn>modutils</prgn> z Debiana <tt>unstable</tt> może pomóc
przy kompilacji najnowszych wydań jądra systemu Linux.
Zobacz <file>&f-kernel-readme;</file>, szczególnie koniec,
aby uzyskać oficjalne informacje.
<p>
Od zawsze kompilacja jądra była trudnym tematem,
który nawet najbardziej zaawansowanych developerów może
wprowadzić w zakłopotanie:
<taglist compact>
<tag>Manoj Srivastava napisał:
<item><tt>--initrd</tt> wymaga specjalnej łatki dla Debiana: cramfs.
<tag>Herbert Xu napisał:
<item>Nie, wcale nie, wszystko co musisz zrobić aby użyć innego systemu
plików niż
 CRAMFS, to ustawienie MKIMAGE w <file>/etc/mkinitrd/mkinitrd.conf</file>.
</taglist>
<p>
Bądź ostrożny i zawsze polegaj na <file>&f-kernel-readme;</file>
napisanym przez Manoj i Kent'a. Upewnij się, że zdobyłeś najnowszą wersję pakietu
unstable <package>kernel-package</package>, jeśli chcesz kompilować
najnowszą wersję jądra.
<p>
<tt>initrd</tt> nie jest wymagane dla jądra kompilowanego tylko dla jednej
maszyny. Używam tego od czasu, kiedy chcę aby moje jądro było niemal
takie samo, jak to dostarczane przez pakiety kernel-image. 
Jeśli używasz <tt>initrd</tt>,
powinieneś przeczytać <manref name="mkinitrd" section="8"> i
<manref name="mkinitrd.conf" section="5">. Zobacz również
<url id="&bug-initrd;">.

<sect1 id="kernel-debian">Standardowa metoda Debiana
<p>
Śledź uważnie raporty o błędach w <package>kernel-package</package>,
<prgn>gcc</prgn>, <prgn>binutils</prgn> i <prgn>modutils</prgn>.
W miarę możliwości używaj ich nowych wersji.
<p>
Kompilacja spersonalizowanego jądra ze źródeł pod Debianem wymaga specjalnej
uwagi. Użyj nowego <tt>--append_to_version</tt> wraz z
<prgn>make-kpkg</prgn>, aby zbudować obrazy jądra wielokrotnego użytku.
<example>
# apt-get install debhelper modutils kernel-package libncurses5-dev
# apt-get install kernel-source-<var>2.4.18</var>    # użyj najnowszej wersji
# apt-get install fakeroot
# vi /etc/kernel-pkg.conf                # wpisz nazwisko i e-mail
$ cd /usr/src                            # stwórz katalog
$ tar --bzip2 -xvf kernel-source-<var>2.4.18</var>.tar.bz2
$ cd kernel-source-<var>2.4.18</var>                 # jeżeli są to źródła Twojego jądra
$ cp /boot/config-<var>2.4.18-386</var> .config      # ustaw obecny plik konfiguracyjny jako domyślny
$ make menuconfig                        # wybierz potrzebne Ci opcje
$ make-kpkg clean                        # musi być uruchomione (per: man make-kpkg)
$ fakeroot make-kpkg --append_to_version -<var>486</var> --initrd \
        --revision=<var>rev.01</var> kernel_image \ 
        modules_image # modules_image używa się dla pcmcia-cs* itd.
$ cd ..
# dpkg -i kernel-image*.deb pcmcia-cs*.deb # instalacja
</example>
<tt>make-kpkg kernel_image</tt> właściwie wykonuje <tt>make oldconfig</tt>
i <tt>make dep</tt>. Nie używaj <tt>--initrd</tt> jeżeli initrd nie jest używane.
<p>
Jeżeli ktoś chce używać modułów z pcmcia-cs lub bez pcmcia, powinien
wybrać „General setup  &mdash;&gt;”,
następnie „PCMCIA/CardBus support  &mdash;&gt;” przy <tt>make menuconfig</tt> i
ustawić konfigurację na „&lt;&nbsp;&gt; PCMCIA/CardBus support” (np. odznaczyć
pole).
<p>
Na maszynie z SMP (Simetric Multi processing), ustaw CONCURRENCY_LEVEL zgodnie z
<manref name="kernel-pkg.conf" section="5">.
</sect1>

<sect1 id="kernel-classic">Metoda klasyczna
<p>
Pobierz źródła z:
<list compact>
<item>Linux:     <url id="&linuxsrc;">
<item>pcmcia-cs: <url id="&pcmciasrc;">
</list>
lub użyj równoważnych źródeł z Debiana i postępuj następująco:
<example>
# cd /usr/src
# tar xfvz linux-<var>whatever</var>.tar.gz
# rm -rf linux
# ln -s linux-<var>whatever</var> linux
# tar xfvz pcmcia-cs-<var>whatever</var>.tar.gz
# ln -s pcmcia-cs-<var>whatever</var> pcmcia
# cd linux
# make menuconfig
... konfiguracja jądra ...
# make dep
# make bzImage
... edycja lilo / grub ...
... przeniesienie /usr/src/linux/arch/i386/boot/bzImage do  /boot ...
... uruchomienie /sbin/lilo lub równoważnego polecenia dla grub
# make modules; make modules_install
# cd ../pcmcia
# make config
# make all
# make install
... dodanie niezbędnych nazw modułów do /etc/modules
# shutdown -r now
... wystartowanie systemu z nowym jądrem ...
</example>
</sect1>

<sect1 id="kernel-headers">Pliki nagłówkowe jądra
<p>
Większość „zwykłych” programów nie potrzebuje plików nagłówkowych jądra, a
nawet może się popsuć
jeśli użyjesz ich bezpośrednio; zamiast tego powinny być skompilowane z
plikami nagłówkowymi, z
którymi <strong>zbudowano/skompilowano <prgn>glibc</prgn></strong>, które są wersjami
z <file>/usr/include/linux</file> i <file>/usr/include/asm</file>
systemu &debian;.
<p>
Nie twórz więc dowiązań symbolicznych do katalogów w <file>/usr/src/linux</file>
z <file>/usr/include/linux</file> i <file>/usr/include/asm</file>,
jak jest to sugerowane w pewnych przestarzałych dokumentach.
<p>
Jeżeli szczególnie <strong>potrzebujesz</strong> plików nagłówkowych jądra dla
aplikacji zależnych od jądra, zmień plik/pliki Makefile,
tak aby ich ścieżki do plików dołączanych (include) wskazywały na
<file><var>katalog-specjalnych-plików-nagłówkowych-jądra</var>/include/linux</file>
i
<file><var>katalog-specjalnych-plików-nagłókowych-jądra</var>/include/asm</file>.
</sect1>

</sect>

<sect id="kernel-modules">Zmodularyzowane jądro 2.4
<p>
Nowe jądra 2.4 w Debianie, dostarczone przez
<package>kernel-image-2.4.<var>NN</var></package>
są bardzo zmodularyzowane. Musisz się upewnić czy moduły
te są aktywne, aby jądro działało tak, jak zamierzałeś.
<p>
W następnej części, jako szybkie rozwiązania, prezentuję wiele
przykładów pliku <file>/etc/modules</file>.
Jednakże, lepszą metodą rozwiązywania problemów z modułami jest
przypisanie ich, jako nazw zastępczych (aliasów) dla urządzeń,
w plikach w <file>/etc/modutils/</file>. Niektóre moduły mogą być
automatycznie aktywowane przez programy rozpoznające sprzęt, takie jak
<package>discover</package>. Więcej na ten temat tutaj: <ref id="hdetect-x">.

<p>
Zobacz <file>Documentation/*.txt</file> w źródłach Linuksa
aby zdobyć szczegółowe informacje.
<sect1 id="kernel-pcmcia">PCMCIA
<p>
<file>/etc/modules</file> musi zawierać następujące wpisy, aby urządzenia
PCMCIA mogły działać:
<example>
# sterownik ISA PnP
isa-pnp
# Niskopoziomowy sterownik PCMCIA
# yenta_socket # w moim przypadku nie jest potrzebny
</example>
O resztę zadbają skrypty PCMCIA (z pakietu
<package>pcmcia-cs</package>),
<prgn>depmod</prgn> i <prgn>kmod</prgn>. Wydaje mi się, że potrzebowałem
<prgn>isa-pnp</prgn> ponieważ mój laptop jest starym
ISA-PCMCIA. Nowsze laptopy z CardBus/PCMCIA być może tego nie wymagają.
<p>
Zdanie wspaniałomyślnego Miquela van Smoorenburga
<email>miquels@cistron.nl</email>:
<p>
„Po prostu wyrzuciłem całość pcmcia
z laptopa w pracy, włącznie z cardmgr itd.
Następnie zainstalowałem jądro 2.4 ze wsparciem dla cardbus, i nowy
pakiet <package>hotplug</package> z woody'ego.
<p>
Jeśli masz 32-bitowe karty, nie potrzebujesz pakietu pcmcia
; 2.4 ma wbudowaną obsługę tych kart.
Zwykły sterownik tulip powinien pracować dobrze z Twoją kartą dlink.
<p>
&mdash;Mike.”
<p> Zobacz: <url id="&pcmcia-howto;" name="Linux PCMCIA HOWTO">
oraz <ref id="trigger-pcmcia">.
</sect1>

<sect1 id="kernel-scsi">SCSI
<p>  <!-- Osamu: maybe test this section? I do not have SCSI :(
                                     But this is almost sure :) -->
[NIE SPRAWDZANE] <file>/etc/modules</file> musi zawierać następujące wpisy,
aby urządzenia SCSI mogły działać:
<example>
# rdzeń SCSI
scsi_mod
# ogólny sterownik SCSI
sg
# dysk SCSI
sd_mod
# wszystkie inne niezbędne moduły
...
</example>
<prgn>depmod</prgn> zajmie się niektórymi z powyższych modułów.
</sect1>

<sect1 id="kernel-net">Obsługa sieci
<p>
<file>/etc/modules</file> musi zawierać nastepujące wpisy dla działania dodatkowych funkcji sieciowych:
<example>
# net/ipv-4
ip_gre
ipip

# net/ipv-4/netfilter
# iptable (in order)
ip_tables
ip_conntrack
ip_conntrack_ftp
iptable_nat
iptable_filter
iptable_mangle
#
ip_nat_ftp
ip_queue
#
ipt_LOG
ipt_MARK
ipt_MASQUERADE
ipt_MIRROR
ipt_REDIRECT
ipt_REJECT
ipt_TCPMSS
ipt_TOS
ipt_limit
ipt_mac
ipt_mark
ipt_multiport
ipt_owner
ipt_state
ipt_tcpmss
ipt_tos
ipt_unclean
#
#ipchains
#ipfwadm
</example>
Powyższe wpisy mogą nie być zoptymalizowane. <prgn>depmod</prgn> zajmie się 
cześcią z wyżej wymienionych modułów.
</sect1>

<sect1 id="ext3">System plików EXT3 ( &gt; 2.4.17)
<p>
Umożliwienie księgowania systemu plików z EXT3 FS przy użyciu Debianowego
pakietu prekompilowanego obrazu jądra ( &gt; 2.4.17) wymaga następujących kroków:
<example>
# cd /etc; mv fstab fstab.old
# sed 's/ext2/ext3,ext2/g' &lt;fstab.old &gt;fstab
# vi /etc/fstab
... ustaw typ głównego systemu plików na „auto” zamiast „ext3,ext2”
# cd /etc/mkinitrd
# echo jbd &gt;&gt;modules
# echo ext3 &gt;&gt;modules
# echo ext2 &gt;&gt;modules
# cd /
# apt-get update; apt-get install kernel-image-<var>2.4.17-686-smp</var>
... zainstaluj najnowsze jądro i ustaw bootowanie (uruchom tu lilo)
# tune2fs -j -i 0 <var>/dev/hda1</var>
# tune2fs -j -i 0 <var>/dev/hda2</var>
... i tak dla wszystkich systemów plików EXT2 konwertowanych na EXT3
# shutdown -r now
</example>
Teraz księgowanie EXT3 już działa.
Używając <tt>ext3,ext2</tt> jako wpis „typ” w <prgn>fstab</prgn>
zapewniasz bezpieczny powrót do EXT2, jeżeli jądro nie wspiera EXT3
dla partycji innych niż główna.
<p>
Jeżeli wcześniej zainstalowałeś sobie jądro 2.4 i nie chcesz go
przeinstalowywać,
wykonaj powyższe kroki aż do poleceń <prgn>apt-get</prgn>, następnie:
<example>
# mkinitrd -o /boot/initrd.img-<var>2.4.17-686-smp</var> /lib/modules/<var>2.4.17-686-smp</var>
# lilo
# tune2fs -j -i 0 <var>/dev/hda1</var>
# tune2fs -j -i 0 <var>/dev/hda2</var>
... dla wszystkich, którzy przekonwertowali EXT2 FS do EXT3
# shutdown -r now
</example>
Teraz księgowanie EXT3 już działa.
<p>
Jeżeli <file>/etc/mkinitrd/modules</file> nie zostało ustawione, podczas uruchomienia <prgn>mkinitrd</prgn> i chciałbyś dodać jakieś moduły w
czasie startu to :
<example>
... przy zgłoszeniu initrd, aby uzyskać powłokę (5 sek.), wciśnij RETURN
# insmod jbd
# insmod ext3 # modprobe ext3 zajmie się wszystkim
# insmod ext2
# ^D
... kontynuuj uruchamianie.
</example>
Na ekranie uruchamiania pojawia się (<prgn>dmesg</prgn>), „cramfs: wrong magic”,
ale jest to uznawane za nieszkodliwe. Ten problem został rozwiązany w Sarge 
(2002/10). Zobacz <url id="&bug-ext3;"> i
<url id="&howtoext3;" name="EXT3 File System mini-HOWTO"> lub
<file>&f-howtoext3;</file> w celu uzyskania dalszych informacji.
<p>
W niektórych systemach donoszone jest o doświadczaniu poważnych blokad jądra,
gdy używane jest EXT3, ale ja nie miałem problemów (przynajmniej z 2.4.17).
</sect1>

<sect1 id="ss-rtl8139">Wsparcie układu Realtek RTL-8139 w jądrze 2.4
<p>
Z nieznanych przyczyn, wsparcie dla modułu RTL-8139 nie nazywa się już rtl8139,
tylko 8139too. Po prostu wyedytuj swój <file>/etc/modules</file> by
uwzględnić tę zmianę przy zmianie jądra 2.2 na 2.4.
</sect1>

<sect1 id="parport">Wsparcie dla portów równoległych
<p>
Dla <package>kernel-image-2.4.*</package>, wsparcie portu równoległego jest
udostępniane jako moduł. Uaktywniasz je przez:
<example>
# modprobe lp
# echo lp >> /etc/modules
</example>
Zobacz <file>Documentation/parport.txt</file> w źródłach Linuksa.

</sect1>
</sect>

<sect id="proc-sys">Dostrajanie jądra przy pomocy systemu plików proc
<p>
Zachowanie jądra systemu Linux może być zmieniane „w locie” przy pomocy
systemu plików proc.
<p>
Podstawowych informacji o zmianach parametrów jądra przez
system plików <file>/proc</file> szukaj w źródłach Linuksa w
<file>Documentation/sysctl/*</file>.
<p>
Zobacz kilka przykładów dla modyfikacji parametrów jądra w
<file>/etc/init.d/networking</file> i <ref id="killecn">.
<p>
By dowiedzieć się jak ustawić konfigurację jądra poprzez system plików
<file>/proc</file> podczas uruchamiania zobacz do 
<manref name="sysctl.conf" section="5">. Zazwyczaj wykorzystywany jest do
tego skrypt <file>/etc/init.d/procps.sh</file> uruchamiany z
<file>/etc/rcS.d/S30procps.sh</file>.

<sect1 id="many-files">Za dużo otwartych plików
<p>
Jądro Linuksa może zgłaszać problem „Za dużo otwartych plików”. Spowodowane jest to małą domyślną wartością (8096) dla <tt>file-max</tt>. Aby naprawić ten problem,
wywołaj następujące polecenie jako root:
<example>
# echo "65536"  &gt; /proc/sys/fs/file-max  # dla jąder 2.2 i 2.4
# echo "131072" &gt; /proc/sys/fs/inode-max # tylko dla jąder 2.2
</example>
lub by zmienić to na stałe umieść następujące wpisy w 
<file>/etc/sysctl.conf</file>:
<example>
file-max=65536   # dla jąder 2.2 i 2.4
inode-max=131072 # tylko dla jąder 2.2
</example>

<sect1 id="bdflush">Przedziały czasu między operacjami dyskowymi
<p>
Możesz zmienić przedziały czasu między operacjami dyskowymi przy pomocy systemu plików proc.
 Następująco skrócimy je z domyślnych pięciu sekund do sekundy.
<example>
# echo "40 0 0 0 100 30000 60 0 0"  &gt; /proc/sys/vm/bdflush
</example>
Może to trochę negatywnie wpływać na osiągi pliku wejścia/wyjścia. Ale zabezpiecza to
zawartość pliku, z wyjątkiem ostatniej sekundy, co i tak jest krótszym czasem,
niż domyślne pięć sekund. Działa to nawet dla systemu plików z księgowaniem.
</sect1>

<sect1 id="over-commit">Stare, powolne maszyny z małą ilością pamięci
<p>
Dla niektórych starych systemów z małą ilością pamięci, użyteczne wciąż może być uruchomienie,
przy pomocy systemu plików proc, przydzielania nieosiągalnej w danym momencie pamięci:
<example>
# echo 1 &gt; /proc/sys/vm/overcommit_memory
</example>
</sect1>

</sect>
</chapt>
