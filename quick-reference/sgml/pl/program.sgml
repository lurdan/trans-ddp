<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.63"   -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->
<!-- DON'T TOUCH GROFF SECTION!!! -->


<chapt id="program">Programowanie
<p>
Pamiętaj, by nie używać nazwy „test” do oznaczania pliku wynikowego,
ponieważ <prgn>test</prgn> jest wbudowanym poleceniem powłoki.

<sect>Gdzie zacząć?
<p>
Odnośniki:
<list compact>
<item>Dokumentacja i przykłady w katalogu <file>&dochome;<var>pakiet</var></file>
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
Wiele długich dokumentów info można otrzymać w postaci wydrukowanej z
<url id="&gnuhome;" name="GNU">.
<p>
W następnych czterech rozdziałach znajdziesz przykładowe skrypty, każdy
napisany w innym języku, które tworzą plik tekstowy zawierający informacje
o koncie, które z kolei mogą być wstawione do pliku <file>/etc/passwd</file>
za pomocą przetwarzania wsadowego np. programem <prgn>newusers</prgn>.
Każdy ze skryptów oczekuje na wejściu pliku, którego linie są następującego
formatu <tt>imię nazwisko hasło</tt>. (Katalogi domowe użytkowników nie
będą tworzone przez te skrypty.)

</sect>

<sect id="shell">Powłoka
<p>
<strong>Najlepszym</strong> sposobem na zrozumienie działania systemów
uniksowych jest przeglądanie i czytanie skryptów powłoki.
Poniżej podam pewne wskazówki i materiały przypominające programowanie
w powłoce. Zobacz <url id="&shell-mistakes;" name="Pomyłki powłoki">
by uczyć się na błędach.

<sect1 id="bash">Bash &ndash; interaktywna powłoka zgodna z <strong>GNU</strong>

<p>
Odnośniki do informacji na temat Bash-a:
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>LDP <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
(Programowanie w BASH-u - Wprowadzenie JTZ)
- informacje dla początkujących
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (Zainstaluj najpierw pakiet <package>bash-doc</package>, aby zobaczyć
 przykłady.)
<item><em>Learning the bash Shell</em>, 2nd edition (O'Reilly) - (Nauka
powłoki bash - drugie wydanie)
</list>
<p>
Oto krótki, przykładowy program (tworzy on wpisy dt. kont na podstawie
danych ze standardowego wejścia dla programu <prgn>newusers</prgn>):
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:„,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">Powłoki zgodne z POSIX
<p>
W systemie &debian; powłoki zgodne z POSIX znajdują się w kilku pakietach:
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 176
  <item>Najmniejszy i jak dotąd najszybszy. &ndash; najlepszy dla początkowego
       rozruchu.
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 180
  <item>Mniejszy i o wiele szybszy &ndash; dobry dla początkowego rozruchu.
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essential: yes
  <item>Priority: required
  <item>Installed-Size: 580
  <item>Większy i z większymi możliwościami &ndash; napisanych zostało już
       wiele rozszerzeń.
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 408
  <item>Kompletny klon powłoki AT&amp;T ksh.
 </list>
</list>
<p>
Jeśli piszesz skrypty powłoki, które mają być przenoszone na inne
powłoki/systemy to
najlepiej pisać je jako skrypty powłoki POSIX. Użyj <file>/bin/sh</file>
dowiązanego do <prgn>ash</prgn> lub (<prgn>dash</prgn>) aby sprawdzić zgodność
z POSIX. Unikaj pisania skryptów z naleciałościami
<strong>bashowymi</strong> lub <strong>zshsowymi</strong>, które przypominają
składnię <prgn>csh</prgn>. Na przykład, staraj się unikać:

<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>file</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>

<p>
Opisy powłoki w tym dokumencie dotyczą tylko powłok zgodnych ze strandardem POSIX,
a więc nie dotyczą powłok typu <prgn>csh</prgn>, włączając <prgn>tcsh</prgn>.

<sect1 id="shell-param">Parametry powłoki
<p>
Kilka <strong>parametrów specjalnych</strong> do zapamiętania:
<example compact>
$0      = nazwa powłoki lub skryptu
$1      = pierwszy(1) argument powłoki
 ...
$9      = dziewiąty(9) argument powłoki
$#      = ilość parametrów pozycyjnych
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = kod zakończenia ostatnio wykonywanego polecenia
$$      = PID aktualnie wykonywanego skryptu powłoki
$!      = PID ostatnio rozpoczętego zadania w tle
</example>
<p>
Podstawowe <strong>rozwinięcia parametrów</strong> (parameter expansion)
do zapamiętania:
<example compact>
       Forma       Jeśli <var>parametr</var>    Jeśli <var>parametr</var> nie
                   jest ustawiony               jest ustawiony
${<var>parametr</var>:-<var>słowo</var>}   $<var>parametr</var>            <var>słowo</var>
${<var>parametr</var>:+<var>słowo</var>}   <var>słowo</var>                null
${<var>parametr</var>:=<var>słowo</var>}   $<var>parametr</var>            <var>słowo</var>
                                 (i wykonuje <var>parametr</var>=<var>słowo</var>)
${<var>parametr</var>:?<var>słowo</var>}   $<var>parametr</var> (wyświetla <var>słowo</var> i kończy działanie)
</example>
Dwukropek (`:') we wszystkich powyższych operatorach nie jest tak naprawdę
potrzebny.
<list compact>
<item>Z `:' = operator sprawdza czy zmienna „istnieje” i „nie jest pusta”.
<item>Bez `:' = operator sprawdza tylko czy zmienna „istnieje”.
</list>
<p>
Podstawowe <strong>podstawienia parametrów</strong>(parameter substitutions)
do zapamiętania:
<example compact>
    Forma                Wynik <!-- FIXME: Sprawdzić to wszystko w bash(1) -->
${<var>parametr</var>&percnt;<var>końcówka</var>}     Usunięcie najmniejszego wzorca <var>końcówka</var>
${<var>parametr</var>&percnt;&percnt;<var>końcówka</var>}    Usunięcie największego wzorca <var>końcówka</var>
${<var>parametr</var>#<var>przedrostek</var>}  Usunięcie najmniejszego wzorca <var>przedrostek</var>
${<var>parametr</var>##<var>przedrostek</var>} Usunięcie największego wzorca <var>przedrostek</var>
</example>

<sect1 id="shell-redirect">Przekierowywanie powłoki
<p>
Podstawowe operatory <strong>przekierowywania</strong> do zapamiętania ([n]
jest opcjonalną liczbą określającą kwalifikator pliku):
<example compact>
[<var>n</var>]&gt; <var>plik</var>     Przekieruj standardowe wyjście (lub <var>n</var>) do <var>pliku</var>.
[<var>n</var>]&gt;&gt; <var>plik</var>    Dołącz standardowe wyjście (lub <var>n</var>) do <var>pliku</var>.
[<var>n</var>]&lt; <var>plik</var>     Przekieruj standardowe wejście (lub <var>n</var>) z <var>pliku</var>.
[<var>n1</var>]&gt;&amp;<var>n2</var>      Przekieruj standardowe wyjście (lub <var>n1</var>) do <var>n2</var>.
&gt; <var>plik</var> &gt;&2    Przekieruj standardowe wyjście i strumień błędów do <var>pliku</var>.
| <var>polecenie</var>     Przekieruj standardowe wyjście na wejście
<var>polecenia</var>.
&gt;&2 | <var>polecenie</var> Przekieruj standardowe wyjście i strumień błędów
na wejście <var>polecenia</var>.
</example>
 Gdzie
<list compact>
	<item>standardowe wejście (stdin): kwalifikator pliku = 0)
	<item>standardowe wyjście (stdout): (kwalifikator pliku = 1)
	 <item>standardowe wyjście błędu (stderr): (kwalifikator pliku = 2)
</list>

<p>
Powłoka umożliwia otwarcie plików przez użycie wbudowanego polecenia
<prgn>exec</prgn> i bezwzględnego kwalifikatora pliku.
<example>
  	 $ echo Witaj &gt;pliczek
  	 $ exec 3&lt;pliczek 4&gt;pliczek2  # otwieranie plików
  	 $ cat &lt;&amp;3 &gt;&amp;4        # przekierowanie stdin do 3, a stdout do 4
  	 $ exec 3&lt;&amp;- 4&gt;&amp;-     # zamykanie plików
  	 $ cat pliczek2
  	 Witaj
</example>
Powyżej <var>n</var><tt>&lt;&amp;-</tt> oraz <var>n</var><tt>&gt;&amp;-</tt>
oznacza zamknięcie kwalifikatora pliku o numerze <var>n</var>.


<sect1 id="shell-cond">Polecenia warunkowe powłoki
<p>
Każde polecenie zwraca <strong>kod wyjścia</strong> (exit status), który
może zostać użyty w wyrażeniu warunkowym:
<list compact>
<item>Sukces: 0 (Prawda)
<item>Błąd: 1&ndash;255 (Fałsz)
</list>
Zauważ, że użycie wartości 0 w celu wyrażenia „prawdy” różni się od zwykłej
konwencji w innych obszarach przetwarzania.
Poza tym `[' jest odpowiednikiem polecenia <prgn>test</prgn>, które traktuje
argumenty aż do `]' jako wyrażenie warunkowe.
<p>
Podstawowe <strong>idiomy warunkowe</strong> (conditional idioms) do 
zapamiętania to:
<example compact>
<var>polecenie</var> && <var>jeśli_sukces_uruchom_również_to_polecenie</var> || true
<var>polecenie</var> || <var>jeśli_nie_sukces_uruchom_w_zamian_to_polecenie</var>

if [ <var>wyrażenie_warunkowe</var> ]; then  
 <var>jeśli_sukces_uruchom_to_polecenie</var>
else
 <var>jeśli_nie_sukces_uruchom_to_polecenie</var>
fi
</example>

<tt>|| true</tt> było potrzebne by upewnić się, że ten skrypt przypadkowo 
nie zakończy się w tej linii jeśli powłoka byłaby wywołana z flagą
<tt>-e</tt>.

<p>
Operatory porównywania <strong>plików</strong> w wyrażeniach warunkowych to:
<example compact>
-e <var>plik</var>         Prawda, jeśli <var>plik</var> istnieje.
-d <var>plik</var>         Prawda, jeśli <var>plik</var> istnieje i jest katalogiem.
-f <var>plik</var>         Prawda, jeśli <var>plik</var> istnieje i jest normalnym plikiem.
-w <var>plik</var>         Prawda, jeśli <var>plik</var> istnieje i jest zapisywalny.
-x <var>plik</var>         Prawda, jeśli <var>plik</var> istnieje i jest wykonywalny.
<var>plik1</var> -nt <var>plik2</var> Prawda, jeśli <var>plik1</var> jest nowszy niż <var>plik2</var>. (modyfikacja)
<var>plik1</var> -ot <var>plik2</var> Prawda, jeśli <var>plik1</var> jest starszy niż <var>plik2</var>. (modyfikacja)
<var>plik1</var> -ef <var>plik2</var> Prawda, jeśli mają takie same numery urządzeń i iwęzłów.
</example>
<p>
Operatory porównywania <strong>łańcuchów znaków</strong> w wyrażeniach
warunkowych:
<example compact>
     -z <var>słowo</var>    Prawda, jeśli długość <var>słowo</var> wynosi zero.
     -n <var>słowo</var>    Prawda, jeśli długość <var>słowo</var> jest różna od zera.
<var>słowo1</var> == <var>słowo2</var>   Prawda, jeśli słowa są równe.
<var>słowo1</var> = <var>słowo2</var>    Prawda, jeśli słowa są równe.
    (dla ścisłej zgodności z POSIX, zamiast „==” należy używać „=”) 
<var>słowo1</var> != <var>słowo2</var>   Prawda, jeśli słowa nie są równe.
<var>słowo1</var> &lt;  <var>słowo2</var>   Prawda, jeśli <var>słowo1</var> sortuje się przed <var>słowo2</var> (zleżne od lokalizacji (locale)).
<var>słowo1</var> &gt;  <var>słowo2</var>   Prawda, jeśli <var>słowo1</var>
sortuje się po <var>słowo2</var> (zależne od lokalizacji (locale) ).
</example>
<p>
Operatory <strong>arytmetycznego</strong> porównywania liczb całkowitych
<p>
Wyrażenia warunkowe to: <tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>, 
<tt>-le</tt>, <tt>-gt</tt>, i <tt>-ge</tt>.
</sect1>

<sect1 id="clprocess">Przetwarzanie linii poleceń
<p>
Powłoka przetwarza skrypt tak:
<list compact> <!-- FIXME: metacharacters, expand, alias ?? -->
<item>rozbicie na <strong>żetony</strong> (tokens) przez meta-znaki: SPACJA, TAB, NOWA_LINIA, ;, (, ), &lt;, &gt;, |, &amp;
<item>sprawdzenie <strong>słów kluczowych</strong> (keyword), jeśli nie są pomiędzy "..." lub '...' (pętla)
<item>rozwinięcie <strong>aliasów</strong>, jeśli nie są pomiędzy "..." lub '...' (pętla)
<item>rozwinięcie <strong>nawiasów</strong>, <tt>a{1,2}</tt> -> <tt>a1 a2</tt>, jeśli nie są pomiędzy "..." lub '...'
<item>rozwinięcie <strong>tyld</strong>, ~<var>użytkownik</var> -> katalog domowy <var>użytkownika</var>, jeśli nie jest pomiędzy "..." lub '...'
<item>rozwinięcie <strong>parametrów</strong>, $<var>PARAMETRÓW</var>, jeśli nie są pomiędzy "..."
<item>rozwinięcie <strong>podstawienia polecenia</strong>,
$(<var>polecenie</var>), jeśli nie jest pomiędzy '...'
<item>podział na <strong>słowa</strong> wg. $IFS, jeśli nie są pomiędzy "..." lub '...'
<item>rozszerzenie *?[] na <strong>ścieżki</strong>, jeśli nie jest pomiędzy "..." lub '...'
<item>znalezienie <strong>polecenia</strong>
<list compact>
<item>funkcji
<item>wbudowanego
<item>pliku w $PATH
</list>
<item>pętla
</list>
<p>
Pojedyncze cudzysłowy pomiędzy podwójnymi cudzysłowami nie dają żadnego
efektu.
<p>
Wykonanie <tt>set -x</tt> w powłoce lub też wywołanie powłoki z opcją
<tt>-x</tt> zmusza powłokę do wypisywania wszystkich poleceń, jakie wykonuje.
Może to być pomocne przy odpluskwianiu.
</sect1>

</sect>

<sect id="awk">Awk
<p>
Miejsca, w których można znaleźć informacje o Awk:
<list compact>
<item><em>Effective awk Programming</em>, 3rd edition (O'Reilly) - (Efektywne
programowanie w awk, trzecie wydanie)
<item><em>Sed &amp; awk</em>, 2nd edition (O'Reilly) - (Sed i awk, drugie
wydanie)
<item><manref name="mawk" section="1"> i <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
Krótki przykład programu (tworzącego wpisy dla <prgn>newusers</prgn>):
<example>
#!/usr/bin/awk -f
# Skrypt tworzący plik przystosowany do użycia z poleceniem 'newusers'
# z pliku zawierającego ID użytkowników i hasła w formie:
# Imię Nazwisko hasło
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Przydzielenie początkowych UID i GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Wywołanie: newusers PoczatkoweUID plik\n" \
          "  gdzie:\n"
          "    PoczątkoweUID jest początkowym identyfikatorem dodawanego użytkownika,\n" \
          "    plik jest plikiem wejścia w postaci:\n" \
          "      imię nazwisko hasło\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Początkowe UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s„/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
Dwa pakiety w systemie &debian; dostarczają <package>awk</package> zgodnego z
POSIX:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priority: required
  <item>Installed-Size: 228
  <item>Mniejszy i znacznie szybszy &ndash; dobry dla domyślnej instalacji
  <item>Zawiera ograniczenia ustalane podczas kompilacji
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 1708
  <item>Większy i potężniejszy &ndash; posiada wiele rozszerzeń
  <list compact>
   <item>System V Release 4 version of UNIX
   <item>Bell Labs awk
   <item>GNU-specific
  </list>
 </list>
</list>
</sect>

<sect id="perl">Perl
<p>
To jest <strong>prawdziwy</strong> interpreter w systemach uniksowych.
<p>
Miejsca, w których można znaleźć informacje o Perl'u:
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3rd edition (O'Reilly)
</list>
<p>
Krótki, przykładowy program (tworzy wpisy dla polecenia <prgn>newusers</prgn>):
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,"„,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Instalacja modułu Perla <var>nazwa_modułu</var>:
<example>
# perl -MCPAN -e 'install <var>nazwa_modułu</var>'
</example>
 
</sect>

<sect>Python
<p>
Jest to miły, zorientowany obiektowo interpreter.
<p>
Miejsca, w których można znaleźć informacje o Pythonie:
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
</list>
<p>
Krótki, przykładowy program (tworzy wpisy dla polecenia <prgn>newusers</prgn>):
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Sposób użycia:  ", sys.argv[0], " PoczątkoweUID [plik]\n" \
"\tPoczątkoweUID jest początkowym identyfikatorem dodawanego użytkownika.\n" \
"\tplik jest plikiem wejścia. Jeśli nie określony to standardowe wejście.\n\n" \
"Format pliku wejściowego:\n"\
"\timię nazwisko hasło\n"
                return 1

def parsefile(startuid):
    #
    # główne filtrowanie
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # powyższe rozsypuje się przy złej liczbie parametrów :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s„/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID zaczyna się od: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Czytaj plik z: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>Make
<p>
Miejsca, w których można znaleźć informacje o Make:
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2nd edition (O'Reilly)
</list>
<p>
Proste zmienne automatyczne:
<p>
Składnia reguł:
<example>
<var>Cel</var>: [ <var>warunek wstępny</var> ... ]
 [TAB]  <var>polecenie1</var>
 [TAB]  -<var>polecenie2</var> # ignoruj błędy
 [TAB]  @<var>polecenie3</var> # wstrzymaj echo
</example>
Gdzie <tt>[TAB]</tt> jest kodem TAB.
Każda linia jest intrepretowana przez powłokę po podmianie zmiennych przez
<prgn>make</prgn>.
Użyj <tt>\</tt> na końcu linii, by kontynuować skrypt.
Użyj <tt>$$</tt>, by wprowadzić <tt>$</tt> dla zmiennych
środowiskowych w skrypcie powłoki. 
<p>
<strong>Uwikłane reguły</strong> dla <var>celu</var> oraz
<var>warunki wstępne</var> mogą być, na przykład, zapisane jako:
<example>
&percnt;: &percnt;.c header.h 
</example>
lub
<example>
&percnt;.o: &percnt;.c header.h
</example>
Tutaj <var>cel</var> zawiera znak <tt>&percnt;</tt> (dokładnie jeden
z nich). Znak <tt>&percnt;</tt> może zastępować jakikolwiek niepusty
podciąg aktualnych nazw plików danego celu. W <var>warunkach wstępnych</var>
również można użyć znaku <tt>&percnt;</tt> by pokazać jak ich nazwy mają
się do aktualnej nazwy celu.
<p>
<strong>Reguły przyrostkowe</strong> są <strong>przestarzałym</strong>
sposobem definiowania reguł uwikłanych dla <prgn>make</prgn>. 
Są nadal obsługiwane w GNU <prgn>make</prgn> dla zgodności, ale używaj
odpowiednich reguł wzorców, kiedykolwiek to możliwe:
<example>
stara reguła przyrostkowa --&gt; nowa reguła wzorcowa
.c:                       --&gt; &percnt;  : &percnt;.c
.c.o:                     --&gt; &percnt;.o: &percnt;.c
</example>
Automatyczne zmienne dla reguł:
<example>
foo.o: new1.c new2.c old1.c new3.c
$@ == foo.o                         (cel)
$< == new1.c                        (pierwszy)
$? == new1.c new2.c new3.c          (nowsze)
$^ == new1.c new2.c old1.c new3.c   (wszystkie)
$* == `&percnt;' dopasowany rdzeń we wzorcu celu
</example>
Opis zmiennych:
<example>
foo1 := bar    # Jednorazowe rozszerzenie
foo2  = bar    # Rekursywne rozszerzenie
foo3 += bar    # Dopisanie
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir katalog/plik.rozszerzenie) # Wydobywa „katalog”
$(notdir NAZWY...), $(basename NAZWY...), $(suffix NAZWY...) ...
</example>
Wprowadź <tt>make -p -f/dev/null</tt>, by zobaczyć automatyczne reguły
wewnętrzne. 
</sect>

<sect>C
<p>
Przygotowanie:
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
Miejsca, w których można znaleźć informacje o C:
<list compact>
<item><tt>info libc</tt> (opis funkcji biblioteki C)
<item><manref name="gcc" section="1">
<item><manref name="each_C_library_function_name" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 
 2nd edition (Prentice Hall).
</list>
<p>

<sect1>Prosty program w C (<prgn>gcc</prgn>)
<p>
Prosty przykład kompilowania <file>przyklad.c</file> z biblioteką
<file>libm</file> do pliku wykonywalnego <prgn>uruchom_przyklad</prgn>:
<example>
$ cat &gt; przyklad.c &lt;&lt; EOF
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* zapobiega przepełnieniu bufora */
        y[10] = '\0'; /* wypełniamy, by upewnić się, że ciąg kończy się '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o uruchom_przyklad przyklad.c -lm
$ ./uruchom_przyklad
        1, 2.915, ./uruchom_,     (null)
$ ./uruchom_przyklad 1234567890qwerty
        2, 3.082, ./uruchom_, 1234567890qwerty
</example>
W przykładzie <tt>-l<strong>m</strong></tt> jest potrzebne, by zlinkować
bibliotekę <tt>lib<strong>m</strong></tt> dla <prgn>sqrt()</prgn>. 
Faktycznie biblioteka
znajduje się w <file>/lib</file> pod nazwą <file>libm.so.6</file>, która
jest dowiązaniem symbolicznym do <file>libm-2.1.3.so</file>.
<p>
Spójrz na ostatni parametr w wyjściowym tekście. Jest tam więcej niż
dziesięć znaków mimo, że użyliśmy <tt>&percnt;10s</tt>.
<p>
Używanie funkcji ze wskaźnikami do operacji na pamięci bez sprawdzania
obszarów granicznych, zwłaszcza takich jak <prgn>sprintf</prgn> lub
<prgn>strcpy</prgn>, jest uznawane za przestarzałe, co ma zapobiegać błędom
przepełnienia buforu. Zamiast nich należy używać <prgn>sprintf</prgn> oraz
<prgn>strncpy</prgn>.
</sect1>

<sect1>Odpluskwianie

<sect2>Uruchamianie i testowanie programów przy pomocy <prgn>gdb</prgn>
<p>
Przygotowanie:
<example>
# apt-get install gdb
</example>
<p>
Miejsca, w których można znaleźć informacje o <prgn>gdb</prgn>:
<list compact>
<item><tt>info gdb</tt> (samouczek)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>
<p>
Do prześledzenia działania programu skompilowanego z opcją <tt>-g</tt>
użyj programu <prgn>gdb</prgn>. Wiele poleceń ma swoje kilkuznakowe skróty.
Dopełnianie tabulatorem działa tak samo jak w powłoce.
<example>
$ gdb program
(gdb) b 1                # ustaw punkt wstrzymania w linii 1
(gdb) run <var>arg1 arg2 arg3</var> # uruchom program
(gdb) next               # następna linia
...
(gdb) step               # krok do przodu
...
(gdb) p parm             # wyświetl parm 
...
(gdb) p parm=12          # ustaw wartość na 12
</example>
<p>
Jeśli chcesz się dowiedzieć, jak przeprowadzić odpluskwianie przy pomocy 
Emacsa, zerknij do <ref id="editkey">.
</sect2>

<sect2 id="ss-ldd">Sprawdzanie zależności od bibliotek
<p>
Aby znaleźć wymagane przez program biblioteki skorzystaj z <prgn>ldd</prgn>:
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
By <prgn>ls</prgn> mogło pracować w środowisku <prgn>chroot</prgn>, muszą
się w nim znaleźć powyższe biblioteki.
<p>
Następujące polecenia mogą być również użyteczne:
<list compact>
<item><prgn>strace</prgn>: śledzi wywołania systemowe oraz sygnały
<item><prgn>ltrace</prgn>: śledzi wywołania biblioteczne
</list>
</sect2>
 
<sect2>Odpluskwianie z użyciem narzędzi do wykrywania wycieków pamięci

<p>
Istnieje wiele narzędzi do wykrywania wycieków pamięci w Debianie:
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (niedostępny w pakiecie, pobierz z  
 <url id="&memwatch-home;" name="memwatch">.)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> z
  <url id="&parasofthome;" name="Parasoft">. (non-free, komercyjnie za opłatą)
</list>
<p>
Sprawdź również <url id="&mallocdebughome;" 
  name="Debugging Tools for Dynamic Storage Allocation and Memory Management">.

<sect1>Flex &ndash; lepszy Lex
<p>
<prgn>flex</prgn> jest szybkim generatorem analizatorów leksykalnych.
<p>
Miejsca, w których można znaleźć informacje o <prgn>flex</prgn>:
<list compact>
<item><tt>info flex</tt> (samouczek)
<item><manref name="flex" section="1">
</list>
<p>
Musisz utworzyć własną funkcję <prgn>main()</prgn> i <prgn>yywrap()</prgn>,
lub <file>program.l</file> powinien wyglądać tak, jak poniżej, by kompilował
się bez biblioteki (<prgn>yywrap</prgn> jest makrem; <tt>&percnt;option
main</tt> uaktywnia bezwarunkowo <tt>&percnt;option noyywrap</tt>):
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
Zamiast tego możesz skompilować program podając na końcu polecenia 
<prgn>cc</prgn> opcję -<tt>lfl</tt> (tak jak przy AT&amp;T-Lex opcję
<tt>-ll</tt>).
Nie potrzeba wtedy używać <tt>&percnt;option</tt>.
</sect1>

<sect1>Bison &ndash; lepszy Yacc
<p>
Kilka pakietów w Debianie dostarcza zgodny z Yacc generator analizatorów
składniowych:
<p>
<list compact>
 <item><package>bison</package>: GNU LALR parser generator
 <item><package>byacc</package>: The Berkeley LALR parser generator
 <item><package>btyacc</package>: Backtracking parser generator oparty na <package>byacc</package>
</list>
<p>
Miejsca, w których można znaleźć informacje o <prgn>bison</prgn>:
<list compact>
<item><tt>info bison</tt> (samouczek)
<item><manref name="bison" section="1">
</list>
<p>
Musisz utworzyć własne funkcje <prgn>main()</prgn>
i <prgn>yyerror()</prgn>. <prgn>main()</prgn> wywołuje
<prgn>yyparse()</prgn>, która z kolei wywołuje <prgn>yylex()</prgn>,
zazwyczaj stworzoną przez FleX.
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> jest narzędziem tworzącym skrypty powłoki, które
automatycznie konfigurują źródła oprogramowania, by dostosować je do wielu
systemów uniksopodobnych, używając systemu budowania GNU.
<p>
<prgn>autoconf</prgn> tworzy skrypt konfigurujący 
<prgn>configure</prgn>, a <prgn>configure</prgn> 
automatycznie dostosowany <file>Makefile</file> używając wzorca
<file>Makefile.in</file>.
 
<sect2>Kompilacja i instalacja programu
<p>
&debian; nie dotyka plików znajdujących się w <file>/usr/local</file>
(zobacz <ref id="diverse">). W związku z tym, jeśli skompilujesz program ze
źródeł oraz zainstalujesz go w <file>/usr/local</file> nie będzie on
kolidował z Debianem.
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # to polecenie przekopiuje pliki do systemu
</example>

<sect2>Odinstalowywanie programu
<p>
Jeśli nadal posiadasz źródła i używają one
<prgn>autoconf</prgn>/<prgn>automake</prgn> oraz pamiętasz parametry
z jakimi je konfigurowałeś spróbuj:
<example>
$ ./configure <var>wszelkie-opcje-jakie-podałeś-przy-konfiguracji</var>
# make uninstall
</example>
<p>
Zamiast tego, jeśli jesteś absolutnie pewien, że podczas instalacji pliki
kopiowane są tylko do <file>/usr/local</file> i nie ma tam niczego ważnego,
możesz usunąć jego zawartość wprowadzając:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
Jeśli natomiast nie jesteś pewien gdzie zostały przekopiowane pliki podczas
instalacji, rozważ zastosowanie <package>checkinstall</package>, który
pozwala w łatwy sposób odinstalować programy.
</sect1>

</sect>

<sect>Przygotowanie dokumentu
<p>

<sect1>Skład tekstu <tt>roff</tt>
<p>
Tradycyjnie już, <tt>roff</tt> jest głównym systemem procesu tekstu
w systemach Unix.
<p>
Zobacz <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7"> oraz
<tt>info groff</tt>.
<p>
Istnieje dobre wprowadzenie do makr <prgn>-me</prgn>.
Jeśli posiadasz <package>groff</package> (w wersji 1.18 lub nowszej), znajdź
<file>&f-meintro;</file> i wprowadź poniższe polecenie:
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
Kolejne polecenie utworzy zwykły plik tekstowy:
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
Dla drukowania skorzystaj z wyjścia PostScript.
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>

<sect1>SGML
<p>
Przygotowanie:
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>

Miejsca, w których można znaleźć informacje o <package>debiandoc-sgml</package>:
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em><url name="DocBook: The Definitive Guide"
  	       id="&f-docbook-defguide;"></em>, by Walsh and Muellner, (O'Reilly)
  	       (pakiet <package>&p-docbook-defguide;</package>)

</list>
<p>
SGML umożliwia zarządzanie wieloma formatami dokumentu. Jednym z prostszych
systemów SGML jest Debiandoc, który jest tutaj używany. Wymaga on pewnych
konwersji plików tekstowych dla następujących znaków:
<!-- nbsp bug in PDF ? -->
<list compact>
<item>„&lt;” --&gt; <tt>&amp;lt;</tt>
<item>„&gt;” --&gt; <tt>&amp;gt;</tt>
<item>„&nbsp;” --&gt; <tt>&amp;nbsp;</tt>  (niełamana spacja)
<item>„&amp;” --&gt; <tt>&amp;amp;</tt>
<item>„&percnt;” --&gt; <tt>&amp;percnt;</tt>
<item>„&copy;” --&gt; <tt>&amp;copy;</tt>
<item>„&ndash;” --&gt; <tt>&amp;ndash;</tt>
<item>„&mdash;” --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
W celu oznaczenia części jako niedrukowalny komentarz wprowadź:
<example>
&lt;!-- A tu jest właśnie komentarz ... --&gt;
</example>
Do oznaczenia miejsca, z którym mamy problemy (brak wiedzy, doświadczenia
z danego zakresu) użyj poniższej formy:
<example>
&lt;![ &percnt;FIXME; [ Nie wiem, co tu powinno być ... ]]&gt;
</example>
W SGMLu <em>pierwsza definicja</em> entitki wygrywa. Przykład:
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
W dokumencie wynikowym będzie "Data 1". Jeśli w pierwszej linii byłoby
"IGNORE" zamiast "INCLUDE", pojawiłoby się "Data 2" (druga linia jest
wyrażeniem warunkowym). Również powtórzone zwroty, wyrażenia mogą być
z góry oddzielone od kontekstu.
<example>
&lt;!entity <var>czyjtojest</var> "mój"&gt;
Witaj  &amp;<var>czyjtojest</var>; przyjacielu.
To jest &amp;<var>czyjtojest</var>; podręcznik.
</example>
Efektem będzie:
<example>
Witaj mój przyjacielu.
To jest mój podręcznik.
</example>
Przyjrzyj się prostemu przykładowi SGML <file>sample.sgml</file>,
znajdującego się w <url id="&examples;" name="examples">.
<p>
Niekiedy, gdy dokument SGML rozrasta się, TeX (używany jako silnik do przetwarzania
tekstu) może zacząć generować błędy. Więcej informacji tutaj: <ref id="texlatex">.

<!-- XXX FIXME XXX: Add XML section-->

<sect1 id=texlatex>TeX/LaTeX
<p>
Przygotowanie:
<example>
	 # tasksel # select Miscellaneous  --&gt; TeX/LaTeX environment
</example>
Odsyłacze poświęcone LaTeXowi:
<list compact>
	<item><url id="&tetex-howto;" name="The teTeX HOWTO: The Linux-teTeX Local Guide">
	 <item><manref name="tex" section="1">
	 <item><manref name="latex" section="1">
	 <item><em>The TeXbook</em>, by Donald E. Knuth, (Addison-Wesley)
		<footnote>
		TeXowe źródło tej książki jest dostępne tutaj:
		<url id="&texbooksource;">.  <url id="&texbookmacros;"> zawiera
		większość potrzebnych makrodefinicji. Można przetworzyć ten dokument
		programem <prgn>tex</prgn> po zakomentowaniu linii od 7 do 10 i
		dodaniu <tt>\input manmac \proofmodefalse</tt>.
		<p>
		Jakkolwiek silnie polecamy zakup tej książki (oraz innych autorstwa
		Donalda E. Knutha) zamiast korzystania z tej wersji, to jest ona
		wspaniałym przykładem źródła dokumentu TeXowego.
	       </footnote>
	 <item><em>LaTeX - A Document Preparation System</em>, by Leslie Lamport,
	       (Addison-Wesley)
	 <item><em>The LaTeX Companion</em>, by Goossens, Mittelbach, Samarin,
	       (Addison-Wesley)
</list>
<p>
TeX to najpotężniejsze środowisko składu dokumentów. Wiele procesorów SGML używa go
do przetwarzania tekstu. Lyx dostarczany w pakietach <package>lyx</package>,
<package>lyx-xforms</package> oraz <package>lyx-qt</package> oferuje przyjemne
środowisko WYSIWYG dla LaTeXa, jednakże wiele osób wybiera Emacsa lub Vima do
tworzenia źródeł (La)TeXowych.
<p>
Istnieje wiele dokumentacji i zasobów dostępnych w Sieci:
<list compact>
	 <item><url id="&f-tetex-doc;" name="teTeX - A Documentation Guide">
	       (<package>&p-tetex-doc;</package> package)
	 <!-- translators please add the following documents:
	 1) "The Not So Short Introduction to LaTeX2e"
	 (&f-tetex-doc; links to an English copy on harddisk (slightly outdated))
	 There exist many translations (and MUCH more documents in ../):
	 ftp://ftp.dante.de/tex-archive/info/lshort/
	 2) ftp://ftp.dante.de/tex-archive/info/<your-language>
	 PS: I (Jens) don't like the following references (too short, external)
	 -->
	 <item><url id="&pfaffbenhome;" name="A Quick Introduction to LaTeX">
	 <item><url id="&latexlyx;" name="A Simple Guide to Latex/Lyx">
	 <item><url id="&latexbasic;" name="Word Processing Using LaTeX">
	 <item><url id="&local-guide;" name="Local User Guide to teTeX/LaTeX">
</list>
Gdy dokument rozrasta się, TeX może zacząć generować błędy.
Żeby uporać się z tym problemem, musisz zwiększyć parametr pool size w
<file>/etc/texmf/texmf.cnf</file> (lub, co bardziej zalecane, zmodyfikować
<file>/etc/texmf/texfm.d/95NonPath</file> i uruchomić
<prgn>update-texmf</prgn>).

<sect1>Literat-programista
<p>
Zamiast pisania kodu zawierającego dokumentację, literat-programista pisze
dokumentację zawierajacą kod. To zapewnia dobrą dokumentację dla programu.
<p>
Więcej na ten temat znajduje się tutaj:
<url id="&literatehome;" name="Literackie programowanie">.

<sect2>Noweb
<p>Przygotowanie:
<example>
	# apt-get install nowebm
</example>
Odsyłacze na temat Noweb:
<list compact>
	 <item><url id="&nowebhome;" name="Noweb --- A Simple, Extensible Tool for Literate Programming">
	 <item><manref name="noweb" section="1">
</list>
<p>
  	 Jest to narzędzie w stylu WEB, które jest prostsze oraz zapewnia
rozszerzalność i niezależność od języka.
<footnote>WEB nie ma nic <strong>nic</strong> wspólnego z World Wide Web. WEB
(dla Pascala) oraz CWEB (dla C/C++) to tradycyjne narzędzia programowania
literackiego. </footnote>

Kiedy <prgn>noweb</prgn> zostanie użyty, wypisuje źródło programu do plików
wyjściowych wskazanych w pliku noweb oraz tworzy pliki w formacie TeX
składające się na dokumentację.

<p>
Pakiet <package>ifupdown</package> to świetny przykład.
  	 <example>
  	 $ apt-get source ifupdown
  	 $ cd ifupdown*
  	 $ make ifupdown.pdf ifupdown.ps
  	 </example>

<sect2>Doxygen
<p>
Przygotowanie:
  	 <example>
  	 # apt-get install doxygen doxygen-doc doxygen-gui
  	 </example>
Odsyłacze na temat Doxygen (tworzone przez <prgn>doxygen</prgn>!):
  	 <list compact>
  	 <item><url id="&doxygenhome;" name="Homepage">
  	 <item><url id="/usr/share/doc/doxygen-doc/html/index.html">
  	 </list>
  	 <p>
Narzędzie potrafi tworzyć pliki HTML, RTF, podręcznika systemowego Unix,
PostScript oraz PDF (z użyciem LaTeXa) stanowiące dokumentację do C++, C,
Jawy, IDL oraz w pewnej mierze programów PHP i C#.

Doxygen jest zgodny z JavaDoc (1.1), Qt-Doc oraz KDOC i został
zaprojektowany specjalnie dla projektów wykorzystujących firmowane
przez Troll Techa <url id="&qthome;" name="Qt">rozwiązania.  
Program tworzy drzewo zależności, diagramy współpracy oraz graficzną
hierarchię klas (nawet dla nieudokumentowanych programów). W efekcie powstaje
dokumentacja podobna do dostarczanej z bibliotekami Qt.
</sect>

<sect id="packaging">Pakietowanie
<p>
Przygotowanie:
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
                  &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # dla Potato
</example>
Miejsca, w których można znaleźć informacje o pakietowaniu:
<list compact>
 <item><ref id="pkg-basics"> (podstawy)
 <item>Debian New Maintainers' Guide (samouczek)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (najlepsza praktyka)
 <item>Debian Policy Manual (autorytatywny)
 <item>Packaging Manual (Potato) 
</list>

<sect1 id="pack-binary">Pakietowanie pojedyńczego pliku binarnego
<p>
Szybka i brzydka metoda pakietowania podesłana przez Joey Hessa.
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mojpakiet
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: mój mały pakiecik
 Nie spodziewaj się zbyt wiele.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">Pakietowanie z użyciem narzędzi
<p>
W celu utworzenia podstawowego pakietu możesz skorzystać
z <prgn>dh_make</prgn> dostępnego w pakiecie <package>dh-make</package>.
Następnie postępuj według instrukcji z <manref name="dh-make" section="1">.
Ten sposób wykorzystuje <prgn>debhelper</prgn> w <prgn>debian/rules</prgn>.
<p>
Starszym sposobem jest użycie <prgn>deb-make</prgn> z pakietu
<package>debmake</package>. Wtedy korzysta się jedynie z powłoki, zamiast
z <prgn>debhelper</prgn>.
<p>
Przykładem wieloźródłowego pakietu może być „mc” (<tt>dpkg-source -x
mc_4.5.54.dsc</tt>), korzystający z „sys-build.mk” Adama Heatha
(<email>doogie@debian.org</email>), oraz „glibc” (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>), który korzysta z innego systemu Joela Kleckera
(<email>espy@debian.org</email>).
</sect>

</chapt>
