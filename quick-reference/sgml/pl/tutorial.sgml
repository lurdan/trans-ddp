<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.38"  -->

<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<!-- INFORMACJE TYMCZASOWE -->
<!-- UWAGA, dokument w aktualizacji do wersji angielskiej 1.75! -->
<!-- Tłumacz: rozie (Paweł 'Róża' Różański) -->
<!-- Poniżej znaczniki dla korektora -->
<!-- Tłum. zrobione 1.75 -->

<chapt id="tutorial">&debian; - samouczek

<p>
<!-- new content -->
Ten rozdział przedstawia podstawowe informacje na temat systemu &debian;
i jest przeznaczony dla zupełnie początkujących użytkowników (newbies).
Jeśli kiedykolwiek korzystałeś już z systemu uniksopodobnego, prawdopodobnie
znasz wszystkie omówione w tym rozdziale informacje, ale możesz przeczytać go
dla odświeżenia swojej wiedzy.  

<sect id="first">Zaczynamy
<p>
<!-- new content -->
Po zainstalowaniu systemu &debian; na swoim komputerze, musisz nauczyć się
kilku rzeczy, aby go używać.  Pozwól, że damy ci szybki kurs.

<sect1 id="login-root">Logowanie do powłoki jako root
<p>
<!-- new content -->

Po uruchomieniu systemu (reboot), zostanie przedstawiony Tobie graficzny lub
tekstowy ekran logowania (zależnie od tego, który wybrałeś podczas wstępnego
wyboru pakietów).  Dla uproszczenia, jeśli pojawił się graficzny ekran
logowania, naciśnij Ctrl-Alt-F1,
<footnote>
Klawisze lewy-Ctrl, lewy-Alt i klawisz F1 należy przycisnąć jednocześnie.  
</footnote>
aby uzyskać tekstowy ekran logowania.
<p>
Przypuśćmy, że nazwa twojego hosta to <tt><var>foo</var></tt>.  Wówczas twój
znak zachęty wygląda tak:
<example>
<var>foo</var> login:
</example>
Wpisz <tt>root</tt>, naciśnij klawisz Enter, a następnie wpisz hasło, które
wybrałeś podczas procesu instalacji.  W systemie &debian;, zgodnie z tradycją
systemów Unix, wielkość liter w haśle ma znaczenie.  Po podaniu hasła system
uruchomi się z informacją powitalną i przedstawi ci znak zachęty linii poleceń
użytkownika root, czekając na wprowadzenie poleceń.  
<footnote>
Zauważ, że jeśli edytowałeś informację powitalną w <file>/etc/motd</file>,
poniższe komunikaty mogą wyglądać inaczej.  
</footnote>
<example>
<var>foo</var> login: root
Password: 
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
Od tej chwili masz możliwość administracji systemem z linii poleceń
użytkownika root.  Konto root jest także nazywane kontem superużytkownika
(superuser) lub uprzywilejowanego użytkownika.  Z tego konta masz możliwość
robienia w systemie wszystkiego:
<list compact>
<item>odczytu, zapisu oraz usuwania każdego pliku w systemie, niezależnie od
praw dostępu do tego pliku
<item>zmiany właściciela pliku oraz praw dostępu do każdego pliku w systemie
<item>ustawiania haseł dla nieuprzywilejowanych użytkowników w systemie
<item>logowania się na dowolne konto w systemie bez znajomości jego hasła
</list>
<p>
Współdzielenie dostępu do konta roota przez posiadanie wspólnego hasła jest
fatalnym pomysłem.  Użycie programów takich jak <manref name="sudo"
section="8"> jest właściwym sposobem na współdzielenie przywilejów
administratora.
<p>
Zauważ też, że logowanie się najpierw na konto nieuprzywilejowanego
użytkownika, a dopiero z niego na konto z przywilejami administracyjnymi jest
uważane za dobry zwyczaj uniksowy.  Jeśli zajdzie potrzeba, używaj komend
<tt>sudo</tt>, <tt>super</tt> lub <tt>su -c</tt>, aby uzyskać ograniczone
przywileje roota. Zobacz <ref id="sudo">.
<footnote>
Muszę przyznać, że kiedyś używałem konta superużytkownika
(konto root) częściej, niż potrzebowałem, głównie z powodu wygody i mojego
niechlujstwa.
</footnote>

<sect1 id="newbiefix">Tworzenie minimlnego środowiska dla początkującego
<p>
<!-- new content -->
Uważam, że nauka systemu operacyjnego komputera przypomina nieco naukę języka
obcego.  Mimo, że książki są pomocne, to nic nie zastąpi samodzielnej
praktyki. Musisz zacząć działać samodzielnie, przy pomocy ułatwiających to
narzędzi.  W związku z tym, dobrym pomysłem jest zainstalowanie kilku
dodatkowych pakietów, takich jak <package>mc</package>, <package>vim</package>,
<package>linx</package>, <package>doc-linux-text</package> oraz
<package>debian-policy</package>.
<footnote>
Dobrym pomysłem może być także instalacja <package>gpm</package>,
<package>emacs21</package> oraz <package>doc-linux-html</package>.  Zobacz
<ref id="gpm"> i <ref id="edit">.
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy 
 ...
</example>
Jeśli pakiety są już zainstalowane w systemie, zostaną dodane.

<sect1 id="newuser"> Dodawanie konta użytkownika
<p>
<!-- new content -->
Podczas instalacji, zwykle tworzy się konto użytkownika nieuprzywilejowanego,
służące do odbioru poczty elektronicznej wysyłanej do użytkownika root.  
<footnote>
Zwykle nazywam te konto <tt>admin</tt>, ale może ono mieć dowolną nazwę.  
</footnote>
Ponieważ nie chcesz używać tego specjalnego konta do działalności treningowej,
powienieneś utworzyć kolejne konto użytkownika.
<p>
Zakładając, że chcesz, aby nazwa nowego użytkownika była <tt><var>penguin</var></tt>, wpisanie:
<example>
root@<var>foo</var>:root# adduser <var>penguin</var>
... odpowiedz na wszystkie pytania
</example>
utworzy to konto.  

<footnote>
Możesz zechcieć dodać użytkownika <tt><var>penguin</var></tt> do grupy
<tt>adm</tt>, aby umożliwić mu odczyt plików z logami w 
<file>/var/log/</file>.  Zobacz <manref name="passwd" section="5">, <manref
name="group" section="5">, <manref name="shadow" section="5">, <manref
name="group" section="5">, <manref name="vipw" section="8"> oraz <manref
name="vigr" section="8">.  W celu otrzymania informacji o oficjalnym znaczeniu
użytkowników i grup, zobacz bieżącą wersję dokumentu <url id="&f-users-and-groups;"
name="Users and Groups">.  
</footnote>
Zanim przejdziemy dalej, nauczmy się paru rzeczy.

<sect1 id="sw-console">Przełączanie między konsolami wirtualnymi
<p>
<!-- modified old content -->
W domyślnej instalacji systemu &debian;, dostępnych jest sześć niezależnych
pseudo-terminali, czyli można używać konsoli tekstowej na sześciu
przełączalnych terminalach VT-100.  Przełączać się między nimi można przez
jednoczesne naciśnięcie klawisza Lewy-Alt i jednego z klawiszy F1&ndash;F6.  
Każdy pseudo-terminal pozwala na niezależne logowanie się na konto systemowe.  
Środowisko wieloużytkownikowe to wspaniała cecha Uniksa, po poznaniu której
ciężko pracować inaczej.  

<p>
<!-- new content -->
Jeśli przypadkowo naciśniesz Alt-F7 podczas pracy na systemie z uruchomionym
środowiskiem graficznym X Window i konsola przełączy się w tryb graficzny,
naciśnięcie Ctrl-Alt-F1 pozwoli na przywrócenie dostępu do konsoli tekstowej.  
Po prostu spróbuj przełączać się na różne konsole i powracać do wyjściowej, aby
przywyknąć do środowiska z wieloma pseudo-terminalami.  

<sect1 id="shutdown">Zamykanie systemu
<p>
<!-- heavily modified content -->
Tak jak każdy współczesny OS, który cache'uje operacje na plikach w pamięci,
także &debian; wymaga właściwej procedury zamykania systemu w celu zachowania
integralności plików, zanim zasilanie może zostać bezpiecznie wyłączone.  
Używaj następującej komendy z konta root do zamknięcia systemu:
<example>
# shutdown -h now
</example>
Tak postępuje się w przypadku trybu wieluużytkownikowego.  Jeśli pracujesz w
trybie pojedynczego użytkownika (single-user), używaj komendy:
<example>
# poweroff -i -f
</example>
Możesz także nacisnąć Ctrl-Alt-Delete aby zamknąć system.  
<footnote>
Klawisz lewy-Ctrl, klawisz lewy-Alt oraz klawisz Delete naciśnięte jednocześnie
w konsoli.  Przy domyślnych ustawieniach powoduje to reboot systemu.  Aby
wykonywane było zamknięcie systemu (<prgn>shutdown</prgn>) z opcją <tt>-h</tt>,
należy zmodyfikować <file>/etc/inittab</file> zgodnie z wytycznymi z <ref id="post-inst">.
</footnote>
<p>
Zaczekaj na pojawienie się napisu "System halted" i dopiero wówczas wyłącz
zasilanie.  Jeśli funkcje APM lub ACPI zostały poprawnie włączone w BIOSie i
Linuksie, system wyłączy się samodzielnie.  Doczytaj szczegóły w <ref id="apm">.  
<sect1 id="playtime">Do rzeczy
<p>
<!-- new content -->
Teraz jesteś gotów rozpocząć zabawę z systemem &debian;, przy czym dopóki
używasz nieuprzywilejowanego konta <tt><var>penguin</var></tt>, nie musisz obawiać
się, że coś zepsujesz w systemie.
<footnote>
Dzieje się tak za sprawą faktu, że system &debian; jest skonfigurowany z
właściwymi prawami dostępu od razu po domyślnej instalacji. Uniemożliwia to
nieuprzywijelowanym użytkownikom uszkodzenie systemu.  Oczywiście, nadal mogą
istnieć dziury, które mogą zostać wykorzystane do dokonania nadużyć, ale ci, którzy
mają powody martwić się o nie, nie powinni czytać tego dokumentu, a
<url id="&securing-debian-howto;" name="Securing Debian Manual">.
</footnote>
<p>
Zaloguj się na konto <tt><var>penguin</var></tt>.   
Jeśli jesteś zalogowany jako root, naciśnij Ctrl-D
<footnote>
Lewy klawisz Ctrl i klawisz d są naciskane jednocześnie.  Nie ma potrzeby
naciskania klawisza Shift pomimo, że te znaki kontrolne są oznaczone w
odniesieniach wielką literą, jako "control D".  
</footnote>
aby zamknąć powłokę root i powrócić do znaku zachęty logowania.  Wprowadź
nowoutworzoną nazwę użytkownika <tt><var>penguin</var></tt> i przynależne jej hasło.
<footnote>
Jeśli wpiszesz tutaj <tt>root</tt> zamiast <tt><var>penguin</var></tt> oraz
podasz przynależne hasło użytkownika <tt>root</tt>, ponownie otrzymasz dostęp
do konta <tt>root</tt>.  Ta procedura będzie konieczna do odzyskania dostępu do
konta <tt>root</tt>.
</footnote>
Zostanie ci przedstawiony następujący znak zachęty.
<example>
<var>penguin</var>@<var>foo</var>:<var>penguin</var>$ 
</example>
<p>
Od teraz, poniższy przykładowy zapis będzie używany dla uproszczenia:
<list compact>
<item><tt>#</tt> : znak zachęty w koncie root
<item><tt>$</tt> : znak zachęty nieuprzywilejowanego użytkownika
</list>
<p>
Teraz rozpoczniesz naukę systemu &debian;, najpierw sposobu prostego <ref
id="mc">, a następnie sposobu właściwego <ref id="unixlike">.  

<!-- /Tłum. zrobione 1.75  -->

<sect id="mc">Midnight Commander (MC)
<p>
<!-- old content -->
Midnight Commander (MC) jest uniwersalnym narzędziem konsoli Linuksa oraz
innych środowisk terminalowych. Umożliwia ono użytkownikowi zdobycie 
doświadczenia w wykonywania poleceń systemowych przy użyciu menu, które są 
poręczniejsze i łatwiejsze w nauce od standardowych poleceń systemu Unix.
<!-- New content -->
<p>
Użyj tego narzędzia by przejrzeć strukturę systemu &debian;. To najlepszy sposóbnauki. Przy pomocy klwiszy kursorów oraz klasiwsza Enter zajrzyj w kilka
kluczowych miejsc:
<list compact>
<item><file>/etc</file> oraz podkatalogi.
<item><file>/var/log</file> oraz podkatalogi.
<item><file>/usr/share/doc</file> oraz podkatalogi.
<item><file>/sbin</file> and <file>/bin</file>
</list>

<sect1 id="mc-enhance">Konfigurowanie MC
<p>
<!-- modified old content -->
Jeśli chcesz aby przy opuszczaniu programu MC zmieniał on aktualny katalog,
musisz zmodyfikować plik <file>~/.bashrc</file> 
(lub <file>/etc/bash.bashrc</file>,
wywoływany z <file>.bashrc</file>), tak jak dokładnie opisano to w jego 
podręczniku, <manref name="mc" section="1">, przy opcji <tt>-P</tt>.
<footnote>
Jeśli nie rozumiesz o czym tutaj mówię, możesz tych zmian dokonać później.
</footnote>

<sect1 id="mc-start">Uruchamianie MC
<p>
<!-- modified old content -->
<example>
$ mc
</example>
MC zajmuje się wszystkimi operacjami na plikach, wykonywanymi z jego
menu, wymagając minimalnego wysiłku od użytkownika. Naciśnij po prostu klawisz
F1 aby uzyskać ekran pomocy. Możesz poruszać się po całym programie używając
klawiszy kursorów oraz klawiszy funkcyjnych.
<footnote>
W terminalach takich jak <prgn>kon</prgn> lub <prgn>kterm</prgn> występują 
pewne problemy ze znakami graficznymi języka japońskiego.
Dodanie <tt>-a</tt> do wywołania MC może je rozwiązać.
</footnote>

<sect1 id="mc-fm">Menedżer plików w MC
<p>
<!-- old content -->
Domyślne ustawienie to dwa okna zawierające listy plików. Kolejnym użytecznym
trybem jest ustawienie prawego okna w tryb „informacja”, co 
pozwala zobaczyć
prawa dostępu itp. Poniżej są niektóre ważniejsze skróty klawiszowe.
Z użyciem uruchomionego demona <prgn>gpm</prgn> można też używać myszy.
(Upewnij się, że naciskasz klawisz Shift w celu uzyskania normalnego działania
Kopiuj i Wklej w MC.)
<list compact>
<item>F1: Menu pomocy
<item>F3: Wewnętrzny podgląd pliku
<item>F4: Wewnętrzny edytor
<item>F9: Uaktywnienie rozwijanego menu
<item>F10: Wyjście z Midnight Commander
<item>Tab: Przełączanie pomiędzy dwoma oknami
<item>Insert: Wybranie pliku do operacji na wielu plikach, np. dla kopiowania
<item><tt>Del</tt>: Usunięcie pliku (Bądź ostrożny&mdash;ustaw MC w tryb bezpiecznego usuwania.)
<item>Klawisze kursora: Oczywiste
</list>

<sect1 id="mc-cl">Triki linii poleceń w MC
<p>
<!-- old content -->
<list compact>
<item>Każde polecenie <prgn>cd</prgn> zmienia katalog pokazany na wybranym 
ekranie.
<item>Ctrl-Enter lub Alt-Enter wkleja nazwę pliku do linii poleceń.
Używaj tego łącznie z poleceniem <prgn>cp</prgn> lub <prgn>mv</prgn>
z edycją w powłoce.
<item>Alt-Tab pokaże dostępne polecenia z linii poleceń.
<item>Możesz określić katalogi startowe dla obu okien podając je jako parametry przy
wywoływaniu MC; na przykład <tt>mc /etc /root</tt>.
<item><tt>Esc</tt> + <var>klawisz numeryczny</var> == <tt>F<var>n</var></tt> 
(np.
  Esc + 1 = F1, itd.; Esc + 0
  = F10)
<item> Klawisz Esc == klawisz Alt (= Meta,
  M-); np. wpisz Esc + c by otrzymać Alt-C
<!-- control characters are referred with the upper case. -->
</list>

<sect1 id="mcedit">Edytor w MC
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
Wewnętrzny edytor ma interesujący schemat kopiuj-i-wklej. Naciśnięcie
F3 oznacza początek wyboru, kolejne wciśnięcie F3 oznacza
koniec wyboru i podświetla zaznaczony obszar. Wtedy możesz ruszać kursorem.
Gdy naciśniesz F6, zaznaczony obszar zostanie przeniesiony do miejsca,
w którym jest kursor. Gdy przyciśniesz F5, zaznaczony obszar zostanie
skopiowany i wklejony w miejsce, w którym jest kursor. F2 zapisuje
plik. F10 powoduje zakończenie MC. Klawisze kursora zwykle działają
intuicyjnie.
<p>
Edytor może być wywołany dla pliku:
<example>
$ mc -e plik_do_edycji
$ mcedit plik_do_edycji
</example>
<p>
Nie jest to edytor wielo-okienkowy, ale możesz osiągnąć podobny efekt używając
wielu konsoli linuksowych. Aby kopiować pomiędzy oknami, użyj klawiszy 
Alt-F<var>n</var>
do przełączania konsol wirtualnych, a do wklejania fragmentu pliku do innego
pliku, użyj „Plik-&gt;Wstaw plik” lub „Plik-&gt;Kopiuj do pliku”.
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it.
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)

I see .. but for now I do this not to hack LaTeX
-->
<p>
Wewnętrzny edytor może być zastąpiony przez dowolnie wybrany zewnętrzny.
<p>
Wiele programów używa także zmiennej środowiskowej <tt>EDITOR</tt> lub 
<tt>VISUAL</tt> by określić, którego edytora użyć. Jeśli nie odpowiada Ci
<prgn>vim</prgn>, ustaw go na <tt>mcedit</tt> przez dodanie poniższych linii 
do <file>~/.bashrc</file>:
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
Zalecam jednak ustawienie ich na <tt>vim</tt>, jeśli to możliwe. Przywyknięcie
do poleceń  <prgn>vim</prgn> jest dobrą rzeczą, od kiedy edytor Vi jest 
nieodłączną cechą świata Linuksa/Uniksa.
<footnote>
Aktualnie, <prgn>vi</prgn> oazr <prgn>nvi</prgn> to programy, które
znajdziesz wszędzie. Wybrałem <prgn>vim</prgn> dla początkujących gdyż
oferuje on pomoc pod klawiszem F1 będąc zarazem podobnym i potężniejszym
narzędziem od samego <prgn>vi</prgn>.
</footnote>

<sect1 id="mc-view">Podgląd w MC
<p>
<!-- almost old content -->
Bardzo sprytne narzędzie. Jest świetny do wyszukiwania słów w dokumentach.
Zawsze używam go do przeglądania plików w katalogu <file>/usr/share/doc</file>.
To najszybszy sposób na przeglądanie mas informacji o Linuksie. Podgląd można
uruchomić bezpośrednio w taki sposób:
<example>
$ mc -v nazwa_pliku_do_podglądu
</example>

<sect1 id="ma-auto">Własności auto-startu programu MC
<p>
<!-- almost old content, tar.gz and deb are new -->
Wciśnij Enter na pliku i właściwy program zajmie się jego zawartością. Jest to bardzo wygodna cecha MC.
<example>
plik wykonywalny:  Wykonanie pliku wykonywalnego
plik man, html:    Przesłanie zawartości pliku przez przeglądarkę
plik tar.gz, plik deb: Przeglądanie zawartości pliku jako podkatalogu
</example>
By te przeglądarki/wirtualne pliki poprawnie działały, przeglądane pliki
nie mogą mieć atrybutu wykonywalności. Zmień ich status używając
polecenia <prgn>chmod</prgn> lub przez menu plików w MC.
</sect1>

<sect1 id="mc-ftp">Wirtualny system plików FTP w programie MC
<p>
<!-- old content -->
MC może służyć do dostępu do plików przez Internet przy użyciu FTP. Wejdź do
menu wciskając F9, następnie wpisz `p', by aktywować wirtualny
system plików FTP. Wpisz URL w formie:
<tt>nazwa_użytkownika:hasło@nazwa_hosta.nazwa_domeny</tt>, co spowoduje
pojawienie się katalogu zdalnego, wyglądającego jak lokalny.

<p>
<!-- new content -->
Wypróbuj <tt>&ftp-debian;</tt> jak adres URL i przejrzyj archiwum
plików systemu &debian;. Przeczytaj <ref id="ftparchives"> by dowiedzieć
się więcej o strukturze katalogów.

<sect id="unixlike">Praca w środowisku uniksopodobnym
<p>
<!-- new content -->
Chociaż MC pozwala Ci zrobić niemal wszystko, jest bardzo ważną rzeczą aby
nauczyć się używać narzędzi linii poleceń uruchamianych z powłoki aby zaznajomić
się ze środowiskiem uniksopodobnym. 
<footnote>
W tym rozdzialem, powłoką idomyślną jest <prgn>bash</prgn>. Po więcej informacji
o różnych powłokach zajrzyj do <ref id="shell">.
</footnote>

<sect1 id="sp-keys">Specjalne sekwencje klawiszy
<p>
<!-- practically new content -->
W środowisku uniksopodobnym, istnieje kilka sekwencji klawiszy które mają 
znaczenie specjalne.
<footnote>
W normalnej znakowej konsoli systemu Linux, tylko klawisze Lewy-Ctrl i Lewy-Alt
mają oczekiwane funkcje.
</footnote>
<list compact>
<item>Ctrl-U: Usuwa linię przed kursorem.
<item>Ctrl-H: Usuwa znak przed kursorem.
<item>Ctrl-D: Kończy standardowe wejście (zamyke powłokę jeśli używasz powłoki)
<item>Ctrl-C: Kończy działający program.
<item>Ctrl-Z: Tymczasowo zatrzymuje program (przenosi program w tło, zobacz <ref id="cmd-back">)
<item>Ctrl-S: Wstrzymuje wyjście na ekran.
<footnote>
Możesz wyłączyć tę opcję terminala używając
<manref name="stty" section="1">.
</footnote>
<item>Ctrl-Q: Przywraca wyjście na ekran.
</list>
<p>
Domyślna powłoka <prgn>bash</prgn>,
posiada zdolność edycji-historii oraz oraz możliwość dopełniania poleceń
przy pomocy klawisza tab, by wspomóc interaktywne używanie.
<list compact>
<item>strzałka w górę:  Zaczyna przeszukiwać historię poleceń.
<item>Ctrl-R: Uruchamia przeszukiwanie historii poleceń.
<item>TAB: Dopełnia wprowadzoną nazwę pliku w linii poleceń.
<item>Ctrl-V TAB: Wprowadza TAB bez próby rozwinięcia go do dopasowania.
</list>
<p>
Inne ważne sekwencje klawiszy do zapamiętania:
<list compact>
<item>Ctrl-Alt-Del:  Ponownie uruchom/zatrzymaj system, 
      zobacz <ref id="post-inst">.
<item>Przeciągnięcie-lewym-klawiszem myszy: Zaznacza i kopiuje do schowka.
<item>Kliknięcie środkowym klawiszem myszy: Wkleja ze schowka w miejsce
      kursora.
<item>Meta-klawisz (terminologia Emacs) jest tradycyjnie powiązany
z klawiszem lewy Alt. Niektóre systemy mogą być skonfigurowane tak, że
Meta-klawisz odpowiada klawiszowi Windows.
</list>
Aby móc używać myszki w znakowej konsoli systemu Linux, musisz mieć 
uruchomionego demona <prgn>gpm</prgn>.
<footnote>
Wśrodowisku X Window, myszka funkcjonuje w ten sam sposób w programie Xterm.
</footnote>
Zajrzyj do <ref id="gpm">.

<sect1 id="unixcmds">Podstawowe komendy uniksowe
<p>
<!-- new content -->
Nauczymy się teraz podstawowych komend uniksowych.
<footnote>
Używam tutaj słowa "Unix" w jego ogólnym znaczeniu. Każdy system operacyjny
będący klonem systemu Unix oferuje zestaw narzędzi będących odpowiednikami
tych uniksowych. System &debian; nie jest wyjątkiem.
Nie martw się, jeśli jakieś polecenia nie działąją zgodnie z Twoimi 
oczekiwaniami. Poniższe przykłady nie zależą od kolejności ich wykonywania.
</footnote>
Wypróbuj działanie wszystkich poniższych poleceń używając do tego konta
zwykłego użytkownika <tt><var>penguin</var></tt> :
<list compact>
<item><tt>pwd</tt>
 <list compact>
 <item>Wyświetla nazwę katalogu, w którym się aktualnie znajdujesz.
 </list>
<item><tt>whoami</tt>
 <list compact>
 <item>Wyświetla Twoją nazwę użytkownika.
 </list>
<item><tt>file <var>foo</var></tt>
 <list compact>
 <item>Wyświetla typ pliku <var>foo</var>.
 </list>
<item><tt>type -p <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wyświetla położenie pliku polecenia <tt><var>nazwa_polecenia</var></tt>.
 <item><tt>which <var>nazwa_polecenia</var></tt> robi to samo.
 </list>
<item><tt>type <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wyświetla informacje o poleceniu <tt><var>nazwa_polecenia</var></tt>.
 </list>
<item><tt>apropos <var>słowo-klucz</var></tt>
 <list compact>
 <item>Wyszukuje polecenia związazane ze <tt><var>słowem-kluczowym</var></tt>.
 <item><tt>man -k <var>słowo-klucz</var></tt> robi to samo.
 </list>
<item><tt>whatis <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wyświetla jednolinijkowe wyjaśnienie o działaniu polecenia
  <tt><var>nazwa_polecenia</var></tt>.
 </list>
<item><tt>man -a <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wyświetla krótkie wyjaśnienie o działaniu poleceniu
  <tt><var>nazwa_polecenia</var></tt>. (styl uniksowy)
 </list>
<item><tt>info <var>nazwa_polecenia</var></tt>
 <list compact>
 <item>Wyświetla raczej obszerne wyjaśnienie o działaniu polecenia
  <tt><var>nazwa_polecenia</var></tt>.  (styl GNU)
 </list>
<item><tt>ls</tt>
 <list compact>
 <item>Listuje zawartość katalogu. (nie wyświetla plików oraz katalogów rozpoczynających się od kropki)
  <footnote>
system Unix tradycyjnie ukryw pliki, których nazwy rozpoczynają się od 
"<tt>.</tt>". Są to zazwyczaj pliki konfiguracyjne oraz zawierające 
ustawienia preferencji uzytkownika.
  </footnote>
 </list>
<item><tt>ls -a</tt>
 <list compact>
 <item>Listuje zawartość katalogu (wszystkie pliki i katalogi)
 </list>
<item><tt>ls -A</tt>
 <list compact>
 <item>Listuje zawartość katalogu. (wszystkie pliki i katalogi, za wyjątkiem
 "<file>..</file>" oraz "<file>.</file>")
 </list>
<item><tt>ls -la</tt>
 <list compact>
 <item>Listuje całą zawartość wraz ze szczegółowymi informacjami. Przeczytaj 
 <ref id="file-system">.
 </list>
<item><tt>ls -d</tt>
 <list compact>
 <item>Listuje podkatalogi znajdujące się w bieżącym katalogu.
 </list>
<item><tt>lsof <var>foo</var></tt>
 <list compact>
 <item>Wyświetla programy korzystające z pliku <tt><var>foo</var></tt>.
 </list>
<item><tt>mkdir <var>foo</var></tt>
 <list compact>
 <item>Tworzy nowy katalog o nazwie <tt><var>foo</var></tt>, w aktualnym 
 katalogu.
 </list>
<item><tt>rmdir <var>foo</var></tt>
 <list compact>
 <item>Usuwa katalog <tt><var>foo</var></tt> znajdujący się w aktualnym
 katalogu.
 </list>
<item><tt>cd <var>foo</var></tt>
 <list compact>
 <item>Zmienia aktualny katalog na katalog <file><var>foo</var></file>
 w bieżącym katalogu lub w katalogu wymienionym w zmiennej  
  <tt>CDPATH</tt>. Przeczytaj o poleceniu <prgn>cd</prgn> w
  <manref name="builtins" section="7">.
  </list>
<item><tt>cd /</tt>
 <list compact>
 <item>Zmienia bieżący katalog na katalog główny.
 </list>
<item><tt>cd</tt>
 <list compact>
 <item>Zmienia katalog bieżacy na katalog domowy uzytkownika.
 </list>
<item><tt>cd /<var>foo</var></tt>
 <list compact>
 <item>Zmienia katalog bieżący na ścieżke bezwzględna
 <file>/<var>foo</var></file>.
  </list>
<item><tt>cd ..</tt>
 <list compact>
 <item>Zmienia katalog na nadrzędny.
 </list>
<item><tt>cd ~<var>foo</var></tt>
 <list compact>
 <item>Zmienia katalog na katalog domowy użytkownika
  <tt><var>foo</var></tt>.
 </list>
<item><tt>cd -</tt>
 <list compact>
 <item>Zmienia katalog na poprzedni.
 </list>
<item><tt>&lt;/etc/motd pager</tt>
 <list compact>
 <item>Wyświetla zawartość pliku <file>/etc/motd</file> używając domyślnego
 pager'a. Przeczytaj <ref id="cmd-stdin">.
  <footnote>
Domyślnym pager'em systemu &debian; jest <prgn>more</prgn>, który nie
posiada opcji przewijania. Po zainstalowaniu pakietu <package>less</package> 
używając polecenia <tt>apt-get install less</tt>, program <prgn>less</prgn> 
staje się domyślnym pager'em posiadającym opcję przewijania przy pomocy
klawiszy kursorów.
  </footnote>
 </list>
<item><tt>touch <var>junkfile</var></tt>
 <list compact>
 <item>Tworzy pusty plik o nazwie <file><var>junkfile</var></file>.
 </list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Kopiuje istniejący plik <file><var>foo</var></file> do nowego pliku
 <file><var>bar</var></file>.
 </list>
<item><tt>rm <var>junkfile</var></tt>
 <list compact>
 <item>Usuwa plik <file><var>junkfile</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
 <list compact>
 <item>Zmienia nazwę istniejącego pliku <file><var>foo</var></file> na
  <file><var>bar</var></file>.
 </list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
 <list compact>
 <item>Przenosi istniejący plik <file><var>foo</var></file> do nowego miejsca
 o nazwie <file><var>bar/baz</var></file>. Katalog <file><var>bar/</var></file>
 musi istnieć.
 </list>
<item><tt>chmod 600 <var>foo</var></tt>
 <list compact>
 <item>Usuwa z listy praw dostępu do istniejącego pliku 
 <file><var>foo</var></file> prawa odczytu oraz zapisu dla innych użytkowników. 
 (brak praw wykonywania dla wszystkich)
 </list>
<item><tt>chmod 644 <var>foo</var></tt>
 <list compact>
 <item>Zmienia prawa dostępu do istniejącego pliku <file><var>foo</var></file> 
 na umożliwiające odczyt ale zabranijące zapisu do pliku dla innych 
 użytkowników. (brak prawa wykonywania dla wszystkich)
 </list>
<item><tt>chmod 755 <var>foo</var></tt>
 <list compact>
 <item>Zmienia prawa dostępu do istniejącego pliku <file><var>foo</var></file> 
 na prawo oidczytu lecz brak prawa zapisu. (prawo wykonywania dla wszystkich)
 </list>
<item><tt>top</tt>
 <list compact>
 <item>Wyświetla informacje o procesach na pełnym ekranie. Wciśnij "q"
 by zakończyć.
 </list>
<item><tt>ps aux | pager</tt>
 <list compact>
 <item>Wyświetla informacje o wszystkich działających procesach używając
 na wyjściu stylu BSD. Zobacz <ref id="cmd-pipe">.
 </list>
<item><tt>ps -ef | pager</tt>
 <list compact>
 <item>Wyświetla informacje o wszystkich działającyh procesach używając
 na wyjściu uniksowego stylu system-V.
 </list>
<item><tt>ps aux | grep -e "[e]xim"</tt>
 <list compact>
 <item>Wyświetla wszystkie procesy <prgn>exim</prgn>. Więcej na temat
 wyrażeń regularnych możesz dowiedzieć się ze strony podręcznika 
 <manref name="grep" section="1"> wprowadzając <tt>man grep</tt>.
 </list>
<item><tt>ps axf | pager</tt>
 <list compact>
 <item>Wyświetla informacje o wszystkich działającyh procesach używając na
 wyjściu stylu tworzenia grafiki przy pomocy znaków ASCII.
 </list>
<item><tt>kill <var>1234</var></tt>
 <list compact>
 <item>Ubija proces identifikowany poprzez jego numer ID: <var>1234</var>.
 Przeczytaj <ref id="kill">.
 </list>
<item><tt>grep -e "<var>pattern</var>" *.html</tt>
 <list compact>
 <item>Wyszukuje i wyświetla wszystkie wystąpienia "<var>wzorca</var>" 
 w plikach <tt>.html</tt> znajdujących się w bieżącym katalogu.
 </list>
<item><tt>gzip <var>foo</var></tt>
 <list compact>
 <item>Kompresuje plik <file><var>foo</var></file> i tworzy 
 <file><var>foo</var>.gz</file> używając kodowania Lempel-Ziv (LZ77).
 </list>
<item><tt>gunzip <var>foo</var>.gz</tt>
 <list compact>
 <item>Dekompresuje plik <file><var>foo</var>.gz</file> i tworzy 
  <file><var>foo</var></file>.
 </list>
<item><tt>bzip2 <var>foo</var></tt>
 <list compact>
 <item>Kompresuje plik <file><var>foo</var></file> i tworzy
  <file><var>foo</var>.bz2</file> używając algorytmu kompresji tekstu poprzez
  sortowanie blokowe Burrows-Wheeler i kodowanie metodą Huffman'a. (lepsza
  kompresja niż przy użyciu <prgn>gzip</prgn>)
 </list>
<item><tt>bunzip2 <var>foo</var>.bz2</tt>
 <list compact>
 <item>Dekompresuje plik <file><var>foo</var>.bz2</file> i tworzy
  <file><var>foo</var></file>.
 </list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
 <list compact>
 <item>Wydobywa pliki z archiwum <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
 <list compact>
 <item>Wydobywa pliki z archiwum <file><var>foo</var>.tar.gz</file>
 </list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
 <list compact>
 <item>Wydobywa pliki z archiwum <file><var>foo</var>.tar.bz2</file>.
  <footnote>
Opcja <tt>--bzip2</tt> jest tutaj używana zamiast nowej krótszej <tt>-j</tt> 
by zapewnić poprawną pracę ze starszą wersją <prgn>tar</prgn> w Potato.
  </footnote>
 </list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
 <list compact>
 <item>Archiwizuje zawartość folderu <file><var>bar</var>/</file> w pliku
 archiwum <file><var>foo</var>.tar</file>.
 </list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
 <list compact>
 <item> Archiwizuje zawartość folderu <file><var>bar</var>/</file> w
 skompresowanym archiwum <file><var>foo</var>.tar.gz</file>.
 </list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
 <list compact>
 <item>Archiwizuje zawartość folderu <file><var>bar</var>/</file> w
 archiwum <file><var>foo</var>.tar.bz2</file>.
  <footnote>
 Opcja <tt>--bzip2</tt> używana jest tutaj dla zachowania kompatybilności.
  </footnote>
 </list>
<item><tt>zcat README.gz | pager</tt>
 <list compact>
 <item>Wyświetla zawartość skompresowanego pliku 
  <file>README.gz</file> używając domyślnego pager'a.
 </list>
<item><tt>zcat README.gz &gt; foo</tt>
 <list compact>
 <item>Tworzy plik o zdekompresowanej <file>foo</file> zawartości pliku 
  <file>README.gz</file>.
 </list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
 <list compact>
 <item>Dołącza zdekompresowaną zawartość pliku <file>README.gz</file> na koniec
 pliku <file>foo</file>. (Jeśli ten plik nie istnieje, zostanie najpierw 
 utworzony)
 </list>
<item><tt>find . -name <var>pattern</var></tt>
 <list compact>
 <item>Wyszukuje nazwy plików pasujące do <tt><var>wzorca</var></tt>. 
 (wolniejsz)
 </list>
<item><tt>locate -d . <var>pattern</var></tt>
 <list compact>
 <item>Wyszukuje nazwy plików pasujące do <tt><var>wzorca</var></tt> powłoki.
  (szybsze, przy użyciu regularnie aktualizowanej bazy plików)
 </list>
<!--
<item>
 <list compact>
 <item><tt></tt>
 </list>
-->
</list>
<p>
W ramach treningu przejrzyj dostępne katalogi by zaznajomić się z systemem.
Jeśli masz jakiekolwiek pytania, przeczytaj obowiązkowo stronę podręcznika
systemowego. Dla przykładu zacznij od poniższych poleceń:
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
Jest już także odpowiednia pora by uruchomić <prgn>vim</prgn> i wcisnąć
klawisz F1. Powinieneś przeczytać przynajmniej pierwsze 35 linijek. 
Następnie przesuń kursor nad <tt>|tutor|</tt> i naciśnij Ctrl-] by
rozpocząć kurs. Przeczytaj <ref id="edit"> by nauczyć się więcej o edytorach.
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
Zauważ, że wiele polecen uniksopodobnych włączając w to niektóre GNU oraz
BSD będą wyświetlały zwięzłą informację jeśli wywołasz je w jeden z poniższych
sposobów:

<example>
$ <var>commandname</var> --help
$ <var>commandname</var> -h
</example>
<p>
Jako ćwiczenie, wypróbuj również przykłady znajdujące się w <ref id="tips">.

<sect1 id="cmd-exec">Wykonywanie poleceń
<p>
<!-- new content -->
Teraz masz już jakieś pojęcie jak używać systemu &debian;. Zajrzyjmy więć
głębiej by poznać mechanizm wykonywania poleceń w systemie &debian;.
<footnote>
W tym miejscu opis został przygotowany dla zupełnie początkujących. Po
dokładniejsze wyjaśnienia zajrzyj do <manref name="bash" section="1">.
</footnote>

<sect1 id="cmd-simple">Proste polecenie
<p>
<!-- new content -->
Proste polecenie jest sekwencją: 
<enumlist compact>
<item>przypisań zmiennych (opcjonalne)
<item>nazwy polecenia
<item>argumentów (opcjonalne)
<item>przekierowań (opcjonalne: <tt>&gt;</tt> , <tt>&gt;&gt;</tt> ,
<tt>&lt;</tt> , <tt>&lt;&lt;</tt> , etc.)
<item>operatorów kontrolujących (opcjonalnie: <tt>&amp;&amp;</tt> , 
<tt>||</tt> ; &lt;newline&gt; , <tt>;</tt> , <tt>&amp;</tt> , <tt>(</tt> , 
<tt>)</tt>)
</enumlist>
<p>
Bardziej skomplikowane polecenia wraz ze znakami cytowania i podmianą
wyrażeń możesz obejrzeć w <ref id="clprocess">.

<sect1 id="cmd-env">Wykonywanie polecenia oraz zmienna środowiskowa
<p>
<!-- new content -->
Typowe wywołanie polecenia używa sekwencji powłoki tak jak poniżej:
<footnote>
By otrzymać poniższe wyjście, musisz mieć zainstalowane francuskie locale,
zobacz <ref id="locales">. To nie jest zbyt istotne dla tego przewodnika
i zostało pokazane tylko by uświadomić Ci ewentualne efekty.
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
Powyżej, program <prgn>date</prgn> jest wykonywany jako zadanie w tle.
Zmienna środowiskowa <tt>LC_ALL</tt> jest:
<list compact>
<item>nieustawiona (domyślne zachowanie systemu, tak jak i w przypadku 
<tt>C</tt>) dla pierwszego polecenia
<item>ustawiona na <tt>fr_FR</tt> (locale francuskie) dla drugiego 
polecenia
</list>
Większość wykonywanych poleceń nie posiada poprzedzających definicji
zmiennej środowiskowej. Dla przykładu powyższego, alternatywnym przykłądem 
jest:
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
Jak pewnie zdążyłeś zauważyć, na dane wyjściowe polecenia oddziaływuje
zmienna środowiskowa w taki sposób, by otrzymać je po francusku. Jeśli
chcesz aby zmienna środowiskowa była dziedziczona przez podprocesy (na
przykład podczas działania skryptu powłoki), musisz "wyeksportować" tę
zmienną w taki oto sposób:
<example>
$ export LC_ALL
</example>

<sect1 id="cmd-path">Ścieżka przeszukiwań poleceń
<p>
<!-- new content -->
Kiedy wpisujesz polecenie w powłoce, wyszukuje ona odpowiedniego programu
zaglądając do katalogów, które umieszczone są w zmiennej środowiskowej 
<tt>PATH</tt>. Wartość zmiennej środowiskowej <tt>PATH</tt> zwana jest również
ścieżką przeszukiwań powłoki.
<p>
W domyślnej instalacji systemu &debian;, zmienna środowiskowa <tt>PATH</tt>
konta użytkownika może nie zawierać ścieżki <file>/sbin</file>. Więc, jeśli
chcesz uruchamiać takie polecenia jak  <prgn>ifconfig</prgn> z katalogu
<file>/sbin</file>, musisz zmienić zmienną środowiskową <tt>PATH</tt> 
tak by zawierała tę ścieżkę. Zmienna środowiskowa <tt>PATH</tt> jest zazwyczaj
inicjalizowana przez plik <file>~/.bash_profile</file>, przeczytaj 
<ref id="bashconf">.

<sect1 id="cmd-opt">Opcje linii poleceń
<p>
<!-- new content -->
Niektóre polecenia przyjmują argumenty. Te zaczynające się od <tt>-</tt> oraz
od <tt>--</tt> zwane są opcjami i kontrolują one zachowanie się polecenia.
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
Tutaj, argument linii poleceń <tt>-R</tt> zmienia zachowanie polecenia 
<prgn>date</prgn> tak, by wyjściowiy ciąg znaków zgodny był z dokumentem 
RFC-2822.

<sect1 id="cmd-wild">Wzorce powłoki
<p>
<!-- new content -->
Bardzo często zdarza się, że potrzebujemy by polecenie działało z grupą
plików, a nie chcemy podawać ich wszystkich ręcznie. Dopełnianie nazw
plików przez <strong>wzorce powłoki</strong> jest do tego celu w 
zupełności wystarczające.
<list compact>
<item><tt>*</tt>
<list compact>
<item>Zastępuje grupę złożoną z zera lub więcej znaków.
<item>Wyjątkiem od tej reguły są pliki zaczynające się od "<tt>.</tt>".
</list>
<item><tt>?</tt>
<list compact>
<item>Zastępuje dokładnie jeden znak.
</list>
<item><tt>[...]</tt>
<list compact>
<item>Zastępuje dokładnie jeden znak z grupy znajdującej się w nawiasach kwadratowych.
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>Zastępuje dokładnie jeden znak z grupy znaków od <tt>a</tt> do <tt>z</tt>.
</list>
<item><tt>[^...]</tt>
<list compact>
<item>Zastępuje dokładnie jeden znak inny niż te znajdujące się w nawiasach
(za wyjątkiem "^").
</list>
</list>
<p>
Dla przykładu, wykonaj poniższe przykłady i przemyśl wyniki jakie dają:
<example>
$ mkdir junk; cd junk; $ touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rmdir junk
</example>

<sect1 id="cmd-return">Wartość zwracana przez polecenia
<p>
Każde polecenie kończąc swoje wykonywanie zwraca wartość zwaną statusem 
zakończenia.
<list compact>
<item>zwracana wartość = 0 jeśli zakończyło się pomyślnie.
<item>zwracana wartość = różna od zera, jeśli polecenie zakończyło się z błędem.
</list>
Wartość zwrócona przez polecenie jest dostępna zaraz po wykonaniu polecenia
w zmiennej środowiskowej <tt>$?</tt>.
<p>
Zauważ, że jeśli status zakończenia używany jest w kontekście logicznym
powłoki, <strong>powodzenie</strong> jest traktowane jako logiczna 
<strong>PRAWDA</strong>. Jest to czasem mylące gdyż <strong>powodzenie</strong>
dotyczy wartości <strong>zero</strong>.
<p>
Przeczytaj <ref id="shell-cond">.

<sect1 id="cmd-typical">Właściwa sekwencja poleceń
<p>
<!-- new content in this whole sect1 ind sect2s -->
Spróbuj zapamiętać następujące idiomy poleceń. Zajrzyj do 
<ref id="shell-param">, <ref id="shell-redirect">,
<ref id="shell-cond">, oraz <ref id="clprocess"> po przeczytaniu 
tychże idiomów.

<sect2 id="cmd-back"><tt>polecenie &amp;</tt>
<p>
<prgn>Polecenie</prgn> zostanie wykonane w <strong>tle</strong>. Zadania
w tle pozwalają użytkownikowi uruchamiać wiele programów w pojedynczej powłoce.
<p>
Zarządzanie procesami znajdującymi się w tle dokonywane jest przy pomocy
poleceń wbudowanych powłoki:
<prgn>jobs</prgn>, <prgn>fg</prgn>, <prgn>bg</prgn> i
<prgn>stop</prgn>. Przeczytaj części "SIGNALS", "JOB CONTROL" i "SHELL
BUILTIN COMMAND" w podręczniku systemowym  
<manref name="bash" section="1">.
<footnote>
System &debian; jest systemem wielozadaniowym.
</footnote>

<sect2 id="cmd-pipe"><tt>polecenie1 | polecenie2</tt>
<p>
Tutaj, na standardowe wejście <prgn>polecenia2</prgn> zostaje przekierowane
standardowe wyjście <prgn>polecenia1</prgn>. Oba polecenia mogą działać
<strong>równolegle</strong>. Zwane jest to <strong>potokiem</strong>.

<sect2 id="cmd-list"><tt>polecenie1 ; polecenie2</tt>
<p>
Tutaj, <prgn>polecenie1</prgn> oraz <prgn>polecenie2</prgn> wykonywane są
<strong>sekwencyjnie</strong>.

<sect2 id="cmd-and"><tt>polecenie1 &amp;&amp; polecenie2</tt>
<p>
Wykonywane jest <prgn>polecenie1</prgn>. Jeśli zakończy się pomyślnie
to wykonywane jest <prgn>polecenie2</prgn>. Wykonywanie poleceń ma tu charakter
<strong>sekwencyjny</strong>. Na końcu zwracany jest status pomyślnego
zakończenia, jeśli oba: <prgn>polecenie1</prgn> <strong>i</strong>
<prgn>polecenie2</prgn> zakończyły się pomyślnie.

<sect2 id="cmd-or"><tt>polecenie1 || polecenie2</tt>
<p>
Wykonywane jest <prgn>polecenie1</prgn>. Jeśli nie wykona się ono pomyślnie,
wykonywane jest <prgn>polecenie2</prgn>. Tu także charakter wykonywania poleceń 
jest <strong>sekwencyjny</strong>. Status zakończenia jest zwracany pomyślny
jeśli <prgn>polecenie1</prgn> <strong>lub</strong> <prgn>polecenie2</prgn> 
zakończyło się pomyślnie.

<sect2 id="cmd-stdout"><tt>polecenie &gt; <var>foo</var></tt>
<p>
Przekierowuje standardowe wyjście z <prgn>polecenia</prgn> do pliku
<tt><var>foo</var></tt>. (powoduje nadpisanie pliku)

<sect2 id="cmd-stdout2"><tt>polecenie &gt;&gt; <var>foo</var></tt>
<p>
Przekierowuje standardowe wyjście <prgn>polecenia</prgn> do pliku
<tt><var>foo</var></tt>. (powoduje dopisanie do pliku)

<sect2 id="cmd-stderr"><tt>polecenie &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
Przekierowuje standardowe wyjście oraz wyjście błędów <prgn>polecenia</prgn>
do pliku <tt><var>foo</var></tt>.

<sect2 id="cmd-stdin"><tt>polecenie &lt; <var>foo</var></tt>
<p>
Przekierowuje standardowe wejście <prgn>polecenia</prgn> do pliku
<tt><var>foo</var></tt>.  Sprawdź:
<example>
$ &lt;/etc/motd pager
 ... (the greetings)
$ pager &lt;/etc/motd
 ... (the greetings)
$ pager /etc/motd
 ... (the greetings)
$ cat /etc/motd | pager
 ... (the greetings)
</example>
Pomimo, że wszystkie powyższe składnie robią dokładnie to samo, ostatni
przykład uruchamia dodatkowe polecenie <prgn>cat</prgn> i przez to marnuje
zasoby systemowe bez powodu.

<sect1 id="cmd-alias">Aliasy poleceń
<p>
<!-- new content -->
Możesz ustawić sobie alias do często wykonywanych poleceń. Na przykład:
<example>
$ alias la='ls -la'
</example>
Teraz, <prgn>la</prgn> działa jak <tt>ls -la</tt> lecz zapisywane jest krócej.
Polecenie to powoduje wylistowanie wszystkich plików w katalogu w długim (szczegółowym) formacie.
<p>
Możesz określić dokładną ścieżkę lub zidentifikować polecenie używając 
<prgn>type</prgn>. Przykładowo:
<example>
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
</example>
W powyższym powłoka ostatnio poszukiwała <prgn>ls</prgn> podczas gdy nie
robiła tego w przypadku <prgn>file</prgn>, stąd wniosek, że powłoka posiada
wewnętrzny bufor w którym przetrzymywana jest lokalizacja najczęściej
używanych poleceń (<prgn>ls</prgn>).

<sect id="text-process">Uniksopodobne przetwarzanie tekstów
<p>
Istnieje kilka standardowych narzędzi do przetwarzania tekstów, które są bardzo
często używane w systemach uniksopodobnych.
<list compact>
<item>Bez użycia wyrażenia regularnego :
<list compact>
<item><prgn>head</prgn> wyświetla poczśtek pliku.
<item><prgn>tail</prgn> wyświetla końcowa część pliku.
<item><prgn>sort</prgn> sortuje linie pliku tekstowego.
<item><prgn>uniq</prgn> usuwa zduplikowane linie z posortowanego pliku.
<item><prgn>tr</prgn> zamienia lub kasuje znaki.
<item><prgn>diff</prgn> porównuje pliki linia po linii.
</list>
<item>Z użyciem podstawowych wyrażeń regularnych (BRE):
<list compact>
<item><prgn>grep</prgn> dopasowuje tekst do wzorca.
<item><prgn>ed</prgn> jest prymitywnym edytorem linii poleceń.
<item><prgn>sed</prgn> jest edytorem strumieni.
<item><prgn>vi</prgn> jest edytorem ekranowym.
<item><prgn>emacs</prgn> jest edytorem ekranowym.
</list>
<item>Z użyciem rozszerzonych wyrażeń regularnych (ERE):
<list compact>
<item><prgn>egrep</prgn> dopasowuje tekst do wzorca.
<item><prgn>awk</prgn> narzędzie do prostego przetwarzania tekstów.
 Zajrzyj do <ref id="awk">.
<item><prgn>perl</prgn> potężne narzędzie do przetwarzania tekstów.
 Zajrzyj do <ref id="perl">.
</list>
</list>
Zajrzyj do<ref id="perl-i">, <ref id="scrp-snip">, oraz <ref id="perl-mad">
Po kilka przykładowych skryptów.

<sect1 id="regex">Wyrażenia regularne
<p>
Wyrażenia regularne używane są w wielu narzędziach do przetwarzania tekstu. 
Są one analogią do wzorców powłoki (patrz <ref id="cmd-wild">) lecz są
zarówno bardziej skomplikowane jak i dają o wiele większe możliwości.
<p>
Wyrażenie regularne opisuje pasujący wzorzec i jest zbudowane ze znaków
tekstowych oraz <strong>metaznaków</strong>. Metaznak jest znakiem ale
traktowanym w specjalny sposób. Dwa główne style, BRE oraz ERE, zależne
od używanych narzędzi, opisane są w <ref id="text-process">.
<p>
W stylu ERE, <strong>metaznaki</strong> zawierają "<tt> \ . [ ] ^
&dollar; * + ? ( ) { } | </tt>". Wyrażenie regularne oznacza:
<list compact>
<item><tt>c</tt>
<list compact>
<item>Dopasowuje nie-metaznaki "<tt>c</tt>".
</list>
<item><tt>\c</tt>
<list compact>
<item>Dopasowuje znaki liter "<tt>c</tt>".
</list>
<item><tt>.</tt>
<list compact>
<item>Zastępuje każdy znak włączając w to znak nowej linii.
</list>
<item><tt>^</tt>
<list compact>
<item>Zastępuje "początek" ciągu znaków.
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>Zastępuje "koniec" ciągu znaków.
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>Zastępuje "początek" słowa.
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>Zastępuje "koniec" słowa.
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>Ta lista zastępuje każdy ze znaków "<tt>abc...</tt>".
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>Ta zanegowana lista zastępuje każdy ze znaków inny niż "<tt>abc...</tt>".
</list>
<item><tt>r*</tt>
<list compact>
<item>Zastępuje zero lub więcej wyrażeń regularnych identyfikowanych przez 
 "<tt>r</tt>".
</list>
<item><tt>r+</tt>
<list compact>
<item>Zastępuje jeden lub więcej wyrażeń regularnych identyfikowanych przez
 "<tt>r</tt>".
</list>
<item><tt>r?</tt>
<list compact>
<item>Zastępuje zero lub jedno wyrażenie regularne identyfikowane przez
"<tt>r</tt>".
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>Zastępuje jedno wyrażenie regularne identyfikowane przez
 "<tt>r1</tt>" lub "<tt>r2</tt>".
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>Zastępuje jedno z wyrażeń regularnych identyfikowaych przez
 "<tt>r1</tt>" lub "<tt>r2</tt>" i traktuje je jako wyrażenie regularne
 objęte <strong>nawiasami kwadratowymi</strong>.
</list>
</list>
<p>
W stylu BRE <strong>metaznaki</strong> "<tt> + ? ( ) { } | </tt>"
tracą swoje specjalne znaczenie; w zamian należy poprzedzić je znakiem
backslash "<tt>\+ \? \( \) \{ \} \| </tt>".  
Więc konstrukcja grupująca <tt>(r1|r2)</tt> musi być zapisana jako 
<tt>\(r1|r2\)</tt> w BRE.
<prgn>Emacs</prgn>, wykorzystujący głównie BRE, traktuje "<tt> + ?
-</tt>" jako <strong>metaznaki</strong>. Z tego powodu nie ma potrzeby ich
poprzedzania. Sprawdź rozdział <ref id="replaceex"> by dowiedzieć się jak
została użyta konstrukcja grupująca.
<p>
Dla przykładu, <prgn>grep</prgn> może zostać użyty do przeszukiwania tekstu
z użyciem wyrażeń regularnych:
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
                    GNU GENERAL PUBLIC LICENSE
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>

<sect1 id="replaceex">Wyrażenia zastępujące
<p>
W wyrażeniach zastępujących następujące znaki mają specjalne znaczenie:
<list>
<item><tt>&amp;</tt>
<list compact>
<item>Reprezentuje dopasowanie wyrażenia regularnego.
(w programie <prgn>emacs</prgn> używaj <tt>\&amp;</tt>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>Reprezentuje <var>n</var>-te dopasowanie wyrażenia regularnego
(<strong>ujętego w nawias</strong>).
</list>
</list>
W Perlu dla ciągu zastępującego używany jest <tt>&dollar;<var>n</var></tt> 
zamiast <tt>\<var>n</var></tt>, a także <tt>&amp;</tt> nie ma specjalnego
znaczenia.
<p>
Przykładowo:
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
Zwróć tutaj szczególną uwagę na styl wyrażenia regularnego objętego
<strong>nawiasami kwadratowymi</strong> i w jaki sposób ciągi znaków pasujące
do wzorca w procesie zastępowania ich wystąpień w tekście, przez różne
narzędzia.
<p>
Te wyrażenia regularne mogą być takżę użyte do poruszania kursorem oraz do
zastępowania tekstu w edytorach.
<p>
Przeczytaj prosze wszystkie związane z tym strony podręcznika systemowego,
by lepiej zapoznać się z tymi poleceniami.

<sect id="unixfile">Uniksopodobny system plików
<p>
<!--
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
W GNU/Linux oraz innych uniksopodobnych systemach operacyjnych
<strong>pliki</strong> zorganizowane są w <strong>katalogi</strong>.
<footnote>
W niektórych systemach <strong>katalogi</strong> zwane są 
<strong>folderami</strong>.
</footnote>
Wszystkie <strong>pliki</strong> i <strong>katalogi</strong> są zgrupowane
w jednym wielkim drzewie, hierarchii plików, której korzeniem (root) jest 
<file>/</file>.
<p>
Te pliki i katalogi mogą być rozmieszczone na wielu urządzeniach. Polecenie 
<manref name="mount" section="8"> pozwala dołączyć pewne systemy plików z 
podłączonych urządzeń do tego wielkiego drzewa plików. Odwrotnynm z kolei
działaniem zajmuje się polecenie <manref name="unmount" section="8">, które
pozwala z powrotem odłączyć dany system plików.

<sect1 id="file-basics">Podstawy uniksowego systemu plików
<p>
<!-- new content -->
Oto podstawy:
<list compact>
<item>Wielkość liter w nazwach plików ma znaczenie. To znaczy, że 
<file>MOJPLIK</file> oraz <file>MOjPlik</file> są <strong>całkiem</strong>
innymi plikami.
<item>Katalog główny zwany jest krótko <file>/</file>. Nie myl jednak
katalogu głównego (root) z użytkownikiem "root" . Zobacz 
<ref id="login-root">.
<item>Każdy katalog ma swoją nazwę, która może zawierać wszystkie litery i 
i symbole <strong>za wyjątkiem</strong> <file>/</file>.
<footnote>
Mimo tego, że <strong>możesz</strong> używać prawie wszystkich liter i symboli
w nazwie pliku, w praktyce jest to zły pomysł. Lepiej unikać wszelkich znaków,
które często mają specjalne znaczenie w linii poleceń, włączając w to spacje,
znak tabulacji, znak nowej linii oraz inne: 
<tt>{ } ( ) [ ] ' ` " \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> .
<p>
Jeśli potrzebujesz rozdzielić słowa w nazwie pliku, dobrym wyborem jest użycie
kropki, myślnika lub znaku podkreślenia. Możesz także napisać każde słowo z
dużej litery.
<tt>NaPrzykładTak</tt>.
</footnote>
Katalog główny (root) jest wyjątkiem; jego nazwa to <file>/</file>
(wymawiane "slesz" lub "katalog główny") i nie może ona zostać
zmieniona.
<item>Każdy plik lub katalog oznaczony jest poprzez <strong>w pełni
określającą nazwę pliku</strong>, <strong>absolutną nazwę pliku</strong>
lub <strong>ścieżkę</strong>, podając sekwencję katalogów, przez które
należy przejść by dotrzeć do pliku. Te trzy terminy są synonimami.
Wszystkie absolutne nazwy plików rozpoczynają się od katalogu <file>/</file> 
i pomiędzy każdym katalogiem lub nazwą pliku znajduje się 
<file>/</file>. Pierwszy <file>/</file> jest nazwą katalogu, ale kolejne są
po prostu separatorami by rozróżnić części nazwy pliku.
<p>
Słowa tutaj używane mogą być mylące. Weżmy następujący przykłąd:
<example>
/usr/share/keytables/us.map.gz
</example>
To jest w pełni określająca nazwa pliku; niektórzy nazywają ją 
<strong>ścieżką</strong>. Ludzie czasem nazywają nazwą pliku samo 
<file>us.map.gz</file>.
<footnote>
Słowo <strong>ścieżka</strong> jest również używane w całkiem innym znaczeniu.
Patrz <ref id="cmd-path">. Odpowiednie znaczenie jest przeważnie zawarte w 
kontekście wypowiedzi.
</footnote>
<item>Katalog główny (root) ma kilka gałęzi, takich jak <file>/etc</file>
ii <file>/usr</file>. Te podkatalogi także posiadają swoje gałęzie 
(podkatalogi), na przykład <file>/etc/init.d</file> i <file>/usr/local</file>. 
Cała ta struktura zwana jest <strong>drzewem katalogów</strong>.
<p>
Możesz myśleć o w pełni określającej nazwie pliku jak o drodze od podstawy 
drzewa
(<file>/</file>), aż do konkretnej gałęzi (pliku). Nie raz też usłyszysz
jak inni mówią o drzewie katalogów jakby to było drzewo 
<strong>rodzinne</strong>, gdzie podkatalogi mają swoich 
<strong>rodziców</strong>, a ścieżka to dokładne pochodzenie pliku.
<p>
Istnieją także ścieżki względne, które rozpoczynają się całkiem gdzie indziej
niż katalog główny (root). Powinieneś zapamiętać, że <file>../</file> odnosi
się do katalogu nadrzędnego. 

<item>Nie ma tutaj katalogu, który odnosiłby się do fizycznego urządzenia
takiego jak dysk twardy. Jest to zasadnicza różnica w kontekście takich
systemó jak CP/M, DOS oraz Windows, gdzie wszystkie ścieżki rozpoczynają się
od nazwy urządzenia; na przykład <tt>C:\</tt>. Patrz <ref id="file-system">.
</list>

<p>
Najlepsze rady dotyczące hierarchii plików zebrane sostały pod adresem
<url id="&f-fhs;" name="Filesystem Hierarchy Standard">. Jako początkujący
powinieneć pamiętać następujące fakty:
<list compact>
<item><file>/</file>
<list compact>
<item>Znak <file>/</file> reprezentuje katalog główny (root).
<p>
</list>
<item><file>/etc</file>
<list compact>
<item>To miejsce gdzie przechowywane są pliki konfiguracyjne systemu.
</list>
<item><file>/var/log</file>
<list compact>
<item>To miejsce przechowywania logów systemowych.
</list>
<item><file>/home</file>
<list compact>
<item>To katalog zawierający katalogi domowe zwykłych użytkowników.
</list>
</list>

<sect1 id="file-system">Koncepcja systemu plików w systemie &debian;
<p>
<!-- old content modified with fs.h reference -->
Zgodnie z tradycją uniksową, system &debian; udostępnia system plików, w którym
fizyczne dane na dyskach twardych i innych nośnikach, oraz interakcja pomiędzy
sprzętem takim jak ekran konsoli i zdalnymi konsolami szeregowymi, zostały 
ujednolicone.
<p>
Każdy plik, katalog, nazwany potok lub urządzenie fizyczne w systemie &debian;
posiada strukturę danych zwaną <strong>węzłem</strong>, która opisuje związane
z nim atrybuty takie jak: właściciel, grupa do której należy, ostatni czas
dostępu, itd. Dokładna definicja <tt>struktury iwęzła</tt> w systemie
&debian; GNU/Linux znajduje się w <url id="&f-inode-def;">.
<p>
Ta ujednolicona reprezentacja jednostek fizycznych to potężne narzędzie,
gdyż pozwala na stosowanie tych samych poleceń do tych samych operacji
na całkowicie różnych od siebie urządzeniach.
<p>
Wszystkie Twoje pliki mogą znajdować się na jednym dysku --- lub możesz mieć
20 dysków, niektóre z nich podłączone do innych komputerów gdzieś w sieci.
Nie będziesz mógł tego rozpoznać po samym wyglądzie drzewa katalogów, a niemal
wszystkie polecenia działają tak samo i bez znaczenia jest na jakim urządzeniu
fizycznym tak na prawdę, znajdują się Twoje pliki.

<sect1 id="file-perm">Prawa dostępu do plików i katalogów
<p>
<!-- old content -->
Prawa dostępu do plików i katalogów są definiowane oddzielnie dla
następujących trzech kategorii użytkowników, których dotyczą:
<list compact>
<item><strong>Właściciel</strong> pliku (u), 
<item>inni użytkownicy w <strong>grupie</strong>, do której należy plik (g),
oraz dla <item>wszystkich <strong>pozostałych</strong> użytkowników (o).
</list>
<p>
Dla pliku każde prawo pozwala odpowiednio na:
<list compact>
<item><strong>odczyt</strong> (r): odczyt zawartości pliku,
<item><strong>zapis</strong> (w): modyfikację zawartości pliku, oraz
<item><strong>wykonanie</strong> (x): uruchomienie pliku jako polecenia.
</list>
<p>
Dla katalogu każde prawo pozwala odpowiednio na:
<list compact>
<item><strong>odczyt</strong> (r): wyświetlenie zawartości katalogu,
<item><strong>zapis</strong> (w): dodawanie i usuwanie plików w katalogu, oraz
<item><strong>wykonanie</strong> (x): dostęp do plików w katalogu.
</list>
Tutaj prawo <strong>wykonania</strong> dla katalogu oznacza nie tylko prawo do
odczytu plików w nim zawartych, ale także na przeglądanie atrybutów takich jak
rozmiar i czas modyfikacji.
<p>
Aby otrzymać informacje o uprawnieniach (oraz inne) plików i katalogów,
używa się polecenia <prgn>ls</prgn>. Zobacz <manref name="ls" section="1">.  
Gdy <prgn>ls</prgn> jest wywołane z parametrem <tt>-l</tt>, wyświetla
następujące informacje w następującej kolejności:
<list compact>
<item><strong>Typ pliku</strong> (pierwsza litera)
 <list compact>
 <item><tt>-</tt>: zwykły plik
 <item><tt>d:</tt> katalog
 <item><tt>l:</tt> dowiązanie symboliczne (symlink)
 <item><tt>c:</tt> urządzenie znakowe
 <item><tt>b:</tt> urządzenie blokowe
 <item><tt>p:</tt> nazwany potok
 <item><tt>s:</tt> gniazdo
 </list>
<item><strong>prawa</strong> dostępu do pliku (kolejnych dziewięć znaków,
po trzy kolejno dla: właściciela, grupy, oraz pozostałych)
<item><strong>liczba dowiązań</strong> (hardlink) do pliku
<item>nazwa <strong>użytkownika</strong> będącego właścicielem pliku
<item>nazwa <strong>grupy</strong>, do której należy plik
<item><strong>rozmiar</strong> pliku w znakach (bajtach)
<item><strong>data i czas</strong> modyfikacji pliku (mtime)
<item><strong>nazwa</strong> pliku.
</list>
<p>

Aby zmienić właściciela pliku, używa się z konta root polecenia 
<prgn>chown</prgn>. Aby zmienić grupę pliku, używa się polecenia 
<prgn>chgrp</prgn> z konta właściciela pliku lub konta root. 
Aby zmienić prawa dostępu do plików czy katalogów, używa się polecenia 
<prgn>chmod</prgn>, także z konta użytkownika lub konta root.
Podstawowa składnia pozwalająca na manipulowanie plikiem <file>foo</file> to:
<example>
# chown <var>nowy_wlasciciel</var> foo
# chgrp <var>nowa_grupa</var> foo
# chmod  [ugoa][+-=][rwx][,...] foo
</example>
Zobacz <manref name="chown" section="1">,
<manref name="chgrp" section="1">, oraz
<manref name="chmod" section="1"> po więcej szczegółów.
<p>
Na przykład w celu uczynienia użytkownika <var>foo</var> właścicielem drzewa
katalogów, a grupy <var>bar</var> współwłaścicielem, wykonaj następujące
polecenia z konta root:
<example>
# cd /some/location/
# chown -R <var>foo</var>:<var>bar</var>
# chmod -R ug+rwX,o=rX 
</example>
<p>
Istnieją jeszcze trzy specjalne bity uprawnień:
<list compact>
<item><strong>ustawia ID użytkownika</strong> (s lub S zamiast x użytkownika), 
<item><strong>ustawia ID grupy</strong> (s lub S zamiast x grupy), oraz
<item><strong>bit lepkości</strong> (sticky bit) (t lub T zamiast x 
pozostałych).
</list>
Na wyjściu polecenia <prgn>ls -l</prgn> dużymi literami oznaczane są bity,
na których miejscu bit wykonywalności nie był ustawiony.
<p>
Ustawienie <strong>ID użytkownika</strong> dla pliku wykonywalnego
pozwala użytkownikowi na wykonanie tego pliku z ID właściciela pliku 
(na przykład <strong>root</strong>). Podobnie, ustawienie
<strong>ID grupy</strong> dla pliku wykonywalnego, pozwala użytkownikowi
na wykonanie pliku z ID grupy pliku (na przykład <strong>root</strong>). 
Ponieważ może to powodować ryzyko naruszenia bezpieczeństwa, włączanie tych 
opcji wymaga szczególnej ostrożności.
<p>
Ustawienie <strong>ID grupy</strong> dla katalogu uaktywnia schemat 
tworzenia plików w stylu BSD, w którym wszystkie pliki tworzone w tym katalogu
należą do <strong>grupy</strong>, mającej do niego uprawnienia.
<p>
Ustawienie <strong>bitu lepkości</strong> dla katalogu zapobiega usuwaniu z 
niego plików przez użytkowników, którzy nie są właścicielami tych pliku.
W celu zabezpieczenia zawartości pliku w katalogach zapisywalnych, takich jak
<file>/tmp</file> czy w katalogach, w których prawo zapisu ma grupa, potrzeba
nie tylko, by było wyłączone prawo <strong>zapisu</strong> dla pliku, ale także
należy ustawić <strong>sticky bit</strong> dla katalogu. W innym przypadku plik
może zostać usunięty, a następnie w jego miejsce może zostać utworzony nowy
plik, o takiej samej nazwie przez dowolnego użytkownika, który ma prawo zapisu
do tego katalogu.
<p>
Poniżej kilka interesujących przykładów praw do pliku.
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
Istnieje alternatywna metoda numeryczna do opisu praw pliku w
<manref name="chmod" section="1"> poleceniach. Metoda ta używa trzech lub
czterech cyfr o znaczeniu ósemkowym. Oznaczają one odpowiednio:
<list compact>
<item>1-sza cyfra opcjonalna: suma opcji
<strong>ustawione ID użytkownika</strong> (=4),
<strong>ustawione ID grupy</strong> (=2), oraz 
<strong>bit lepkości</strong> (=1)
<item>2-ga cyfra: suma praw
<strong>odczytu</strong> (=4), <strong>zapisu</strong> (=2), oraz
<strong>wykonywania</strong> (=1)
dla <strong>użytkownika</strong>
<item>3-cia cyfra: to samo ale dla <strong>grupy</strong>
<item>4-ta cyfra: to samo ale dla <strong>innych</strong>
</list>
<p>
Brzmi to dość skomplikowanie ale jest całkiem proste. Jeśli spojrzysz na
pierwsze kilka kolumn (2-10) będących wynikiem polecenia <tt>ls -l</tt>
i odczytasz ich znaczenie binarnie (podstawa=2) reprezentację praw do pliku
(gdzie "-" to "0" a "rwx" to "1"), wartość takiego wyrażenia numerycznego
powinna mieć dla Ciebie poprawny sens jako reprezentacja ósemkowa (podstawa=8) 
praw dostępu do pliku.
<footnote>
Oczywiśce metoda ta sprawdza się tylko w przypadku 3 cyfr.
</footnote>
Spójrz na ten przykład:
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
Domyślna maska praw dostępu do pliku ustawiana jest przy użyciu wbudowanego 
polecenia powłoki <prgn>umask</prgn>. Zobacz 
<manref name="builtins" section="7">.
</sect1>

<sect1 id="timestamp">Znaczniki czasu
<p>
<!-- old content, minor edit -->
Dla plików GNU/Linux istnieją trzy typy znaczników czasu:
<list compact>
<item><strong>mtime</strong>: czas modyfikacji (<tt>ls -l</tt>),
<item><strong>ctime</strong>: czas zmiany statusu (<tt>ls -lc</tt>), oraz
<item><strong>atime</strong>: czas ostatniego dostępu (<tt>ls -lu</tt>).
</list>
Zauważ, że <strong>ctime</strong> nie jest czasem utworzenia pliku.  
<list compact>
<item>Nadpisanie pliku zmieni wszystkie <strong>mtime</strong>,
  <strong>ctime</strong> i <strong>atime</strong> pliku.
<item>Zmiana praw lub właściciela pliku zmieni <strong>ctime</strong> oraz
<strong>atime</strong> pliku.
<item>Odczyt pliku zmieni jego <strong>atime</strong>.
</list>
Zauważ, że nawet zwykły odczyt z pliku w systemie &debian; powoduje normalnie
operację zapisu w celu aktualizacji informacji <strong>atime</strong>
w <strong>inode</strong>.
Montowanie systemu plików z opcją <tt>noatime</tt> pozwoli systemowi na
ominięcie tej operacji i zaowocuje szybszym dostępem do pliku przy odczycie.
Zobacz <manref name="mount" section="8">.
<p>
<!-- new content -->
Użyj polecenia <manref name="touch" section="1"> aby zmienić znacznik czasu
istniejącego pliku.
</sect1>

<sect1 id="links">Dowiązania (links)
<p>
<!-- old content -->
Istnieją dwie metody na związanie pliku <var>foo</var> z innym plikiem 
<var>bar</var>.
<list compact>
<item><strong>dowiązanie</strong> (hardlink) jest to inna nazwa dla istniejącego pliku
 (<tt>ln <var>foo</var> <var>bar</var></tt>),
<item><strong>dowiązanie symboliczne</strong> lub „symlink” jest specjalnym
plikiem, który wskazuje na inny poprzez nazwę 
(<tt>ln -s <var>foo</var> <var>bar</var></tt>).
</list>
Spójrz na poniższe przykłady zmian w dowiązaniach, oraz na subtelne
różnice w rezultacie polecenia <prgn>rm</prgn>.
<example>
$ echo "Oryginalna zawartość" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # dowiązanie (hardlink)
$ ln -s <var>foo</var> <var>baz</var>  # dowiązanie symboliczne
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "Nowa zawartość" &gt; <var>foo</var>
$ cat <var>bar</var>
Oryginalna zawartość
$ cat <var>baz</var>
Nowa zawartość
</example>
Dowiązanie symboliczne zawsze ma, jak widać w przykładzie powyżej prawa 
dostępu „rwxrwxrwx”, a jego faktyczne prawa dostępu są takie 
jak wskazywanego pliku.
<p>
Katalog <file>.</file> jest dowiązaniem do katalogu, w którym sam się
pojawia, zatem liczba dowiązań do nowego katalogu rozpoczyna się od 2. 
Katalog <file>..</file> jest dowiązaniem do katalogu nadrzędnego, 
zatem liczba dowiązań do katalogu rośnie wraz z liczbą nowych podkatalogów.

<sect1 id="fifo">Nazwane potoki (FIFOs)
<p>
<!-- DDP Debian Tutorial content -->
<p>
Naznway potok jest plikiem, który działa jak potok. Wrzucasz coś do pliku
i dostajesz coś z niego na zewnątrz. Zwane jest to FIFO, lub 
First-In-First-Out (Pierwsze-Weszlo-Pierwsze-Wyszło): pierwsza rzecz jaką
włożysz do takiego pliku, jest pierwszą rzeczą którą możesz z niego odebrać.
<p>
Jeśli zapisujesz do nazwanego potoku, proces który tego dokonuje, nie zakończy
się dopóki dane, które zostały do niego zapisane, nie zostaną odczytane. 
Jeśli czytasz z nazwanego potoku, proces który dokonuje odczytu czeka z
zakończeniem, dopóki tylko jest coś do odczytania. Nazwany potok ma zawsze
zerową wielkość --- nie przechowuje żadnych danych, po prostu łączy dwa procesy
tak jak <tt>|</tt> w powłoce. Jednakże, to iż taki potok ma swoją nazwę,
powoduje, że dwa procesy nie muszą być w jednej linii poleceń a nawet, 
mogą być uruchamiane przez różnych użytkowników.

<p>
Spróbuj sam wykonując poniższy przykład:
<example>
$ cd; mkfifo mypipe
$ echo "hello" &gt;mypipe &amp; # put into background
[1] <var>5952</var>
$ ls -l mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
$ cat mypipe
hello
[1]+  Done                    echo hello &gt;mypipe
$ ls mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
$ rm mypipe
</example>

<sect1 id="sockets">Gniazda
<p>
<!-- new content -->
Gniazdo jest podobne do nazwanego potoku (FIFO) i pozwala procesom na wymianę
informacji. W przypadku gniazda jednak, procesy nie muszą być uruchomione w
tym samym czasie, a nawet nie nie muszą być procesami potomnymi swoich 
przodków. To jest punkt styku ich komunikacji międzyprocesowej.
Informacje mogą być wymieniane przez sieć pomiędzy dwoma różnymi komputerami.

<sect1 id="device">Pliki urządzeń
<p>
<!-- DDP Debian Tutorial content, modified -->
Plik urządzenia odnosi się do fizycznego lub wirtualnego urządzenia, takiego
jak dysk twardy, karta graficzna, ekran czy klawiatura, w Twoim systemie.
Przykładem urządzenia wirtualnego jest konsola, reprezentowana przez 
<tt>/dev/console</tt>.
<p>
Istnieją dwa typy urządzeń:
<list compact>
<item><strong>urządzenie znakowe</strong>
<list compact>
<item>Dostęp do takiego urządzenia odbywa się znak po znaku, to znaczy, że 
najmniejsza porcja danych jaka może być zapisana lub odczytana z urządzenia
to jeden znak (bajt).
</list>
<item><strong>urządzenie blokowe</strong>
<list compact>
<item>Dostęp do takiego urządzenia następuje poprzez zczytania lub zapisanie
większej ilości danych, zwanych blokami, które zawierają pewną ilość znaków.
Dobrym przykładem jest tutaj Twój dysk twardy.
</list>
</list>
<p>
Możesz odczytywać oraz zapisywać do plików urządzeń, lecz mogą one zawierać
również dane binarne o całkowicie niezrozumiałym zapisie dla człowieka.
Zapisywanie danych do takich plików jest czasami przydatne przy badaniu
problemów tyczących się łączenia sprzętu. Dla przykładu możesz przesłać
plik tekstowy do urządzenia drukarki <file>/dev/lp0</file> lub wysłać 
odpowiednie polecenie modemowe na odpowiedni port szeregowy
<file>/dev/ttyS0</file>. Jednak robiąc to nieostrożnie można spowodować
poważne uszkodzenie, więc postępuj z rozwagą.

<sect2 id="devnull"><file>/dev/null</file> i inne 
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> jest specjalnym plikiem urządzenia, które porzuca
wszystko co do niego wrzucisz. Jeśli czegoś nie potrzebujesz, wrzuć to do 
<file>/dev/null</file>. Jest to taka dziura bez dna. Jeśli spróbujesz coś
przeczytać z <file>/dev/null</file>, dostaniesz natychmiast znak końca pliku.
<p>
<file>/dev/zero</file> działa podobnie, z tym, że próba odczytu zwraca znak
<tt>\0</tt> (to nie to samo zero co "0" w kodzie ASCII).  Patrz 
<ref id="dummyfile">.

<sect2 id="node">Numer węzłowy urządzenia
<p>
<!-- new content -->
Numer węzłowy urządzenia wyświetlany jet jako wynik polecenia <prgn>ls</prgn>:
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
Tutaj,
<list compact>
<item><file>/dev/hda</file> posiada pierwszorzędny numer urządzenia 3 oraz 
pomoniczy numer urządzenia 0. Ustawione jest też prawo odczytu/zapisu dla 
użytkowników należacych do grupy <tt>disk</tt>,
<item><file>/dev/ttyS0</file> posiada pierwszorzędny numer urządzenia 4 oraz
drugorzędny numer urządzenia 64. Prawa odczytu/zapisu ustawione są dla 
użytkowników należących do grupy <tt>dialout</tt> i 
<item><file>/dev/zero</file> posiada pierwszorzędny numer urządzenia 1 oraz
drugorzędny numer urządzenia 5. Prawa odczytu/zapisu ustawione są dla 
wszystkich.
</list>
<p>
W starszych systemach, proces instalacyjny tworzył węzły urządzeń przy użyciu
polecenia <prgn>/sbin/MAKEDEV</prgn>. Patrz <manref name="MAKEDEV" section="8">.
<p>
W systemach nowszych, system plików <file>/dev</file> jest automatycznie
zapełniany przez urządzenie systemu plików podobne do <file>/proc</file>.

<sect1 id="procfs">System plików <file>/proc</file>
<p>
<!-- modified heavily, original from Debian Guide -->
System plików <file>/proc</file> jest tak naprawdę pseudo-systemem plików,
który zawiera informacje o systemie oraz uruchomionych w nim procesach.
<p>
Ludzie często nie wiedzą co robić, gdy zauważają dość duży plik w  
<file>/proc/kcore</file>. Jest to mniej więcej kopia pamięci Twojego 
komputera. Używana jest do diagnozowania jądra. Obecnie ten plik nie 
istnieje, więc nie martw się o jego wielkość. 
<p>
Patrz <ref id="proc-sys"> and <manref name="proc" section="5">.

<sect id="xtuto">System X Window
<p>
<!-- practically new content -->
Patrz <ref id="x">.

<sect1 id="xstart">Uruchamianie systemu X Window
<p>
System X Window może być uruchamiany automatycznie z podobnym do
<prgn>xdm</prgn> graficznym demonem logowania lub poprzez wpisanie w konsoli:
console.
<example>
$ exec startx
</example>

<sect1 id="xmenu">Menu systemu X Window
<p>
Od kiedy środowisko X potrafi pomieścić wiele menedżerów okien, zmienił
się znacząco interfejs użytkownika. Zapamiętaj, że zawsze po naciśnięciu 
prawego guzika myszy w głównym oknie menedżera, ujrzysz rozwijalne menu.
<list compact>
<item>Aby uruchomić powłokę, wybierz z menu program Xterm:
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>Aby przeglądać strony internetowe w trybie graficznym, wybierz Mozillę:
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>Aby przeglądać pliki PDF w trybie graficznym, wybierz Xpdf:
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
Jeśli nie możesz znależć któregoś programu w menu, zainstaluj odpowiednie 
pakiety. Patrz <ref id="apt-install">.

<sect1 id="xkeys">Skróty klawiszowe w systemie X Window
<p>
Poniżej lista ważniejszych sekwencji klawiszy, przydatnych podczas pracy 
w systemie X Window.
<list compact>
<item>Ctrl-Alt-F1 do F6: Przełącza na inne pseudo-terminale (podobnie do 
systemów X window, DOSEMU, itp.)
<item>Alt-F7:               Przełącza z powrotem do systemu X Window
<item>Ctrl-Alt-minus:       Zmienia rozdzielczość w systemie X Window (minus
odnosi się do klawisza na klawiaturze numerycznej)
<item>Ctrl-Alt-plus:        Zmienia rozdzielczość w przeciwną stronę
w systemie X Window (plus odnosi sie do klawisza na klawiaturze numerycznej)
<item>Ctrl-Alt-Backspace:   Kończy działanie X Serwera
<item>Alt-X, Alt-C, Alt-V:  Standardowe kombinacje klawiszy: wycinanie, 
kopiowanie oraz wklejanie działające tak jak w systemach Windows/Mac. W
niektórych programach powyższe kombinacje z klawiszem Alt zostały zastąpione
odpowiednimi kombinacjami z klawiszem Ctrl, na przykłąd w Netscape Composer..
</list>

<sect id="cmd-study">Dalsza nauka
<p>
Na tym etapie wiedzy, polecam Ci zaznajomienie się z kluczowymi książkowymi
przewodnikami ze strony 
<url id="&tldp-guide;" name="The Linux Documentation Project: Guides">:
<list compact>
<item>"The Linux System Administrators' Guide",
<list compact>
<item>Opisuje wszelkie aspekty dotyczące utrzymania systemu na chodzie, 
włączając w to konta użytkownikóa, kopie zapasowe oraz konfigurowanie systemu.
<item>pakiet: <package>&p-sysadmin-guide;</package>
<item>plik: <url id="&f-sysadmin-guide;">
<item>strona: <url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition",
<list compact>
<item>Jest to podręcznik administracji siecią w środowisku Linux.
<item>pakiet: <package>&p-netadmin-guide;</package>
<item>plik: <url id="&f-netadmin-guide;">
<item>strona: <url id="&w-netadmin-guide;">
</list>
 <item>"Linux: Rute User's Tutorial and Exposition"
 <list compact>
  <item>A nice online and hardcover book covering GNU/Linux system 
        administration.
  <item>By Paul Sheer
  <item>Published by Prentice Hall
  <item>Package: <package>&p-rutebook;</package> (from <tt>non-free</tt>)
  <item>File: <file>&f-rutebook;</file>
  <!--
  <item>Web: <url id="&rutehome;">
  -->
 </list>
</list>
<p>
Zobacz <ref id="support"> po więcej materiałów do nauki.

</chapt>

