<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.38"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="vcs">Systemy kontroli wersji

<sect id="cvs">Concurrent Versions System (CVS)

<p>Przeczytaj (np. przeglądarką <prgn>lynx</prgn>) pliki:
<file>/usr/share/doc/cvs/html-cvsclient</file>,
<file>/usr/share/doc/cvs/html-info</file>,
<file>/usr/share/doc/cvsbook</file> lub wykonaj polecenia:
<tt>info cvs</tt> oraz <tt>man cvs</tt> w celu uzyskania
dokładnych informacji.

<sect1 id="cvs-inst">Instalacja serwera CVS
<p>
Poniższe ustawienia pozwalają na wprowadzanie zmian w repozytorium wyłącznie
użytkownikom należącym do grupy „src”, a na administrację CVS wyłącznie
członkowi grupy „staff”, redukując w ten sposób szanse zastrzelenia samego
siebie.
<example>
# cd <var>/var/lib</var>; umask 002 ; mkdir <var>cvs</var> # [Woody] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=<var>/var/lib/cvs</var>
# cd $CVSROOT
# chown root:src .	# „staff” dla większych ograniczeń rozpoczynania projektów
# chmod 3775 .		# Jeśli w powyższym występuje „staff”, użyj 2775
# cvs -d <var>/var/lib/cvs</var> init 	# bezpieczniej jest określić -d tutaj!
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect1>

<sect1 id="cvs-examples">Przykładowe sesje CVS
<p>
Poniżej znajdują się przykłady konfiguracji środowiska powłoki dla dostępu do
repozytoriów CVS.

<sect2>Anonimowy CVS (tylko pobieranie)
<p>
Zdalny dostęp tylko do odczytu:
<example>
$ export CVSROOT=:pserver:<var>anonymous@cvs.sf.net:/cvsroot/qref</var>
$ cvs login
$ cvs -z3 co <var>qref</var>
</example>
</sect2>

<sect2>Użycie lokalnego serwera CVS
<p>
Dostęp lokalny z powłoki na tej samej maszynie:
<example>
$ export CVSROOT=<var>/var/lib/cvs</var>
</example>
</sect2>

<sect2>Użycie odległego pservera CVS
<p>
Zdalny dostęp bez SSH (używając obsługi RSH w <prgn>cvs</prgn>):
<example>
$ export CVSROOT=:pserver:<var>account@cvs.foobar.com:/var/lib/cvs</var>
$ cvs login
</example>
Jest to metoda podatna na podsłuch.
</sect2>

<sect2>Użycie zdalnego CVS przez <prgn>ssh</prgn>
<p>
Zdalny dostęp z SSH:
<example>
$ export CVSROOT=:ext:<var>account@cvs.foobar.com:/var/lib/cvs</var>
</example>
lub dla SourceForge:
<example>
$ export CVSROOT=:ext:<var>account@cvs.sf.net:/cvsroot/qref</var>
</example>
Możesz również użyć uwierzytelnienia RSA (<ref id="ssh-rsa">), które eliminuje
pytanie o hasło.
</sect2>

<sect2>Tworzenie nowego archiwum CVS
<p>
Dla,
<example>
OBIEKT              WARTOŚĆ                          ZNACZENIE
Drzewo źródeł:      ~/<var>project-x</var>           Wszystkie kody źródłowe
Nazwa projektu:     <var>project-x</var>             Nazwa projektu
Źródło modułu:      <var>Main-branch</var>           Nazwa całego modułu (vendortag)
Etykieta wydania:   <var>Release-original</var>      Nazwa wydania (releasetag)
</example>
Wykonaj,
<example>
$ cd ~/<var>project-x</var>                 # przejdź do katalogu ze źródłami
 ... stwórz drzewo źródeł ...
$ cvs import -m <var>"Start project-x" project-x Main-branch Release-original</var>
$ cd ..; rm -R ~/<var>project-x</var>
</example>
</sect2>

<sect2>Praca z CVS
<p>
Praca nad projektem <var>project-x</var> przy użyciu lokalnego repozytorium:
<example>
$ cd                            # przejście do przestrzeni roboczej
$ cvs co <var>project-x</var>              # pobranie źródeł z CVS-u
$ cd <var>project-x</var>
 ... wprowadzanie zmian w zawartości ...
$ cvs diff -u                   # podobne do diff -u repozytorium/ lokalne/
$ cvs up -C <var>modyfikowany_plik</var>   # cofnięcie zmian w pliku
$ cvs ci -m "<var>Opisz zmiany</var>"      # wysłanie modyfikacji do CVS
$ vi <var>nowy_plik</var>
$ cvs add <var>nowy_plik</var>
$ cvs ci -m "<var>Dodano nowy_plik</var>"
$ cvs up                        # pobranie najnowszych wersji z CVS
 ... by utworzyć wszystkie nowoutworzone katalogi w CVS użyj
 ... "cvs up -d -P" w zastępstwie.
 ... uważaj na linie zaczynające się od „C <var>nazwa_pliku</var>”
 ... kod niezmodyfikowany przeniesiony jest do `.#<var>nazwa_pliku</var>.wersja'.
 ... szukaj "&lt;&lt;&lt;&lt;&lt;&lt;&lt;" i "&gt;&gt;&gt;&gt;&gt;&gt;&gt;" w <var>nazwa_pliku</var>.
$ cvs tag <var>Release-1</var>             # dodaj symboliczną nazwę wydania
 ... edytuj dalej ...
$ cvs tag -d <var>Release-1</var>          # usuń nazwę wydania
$ cvs ci -m "<var>następne komentarze</var>"
$ cvs tag <var>Release-1</var>             # ponownie dodaj nazwę wydania
$ cd                            # wróć do przestrzeni roboczej
$ cvs co -r <var>Release-initial</var> -d <var>old</var> <var>project-x</var>
 ... pobierz wersję oryginalną do katalogu <var>old</var>
$ cd old
$ cvs tag -b <var>Release-initial-bugfixes</var> # stwórz nazwę odgałęzienia (-b)
 ... możesz teraz pracować na starej wersji (Tag=sticky)
$ cvs update -d -P         # nie twórz pustych katalogów
 ... drzewo źródeł ma teraz trwałą (sticky) nazwę „Release-initial-bugfixes”
 ... pracuj na tym odgałęzieniu
$ cvs up -d -P # zsynchronizuj z plikami modyfikowanymi przez innych w tej gałęzi
$ cvs ci -m "<var>check into this branch</var>"
$ cvs update -kk -A -d -P
 ... usuń trwałą nazwę i zapomnij zawartość
 ... aktualizuj z głównego pnia bez rozwijania słów kluczowych
$ cvs update -kk -d -P -j <var>Release-initial-bugfixes</var>
 ... włączenie z odgałęzienia <var>Release-initial-bugfixes</var> do drzewa
 ... głównego.  Napraw konflikty edytorem.
$ cvs ci -m "<var>włączono Release-initial-bugfixes</var>"
$ cd
$ tar -cvzf <var>old-project-x.tar.gz</var> <var>old</var>     # stwórz archiwum, -j dla bz2
$ cvs release -d <var>old</var>               # usuń lokalne źródła (opcjonalne)
</example>
Miłe opcje do zapamiętania (używaj jako pierwszych opcji dla <prgn>cvs</prgn>):
<example>
-n      pusty przebieg, żadnych efektów
-t      wyświetl komunikaty pokazujące etapy pracy cvs
</example>
</sect2>

<sect2>Eksport plików z CVS
<p>
Aby pobrać najnowszą wersję z CVS użyj „tomorrow”:
<example>
$ cvs ex -D tomorrow <var>nazwa_modułu</var>
</example>
</sect2>

<sect2>Zarządzanie CVS
<p>
Dodaj alias dla projektu (serwer lokalny):
<example>
$ su - admin           # członek grupy staff
$ export CVSROOT=<var>/var/lib/cvs</var>
$ cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "<var>px</var> -a <var>project-x</var>" &gt;&gt;modules
$ cvs ci -m "<var>px jest teraz aliasem project-x</var>"
$ cvs release -d .
$ exit                 # Ctrl-D aby wyjść z su
$ cvs co -d <var>project</var> <var>px</var>
 ... pobierz <var>project-x</var> (alias:<var>px</var>) z CVS to katalogu project
$ cd project
 ... wprowadź zmiany w zawartości ...
</example>0
</sect2>

<sect1 id="cvs-trouble">Rozwiązywanie problemów z CVS

<sect2>Uprawnienia plików w repozytorium
<p>
CVS nie nadpisuje aktualnych plików w repozytorium, tylko zastępuje je innymi.
Z tego powodu, <em>pozwolenie na pisanie do katalogu z repozytorium</em> ma
kluczowe znaczenie. Dla każdego nowego repozytorium, wykonaj następujące czynności
aby zapewnić ten warunek.
<example>
# cd <var>/var/lib/cvs</var>
# chown -R root:src <var>repozytorium</var>
# chmod -R ug+rwX   <var>repozytorium</var>
# chmod    2775     <var>repozytorium</var>  # jeśli potrzebne, w podkatalogu
</example>
</sect2>

<sect2>Bit wykonywalności
<p>
Bit wykonywalności pliku jest zachowany przy pobieraniu z CVS.  Kiedy tylko
zobaczysz problem z prawem do wykonywania w pobranych plikach, zmień uprawnienia
pliku w repozytorium następującym poleceniem.
<example>
# chmod ugo-x <var>nazwa_pliku</var>
</example>
</sect2>

</sect1>

<sect1 id="cvs-short">Polecenia CVS
<p>
Oto polecenia CVS wraz ze skrótami.
<example>
{add|ad|new} [-k kflag] [-m 'komunikat'] pliki...
{admin|adm|rcs} [opcje-rcs] pliki...
{annotate|ann} [opcje] [pliki...]
{checkout|co|get} [opcje] moduły...
{commit|ci|com}   [-lnR]  [-m  'podsumowanie_zmian'  |  -f  file] \
        [-r rewizja] [pliki...]
{diff|di|dif} [-kl] [opcje_rcsdiff] [[-r rev1 | -D data1] \
        [-r rev2 |  -D data2]] [pliki...]
{export|ex|exp} [-flNn] -r rev|-D data [-d katalog] [-k kflag] moduł...
{history|hi|his} [-report] [-flags] [-options args] [pliki...]
{import|im|imp} [-opcje] repozytorium vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] opcje-rlog [pliki...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] moduły...
{release|re|rel} [-d] katalogi...
{remove|rm|delete} [-lR] [pliki...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  tag  |  -D  data] \
         nazwa_symboliczna moduły...
{status|st|stat} [-lR] [-v] [pliki...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r tag | -D data]  [-f] \
         nazwa_symboliczna [pliki...]
{update|up|upd} [-AdflPpR] [-d] [-r tag|-D data] pliki...
</example>
</sect1>

<sect id="svn">Subversion
<p>
Subversion jest systemem kontroli wersji nowej generacji, który tworzony był z
myślą o zastąpieniu CVS.  Według twórców jest on obecnie w stanie „alpha”,
jednak prawdopodobnie jest wystarczająco stabilny dla większości
użytkowników.  W momencie powstawania tego tekstu,
Subversion dostępny jest wyłącznie w <tt>niestabilnej</tt>
gałęzi Debiana.

<sect1 id="svn-inst">Instalacja serwera Subversion
<p>
Meta-pakiet <package>subversion-server</package> jest zależny
od wymaganych do użycia systemu Subversion pakietów
(<package>libapache2-dav-svn</package> oraz
<package>subversion-tools</package>).

<sect2>Tworzenie repozytorium
<p>
Aktualnie, pakiet <package>subversion</package> nie tworzy repozytorium, więc
musi być ono utworzone ręcznie.  Jednym z możliwych miejsc dla repozytorium jest
<file>/var/local/repos</file>.
<p>
Utwórz katalog:
<example>
# mkdir -p /var/local/repos
</example>
Utwórz bazę danych repozytorium:
<example>
# svnadmin create /var/local/repos
</example>
Daj prawo do zapisu w repozytorium serwerowi WWW:
<example>
# chown -R www-data:www-data /var/local/repos
</example>
</sect2>
<sect2>Konfiguracja Apache2
<p>
Aby umożliwić dostęp do repozytorium przez uwierzytelnienie użytkownika, dodaj
(lub usuń komentarz) następujące wpisy do
<file>/etc/apache2/mods-available/dav_svn.conf</file>:
<example>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/local/repos
  AuthType Basic
  AuthName "Repozytorium Subversion"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt/Location&gt
</example>
Następnie stwórz plik z hasłami użytkowników używając polecenia:
<example>
htpasswd2 -c /etc/subversion/passwd jakiś-użytkownik
</example>
Przeładuj Apache2, a Twoje nowe repozytorium Subversion będzie dostępne pod
adresem http://<var>nazwa_hosta</var>/repos.
</sect2>
</sect1>

<sect1 id="svn-cvs">Przenoszenie repozytorium CVS do Subversion
</sect1>
<sect1 id="svn-usage">Przykłady użycia Subversion
<p>
Poniższe części pokazują jak używać różnych poleceń w Subversion.

<sect2>Tworzenie nowego archiwum
<p>
Aby stworzyć nowe archiwum Subversion, napisz poniższe polecenia:
<example>
$ cd ~/<var>twój-projekt</var>         # przejdź do katalogu źródeł
$ svn import http://localhost/repos <var>twój-projekt</var> \
  <var>nazwa-projektu</var> -m "początkowy import projektu"
</example>
<p>
Tworzy to katalog o nazwie <var>nazwa-projektu</var> w Twoim repozytorium.
Katalog ten zawiera pliki Twojego projektu.  Sprawdź pod adresem
http://localhost/repos/ czy się tam znalazł.
</sect2>

<sect2>Praca z Subversion
<p>
Praca z <var>project-y</var> przy użyciu Subversion:
<example>
$ cd                            # przejdź do przestrzeni roboczej
$ svn co http://localhost/repos/<var>project-y</var>  # pobierz źródła
$ cd <var>project-y</var>
 ... wykonaj pracę ...
$ svn diff                      # podobne do diff -u repozytorium/ lokalne/
$ svn revert <var>modyfikowany_plik</var>  # cofnij zmiany w pliku
$ svn ci -m "<var>Opisz zmiany</var>"      # wyślij pliki do repozytorium
$ vi <var>dodany_plik</var>
$ svn add <var>dodany_plik</var>
$ svn add <var>nowy_katalog</var>          # rekursywnie dodaj pliki z nowy_katalog
$ svn add -N <var>new_dir2</var>           # nierekursywnie dodaj nowy katalog
$ svn ci -m "Dodano <var>nowy_plik</var>, <var>nowy_katalog</var>, <var>nowy_katalog2</var>"
$ svn up                        # pobranie najnowszej wersji z repozytorium
$ svn log                       # pokazuje wszystkie wprowadzone zmiany
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>project-y-branch</var> \
      -m "Tworzę własną gałąź <var>project-y</var>"  # rozgałęzienie <var>project-y</var>
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>proj-y_release1.0</var> \
      -m "<var>project-y</var> 1.0 release"    # dodanie tagu release
 ... zauważ, że odgałęzianie i tagowanie są tym samym. Jedyną różnicą jest to,
 ... że gałęzie można uaktualniać, a tagów nie.

 ... wprowadzaj zmiany w gałęzi ...

$ # połącz odgałęzienie z gałęzią główną
$ svn merge http://localhost/repos/<var>project-y</var> \
   http://localhost/repos/<var>project-y-branch</var>
$ svn co -r 4 http://localhost/repos/<var>project-y</var> # pobierz rewizję 4
</example>

</sect2>

</sect1>
</sect>
</chapt>
