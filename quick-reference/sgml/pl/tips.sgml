<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.81"  -->

<chapt id="tips">Debianowe porady


<sect id="booting">Uruchamianie systemu
<p>
Zajrzyj do LDP <url id="&bootprompt-howto;" name="BootPrompt-HOWTO">
w celu uzyskania szczegółowych informacji na temat boot prompt.

<sect1 id="crackroot">„Zapomniałem hasła roota!” (1)
<p> 
Możliwe jest uruchomienie systemu i zalogowanie się na konto
administratora (root) bez znajomości hasła, jeżeli tylko posiadamy
dostęp do lokalnej konsoli (zakładając, że nie zostało założone
hasło na BIOS lub program ładujący system taki jak <prgn>lilo</prgn>).
<p>
Poniżej przedstawiono procedurę postępowania w takim przypadku,
która nie wymaga posiadania dodatkowych narzędzi, jak choćby dyskietek
czy płyt z systemem, ani modyfikacji ustawień BIOSu. Zakładamy, że
„Linux” to etykieta podstawowego jądra systemu w domyślnej instalacji
Debiana.
<p>
Gdy tylko pojawi się ekran startowy <prgn>lilo</prgn> oraz napis
<tt>boot:</tt> (być może musisz przytrzymać klawisz shift podczas
uruchamiania <prgn>lilo</prgn> aby zapobiec automatycznemu startowi
systemu) wpisz:

<example>
boot: Linux init=/bin/sh
</example>

To wymusza załadowanie jądra oraz uruchomienie <file>/bin/sh</file>
w miejsce standardowego programu <prgn>init</prgn>.
Dzięki temu uzyskujesz przywileje administratora oraz dostęp do konta root.

Ponieważ system plików <file>/</file> jest zamontowany w trybie „tylko do
odczytu”, a inne nie są zamontowane w ogóle, trzeba wykonać kilka
operacji, aby uzyskać w pełni funkcjonujący system.

<example>init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>

(Jeżeli drugie pole danych zapisanych w <file>/etc/passwd</file> zawiera
tylko literkę „x” dla każdego użytkownika, oznacza to, że Twój system
używa osobnego pliku do przechowywania haseł i musisz edytować
<file>/etc/shadow</file>.)

Aby wyłączyć hasło dla konta root, wykasuj całą zawartość pola
odpowiedzialnego za hasło (jest to drugie pole w pliku
<file>/etc/passwd</file> lub <file>/etc/shadow</file>, jeżeli system go
używa). Teraz możesz przeładować system i zalogować się na konto root bez
hasła. Podczas inicjowania na poziomie startu równym 1 („runlevel 1”),
Debian (od wersji Potato) wymaga hasła, czego niektóre starsze dystrybucje
nie czynią.
<p>

Dobrym pomysłem jest mieć jakiś prosty edytor w <file>/bin/</file> na
wypadek, gdyby <file>/usr/</file> było niedostępne (zobacz także
<ref id="bin-editor">).


<p>
Możesz także rozważyć instalację pakietu <package>sash</package>. Jeśli
system przestanie się uruchamiać, wykonaj:

<example>
boot: Linux init=/bin/sash
</example>

<prgn>sash</prgn> jest interaktywnym zamiennikiem dla <prgn>sh</prgn>,
nawet gdy <file>/bin/sh</file> jest niezdatny do użytku. <prgn>sash</prgn>
jest łączony statycznie i zawiera wbudowane wiele typowych 
funkcji (wpisz „help” w linii poleceń, aby poznać jego możliwości).
</sect1>

<sect1 id="crackroot2">„Zapomniałem hasła roota!” (2)
<p>
Uruchom system z zestawu dyskietek ratunkowych lub z płyty CD.
Załóżmy, że <file><var>/dev/hda3</var></file> to oryginalna, główna
partycja (root). Poniższe polecenia pozwolą na równie łatwe, jak w poprzednim
punkcie, wyedytowanie plików z użytkownikami i hasłami.

<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
Przewagą tej metody nad poprzednią jest to, że nie trzeba znać hasła do
<prgn>lilo</prgn> (jeżeli jest takowe uaktywnione). Aczkolwiek wymaga to
ingerencji w ustawienia BIOSu i włączenie możliwości startu systemu z CD
czy też dyskietek.

</sect1>

<sect1 id="dead-lilo">System się nie uruchamia
<p>
To żaden problem, nawet jeśli zaniedbano przygotowawania
dystkietki startowej. Jeśli <prgn>lilo</prgn> jest uszkodzone, użyj 
płyty startowej z zestawu płyt instalacyjnych Debiana (lub utwórz 
dyskietkę startową z obrazów zawartych na tejże płycie)
i uruchom system przy jej pomocy. 

<p>
Zakładamy, że główna partycja Twojej instalacji Linuksa to 
<file><var>/dev/hda12</var></file> oraz że chcesz ustawić 3 poziom startu. 
<p>
Gdy pojawi się komunikat startowy, wpisz:

<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>

Po chwili otrzymujesz prawie w pełni funkcjonalny system wykorzystujący
jądro z płytki/dyskietki startowej. Mogą jednak wystąpić pewne problemy 
wynikające z braku pewnych możliwości lub modułów w dystrybucyjnym jądrze.

<p>
Jeśli masz uszkodzony system zainteresuj się też rozdziałem
<ref id="un-bootable">.

<p>
Jeżeli potrzebujesz specjalnie dostosowanej dyskietki startowej, przejrzyj
plik <file>readme.txt</file> umieszczony na dysku ratunkowym.

</sect1>

<sect1 id="no-x-start">Jak wyłączyć automatyczne uruchamianie Xów przy starcie?!

<p>
Ujarzmianie wersji <tt>unstable/sid</tt> może być zabawne, ale 
zawierający błędy <prgn>xdm</prgn>, <prgn>gdm</prgn>,
<prgn>kdm</prgn> oraz <prgn>wdm</prgn> starujący przy uruchamianiu
systemu może Ci dopiec.
<p>
Na początek zdobądź dostęp do konta administratora (root) wpisując 
poniższe polecenie podczas startu <prgn>lilo</prgn>:
<example>
boot: <var>Linux</var> vga=normal s
</example>
Zakładamy, że <var>Linux</var> to etykieta jądra, które
zazwyczaj uruchamiasz. Natomiast „vga=normal” sprawi, że 
<prgn>lilo</prgn> wystartuje w normalnym trybie VGA. Ostatni 
parametr -- „s” (lub „S”) sprawia, że <prgn>init</prgn> 
uruchamia system w trybie pojedynczego użytkownika. 
Teraz wystarczy wpisać hasło administratora (konto root).
<p>
Istnieje kilka sposobów na wyłączenie wszystkich demonów systemu X:
<list>
<item>uruchom <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6 .</tt>
<item>wstaw „exit 0” na początek wszystkich plików
     <file>/etc/init.d/<var>?</var>dm</file>.

<item>zmień nazwę wszystkich plików
     <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> na
     <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>usuń wszystkie pliki
     <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>.
<item>uruchom 
     <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
W przykładach <file>rc<var>2</var>.d</file> oznacza aktualny 
poziom startu (runlevel) ustalony w <file>/etc/inittab</file>, 
zaś <file><var>?</var>dm</file> oznacza, że powinieneś 
uruchomić każdy z programów: <prgn>xdm</prgn>, <prgn>gdm</prgn>,
<prgn>kdm</prgn> czy też <prgn>wdm</prgn>.
<p>
Tylko pierwsze z rozwiązań wymienionych na liście, jest 
„jedynie słuszną drogą” w systemie &debian;. 
Ostatni ze sposobów jest łatwy, ale wymaga ponownego ustawienia menedżera
ekranu używając później <prgn>dpkg-reconfigure</prgn>. 
Pozostałe to różne metody na 
wyłączenie demonów.
<p>
Po tych czynnościach nadal możesz uruchomić środowisko graficzne
poleceniem <prgn>startx</prgn> wydanym na dowolnej konsoli tekstowej. 
</sect1>

<sect1 id="bootprompt">Inne triki stosowane podczas startu systemu
<p>
System może być uruchamiany w wybranym poziomie startu (runlevel) oraz 
z określoną przez użytkownika konfiguracją. Wystarczy wykorzystać 
udostępnianą przez <prgn>lilo</prgn> możliwość podania parametrów
przy uruchamianiu systemu.

Szczegóły znajdziesz w 
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).

<p>
Jeżeli chcesz uzyskać 4 poziom startu, spróbuj poniższego:

<example>
boot: Linux 4
</example>

<p>
Jeśli natomiast chcesz uzyskać tryb pojedynczego użytkownika (single-user), 
a znasz hasło administratora, możesz użyć:

<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>

<p>
W przypadku, gdy chcesz uruchomić system tak, aby wykorzystywał 
mniej pamięci, niż jest w rzeczywistości w komputerze (powiedzmy 48MB, 
podczas gdy komputer ma 64MB), użyj:

<example>
boot: Linux mem=48M
</example>
Upewnij się, że nie podajesz wartości przewyższającej dostępną pamięć, 
gdyż wtedy jądro może ulec katastrofie! Jeżeli posiadamy więcej niż 64MB 
(przykładowo 128MB), do czasu aż podamy <tt>mem=128M</tt> podczas startu 
lub w <file>/etc/lilo.conf</file>, starsze jądra i/lub płyty główne ze 
starszym BIOSem mogą nie używać pamięci powyżej 64MB.
</sect1>

<sect1 id="bootgrub">Ustawianie parametrów uruchomieniowych GRUB
<p>

<prgn>GRUB</prgn> jest to nowy zarządca startu systemu wywodzący się z
projektu GNU Hurd. Jest on bardziej elastyczny niż <prgn>lilo</prgn>, jednakże
występują tu drobne różnice w zakresie manipulowania parametrami startu 
systemu.

<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Musisz być świadom nazw urządzeń pochodzących z Hurda:
<example>
HURD/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,0)             /dev/hda1           C: (zazwyczaj)
 (hd0,3)             /dev/hda4           F: (zazwyczaj)
 (hd1,3)             /dev/hdb4           ?
</example>
Zajrzyj do <file>&f-grub;</file> oraz <file>&f-grub-doc;</file> po 
dokładniejsze informacje.
</sect1>

</sect>

<sect>Rejestrowanie działań

<sect1 id="script">Rejestrowanie poleceń powłoki
<p>
Administracja systemem pociąga za sobą o wiele więcej drobiazgowych zadań 
w Uniksie niż w zwykłych środowiskach komputerów osobistych. Upewnij się, że 
znasz przynajmniej podstawowe sposoby konfiguracji, na wypadek gdyby zaszła 
potrzeba odratowania systemu z problemów. 
Bazujące na graficznym interfejsie narzędzia 
konfiguracyjne wyglądają przyjemnie i wygodnie, jednakże zazwyczaj nie nadają
się do użycia w stanie zagrożenia. 

<p>
Tak więc, rejestrowanie działań poleceniami powłoki jest dobrym zwyczajem, 
szczególnie podczas pracy jako administrator (root).

<p>
Emacs: Użyj M-x <tt>shell</tt> aby rozpocząć nagrywanie do bufora oraz
C-x C-w aby zapisać bufor na dysk. 

<p>
Powłoka: Użyj polecenia <prgn>screen</prgn> oraz „^A H” jak opisano w
<ref id="screen"> lub skorzystaj z <prgn>script</prgn>.

<example>
$ script nagranie
Script started, file is nagranie
$ ...
  ... Rób cokolwiek ...
  ... Na zakończenie naciśnij Ctrl+D ...
Script done, file is nagranie
$ col -bx &lt;nagranie &gt;raport
$ vi raport
</example>
Poniższe polecenie może być użyte zamiast polecenia <prgn>script</prgn>:
<example>
$ bash -i 2&gt;&amp;1 | tee nagranie
</example>
</sect1>

<sect1>Rejestrowanie obrazu w Xach.

<p>
Jeżeli chcesz zarejestrować graficzny obraz aplikacji w środowisku X-Window, 
możesz użyć programu <prgn>gimp</prgn> (GUI). Potrafi on przechwytywać 
określone okna z osobna lub cały ekran. Innym rozwiązaniem jest zastosowanie 
programów takich jak: <prgn>xwd</prgn> (z pakietu <package>xbase-clients</package>), 
<prgn>import</prgn> (z pakietu <package>imagemagick</package>) oraz <prgn>scrot</prgn>
(z pakietu <package>scrot</package>).

</sect1>


</sect>

<sect id="archiving">Kopiowanie oraz archiwizacja całych katalogów
<sect1>Podstawowe polecenia do kopiowania całych podkatalogów
<p>
Jeżeli chcesz przearanżować strukturę położenia plików, skorzystaj na 
przykład z:
<example>
Typowa metoda:
# cp -a /początkowy/katalog /docelowy/katalog # wymaga narzędzia GNU cp
# (cd /początkowy/katalog &amp;&amp; tar cf - . ) | \
        (cd /docelowy/katalog &amp;&amp; tar xvfp - )
Jeżeli twarde dowiązania są wymagane, przydatna okaże się metoda:
# cd /ścieżka/do/starego/katalogu
# find . -depth -print0 | afio -p -xv -0a /punkt/montowania/nowego/katalogu
Jeśli cel jest na odległej maszynie:
# (cd /początkowy/katalog &amp;&amp; tar cf - . ) | \
        ssh użytkownik@komputer.odległy (cd /docelowy/katalog &amp;&amp; tar xvfp - )
Jeżeli nie ma dowiązań do plików, wystarczy:
# scp -pr użytkownik1@jeden.komputer:/początkowy/katalog \
          użytkownik2@drugi.komputer:/docelowy/katalog
</example>
W przykładach <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> oraz <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
Powyższe sposoby kopiowania całych katalogów zostały 
zaprezentowane przez Manoja Srivastavę <email>srivasta@debian.org</email> na 
liście dyskusyjnej debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Tradycyjne narzędzie <prgn>cp</prgn> nie było dobrym 
kandydatem do takich zadań, gdyż nie wyłuskiwało symbolicznych
dowiązań ani nie chroniło dowiązań twardych. Kolejną rzeczą wymagającą
rozważenia były tzw. rzadkie (sparse) pliki (pliki z dziurami).
<p>
GNU <prgn>cp</prgn> przezwyciężyło te ograniczenia, 
jednakże na systemach niezgodnych z GNU, <prgn>cp</prgn> może 
wciąż sprawiać problemy. Możesz również nie móc tworzyć małych, 
przenośnych archiwów używając <prgn>cp</prgn>.
<example>
&percnt; cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
Tar przezwycięża kilka z problemów, które <prgn>cp</prgn> 
ma z symbolicznymi dowiązaniami. Jednakże, jakkolwiek <prgn>cpio</prgn> 
obsługuje specjalne pliki, to konwencjonalny <prgn>tar</prgn> nie.
<p>
W przypadku wielu dowiązań (hardlink) do jednego pliku, 
<prgn>tar</prgn> umieszcza na taśmie tylko jedną kopię;
<prgn>cpio</prgn> umieszcza jedną kopię dla każdego dowiązania.
<p>
Polecenie <prgn>tar</prgn> zmieniło swoją opcję używaną dla plików
<file>.bz2</file> pomiędzy Potato a Woody, więc używaj w skryptach 
<tt>--bzip2</tt> zamiast ich krótkiej formy <tt>-I</tt> (Potato) 
czy też <tt>-j</tt> (Woody).
</sect1>

<sect1><prgn>pax</prgn>
<p>
Nowe, wypasione narzędzie POSIX (IEEE Std 1003.2-1992, strony 380&ndash;388
(rozdział 4.48) oraz strony 936&ndash;940 (rozdział E.4.48)) o nazwie
Portable ArchiveInterchange. <prgn>pax</prgn> potrafi czytać, zapisywać
i wyświetlać zawartość pliku archiwum, jak również kopiować hierarchie
katalogów. Operacje narzędzi <prgn>pax</prgn> są niezależne od określonego
rodzaju archiwum i obsługują szeroką gamę różnorodnych formatów.
<p>
Implementacje programu <prgn>pax</prgn> są  ciągle nowe i siermiężne.
<example>
# apt-get install pax
$ pax -rw -p e . nowy_katalog
 lub
$ find . -depth  | pax -rw -p e  nowy_katalog
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn> kopiuje pliki do lub z archiwum programu <prgn>cpio</prgn> 
albo programu <prgn>tar</prgn>.
Archiwum może być plikiem na dysku, taśmą magnetyczną czy też potokiem.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> jest lepszym wyborem w zakresie obsługi archiwów
w formacie <prgn>cpio</prgn>. Jest zdecydowanie szybszy niż 
<prgn>cpio</prgn>, udostępnia więcej opcji obsługi taśmy 
magnetycznej oraz zachowuje się o wiele wdzięczniej w przypadku 
uszkodzenia danych wejściowych. Obsługuje wieloczęściowe archiwa podczas 
interaktywnych operacji. <prgn>afio</prgn> może tworzyć kompresowane 
archiwa, które są o wiele bezpieczniejsze niż kompresowane produkty 
<prgn>tar</prgn>a lub <prgn>cpio</prgn>. 
<prgn>afio</prgn> jest używane jako „archiwizujący silnik” w skryptach
do tworzenia kopii zapasowych.
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
</sect1>
</sect>

<sect id="diff-backup">Kopia różnicowa oraz synchronizacja danych
<p>
Kopie różnicowe oraz synchronizacja danych mogą być wykonane różnymi
metodami:
<list>
<item><package>rcs</package>:  kopia oraz historia, tylko tekst
<item><package>rdiff-backup</package>:  kopia oraz historia. symboliczne dowiązania .
<item><package>pdumpfs</package>:  kopia oraz historia w granicach systemu plików.
symlink OK<item><package>rsync</package>:  jednokierunkowa synchronizacja
<item><package>unison</package>: dwukierunkowa synchronizacja
<item><package>cvs</package>:  wielotorowa synchronizacja z serwerem, kopia oraz 
historia, tylko tekst, dojrzałe rozwiązanie. Zobacz też tutaj: <ref id="cvs">.
<item><package>arch</package>:  wielotorowa synchronizacja z serwerem, kopia oraz 
historia, brak takich rzeczy jak „roboczy katalog”.
<item><package>subversion</package>:  wielotorowa synchronizacja z serwerem, kopia 
oraz historia, Apache.
</list>
Połączenie jednej z tych metod z archiwizacją opisaną tutaj:
<ref id="archiving"> oraz automatycznym wykonywaniem zadań o określonym czasie 
(<ref id="cronjob">) pozwoli stworzyć miły system kopii bezpieczeństwa.
<p>
Poniżej opiszę trzy łatwe w użyciu narzędzia.

<sect1 id="rdiff-backup">Kopia różnicowa z użyciem rdiff
<p>
<package>rdiff-backup</package> pozwala przyjemnie i prosto utworzyć 
kopię bezpieczeństwa wraz z historią zmian, obsługując 
dowolne typy plików, włączając w to dowiązania symboliczne.
Aby zarchiwizować <file>~/</file> do <file>/mnt/kopia</file>, 
zastosuj:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/kopia
</example>
Aby przywrócić dane sprzed trzech dni do <file>~/stare</file>, użyj:
<example>
$ rdiff-backup -r 3D /mnt/kopia ~/stare
</example>
Poczytaj też podręcznik systemowy: <manref name="rdiff-backup" section="1">.

<sect1 id="pdumpfs-backup">Codzienna kopia z użyciem <package>pdumpfs</package>
<p>
<package>pdumpfs</package> to prosty system tworzenia codziennych
kopii zapasowych, zbliony do <prgn>dumpfs</prgn>. Możesz korzystać z 
dostępu do wcześniejszych kopii w dowolnym momencie.
Spróbuj uruchomić kopię bezpieczeństwa swojego katalogu domowego
z wykorzystaniem <prgn>pdumpfs</prgn> oraz <prgn>cron</prgn>a!
<p>
<prgn>pdumpfs</prgn> tworzy archiwum <tt>YYYY/MM/DD</tt> w docelowym
katalogu. Przy pierwszym uruchomieniu <prgn>pdumpfs</prgn> 
wszystkie źródłowe pliki są kopiowane do 
docelowego katalogu. Za kolejnymi uruchomieniami kopiowane
są jedynie te pliki, które zostały zmodyfikowane lub utworzone od ostatniego 
uruchomienia programu <prgn>pdumpfs</prgn>, natomiast pozostające bez zmian 
są przedstawiane w postaci dowiązania do ich odpowiedników we wcześniejszych
kopiach celem zaoszczędzenia miejsca na dysku.
<example>
$ pdumpfs <var>kat_źródłowy</var> <var>kat_docelowy</var> [<var>nazwa docelowa</var>]
</example>
Zobacz także: <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">Regularne kopie różnicowe wykonywane z użyciem RCS
<p>
<package>Changetrack</package> regularnie rejestruje zmiany w tekstowych 
plikach konfiguracyjnych. 
Zobacz także: <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>

<sect>Przywracanie po zawieszeniu systemu
<sect1 id="kill">Usuwanie procesów
<p>
Uruchom <prgn>top</prgn> aby zobaczyć, które procesy zużywają 
największą ilość zasobów. Naciśnij „P” aby posortować wg zużycia 
mocy procesora, „M” wg zużycia pamięci oraz „k” aby usunąć proces.
Alternatywnie, możesz użyć <tt>ps aux | less</tt> (sposób BSD) lub 
<tt>ps -efH | less</tt> (sposób System-V).
Ta druga składnia pokazuje identyfikatory procesów nadrzędnych. 
(<tt>PPID</tt>), co pozwala na ubicie zombie (niefunkcjonujących 
procesów potomnych).
<p>
Użyj polecenia <prgn>kill</prgn> aby usunąć proces (lub wysłać do niego sygnał) 
według ID procesu. <prgn>killall</prgn> działa analogicznie, ale możliwe jest 
podanie nazwy procesu. Najczęściej używane sygnały:
<example>
 1: HUP,  uruchom ponownie demona
15: TERM, normalne zakończenie pracy
 9: KILL, bezkompromisowe usunięcie
</example>

</sect1>

<sect1>Alt-SysRq
<p>
Jądro pozwala się zabezpieczyć przed wadliwym działaniem systemu za pomocą
opcji „Magic SysRq key” podawanej przy jego kompilacji.
Wciśnięcie na architekturze i386 Alt-SysRq, a za nim jeden
z klawiszy <tt>r 0 k e i s u b</tt> czyni cuda.
<p>
Klawisz `r' przywróci stan klawiatury po takich niespodziankach jak
zawieszenie się serwera X. Zmiana poziomu logowania na konsoli na `0' 
zmniejsza ilość wyświetlanych komunikatów o błędach. sa'k' (z ang. system 
attention key) zabija wszystkie procesy na danej konsoli wirtualnej.
`e' zabija wszystkie procesy na danym terminalu poza procesem init.
`i' zabija wszystkie procesy poza procesem init.
<p>
`S'ync, `u'mount i re`b'oot służą do wychodzenia z najcięższych kłopotów.
<p>
Szczegółowe instrukcje znajdziesz w pliku:
<file>
/usr/share/doc/kernel-doc-<var>version</var>/Documentation/sysrq.txt.gz
</file>
lub
<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.
</sect1>
</sect>


<sect id="nifty">Warte zapamiętania polecenia

<sect1>Przeglądarka treści tekstowych
<p>
<prgn>less</prgn> jest domyślną przeglądarką zawartości plików.  Klawisz „h” 
przywołuje pomoc. Program potrafi o wiele więcej niż <prgn>more</prgn>.  
<prgn>less</prgn> może być „podrasowany” przez wykonanie polecenia <tt>eval 
$(lesspipe)</tt> lub <tt>eval $(lessfile)</tt> w skryptach startowych powłoki.  
Zobacz więcej: <file>&f-lessopen;</file>. Opcja <tt>-R</tt> umożliwia 
wykorzystywanie nieobrobionego wyjścia oraz włącza sekwencje ANSI sterujące 
kolorami. Zobacz także: <manref name="less" section="1">.
<p>
<prgn>w3m</prgn> może być użyteczny jako alternatywna przeglądarka w 
przypadku niektórych systemów kodowania (np. EUC).

<sect1>Wolna pamięć
<p>
<prgn>free</prgn> oraz <prgn>top</prgn> stanowią dobry sposób uzyskania 
informacji na temat pamięci. Nie zwracaj uwagi na wartość „used” w linii
„Mem:”, ale skorzystaj z liczby umieszczonej poniżej (w przykładzie 
jest to 38792).
<example>
$ free -k # dla komputera z pamięcią o rozmiarze 256MB 
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
Ścisły rozmiar fizycznej pamięci może być sprawdzony poleceniem
<tt>grep '^Memory' /var/log/dmesg</tt>, które w przypadku z przykładu 
powyżej daje komunikat: „Memory: 256984k/262144k available (1652k kernel
code, 412k reserved, 2944k data, 152k init)”.
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Około 5MB jest nieużyteczne dla systemu, ponieważ jądro tego używa.
</sect1>

<sect1>Ustawianie czasu (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
Powyższe polecenia ustawiają sprzętowy zegar na wartość: <tt>MM/DD hh:mm, 
CCYY</tt>. Czas jest pokazywany zgodnie z lokalną strefą czasową, jednak
sprzętowy zegar jest ustawiany według czasu uniwersalnego (UTC).

<sect1>Ustawianie czasu (NTP)
<p>
Zaglądnij też do: <url id="&time-howto;" name="Managing Accurate Date and Time
HOWTO">.
<p>

<sect2>Ustawianie czasu w przypadku stałego łącza z Internetem
<p>
Ustaw czas systemu automatycznie według odległego serwera:
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>serwer</var>
</example>
Dobrym rozwiązanie jest umieszczenie tego w pliku
<file>/etc/cron.daily/</file> jeżeli Twój system ma stałe łącze z Internetem,
a dokładniej, z wskazanym serwerem.

<sect2>Ustawianie czasu przy czasowych połączeniach z siecią
<p>
Użyj pakietu <package>chrony</package>.
</sect1>

<sect1 id="setterm">Jak kontrolować funkcje konsoli, takie jak wygaszacz
ekranu
<p>
W celu wyłączenia wygaszacza ekranu w konsoli tekstowej, należy wykonać:
<example>
# setterm -powersave off
</example>
<p>
Możesz uruchomić konsolę kon2 (kanji) używając:
<example>
# kon -SaveTime 0
</example>
<p>
Mając uruchomieny X Window System:
<example>
# xset s off
 lub
# xset -dpms
 lub
# xscreensaver-command -prefs
</example>
Przeczytaj odpowiednie strony podręcznika systemowego na temat obsługi innych
funkcji konsoli. Zobacz także <manref name="stty" section="1">. Znajdziesz
tam nieco na temat sprawdzania oraz zmiany ustawień linii komend.
</sect1>

<sect1 id="getent">Przeszukiwanie administracyjnych baz danych
<p>
Glibc umożliwia wykorzystanie: <manref name="getent" section="1"> 
do wyszukiwania wpisów w administracyjnych bazach danych, takich jak
passwd, group, hosts, services, protocols czy networks.
<example compact>
getent baza_danych [klucz ...]
</example>

<sect1>Wyłączenia dźwięków (brzęczyk)
<p>
Najprościej odłączyć głośniczek  ;-). Albo, dla basha:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Komunikaty o błędach na ekranie konsoli
<p>
Aby wyłączyć komunikaty o błędach wysyłane na konsolę tekstową, 
zaglądnij do <file>/etc/init.d/klogd</file>.
Ustaw <tt>KLOGD="-c <var>3</var>"</tt> w tym skrypcie oraz uruchom 
<tt>/etc/init.d/klogd restart</tt>. Inna metoda, to 
uruchomienie <tt>dmesg -n<var>3</var></tt>.
<p>
Poziomy raportowania błędów są następujące:
<list compact>
<item>0: KERN_EMERG,   system jest bezużyteczny
<item>1: KERN_ALERT,   reakcja musi być natychmiastowa
<item>2: KERN_CRIT,    krytyczna sytuacja (critical conditions)
<item>3: KERN_ERR,     błędna sytuacja (error conditions)
<item>4: KERN_WARNING, ostrzeżenie (warning conditions)
<item>5: KERN_NOTICE,  normalna, choć ważna sytuacja (significant condition)
<item>6: KERN_INFO,    informacyjne
<item>7: KERN_DEBUG,   komunikaty odpluskwiania
</list>
<p>
Jeśli denerwuje Cię jeden, specyficzny, bezużyteczny komunikat o błędzie,
zastanów się nad zastosowaniem trywialnej łatki na jądro, takiej jak 
<file>shutup-abit-bp6</file> (dostępna w <url id="&examples;"
name="podkatalogu z przykładami">).
<p>
Możesz także zaglądnąć do <file>/etc/syslog.conf</file>; sprawdź czy
jakieś komunikaty nie są wysyłane do urządzenia powiązanego z konsolą.
</sect1>

<sect1>Ustawienie właściwego typu konsoli
<p>
Ekran konsoli w systemach uniksowych jest zazwyczaj obsługiwany 
przez bilioteki (n)curses.  Zapewniają one niezależne od rodzaju 
terminala metody obsługi ekranu.
Sprawdź: <manref name="ncurses" section="3X"> oraz
<manref name="terminfo" section="5">.
<p>
W systemie &debian;, jest nieco wstępnie zdefiniowanych wartości:
<example>
$ toe | less                  # wszystkie wartości
$ toe /etc/terminfo/ | less   # wartości dające się modyfikować przez użytkowników
</example>
Wyeksportuj Twój wybór jako zmienną środowiskową <tt>TERM</tt>.
<p>
Jeżeli wartość terminfo dla <prgn>xterm</prgn> nie działa właściwie z
xtermami 
nie pochodzącymi z Debiana, zmień rodzaj terminala z „xterm” na jedną
z wersji posiadających ograniczenia funkcjonalności, jak np.„xterm-r6” 
podczas zdalnego logowania do Debiana.
Zobacz także: <file>&f-libncurse;</file>.
„dumb” jest najniższą wspólną definicją dla terminfo.
</sect1>

<sect1>Przywracanie konsoli do rozsądnego stanu
<p>
Jeśli ekran stanie się nieczytelny po wykonaniu polecenia
<tt>cat <var>jakiś-plik-binarny</var></tt> 
(możesz nie widzieć poleceń, jakie wpisujesz), zastosuj:
<example>
$ reset
</example>
</sect1>

<sect1>Konwersja plików ze stylu dosowego na uniksowy
<p>
Przekształcanie dosowego pliku tekstowego (koniec-linii = <tt>^M^J</tt>) 
na format uniksowy (koniec-linii = <tt>^J</tt>):
<example>
# apt-get install sysutils
$ dos2unix <var>plik_dosowy</var>
</example>
</sect1>

<sect1 id="perl-i">Zastępowanie przy pomocy wyrażeń regularnych
<p>
Zamiana wszystkich wystąpień <var>WYRAŻENIE_POCZĄTKOWE</var> na 
<var>WYRAŻENIE_KOŃCOWE</var> 
we wszystkich plikach <var>PLIKI</var> ...:
<example>
$ perl -i -p -e 's/<var>WYRAŻENIE_POCZĄTKOWE</var>/<var>WYRAŻENIE_KOŃCOWE</var>/g;' <var>PLIKI</var> ...
</example>
<tt>-i</tt> służy do „in-place editing”, <tt>-p</tt> wymusza przetwarzanie 
w pętli, każdy plik z podanych jako <var>PLIKI</var> ...  Jeśli zastępowanie 
jest złożone, możesz zabezpieczyć się przed błędami używając parametru 
<tt>-i.bak</tt> zamiast <tt>-i</tt>; to zachowa oryginalne pliki dodając do ich 
nazwy <tt>.bak</tt>.
</sect1>

<sect1>Edytowanie plików przez skrypt
<p>
Poniższy skrypt usunie linie 5&ndash;10 oraz 16&ndash;20.
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
Polecenia <prgn>ed</prgn> są takie same jak polecenia <prgn>vi</prgn>
w trybie wydawania poleceń. Modyfikacja pliku od tyłu ułatwia jego edycję
w skryptach.
</sect1>

<sect1>Odnajdywanie różnic i scalanie uaktualnień w pliku źródłowym
<p>
Poniższa procedura odnajduje różnice pomiędzy dwoma plikami i 
tworzy zunifikowane pliki „diff”: <var>plik.łatka0</var> lub
<var>plik.łatka1</var>:
<example>
$ diff -u <var>plik.stary</var> <var>plik.nowy1</var> &gt; <var>plik.łatka0</var>
$ diff -u <var>stary/plik</var> <var>nowy1/plik</var> &gt; <var>plik.łatka1</var></example>
Pliki „diff”, nazywane także łatkami (patch) są używane do przesyłania
uaktualnień kodów źródłowych programów. Po odebraniu takiego pliku, 
można go zaaplikować na posiadany stary plik używając poleceń:
<example>
$ patch -p0 <var>plik.stary</var> &lt; <var>plik.łatka0</var>
$ patch -p1 <var>plik.stary</var> &lt; <var>plik.łatka1</var>
</example>
Jeśli masz wszystkie trzy wersje kodów źródłowych, możesz je 
połączyć używając narzędzia <prgn>diff3</prgn>:
<example>
$ diff3 -m <var>plik.mój</var> <var>plik.stary</var> <var>plik.twój</var> &gt; <var>plik</var></example>
</sect1>

<sect1>Przekształcanie dużego pliku w kilka małych
<p>
<example>
$ split -b 650m <var>plik</var>   # podział pliku na kawałki 650 MB 
$ cat x* &gt; <var>dużyplik</var>     # łączenie plików w jeden duży
</example>
</sect1>

<sect1>Wyłuskiwanie danych z tekstowych tabel
<p>
Rozpatrzymy plik nazwany <file>DPL</file> 
w którym zachowywane są wszystkie nazwiska przywódców projektu 
&debian; oraz daty rozpoczęcia ich działalności. Dane oddzielone są
przerwami.
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   January 1998
Wichert Akkerman  January 1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr March   2003
</example>
Najczęsciej używanym narzędziem do takich zadań jest Awk.
<example>
$ awk '{ print $3 }' &lt;DPL                   # Miesiące
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' &lt;DPL          # przywódca zwany Ian
Ian     Murdock   August  1993
Ian     Jackson   January 1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # Kiedy rozpoczął Perens 
April 1996
</example>

<p>
Powłoka taka jak Bash również może zostać użyta do obrabiania tego typu
plików:
<example>
$ while read first last month year; do 
    echo $month
  done &lt;DPL
... taki sam efekt jak w pierwszym przykładzie z Awk
</example>
W tym przypadku wbudowane polecenie <prgn>read</prgn> używa znaków z $IFS
(wewnętrzne separatory pól) by podzielić linie na słowa.
<p>
Jeśli zmienisz IFS na ":" będziesz mógł bezproblemowo z powłoką obrabiać plik 
<file>/etc/passwd</file>:
<example>
$ oldIFS="$IFS"   # zapisuje starą wartość
$ IFS=":"
$ while read user password uid gid rest_of_line; do
    if [ "$user" = "osamu" ]; then
      echo "$user's ID is $uid"
    fi
  done < /etc/passwd
osamu's ID is 1001
$ IFS="$oldIFS"   # przywraca starą wartość
</example>
(Jeśli chcesz użyć Awk do tego samego skorzystaj z <tt>FS=":"</tt> by
ustawić separator pól.)
<p>
IFS jest również używane przez powłokę do rozdzielania wyników dopełniania 
parametrów, podmian poleceń i dopełniania arytmetycznego. To nie dotyczy
wyrazów w podwójnym lub pojedynczym cudzysłowiu. Domyślną wartością IFS
jest kombinacja następujących znaków
&lt;spacja&gt;, &lt;tabulator&gt; i &lt;znak nowej linii&gt;.
<p>
Uważaj używając trików z IFS w powłoce.
Dziwne rzeczy się mogą dziać kiedy powłoka zinterpretuje część skryptu jako
swoje <strong>wejście</strong>.
<example>
$ IFS=":,"                        # użyj ":" i "," jako IFS
$ echo IFS=$IFS,   IFS="$IFS"     # echo jest wbudowane w Basha 
IFS=  , IFS=:,
$ date -R                         # zwykłe wyjście polecenia
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # pod-powłoka --&gt; wejście do głównej powłoki
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # przywrócenie domyślnej wartości IFS
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>


</sect1>

<sect1 id="scrp-snip">Kawałki kodu przekierowywania poleceń
<p>
Poniższe skrypty wspólnie tworzą piękną całość jeśli są połączone potokiem
(ang. pipe).
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # znajduje wszystkie pliki w /usr z wyłączeniem pewnych
plików
xargs -n 1 <var>polecenie</var>  # uruchamia polecenia dla każdego z elementu ze standardowego wejścia
xargs -n 1 echo |    # dzieli elementy oddzielone białymi znakami na linie
xargs echo      |    # łączy wszystkie linie w jedną
grep -e <var>wzorzec</var>|     # wyciąga linie zawierające dany <var>wzorzec</var>
cut -d: -f3 -|       # wyciąga trzecie pole oddzielone znakiem : (np. plik passwd)
awk '{ print $3 }' | # wyciąga trzecie pole oddzielone białymi znakami
awk -F'\t' '{ print $3 }' |        # wyciąga trzecie pole oddzielone tabulatorem
col -bx |            # usuwa backspace i rozwija tabulacje na spacje
expand -|            # rozwija tabulacje
sort -u|             # sortuje i usuwa powtórzenia

tr '\n' ' '|         # usuwa znaki LF (wysuń wiersz)
tr '\r' &apos;&apos;|          # usuwa znaki CR (powrót karetki)
tr 'A-Z' 'a-z'|      # przekształca wielkie litery w małe
sed 's/^/# /'|       # zmienia każdą linię na komentarz (zaczyna się od #)
sed 's/\<var>.ext</var>//g'|     # usuwa <var>.ext</var>
sed  -n -e 2p|       # wypisuje drugą linię
head -n 2 -|         # wypisuje pierwsze 2 linie
tail -n 2 -|         # wypisuje ostatnie 2 linie
</example>
</sect1>

<sect1>Skrypty działające w pętli na każdym pliku
<p>
Poniższe sposoby pętli działającej na plikach z rozszerzeniem 
<tt>*.<var>ext</var></tt> zapewniają prawidłową obsługę dziwnych nazw
plików na przykład ze spacjami:
<list>
<item>Pętla w powłoce:
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>command</var> "$<var>x</var>"
  fi
done
</example>
<item><prgn>find</prgn> w kombinacji z <prgn>xargs</prgn>:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>command</var>
</example>
<item><prgn>find</prgn> z opcją <tt>-exec</tt> w poleceniu:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>command</var> '{}' \;
</example>
<item><prgn>find</prgn> z opcją <tt>-exec</tt> i krótkim skryptem powłoki:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>command</var> '{}' && echo 'successful'" \;
</example>
</list>
</sect1>


<sect1 id="perl-mad">Szaleństwo krótkich skryptów Perla
<p>
Jakkolwiek każdy skrypt Awk może zostać automatycznie przekształcony do
postaci perlowej z użyciem <manref name="a2p" section="1">, to jednolinijkowe
skrypty Awk najwygodniej przekształcać do jednolinijkowych skryptów Perla
ręcznie. Przykładowo:
<example>
awk '($2=="1957") { print $3 }' |
</example>
może być zapisany jak poniżej:
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
Teraz usuwamy wszystkie białe znaki oraz wykorzystujemy przewagę 
automatycznej konwersji pomiędzy liczbami a ciągami tekstowymi:
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
Zobacz też do: <manref name="perlrun" section="1">.
Wiele równie, lub bardziej szalonych skrytów Perla znajdziesz tutaj: 
<url id="&perlgolf;">.
</sect1>

<sect1>Pobieranie tekstu oraz archiwów list dyskusyjnych ze stron WWW
<p>
Poniższe polecenia zczytają stronę WWW do pliku tekstowego.
Przydatne na przykład do skopiowania konfiguracji ze strony WWW.
<example>
$ lynx -dump http://<var>www.odległa-strona.pl/plik.html</var> &gt;<var>plik.txt</var></example>
<prgn>links</prgn> i <prgn>w3m</prgn> mogą być również analogicznie 
użyte, z dokładnością do niewielkich różnic.
<p>
Jeśli to jest archiwum listy dyskusyjnej, użyj <prgn>munpack</prgn> 
aby uzyskać zawartość mime.</sect1>

<sect1>Estetyczne wydruki stron WWW
<p>
Poniższe polecenia wydrukują stronę WWW do drukarki/pliku PostScript:
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Zobacz także <ref id="lprlpd"> oraz sprawdź pakiety: <prgn>a2ps</prgn> 
oraz <prgn>mpage</prgn> służące do tworzenia PostScriptu.
</sect1>

<sect1>Estetyczne wydruki stron podręcznika systemowego
<p>
Poniższe polecenia wydrukują stronę podręcznika systemowego do 
drukarki/pliku PostScript:
<example>
$ man -Tps <var>jakaś-strona-podręcznika</var> | lpr
$ man -Tps <var>jakaś-strona-podręcznika</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Łączenie dwóch plików w formacie PostScript lub PDF 
<p>
Możesz połączyć pliki w formacie PostScript lub PDF:
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>

<sect1>Czas trwania
<p>
Wyświetlanie czasu trwania danego polecenia.
<example>
# time <var>jakieś-polecenie</var> &gt;/dev/null
real    0m0.035s       # czas, jaki upłynął na zegarku ściennym (czas rzeczywisty)
user    0m0.000s       # czas spędzony w trybie użytkownika
sys     0m0.020s       # czas spędzony w trybie jądra
</example>
</sect1>

<sect1>Polecenie <prgn>nice</prgn>
<p>
Użyj polecenia <prgn>nice</prgn> (z pakietu GNU 
<package>shellutils</package>) by ustawić podczas startu „przyjazność” 
programu w stosunku do innych. <prgn>renice</prgn>
(z <package>bsdutils</package>) lub <prgn>top</prgn> może zmienić tą wartość.
Wartość równa 19 oznacza najniższy priorytet procesu. Wartość ujemna jest
uważana za „nieprzyjazną” - wartość -20 oznacza wysoki priorytet procesu.
Tylko superużytkownik może ustawiać ujemne wartości nice.
<example>
# nice  -19 <var>top</var> # bardzo „miły” dla innych procesów
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # bardzo szybki</example>
Czasami ekstremalne wartości nice sprawiają więcej kłopotu niż pożytku, dlatego
używaj tego polecenia bardzo uważnie.
</sect1>

<sect1 id="cronjob">Harmonogram działań (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Użyj pakietu <prgn>cron</prgn> lub <prgn>at</prgn> aby zaplanować zadania
w systemie GNU/Linux.
Zobacz: <manref name="at" section="1">, <manref name="crontab" section="5">,
<manref name="crontab" section="8">.
<p>
Wykonaj polecenie <tt>crontab -e</tt> edytujące zawartość
spisu zadań („crontab”). Przykładowa zawartość takiego pliku:
<example>
# użyj /bin/sh do wykonywania poleceń, niezależnie od zapisu w /etc/passwd 
SHELL=/bin/sh
# prześlij standardowe wyjście poleceń do `pawel', niezależnie od tego, 
# czyj zestaw poleceń jest wykonywany
MAILTO=pawel
# Min Godzina DzieńMiesiąca Miesiąc DzieńTygodnia polecenie 
# (DzieńTygodnia i DzieńMiesiąca są połączone spójnikiem LUB)
# wykonaj o 00:05 każdego dnia
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# wykonaj o 14:15 pierwszego dnia każdego miesiąca -- wynik wysylany do Pawła
15 14 1  * *   $HOME/bin/monthly
# wykonaj o 22:00 każdego dnia tygodnia (1-5), wkurzamy Joe. 
# &percnt; to nowa linia, ostatni &percnt; to cc:
0 22 *   * 1-5 mail -s "Jest 10 wieczór" joe&percnt;Joe,&percnt;&percnt;Czy wiesz, gdzie są twoje dzieciaki?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "wykonane 23 minuty po godzinie 0, 2, 4 ..., dnia 1 lutego"
5  4 *   * sun echo "wykonane 04:05 każdej niedzieli"
# Wykonaj o 03:40 w pierwszy poniedziałek miesiąca
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>

Uruchom polecenie <prgn>at</prgn> aby wykonać jednorazowe zadanie:
<example>
$ echo '<var>polecenie -argumenty</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Zmiana konsoli przy pomocy <prgn>screen</prgn>a
<p>
Program <prgn>screen</prgn> umożliwia uruchomienie 
<strong>wielu</strong> pozornych terminali, każdy ze swoją
własną powłoką, <strong>na pojedynczym</strong> fizycznym terminalu 
lub emulatorze terminala. Nawet jeśli używasz wirtualnych konsoli 
Linuksa lub wielu x-terminali, program <prgn>screen</prgn> jest 
wart zainteresowania z uwagi na bogaty zbiór możliwości, takich jak np.:
<list compact>
<item>przewijany dostęp do historii poleceń,
<item>kopiowanie i wklejanie,
<item>zapisywanie stanu wyjścia (logowanie),
<item>digraph entry oraz
<item>możliwość <strong>odłączenia</strong> sesji całego 
programu <prgn>screen</prgn> od terminala i ponowne jej przyłączenie 
później. Pozwala to na zdalne uruchomienie czasochłonnego zadania, 
rozłączenie i powrócenie do niego, gdy już się wykona. 
</list>

<sect2>Scenariusz zdalnego dostępu
<p>
Jeśli często podłączasz się do systemu ze zdalnego terminala lub
korzystając z programu emulującego terminal w trybie VT100,
<prgn>screen</prgn> uczyni Twoje życie łatwiejszym :-) dzięki 
opcji <strong>detach</strong>.<p>
<enumlist compact>
<item>jesteś połączony przez łącze wdzwaniane i masz uruchomiony 
program <prgn>screen</prgn> ze sporą ilością sesji zawierających
różne programy
<item>nagle musisz porzucić terminal, ale nie chcesz stracić swojej 
dotychczasowej pracy po rozłączeniu 
<item>wpisujesz więc <tt>Ctrl+A d</tt> aby <strong>odłączyć</strong> 
sesje od terminala, a następnie przerywasz podłączenie do systemu. 
(lub szybciej: wpisując <tt>Ctrl+A DD</tt> zmuszając program
<prgn>screen</prgn> jednocześnie do odłączenia sesji i zakończenia 
połączenia)
<item>gdy ponownie przyłączysz się do systemu, wpisz polecenie
<tt>screen -r</tt>, a <prgn>screen</prgn> magicznie 
<strong>przyłączy się ponownie</strong> i wszystkie sesje zostaną 
przywrócone.
</enumlist>

<sect2>Podstawowe polecenia <prgn>screen</prgn>a
<p>
Gdy uruchomisz program <prgn>screen</prgn>, wszystkie naciskane klawisze
są wysyłane do aktualnej sesji, za wyjątkiem kombinacji wywołującej system 
poleceń <prgn>screen</prgn>a. Domyślnie jest to <tt>Ctrl+A</tt>. Wszystkie
polecenia programu <prgn>screen</prgn> są wpisywane przy użyciu <tt>Ctrl+A</tt>
a następnie pojedynczych klawiszy.
Użyteczne polecenia:
<example>
^A ?     pomoc do programu 
^A c     utwórz nową sesję i przełącz się do niej
^A n     następna sesja
^A p     poprzednia sesja
^A <var>0</var>     idź do sesji numer <var>0</var>
^A w     wyświetl listę sesji
^A a     Wyślij Ctrl+A do aktualnej sesji (normalne Ctrl+A jest przechwytywane)
^A h     zapisz kopię aktualnej sesji do pliku
^A H     rozpocznij/zakończ przechwytywanie aktualnej sesji do pliku
^A ^X    zabezpiecz terminal (ochrona hasłem)
^A d     odłącz sesje od terminala 
^A DD    odłącz sesje od terminala, a terminal od systemu 
</example>
To tylko niewielki podzbiór poleceń programu <prgn>screen</prgn>.
Jeśli istnieje coś, co chciał(a)byś wykonać przy użyciu <prgn>screen</prgn>a 
zapewne jest to możliwe! 
<p>
Zobacz także: <manref name="screen" section="1">.

<sect2>Backspace i/lub Ctrl+H w sesji <prgn>screen</prgn>a
<p>
Jeśli zauważysz, że backspace i/lib Ctrl+H nie działają dobrze
podczas działania programu <prgn>screen</prgn>, 
wyedytuj plik <file>/etc/screenrc</file>,
znajdź linię:
<example compact>
bindkey -k kb stuff "\177"
</example>
i zakomentuj ją (np. dodaj „#” jako pierwszy znak tej linii).

</sect1>

<sect1 id="net-test">Podstawy testowania sieci
<p>
Zainstaluj pakiety:
<package>netkit-ping</package>,
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (dla jądra 2.2),
<package>iptables</package> (dla jądra 2.4), oraz
<package>net-tools</package> i wykonaj:
<example>
$ ping <var>www.google.com</var>       # sprawdź połączenie z www.google.com
$ traceroute <var>www.google.com</var> # sprawdź trasę pakietów
$ ifconfig                  # sprawdź ustawienia komputera
$ route -n                  # sprawdź ustawienia tras pakietów
$ dig <var>[@serwer-dns.pl] host.dom [{a|mx|any}]</var> |less
      # sprawdź wpisy DNS dla <var>host.dom</var> zapisane w <var>dns-server.com</var>
      # typy rekorów to: <var>{a|mx|dowolne}</var>
$ ipchains  -L -n |less     # sprawdź filtry pakietów (jądro 2.2)
$ iptables -L -n |less      # check packet filter (jądro 2.4)
$ netstat -a                # znajdź wszystkie otwarte porty
$ netstat -l --inet         # znajdź nasłuchujące porty
$ netstat -ln --tcp         # znajdź nasłuchujące porty TCP (numerycznie)
</example>
</sect1>

<sect1 id="flush-mail">Wypychanie przesyłek z lokalnej kolejki
<p>
Aby wypchnąć listy z lokalnej kolejki, możesz użyć:
<example>
# exim -q    # wypchnij czekające listy
# exim -qf   # wypchnij wszystkie listy
# exim -qff  # wypchnij nawet zamrożone przesyłki
</example>
<tt>-qff</tt> może być użyteczną opcją w skrypcie
<file>/etc/ppp/ip-up.d/exim</file>.
</sect1>

<sect1 id="remove-mail">Usuwanie zamrożonych przesyłek z lokalnej kolejki
<p>
Aby usunąć zamrożone przesyłki z lokalnej kolejki, 
wysyłając jednocześnie komunikat o błędzie, wykonaj:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Ponownie dostarczanie zawartości mboksa
<p>
Jeśli Twój katalog domowy został zapełniony i procmailowi nie udało się
dokonać swego dzieła, musisz ręcznie przenieść pocztę do posortowanych
skrzynek w Twoim katalogu domowym z pliku
<file>/var/mail/<var>nazwa_użytkownika</var></file>. Po zwolnieniu miejsca
w katalogu domowym wykonaj poniższe czynności:
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>nazwa_użytkownika</var>
# /etc/init.d/exim start
</example>
</sect1>

<sect1>Usuwanie zawartości plików
<p>
W celu usunięcia zawartości plików takich jak dzienniki systemowe, 
nie używaj polecenia <tt>rm</tt> do usunięcia pliku i nie twórz pustego
od nowa, ponieważ pomiędzy tymi operacjami, jakaś część systemu może chcieć 
dokonać zapisków do takiego pliku. Poniżej pokazano sposób na bezpieczne 
usuwanie zawartości pliku:
<example>
$ :&gt;<var>plik-do-wyczyszczenia</var>
</example>
</sect1>

<sect1 id="dummyfile">Sztuczne pliki
<p>
Poniższe polecenia utworzą sztuczne lub puste pliki:
<example>
$ dd if=/dev/zero    of=<var>nazwa_pliku</var> bs=1k count=5 # 5KB samych zer
$ dd if=/dev/urandom of=<var>nazwa_pliku</var> bs=1M count=7 # 7MB losowej zawartości
$ touch <var>nazwa_pliku</var> #  pusty plik, jeśli nie istnieje
</example>
Przykładowo, poniższe polecenie, wykonane z powłoki dyskietki startowej 
systemu &debian; usunie całkowicie zawartość dysku twardego 
<file>/dev/hda</file>:
<example>
# dd if=/dev/urandom of=/dev/hda ; dd if=/dev/zero of=/dev/hda
</example>
</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
Program <prgn>chroot</prgn>, <manref name="chroot" section="8">, 
pozwala na uruchomienie różnych instancji środowiska GNU/Linux 
na jednym systemie bez ponownego uruchomiania go.
<p>
Można też uruchamiać zasobożerne programy takie jak <prgn>apt-get</prgn>
czy <prgn>dselect</prgn> w środowisku chroot na szybkim komputerze
mając zamontowane na wolniejszym komputerze zasób NFS na prawach r/w, który
to zasób jest głównym punktem montowania na wolniejszym komputerze.

<sect2 id="chroot-debian">Uruchamianie innej dystrybucji Debiana przy użyciu
<prgn>chroot</prgn><p>
Debianowe środowisko chroot można łatwo stworzyć przy pomocy
<prgn>debootstrap</prgn> w Woodym. Na przykład jeśli chcesz utworzyć
chroota z Sidem w katalogu <var>/sid-root</var> mając szybki dostęp
do Internetu:
<example>
main # cd / ; mkdir <var>/sid-root</var>
main # debootstrap woody <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... obserwuj jak program ściąga całą podstawę systemu
main # echo "proc-sid <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount proc-sid <var>/sid-root</var>/proc -t proc
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # cd /dev; /sbin/MAKEDEV generic ; cd -
chroot # apt-setup # ustawianie /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # wskaż źródła na unstable
chroot # dselect  # możesz też użyć aptitude, zainstaluj mc i vima :-)
</example>
<p>
W tej chwili powinieneś posiadać w pełni funkcjonalny system &debian;, w którym
możesz mieszać bez strachu, że coś popsujesz w Twojej głównej dystrybucji.
<p>
Ta sztuczka z <prgn>debootstrap</prgn> może też być użyta do instalcji
Debiana bez użycia dysku instalacyjnego Debiana lecz przy wykorzystaniu
innej dystrybucji GNU/Linux. Zobacz też <url id="&setup-chroot;">.

<sect2 id="chroot-console">Ustawianie loginu dla <prgn>chroot</prgn>
<p>
Wpisanie <tt>chroot <var>/sid-root</var> /bin/bash</tt> jest proste, ale
zostawia to wiele zmiennych środowiskowych walających się po pamięci, a które
nie są potrzebne lub nawet są niepożądane. Dużo lepszym sposobem jest
uruchomienie kolejnego procesu login na oddzielnym terminalu wirtualnym,
z którego możesz się bezpośrednio logować do systemu chroot.
<p>
Ponieważ domyślnie w systemie &debian; terminale <tt>tty1</tt> do <tt>tty6</tt>
są przeznaczone na konsole Linuksa, a <tt>tty7</tt> na sesję
X Window System, użyjemy konsoli <tt>tty8</tt> jako konsoi chroot. Po
utworzeniu środowiska chroot tak jak to zostało opisane w <ref
id="chroot-debian">, wpisz będąc rootem w głównym systemie:
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8"  >> /etc/inittab
main # init q    # przeładowanie init
</example>

<sect2 id="chroot-x">Ustawianie Xów do działania w <prgn>chroot</prgn>
<p>
Chcesz bezpiecznie uruchamiać najnowsze Xy i GNOME w środowisku chroot?
Jest to możliwe! Poniższy przykład uruchomi GDM na wirtualnym terminalu
<tt>vt9</tt>.
<p>
Najpierw zainstaluj system chroot wg. opisu w <ref id="chroot-debian">.
Z głównego systemu skopiuj kluczowe pliki konfiguracyjne do systemu chroot.
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # lub użyj konsoli chroot
chroot # cd /dev; /sbin/MAKEDEV generic ; cd -
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # wykonaj s/vt7/vt9/ w sekcji [servers]
chroot # /etc/init.d/gdm start
</example>
Plik <file>/etc/gdm/gdm.conf</file> został tak zmieniony, by pierwszą konsolą 
była konsola <tt>vt9</tt>, a nie <tt>vt7</tt>.
<p>
Teraz możesz bez problemu przełączać się między funkcjonalnymi środowiskami
X systemu głównego i systemu chroot przez proste przełączanie wirtualnych
terminali Linuksa, np. za pomocą kombinacji klawiszy Ctrl-Alt-F7
i Ctrl-Alt-F9. Miłej zabawy!
<p>
[FIXME] Dodaj komentarz i dowiązanie do skryptu init z chrootowanego gdm.

<sect2 id="chroot-dist">Uruchamianie innych dystrybucji w środowisku <prgn>chroot</prgn>
<p>
Środowisko chroot dla innej dystrybucji można utworzyć całkiem prosto.
Instalujesz system na oddzielnej partycji korzystając z instalatora danej
dystrybucji, i wykonujesz poniższe polecenia (przy założeniu, że główna
partycja innej dystrybucji to <file><var>/dev/hda9</var></file>):
<example>
main # cd / ; mkdir <var>/other-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/other-dist</var>
main # chroot <var>/other-dist</var> /bin/bash
</example>
Następnie postępuj tak jak opisano to w <ref id="chroot-debian">, <ref
id="chroot-console"> oraz <ref id="chroot-x">.

<sect2 id="chroot-build">Budowanie pakietu w środowisku <prgn>chroot</prgn>
<p>
<package>pbuilder</package> jest bardziej wyspecjalizowanym narzędziem
przygotowującycm środowisko chroot i budującym w nim pakiet. Jest to idealny
system sprawdzający, czy zależności budowania są poprawne oraz do upewnienia
się, że niepotrzebne i niepoprawne zależności budowania nie znajdą się
w pakiecie wynikowym.

</sect1>

<sect1>Jak weryfikować dowiązania (hardlink)
<p>
Możesz sprawdzić czy dwa pliki są tym samym plikiem z dwoma 
dowiązaniami:
<example>
$ ls -li <var>plik_1</var> <var>plik_2</var>
</example>

<sect1>Montowanie obrazów systemów plików
<p>
Jeżeli <file><var>plik.img</var></file> zawiera obraz zawartości
twardego dysku, zaś oryginalny twardy dysk ma konfigurację dającą:
<var>xxxx</var> = (bajtów/sektor) * (sektorów/cylinder), wtedy możesz 
taki obraz zamontować do katalogu <file>/mnt</file> poleceniem:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>plik.img</var> /mnt
</example>
Zauważ, że większość twardych dysków ma 512 bajtów/sektor.

<sect1 id="smbmount">Samba
<p>
Przykładowy dostęp do plików serwowanych przez Windows:

<list compact>
<item> montowanie zasobów Windows do Linuksa:
     <example>
     # mount -t smbfs -o <var>username=moja_nazwa,uid=mój_uid,gid=mój_gid</var> \
             <var>//serwer/dzielony_zasób /mnt/smb</var>  
     </example>
<item> inny sposób na montowanie zasobów Windows do Linuksa:
     <example>
     # smbmount <var>//serwer/dzielony_zasób /mnt/smb</var> \
             -o "<var>username=moja_nazwa,uid=mój_uid,gid=mój_gid</var>"
     </example>
<item> lista udostępnianych zasobów na wskazanym serwerze:
     <example>
     # smbclient -L <var>192.168.1.2</var> 
     </example>
</list>

<p>
Otoczenie sieciowe Samby może być sprawdzane spod GNU/Linuksa:
<example>
# smbclient -N -L <var>adres_ip_twojego_komputera</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>Narzędzia do obsługi obcych systemów plików
<p>
Obsługa wielu obcych systemów plików jest wspierana obecnie 
przez linuksowe jądro, a więc mogą być one dostępne w prosty 
sposób, poprzez zamontowanie urządzeń je zawierających.
Dla niektórych systemów plików są dostępne także specjalne narzędzia
umożliwiające dostęp do nich bez montowania urządzeń.
Są one dostępne jako programy pracujące w przestrzeni użytkownika, a zatem
wsparcie ze strony jądra nie jest potrzebne.
<list compact>
<item><package>mtools</package>: system plików MSDOS (MS-DOS, Windows)
<item><package>cpmtools</package>: system plików CP/M
<item><package>hfsutils</package>: system plików HFS (native Macintosh)
<item><package>hfsplus</package>: system plików HFS+ (modern Macintosh)
</list>
Do tworzenia i weryfikacji systemu plików MS-DOS FAT
użyteczne może być narzędzie: <package>dosfstools</package>.
</sect1>

</sect>
	 
<sect id="oops">Typowe błędy
<p>
Poniżej przedstawiamy kilka przykładów niebezpiecznych działań.
Niebezpieczeństwo jest jeszcze większe, jeśli używasz konta uprzywilejowanego
(<tt>root</tt>).
  	 
<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>
  	 <!--
  	 I know using quotes here are irregular but it is hard to read without it.
  	 -->
W poleceniu ,,<tt>rm -rf .*</tt>'', ,,<tt>.*</tt>'' jest rozwijane w
taki sposób, że zawiera także katalogi ,,<tt>.</tt>'' oraz ,,<tt>..</tt>''.
Jeśli więc posiadasz uprawnienia zapisu do katalogu nadrzędnego, to polecenie
to usunie także wszystkie katalogi znajdujące się <strong>obok</strong>
aktualnego katalogu.

<p>
<list compact>
<item>"<tt>rm -rf .</tt>" : usuwa wszystko w głąb bieżącego katalogu oraz
również ten katalog.
<item>"<tt>rm -rf *</tt>" : usuwa wszystkie pliki i katalogi, poza
rozpoczynającymi się znakiem kropki leżące w bieżącym katalogu.
<item>"<tt>rm -rf .[^.]*</tt>" : usuwa wszystkie pliki i katalogi, których
nazwy rozpoczynają się znakiem kropki
<item>"<tt>rm -rf .*</tt>" : usuwa wszystko znadujące się w nadrzędnym
katalogu oraz sam nadrzędny katalog.
</list>
  	 
<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
Utrata kilku ważnych plików, takich jak <file>/etc/passwd</file> na
skutek głupiej pomyłki bywa problematyczne. &debian; wykonuje regularne
kopie tych plików w <file>/var/backup/</file>.  Kiedy przywrócisz te pliki, 
musisz ręcznie ustawić odpowiednie prawa.

	<example>
  	 # cp /var/backup/passwd /etc/passwd
  	 # chmod 644 /etc/passwd
  	 </example>
Przeczytaj także <ref id="recover-status">.
</chapt>
