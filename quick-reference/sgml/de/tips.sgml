<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.120"  -->

<chapt id="tips">&debian;-Tipps

<sect id="booting">Booten des Systems
<p>
Detaillierte Informationen über den Boot-Prompt (also die Eingabeaufforderung
beim Systemstart) gibt es im
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> des LDP.

<sect1 id="crackroot">"Ich habe das root-Passwort vergessen!" (1)
<p>
Sobald man Zugriff auf die Tastatur eines Rechners hat, kann das
System gestartet werden und ein Login stattfinden, auch ohne das
root-Passwort zu kennen. (Dies setzt allerdings voraus, dass keine
zusätzlichen Schutzmaßnahmen ergriffen wurden, wie z.B. ein 
BIOS-Passwort oder eine Passwortabfrage durch <prgn>lilo</prgn>, was ein
Booten des Systems verhindern würde.)
<p>
Dies ist ein Vorgehen, das keine externen Boot-Medien und Änderungen der
BIOS-Einstellungen benötigt. Die Bezeichnung für die voreingestellte
Boot-Option sei "Linux".
<p>
Sobald die <prgn>lilo</prgn>-Boot-Meldung <tt>boot:</tt> erscheint
(auf einigen Systemen muss die Shift-/Umschalt-Taste gedrückt werden,
um einen automatischen Bootvorgang zu unterbrechen und wenn <prgn>lilo</prgn>
den Framebuffer verwendet, muss TAB gedrückt werden, um die eingegebenen
Optionen zu sehen), ist Folgendes
einzugeben:
<example>
boot: Linux init=/bin/sh
</example>
Das System startet nun den Kernel und daraufhin das Programm
<file>/bin/sh</file> anstelle des üblichen <prgn>init</prgn>-Prozesses.
Die nun erlangte Shell hat root-Privilegien. Da das Hauptverzeichnis
<file>/</file> nur les- aber nicht schreibbar ist und viele während des
üblichen Boot-Prozesses eingeklinkten Verzeichnisse nicht erreichbar sind,
müssen diese nachträglich gemountet werden, um ein vernünftiges Arbeiten
zu ermöglichen:
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(Wenn in der Datei <file>/etc/passwd</file> das zweite Datenfeld
bei allen Einträgen ein "x" ist, dann
benutzt das System shadow-Passwörter. In diesem Fall muss statt
<file>/etc/passwd</file> die Datei <file>/etc/shadow</file> editiert
werden.) Um das root-Passwort zurückzusetzen, muss das zweite Feld des
root-Eintrags gelöscht werden. Nach einem Neustart ist das
root-Passwort leer und kann neu vergeben werden. Wenn das System in den
Runlevel 1 fährt, wird (zumindest bei Debian-Versionen nach Potato)
ein Passwort benötigt.
<p>
Ein Editor im
<file>/bin/</file>-Verzeichnis ist absolut empfehlenswert, für den Fall, dass
der <file>/usr/</file>-Baum nicht erreichbar ist (siehe dazu auch
<ref id="bin-editor">).
<p>
Für Notfälle hat sich außerdem <package>sash</package> (stand
alone shell) bewährt. Wenn das System nicht mehr gebootet werden kann, geben
Sie am <prgn>lilo</prgn>-Prompt Folgendes ein:
<example>
boot: Linux init=/bin/sash
</example>
Das Programm <prgn>sash</prgn> dient als Ersatz für <prgn>sh</prgn>, selbst
wenn <file>/bin/sh</file> nicht nutzbar ist. Es ist statisch gelinkt und hat
viele Standardbefehle eingebaut.
(Wenn <prgn>sash</prgn> gestartet ist, wird "help" eine kurze Referenz
anzeigen.)
</sect1>

<sect1 id="crackroot2">"Ich habe das root-Passwort vergessen!" (2)
<p>
Starten Sie das System mit einer Rettungsdiskette/-CD. Sei
<file><var>/dev/hda3</var></file> die Root-Partition. Dann kann die
Passwortdatei editiert werden durch:
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
Der Vorteil dieser Variante ist, dass ein eventuell vergebenes
<prgn>lilo</prgn>-Passwort umgangen werden kann. Erforderlich ist allerdings,
dass im BIOS die Einstellung für das Boot-Laufwerk manipuliert werden kann
(falls es nicht schon entsprechend eingestellt ist).
</sect1>

<sect1 id="dead-lilo">Das System kann nicht gestartet werden
<p>
Dies ist kein Problem, selbst wenn Sie keine Boot-Diskette während der
Installation angelegt haben. Wenn <prgn>lilo</prgn> defekt ist, können
Sie die Boot-Disk des Debian-Installationssets verwenden und davon Ihr System
booten. Wenn Ihre Root-Partition <file><var>/dev/hda12</var></file> ist und
im Runlevel 3 gestartet werden soll, geben Sie Folgendes am Boot-Prompt ein:
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
Danach haben Sie ein fast vollständig funktionsfähiges System mit dem Kernel
des Installationsmediums gestartet. (Es kann einige kleinere Probleme 
aufgrund fehlender Kerneleigenschaften oder Module geben.)
<p>
Vergleichen Sie <ref id="un-bootable"> wenn Sie ein defektes System haben.
<p>
Benötigen Sie eine angepasste Boot-Diskette, folgen Sie den Anweisungen in
<file>readme.txt</file> auf der Rettungsdiskette.
</sect1>

<sect1 id="no-x-start">Abschalten von X beim Booten
<p>
Dem Nachjagen von <tt>unstable/sid</tt> ist lustig, aber ein fehlerhaftes
<prgn>xdm</prgn>, <prgn>gdm</prgn>, <prgn>kdm</prgn> oder <prgn>wdm</prgn>, das
während des Boot-Prozesses gestartet wird, kann sehr unangenehm sein.
<p>
Zuerst sollten Sie Zugang zu einer root-Shell erlangen, indem Sie Folgendes
am Boot-Prompt eingeben:
<example>
boot: <var>Linux</var> vga=normal s
</example>
Hier steht <var>Linux</var> für das Kernel-Image, das Sie starten;
"vga=normal" stellt sicher, dass <prgn>lilo</prgn> im normalen VGA-Modus
startet und "s" (oder "S") ist der Parameter der an <prgn>init</prgn>
weitergegeben wird und für Single-User-Modus steht.  Geben Sie das
root-Passwort am Prompt ein.
<p>
Es gibt mehrere Möglichkeiten alle Daemonen die X starten zu deaktivieren:
<list>
<item>Starten von <tt>update-rc.d -f <var>?</var>dm remove</tt>;
                  <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6 .</tt>
<item>Einfügen von "exit 0" am Anfang der
      <file>/etc/init.d/<var>?</var>dm</file>-Dateien.
<item>Umbenennen aller <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>-Dateien
      in <file>/etc/rc2.d/K99<var>?</var>dm</file>.
<item>Entfernen aller <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>-Dateien.
<item>Starten von <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Hier muss die Nummer in <file>rc<var>2</var>.d</file> dem Runlevel entsprechen, das in der 
Datei <file>/etc/inittab</file> angegeben wurde. <file><var>?</var>dm</file>
bedeutet, dass das Kommando mehrfach ausgeführt wird, wobei es jeweils durch
<prgn>xdm</prgn>, <prgn>gdm</prgn>, <prgn>kdm</prgn> und
<prgn>wdm</prgn> ersetzt wird.
<p>
Nur der erste Weg ist "der eine wahre Weg" in &debian;.  
Der letzte ist einfach, funktioniert aber nur in &debian; und erfordert, dass
der Display-Manager später mit <prgn>dpkg-reconfigure</prgn> gesetzt wird.
Alles andere sind allgemeine Methoden, um Daemonen zu deaktivieren.
<p>
Sie können immer noch X mit dem Kommando <prgn>startx</prgn> von einer
beliebigen Konsole starten.
</sect1>

<sect1 id="bootprompt">Weitere Tricks mit dem Boot-Prompt
<p>
Mittels des <prgn>lilo</prgn>-Boot-Prompts kann das System in einem
beliebigen Runlevel gestartet werden. Details dazu finden sich im
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> des LDP.
<p>
Soll das System im Runlevel 4 starten, verwenden Sie folgende Eingabe am
<prgn>lilo</prgn>-Boot-Prompt.
<example>
boot: Linux 4
</example>
<p>
Wenn das System im normal funktionierendem Einzelnutzer-Modus gestartet werden
soll und Sie das root-Passwort kennen, so kann eins der folgenden Beispiele
am <prgn>lilo</prgn>-Boot-Prompt verwendet werden.
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Auch der benutzte Speicherbereich kann eingeschränkt werden. Das folgende
Beispiel weist das System an, nur 48MB des verfügbaren Speichers zu 
belegen.
<example>
boot: Linux mem=48M
</example>
Achtung: Wird an dieser Stelle mehr Speicher angegeben als vorhanden, wird
der Kernel abstürzen. Wenn man mehr als 64 MB Speicher hat, kann es bei
alten Kernels und/oder Mainboards passieren, dass das System nur 64MB nutzt.
In diesem Fall kann man versuchen den ungenutzten Speicher mit
<tt>mem=128M</tt> zu aktivieren. Äquivalent dazu ist ein Eintrag in der
Datei <file>/etc/lilo.conf</file>.
</sect1>

<sect1 id="bootgrub">Setzen von GRUB-Boot-Parametern
<p>
GRUB ist ein neuer Boot-Manager des GNU Hurd-Projekts und ist viel flexibler
als Lilo, handhabt aber die Boot-Parameter etwas anders.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Sie müssen die Hurd-Gerätenamen kennen:
<example>
Hurd/GRUB           Linux               MS-DOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,0)             /dev/hda1           C: (normalerweise)
 (hd0,3)             /dev/hda4           F: (normalerweise)
 (hd1,3)             /dev/hdb4           ?
</example>
Vergleichen Sie <file>&f-grub;</file> und <file>&f-grub-doc;</file> für
Details.
</sect>

<sect>Aufzeichnung von Aktivitäten

<sect1 id="script">Aufzeichnen von Shell-Eingaben 
<p>
Um ein Unix-artiges System gekonnt zu administrieren, sind mitunter
knifflige oder raffinierte Aufgaben zu erledigen. Machen Sie sich
deshalb mit den grundlegenden Konfigurationsaufgaben vertraut, so 
dass Sie im Notfall wissen, wo Sie Hand anlegen müssen.
Fensterbasierte Konfigurations-Werkzeuge sind nett und bequem, nutzen
aber nichts, wenn man versucht eine defekte X-Window-Konfiguration
wieder herzustellen.
<p>
Die Aufzeichnung von Tastatur-Eingaben ist, insbesondere als root, 
hin und wieder nützlich.
<p>
Emacs: M-x <tt>shell</tt> startet die Aufzeichnung. ("M" steht hier für
die Meta-Taste, meist Alt oder auch Esc.) C-x C-w schreibt die
aufgezeichnete Sequenz in eine Datei.
<p>
Shell: Verwenden Sie das <prgn>screen</prgn>-Kommando mit "^A H", wie in
<ref id="screen"> beschrieben oder das <prgn>script</prgn>-Kommando. 
<example>
$ script
Script wurde gestartet, die Datei ist typescript
 ... irgendwelche Eingaben ...
 Strg-D
$ col -bx &lt;typescript &gt;Sicherung
$ vi Sicherung
</example>
Falls das <prgn>script</prgn>-Programm fehlt, kann diese Funktion mit
der Shell simuliert werden:
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>X-Aktivitäten aufzeichnen
<p>
Um den grafischen Bildschirm aufzunehmen, auch X-Terminals und andere
beliebige Fenster, kann <prgn>gimp</prgn> benutzt werden. 
Alternativen sind <prgn>xwd</prgn>
(<package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>) und <prgn>scrot</prgn>
(<package>scrot</package>). 
</sect1>

</sect>

<sect id="archiving">Kopieren und Archivieren eines Unterverzeichnis
<p>
Diese Kopier- und Archivierungskommandos bieten die Grundlagen für eine
Sicherung des Systems und der Daten. Ein Beispiel eines einfachen
Backup-Skripts findet sich unter dem Namen <prgn>backup</prgn> in den 
<url id="&examples;" name="Beispielskripten">.

<sect1>Grundlegende Kommandos zum Kopieren eines Unterverzeichnis
<p>
Möchte man seine Verzeichnisstruktur neu arrangieren, verschiebt man den
Inhalt inklusive Datei-Links wie folgt:
<example>
Standardmethode:
# cp -a /source/directory /dest/directory # erfordert GNU cp
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
Wenn ein harter Link beteiligt ist, benötigt man eine pedantische
Methode:
# cd /Pfad/zum/alten/Verzeichnis
# find . -depth -print0 | afio -p -xv -0a /neues/Verzeichnis
Vom entfernten Rechner:
# (cd /Quell/Verzeichnis &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /Ziel/Verzeichnis &amp;&amp; tar xvfp - )
Wenn es keine Links gibt:
# scp -pr user1@host1.dom:/Quell/Verzeichnis \
          user2@host2.dom:/Ziel/Verzeichnis
</example>
<p>
Die folgenden vergleichenden Informationen zum Kopieren eines kompletten
Unterverzeichnis wurden von Manoj Srivastava
<email>srivasta@debian.org</email> auf debian-user@lists.debian.org
aufgeführt.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Ursprünglich war das Programm <prgn>cp</prgn> für diesen Zweck nicht gut 
geeignet, da es keine symbolischen Links auflösen oder harte Links
beibehalten konnte. Ein anderer Punkt waren spärliche (sparse) Dateien
(Dateien mit Löchern).
<p>
Die GNU-Version von <prgn>cp</prgn> überwand zwar diese Probleme, doch auf
nicht-GNU-Systemen kann es noch zu Schwierigkeiten kommen. Des Weiteren kann
<prgn>cp</prgn> keine kleinen, portablen Archive erzeugen.
<example>
&percnt; cp -a . neuesverzeichnis
</example>

<sect1><prgn>tar</prgn>
<p>
Das Archivierungsprogramm <prgn>tar</prgn> kann im Gegensatz zu
<prgn>cp</prgn> mit symbolischen Links umgehen. Obwohl <prgn>cpio</prgn>
mit speziellen Dateien umgehen kann, konnten ältere <prgn>tar</prgn>-Versionen
dies nicht.
<p>                                                             
Wenn <prgn>tar</prgn> auf mehrere harte Links einer Datei stößt, wird
nur einmal die Datei in das Archiv kopiert; die Datei kann dann <em>nur</em>
unter dem Namen der ursprünglichen Datei zurückgewonnen werden.
<prgn>cpio</prgn> dagegen kopiert für jeden harten Link die komplette Datei
in das Archiv, so dass sie unter jedem der Link-Namen wiedergeholt werden
kann.
<p>
Das Kommando <prgn>tar</prgn> hat die Option für das Packen mit
<file>.bz2</file>-Dateien zwischen Potato und Woody umbenannt. Empfohlen wird
deshalb in Skripten die Option <tt>--bzip2</tt> statt der Kurzform <tt>-I</tt>
(Potato) oder <tt>-j</tt> (Woody).
</sect1>

<sect1><prgn>pax</prgn>
<p>
Hinter dem Namen <prgn>pax</prgn> (IEEE-Standard 1003.2-1992, 
Seiten 380&ndash;388 (Abschnitt 4.48) und Seiten 936&ndash;940 (Abschnitt
E.4.48)) verbirgt sich ein multifunktionales POSIX-Werkzeug zum Austausch von
portablen Archiven.
<prgn>pax</prgn> liest und schreibt Archive, listet deren Inhalt auf
und kopiert Verzeichnishierarchien. <prgn>pax</prgn> arbeitet unabhängig von
einem spezifischen Archivformat und unterstützt eine große Bandbreite an
Formaten.
<p>
<prgn>pax</prgn> ist noch neu und es können noch Kinderkrankheiten
auftreten.
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 oder
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
Das Kommando verwaltet die gleichnamigen Archive oder auch solche, die
mit <prgn>tar</prgn> erstellt wurden.
Das Archiv kann statt einer Datei auch eine Pipe oder ein Magnetband sein.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> ersetzt <prgn>cpio</prgn>. Es liest dessen Archive
schneller, unterstützt mehr Laufwerksoptionen, hat eine bessere Fehlerkorrektur
und kann das Archiv auf mehrere Medien verteilen. Die Kompression mit
<prgn>afio</prgn> ist zuverlässiger als die von <prgn>tar</prgn> und
<prgn>cpio</prgn>. Am besten benutzt man <prgn>afio</prgn> in 
Backup-Skripts als "Archiv-Maschinerie".
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
Ich mache alle meine Backups auf Band mit <prgn>afio</prgn>. 
</sect1>
</sect>

<sect id="diff-backup">Differenzielles Backup und Datensynchronisation
<p>
Differenzielle Backups und Datensynchronisation kann mit verschiedenen
Methoden implementiert werden:
<list>
<item><package>rcs</package>:  Backups, auch mehrerer älterer Versionen, nur
      für Texte
<item><package>rdiff-backup</package>: Backups, auch mehrerer älterer
      Versionen. Symbolische Links werden unterstützt.
<item><package>pdumpfs</package>: Backups, auch mehrerer älterer Versionen
      in einem Dateisystem. Symbolische Links werden unterstützt.
<item><package>rsync</package>:  1-Weg-Synchronisation
<item><package>unison</package>:  2-Wege-Synchronisation
<item><package>cvs</package>:  Mehr-Wege-Synchronisation mit
      Server-Backups, auch mehrerer älterer Versionen, nur für Texte,
      ausgereift. Vergleichen Sie mit <ref id="cvs">.
<item><package>arch</package>:  Mehr-Wege-Synchronisation mit Server-Backups,
      auch mehrerer älterer Versionen. Es gibt keine Dinge wie
      "Arbeitsverzeichnis".
<item><package>subversion</package>: Mehr-Wege-Synchronisation mit 
      Server-Backups, auch mehrerer älterer Versionen, Apache.
</list>
Kombinationen einer dieser Methoden mit der Archivierungsmethode, die in
<ref id="archiving"> beschrieben ist, und den automatisierten Jobs in
<ref id="cronjob"> bilden ein nettes Backup-System.
<p>
Ich werde drei einfach zu nutzende Hilfsmittel angeben.

<sect1 id="rdiff-backup">Differenzielles Backup mit rdiff
<p>
<package>rdiff-backup</package> bietet ein nettes und einfaches Backup mit
differenziellen Versionen für beliebige Dateitypen, inklusive symbolischen
Links. Sichern des Großteils von <file>~/</file> nach <file>/mnt/backup</file>:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
Wiederherstellen von drei Tage alten Daten aus diesem Archiv nach
<file>~/old</file>:
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
Vergleichen Sie <manref name="rdiff-backup" section="1">.

<sect1 id="pdumpfs-backup">Tägliches Backup mit <package>pdumpfs</package>
<p>
<package>pdumpfs</package> ist ein einfaches System zum täglichen Backup,
ähnlich zu Plan9s <prgn>dumpfs</prgn>, das tägliche Schnappschüsse bewahrt.
Man kann auf die letzten Schnappschüsse zu beliebiger Zeit zugreifen, um eine
Datei eines bestimmten Tages wiederherzustellen. Führen Sie ein Backup Ihres
Homeverzeichnisses mit <prgn>pdumpfs</prgn> und <prgn>cron</prgn> aus!
<p>
<prgn>pdumpfs</prgn> erstellt die Schnappschüsse <tt>YYYY/MM/DD</tt> im
Zielverzeichnis. Alle Quelldateien werden in das Schnappschussverzeichnis
kopiert, wenn <prgn>pdumpfs</prgn> das erste Mal gestartet wird. Beim zweiten
und folgenden Male kopiert <prgn>pdumpfs</prgn> nur aktualisierte oder neu
erstellte Dateien und speichert nicht geänderte Dateien als harte Links auf
die Dateien vom Schnappschuss des letzten Tages, um Speicherplatz zu sparen.
<example>
$ pdumpfs <var>src-dir</var> <var>dest-dir</var> [<var>dest-basename</var>]
</example>
Vergleichen Sie <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">Regelmäßige differenzielle Backups mit RCS
<p>
<package>Changetrack</package> zeichnet Änderungen von textbasierten
Konfigurationsdateien regelmäßig in RCS-Depots auf.  
Lesen Sie <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>

<sect>Wiederherstellen eines eingefrorenen Systems
<sect1 id="kill">Einen Prozess killen/beenden
<p>
<prgn>top</prgn> hilft außer Kontrolle geratene
Prozesse zu identifizieren. `P' sortiert die Spalten nach CPU-Last, `M'
nach Speicherverbrauch und `k' kann einen Prozess "abschießen".
Alternativ kann das BSD-artige <tt>ps aux | less</tt> oder System V-artige
<tt>ps -efH | less</tt> verwendet werden. Die System V-artige Syntax zeigt
die IDs der Elternprozesse (<tt>PPID</tt>), die zum Killen von
Zombie-Kindprozessen genutzt werden können.
<p>
Verwenden Sie <prgn>kill</prgn> zum Killen eines Prozesses mittels der
Prozess-ID-Nummer (oder um ihm Signale zu senden). <prgn>killall</prgn>
bewerkstelligt dasselbe über den Namen des Programms. Oft verwendete
Signale sind
<example>
 1: HUP,  Daemon neustarten
15: TERM, normales Beenden
 9: KILL, erzwungenes Beenden
</example>

</sect1>

<sect1>Alt-SysRq
<p>
Wenn der Kernel mit Unterstützung der "magischen SysRq-Taste" kompiliert
wurde, kann das System mit etwas Glück auch aus dem totalen Nirwana geholt
werden. Drücken von Alt-SysRq (SysRq ist oft mit "Druck" beschriftet) bei
einem i386, gefolgt von einer der Tasten
<tt>r 0 k e i s u b</tt>, aktiviert die Kernel-Notbremse.
<p>
`r' (un`r'aw) stellt die Tastatur wieder her, nachdem beispielsweise X abgestürzt ist.
`0' setzt das Level, mit dem Fehlermeldungen auf der Konsole ausgegeben
werden, herunter. `k' (sa`k', system attention key) killt alle Prozesse auf der
aktuellen virtuellen Konsole. `e' (t`e'rminate) beendet alle Prozesse des aktuellen
Terminals außer <prgn>init</prgn>. `i' (k`i'll) killt alle Prozesse außer
<prgn>init</prgn>.
<p>
`S'ync, `u'mount und re`b'oot sind wirklich nur für den allerletzten
Notfall.
<p>
Detaillierte Informationen finden sich in 
<file>/usr/share/doc/kernel-doc-<var>version</var>/Documentation/sysrq.txt.gz</file>
oder
<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>


<sect id="nifty">Elegante kleine Kommandos zum Merken

<sect1>Dateibetrachter
<p>
<prgn>less</prgn> ist der Standard-Dateibetrachter, der Textdateien seitenweise
ausgibt. Hilfe bietet `h'. <prgn>less</prgn> kann mehr als dessen Urahn 
<prgn>more</prgn>. Es kann mit <tt>eval $(lesspipe)</tt> oder <tt>eval
$(lessfile)</tt> in einer Shell-Startdatei überladen (erweitert) werden.
Sehen Sie hierzu <file>&f-lessopen;</file>. Die Option <tt>-R</tt> erlaubt die
Ausgabe von Sonderzeichen (raw characters) und schaltet die ANSI-Farbsequenzen
ein. Vergleichen Sie <manref name="less" section="1">.
<p>
<prgn>w3m</prgn> kann für einige Code-Systeme (EUC) eine Alternative sein.

<sect1>Freier Speicher
<p>
<prgn>free</prgn> und <prgn>top</prgn> informieren über freien Speicher und
dessen Verbrauch. Sorgen Sie sich nicht um die Größe des "used"-Eintrags in
der zweite Datenzeile, sondern lesen Sie den Wert darunter ab (hier: 38792)
<example>
$ free -k # für 256MB Hauptspeicher
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
Die präzise Menge an Hauptspeicher, die zur Verfügung steht, kann mit
<tt>grep '^Memory' /var/log/dmesg</tt> bestätigt werden, was in diesem Fall
"Memory: 256984k/262144k available (1652k kernel code, 412k reserved,
2944k data, 152k init)" ergibt.
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Etwa 5MB können nicht vom System verwendet werden, da der Kernel sie in
Beschlag nimmt.
</sect1>

<sect1>Setzen der Uhrzeit (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
Dies setzt die Hardware-Uhr auf MM/DD hh:mm, CCYY. Dabei stehen die Kürzel
für DD=Tag, MM=Monat, hh=Stunde, mm=Minute, CCYY=Jahr. Die Zeiten werden in
lokaler Zeit ausgegeben, die Hardware-Uhr verwendet jedoch UTC als Zeitzone.
<p>
Falls die Hardware-Zeit (BIOS) auf GMT gesetzt ist, muss  
<tt>UTC=yes</tt> in <file>/etc/default/rcS</file> eingetragen sein.

<sect1>Setzen der Uhrzeit (NTP)
<p>
Referenz: <url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">.
<p>
<sect2>Setzen der Zeit bei permanenter Internet-Verbindung
<p>
Die Uhrzeit kann automatisch mit Hilfe eines Zeit-Servers korrekt gesetzt
werden:
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
Dies sollte in <file>/etc/cron.daily/</file> verwendet werden, wenn man eine
permanente Internet-Verbindung hat.

<sect2>Setzen der Uhrzeit bei sporadischer Internet-Verbindung
<p>
Das Paket <package>chrony</package> hilft hier weiter.
</sect1>

<sect1 id="setterm">Konsole-Eigenschaften wie den Bildschirmschoner steuern
<p>
Zum Deaktivieren des Bildschirmschoners sind folgende Kommandos geeignet:
<p>
Auf der Konsole:
<example>
# setterm -powersave off
</example>
<p>
Start der kon2 (kanji) Konsole mit:
<example>
# kon -SaveTime 0
</example>
<p>
Während X-Windows läuft:
<example>
# xset s off
 oder
# xset -dpms
 oder
# xscreensaver-command -prefs
</example>
Lesen Sie die entsprechenden Handbuchseiten, um zu erfahren, wie man andere
Eigenschaften der Konsole steuert. Vergleichen Sie auch <manref name="stty"
section="1"> zum Ändern und zur Ausgabe von Terminal-Line-Einstellungen.
</sect1>

<sect1 id="getent">Durchsuchen von Datenbanken zur Systemverwaltung
<p>
Die glibc-Bibliothek ermöglicht das Durchsuchen von System-Datenbanken,
nach beispielsweise passwd, group, hosts, services, protocols oder networks
mittels <manref name="getent" section="1">.
<example compact>
getent database [key ...]
</example>

<sect1>Sound abstellen (beep)
<p>
Im Zweifelsfall kann man immer den Stecker des Lautsprechers herausziehen
;-) Für die Bash-Shell gilt:
<example>
echo "set bell-style none" &gt;&gt; ~/.inputrc
</example>
<!-- FIXME: xset b off für X erwähnen -->
</sect1>

<sect1>Fehlermeldungen auf der Konsole
<p>
Wenn übermäßig viele Fehlermeldungen die Konsole unbrauchbar werden lassen,
sollte man zuerst in <file>/etc/init.d/klogd</file> nachsehen. Um das
Warnlevel zu ändern, kann man <tt>KLOGD="-c <var>3</var>"</tt> setzen.
Neustart des Daemons mit <file>/etc/init.d/klogd restart</file> aktiviert
die neuen Werte. Alternativ kann <tt>dmesg -n<var>3</var></tt> benutzt
werden.
<p>
Das Warnlevel schlüsselt sich wie folgt auf:
<list compact>
<item>0: KERN_EMERG,   System ist unbenutzbar
<item>1: KERN_ALERT,   sofortiger Eingriff nötig
<item>2: KERN_CRIT,    kritischer Zustand
<item>3: KERN_ERR,     Fehler
<item>4: KERN_WARNING, Warnung
<item>5: KERN_NOTICE,  normale aber bedeutende Nachricht
<item>6: KERN_INFO,    Information
<item>7: KERN_DEBUG,   reine Debug-Nachricht
</list>
<p>
Wenn eine bestimmte unkritische Fehlermeldung oft auftritt,
kann diese auch durch einen trivialen Kernelpatch unterbunden werden. (Siehe
dazu das Beispiel <file>shutup-abit-bp6</file> im 
<url id="&examples;" name="Beispielverzeichnis">.)
<p>
Auch ein Blick in <file>/etc/syslog.conf</file> kann hilfreich sein, um zu
verstehen, welche Nachrichten auf der Konsole ausgegeben werden.
</sect1>

<sect1>Setzen des korrekten Konsole-Typs
<p>
Die Konsole wird in Unix-artigen Systemen üblicherweise mit den Routinen
aus der (n)curses-Bibliothek angesteuert. Dies erlaubt eine im Wesentlichen
von der Terminal-Art unabhängige Ausgabe mit vernünftiger Update-Strategie.
Siehe <manref name="ncurses" section="3X"> und
<manref name="terminfo" section="5">.
<p>
&debian; bietet eine ganze Reihe von Voreinstellungen:
<example>
$ toe | less                  # alle Einträge
$ toe /etc/terminfo/ | less   # durch Benutzer einstellbare Einträge
</example>
Die Auswahl kann durch Export der Umgebungsvariablen <tt>TERM</tt>
aktiviert werden.
<p>
Wenn der terminfo-Eintrag für <prgn>xterm</prgn> mit einem <prgn>xterm</prgn>,
das remote aufgerufen wird und das nicht auf Debian läuft, nicht funktioniert,
kann der Terminaltyp von "xterm" auch auf eine der primitiveren Varianten,
wie "xterm-r6", umgestellt werden.
Sehen Sie <file>&f-libncurse;</file> für weitere Informationen.
Der kleinste gemeinsame Nenner für terminfo ist "dumb".
</sect1>

<sect1>Die Konsole wiederherstellen
<p>
Ist der Bildschirm auf Grund von <tt>cat <var>Binärdatei</var></tt>
unleserlich (und sogar eingetippte Kommandos sind nicht sichtbar), so hilft:
<example>
$ reset
</example>
</sect1>

<sect1 id="dos2unix">Konvertieren einer Textdatei von DOS nach Unix
<p>
Eine DOS-Textdatei (Zeilenende von <tt>^M^J</tt>),
kann mit einem einzigen Kommando in eine Unix-Textdatei (Zeilenende =
<tt>^J</tt>) umgewandelt werden:
<example>
# apt-get install sysutils
$ dos2unix <var>DOS-Datei</var>
</example>
</sect1>

<sect1 id="recode">Konvertierung einer Textdatei mit <prgn>recode</prgn>
<p>
Folgendes wird Textdateien zwischen DOS-, Mac- und Unix-Zeilenende-Stilen
umwandeln:
<example>
$ recode /cl../cr &lt;<var>dos.txt</var> &gt;<var>mac.txt</var>
$ recode /cr.. &lt;<var>mac.txt</var> &gt;<var>unix.txt</var>
$ recode ../cl &lt;<var>unix.txt</var> &gt;<var>dos.txt</var>
</example>
<!-- FIXME: free, surface? -->
Das freie <prgn>recode</prgn> konvertiert Dateien zwischen verschiedenen
Zeichensätzen und Surfaces mittels:
<example>
$ recode <var>Zeichensatz1</var>/<var>Surface1</var>..<var>Zeichensatz2</var>/<var>Surface2</var> \
  &lt;<var>Eingabe.txt</var> &gt;<var>Ausgabe.txt</var>
</example>
Üblicherweise verwendete Zeichensätze sind (siehe auch
<ref id="base-locale">)<footnote>
<prgn>recode</prgn> erlaubt gebräuchlichere Bezeichnungen als <prgn>iconv</prgn>.
</footnote>:
<list compact>
<item><tt>us</tt> &mdash; ASCII (7 Bit)
<item><tt>l1</tt> &mdash;  ISO Latin-1 (ISO-8859-1, westliches Europa, 8 Bit)
<item><tt>KOI8-RU</tt> &mdash; KOI8-RU für Russisch (Unix)
<!-- TODO: Microsoft Russisch -->
<item><tt>SJIS</tt> &mdash; Shift-JIS für Japanisch (Microsoft)
<item><tt>ISO2022JP</tt> &mdash; E-Mail-Kodierung für Japanisch (7 Bit)
<item><tt>u2</tt> &mdash; UCS-2 (Universal Character Set, 2 Byte)
<item><tt>u8</tt> &mdash; UTF-8 (Universal Transformation Format, 8 Bit)
</list>
Gebräuchliche Surfaces sind<footnote>
Zeilenenden:
<list compact>
<item>Wagenrücklauf (carriage return) bedeutet ASCII 13, ASCII 0xD, ^M und \r.
<item>Zeilenumbruch (line feed) bedeutet ASCII 10, ASCII 0xA, ^J und \n.
</list>
</footnote>:
<list compact>
<item><tt>/cr</tt> &mdash; Wagenrücklauf als Zeilenende (Mac-Text)
<item><tt>/cl</tt> &mdash; Wagenrücklauf und Zeilenumbruch als Zeilenende (DOS-Text)
<item><tt>/</tt> &mdash; Zeilenumbruch als Zeilenende (Unix-Text)
<item><tt>/d1</tt> &mdash; Menschenlesbare Byte-weise Dezimalausgabe
<item><tt>/x1</tt> &mdash; Menschenlesbare Byte-weise Hexadezimalausgabe
<item><tt>/64</tt> &mdash; Base64-kodierter Text
<item><tt>/QP</tt> &mdash; Quoted-Printable-kodierter Text
</list>
Weitere Informationen finden sich in der entsprechenden Beschreibung in
<tt>info recode</tt>.
<p>
Es gibt auch spezialisiertere Konvertierungswerkzeuge:
<list compact>
<item>Zeichensatzkonvertierung:
<list compact>
<item><prgn>iconv</prgn> &mdash; Locale-Kodierungskonvertierungen
<item><prgn>konwert</prgn> &mdash; raffinierte Kodierungskonvertierungen
</list>
<item>Binärdateikonvertierung:
<list compact>
<item><prgn>uuencode</prgn> und <prgn>uudecode</prgn> &mdash; für Unix.
<item><prgn>mimencode</prgn> &mdash; für E-Mails.
</list>
</list>
</sect1>

<sect1 id="perl-i">Ersetzung regulärer Ausdrücke
<p>
Alle Vorkommen des regulären Ausdrucks <var>REGEX</var> können durch
<var>TEXT</var> in allen Dateien <var>DATEIEN</var> ersetzt werden durch:
<example>
$ perl -i -p -e 's/<var>REGEX</var>/<var>TEXT</var>/g;' <var>DATEIEN</var> ...
</example>
<tt>-i</tt> zeigt an, dass die Orginaldateien bearbeitet werden, 
<tt>-p</tt> sorgt ausdrücklich für die Iteration über die Dateinamen. Wenn
der reguläre Ausdruck kompliziert ist, kann man sich versichern, indem man
die Originaldateien behält: Durch <tt>-i.bak</tt> anstelle von <tt>-i</tt>
bleiben die Originale erhalten und bekommen die Endung <tt>.bak</tt>.
</sect1>

<sect1>Bearbeiten einer Datei mittels eines Skripts
<p>
Das folgende Skript entfernt die Zeilen 5&ndash;10 und 16&ndash;20 ohne Umweg
über eine temporäre Datei.
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
Die <prgn>ed</prgn>-Kommandos sind die selben wie beim <prgn>vi</prgn> im
Kommandomodus. Das Bearbeiten der Datei von hinten erleichtert die Arbeit.
</sect1>

<sect1>Extrahieren von Unterschieden und Einbringen von Updates für
       Quelldateien
<p>
Die folgenden Kommandos bestimmen die Unterschiede zwischen zwei Quelldateien
und erzeugen diff-Dateien <var>Datei.patch1</var> und <var>Datei.patch2</var>
im "unified"-Stil:
<example>
$ diff -u <var>Datei.alt</var> <var>Datei.neu</var> &gt; <var>Datei.patch1</var>
$ diff -u <var>alt/Datei</var> <var>neu/Datei</var> &gt; <var>Datei.patch2</var>
</example>
Die Diff-Datei (alternativ wird sie auch Patch-Datei genannt) wird verwendet,
um Veränderungen zu beschreiben. Jeder der diese Datei erhält, kann diese
Änderungen auf eine andere Datei wie folgt anwenden:
<example>
$ patch -p0 <var>Datei</var> &lt; <var>Datei.patch1</var>
$ patch -p1 <var>Datei</var> &lt; <var>Datei.patch2</var>
</example>
Wenn drei Versionen des Quellcodes vorliegen, können diese einfacher mit
<prgn>diff3</prgn> vermengt werden:
<example>
$ diff3 -m <var>Datei.meine</var> <var>Datei.alt</var> <var>Datei.deine</var> &gt; <var>Datei</var>
</example>
</sect1>

<sect1>Eine große Datei in kleine zerlegen
<p>
<example>
$ split -b 650m <var>Datei</var>   # in 650MB große Stücke trennen
$ cat x* &gt;<var>großeDatei</var>    # wieder zusammenfügen
</example>
</sect1>

<sect1>Extrahieren von Daten aus Tabellen in Textdateien
<p>
Sei <file>DPL</file> der Name einer Textdatei, in welcher alle vorherigen
&debian;-Projektleiter mit Namen und Einführungsdatum, durch Freizeichen
getrennt, aufgeführt sind.
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   Januar  1998
Wichert Akkerman  Januar  1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr März    2003
</example>
Awk wird oft benutzt, um Daten aus dieser Art von Datei zu extrahieren.
<example>
$ awk '{ print $3 }' &lt;DPL                   # Monat des Beginns
August
April
Januar
Januar
April
April
März
$ awk '($1=="Ian") { print }' &lt;DPL          # Vorname Ian
Ian     Murdock   August  1993
Ian     Jackson   Januar  1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # wann fing Perens an
April 1996
</example>
<p>
Shells wie Bash sind ebenfalls in der Lage, Dateien dieser Art auszulesen:
<example>
$ while read Vorname Nachname Monat Jahr; do 
    echo $Monat
  done &lt;DPL
... selbe Ausgabe wie beim ersten Awk-Beispiel
</example>
Das eingebaute Kommando <prgn>read</prgn> verwendet die Zeichen in $IFS 
(interne Feld-Separatoren), um Zeilen in Wörter aufzuteilen.
<p>
Wenn IFS auf ":" gesetzt wird, kann <file>/etc/passwd</file> leicht mit der
Shell ausgelesen werden:
<example>
$ altIFS="$IFS"   # alten Wert sichern
$ IFS=":"
$ while read Benutzer Passwort uid gid Zeilenrest; do
    if [ "$Benutzer" = "osamu" ]; then 
      echo "$Benutzer's ID ist $uid"
    fi
  done < /etc/passwd
osamu's ID ist 1001
$ IFS="$altIFS"   # Wert zurücksetzen
</example>
(Wenn Awk dazu verwendet wird, so wird der Spaltentrenner mit <tt>FS=":"</tt>
angegeben.)
<p> 
IFS wird auch von der Shell benutzt, um die Ergebnisse von
Parameterauswertungen, Kommando-Substitutionen und arithmetischen
Auswertungen aufzuteilen. Dies geschieht nicht innerhalb von doppelten oder
einfachen Anführungszeichen. Der Standardwert von IFS sind die Werte
&lt;Leerzeichen&gt;, &lt;Tabulator&gt; und &lt;neue Zeile&gt;.
<p>
Man muss bei der Verwendung von IFS-Tricks vorsichtig sein. Eigenartige Dinge
können geschehen, wenn die Shell Teile eines Skripts als
<strong>Eingabe</strong> interpretiert.
<example>
$ IFS=":,"                        # ":" und "," seien Feldtrenner
$ echo IFS=$IFS,   IFS="$IFS"     # echo ist ein Bash Kommando
IFS=  , IFS=:,
$ date -R                         # nur eine Kommandoausgabe
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # Untershell --&gt; Eingabe der Haupt-Shell
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # zurücksetzen von IFS auf den Standardwert
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>
</sect1>


<sect1 id="scrp-snip">Skript-Auszüge für Pipe-Kommandos
<p>
Hier folgen einige kleine lehrreiche Beispiele zur Verwendung von Pipes:
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # Finde alle Dateien unterhalb /usr 
                     # mit Ausnahme bestimmter Pfade
xargs -n 1 <var>Kommando</var>  # Starte Kommando für alle Eingaben von stdin
xargs -n 1 echo |    # Beliebige Leerzeichen werden zu Zeilenumbrüchen
xargs echo      |    # alle Zeilen zu einer zusammenfassen
grep -e <var>Muster</var>|     # Gebe Zeilen aus, die <var>Muster</var> 
                     # enthalten
cut -d: -f3 -|       # gebe das dritte Feld aus, : sei Trenner  
                     # (z.B. für die Passwortdatei passwd)
awk '{ print $3 }' | # extrahiere das dritte Feld, Freizeichen sei Trenner
awk -F'\t' '{ print $3 }' |
                     # gib drittes Feld aus mit Tab als Trenner
col -bx |            # Entferne Backspace und expandiere Tabs zu Leerzeichen
expand -|            # expandiere Tabs zu Leerzeichen
sort -u|             # Sortiere und entferne doppelte Einträge

tr '\n' ' '|         # mehrere Zeilen zu einer zusammenfügen
tr '\r' ''|          # CR entfernen
tr 'A-Z' 'a-z'|      # Großbuchstaben in Kleinbuchstaben umwandeln
sed 's/^/# /'|       # aus der Zeile einen Kommentar machen
sed 's/\<var>.ext</var>//g'|    # Entferne <var>.ext</var>
sed  -n -e 2p|       # zeige die zweite Zeile
head -n 2 -|         # zeige die ersten beiden Zeilen
tail -n 2 -|         # zeige die letzten beiden Zeilen
</example>
</sect1>

<sect1>Skript-Auszüge zum Durchlaufen mehrerer Dateien
<p>
Die folgenden Möglichkeiten zum Durchlaufen aller auf
<tt>*.<var>ext</var></tt> passenden Dateien sind auch dann geeignet, wenn
die Dateinamen Sonderzeichen wie Leerzeichen enthalten und bewirken alle
dasselbe:
<list>
<item>Shell-Schleife (Dieses Beispiel verwendet mehrere Zeilen mit
<tt>PS2=" "</tt>. Um dasselbe in einer Zeile zu erreichen, muss ein Semikolon
für jeden Zeilenumbruch eingefügt werden.):
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>Kommando</var> "$<var>x</var>"
  fi
done
</example>
<item><prgn>find</prgn> und <prgn>xargs</prgn> Kombination:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>Kommando</var>
</example>
<item><prgn>find</prgn> mit <tt>-exec</tt> Option mit einem Kommando:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>Kommando</var> '{}' \;
</example>
<item><prgn>find</prgn> mit <tt>-exec</tt> Option mit einem kurzen Shell-Skript:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>Kommando</var> '{}' && echo 'erfolgreich'" \;
</example>
</list>
</sect1>

<sect1 id="perl-mad">Kurze Perl-Skripte
<p>
Obwohl jedes Awk-Skript automatisch in ein Perl-Skript mittels
<manref name="a2p" section="1"> umgeschrieben werden kann, sollten einzeilige
Awk-Skripte am besten manuell nach Perl konvertiert werden. Zum Beispiel ist
<example>
awk '($2=="1957") { print $3 }' |
</example>
äquivalent zu allen der folgenden Zeilen:
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
Da alle Leerräume im <prgn>perl</prgn>-Argument in der obigen Zeile entfernt
werden können und unter Ausnutzung der automatischen Umwandlung zwischen
Zahlen und Zeichenketten in Perl kann auch Folgendes verwendet werden:
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
Man vergleiche <manref name="perlrun" section="1"> für die
Kommandozeilenoptionen. Für noch verrücktere Perl-Skripte wird auf
<url id="&perlgolf;"> verwiesen.
</sect1>

<sect1>Text oder ein Mailinglistenarchiv aus einer Webseite extrahieren
<p>
Das Folgende liest eine Webseite aus und schreibt die Ausgabe in eine
Textdatei. Dies ist sehr nützlich, wenn man Konfigurationen aus dem Web
kopieren will.
<example>
$ lynx -dump http://<var>www.adresse.de/info.html</var> &gt;<var>Textdatei</var>
</example>
<prgn>links</prgn> und <prgn>w3m</prgn> können hier auch verwendet werden,
die Ergebnisse sich aber eventuell leicht unterschiedlich.
<p>
Falls ein Archiv einer Mailingliste geladen wird, kann <prgn>munpack</prgn>
benutzt werden, um den MIME-Inhalt zu extrahieren.
</sect1>

<sect1>Formatierte Ausgabe von Webseiten
<p>
Um eine Webseite zu drucken, kann diese in das PostScript-Format umgewandelt
werden:
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Man vergleiche <ref id="lprlpd">.  Alternativ können auch das
<prgn>a2ps</prgn> oder <prgn>mpage</prgn> Paket zum Erzeugen von
PostScript-Dateien verwendet werden.
</sect1>

<sect1>Formatierte Ausgabe einer Handbuchseite
<p>
Das Folgende druckt eine Handbuchseite in eine PostScript-Datei/Drucker.  
<example>
$ man -Tps <var>some-manpage</var> | lpr
$ man -Tps <var>some-manpage</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Vermengen zweier PostScript- oder PDF-Dateien
<p>
Zwei PostScript- oder PDF-Dateien können wie folgt zu einer zusammengefasst
werden:
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>

<sect1>Ausführungsdauer messen
<p>
Um die verschiedenen Zeiten, die mit einem Prozessablauf verbunden sind,
anzuzeigen, kann <prgn>time</prgn> verwendet werden.
<example>
# time <var>some-command</var> &gt;/dev/null
real    0m0.035s       # "Echte" Zeit
user    0m0.000s       # Zeit in Benutzermodus
sys     0m0.020s       # Zeit in Kernelmodus
</example>
</sect1>

<sect1><prgn>nice</prgn>-Befehl
<p>
Der <prgn>nice</prgn>-Befehl dient dazu, die Priorität eines Prozesses zu
setzen. Dessen Verwandter <prgn>renice</prgn> (Paket
<package>bsdutils</package>) ändert die Priorität eines bereits laufenden
Prozesses. Letzteres kann auch aus <prgn>top</prgn> heraus geschehen. Ein
<prgn>nice</prgn>-Wert von 19 bedeutet niedrigste Priorität &ndash; der Prozess
ist langsam &ndash;, absteigend wird die Priorität erhöht. Kleinere Werte als 0
kann nur der Administrator setzen, -20 ist die höchste Priorität.
<example>
# nice  -19 <var>top</var>                                      # sehr nett
# nice --20 <var>wodim -v -eject speed=2 dev=0,0 disk.img</var> # sehr schnell
</example>
Manchmal kann ein sehr langsamer Prozess dem System mehr schaden als
nützen, also ist Vorsicht geboten.
</sect1>

<sect1 id="cronjob">Terminplanung für Prozesse (<prgn>cron</prgn>,
                    <prgn>at</prgn>)
<p>
Mit <prgn>cron</prgn> und <prgn>at</prgn> können zu bestimmten Terminen
Befehle ausgeführt werden. Siehe <manref name="at" section="1">,
<manref name="crontab" section="5">, <manref name="crontab" section="8">. 
<p> 
Die Tabelle für wiederkehrende Ausführung kann mit <tt>crontab -e</tt>
bearbeitet werden. Beispiele einer crontab-Tabelle:
<example>
# Verwende /bin/sh zur Ausführung, egal was passwd sagt
SHELL=/bin/sh
# Standardausgabe wird an `paul' geschickt.
MAILTO=paul
# Min Stunde TagDesMonats Monat TagDerWoche Befehl (Komma wird 'und')
# starte um 00:05, jeden Tag
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# starte unm 14:15 am Monatsersten -- Ausgabe per E-Mail an Paul
15 14 1  * *   $HOME/bin/monthly
# starte um 22:00 an Werktagen (1-5), schicke E-Mail an Joe. &percnt; für Zeilenumbruch, letztes &percnt; für cc:
0 22 *   * 1-5 mail -s "Es ist 10 Uhr" joe&percnt;Joe,&percnt;&percnt;Gute Nacht?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "Startet 23 Minuten nach 0 Uhr, 2 Uhr, 4 Uhr ..., am 1. Feb."
5  4 *   * sun echo "Startet um 04:05 jeden Sonntag"
# Startet um 03:40 an jedem ersten Montag des Monats
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
Um einen Befehl zur einmaligen Ausführung zu terminieren dient <prgn>at</prgn>
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Konsolenumschaltung mit <prgn>screen</prgn>
<p>
Mit <prgn>screen</prgn> kann man mehrere virtuelle Terminals
auf einer einzigen Konsole starten, jedes mit einer eigenen interaktiven
Shell. Selbst wenn man immer zwischen virtuellen Terminals umschalten kann
oder mehrere <prgn>xterm</prgn>-Fenster offen hält, sollte man sich <prgn>screen</prgn>
wegen seiner vielfältigen Möglichkeiten anschauen. Dazu gehören
<list compact>
<item>Kommando-Rückholung,
<item>Kopieren-Einfügen,
<item>protokollieren,
<item>Eingabe von Umlauten und
<item>die Möglichkeit eine komplette Sitzung an einem Terminal anzuhalten
      und später fortzusetzen.
</list>

<sect2>Beispiel für einen Fernzugriff
<p>
Wenn man sich häufig mit einem VT100-Terminal-Programm über ein Netzwerk
auf einem PC einwählt, wird man das Sitzungsmanagement mit
<prgn>screen</prgn> sicherlich nützlich finden.
<p>
<enumlist compact>
<item>Angenommen man ist über eine Telefonverbindung eingeloggt, eine
      <prgn>screen</prgn>-Sitzung ist gestartet und man hat einen längeren
      Text mit einem Editor geschrieben. Aus irgendwelchen Gründen, muss man
      jetzt die Verbindung unterbrechen.
<item>Durch Drücken von <tt>^A d</tt> wird die aktuelle Sitzung gesichert.
      (Noch schneller geht es mit <tt>^A DD</tt>, dann wird sogar gleich der
      Logout für einen vorgenommen.)
<item>Wenn man sich später wieder einwählt kann man mit <tt>screen -r</tt>
      die Sitzung holen, und <prgn>screen</prgn> wird die Sitzung so
      restaurieren, wie sie verlassen wurde.
</enumlist>

<sect2>Typische <prgn>screen</prgn>-Befehle
<p>
Wenn der <prgn>screen</prgn>-Prozess gestartet ist, reicht dieser alle
Tastatureingaben an das aktuelle Fenster, bis auf die Kommandosequenz, die
auf <tt>^A</tt> voreingestellt ist. Alle <prgn>screen</prgn>-Befehle
beginnen mit <tt>^A</tt> und werden dann von einem einzelnen Buchstaben
gefolgt (ggf. folgen dann die Parameter). Beispiele für Befehle:
<example>
^A ?     Hilfe (Tastaturbelegung)
^A c     Neues Fenster und wechsele dorthin
^A n     Gehe zum nächsten Fenster
^A p     Gehe zum vorherigen Fenster
^A <var>0</var>     Gehe zum Fenster Nummer <var>0</var>
^A w     Zeige eine Liste der Fenster
^A a     Gebe das ^A an die Applikation weiter
^A h     Hardcopy des Fensters in Datei
^A H     Starte/Beende Protokoll des aktuellen Fensters in eine Datei
^A ^X    Sichere das Terminal mit einem Passwort
^A d     Aktuelle Sitzung vom Terminal abmelden
^A DD    Vom Terminal abmelden und Logout
</example>
Dies ist nur eine kleine Auswahl der Befehle, die das mächtige
<prgn>screen</prgn> unterstützt. Siehe <manref name="screen" section="1"> für 
weitere Details.

<sect2>Backspace und/oder Strg-H in einer <prgn>screen</prgn> Sitzung
<p>
Wenn die Backspace- oder Strg-H-Taste während einer
<prgn>screen</prgn>-Sitzung nicht funktionieren, muss die Zeile 
<example compact>
bindkey -k kb stuff "\177"
</example>
in der Datei <file>/etc/screenrc</file> auskommentiert ("#") werden.

</sect1>

<sect1 id="net-test">Grundlagen &ndash; Prüfung des Netzwerks
<p>
Zu installierende Pakete, um die grundlegenden Funktionen des Netzwerks zu überprüfen:
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (für 2.2er Kernel),
<package>iptables</package> (für 2.4er Kernel) und das
<package>net-tools</package>-Paket. Nun sollte man folgende Sequenz ausführen:
<example>
$ ping <var>yahoo.com</var>            # teste Internetverbindung
$ traceroute <var>yahoo.com</var>      # tracen der IP-Pakete
$ ifconfig                  # testen der host-Konfiguration
$ route -n                  # testen der routing-Konfiguration
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # teste <var>host.dom</var> DNS-Einträge am <var>dns-server.com</var> 
      # und suche dort nach <var>{a|mx|any}</var> Eintrag
$ ipchains -L -n |less      # teste packet-Filter (2.2 kernel)
$ iptables -L -n |less      # teste packet-Filter (2.4 kernel)
$ netstat -a                # Finde alle offenen Ports
$ netstat -l --inet         # Finde alle auf Eingabe wartenden Ports
$ netstat -ln --tcp         # Ebenso (TCP, numerisch) Ports
</example>
</sect1>

<sect1 id="flush-mail">E-Mail aus dem lokalen Spooler leiten (flush)
<p>
Um E-Mail aus dem lokalen Spooler weiterzuleiten:
<example>
# exim4 -q    # wartende E-Mail anstoßen
# exim4 -qf   # alle E-Mails weiterleiten
# exim4 -qff  # dasselbe, auch E-Mail mit Status 'frozen' wird weitergeleitet
</example>
<tt>-qff</tt> wäre wohl die bessere Wahl in dem Skript
<file>/etc/ppp/ip-up.d/exim</file>.
Für Woody und ältere Distributionen muss <prgn>exim4</prgn> durch <prgn>exim</prgn> ersetzt werden.
</sect1>

<sect1 id="remove-mail">Eingefrorene E-Mails aus dem lokalen Spooler entfernen
<p>
Um nicht weiter vermittelbare E-Mails aus dem lokalen Spooler zu entfernen
und eine Fehlermeldung zurückzugeben dient:
<example>
# exim4 -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
Für Woody und ältere Distributionen muss <prgn>exim4</prgn> durch <prgn>exim</prgn> ersetzt werden.
</sect1>

<sect1>Neuausliefern von <file>mbox</file>-Inhalten
<p>
Falls das Homeverzeichnis voll wurde und <prgn>procmail</prgn> fehlschlug,
muss man E-Mails aus <file>/var/mail/<var>Benutzername</var></file> erneut
manuell in die sortierten Postfächer im Homeverzeichnis ausliefern. Nachdem
Plattenplatz im Homeverzeichnis bereitgestellt wurde, ist Folgendes zu starten:
<example>
# /etc/init.d/exim4 stop
# formail -s procmail &lt;/var/mail/<var>Benutzername</var>
# /etc/init.d/exim4 start
</example>
Für Woody und ältere Distributionen muss <prgn>exim4</prgn> durch <prgn>exim</prgn> ersetzt werden.
</sect1>

<sect1>Dateiinhalte zurücksetzen
<p>
Um eine Datei zurückzusetzen, z.B. eine Log-Datei, sollte nicht <tt>rm</tt>
benutzt werden, da diese Dateien im Sekundenrhythmus geschrieben werden.
Sicherer ist:
<example>
$ :&gt;<var>zu_leerende_Datei</var>
</example>
</sect1>

<sect1 id="dummyfile">Dummy-Dateien
<p>
Die folgenden Befehle erzeugen Dummy- oder leere Dateien beliebiger Größe:
<example>
$ dd if=/dev/zero    of=<var>Dateiname</var> bs=1k count=5 # 5KB große, aber leere Datei
$ dd if=/dev/urandom of=<var>Dateiname</var> bs=1M count=7 # 7MB mit Zufallsinhalt
$ touch <var>Dateiname</var> #erzeuge 0B Datei (wenn sie existiert, setze mtime neu)
</example>
<!-- FIXME: Boot floppy ? -->
Die folgenden Kommandos werden, wenn sie von der Shell der &debian;-Boot-Diskette
gestartet werden, beispielsweise den gesamten Inhalt der Festplatte
<file>/dev/hda</file> für die meisten praktischen Gegebenheiten löschen.
<example>
# dd if=/dev/urandom of=/dev/hda; dd if=/dev/zero of=/dev/hda
</example>

</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
Das Programm <prgn>chroot</prgn>, <manref name="chroot" section="8">,
ermöglicht es, verschiedene Instanzen der GNU/Linux-Umgebung in einem
einfachen System simultan ohne Neustart laufen zu lassen.
<p>
Es ist auch möglich, ein ressourcenhungriges Programm wie <prgn>apt-get</prgn>
oder <prgn>dselect</prgn> im Chroot eines schnellen Rechners laufen zu lassen,
während das Dateisystem eines langsamen Systems per NFS les- und schreibbar
gemountet wurde und der Chroot auf den Einhängepunkt verweist.

<sect2 id="chroot-debian">Betreiben einer anderen &debian;-Distribution mit <prgn>chroot</prgn>
<p>
Ein auf <prgn>chroot</prgn> basierendes System kann leicht mit 
dem <prgn>debootstrap</prgn>-Kommando in Sarge erzeugt werden.
Für Distributionen, die neuer als Sarge sind, kann stattdessen auch
<prgn>cdebootstrap</prgn> mit entsprechender Option verwendet werden.
Um zum Beispiel ein Sid-Chroot in <var>/sid-root</var> zu erzeugen, wenn man
einen schnellen Internet-Zugang hat:
<example>
main # cd /; mkdir <var>/sid-root</var>
main # debootstrap sid <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... beobachten, wie das gesamte System heruntergeladen wird
main # echo "proc <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount <var>/sid-root</var>/proc
main # mount /dev/ <var>/sid-root</var>/dev -o bind
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # cd /dev; /sbin/MAKEDEV generic; cd -
chroot # apt-setup # Einrichten von /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # Quellen auf unstable setzen
chroot # dselect  # oder aptitude, installieren von mc und vim :-)
</example>
<p>
Zu diesem Punkt sollte ein voll funktionsfähiges &debian;-System zur
Verfügung stehen, in dem man ohne Angst, die Hauptinstallation zu
beeinflussen, herumspielen kann.
<p>
Dieser <prgn>debootstrap</prgn>-Trick kann auch verwendet werden, um
&debian; auf einem System ohne ein &debian;-Installationsmedium, aber dafür
mit dem einer anderen GNU/Linux-Distribution, zu installieren.
Siehe <url id="&setup-chroot;">.

<sect2 id="chroot-console">Einrichten eines Logins für <prgn>chroot</prgn>
<p>
Eingeben von <tt>chroot <var>/sid-root</var> /bin/bash</tt> ist einfach,
behält aber alle Umgebungsvariablen bei, was man eventuell nicht möchte,
und hat andere Probleme. Ein viel besserer Ansatz ist es, einen anderen
Login-Prozess auf einem separaten virtuellen Terminal zu starten, mit dem
man sich direkt am Chroot anmelden kann.
<p>
Da auf Standard-&debian;-Systemen auf <tt>tty1</tt> bis
<tt>tty6</tt> Linux-Konsolen und auf <tt>tty7</tt> das X Window System
läuft, wird <tt>tty8</tt> als Beispiel für die Chroot-Konsole verwendet.
Nach der Erzeugung eines Chroot-Systems wie in <ref id="chroot-debian">
beschrieben, ist Folgendes in einer root-Shell im Hauptsystem einzugeben:
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8" >> /etc/inittab
main # init q    # init neuladen
</example>

<sect2 id="chroot-x">Einrichten von X für <prgn>chroot</prgn>
<p>
Die aktuellste Version von X und GNOME soll sicher in einem Chroot laufen?
Das ist möglich! Das folgende Beispiel wird GDM auf dem virtuellen Terminal
<tt>vt9</tt> starten.
<p>
Zuerst ist ein Chroot-System, wie unter <ref id="chroot-debian"> beschrieben,
zu installieren. Aus dem Hauptsystem sind einige wichtige
Konfigurationsdateien in das Chroot-System zu kopieren.
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # oder Verwendung der Chroot-Konsole
chroot # cd /dev; /sbin/MAKEDEV generic; cd -
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # in [servers] s/vt7/vt9/ ersetzen
chroot # /etc/init.d/gdm start
</example>
<file>/etc/gdm/gdm.conf</file> wurde editiert, um die erste virtuelle Konsole
von <tt>vt7</tt> in <tt>vt9</tt> abzuändern.
<p>
Nun kann leicht zwischen der vollen X-Umgebung im Chroot und im Hauptsystem
umgeschaltet werden, indem man die virtuellen Linux-Terminals wechselt. Zum Beispiel
durch Drücken von Strg-Alt-F7 und Strg-Alt-F9. Haben Sie Spaß!
<p>
[FIXME] Einen Kommentar und Link zum Init-Skript des <prgn>gdm</prgn> im
Chroot hinzufügen.

<sect2 id="chroot-dist">Andere Distributionen mit <prgn>chroot</prgn> laufen lassen
<p>
Eine Chroot-Umgebung für eine andere Linux-Distribution kann leicht erstellt
werden. Sie installieren ein System in eine andere Partition unter Verwendung
des Installationsprogramms der anderen Distribution. Falls dessen
Root-Partition sich in <file><var>/dev/hda9</var></file> befindet:
<example>
main # cd /; mkdir <var>/andere-Dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/andere-Dist</var>
main # chroot <var>/andere-Dist</var> /bin/bash
</example>
Dann ist wie in <ref id="chroot-debian">, <ref id="chroot-console"> und
<ref id="chroot-x"> zu verfahren.

<sect2 id="chroot-build">Erstellen eines Pakets mit <prgn>chroot</prgn>
<p>
Es gibt ein ausgefeilteres <prgn>chroot</prgn>-Paket,
<package>pbuilder</package>. Es erzeugt eine <prgn>chroot</prgn>-Umgebung
und stellt ein &debian;-Paket in dieser Sandbox zusammen. Es ist ideal zum
Überprüfen von Bauabhängigkeiten und zum Sicherstellen, dass falsche
Paketabhängigkeiten nicht in den erzeugten Paketen existieren.

</sect1>

<sect1>Tests auf harte Links
<p>
Man kann wie folgt überprüfen, ob zwei Dateien die selbe Datei mit zwei
harten Links sind:
<example> 
$ ls -li <var>Datei1</var> <var>Datei2</var>
</example>

<sect1>Ein Festplatten-Image <prgn>mount</prgn>en 
<p>
Wenn <file><var>Datei.img</var></file> ein Festplatten-Image enthält und die
Quellfestplatte eine Konfiguration wie <var>xxxx</var> = (Byte/Sektor) *
(Sektor/Zylinder) hat, dann kann dieses Image mit dem folgenden Befehl nach
<file>/mnt</file> gemountet werden:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
Die meisten Festplatten haben 512 Byte/Sektor.

<sect1 id="smbmount">Samba
<p>
Grundlagen, um auf Windows-Dateien zuzugreifen:
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
  <var>//server/share /mnt/smb</var> # freigegebene Windows-Laufwerke mounten
# smbmount <var>//server/share /mnt/smb</var> \
  -o "<var>username=mein_name,uid=meine_uid,gid=meine_gid</var>"
# smbclient -L <var>192.168.1.2</var> # Freigaben anzeigen
</example>
<p>
Die Samba-Netzwerk-Nachbarschaft kann angezeigt werden mit:
<example>
# smbclient -N -L <var>eigene_IP_Adresse</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>Werkzeuge für fremde Dateisysteme
<p>
Viele fremde Dateisysteme werden vom Linux-Kernel unterstützt, so dass man
durch einfaches Einbinden der Geräte auf diese zugreifen kann. Für bestimmte
Dateisysteme, gibt es auch ein paar spezielle Werkzeuge zum Zugriff auf
Dateisysteme ohne die Geräte einzubinden. Dies wird durch User-Space-Programme
erreicht, so dass Kernel-Unterstützung für diese Dateisysteme nicht benötigt
wird.
<list compact>
<item><package>mtools</package>: für MS-DOS-Dateisysteme (MS-DOS, Windows)
<item><package>cpmtools</package>: für CP/M-Dateisysteme
<item><package>hfsutils</package>: für HFS-Dateisysteme (nativer Macintosh)
<item><package>hfsplus</package>: für HFS+-Dateisysteme (moderner Macintosh)
</list>
Um MS-DOS-FAT-Dateisysteme zu erzeugen und zu überprüfen, ist das Paket
<package>dosfstools</package> nützlich.
</sect1>

</sect>

<sect id="oops">Typische Fehler
<p>
Es werden einige Beispiele gefährlicher Aktionen aufgeführt. Die negativen
Auswirkungen werden verstärkt, wenn das privilegierte Konto <tt>root</tt>
verwendet wird.

<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>
<!-- 
I know using quotes here are irregular but it is hard to read without it. 
-->
Die Verwendung von Jokerzeichen in Kommandozeilenargumenten wie in 
"<tt>rm -rf .*</tt>" kann gefährliche Auswirkungen haben, da "<tt>.*</tt>" 
beim Expandieren auch "<tt>.</tt>" und "<tt>..</tt>" enthält. Glücklicherweise
prüft die aktuelle Version des "<tt>rm</tt>"-Kommandos in der
&debian;-Distribution die Dateinamen im Argument und verweigert die Entfernung
von "<tt>.</tt>" und "<tt>..</tt>". Dies ist jedoch nicht immer der Fall.
Man kann das Folgende versuchen, um zu testen, wie Joker in Dateinamen
funktionieren.
<p>
<list compact>
<item>"<tt>echo *</tt>": listet jede Nicht-Punktdatei und
      Nicht-Punktverzeichnisse im aktuellen Verzeichnis auf.
<item>"<tt>echo .[^.]*</tt>": listet jede Punktdatei und alle Punktverzeichnisse
      im aktuellen Verzeichnis auf.
<item>"<tt>echo .*</tt>": listet das Elternverzeichnis und alles darin auf.
</list>

<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
Der Verlust einiger wichtiger Dateien wie <file>/etc/passwd</file> durch
eigenes Verschulden ist schlimm. Das &debian;-System macht regelmäßig
Sicherheitskopien dieser Dateien in <file>/var/backups/</file>. Wenn diese
Dateien wiederhergestellt werden, muss man eventuell die Rechte manuell
anpassen.
<example>
# cp /var/backups/passwd /etc/passwd
# chmod 644 /etc/passwd
</example>
Siehe auch <ref id="recover-status">.

</chapt>

