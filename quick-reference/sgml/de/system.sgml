<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.61"  -->
<chapt id="system">Debian-Grundlagen

<!-- 

Merged from 4 SGML files in FAQ February 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding non-English is added.

Merged from other SGML files in FAQ February 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suit "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suit better for Potato and Woody.
Unless slink is used, how many people about dpkg-ftp :)

-->

<p>
Dieses Kapitel liefert grundlegende Informationen über das Debian-System
für Nicht-Programmierer.  Für die ultimativen Informationen vergleiche:
<p>
<list compact>
<item>Debian Policy Manual
<item>Debian Developer's Reference
<item>Debian New Maintainers' Guide
<p>
</list>
aufgeführt unter <ref id="references">.

<p>
Wenn Sie nach nicht allzu ausführlichen "wie geht" Erklärungen suchen,
wechseln Sie direkt nach <ref id="package"> oder in andere relevante Kapitel.
<p>
Dieses Kapitel basiert auf Dokumenten aus der "Debian-FAQ", größtenteils
umgeschrieben, um dem gewöhnlichen Debian-Systemadministrator den Einstieg
zu erleichtern.

<!-- 
"FTP archives" is now changed to simple "archives" since it can be reached 
through HTTP and other methods
-->

<sect id="ftparchives">Die Debian-Archive

<sect1 id="dirtree">Verzeichnisstrukturen

<p>Die Software, welche für &debian; paketiert wurde, ist in einem der
vielen Verzeichnisbäume auf jedem
<url id="&mirror-site;" name="Debian-Mirror">
durch FTP oder HTTP verfügbar.

<p>Die folgenden Verzeichnisse können auf jedem Debian-Mirror unter
dem <file>debian</file> Verzeichnis gefunden werden:
<taglist>
  <tag><file>dists/</file>:
    <item>Dieses Verzeichnis enthält die "Distributionen" und ist für
    den Zugriff auf die aktuell verfügbaren Pakete in Debian ausgelegt.
    Einige alte Pakete, 
    die <file>Contents-*.gz</file>-Dateien
    und die <file>Packages.gz</file>-Dateien sind immer
    noch hier zu finden.
  <tag><file>pool/</file>:
    <item>Die neue Position aller Debian-Pakete.
  <tag><file>tools/</file>:
    <item>DOS-Hilfsmittel zum Erzeugen von Bootdisketten, Partitionieren
    der Festplatte, Komprimieren/Dekomprimieren von Dateien und zum
    Booten von Linux.
  <tag><file>doc/</file>:
    <item>Die grundlegenden Debian-Dokumentationen wie die FAQ's,
          Erläuterungen zum Fehler-Melde-System, usw.
  <tag><file>indices/</file>:
    <item>Enthält die <file>Maintainers</file>-Datei (Liste aller
          Paketbetreuer) und die <file>override.*</file>-Dateien.
  <tag><file>project/</file>:
    <item>Hauptsächlich Material, welches nur für Entwickler von Interesse
          ist, wie z.B.:
    <taglist>
      <tag><file>project/experimental/</file>:
        <item>Dieses Verzeichnis enthält Pakete und Hilfsmittel, welche
        noch entwickelt werden und sich noch im Alpha-Stadium befinden.
        Benutzer sollten keine Pakete von hier verwenden, da sie selbst
        für den Erfahrensten gefährlich und schädlich sind.
      <tag><file>project/orphaned/</file>:
        <item>Pakete, welche von ihrem alten Betreuer aufgegeben wurden
        und aus der Distribution zurückgezogene Software.
    </taglist>
</taglist>

<sect1 id="dists">Debian-Distributionen

<p>Normalerweise befinden sich drei Debian-Distributionen im
<file>dists</file>-Verzeichnis. Dies sind die <tt>stable</tt>-, die
<tt>testing</tt>- und die <tt>unstable</tt>-Distribution. Manchmal gab es
auch eine <tt>frozen</tt>-Distribution (zurzeit ist es einfach ein
Entwicklungsschritt der testing-Distribution).  Jede Distribution ist ein
symbolischer Link in das entsprechende Verzeichnis mit einem Kodenamen im
<file>dists</file>-Verzeichnis.

<sect1 id="stable">Die <tt>stable</tt>-Distribution

<p>Pakete der <tt>stable</tt>-Distribution, &stabledebian;, 
befinden sich im <file>stable</file>- (symbolischer Link zu
<file>&stablecodenamedir;/</file>) Verzeichnis:
<list>
  <item><file>stable/main/</file>:
  Dieses Verzeichnis enthält die Paketversionen, die zur aktuellsten Ausgabe
  des &debian;-Systems gehören.

  <p>Diese Pakete sind alle frei, das bedeutet sie entsprechen alle den <url name="Debian Free Software
  Leitlinien (DFSG)" id="&social-contract;#guidelines"> (auch verfügbar unter
  <file>&f-social-contract;</file> installiert durch 
  <package>&p-social-contract;</package>).

  <item><file>stable/non-free/</file>: Dieses Verzeichnis enthält Pakete,
  die entsprechend der DFSG nicht frei sind.

  <p>Zum Beispiel verbieten die Lizenzen einiger Pakete die kommerzielle
  Verteilung.  Andere können weitergegeben werden, sind aber Shareware.

  <item><file>stable/contrib/</file>: Dieses Verzeichnis enthält Pakete,
  welche DFSG-frei sind, aber irgendwie
  von einem Paket abhängen, das im Sinne der DFSG <strong>nicht</strong> frei ist.
</list>
<!-- CHECKME: not in sync with same text below -->
Heutzutage befinden sich Pakete in Ergänzung zu obigen Verzeichnissen
unterhalb des <file>pool</file>-Verzeichnisses (<ref id="pools">).  

<p>Der aktuelle Status von Fehlern der <tt>stable</tt>-Distribution ist
unter der <url id="&stable-problems;" name="Stable Problems">-Webseite
aufgeführt.

<sect1 id="testing">Die <tt>testing</tt>-Distribution

<p>Pakete der <tt>testing</tt>-Distribution, &testingdebian;, 
befinden sich im <file>testing</file>- (symbolischer Link zu
<tt>&testingcodenamedir;/</tt>) Verzeichnis, nachdem sie einige Zeit in
<tt>unstable</tt> getestet wurden. Heutzutage befinden sich neue Pakete
unterhalb des
<file>pool</file>-Verzeichnisses (<ref id="pools">).
Auch in <file>testing/</file> gibt es die
<file>main</file>-, <file>contrib</file>- und
<file>non-free</file>-Unterverzeichnisse, diese entsprechen den
Verzeichnissen in <file>stable/</file>.

<p>Diese Pakete müssen auf allen Architekturen, auf denen sie zur Verfügung
stehen, gleich aktuell sein und installierbar sein;
sie müssen auch weniger veröffentlichungskritische
Fehler haben, als die Versionen in <tt>unstable</tt>. Auf diese Art hoffen
wir, dass <tt>testing</tt> fast immer zur Veröffentlichung bereit ist.
Mehr Details zu den Test-Mechanismen sind  unter
<url id="&testing-notes;"> verfügbar.

<p>Der aktuellste Status der <tt>testing</tt>-Distribution ist unter
folgenden Seiten aufgeführt:
<list compact>
<item><url id="&update-excuses;" 
         name="update Ausflüchte">
<item><url id="&testing-problems;" 
         name="testing Probleme">
<item><url id="&release-critical;" 
         name="veröffentlichungskritische Fehler">
<item><url id="&qa-base-bugs;" 
         name="Basissystem Fehler">
<item><url id="&qa-standard-bugs;" 
         name="Fehler in Standard und Task Paketen">
<item><url id="&qa-bugs;" 
         name="andere Fehler und Bemerkungen zu Fehlerausmerzungs-Partys">
</list>

<sect1 id="unstable">Die <tt>unstable</tt>-Distribution

<p>Pakete, welche zur <tt>unstable</tt>-Distribution mit dem Kodenamen "Sid"
gehören, werden im <file>unstable</file>- (symbolischer Link zu
<file>sid/</file>) Verzeichnis aufbewahrt, nachdem sie in das Debian-Archiv
geladen wurden und verbleiben hier solange, bis sie nach <file>testing/</file>
verschoben werden. Heutzutage befinden sich Pakete unterhalb des
<file>pool</file>-Verzeichnisses (<ref id="pools">).
Es gibt auch <file>main</file>-,
<file>contrib</file>- und <file>non-free</file>-Unterverzeichnisse in
<file>unstable/</file>, welche dem selben Zweck dienen wie in
<file>stable/</file>.

<p>Die <tt>unstable</tt>-Distribution enthält ein Abbild des aktuellsten 
Entwickler-Systems. Benutzer sind willkommen diese Pakete zu benutzen 
und zu testen, werden aber über den Status der Einsatzbereitschaft gewarnt.
Der Vorteil der Benutzung der <tt>unstable</tt>-Distribution ist, dass man
immer auf dem Laufenden mit der aktuellsten &debian;-Software ist &ndash;
geht jedoch etwas schief, so muss man auch damit umgehen können. :-)

<p>Der aktuelle Status der Fehler in der <tt>unstable</tt>-Distribution
wird auf der <url id="&unstable-problems;"
name="Unstable Problems">-Webseite aufgeführt.

<!-- Above was enough
<sect1 id="sid">The Sid distribution

<p>Sid or <tt>unstable</tt> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <tt>testing</tt>,
in order to be released in <tt>stable</tt> later on. Sid contains packages
for both released and unreleased architectures.

<p>The name "Sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">Die <tt>frozen</tt>-Distribution

<p>Wenn die <tt>testing</tt>-Distribution ausgereift ist, so wird aus ihr
frozen, was bedeutet, dass kein neuer Code mehr akzeptiert wird, nur noch
Bugfixes, wenn nötig.
Es wird auch ein neuer Verzeichnisbaum im <file>dists</file>-Verzeichnis
angelegt und einem neuen Kodenamen zugeordnet. Die eingefrorene Distribution
durchläuft nun einige Monate lang Tests mit zwischenzeitlichen Updates und
Zwischenausgaben, welche "Test-Zyklen" genannt werden.

<p>Wir führen eine Liste aller Fehler in der <tt>frozen</tt>-Distribution, welche
die Veröffentlichung eines Paketes verzögern können, sowie von Fehlern,
welche ähnliche Auswirkungen auf die gesamte Ausgabe haben. 
Sobald die Anzahl der Fehler den maximal zulässigen Wert unterschreitet,
wird aus der eingefrorenen Distribution <tt>stable</tt>, sie wird
veröffentlicht und die letzte <tt>stable</tt>-Distribution veraltet (und
wird ins Archiv verschoben).

<sect1 id="codenames">Debian-Distributions-Kodenamen

<p>Verzeichnisnamen im <file>dists</file>-Verzeichnis, wie
<file>&stablecodenamedir;/</file> und <file>&testingcodenamedir;/</file> sind
nur "Kodenamen". Wenn sich eine &debian;-Distribution in der Entwicklung
befindet, besitzt sie keine Versionsnummer sondern nur einen Kodenamen.
Der Grund für diese Kodenamen ist das Spiegeln der &debian;-Distributionen
zu vereinfachen. (Wenn <file>unstable</file> ein reales Verzeichnis wäre und plötzlich in
<file>stable/</file> umbenannt wird, so müsste vieles erneut heruntergeladen
werden).

<p>Zurzeit ist <file>stable/</file> ein symbolischer Link zu
<file>&stablecodenamedir;/</file> und <file>testing/</file> ist ein
symbolischer Link zu <file>&testingcodenamedir;/</file>. Das bedeutet, dass
<tt>&stablecodename;</tt> die aktuelle <tt>stable</tt>-Distribution und
<tt>&testingcodename;</tt> die aktuelle <tt>testing</tt>-Distribution ist.

<p><file>unstable/</file> ist ein permanenter symbolischer Link zu
<file>sid/</file>, so wie Sid ständig für die <tt>unstable</tt>-Distribution steht.
<!-- (see <ref id="sid">).-->

<sect1 id="oldcodenames">In der Vergangenheit verwendete Kodenamen

<p>Bereits verwendete Kodenamen sind:
"Buzz" für Ausgabe 1.1,
"Rex" für Ausgabe 1.2, "Bo" für die Ausgaben 1.3.x,
"Hamm" für Ausgabe 2.0, "Slink" für Ausgabe 2.1,
"Potato" für Ausgabe 2.2,
"Woody" für Ausgabe 3.0 und
"Sarge" für Ausgabe 3.1.



<sect1 id="sourceforcodenames">Die Herkunft der Kodenamen

<p>Bisher wurden Personen aus dem Film <em>Toy Story</em> von Pixar
<!-- und Walt Disney --> verwendet.
<list compact>
  <item><strong>Buzz</strong> (Buzz Lightyear) war der Astronaut,
  <item><strong>Rex</strong> war der Tyrannosaurus,
  <item><strong>Bo</strong> (Bo Peep, dt. Porzelienchen) war das Mädchen,
                            das sich um die Schafe kümmerte,
  <item><strong>Hamm</strong> war das Sparschwein (dt. Specki),
  <item><strong>Slink</strong> (Slinky Dog) war der Spielzeughund,
  <item><strong>Potato</strong> war natürlich Mr. Potato Head (der
                                Kartoffelkopf, dt. Charly Naseweis),
  <item><strong>Woody</strong> war der Cowboy,
  <item><strong>Sarge</strong> war der Anführer der grünen Plastikarmee-Männer,
                               <!-- Fichtennadel? -->
  <item><strong>Etch</strong> (Etch-a-Sketch) war die Schreibtafel,
  <item><strong>Sid</strong> war ein Nachbarsjunge, welcher Spielzeug zerstörte.
</list>
<!--
  more info in http://www.pixar.com/featurefilms/ts/index.html 
  or better yet http://us.imdb.com/M/title-exact?Toy&percnt;20Story&percnt;20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Andy (the kid)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">Das <file>pool</file>-Verzeichnis

<p>Früher wurden Pakete in dem Unterverzeichnis von <file>dists</file>
aufbewahrt, welches der verwendeten Distribution entsprach. Es stellte sich
heraus, dass dies einige Probleme verursachte, wie z.B. große
Bandbreitenverschwendung auf Mirrors nach einigen großen Änderungen.

<p>Pakete werden nun in einem großen "Pool" gespeichert, entsprechend dem
Namen des Quellpakets strukturiert. Um dies handhaben zu können, wurde der
Pool je nach Abschnitt (<tt>main</tt>, <tt>contrib</tt> und
<tt>non-free</tt>) sowie dem ersten Buchstaben des Quellpakets unterteilt.
Diese Verzeichnisse enthalten verschiedene Dateien: die Binärpakete für jede
Architektur und das Quellpaket von welchem die Binärpakete erzeugt wurden.

<p>Man kann herausfinden wo sich ein Paket befindet, indem man ein Kommando
wie <tt>apt-cache showsrc <var>Paketname</var></tt> aufruft und nach der
"Directory:"-Zeile schaut. Das <package>apache</package>-Paket wird z.B.
unter <file>pool/main/a/apache/</file> gespeichert. Da es sehr viele
<tt>lib*</tt>-Pakete gibt, werden diese gesondert behandelt: das
<package>libpaper</package>-Paket wird beispielsweise unter
<file>pool/main/libp/libpaper/</file> gespeichert.

<p>Die <file>dists</file>-Verzeichnisse werden nach wie vor für die Index-Dateien,
welche von Programmen wie <prgn>apt</prgn> verwendet werden, genutzt.

<p>Normalerweise muss man sich um dies nicht kümmern, da neue <prgn>apt</prgn>
und wahrscheinlich ältere <file>dpkg-ftp</file> Programme
dies problemlos handhaben. Sind Sie an weiteren
Informationen interessiert, so sei auf die <url id="&pool-faq;"
name="RFC: Implementation von Paketpools"> verwiesen.

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Historische Bemerkungen über Sid

<p>Als das heutige Sid noch nicht existierte, gab <!--FTP removed --> 
es im Debian-Archiv nur einen Zweig für nicht ausgereifte Pakete: es gab die
Annahme, dass, wenn eine Architektur im aktuellen <file>unstable/</file> hinzukam,
sie veröffentlicht wurde, wenn diese Distribution zum neuen
<tt>stable</tt>-Zweig wurde.
Für viele Architekturen war das nicht der Fall, was dazu führte,
dass diese Verzeichnisse während der Veröffentlichung verschoben wurden.
Dies war unpraktisch, da die Verschiebung zu einer großen Bandbreitenbelastung
führte.

<p>Die Archiv-Administratoren umgingen das Problem einige Jahre, indem
sie Binaries für nichtveröffentlichte Architekturen in einem speziellen
Verzeichnis namens <file>sid</file> bereitstellten. Wenn eine Architektur
das erste Mal veröffentlicht wurde, gab es einen Link vom aktuellen <file>stable/</file> zu <file>sid/</file>
und später wurden sie wie üblich unter <file>unstable/</file>
erzeugt. Diese Vorgehensweise war zum Teil für die Anwender verworren.

<p>Mit Beginn der Paket-Pools (vergleiche <ref id="pools">) während der 
Entwicklung der Woody-Distribution, wurden Binärpakete
unabhängig von der Distribution vorschriftsmäßig im Pool gehalten, so dass
die Veröffentlichung einer Distribution nicht länger zu einer großen
Bandbreitenverschwendung auf den Mirrors führte (es gibt dennoch
während der Entwicklung eine relativ große Bandbreitenauslastung).

<sect1 id="incoming">Heraufgeladene Pakete in <file>incoming/</file>
<p>
Heraufgeladene Pakete befinden sich zunächst unter <url id="&incoming;"> 
nachdem sie überprüft wurden, um sicherzustellen, dass sie wirklich von
einem Debian-Entwickler stammen, (und sie werden in das
<file>DELAYED</file>-Unterverzeichnis verschoben,
wenn das Paket nicht von einem Entwickler
stammt, d.h. ein Non-Maintainer Upload (NMU) ist). Einmal pro Tag werden sie
von <file>incoming/</file> nach <file>unstable/</file> verschoben.
<p>
Im Notfall kann man Pakete aus <file>incoming/</file> installieren, bevor sie
nach <file>unstable/</file> kommen.
</sect1>

<sect1 id="snapshot">Wiederauffinden eines älteren Paketes
<p>
Während die aktuellsten Debian-Distributionen unter dem
<file>debian</file>-Verzeichnis auf jedem
<url id="&mirror-site;" name="Debian-Mirror"> zu
finden sind, werden die Archive für ältere Debian-Distributionen wie Slink
unter <url id="&archivehome;"> oder unterhalb des <file>debian-archive</file> 
Verzeichnis auf jedem Debian-Mirror gehalten.
<p>
Ältere <tt>testing</tt>- und <tt>unstable</tt>-Pakete befinden sich
auf <url id="&snapshothome;">.

</sect1>

<sect1 id="archsections">Architekturabhängige Verzeichnisse
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>Innerhalb jedes der wichtigen Verzeichnisbäume
(<file>dists/stable/main</file>, <file>dists/stable/contrib</file>,
<file>dists/stable/non-free</file>, <file>dists/unstable/main</file>, etc.),
befinden sich die Einträge der Binärpakete in Unterverzeichnissen, deren
Namen die Prozessorarchitektur kennzeichnen, für die sie kompiliert wurden.

<list>
  <item><file>binary-all/</file> für Pakete, welche architekturunabhängig
    sind. Dies umschließt z.B. Perl-Skripte oder Dokumentationen.
  <item><file>binary-<var>Plattform</var>/</file> für Pakete, welche sich
    auf einer einzelnen Binärplattform starten lassen.
  <!-- Yes I simplified this -->
</list>

<p>Es ist anzumerken, dass die aktuellen Binärpakete
sich nicht mehr länger in diesen Verzeichnissen,
dafür aber im <file>pool</file>-Verzeichnis befinden. Die Index-Dateien
(<file>Packages</file> und <file>Packages.gz</file>) befinden sich nach wie
vor zwecks Abwärtskompatibilität dort.

<p>Für die aktuell unterstützten Binärarchitekturen vergleiche die
Release Notes der einzelnen Distributionen. Sie können unter der
Release-Notes-Seite für <url id="&stable-release;" name="stable"> und
<url id="&testing-release;" name="testing"> gefunden werden.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">Der Quellcode

<p>Der Quellcode für alles im Debian-System ist mit darin enthalten.
Außerdem <strong>fordern</strong> die Lizenzvereinbarungen der meisten
Programme im System, dass der Quellcode zusammen mit den Programmen
ausgeliefert wird, oder dass dem Programm Informationen beiliegen, wie er zu
erhalten ist.

<p>Normalerweise befindet sich der Quellcode in den
<file>source</file>-Verzeichnissen, welche parallel zu allen
architekturspezifischen
Binärverzeichnissen sind oder aktueller im <file>pool</file>-Verzeichnis
(vergleiche <ref id="pools">). Um den Quellcode zu erhalten, ohne sich mit
der Verzeichnisstruktur des <!--FTP--> Debian-Archivs auseinandersetzen zu
müssen, kann ein Befehl wie <tt>apt-get source <var>Meinpaketname</var></tt>
genutzt werden.

<p>Einige Pakete wie z.B. <package>pine</package>, sind wegen deren
Lizenzbedingungen nur im Quellcode erhältlich.  (Kürzlich wurde das
<package>pine-tracker</package>-Paket bereitgestellt, um die
Pine-Installation zu vereinfachen.)
Die Anweisungen beschrieben in <ref id="port">
und <ref id="packaging"> bieten einige Möglichkeiten, um ein Paket manuell
zu paketieren.

<p>Der Quellcode kann, muss aber nicht für Pakete in <file>contrib</file>-
und <file>non-free</file>-Verzeichnissen, welche formal nicht Teil des
Debian-Systems sind, verfügbar sein.

<sect id="pkg-basics">Das Debian-Paketverwaltungssystem

<sect1 id="package-basics">Überblick über Debian-Pakete

<p>Pakete enthalten im Allgemeinen all die Dateien, welche nötig sind um
eine Menge von zusammengehörigen Kommandos oder Eigenschaften zu
implementieren. Es gibt zwei Typen von Debian-Paketen:
<list>
  <item><strong>Binärpakete</strong>, welche ausführbare Programme enthalten,
  Konfigurationsdateien, man/info-Seiten, Copyright-Informationen und andere
  Dokumentationen.
  Diese Pakete werden in einem Debian-spezifischen Archivformat verteilt
  (vergleiche <ref id="deb-format">); sie zeichnen sich i.a. durch die
  <tt>.deb</tt>-Dateierweiterung aus. Binärpakete können mit Debians
  <prgn>dpkg</prgn>-Programm ausgepackt werden; Details sind in der Handbuchseite
  beschrieben.
  
  <item><strong>Quellpakete</strong>, welche eine <tt>.dsc</tt>-Datei
  enthalten, die das Quellpaket beschreibt (inklusive der Namen der folgenden
  Dateien), ebenso wie eine <tt>.orig.tar.gz</tt>-Datei, welche den
  ursprünglichen unveränderten Quellcode in gzip-komprimiertem tar-Format
  enthält und gewöhnlich eine <tt>.diff.gz</tt>-Datei, die Debian-spezifische
  Änderungen zu den Originalquellen enthält. Das Programm
  <prgn>dpkg-source</prgn> packt und entpackt Debian-Quellpakete; Details sind
  in der Handbuchseite enthalten.
</list>

<p>Die Installation der Software durch das Paketsystem nutzt
"Abhängigkeiten", welche vom Paketbetreuer vorgegeben werden. Diese
Abhängigkeiten sind in der <file>control</file>-Datei, die jedem Paket
zugeordnet ist, enthalten.
Das Paket, welches den GNU C Compiler enthält (<package/gcc/), "hängt" z.B.
von dem Paketen <package/binutils/ "ab", das den Linker und Assembler
enthält. Versucht ein Benutzer <package/gcc/ zu installieren, ohne zuvor
<package/binutils/ installiert zu haben, so wird das Paketverwaltungssystem
(dpkg) die Fehlermeldung ausgeben, dass es <package/binutils/ benötigt
und die Installation von <package/gcc/ abbrechen. (Dennoch kann dieses
Verhalten vom Nutzer geändert werden; vergleiche <manref name="dpkg"
section="8">.)  Für weitere Einzelheiten wird auf <ref id="depends">
verwiesen.

<p>Debian's Paketverwaltungstools können benutzt werden um:
<list>
  <item>Pakete oder Teile von Paketen zu manipulieren und handzuhaben,
  <item>dem Nutzer im Aufteilen von Paketen zu helfen, welche mittels
    kleiner Medien wie Disketten übertragen werden müssen,
  <item>Entwickler beim Erzeugen von Paketarchiven zu helfen und um
  <item>den Nutzern bei der Installation von Paketen, die sich auf
    entfernten <!--FTP-->Debian-Archiven befinden, zu helfen.
</list>

<sect1 id="deb-format">Debian-<!--Binär-->Paketformat

<p>Ein Debian-"Paket" oder eine Debian-Archivdatei enthält ausführbare
Dateien, Bibliotheken und Dokumentationen, welche einem bestimmten Programm
oder einer Menge von zugehörigen Programmen zugeordnet sind. Normalerweise
hat eine Debian-Archivdatei einen Dateinamen der mit <tt>.deb</tt> endet.
<footnote>
<!-- Below added by Osamu based on a message posted by Colin Watson -->
<p>Das <prgn>debian-installer</prgn>-Projekt führte Dateinamen ein, die
auf <tt>.udeb</tt> enden. Kurzum, es ist ein Mikro-<tt>.deb</tt>
Format, das den Debian-Richtlinien für freie Software nicht exakt folgen muss.
So fehlt z.B. die Dokumentation und es wird nur vom
<prgn>debian-installer</prgn> genutzt, dem neuen Debian-Installationsprogramm,
das ursprünglich für die Sarge-Ausgabe entwickelt wurde. Die Dateiformate von <tt>.deb</tt>
und <tt>.udeb</tt> sind identisch. Das Programm <prgn>udpkg</prgn>, das mit
<tt>.udeb</tt>-Paketen umgehen kann, hat eingeschränktere Fähigkeiten als
das Standard-<prgn>dpkg</prgn> und unterstützt weniger Paketbeziehungen. Der
Unterschied im Namen besteht, weil die Debian-Archivbetreuer nicht glücklich
mit <tt>.deb</tt>s im Archiv sind, die den Richtlinien nicht folgen. Deshalb
wurde ein unterschiedlicher Name gewählt um dies zu betonen und um es
unwahrscheinlicher zu machen, dass Benutzer diese unabsichtlich auf einem
richtigen System installieren. <tt>.udeb</tt>s werden nur in einer Initial
Ramdisk während der Basisinstallation genutzt, um ein sehr beschränktes
Debian-System zu erstellen.
</footnote>

<p>Die internen Einzelheiten dieses Debian-Binärpaketformats werden in der
<manref name="deb" section="5"> Handbuchseite beschrieben. Da dieses interne
Format in Zukunft geändert werden kann (zwischen verschiedenen Ausgaben von
&debian;), sollte stets <manref name="dpkg-deb" section="1"> für Änderungen
der <tt>.deb</tt>-Dateien verwendet werden.

<!-- Below added by Osamu Not sure but should be right -->

<p>Zumindest in der Sarge-Distribution kann auf alle Debian-Archivdateien
mit den Standard-Unix-Kommandos <prgn>ar</prgn> und <prgn>tar</prgn>
zugegriffen werden, auch wenn das <prgn>dpkg</prgn>-Kommando nicht
verfügbar ist.

<sect1 id="pkgname">Namenskonventionen für Debians Paketdateinamen
<!--
Why are Debian package filenames so long? 
-->
<p>Die Debian-<!--binary-->Paketdateinamen folgen den Konventionen:
<example>
<var>foo</var>_<var>ver</var>-<var>rev</var>_<var>arch</var>.deb
</example>
wobei <var>foo</var> üblicherweise für den Paketnamen, <var>ver</var> für
die Originalversionsnummer, <var>rev</var> für die Debian-Revisionsnummer und
<var>arch</var> für die Zielarchitektur steht. Dateien können natürlich leicht
umbenannt werden. Sie können herausfinden, welches Paket sich in Wirklichkeit
in einer gegebenen Datei mit Namen <var>Dateiname</var> befindet, indem das
folgende Kommando ausgeführt wird:
<example>dpkg --info <var>filename</var></example>

<p>Die Debian-Revisionsnummer wird vom Debian-Entwickler angegeben oder von
demjenigen, der das Paket baut. Eine Änderung in der Revisionsnummer 
kennzeichnet in der Regel, dass einige Aspekte der Paketierung geändert wurden.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->
<sect1 id="conffile">Bewahren der lokalen Konfiguration
<!--
What is a Debian conffile
-->
<p>Konfigurationsdateien, die vom lokalen Administrator anpassbar sind,
befinden sich in <file>/etc/</file>.
Die &debian;-Policy legt fest, dass alle Änderungen zu lokalen
Konfigurationsdateien bei Paketaktualisierungen erhalten bleiben müssen.
<p>
Falls eine Standardversion einer lokal anpassbaren Datei mit einem Paket
vertrieben wird, so ist diese Datei als "conffile" aufgeführt.
Das Paketverwaltungssystem aktualisiert solche Dateien nicht ohne die
Erlaubnis des Administrators, falls sie geändert wurden, seitdem das Paket
das letzte Mal installiert wurde. Andererseits werden nicht veränderte
Konfigurationsdateien zusammen mit dem Rest des Pakets aktualisiert.
Dies ist nahezu immer erwünscht, so dass es vorteilhaft ist, die
Änderungen an Konfigurationsdateien zu minimieren.

<p>Um die Konfigurationsdateien, die zu einem Paket gehören, zu bestimmen,
kann man
<example>
dpkg --status <var>Paket</var>
</example>
ausführen und nach "Conffiles:" schauen.

<p>
Für weitere Informationen zu Konfigurationsdateien, kann man den
entsprechenden Abschnitt "Konfigurationsdateien" im Debian Policy-Handbuch
lesen (vergleiche <ref id="references">).

<sect1 id="maintscripts">Debian-Wartungsskripte
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian-Wartungsskripte sind ausführbare Skripte, welche automatisch
gestartet werden bevor oder nachdem ein Paket installiert wird.
Zusammen mit einer Datei namens <file>control</file> sind all diese Dateien
Teil des "control"-Abschnitts einer Debian-Archivdatei.

<p>Die einzelnen Dateien sind:
<taglist>
<tag>preinst
  <item>Dieses Skript wird ausgeführt, bevor das Paket aus der
  Debian-Archivdatei (<tt>.deb</tt>) ausgepackt wird. Viele "preinst"-Skripte beenden
  Dienste von Paketen, welche aktualisiert werden, bis deren Installation
  oder Upgrade vollzogen ist (d.h. nach der erfolgreichen Ausführung des
  "postinst"-Skriptes).

<tag>postinst
  <item>Dieses Skript schließt typischerweise jede nötige Konfiguration
  eines Paketes ab, nachdem es aus der Debian-Archivdatei (<tt>.deb</tt>)
  ausgepackt wurde. Oft fragen "postinst"-Skripte die Nutzer nach Daten,
  und/oder weisen sie darauf hin, dass, wenn sie die Standardwerte
  akzeptieren, sie später die Möglichkeit haben zurückzugehen und das Paket
  zu rekonfigurieren, sollte dies nötig sein.
  Viele "postinst"-Skripte führen Kommandos aus, welche nötig sind, um
  Dienste zu starten oder nach der Installation oder dem Upgrade neu zu
  starten.

<tag>prerm
  <item>Dieses Skript beendet typischerweise Daemonen, welche dem Paket
  zugeordnet sind. Es wird ausgeführt, bevor die zum Paket gehörenden
  Dateien gelöscht werden.

<tag>postrm
  <item>Dieses Skript modifiziert typischerweise Links oder andere Dateien,
  welche dem Paket zugeordnet sind und/oder entfernen Dateien, welche von
  ihm erzeugt wurden. (Siehe auch <ref id="virtual">.)
</taglist>

<p>Zurzeit können all diese Kontrolldateien im Verzeichnis
<file>/var/lib/dpkg/info</file> gefunden werden. Die auf das Paket
<tt>foo</tt> bezogenen Dateien beginnen mit "foo" und haben die
entsprechende Dateierweiterungen "preinst", "postinst", u.s.w. Die Datei
<file>foo.list</file> in diesem Verzeichnis enthält alle Dateien, welche mit
dem Paket <tt>foo</tt> installiert wurden.
(Es ist zu beachten, dass die Position dieser Dateien eine interne
<prgn>dpkg</prgn>-Eigenschaft ist und sich in der Zukunft ändern kann.)

<sect1 id="priority">Paket-Prioritäten
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Jedem Debian-Paket ist eine <strong>Priorität</strong> vom
Distributionsbetreuer zugeordnet worden, um die Arbeit des
Paketverwaltungssystems zu vereinfachen. Die Prioritäten sind:

<list>
  <item><strong>Erforderliche</strong> Pakete werden benötigt für die
    zuverlässige Funktionalität des Systems.
    <p>
    Dies schließt alle Tools, welche nötig sind, um das System zu
    reparieren, ein. Diese Pakete dürfen nicht entfernt werden,
    andernfalls kann das System komplett versagen und man ist nicht
    einmal in der Lage <prgn>dpkg</prgn> zum Wiederherstellen zu nutzen.
    Systeme die nur die erforderlichen Pakete enthalten, sind
    wahrscheinlich ungeeignet für die meisten Aufgaben, jedoch kann der
    Systemadministrator jederzeit neue Software installieren.
  <item><strong>Wichtige</strong> Pakete sollten auf jedem Unix-artigen
    System gefunden werden.
    <p>
    Andere Pakete ohne die das System nicht gut oder brauchbar arbeitet, 
    haben diese Priorität. Dies schließt <strong>nicht</strong> Emacs,
    X11, TeX oder andere große Anwendungen ein. Diese Pakete erzeugen
    nur die nötige Infrastruktur.
  <item><strong>Standard</strong>pakete sind auf jedem Linuxsystem üblich,
    inklusive einem kleinen aber nicht zu sehr beschränkten textbasierten
    System.
    <p>
    Dies ist der Standardinstallationsumfang, solange der Nutzer nichts
    anderes wählt. "Standard" enthält nicht viele große Anwendungen, aber
    es enthält Emacs (das ist mehr eine Infrastruktur als eine Anwendung)
    und eine geeignete Teilmenge von TeX und LaTeX (sofern dies ohne X
    möglich ist).
  <item><strong>Optionale</strong> Pakete enthalten all diese, welche man
    vernünftigerweise installieren möchte, auch wenn man damit nicht
    vertraut ist und keine speziellen Anforderungen daran hat.
    <p>
    Dies schließt X11, eine vollständige TeX-Distribution und viele
    Anwendungen mit ein.
  <item><strong>Zusätzliche</strong> Pakete sind entweder nicht mit anderen
    Paketen mit höherer Priorität verträglich, sind wahrscheinlich nur
    nützlich, wenn man sie bereits näher kennt oder haben spezielle
    Anforderungen, die sie für "Optional" ungeeignet machen.
</list>
<p>
Beachten Sie die Unterschiede zwischen "Priority: required", "Section:
base" und "Essential: yes" in der Paketbeschreibung. "Section: base"
bedeutet, dass dieses Paket vor allen anderen in einem neuen System
installiert wird. Die meisten der Pakete mit "Section: base" enthalten
"Priority: required" oder zumindest "Priority: important" und viele von
diesen sind mit "Essential: yes" versehen. "Essential: yes" bedeutet, dass
das Paket die Angabe einer bestimmten Option an das Paketmanagementsystem
wie <prgn>dpkg</prgn> erfordert, wenn es aus dem System entfernt werden soll.
Beispielsweise sind <package>libc6</package>, <package>mawk</package> und
<package>makedev</package> Pakete mit "Priority: required" und
"Section: base" aber enthalten nicht "Essential: yes".

<sect1 id="virtual">Virtuelle Pakete

<p>Ein virtuelles Paket ist ein allgemeiner Name, welcher für eine Gruppe
von Paketen steht, die alle ähnliche Funktionalitäten bereitstellen. Die
Programme <prgn>tin</prgn> und <prgn>trn</prgn> sind beispielsweise beide
News-Reader und einer von beiden sollte deshalb die Abhängigkeiten eines
Programms, welches einen News-Reader im System benötigt, um richtig
funktionieren zu können, erfüllen. Deshalb sagt man, dass beide das
"virtuelle Paket" <package>news-reader</package> bereitstellen.

<p>Analog stellen viele Pakete wie <prgn>exim</prgn>, <package>exim4</package>,
<prgn>sendmail</prgn> und <package>postfix</package> die
Funktionalität eines Mail-Transport-Agent bereit. Deshalb wird das virtuelle
Paket <package>mail-transport-agent</package> von beiden angeboten.
Wenn eines dieser Programme installiert ist, dann wird jedes Programm, das
von der Installation eines Mail-Transport-Agent abhängt, mit der
Existenz dieses virtuellen Paketes zufrieden sein.

<p>Debian besitzt einen Mechanismus so dass, wenn mehr als ein Paket,
welches das selbe virtuelle Paket bereitstellt, auf dem System installiert
ist, der Systemadministrator ein Programm bevorzugt auswählen kann. Das
entsprechende Kommando ist <prgn>update-alternatives</prgn> und wird genauer
in <ref id="alternatives"> beschrieben.

<sect1 id="depends">Paketabhängigkeiten
<p>Das Debian-Paketsystem enthält Paketabhängigkeiten, welche
verwendet werden, um den Fakt festzuhalten, dass ein Paket ein anderes
Paket installiert benötigt, um zu funktionieren oder um besser zu
funktionieren.
<list>
  <item>Paket A <strong>hängt</strong> von Paket B <strong>ab</strong>,
    wenn B unbedingt installiert sein muss, um A verwenden zu können. In
    einigen Fällen hängt A nicht nur von B, sondern einer speziellen
    Version von B ab. In diesem Fall ist die Versionsabhängigkeit im
    Allgemeinen eine untere Schranke, d.h. A hängt von einer beliebigen
    Version von B ab, welche aktueller als eine angegebene Version ist.

  <item>Paket A <strong>empfiehlt</strong> Paket B, wenn der Paketbetreuer
    meint, dass die meisten Nutzer A nicht ohne die von B bereitgestellte
    Funktionalität haben wollen.

  <item>Paket A <strong>schlägt</strong> Paket B <strong>vor</strong>, wenn
    B Dateien enthält, welche sich auf die Funktionalität von A beziehen
    und diese erweitern.
    Die selbe Beziehung wird ausgedrückt, wenn festgelegt wird, dass Paket B
    Paket A <strong>verbessert</strong>.

  <item>Paket A <strong>kollidiert</strong> mit Paket B, wenn A nicht
    korrekt funktioniert, falls B auf dem System installiert ist.
    Der "Konflikt"-Status wird oft mit "ersetzt" kombiniert.

  <item>Paket A <strong>ersetzt</strong> Paket B, wenn Dateien, die von
    B installiert wurden, von A entfernt oder durch
    Dateien in A überschrieben werden.

  <item>Paket A <strong>unterstützt</strong> Paket B, wenn alle Dateien
    und Funktionalitäten von B in A verfügbar sind.
</list>

<p>Weitere detaillierte Informationen zur Verwendung dieser Terme können im
<em>Packaging Manual</em> und dem <em>Policy Manual</em> gefunden werden.

<p>Es ist zu beachten, dass <prgn>aptitude</prgn> und <prgn>dselect</prgn> eine bessere Kontrolle
über Pakete, die mit <strong>empfiehlt</strong> und <strong>schlägt
vor</strong> spezifiziert werden, bietet als <prgn>apt-get</prgn>, was
einfach alle <strong>hängt ab</strong> Pakete wählt und
<strong>empfiehlt</strong> und <strong>schlägt vor</strong> ignoriert.
Beide Programme nutzen in aktuellen Versionen APT als Back-end.

<sect1 id="pre-depends">Die Bedeutung von "pre-depends" (Vor-Abhängigkeiten)

<p><prgn>dpkg</prgn> konfiguriert ein Paket, von dem ein anderes Paket
abhängt, immer, bevor es das Paket konfiguriert, das die Abhängigkeit erklärt.
Jedoch packt <prgn>dpkg</prgn> normalerweise Archivdateien in beliebiger
Reihenfolge aus, unabhängig von Abhängigkeiten.
(Das Auspacken besteht aus dem Extrahieren der Dateien aus der Archivdatei
und dem Ablegen am richtigen Ort.)
Falls jedoch ein Paket eine <strong>pre-depends</strong>-Abhängigkeit zu
einem Paket erklärt, dann wird dieses andere Paket zuerst ausgepackt und
konfiguriert, bevor dasjenige, mit der Vor-Abhängigkeit auch nur ausgepackt
wird.<footnote>
Dieser Mechanismus wurde eingeführt, um das System sicher
vom <tt>a.out</tt>- auf das ELF-Format zu aktualisieren, wobei die 
<strong>Reihenfolge</strong> in welcher die Pakete entpackt werden,
bedeutend ist.
</footnote>

Die Verwendung dieser Abhängigkeit wird minimiert.

<sect1 id="pkgstatus">Paket-Status
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p>Der Paket-Status kann "unbekannt", "installieren", "entfernen",
"säubern" oder "halten" sein.
Diese "gewünschten" Werte kennzeichnen, was der Nutzer mit einem Paket
beabsichtigte (entweder durch Anwahl des "[A]uswählen" Punktes in
<prgn>dselect</prgn> oder durch direkten Aufruf von <prgn>dpkg</prgn>).

<p>Deren Bedeutung ist:
<list compact>
  <item><strong>unbekannt</strong>    - der Nutzer hat niemals angegeben, ob
                er das Paket will.
  <item><strong>installieren</strong> - der Nutzer will das Paket installiert
                oder aktualisiert haben.
  <item><strong>entfernen</strong>    - der Nutzer will das Paket entfernen
                lassen, ohne das existierende Konfigurationsdateien gelöscht
                werden.
  <item><strong>säubern</strong>      - der Nutzer will das Paket komplett
                entfernt haben, inklusive der Konfigurationsdateien.
  <item><strong>halten</strong>       - der Nutzer will das Paket nicht
                verarbeiten lassen, d.h. er möchte die aktuelle Version im
                aktuellen Status belassen, unabhängig vom Wert.
</list>

<sect1 id="puttingonhold">Zurückhalten von Paketen von einem Upgrade
<!--
How do I put a package on hold?
Made major rewrite to accommodate new /etc/apt/preferences in progress
-->
<p>Es gibt zwei Mechanismen zum Zurückhalten von Paketen von einem Upgrade, 
durch <prgn>dpkg</prgn> oder beginnend mit Woody durch APT.

<p>Mit <prgn>dpkg</prgn> ist zuerst die Paketauswahlliste zu exportieren:
<example>
dpkg --get-selections \* &gt; <var>Paketauswahl.txt</var>
</example>
Dann muss die erzeugte Datei <file><var>Paketauswahl.txt</var></file>
editiert werden, indem die Zeile, welche das zu haltende Paket, z.B. 
<package>libc6</package>, enthält, von:
<example>
libc6                       install
</example>
auf:
<example>
libc6                       hold
</example>
geändert wird.
Nach dem Speichern ist die Datei in die <prgn>dpkg</prgn>-Datenbank
zurückzuladen mit:
<example>
dpkg --set-selections &lt; <var>Paketauswahl.txt</var>
</example>
Kennt man den Paketnamen des zu haltenden Pakets, kann man auch einfach
<example>
echo libc6 hold | dpkg --set-selections
</example>
starten. Wann immer der Installations-Prozess dieses Paket bearbeitet (zu
upgraden versucht), hält er es zurück.
<!-- FIXME
  This procedure holds packages at the install process of each package file.
-->

<p>Der selbe Effekt kann mit <prgn>dselect</prgn> erreicht werden. Dazu ist
einfach der Punkt [A]uswählen und dann das Paket zu wählen, dessen Status
beibehalten werden soll sowie schließlich `=' (oder `H') zu drücken. Die
Änderungen werden sofort aktiv, nachdem das [A]uswählen Menü beendet wird.

<p>Das APT-System in der Woody-Distribution hat einen neuen "Alternativen"
Mechanismus zum Halten von Paketen während des Archivabfrageprozesses unter
Verwendung von <tt>Pin-Priority</tt>. Vergleiche die Handbuchseite
<manref name="apt_preferences" section="5"> sowie <url id="&apt-howto;">
oder das <package>&p-apt-howto;</package>-Paket.

<sect1 id="sourcepkgs">Quellpakete

<p>
Quellpakete befinden sich in einem Verzeichnis namens <file>source</file> und
können entweder manuell heruntergeladen werden oder durch
<example>
apt-get source <var>foo</var>
</example>
(vergleiche die <manref name="apt-get" section="8"> Handbuchseite wie man APT
dazu bringt, dies zu tun).


<sect1 id="sourcebuild">Erzeugen von Binär- aus Quellcodepaketen

<p>Für ein Paket <tt><var>foo</var></tt> benötigt man alle
<file><var>foo_*</var>.dsc</file>-, <file><var>foo_*</var>.tar.gz</file>- und
<file><var>foo_*.diff</var>.gz</file>-Dateien, um die Quellen zu übersetzen
(Bemerkung: es gibt keine <tt>.diff.gz</tt>-Datei für ein natives
Debian-Paket).

<p>Sind diese Dateien vorhanden und ist das <package>dpkg-dev</package>-Paket
installiert, so extrahiert das Kommando
<example>
$ dpkg-source -x <var>foo_version-revision</var>.dsc
</example>
das Paket in ein Verzeichnis namens <tt><var>foo-version</var></tt>.

<p>Zum Erzeugen des Binärpakets ist Folgendes auszuführen:
<example>
$ cd foo-version
$ su -c "apt-get update; apt-get install fakeroot"
$ dpkg-buildpackage -rfakeroot -us -uc
</example>
Und danach
<example>
# su -c "dpkg -i ../<var>foo_version-revision_arch</var>.deb"
</example>
zum Installieren des neu gebildeten Pakets. Vergleiche <ref id="port">.

<!-- Woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Erzeugen neuer Debian-Pakete

<p>Für detaillierte Informationen zum Erzeugen neuer Pakete sollte der <em>New
Maintainers' Guide</em> gelesen werden, verfügbar im Paket
<package>maint-guide</package> oder unter <url id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rarely used command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rarely use command for Woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<!-- Jens: up to here in sync with rev 1.100 -->
<sect id="uptodate">Aktualisierung eines Debian-Systems

<p>Einer von Debians Vorzügen ist die Unterstützung eines konsistenten 
Upgrade-Wegs sowie ein sicherer Upgrade-Prozess und es wird stets versucht,
eine ältere Ausgabe problemlos zu aktualisieren. Pakete warnen den Nutzer,
sollten bedeutende Bemerkungen während des Upgrade-Prozesses auftreten und
bieten oft eine Lösung zu einem möglichen Problem.

<p>Man sollte auch die Release Notes lesen, das Dokument, das die Details zu
spezifischen Upgrades enthält. Es wird mit allen Debian-CDs ausgeliefert und
ist im WWW unter <url id="&stable-release;"> oder
<url id="&testing-release;"> verfügbar.

<p>
Eine praktische Anleitung zum Aktualisieren wird in <ref id="package">
bereitgestellt. Dieser Abschnitt beschreibt die grundlegenden Einzelheiten.

<sect1 id="howtocurrent">Methoden zum Aktualisieren eines Debian-Systems

<p>Man kann immer einfach einen anonymen FTP- oder <prgn>wget</prgn>-Aufruf
zu einem Debian-Archiv starten, die Verzeichnisse durchsehen, bis man die
gewünschte Datei gefunden hat, diese herunterladen und schließlich mittels
<prgn>dpkg</prgn> installieren. (Es ist zu beachten, dass <prgn>dpkg</prgn>
die aktualisierten Dateien immer in das korrekte Verzeichnis installiert,
auch in einem laufenden System.) Manchmal kommt es dennoch vor, dass ein
überarbeitetes Paket die Installation einer neuen Version eines anderen
Paketes erfordert. In diesem Fall schlägt die Installation fehl, wenn das
andere Programm nicht installiert ist.

<p>Viele Personen finden dieses manuelle Vorgehen zu Zeit aufwendig, da
Debian sich so schnell entwickelt &ndash; typischerweise werden ein Dutzend
oder mehr Pakete jede Woche hochgeladen. Diese Zahl ist kurz vor einer neuen
Veröffentlichung noch größer. Um dies besser handhaben zu können, bevorzugen
viele Personen ein automatisches Programm zum Upgraden. Einige
spezialisierte Paketmanagement-Tools sind für diesen Zweck verwendbar.

<sect1 id="pkgtools">Überblick über Paketverwaltungstools

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>Das Debian-Paketverwaltungssystem hat zwei Aufgaben: die Manipulation 
der Paketdatei und das Herunterladen von Paketdateien aus dem Debian-Archiv.
<prgn>dpkg</prgn> erfüllt die erste Aufgabe, APT und <prgn>dselect</prgn>
die letztere.

<sect1 id="dpkg"><prgn>dpkg</prgn>

<p>Dies ist das wichtigste Programm zum Manipulieren von Paketdateien. Für
eine ausführliche Beschreibung ist <manref name="dpkg" section="8"> zu
lesen.
<!-- "install dpkg" deleted because it's a required package -->

<p><prgn>dpkg</prgn> wird mit einigen wichtigen Programmen ausgeliefert.

<list>
<item><prgn>dpkg-deb</prgn>: Manipuliert <tt>.deb</tt> Dateien. 
      <manref name="dpkg-deb" section="1">
<item><prgn>dpkg-ftp</prgn>: Ein älteres Programm zum Herunterladen von
      Paketen. <manref name="dpkg-ftp" section="1">
<item><prgn>dpkg-mountable</prgn>: Ein älteres Programm zum Herunterladen von
      Paketen. <manref name="dpkg-mountable" section="1">
<item><prgn>dpkg-split</prgn>: Teilt ein größeres Paket in kleinere Dateien
      auf. <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> und <prgn>dpkg-mountable</prgn> wurden durch das
APT-System ersetzt.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT, das zukunftsweisende Paket-Tool (Advanced Packaging Tool) ist eine
fortschrittliche Schnittstelle zu Debians Paketsystem und besteht aus
verschiedenen Programmen, deren Namen oft mit "apt-" beginnen. 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn> und <prgn>apt-cdrom</prgn> 
sind die Kommandozeilen-Tools zum Umgang mit Paketen. Diese werden auch von
anderen Programmen, wie <prgn/dselect/ und <prgn/aptitude/ genutzt.

<p>Für weitere Informationen ist das <package/apt/-Paket zu installieren
und
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> sowie
<file>/usr/share/doc/apt/guide.html/index.html</file> zu lesen.

<p>Weitere Informationen finden sich im
<url id="&apt-howto;" name="APT HOWTO">.
Dazu kann <package/apt-howto-de/ installiert werden und steht
dann unter <file>&f-apt-howto;</file> zur Verfügung.

<p><tt>apt-get upgrade</tt> und <tt>apt-get dist-upgrade</tt> installieren
nur die Pakete, die unter "Depends:" ("hängt ab:") aufgeführt sind und
übersieht alle unter "Recommends:" ("empfiehlt:") und "Suggests:" ("schlägt
vor:") gelisteten Pakete. Um dies zu vermeiden, sollte <prgn>dselect</prgn>
verwendet werden.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics"><prgn>dselect</prgn>

<p>Dieses Programm besitzt eine Menüoberfläche zu Debians
Paketverwaltungssystem. Es ist besonders für die Erstinstallation und große
Upgrades nützlich. Vergleiche <ref id="dselect">.

<p>Für weitere Informationen sollte das <package/install-doc/-Paket
installiert und
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> oder
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">
gelesen werden.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single-user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <prgn>start-stop-daemon</prgn> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Aktualisieren eines laufenden Systems

<p>Der Kernel (das Dateisystem) in &debian;-Systemen unterstützt das Ersetzen
von Dateien auch während sie benutzt werden.

<p>Es wird auch ein Programm namens <prgn/start-stop-daemon/ bereitgestellt,
das verwendet wird, um Daemonen während des Bootens zu starten oder zum
Stoppen von Daemonen, wenn das Kernel-Runlevel geändert wird (z.B. von 
Mehrbenutzer- zu Einzelbenutzermodus oder zu "halt"). Das gleiche Programm
wird von Installationsskripten genutzt, wenn ein Paket, das einen Daemon
enthält, installiert wird, um laufende Daemonen zu stoppen und bei Bedarf
neuzustarten.

<p>Es wird darauf hingewiesen, dass das Debian-System den Einzelnutzermodus
nicht erfordert, um ein laufendes System zu aktualisieren.


<sect1 id="savedebs">Heruntergeladene und zwischengespeicherte
                     <tt>.deb</tt>-Archiv-Dateien

<p>Hat man Paketdateien manuell auf die Festplatte heruntergeladen (was
nicht unbedingt notwendig ist, vergleiche die obige Beschreibung von
<prgn>dpkg-ftp</prgn> oder APT), dann kann man die <tt>.deb</tt>-Dateien
nach der Installation der Pakete aus dem System entfernen.

<p>Wenn APT verwendet wird, so werden diese Dateien im
<file>/var/cache/apt/archives</file>-Verzeichnis zwischengespeichert. Sie
können nach der Installation gelöscht werden (<tt>apt-get clean</tt>) oder
auf einen anderen Rechner ins <file>/var/cache/apt/archives</file>
Verzeichnis kopiert werden, um das Herunterladen während mehrerer
Installationen zu vermeiden.

<sect1 id="keepingalog">Aufbewahren des Datensatzes für Upgrades

<p><prgn/dpkg/ bewahrt einen Datensatz aller Pakete, die ausgepackt,
konfiguriert, entfernt und/oder gesäubert wurden, auf. Jedoch wird
(zurzeit) kein Protokoll der Terminaleingaben, während der Paketmanipulation,
erzeugt.

<p>Der einfachste Weg, dieses Problem zu umgehen, ist Sitzungen von
<prgn>dpkg</prgn>, <prgn>dselect</prgn>, <prgn>apt-get</prgn>, etc.
innerhalb des <manref name="script" section="1"> Programms ablaufen zu
lassen.

<sect id="boot">Der Debian-Bootvorgang

<sect1 id="init">Das <prgn>init</prgn>-Programm

<p>Wie alle Unices, wird Debian durch das Programm <prgn>init</prgn>
gestartet. Die Konfigurationsdatei für <prgn>init</prgn> (dies ist
<file>/etc/inittab</file>) gibt an, dass das erste zu startende Skript
<file>/etc/init.d/rcS</file> ist. Dieses Skript startet alle anderen Skripte
in <file>/etc/rcS.d/</file>, entweder
indem diese eingebunden oder explizit als Unterprozess aufgerufen werden,
je nach Dateierweiterung. Diese Skripte initialisieren das System indem sie
z.B. Dateisysteme überprüfen und einbinden, Module laden, Netzwerk-Dienste
starten, die Uhrzeit setzen, u.a. Danach werden zwecks Kompatibilität die
Dateien (mit Ausnahme der mit einem `.' im Dateinamen) in
<file>/etc/rc.boot/</file> ausgeführt. Jedes Skript in diesem Verzeichnis ist
normalerweise dem Systemadministrator vorbehalten, die Verwendung dieser in
Paketen wird missbilligt. Vergleichen Sie <ref id="init-hints"> und
<url id="&sysvinit;" name="System run levels and init.d scripts"> in den
Debian-Richtlinien für weitere Informationen.

<sect1 id="runlevels">Runlevel

<p>Nach dem Bootprozess führt <prgn>init</prgn> alle Startskripte in einem
durch das Standard-Runlevel festgelegten Verzeichnis aus. (Dieses Runlevel
wird durch den Eintrag <tt>id</tt> in <file>/etc/inittab</file> festgelegt).
Wie viele <!-- all? SGK --> System-V-kompatible Unices hat Linux 7 Runlevel:
<list compact>
  <item>0 (Anhalten des Systems),
  <item>1 (Einzelnutzer Modus),
  <item>2 bis 5 (verschiedene Mehrbenutzer-Modi) und
  <item>6 (Neustart des Systems).
</list>
<p>
Für Debian-Systeme gilt <tt>id=2</tt>, was bedeutet, dass das
Standard-Runlevel 2 sein wird, wenn der Mehrbenutzer-Modus aktiv ist und die
Skripte in <file>/etc/rc2.d/</file> werden ausgeführt.

<p>In Wirklichkeit sind die Skripte in den Verzeichnissen
<file>/etc/rc<var>N</var>.d/</file> nur symbolische Links zu Skripten in
<file>/etc/init.d/</file>. Dennoch werden die <strong>Namen</strong> der
Dateien in jedem der <file>/etc/rc<var>N</var>.d/</file>-Verzeichnisse
individuell gewählt, um anzugeben <strong>wie</strong> die Skripte in
<file>/etc/init.d/</file> gestartet werden. Speziell werden bevor ein
Runlevel aktiv wird, alle Skripte die mit `K' beginnen ausgeführt; diese
Skripte beenden Dienste. Danach werden alle Skripte die mit `S' beginnen
gestartet; diese Skripte starten Dienste. Die zweistellige dem `K' oder `S'
folgende Nummer bestimmt die Reihenfolge der Ausführung. Skripte mit kleinerer
Nummer werden zuerst ausgeführt.

<p>Dieses Vorgehen funktioniert, da die Skripte in <file>/etc/init.d/</file>
alle
ein Argument akzeptieren, das entweder "start", "stop", "reload", "restart"
oder "force-reload" sein kann und eine dem Argument entsprechende Aktion
ausführen (starten, stoppen, neuladen, neustarten, erzwinge Neuladen).
Diese Skripte können auch ausgeführt werden, nachdem das System gebootet
wurde, um verschiedene Prozesse zu kontrollieren.

<p>Zum Beispiel führt das Argument "reload" im Kommando
<example>
# /etc/init.d/exim4 reload
</example>
dazu, dass der exim4-Daemon ein Signal zum erneuten Einlesen der
Konfigurationsdatei erhält.

<sect1 id="custombootscripts">Anpassen des Bootvorgangs
<p>
Debian verwendet kein BSD typisches <tt>rc.local</tt> Verzeichnis, um den
Bootvorgang anzupassen; stattdessen wird folgender Mechanismus angeboten.

<p>Angenommen <tt>foo</tt> sei ein Skript, das während des Startvorgangs
oder beim Übergang in ein bestimmtes (System V) Runlevel aufgerufen werden
soll. Dann sollte der Systemadministrator:
<enumlist>
  <item>Das Skript <tt>foo</tt> in das Verzeichnis <file>/etc/init.d/</file>
        verschieben.
  <item>Das Debian-Kommando <prgn>update-rc.d</prgn> mit entsprechenden
        Argumenten starten, um Links zwischen den (Kommandozeilen
        spezifischen) Verzeichnissen <tt>rc<var>?</var>.d</tt> und
        <file>/etc/init.d/foo</file> anzulegen.
        Dabei bezeichnet <var>?</var> eine Nummer von 0 bis 6, die einem der
        System V Runlevel entspricht.
  <item>Das System neu booten.
</enumlist>

<p>Das Kommando <prgn>update-rc.d</prgn> setzt Links zwischen Dateien im
Verzeichnis <tt>rc<var>?</var>.d</tt> und dem Skript in
<file>/etc/init.d/</file>. Jeder Link beginnt mit einem `S' oder `K',
gefolgt von einer Nummer, gefolgt vom Namen des Skripts. Beim Wechsel in
das Runlevel <var>N</var>, werden Skripte in
<file>/etc/rc<var>N</var>.d/</file> die mit `K' beginnen mit <tt>stop</tt>
als Argument ausgeführt, gefolgt von den mit `S' beginnenden Skripten in
<file>/etc/rc<var>N</var>.d/</file> mit <tt>start</tt> als Argument.
<!-- FIXME N1, N2 in directory? -->

<p>Man kann z.B. das Skript <tt>foo</tt> beim Booten ausführen lassen, indem
man es nach <file>/etc/init.d/</file> verschiebt und die Links mit
<tt>update-rc.d foo defaults 19</tt> erstellt. Das Argument <tt>defaults</tt>
bezieht sich auf das Standard-Runlevel, welches zwischen 2 und 5 liegt. Das
Argument <tt>19</tt> sichert, dass <tt>foo</tt> vor allen Skripten, welche
die Nummern 20 oder größer enthalten, gestartet wird.

<sect id="diverse">Unterstützung von Vielfalten
<p>
Debian unterstützt verschiedene Möglichkeiten zum Anpassen des Systems, ohne
das System zu beeinträchtigen. 
<list>
<item><prgn>dpkg-divert</prgn>, vergleiche <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, vergleiche <ref id="equivs">.
<item><prgn>update-alternative</prgn>, vergleiche <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> kann viele Boot-Loader anpassen. 
      Vergleiche <manref name="make-kpkg" section="1"> und
      <ref id="kernel-compile">.
</list>
Alle Dateien unter <file>/usr/local/</file> gehören dem Systemadministrator 
und &debian; wird sie nicht verändern. Viele (oder alle) Dateien unter
<file>/etc</file> sind Konfigurationsdateien und &debian; wird
sie nicht während eines Upgrades überschreiben, es sei denn der
Systemadministrator erlaubt dies ausdrücklich.

<sect id="i18n">Internationalisierung
<p>
Das &debian;-System ist internationalisiert und bietet Unterstützung zur
Ein- und Ausgabe von Zeichen in vielen Sprachen, beides in der Konsole und
unter X. Viele Texte, Handbuchseiten und Systemausgaben wurden in eine ständig
wachsende Anzahl von Sprachen übersetzt. Während der Installation fordert
Debian den Nutzer zur Wahl der Installationssprache (und manchmal eines
lokalen Dialekts) auf.
<p>
Sollte das installierte System nicht alle benötigten Eigenschaften der
Sprache unterstützen, soll eine andere Sprache gewählt werden oder wurde
eine neue Tastatur angeschlossen, um die Sprache zu unterstützen, vergleiche
<ref id="l10n">.

<sect id="kernel-details">Debian und der Kernel
<p>
Vergleiche <ref id="kernel">.

<sect1 id="non-debian-kernel">Kompilierung eines Kernel aus Debian-fremden
  Quellen

<p><!--Yes.  But you have-->
Man sollte die Debian-Politik bezüglich der Header verstanden haben, bevor
man startet.

<p>Die Debian-C-Bibliotheken wurden mit der aktuellsten
<strong>stabilen</strong> Version der <strong>Kernelheader</strong>
erstellt.

<p>Zum Beispiel nutzte die Debian 1.2 Ausgabe Version 5.4.13 der Header.
Dieses Vorgehen unterscheidet sich von den Linux-Kernelquellpaketen, die
auf allen Linux-FTP-Archiv-Seiten verbreitet werden, welche aktuellere
Versionen der Header verwenden. Die Kernelheader aus den Kernelquellen
befinden sich in <file>/usr/include/linux/include/</file>.

<p>Wenn es nötig ist, ein Programm mit aktuelleren Kernelheadern als in
<package/libc6-dev/ zu übersetzen, so muss
<tt>-I/usr/src/linux/include/</tt> zur Kommandozeile beim Kompilieren
hinzugefügt werden. Dies ist z.B. für das Paketieren des automounter-Daemon
(<package/amd/) von Bedeutung. Als neue Kernel einige NFS-bezogene Internals
änderten, musste dies <prgn>amd</prgn> mitgeteilt werden. Dies erforderte
die Einbindung der aktuellsten Kernelheader.

<sect1 id="customkernel">Tools zum Erzeugen angepasster Kernel

<p>Nutzern die einen angepassten Kernel erzeugen wollen (oder müssen), wird
empfohlen, das Paket <package/kernel-package/ herunterzuladen. Dieses Paket
enthält das Skript zur Kernelerstellung und bietet die Möglichkeit, ein
Debian kernel-image Paket einfach durch Aufruf von
<example>
# make-kpkg kernel_image
</example>
im Kernelquellverzeichnis zu starten. Hilfe ist durch Ausführung von
<example>
# make-kpkg --help
</example>
verfügbar und durch die Handbuchseite <manref name="make-kpkg" section="1">
sowie <ref id="kernel">.

<p>Nutzer müssen den Quellcode für den aktuellsten Kernel (oder den Kernel
ihrer Wahl) separat vom bevorzugten Linux-Archiv herunterladen, wenn kein
<package/kernel-source-<var>version</var>/-Paket (dabei steht
<var>version</var> für die Kernel-Version) vorhanden ist. Das Debian
<file>initrd</file>-Bootskript erfordert einen speziellen Kernel-Patch namens
<prgn>initrd</prgn>; vergleiche <url id="&bug-initrd;">.

<p>Detaillierte Anweisungen zur Benutzung des <package/kernel-package/-Pakets
sind in der Datei <file>/usr/share/doc/kernel-package/README.gz</file> zu
finden.

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="modules">Spezielle Regeln für den Umgang mit Modulen

<p>Debians <package/modconf/ Paket enthält ein Shellskript
(<file>/usr/sbin/modconf</file>), dass zur Anpassung der Modulkonfiguration
genutzt werden kann. Dieses Skript besitzt eine Menü basierte Schnittstelle,
die den Nutzer nach Einzelheiten über ladbare Gerätetreiber im System fragt.
Die Antworten werden benutzt, um die Datei <file>/etc/modules.conf</file>
(welche Aliase enthält sowie andere Argumente, die in Verbindung mit
verschiedenen Modulen verwendet werden müssen) anzupassen, auf Grund von
Dateien in <file>/etc/modutils/</file> und <file>/etc/modules</file> (die
die Module auflistet, die zur Bootzeit geladen werden müssen).

<p>Wie die (neuen) <file>Configure.help</file>-Dateien, die nun verfügbar
sind, um angepasste Kernel zu unterstützen, kommt das <package>modconf</package>-Paket
mit einer Reihe von Hilfe-Dateien (in <file>/usr/share/modconf/</file>),
die detaillierte Informationen über passende Argumente für jedes Modul
enthalten.

<sect1 id="removeoldkernel">Deinstallation eines alten Kernel-Pakets

<p>Das <prgn>kernel-image-<var>NNN</var>.prerm</prgn>-Skript überprüft, ob der
aktuell laufende Kernel mit dem zu entfernenden Kernel übereinstimmt.
Deshalb können ungewünschte kernel-image Pakete sicher mittels
<example>
# dpkg --purge --force-remove-essential kernel-image-<var>NNN</var>
</example>
entfernt werden. (<var>NNN</var> ist durch die entsprechende Kernelversion und
Revisionsnummer zu ersetzen.)
</sect>
