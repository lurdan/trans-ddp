<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.120"  -->
<chapt id="tips"> &debian; 小技巧


<sect id="booting">启动系统
<p>
关于系统启动提示的详细信息请参见 LDP 
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO">。

<sect1 id="crackroot">“我忘记了 root 密码！”(一)
<p>
只要能访问控制台键盘，不需要 root 密码也可以启动系统并以 root 帐号登录。 (这里假设没有 BIOS 密码或 <prgn>lilo</prgn> 之类的启动引导器密码用于控制系统启动。)
<p>
下面是一个不需要额外的启动盘或对 BIOS 启动设置进行修改的过程。这里的“Linux”是代表在 Debian 默认安装系统中启动 Linux 内核的标签。
<p>
在 <prgn>lilo</prgn> 的启动屏幕中，当 <tt>boot:</tt> 一出现时 (在某些系统中，您必须按 shift 键以阻止自动启动；如果 <prgn>lilo</prgn> 使用 framebuffer，您需要按 TAB 键才能看到自己输入的选项)，就输入：
<example>
boot: Linux init=/bin/sh
</example>
这会让系统启动内核并运行 <file>/bin/sh</file> 而非其标准的 <prgn>init</prgn>。现在你已获得 root 权限和一个 root shell。由于当前 <file>/</file> 是以只读方式挂载，而其它的硬盘分区均未挂载，故你必须完成下列步骤才能获得一个有适当功能的系统。
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(如果 <file>/etc/passwd</file> 文件中所有用户的第二个域的数据都为“x”，就表明系统使用了影子(shadow)密码，必须编辑 <file>/etc/shadow</file>。)要删除 root 密码，请编辑密码文件中第二个数据域，将它设置为空白。这样重启系统不用密码就能登录到 root。当系统启动进入 runlevel 1 时，Debian(至少是 Potato 以后的版本)需要密码，一些较老的版本则不需要。
<p>
在 <file>/bin</file> 下装一个小编辑器是个好习惯，因为有时 <file>/usr</file> 是无法访问的(参阅<ref id="bin-editor">)。
<p>
另外可以安装 <package>sash</package> 软件包，当系统无法启动时，还可执行：
<example>
boot: Linux init=/bin/sash
</example>
当 <file>/bin/sh</file> 不可用时，<prgn>sash</prgn> 可作为 <prgn>sh</prgn> 的交互式替代品，它是静态链接，内建了许多标准工具(在系统提示符下输入“help”可获得参考列表)。
</sect1>

<sect1 id="crackroot2">“我忘记了 root 密码！”(二)
<p>
从急救盘启动系统。假设 <file><var>/dev/hda3</var></file> 是原始 root 分区，可用下面的方法编辑密码文件，与上述方法一样容易。
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
与上面的方法相比，该方法的好处在于不需要知道 <prgn>lilo</prgn> 密码(如果有的话)。但如果系统没有预先设置为从软盘或 CD 启动，就需要访问 BIOS 的权限。
</sect1>

<sect1 id="dead-lilo">无法启动系统
<p>
没在安装过程中制作启动盘？没关系。如果 <prgn>lilo</prgn> 损坏了，从 Debian 安装套件中拿出启动盘，用它来启动系统。假设你的 root 分区在 <file><var>/dev/hda12</var></file>，你想进入 runlevel 3，在启动提示符后输入：
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
接下来，系统使用软盘上的内核启动，你可登录到一个几乎拥有全部功能的系统了。(可能有少量特性或模块不可用。)
<p>
如果系统崩溃，亦可参阅<ref id="un-bootable">。
<p>
如果想做张自定义启动盘，参阅急救盘中的 <file>readme.txt</file> 文档。
</sect1>

<sect1 id="no-x-start">“我不想直接启动到 X！”
<p>
玩 <tt>unstable/sid</tt> 很有趣，但在启动进程中执行不稳定的 <prgn>xdm</prgn>、<prgn>gdm</prgn>、<prgn>kdm</prgn> 或 <prgn>wdm</prgn> 会让你焦头烂额。
<p>
首先，在启动提示符后输入如下指令获得 root shell：
<example>
boot: <var>Linux</var> vga=normal s
</example>
这里的 <var>Linux</var> 是你要启动的内核的标记，“vga=normal”告诉 <prgn>lilo</prgn> 在普通 VGA 屏幕下运行，“s”(或“S”)是传给 <prgn>init</prgn> 的参数，告诉它进入单用户模式。在提示符后输入 root 密码。
<p>
有多种方法禁用 X 启动 daemons：
<list>
<item>运行 <tt>update-rc.d -f <var>?</var>dm remove</tt> ; <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6 .</tt>
<item>在所有 <file>/etc/init.d/<var>?</var>dm</file> 文件的最前面加上“exit 0”。
<item>把所有的 <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> 文件改名为 <file>/etc/rc2.d/K99<var>?</var>dm</file>。
<item>删除所有的 <file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> 文件。
<item>运行 <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
其中，<file>rc<var>2</var>.d</file> 中的数字必须与 <file>/etc/inittab</file> 中指定的 runlevel 一致。而 <file><var>?</var>dm</file> 的意思是你要将同一个命令运行多次，每次将其替换成 <prgn>xdm</prgn>、<prgn>gdm</prgn>、<prgn>kdm</prgn> 和 <prgn>wdm</prgn> 中的一个。
<p>
在 &debian; 下只有第一种方法是“唯一正确的方法”。最后一种方法比较简单但只适用于 &debian;，而且还需要使用 <prgn>dpkg-reconfigure</prgn> 重新设置一次。其它方法都是通用的中 daemons 的方法。
<p>
你仍可在任何控制台 shell 中用 <prgn>startx</prgn> 命令启动 X。
</sect1>

<sect1 id="bootprompt">其它用于启动提示符的技巧
<p>
使用 <prgn>lilo</prgn> 启动提示符，可指定系统启动到特定的 runlevel 和配置。详情参阅 <url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP)。
<p>
如果希望系统启动到 runlevel 4，可以 <prgn>lilo</prgn> 启动提示符后输入：
<example>
boot: Linux 4
</example>
<p>
如果希望系统启动到正常功能的单用户模式，而且你知道 root 密码，可在 <prgn>lilo</prgn> 启动提示符后输入下列任一参数。
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
如果希望系统以少于实际内存数的内存启动(也就是说机器有 64MB 内存，只分配 48MB 给系统使用)，在 <prgn>lilo</prgn >启动提示符后输入：
<example>
boot: Linux mem=48M
</example>
注意，不要指定大于实际内存数的内存，否则内核会崩溃。如果你有多于 64MB 的内存，如 128MB，应在系统启动时执行 <tt>mem=128M</tt> 或在 <file>/etc/lilo.conf</file> 中添加类似的命令行，否则旧内核或使用旧 BIOS 的主板将无法使用大于 64MB 的内存。
</sect1>

<sect1 id="bootgrub">设置 GRUB 启动参数
<p>
GRUB 是 Hurd 项目开发的新型启动管理器，比 Lilo 更灵活，不过启动参数也与之稍有不同。
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
请注意 Hurd 中的设备名：
<example>
HURD/GRUB           Linux               MS-DOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,0)             /dev/hda1           C: (usually)
 (hd0,3)             /dev/hda4           F: (usually)
 (hd1,3)             /dev/hdb4           ?
</example>
详情参阅 <file>&f-grub;</file> 和 <file>&f-grub-doc;</file>。
</sect>

<sect>活动记录

<sect1 id="script">记录 shell 活动
<p>
比起普通的个人电脑环境，Unix 环境的系统管理包含了更多细致的任务。必须掌握所有基本的配置方法以便进行系统故障恢复。基于 X11 的 GUI 配置工具看上去漂亮又好用，但不适用于紧急状况。
<p>
记录 shell 活动是个好习惯，特别是 root 用户。
<p>
Emacs：使用 M-x <tt>shell</tt> 在缓冲区中开始记录，使用 C-x C-w 将缓冲区中的记录写入文件。
<p>
Shell：使用 <prgn>screen</prgn> 命令和 <ref id="screen"> 
中描述的“^A H”；或者使用 <prgn>script</prgn> 命令。
<example>
$ script
Script started, file is typescript
 ... do whatever ...
 Ctrl-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
还可使用下面的方法：
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>记录 X 活动
<p>
如果需要 X 应用程序的活动记录图，包括 <prgn>xterm </prgn>
屏显，可使用 <prgn>gimp</prgn>(GUI)。它可以对每个窗口或整个屏幕进行拍照。还可以使用 <prgn>xwd</prgn>(<package>xbase-clients</package>)、<prgn>import</prgn>(<package>imagemagick</package>)
和 <prgn>scrot</prgn>(<package>scrot</package>)。
</sect1>


</sect>

<sect id="archiving">拷贝及创建子目录
<p>
这些拷贝和归档命令提供系统和数据备份的基本功能。
在 <url id="&examples;" name="the example scripts">
中提供了一个名为 <prgn>backup</prgn> 的简单备份脚本例子。

<sect1>拷贝整个子目录的基本命令
<p>
如果想重新整理文件组织结构，可使用下面的方法移动文件及文件链接：
<example>
标准方法：
# cp -a /source/directory /dest/directory # 要求 GNU cp
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
如果包含硬链接，则需要更严谨的方法：
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
如果是远程操作：
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
如果没有链接文件：
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
<p>
下面的有关拷贝整个子目录的信息由 Manoj Srivastava 
<email>srivasta@debian.org</email> 发表于 debian-user@lists.debian.org。
</sect1>

<sect1><prgn>cp</prgn>
<p>
传统上，<prgn>cp</prgn> 并不能真正完成这个任务，因为它既没对符号链接进行区别对待，又不能保存硬链接。另一件需要注意的事就是稀疏文件(有洞的文件)。
<p>
GNU <prgn>cp</prgn> 克服了这缺陷，然而对于非 GNU 系统，<prgn>cp</prgn> 仍存在问题。而且使用 <prgn>cp</prgn> 无法生成小巧轻便的文档包。
<example>
&percnt; cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
Tar 克服了 <prgn>cp</prgn> 在处理符号链接时出现的问题，然而，<prgn>cpio</prgn> 可以处理特殊文件，传统的 <prgn>tar</prgn> 却不行。
<p>                                                             
对于某个有多重硬链接的文件，<prgn>tar</prgn> 的处理方法是只将其中一个链接拷贝到磁带上，所以日后你只能找回拷贝中所保留那个的链接所指的文件；<prgn>cpio</prgn> 会为每个链接做一个拷贝，日后你可以找回任意一个链接所指的文件。
<p>
在 Potato 和 Woody 中，操作 <file>.bz2</file> 文件的 <prgn>tar</prgn> 命令参数有所变化，所以请在脚本中使用 <tt>--bzip2</tt> 而不要简写为 <tt>-I</tt>(Potato)或 <tt>-j</tt>(Woody)。  
</sect1>

<sect1><prgn>pax</prgn>
<p>
全新的，符合 POSIX(IEEE Std 1003.2-1992, pages 380&ndash;388 (section 4.48) and pages
936&ndash;940 (section E.4.48))标准的，众望所归的，轻便的文档包交互工具。<prgn>pax</prgn>可以读、写以及列出文档包的成员，并能拷贝文件目录层次。<prgn>pax</prgn> 的操作独立于特定的文档包格式，支持各种各样不同的文档包格式。
<p>
<prgn>pax</prgn>工具刚刚成形，还很新。
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 or
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn> 从 <prgn>cpio</prgn> 或 <prgn>tar</prgn> 文档包提取/放入文件。该文档包可以是硬盘上的另一个文件，也可以是磁带或管道。
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> 更善于处理 <prgn>cpio</prgn> 格式的文档包。通常它比
<prgn>cpio</prgn> 要快，且提供了更多磁带选项，并且能更友好的处理有讹误的输入数据。它支持交互式处理多卷文档包。用 <prgn>afio</prgn> 制作压缩文档包比压缩 <prgn>tar</prgn> 或 <prgn>cpio</prgn> 文档包更安全。在备份处理脚本中 <prgn>afio</prgn> 是更佳的“文档处理引擎”。
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
对所有的磁带备份我都使用 <prgn>afio</prgn>。
</sect1>
</sect>

<sect id="diff-backup">差量备份与数据同步
<p>
要进行差异备份和数据同步可使用下列几种方法：
<list>
<item><package>rcs</package>：备份并进行历史记录，只支持文本。
<item><package>rdiff-backup</package>：备份并进行历史记录。支持链接。
<item><package>pdumpfs</package>：对文件系统进行备份和历史记录。支持链接。
<item><package>rsync</package>：单路同步。
<item><package>unison</package>：双路同步。
<item><package>cvs</package>：多路同步服务器备份并进行历史记录，只支持文本，技术成熟。参阅<ref id="cvs">。
<item><package>arch</package>：多路同步服务器备份并进行历史记录，但包括“处于工作中的目录”。
<item><package>subversion</package>：多路同步服务器备份并进行历史记录，专用于 Apache。 
</list>
有关将这些方法与文档包操作结合应用的讨论参阅<ref id="archiving">，有关自动进行备份的讨论参阅<ref id="cronjob">。
<p>
我只讲解三个较容易使用的工具。

<sect1 id="rdiff-backup">使用 rdiff 进行差异备份
<p>
<package>rdiff-backup</package> 提供了简单好用的方法对任何文件包括链接进行历史差异备份。例如要对 <file>~/</file> 目录下的所有文件备份到 <file>/mnt/backup</file>：
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
从该文档包中取出 3 天前的旧数据恢复到 <file>~/old</file> 目录：
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
参阅 <manref name="rdiff-backup" section="1">。

<sect1 id="pdumpfs-backup">使用 <package>pdumpfs</package> 进行每日备份
<p>
<package>pdumpfs</package> 是一种简单的每日备份系统，与 Plan9 的 <prgn>dumpfs</prgn> 一样，它每天都保存系统快照。任何时候都可以用它来恢复到某天的系统状态。请使用 <prgn>pdumpfs</prgn> 和 <prgn>cron</prgn> 来备份你的 home 目录。
<p>
在目标目录中，<prgn>pdumpfs</prgn> 以 <tt>YYYY/MM/DD</tt> 的方式来组织系统快照。
当 <prgn>pdumpfs</prgn> 第一次运行时，它将所有源文件拷贝到快照目录。从每二次运行起，<prgn>pdumpfs</prgn> 仅拷贝更新的或新建的文件，对于没有改变的文件用硬链接方式指向前一天的系统快照，以此来节省硬盘空间。
<example>
$ pdumpfs <var>src-dir</var> <var>dest-dir</var> [<var>dest-basename</var>]
</example>
参阅 <manref name="pdumpfs" section="8">。
</sect1>

<sect1 id="backup">使用 RCS 进行定期差异备份
<p>
<package>Changetrack</package> 会定期对 RCS 文档包中基于文本格式的配置文件的变化进行记录。参阅 <manref name="changetrack" section="1">。
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>系统冻结恢复
<sect1 id="kill">中止一个进程
<p>
运行 <prgn>top</prgn> 看看什么进程的活动有异常。按“P”以
CPU 使用率排序，“M”以内存使用率排序，“k”可以中止一个进程。还有一种方法，使用 BSD风格的 <tt>ps aux | less</tt> 或 System V 风格的 <tt>ps -efH | less</tt>。System V 风格的排列会显示父进程 ID 
(<tt>PPID</tt>)，这对中止出错的(死掉的)子进程十分有用。
<p>
知道了进程的 ID，就可使用 <prgn>kill</prgn> 中止(或发信号给)某个进程，<prgn>killall</prgn> 的作用正如其名一样。经常使用的信号有：
<example>
 1: HUP，重启 daemon
15: TERM，普通中止
 9: KILL，强令中止
</example>

</sect1>

<sect1>Alt-SysRq
<p>
内核编译选项“Magic SysRq key”提供系统强心针。在 i386 机器上按下 ALT-SysRq
组合键后，试试按下列各键 <tt>r 0 k
e i s u b</tt>，奇迹产生了：
<p>
Un'r'aw 让键盘从 X 崩溃中重生。将控制台 loglevel 改为'0'以减少错误信息。sa'k'(system attention key)中止当前虚拟控制台的所有进程。t'e'rminate 中止当前终端除
<prgn>init</prgn> 外的所有进程。k'i'll中止除 <prgn>init</prgn> 外的所有进程。
<p>
'S'ync，'u'mount 和 re'b'oot 帮你逃离真正的险境。
<p>
详情参阅 <file>/usr/share/doc/kernel-doc-<var>version</var>/Documentation/sysrq.txt.gz</file> 或 <file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>。

</sect1>
</sect>


<sect id="nifty">记住这些可爱的小命令

<sect1>Pager
<p>
<prgn>less</prgn> 就是默认的 pager(文件内容浏览器)。按“h”可获得帮助。它比 <prgn>more</prgn> 更有用。在 shell 启动脚本中运行 <tt>eval $(lesspipe)</tt> 或 <tt>eval $(lessfile)</tt> 可以让 <prgn>less</prgn> 活力四射。详情参阅 <file>&f-lessopen;</file>。使用 <tt>-R</tt> 选项可输出生癖字符 and enables ANSI color escape sequences。参阅 <manref name="less" section="1">。
<p>
对于某些编码系统(EUC)<prgn>w3m</prgn> 可能是更好的选择。

<sect1>释放内存
<p>
<prgn>free</prgn> 和 <prgn>top</prgn> 能让你了解内存资源的许多有用信息。别担心“Mem:”行中“used”的大小，看看它下面的数字(本例的数字是 38792)。
<example>
$ free -k # 用 256MB 内存的机器
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
物理内存的准确大小可通过 <tt>grep '^Memory'
/var/log/dmesg</tt> 得到，本例将显示“Memory: 256984k/262144k available (1652k kernel code, 412k reserved, 2944k data, 152k init)”。
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
约有5MB内存系统不能使用，因为内核需要它。
</sect1>

<sect1>设定时间(BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc --systohc
# hwclock --show
</example>
设定系统时间和硬件时间为 MM/DD hh:mm, CCYY。显示时间为本地时间而硬件时间使用 UTC。
<p>
如果硬件(BIOS)时间设置为 GMT，在文件 <file>/etc/default/rcS</file> 中改变设置
<tt>UTC=yes</tt>。

<sect1>设定时间(NTP)
<p>
参考：<url id="&time-howto;" name="Managing Accurate Date and Time HOWTO">。
<p>
<sect2>拥有永久 Internet 连接的系统设置时间
<p>
设置系统时钟通过远程服务器自动对时：
<!-- [XXX FIXME XXX] some what broken ntpdate -->
<example>
# ntpdate <var>server</var>
</example>
如果你的系统拥有永久的 Internet 连接，应该将该命令加入 <file>/etc/cron.daily/</file>。

<sect2>偶尔进行 Internet 连接的系统设置时间
<p>
使用<package>chrony</package> 软件包。
</sect1>

<sect1 id="setterm">如何禁用屏幕保护程序
<p>
禁用屏幕保护程序,使用下面的命令。
<p>
对于 Linux 控制台：
<example>
# setterm -powersave off
</example>
<p>
启动 kon2 (kanji)控制台可执行：
<example>
# kon -SaveTime 0
</example>
<p>
运行X可执行：
<example>
# xset s off
 或
# xset -dpms
 或
# xscreensaver-command -prefs
</example>
控制其它的控制台特征，请参阅相关 man 页面。
改变和显示终端行设置，请参阅 <manref name="stty" section="1">。
</sect1>

<sect1 id="getent">搜索系统管理数据库
<p>
Glibc提供了<manref name="getent" section="1">搜索管理数据库的各类项目。例如passwd、group、hosts、services、protocols、networks。
<example compact>
getent database [key ...]
</example>

<sect1>禁用声音(响铃)
<p>
最直接的方法是拔掉 PC 喇叭。;-) 对于 Bash shell 可执行：
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>控制台上的错误信息
<p>
不想看屏幕显示的错误信息，首选的方法是检查 <file>/etc/init.d/klogd</file>，在该脚本中设置 <tt>KLOGD="-c <var>3</var>"</tt> 然后运行 <tt>/etc/init.d/klogd restart</tt>。另一种方法是执行 <tt>dmesg -n<var>3</var></tt>。
<p>
这儿是各种错误级别的含义：
<list compact>
<item>0: KERN_EMERG,   系统不可用
<item>1: KERN_ALERT,   必须立即执行
<item>2: KERN_CRIT,    紧急状态
<item>3: KERN_ERR,     错误状态
<item>4: KERN_WARNING, 警告状态 
<item>5: KERN_NOTICE,  正常状态且十分重要
<item>6: KERN_INFO,    报告
<item>7: KERN_DEBUG,   debug-level 信息
</list>
<p>
如果你很厌恶详细而无用的错误信息，可以试试这个小补丁 <file>shutup-abit-bp6</file>(位于 <url id="&examples;" name="样例脚本子目录">)。
<p>
另一个该看看的地方是 <file>/etc/syslog.conf</file>;，检查一下是否有信息记录被发送到了控制台设备。
</sect1>

<sect1>正确设置控制台类型
<p>
在类 Unix 系统中，访问控制台屏幕通常要调用库例程，这就为用户提供了一种独立于终端的方式来优化字符的屏幕更新过程。参阅 <manref name="ncurses" section="3X">和<manref name="terminfo" section="5">。
<p>
在 &debian; 系统中，有大量预定义项目：
<example>
$ toe | less                  # 所有项目
$ toe /etc/terminfo/ | less   # 用户可再配置的项目
</example>
你的选择可导出到环境变量 <tt>TERM</tt>。
<p>
当登录到远程Debian系统时，如果 <prgn>xterm</prgn> 的 terminfo 项目在非 Debian 的 <prgn>xterm</prgn> 中失效，请将终端类型改为支持较少特性的版本如“xterm-r6”。
参阅 <file>&f-libncurse;</file>。“dumb”是 terminfo 的最小公分母。
</sect1>

<sect1>让控制台恢复正常状态
<p>
如果执行 <tt>cat <var>some-binary-file</var></tt> 后屏幕一片混乱(当你输入命令时，无法看到正常的回显（echo）)：
<example>
$ reset
</example>
</sect1>

<sect1 id="dos2unix">将 DOS 下的文本文件转换为 Unix 类型
<p>
将DOS文本文件(行尾=^M^J)转换成 Unix 文本文件(行尾=^J)。
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1 id="recode">使用 <prgn>recode</prgn> 转化文本文件
<p>
下面将在 DOS、 Mac 和 Unix 的文本文件中转换行结尾格式：
<example>
$ recode /cl../cr &lt;<var>dos.txt</var> &gt;<var>mac.txt</var>
$ recode /cr.. &lt;<var>mac.txt</var> &gt;<var>unix.txt</var>
$ recode ../cl &lt;<var>unix.txt</var> &gt;<var>dos.txt</var>
</example>
自由的 <prgn>recode</prgn> 在各种各样的字符集和界面中转换：
<example>
$ recode <var>charset1</var>/<var>surface1</var>..<var>charset2</var>/<var>surface2</var> \
  &lt;<var>input.txt</var> &gt;<var>output.txt</var>
</example>
使用的通用字符集设置是(参阅 <ref id="base-locale">)
<footnote>
<prgn>recode</prgn> 比 <prgn>iconv</prgn> 拥有更多方便的别名。
</footnote>
:
<list compact>
<item><tt>us</tt> &mdash; ASCII (7 bits)
<item><tt>l1</tt> &mdash;  ISO Latin-1 (ISO-8859-1, Western Europe, 8 bits)
<item><tt>EUCJP</tt> &mdash; EUC-JP for Japanese (Unix)
<item><tt>SJIS</tt> &mdash; Shift-JIS for Japanese (Microsoft)
<item><tt>ISO2022JP</tt> &mdash; Mail encoding for Japanese (7 bits)
<item><tt>u2</tt> &mdash; UCS-2 (Universal Character Set, 2 bytes)
<item><tt>u8</tt> &mdash; UTF-8 (Universal Transformation Format, 8 bits)
</list>
使用的通用界面
<footnote>
行结尾：
<list compact>
<item>回车键表示为：ASCII 13、 ASCII 0xD、^M 和 \r 。
<item>换行表示为： ASCII 10、 ASCII 0xA、 ^J 和 \n 。
</list>
</footnote>
：
<list compact>
<item><tt>/cr</tt> &mdash; Carriage return as end of line (Mac text)
<item><tt>/cl</tt> &mdash; Carriage return line feed as end of line (DOS text)
<item><tt>/</tt> &mdash; Line feed as end of line (Unix text)
<item><tt>/d1</tt> &mdash; Human readable bytewise decimal dump
<item><tt>/x1</tt> &mdash; Human readable bytewise hexidecimal dump
<item><tt>/64</tt> &mdash; Base64 编码文本
<item><tt>/QP</tt> &mdash; Quoted-Printable 编码文本
</list>
更多信息，请参阅 <tt>info recode</tt> 中的相关描述。
<p>
有更多的专业转换工具：
<list compact>
<item>字符集转换：
<list compact>
<item><prgn>iconv</prgn> &mdash; 本地编码转换
<item><prgn>konwert</prgn> &mdash; 特殊编码转换
</list>
<item>二进制文件转换：
<list compact>
<item><prgn>uuencode</prgn> 和 <prgn>uudecode</prgn> &mdash; 用于 Unix
<item><prgn>mimencode</prgn> &mdash; 用于邮件
</list>
</list>
</sect1>

<sect1 id="perl-i">正规表达式的置换
<p>
将所有文件 <var>FILES</var> ...中的所有 <var>FROM_REGEX</var> 字段替换成
 <var>TO_TEXT</var> 字段。
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_TEXT</var>/g;' <var>FILES</var> ...
</example>
<tt>-i</tt> 表示“就地编辑”，<tt>-p</tt> 表示“在<var>FILES</var>...各文件中循环”。如果置换很复杂，应使用参数 <tt>-i.bak</tt> 而非 <tt>-i</tt>，这有助于出错恢复；它会将每个原始文件保存为以 <tt>.bak</tt> 为后缀的备份文件。
</sect1>

<sect1>使用脚本来编辑文件
<p>
下面的脚本将删除 5&ndash;10 行以及 16&ndash;20 行。
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
在此，<prgn>ed</prgn> 命令与 <prgn>vi</prgn> 命令模式下的是一样的，从外部编辑文件的方式使它更适于脚本化。
</sect1>

<sect1>提取源文件修改部分合并到更新包
<p>
下面的操作将根据文件位置，提取源文件的修改部分并创建统一的 diff 文件 <var>file.patch0</var> 或 <var>file.patch1</var>：
<example>
$ diff -u <var>file.old</var> <var>file.new</var> &gt; <var>file.patch0</var>
$ diff -u <var>old/file</var> <var>new/file</var> &gt; <var>file.patch1</var>
</example>
diff 文件(也称补丁文件)通常用于发送程序更新。收到的补丁文件可使用下面的方法更新另一个<var>文件</var>：
<example>
$ patch -p0 <var>file</var> &lt; <var>file.patch0</var>
$ patch -p1 <var>file</var> &lt; <var>file.patch1</var>
</example>
如果有 3 个版本的源代码，使用 <prgn>diff3</prgn> 来合并效率更高：
<example>
$ diff3 -m <var>file.mine</var> <var>file.old</var> <var>file.yours</var> &gt; <var>file</var>
</example>
</sect1>

<sect1>分割大文件
<p>
<example>
$ split -b 650m <var>file</var>   # 将大文件分块成多个 650MB 的小文件
$ cat x* &gt;<var>largefile</var>    # 将所有小文件合并成一个大文件
</example>
</sect1>

<sect1>从文本格式的表格中抽取数据
<p>
假设有一个文本文件名为 <file>DPL</file>，其中存放着所有前 &debian; 项目领导人的名字和他们的上台日期，表格格式是以空格做为分隔的。
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   January 1998
Wichert Akkerman  January 1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr March   2003
</example>
<!-- FIXME: Update me -->
Awk 经常用于从这类文件中提取数据。
<example>
$ awk '{ print $3 }' &lt;DPL                   # month started
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' &lt;DPL          # DPL called Ian
Ian     Murdock   August  1993
Ian     Jackson   January 1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # When Perens started
April 1996
</example>
<p>
象 Bash 这种 Shell 也能够用来分析这种文件：
<example>
$ while read first last month year; do 
    echo $month
  done &lt;DPL
... 跟第一个 Awk 例子有相同的输出
</example>
在这里，<prgn>read</prgn> 内建命令使用字符 $IFS 
(internal field separators 内部列分隔符)来将行分开为单词。
<p>
如果你改变 IFS 为 ":"，你能够用 shell 漂亮的分析 <file>/etc/passwd</file>：
<example>
$ oldIFS="$IFS"   # 保存旧值
$ IFS=":"
$ while read user password uid gid rest_of_line; do
    if [ "$user" = "osamu" ]; then 
      echo "$user's ID is $uid"
    fi
  done < /etc/passwd
osamu's ID is 1001
$ IFS="$oldIFS"   # 恢复旧值
</example>
(如果使用 Awk 作同样的事情，使用 <tt>FS=":"</tt> 来设置列分隔符。)
<p> 
shell 也使用 IFS 来分开参数扩展、命令替换和算术扩展的结果集。
但在被单引号或双引号引用的单词内，不会发生这种情况。
默认的 IFS 值是：
&lt;space&gt;、 &lt;tab&gt; 和 &lt;newline&gt; 。
<p>
请小心使用这个 shell IFS 技巧。 
当 shell 解释部分脚本作为它的<strong>输入</strong>时，奇怪的事情将会发生。
<example>
$ IFS=":,"                        # 使用 ":" 和 "," 作为 IFS
$ echo IFS=$IFS,   IFS="$IFS"     # echo 是 Bash 内建的
IFS=  , IFS=:,
$ date -R                         # 只是一个命令输出
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # 子 shell --&gt; 输入到主 shell
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # 重设 IFS 为默认的
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>
</sect1>


<sect1 id="scrp-snip">精巧的管道命令辅助脚本
<p>
下列脚本做为管道的一部分十分有用。
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # 查找 /usr 下的所有文件，排除某些文件
xargs -n 1 <var>command</var>   # 将所有项作为标准输入来执行命令
xargs -n 1 echo |    # 将空格隔离的项分开为行
xargs echo      |    # 合并所有的行到一行里面
grep -e <var>pattern</var>|     # 提取含有 <var>pattern</var> 的行
cut -d: -f3 -|
        # 提取用 : 分开的第 3 列(比如说 passwd 文件)
awk '{ print $3 }' | # 提取用空格分开的第 3 列
awk -F'\t' '{ print $3 }' |
       # 提取用 tab 分开的第 3 列
col -bx |            # 删除退格键，扩展 tab 为空格
expand -|            # 扩展 tab
sort -u|             # 排序并删除重复行

tr '\n' ' '|         # 将多行连接为一行
tr '\r' ''|          # 删除 CR
tr 'A-Z' 'a-z'|      # 转化大写字母为小写
sed 's/^/# /'|       # 将每行变为注释
sed 's/\<var>.ext</var>//g'|    # 删除 <var>.ext</var>
sed  -n -e 2p|       # 显示第 2 行
head -n 2 -|         # 显示头两行
tail -n 2 -|         # 显示最后两行
</example>
</sect1>

<sect1>循环每一个文件的脚本片段
<p>
下面的方法将循环处理匹配 <tt>*.<var>ext</var></tt> 的每一个文件，确保适当处理文件名包含空格的奇怪文件，并且执行相同的操作。
<list>
<item>Shell 循环 (在 <tt>PS2=" "</tt> 时使用多行格式的例子。
如果在一行内输入这些命令，需要在每一个换行处加一个分号。)：
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>command</var> "$<var>x</var>"
  fi
done
</example>
<item><prgn>find</prgn> 和 <prgn>xargs</prgn> 结合：
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>command</var>
</example>
<item>加 <tt>-exec</tt> 选项的 <prgn>find</prgn> 和一个命令结合：
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>command</var> '{}' \;
</example>
<item>加 <tt>-exec</tt> 选项的 <prgn>find</prgn> 和一个短的 shell 脚本结合：
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>command</var> '{}' && echo 'successful'" \;
</example>
</list>
</sect1>

<sect1 id="perl-mad">短小的 Perl 脚本
<p>
虽然任何 Awk 脚本均可使用 <manref name="a2p" section="1"> 自动重写成 Perl，
但最好用手工的方法将一行 Awk 脚本转化为一行 perl 脚本。例如：
<example>
awk '($2=="1957") { print $3 }' |
</example>
与下列任意一行相当：
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
其实上面各行中所有 <prgn>perl</prgn> 参数中的空格均可去掉，这得益于 Perl 的数字字符串自动转换功能。
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
有关命令行参数的信息可参阅 <manref name="perlrun" section="1">，在 <url id="&perlgolf;"> 有更多令人着魔的 Perl 脚本，你会感兴趣的。
</sect1>

<sect1>从网页上获取文本或邮件列表文档
<p>
下面的操作将网页转化为文本文件。从网上拷贝配置文件时十分有用。
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>textfile</var>
</example>
<prgn>links</prgn> 和 <prgn>w3m</prgn> 也可以这么用，只是生成的文本样式可能略有不同。
<p>
如果是邮件列表文档，可使用 <prgn>munpack</prgn> 从文本获得 mime 内容。
</sect1>

<sect1>打印网页
<p>
下面的操作将网页内容打印成 PostScript 文件或发送到打印机。
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
参阅<ref id="lprlpd">。还可使用 <prgn>a2ps</prgn> 和 <prgn>mpage</prgn> 软件包生成 PostScript 文件。
</sect1>

<sect1>打印帮助页面
<p>
下面的操作将帮助页面打印成PostScript文件或发送到打印机。
<example>
$ man -Tps <var>some-manpage</var> | lpr
$ man -Tps <var>some-manpage</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>合并两个 PostScript 或 PDF 文件
<p>
可以将两个 PostScript 文件或 PDF 文件合并。
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>
 
<sect1>命令耗时
<p>
显示某进程的耗时
<example>
# time <var>some-command</var> &gt;/dev/null
real    0m0.035s       # 挂钟时间(过去的真实时间)
user    0m0.000s       # 用户模式时间
sys     0m0.020s       # 核心模式时间
</example>
</sect1>

<sect1><prgn>nice</prgn> 命令
<p>
使用 <prgn>nice</prgn>(来自 GNU <package>shellutils</package> 软件包)可设置命令启动时的 nice 值。<prgn>renice</prgn>(<package>bsdutils</package>)和
 <prgn>top</prgn> 可以重设进程的 nice 值。nice 值为 19 代表最慢的(优先级最低的)进程；负值就“not-nice”，如 -20 代表非常快的(优先级高的)进程。只有超级用户可以设定负 nice 值。
<example>
# nice  -19 <var>top</var>                                      # very nice
# nice --20 <var>wodim -v -eject speed=2 dev=0,0 disk.img</var> # very fast
</example>
有时极端的 nice 值对系统弊大于利，所以使用该命令要小心。
</sect1>

<sect1 id="cronjob">日程安排(<prgn>cron</prgn>，<prgn>at</prgn>)
<p>
在 Linux 下使用 <prgn>cron</prgn> 和 <prgn>at</prgn> 进行任务日程安排。参阅 <manref name="at" section="1">、<manref name="crontab" section="5">、<manref name="crontab" section="8">。
<p> 
执行命令 <tt>crontab -e</tt> 创建或编辑 crontab 文件，为规律事务(按周期循环的事务)安排日程。下面的一个 crontab 文件样例：
<example>
# use /bin/sh to run commands, no matter what /etc/passwd says
SHELL=/bin/sh
# mail any output to `paul', no matter whose crontab this is
MAILTO=paul
# Min Hour DayOfMonth Month DayOfWeek command (Day... are OR'ed)
# run at 00:05, every day
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# run at 14:15 on the first of every month -- output mailed to paul
15 14 1  * *   $HOME/bin/monthly
# run at 22:00 on weekdays(1-5), annoy Joe. &percnt; for newline, last &percnt; for cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Where are your kids?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# run at 03:40 on the first Monday of each month
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
执行 <prgn>at</prgn> 命令为偶然任务(只执行一次的任务)安排日程：
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">用 <prgn>screen</prgn> 来定制控制台
<p>
<prgn>screen</prgn> 程序允许在单一的物理终端或终端模拟窗口运行多个伪终端，每个伪终端都拥有自己的交互式 shell。即便可以使用 Linux 伪终端或多个
<prgn>xterm</prgn> 窗口，研究一下如何设置 <prgn>screen</prgn> 丰富的特性仍很有益，这些特性包括：
<list compact>
<item>回溯历史显示， 
<item>拷贝和粘贴，
<item>输出到日志，
<item>图形入口， 
<item>将终端与整个 <prgn>screen</prgn> 会话<strong>分离</strong>，稍后再连接。
</list>

<sect2>远程访问方案
<p>
如果你经常从远程终端登录到 Linux 机器或使用 VT100 终端程序，<prgn>screen</prgn> 的 <strong>detach</strong>(分离)特性将简化你的生活。
<p>
<enumlist compact>
<item>通过拔号连接登录，运行了一个非常复杂的 <prgn>screen</prgn> 会谈，打开了好几个窗口，有编辑器和其它一些程序。
<item>突然你需要离开终端一下，但你并不想挂断连接中止工作。
<item>输入<tt>^A d</tt><strong>离开</strong>会话，然后登出系统。(或者更简单些，输入<tt>^A DD</tt>离开会话并自动登出系统)
<item>当你回来时，需要再次登录，可输入命令 <tt>screen -r</tt>，<prgn>screen</prgn> 会如魔法般地重新连接上所有打开的窗口。
</enumlist>

<sect2>典型的 <prgn>screen</prgn> 命令
<p>
一但打开了 <prgn>screen</prgn> 程序，除了命令按键(默认为<tt>^A</tt>)所有的键盘输入都被送到当前窗口，所有的 <prgn>screen</prgn> 命令均按特定方式输入：<tt>^A</tt>加一个单键命令[加一些参数]的。常用的命令有：
<example>
^A ?     显示帮助屏幕(显示命令集)
^A c     创建并切换到新窗口
^A n     跳到下一个窗口
^A p     跳到上一个窗口
^A <var>0</var>     跳到 <var>0</var> 号窗口
^A w     显示窗口列表
^A a     将 Ctrl-A 做为键盘输入发送到当前窗口
^A h     对当前窗口做硬拷贝写入到文件
^A H     开始/中止将当前窗口事件记录到文件
^A ^X    锁定终端(密码保护)
^A d     从终端分离屏幕会话
^A DD    分离屏幕会话并退出登录
</example>
以上只是 <prgn>screen</prgn> 命令的一个很小的子集。只要是你认为 <prgn>screen</prgn> 能干的事，没准它真就可以！详情参阅 <manref name="screen" section="1">。

<sect2><prgn>screen</prgn> 会话中的退格键和Ctrl-H
<p>
在运行 <prgn>screen</prgn> 时，如果发现退格键和 / 或 Ctrl-H 无法正常工作，可编辑<file>/etc/screenrc</file>，找到这行：
<example compact>
bindkey -k kb stuff "\177"
</example>
将这注释掉(例如在句首添加“#”)。


</sect1>

<sect1 id="net-test">网络测试基础
<p>
安装 <package>netkit-ping</package>、<package>traceroute</package>、<package>dnsutils</package>、<package>ipchains</package>(适用于 2.2 版内核)、<package>iptables</package>(适用于 2.4 版内核) 和 <package>net-tools</package> 软件包，然后执行：
<example>
$ ping <var>yahoo.com</var>            # 检查 Internet 连接
$ traceroute <var>yahoo.com</var>      # 跟踪 IP 数据包
$ ifconfig                  # 检查主机设置
$ route -n                  # 检查路由设置
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # 检查<var>dns-server.com</var>的<var>host.dom</var> DNS 记录
      # 查找<var>{a|mx|any}</var>记录
$ ipchains  -L -n |less     # 检查包过滤(2.2 kernel)
$ iptables -L -n |less      # 检查包过滤(2.4 kernel)
$ netstat -a                # 查找系统上所有打开的端口
$ netstat -l --inet         # 查找系统监听的端口
$ netstat -ln --tcp         # 查找系统监听的 TCP 端口(端口数字)
</example>
</sect1>

<sect1 id="flush-mail">从本地缓冲池中清空(flush)邮件
<p>
从本地缓冲池中清空邮件：
<example>
# exim4 -q    # 清空待读邮件
# exim4 -qf   # 清空所有邮件
# exim4 -qff  # 清空冻结邮件
</example>
<tt>-qff</tt> 选项用在 <file>/etc/ppp/ip-up.d/exim</file> 脚本中效果更好。
在 Woody 和更老的版本中，使用 <prgn>exim</prgn> 代替 <prgn>exim4</prgn>。
</sect1>

<sect1 id="remove-mail">删除本地缓冲池中的冻结邮件
<p>
删除本地缓冲池中的冻结邮件并返回出错信息：
<example>
# exim4 -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
在 Woody 和更老的版本中，使用 <prgn>exim</prgn> 代替 <prgn>exim4</prgn>。
</sect1>

<sect1>再分发 <file>mbox</file> 中的信件
<p>
如果 home 目录没有空间继续处理邮件，<prgn>procmail</prgn> 将失败，
就需要对磁盘空间进行扩容，扩容完成后需要手工分发 <file>/var/mail/<var>username</var></file> 目录中的邮件到 home 目录中的分类邮箱，执行：
<example>
# /etc/init.d/exim4 stop
# formail -s procmail &lt;/var/mail/<var>username</var>
# /etc/init.d/exim4 start
</example>
在 Woody 和更老的版本中，使用 <prgn>exim</prgn> 代替 <prgn>exim4</prgn>。
</sect1>

<sect1>清空文件内容
<p>
要清空某些文件如日志文件的内容，千万不要使用 <tt>rm</tt> 删除文件然后再创建一个新的空文件，因为在两次操作的间隔，系统可能需要访问该文件。下面是清空文件内容的安全方法：
<example>
$ :&gt;<var>file-to-be-cleared</var>
</example>
</sect1>

<sect1 id="dummyfile">空文件
<p>
下面的命令可以创建空文件：
<example>
$ dd if=/dev/zero    of=<var>filename</var> bs=1k count=5 # 5KB 零内容
$ dd if=/dev/urandom of=<var>filename</var> bs=1M count=7 # 7MB 随机内容
$ touch <var>filename</var> #  创建一个 0 B 大小的文件 (如果文件存在，更新该文件的修改时间)
</example>
例如，最实用的用法是从 &debian; 启动软盘的 shell 中执行下列命令将硬盘 <file>/dev/hda</file> 的内容完全清空。
<example>
# dd if=/dev/urandom of=/dev/hda; dd if=/dev/zero of=/dev/hda
</example>

</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
<prgn>chroot</prgn> 程序，<manref name="chroot" section="8">，不需要重启系统，就可以在单独的系统上同时运行多个不同的 GNU/Linux 环境。
<p>
还可以在较快主机的 chroot 下运行某些需耗大量系统资源内存的程序如 <prgn>apt-get</prgn>
或 <prgn>dselect</prgn>，并将较慢子机的硬盘通过 NFS 方式挂载到主机，开放读/写权限，在主机上以 chroot 方式操作子机。

<sect2 id="chroot-debian">用 <prgn>chroot</prgn> 来运行不同版本的 &debian;
<p>
在 Sarege 中使用 <prgn>debootstrap</prgn> 命令很容易构造 chroot &debian;
体系。对于 Sarge 的后续发行版，用 <prgn>cdebootstrap</prgn>
命令加上适当的选项来代替 <prgn>debootstrap</prgn>。例如，在一台拥有快速
Internet 连接的机器的 <var>/sid-root</var> 下创建一个 Sid chroot：
<example>
main # cd /; mkdir <var>/sid-root</var>
main # debootstrap sid <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... 看它下载整个系统
main # echo "proc <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount <var>/sid-root</var>/proc
main # mount /dev/ <var>/sid-root</var>/dev -o bind
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # cd /dev; /sbin/MAKEDEV generic; cd -
chroot # apt-setup # 创建 /etc/apt/sources.list 文件
chroot # vi /etc/apt/sources.list # 将源指向 unstable
chroot # dselect  # 可以使用 aptitude，安装 mc 和 vim :-)
</example>
<p>
现在你就拥有了一个全功能 &debian; 子系统，可以尽情享受而不必担心主 &debian; 受到不利影响。
<p>
该 <prgn>debootstrap</prgn> 应用技巧还可以实现在没有 &debian; 安装盘的情况下，从另一个 GNU/Linux 发行版下安装 &debian;。参阅 <url id="&setup-chroot;">。

<sect2 id="chroot-console">设置 <prgn>chroot</prgn> 登录
<p>
输入 <tt>chroot <var>/sid-root</var> /bin/bash</tt> 非常简单，但这将保留当前的所有环境变量，你可能并不希望这样并且有时还会出问题。更好的方法是，在别的虚拟终端上执行另一个登录进程，登录到 chroot 目录。
<p>
在默认的 &debian; 系统中，从 <tt>tty1</tt> 到 <tt>tty6</tt> 运行 Linux 控制台，<tt>tty7</tt> 运行 X Window 系统，在本例中，我们将 <tt>tty8</tt> 设置成 chroot 控制台。按照<ref id="chroot-debian"> 中的描述创建好 chroot 系统后，就可以在主系统的 root shell 中输入：
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8" >> /etc/inittab
main # init q    # 重启 init
</example>

<sect2 id="chroot-x">配置 <prgn>chroot</prgn> 下的 X
<p>
想在 chroot 下安全地运行最新版的 X 和 GNOME 吗？完全可以！下面的例子将实现在虚拟终端 <tt>vt9</tt> 下运行 GDM。
<p>
首先，按照<ref id="chroot-debian">中描述的方法安装好 chroot 系统，从主系统的 root 下拷贝关键配置文件到 chroot 系统。
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # or use chroot console
chroot # cd /dev; /sbin/MAKEDEV generic; cd -
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # do s/vt7/vt9/ in [servers] section
chroot # /etc/init.d/gdm start
</example>
在此，编辑 <file>/etc/gdm/gdm.conf</file>，使其在 <tt>vt7</tt> 到 <tt>vt9</tt> 上创建虚拟终端。
<p>
现在可以很容易地能过切换 Linux 虚拟终端来实现在主系统的 X 环境和 chroot 系统的 X 环境之间转换，例如使用 Ctrl-Alt-F7 和 Ctrl-Alt-F9。酷吧！
<p>
[FIXME] 在 chroot 系统下 <prgn>gdm</prgn> 的 init 脚本中添加一条注释和一条链接。

<sect2 id="chroot-dist">使用 <prgn>chroot</prgn> 来运行其它发行版
<p>
很容易创建一个包含其它发行版的 chroot 环境。使用其它发行版的安装程序将它们安装到单独的硬盘分区中。例如 root 分区位于 <file><var>/dev/hda9</var></file>：
<example>
main # cd /; mkdir <var>/other-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/other-dist</var>
main # chroot <var>/other-dist</var> /bin/bash
</example>
接下来按照 <ref id="chroot-debian">、<ref id="chroot-console"> 和 <ref id="chroot-x"> 处理。

<sect2 id="chroot-build">使用 <prgn>chroot</prgn> 来编译软件包
<p>
这儿有一个很特殊的 chroot 软件包 <package>pbuilder</package>，它构造一个 chroot 系统并在其中编译软件包。该体系可用于检查软件包编译时关联关系是否正确，并确保编译生成的软件包中没有不必要的或错误的关联关系。

</sect1>

<sect1>怎样检查硬链接
<p>
<!-- two hard links?, one would be suffiecient? -->
检查两个文件是否是指向同一个文件的两个硬链接：
<example> 
$ ls -li <var>file1</var> <var>file2</var>
</example>
 
<sect1><prgn>mount</prgn> 硬盘上的镜像文件
<p>
如果 <file><var>file.img</var></file> 文件是硬盘内容的镜像文件，而且原始硬盘的配置参数为 <var>xxxx</var> = (bytes/sector) * (sectors/cylinder)，那么，下面的命令将其挂载到 <file>/mnt</file>：
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
注意绝大部分的硬盘都是 512 bytes/sector。

<sect1 id="smbmount">Samba
<p>
获取 Windows 文件的基本方法：
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # 挂载 Windows 的文件到 Linux
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # 列出某个计算机的共享目录
</example>
<p>
可从 Linux 检查 Samba网上邻居：
<example>
# smbclient -N -L <var>ip_address_of_your_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

<sect1>外来文件系统的操作工具
<p>
Linux 内核支持多种外来文件系统，想访问它们只需将其挂载到合适的文件系统下就行了。对某些文件系统，还提供专门工具不需要挂载，只依靠用户空间的程序，不需要内核提供文件系统支持，就能完成访问。
<list compact>
<item><package>mtools</package>: for MS-DOS filesystem (MS-DOS, Windows)
<item><package>cpmtools</package>: for CP/M filesystem
<item><package>hfsutils</package>: for HFS filesystem (native Macintosh)
<item><package>hfsplus</package>: for HFS+ filesystem (modern Macintosh)
</list>
对于创建和检查 MS-DOS FAT 文件系统 <package>dosfstools</package> 非常有用。
</sect1>

</sect>

<sect id="oops">需要注意的典型错误
<p>
这里有一些危险行为的例子。如果你是使用特权账号 <tt>root</tt>
的话，负面影响将会更大。

<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>
<!-- 
I know using quotes here are irregular but it is hard to read without it. 
-->
在象"<tt>rm -rf .*</tt>" 的命令行参数中使用通配符文件名，有可能造成危险的结果，
因为 "<tt>.*</tt>" 扩展为 "<tt>.</tt>" 和
"<tt>..</tt>"。
比较幸运的是，在 &debian; 发行版中，当前版本的 "<tt>rm</tt>" 
命令会检查文件名参数的健全性，会拒绝删除 "<tt>.</tt>" 和 "<tt>..</tt>"。
但这种检查并不一定在其它地方存在。
尝试下面的操作来参看通配符文件名是怎样工作的。
<p>
<list compact>
<item>"<tt>echo *</tt>" : 列出当前目录下所有不以点开头的文件和目录
<item>"<tt>echo .[^.]*</tt>" : 列出当前目录下所有以点开头的文件和目录
<item>"<tt>echo .*</tt>" : 列出父目录下的所有东西以及父目录自身
<!-- FIXME: wrong in Etch -->
</list>

<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
由于你的过失，丢失象 <file>/etc/passwd</file> 这样的重要文件，是一件非常痛苦的事。&debian; 系统周期性的将他们备份到 <file>/var/backups/</file>。
当你恢复这些文件的时候，你需要设置适当的权限。
<example>
# cp /var/backups/passwd /etc/passwd
# chmod 644 /etc/passwd
</example>
参阅 <ref id="recover-status">。

</chapt>

