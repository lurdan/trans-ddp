<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.75"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->
<!-- DON'T TOUCH GROFF SECTION!!! -->

<chapt id="program">编程
<p>
不要用“test”命名可执行的测试文件。<prgn>test</prgn> 是一个 shell 的内建命令。

<sect>从哪儿开始
<p>
参考资源：
<list compact>
<item><file>&dochome;<var>package</var></file> 下的文档和样例
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
更详细的文档可以从<url id="&gnuhome;" name="GNU">获得打印版本。
<p>
接下来的四个小节中包含了用不同的编程语言编写的脚本样例，该脚本创建一个包含用户帐户信息的文本文件，调用一组进程如 newusers 程序，将这些信息加入到 <file>/etc/passwd</file>。每个脚本均需要一个输入文件，该文件应包含格式如 <tt>first_name last_name password</tt> 的行。(这些脚本并不创建真正的用户目录。)
</sect>

<sect id="shell">Shell
<p>
理解类 Unix 系统如何工作的<strong>最好</strong>方法就是阅读 shell 脚本。在此，我们就 shell 编程做个简单的介绍。
参阅 <url id="&shell-mistakes;" name="Shell Mistakes"> 来学习更多的错误。

<sect1 id="bash">Bash &ndash; <strong>GNU</strong> 标准交互式 shell
<p>
Bash 参考资源：
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item>LDP <url id="&bashprogintro-howto;" name="BASH Programming - Introduction HOWTO">
作为开始信息。
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (安装 <package>bash-doc</package> 软件包阅读样例文件。)
<item><em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
</list>
<p>
一个简短的程序样例(从标准输入端创建帐户信息供 <prgn>newusers</prgn> 使用)：
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">POSIX shells
<p>
&debian; 中有几个软件包提供了 POSIX shell：
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 176
  <item>到目前为止最小和最快的 &ndash; 最适合用在初始化安装中
  </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 180
  <item>较小和较快的 &ndash; 比较适合用在初始化安装中
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essential: yes
  <item>Priority: required
  <item>Installed-Size: 580
  <item>较大和多特征的 &ndash; 应用了许多扩展
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 408
  <item>完全跟 AT&amp;T 的 ksh 类似
 </list>
</list>
<p>
如果你想编写具有通用性的 shell 脚本，最好写 POSIX shell 脚本。可将 <file>/bin/sh</file> 链接到 <prgn>ash</prgn> 或(<prgn>dash</prgn>)来测试脚本的 POSIX 兼容性。
避免用 bash 化 或 zsh 化的思维去编写脚本。
例如，应避免：
<list compact>
<item><tt>if [ <var>foo</var> == <var>bar</var> ] ; then ... </tt>
<item><tt>diff -u <var>file</var>.c{.orig,} </tt>
<item><tt>mkdir <var>/foo</var>{<var>bar</var>,<var>baz</var>} </tt>
</list>
<p>
本文档的 shell 描述，只适用于 POSIX 类型的 shell，不适用于包括 <prgn>tcsh</prgn>
在内的 <prgn>csh</prgn> 类型。

<sect1 id="shell-param">Shell 参数
<p>
几个需要记住的<strong>特殊参数</strong>：
<example compact>
$0      = shell 名称或 shel 脚本名称
$1      = 第一个(1)shell 参数
 ...
$9      = 第九个(9)shell 参数
$#      = 位置参数的个数
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = 最近执行的命令的退出状态
$$      = 当前 shell 脚本的 PID
$!      = 最近启动的后台作业的 PID
</example>
<p>
需要记住的基本<strong>扩展参数</strong>：
<example compact>
    形式        如果设置了 <var>var</var>      如果没有设置 <var>var</var>
${<var>var</var>:-<var>string</var>}  $<var>var</var>                <var>string</var>
${<var>var</var>:+<var>string</var>}  <var>string</var>              null
${<var>var</var>:=<var>string</var>}  $<var>var</var>                <var>string</var> 
                                    (并且执行 <var>var</var>=<var>string</var>)
${<var>var</var>:?<var>string</var>}  $<var>var</var>                (返回 <var>string</var> 然后退出)
</example>
在此，冒号“:”在所有运算表达式中事实上均是可选的。
<list compact>
<item>有“:” = 运算表达式测试“存在”和“非空”。
<item>没有“:” = 运算表达式仅测试“存在”。
</list>
<p>
需要记住的<strong>替换参数</strong>：
<example compact>
    形式        	结果
${<var>var</var>&percnt;<var>suffix</var>}   删除位于 var 结尾的 <var>suffix</var> 最小匹配模式
${<var>var</var>&percnt;&percnt;<var>suffix</var>}  删除位于 var 结尾的 <var>suffix</var> 最大匹配模式
${<var>var</var>#<var>prefix</var>}   删除位于 var 开头的 <var>prefix</var> 最小匹配模式
${<var>var</var>##<var>prefix</var>}  删除位于 var 开头的 <var>prefix</var> 最大匹配模式
</example>

<sect1 id="shell-redirect">Shell 重定向
<p>
需要记住的基本<strong>重定向</strong>(redirection)运算符(在此[<var>n</var>]表示定义文件描述符的可选参数)：
<example compact>
[<var>n</var>]&gt; <var>file</var>     重定向标准输出(或 <var>n</var>)到 <var>file</var>。
[<var>n</var>]&gt;&gt; <var>file</var>    重定向标准输出(或 <var>n</var>)到 <var>file</var>。
[<var>n</var>]&lt; <var>file</var>     将<var>file</var>重定向到标准输入(或 <var>n</var>)。
[<var>n1</var>]&gt;&amp;<var>n2</var>      重定向标准输出(或 <var>n1</var>) 到<var>n2</var>。
2&gt; <var>file</var> &gt;&2    重定向标准输出和错误输出到 <var>file</var>。
| <var>command</var>     将标准输出通过管道传递给 <var>command</var>。
2&gt;&1 | <var>command</var> 将标准输出或错误输出通过管道传递给 <var>command</var>。
</example>
在这里：
<list compact>
<item>stdin:  标准输入 (文件描述符 = 0)
<item>stdout: 标准输出 (文件描述符 = 1)
<item>stderr: 标准错误 (文件描述符 = 2)
</list>
<p>
shell 允许你通过使用 <prgn>exec</prgn> 内嵌一个任意的文件描述符来打开文件。
<example>
$ echo Hello &gt;foo
$ exec 3&lt;foo 4&gt;bar  # 打开文件
$ cat &lt;&amp;3 &gt;&amp;4       # 重定向标准输入到 3,标准输出到 4
$ exec 3&lt;&amp;- 4&gt;&amp;-    # 关闭文件
$ cat bar
Hello
</example>
在这里， <var>n</var><tt>&lt;&amp;-</tt> 和 <var>n</var><tt>&gt;&amp;-</tt>
表示关闭文件描述符 <var>n</var>。

<sect1 id="shell-cond">Shell 条件表达式
<p>
每条命令均可返回一个<strong>退出状态</strong>，这个状态值可用于条件表达式：
<list compact>
<item>成功：0 (True)
<item>错误：1&ndash;255 (False)
</list>
注意该用法，返回值0用来表示“true”与计算机其它领域中常见的转换是不同的。另外`['等阶于使用<prgn>test</prgn>命令进行参数赋值`]'相当于一个条件表达式。
<p>
需要记住的常用基本<strong>条件表达式</strong>：
<example compact>
<var>command</var> && <var>if_success_run_this_command_too</var> || true
<var>command</var> || <var>if_not_success_run_this_command_instead</var>

if [ <var>conditional_expression</var> ]; then  
 <var>if_success_run_this_command</var>
else
 <var>if_not_success_run_this_command</var>
fi
</example>
当 shell 使用 <tt>-e</tt> 调用的时候，
需要使用 <tt>|| true</tt> 来确保这个 shell 不会在本行意外退出。
<p>
在条件表达式中使用的<strong>文件</strong>比较运算符有：
<example compact>
-e <var>file</var>         <var>file</var> 存在则返回True。
-d <var>file</var>         <var>file</var> 存在且是一个目录则返回 True。
-f <var>file</var>         如果 <var>file</var> 存在且是一个普通文件则返回 True。
-w <var>file</var>         如果 <var>file</var> 存在且可写则返回 True。
-x <var>file</var>         如果 <var>file</var> 存在且可执行则返回 True。
<var>file1</var> -nt <var>file2</var> 如果 <var>file1</var> 比 <var>file2</var> 新则返回 True。(指修改日期)
<var>file1</var> -ot <var>file2</var> 如果 <var>file1</var> 比 <var>file2</var> 旧则返回 True。(指修改日期)
<var>file1</var> -ef <var>file2</var> 如果两者是相同的设备和具有相同的结点(inode)数则返回 True。
</example>
<p>
条件表达式中使用的<strong>字符串</strong>比较运算符有：
<example compact>
     -z <var>str</var>    如果 <var>str</var> 长度为零则返回 True。
     -n <var>str</var>    如果 <var>str</var> 长度为非零则返回 True。
<var>str1</var> == <var>str2</var>   如果字符串相等则返回 True。
<var>str1</var> =  <var>str2</var>   如果字符串相等则返回 True。
    (使用"=="代替"="符合严格意义上的 POSIX 兼容) 
<var>str1</var> != <var>str2</var>   如果字符串不相等则返回 True。
<var>str1</var> &lt;  <var>str2</var>   如果 <var>str1</var> 排在 <var>str2</var> 之前则返回 True(与当前位置有关)。
<var>str1</var> &gt;  <var>str2</var>   如果 <var>str1</var> 排在 <var>str2</var> 之后则返回 True(与当前位置有关)。
</example>
<p>条件表达式中的<strong>算术</strong>整数比较运算符有<tt>-eq</tt>、<tt>-ne</tt>、<tt>-lt</tt>、<tt>-le</tt>、<tt>-gt</tt>和<tt>-ge</tt>。
</sect1>

<sect1 id="clprocess">命令行处理
<p>
shell按如下的方式处理脚本：
<list compact>
<item>用这些元字符将其分割成 <strong>tokens</strong>：SPACE, TAB, NEWLINE, ;, (, ), &lt;, &gt;, |, &amp;
<item>如果不在"..."或'...'内就检查 <strong>keyword</strong>(循环检查)
<item>如果不在"..."或'...'内就扩展 <strong>alias</strong>(循环检查) 
<item>如果不在"..."或'...'内就扩展 <strong>brace</strong>，<tt>a{1,2}</tt> -> <tt>a1 a2</tt>
<item>如果不在"..."或'...'内就扩展 <strong>tilde</strong>, ~<var>user</var> -> <var>user</var>'s home 
directory
<item>如果不在'...'内就扩展 <strong>parameter</strong>, $<var>PARAMETER</var>
<item>如果不在'...'内就扩展 <strong>command substitution</strong>, $(<var>command</var>)
<item>如果不在"..."或'...'内就用 $IFS 分割成 <strong>words</strong>
<item>如果不在"..."或'...'内就扩展 <strong>pathname</strong> *?[]
<item>查找 <strong>command</strong>
<list compact>
<item>function
<item>built-in
<item>file in $PATH
</list>
<item>循环
</list>
<p>
在双单号内单引号将失效。
<p>
在 shell 里执行 <tt>set -x</tt> 或者使用 <tt>-x</tt> 选项调用 shell，
该 shell 将会显示出所有执行的命令。
这对调试非常有用。
</sect1>

</sect>

<sect id="awk">Awk
<p>
Awk的参考资源：
<list compact>
<item><em>Effective awk Programming</em>, 3rd edition (O'Reilly)
<item><em>Sed &amp; awk</em>, 2nd edition (O'Reilly)
<item><manref name="mawk" section="1"> 和 <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
简短的程序样例(创建 <prgn>newusers</prgn> 命令输入)：
<example>
#!/usr/bin/awk -f
# Script to create a file suitable for use in the 'newusers' command,
# from a file consisting of user IDs and passwords in the form:
# first_name last_name password
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
          "  where:\n" \ 
          "    startUID is the starting userid to add, and\n" \
          "    file is an input file in form:\n" \
          "      first_name last_name password\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Starting UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
&debian; 中有两个软件包提供了 POSIX <package>awk</package>：
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priority: required
  <item>Installed-Size: 228
  <item>较小和较快 &ndash; 适于默认安装
  <item>编译时的限制存在
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priority: optional
  <item>Installed-Size: 1708
  <item>较大和多特征的 &ndash; 应用了许多扩展
  <list compact>
   <item>System V Release 4 version of UNIX
   <item>Bell Labs awk
   <item>GNU-specific
  </list>
 </list>
</list>
</sect>

<sect id="perl">Perl
<p>
运行于类 Unix 系统上的<strong>解释器</strong>。
<p>
Perl 参考资源：
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3rd edition (O'Reilly)
<item><url id="&perlhome;" name="The Perl Directory">
</list>
<p>
简短的程序样例(创建 <prgn>newusers</prgn> 命令输入)：
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
安装 Perl 模块 <var>module_name</var>：
<example>
# perl -MCPAN -e 'install <var>module_name</var>'
</example>
 
</sect>

<sect id="python">Python
<p>
一个不错的面向对象的解释器。
<p>
Python 参考资源：
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
<item><url id="&pythonhome;" name="Python Programming Language">
</list>
<p>
简短的程序样例(创建 <prgn>newusers</prgn> 命令输入)：
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input filename. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirst_name last_name password\n"
                return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crashes with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect id="make">Make
<p>
Make 参考资源：
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2nd edition (O'Reilly)
</list>
<p>
简单自动变量：
<p>
语法规则：
<example>
<var>target</var>: [ <var>prerequisites</var> ... ]
 [TAB]  <var>command1</var>
 [TAB]  -<var>command2</var> # ignore errors
 [TAB]  @<var>command3</var> # suppress echoing
</example>
在此<tt>[TAB]</tt>代表一个 TAB 符。
在完成 <prgn>make</prgn> 变量代换后，shell 将逐行进行解释。在行尾使用 <tt>\</tt> 可以续行。使用 <tt>$$</tt> 可将 <tt>$</tt> 加入到 shell 脚本的环境变量中。
<p>
适用于 <var>target</var> 和 <var>prerequisites</var> 的隐含的等价规则：
<example>
&percnt;: &percnt;.c header.h
</example>
or,
<example>
&percnt;.o: &percnt;.c header.h
</example>
在此，<var>target</var> 包含了 <tt>&percnt;</tt> 字符(确切地说是其中之一)，<tt>&percnt;</tt> 可匹配实际的 target 文件名中任何非空子串。<var>prerequisites</var> 同样也使用 <tt>&percnt;</tt> 来显示它们的名字是如何关联到实际的 target 文件名的。
<p>
用 <strong>Suffix rules</strong> 方法来定义 <prgn>make</prgn> 的隐含规则(implicit rules)已经<strong>过时</strong>。GNU <prgn>make</prgn> 因为兼容性的考虑仍支持它，但只要有可能就应该使用与之等价的模版规则(pattern
rules)：
<example>
old suffix rule --&gt; new pattern rule
.c:             --&gt; &percnt;  : &percnt;.c
.c.o:           --&gt; &percnt;.o: &percnt;.c
</example>
上述规则所使用的自动变量：
<example>
foo.o: new1.c new2.c old1.c new3.c
$@ == foo.o                         (target)
$< == new1.c                        (first one)
$? == new1.c new2.c new3.c          (newer ones)
$^ == new1.c new2.c old1.c new3.c   (all)
$* == `&percnt;' matched stem in the target pattern.
</example>
变量参考：
<example>
foo1 := bar    # One-time expansion
foo2  = bar    # Recursive expansion
foo3 += bar    # Append
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extracts "directory"
 $(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
执行<tt>make -p -f/dev/null</tt>可查看内部自动规则。
</sect>

<sect id="c">C
<p>
准备工作：
<example>
# apt-get install glibc-doc manpages-dev libc6-dev gcc
</example>
<p>
C参考资源：
<list compact>
<item><tt>info libc</tt> (C library function reference)
<item><manref name="gcc" section="1">
<item><manref name="each_C_library_function_name" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>,
 2nd edition (Prentice Hall). <url id="&kandr-c;">
<item>ISO C standard. <url id="&iso-c;">
</list>
<p>

<sect1>简单 C 编程(<prgn>gcc</prgn>)
<p>
一个简单的例子，将 <file>example.c</file> 和库函数 <file>libm</file> 编译成可执行文件 <prgn>run_example</prgn>：
<example>
$ cat &gt; example.c &lt;&lt; EOF
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* prevent buffer overflow */
        y[10] = '\0'; /* fill to make sure string ends with '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o run_example example.c -lm
$ ./run_example
        1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
        2, 3.082, ./run_exam, 1234567890qwerty
</example>
在此，<prgn>sqrt()</prgn> 链接库函数 <file>lib<strong>m</strong></file> 需要 <tt>-l<strong>m</strong></tt> 选项。真正的库函数是位于 <file>/lib/</file> 下的 <file>libm.so.6</file>，它是 <file>libm-2.1.3.so</file> 的一个符号链接。
<p>
看看输出文本中最后的参数，尽管指定了 <tt>&percnt;10s</tt>，它还是多于10个字符。
<p>
使用不带边界检查的指针内存操作函数如 <prgn>sprintf</prgn> 和 <prgn>strcpy</prgn> 会妨碍缓冲区溢出侦测，故使 用<prgn>snprintf</prgn> 和 <prgn>strncpy</prgn>。
</sect1>

<sect1>调试

<sect2>使用 <prgn>gdb</prgn> 进行调试
<p>
准备工作：
<example>
# apt-get install gdb
</example>
<p>
<prgn>gdb</prgn>参考资源：
<list compact>
<item><tt>info gdb</tt> (tutorial)
<item><manref name="gdb" section="1">
<item><url id="&gdbtutorial;">
</list>
<p>
使用 <tt>-g</tt> 选项编译程序就可使用 <prgn>gdb</prgn> 进行调试。许多命令都可以缩写。Tab 扩展功能和在 shell 中的一样。
<example>
$ gdb program
(gdb) b 1                # 在line 1 设置断点
(gdb) run <var>arg1 arg2 arg3</var> # 运行程序
(gdb) next               # 下一行
...
(gdb) step               # 前进一步
...
(gdb) p parm             # 打印 parm  
...
(gdb) p parm=12          # 设置其值为 12
</example>
<p>
在 Emacs 环境下调试程序，参阅<ref id="editkey">。
<p>
&debian; 系统上所有默认安装的二进制文件都已经进行了 strip 操作，
调试符号已经被移除。
为了能够让 <prgn>gdb</prgn> 对 &debian; 软件包进行调试，
相关的软件包需要使用下面的方法重新打包：
<list compact>
<item>编辑 <file>debian/control</file> 来改变软件包的 
<url id="&policy-version;" name="版本">。
<item>检查打包脚本，确保使用 <tt>CFLAGS=-g-Wall</tt> 来编译二进制文件。
<item>设置 <tt>DEB_BUILD_OPTIONS=nostrip,noopt</tt> 来建立  &debian; 包。
</list>
更多信息请参阅： <url name="Policy 10.1" id="&strip-symbols;">。
</sect2>

	
<sect2 id="ss-ldd">检查库函数关联关系
<p>
使用<prgn>ldd</prgn>可查看程序与库函数的关联关系：
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
可在 chrooted 环境下使用 <prgn>ls</prgn> 检查上述库函数在你的 <prgn>chroot</prgn> 环境中是否可见。
<p>
下面的命令也很有用：
<list compact>
<item><prgn>strace</prgn>: 跟踪系统调用和消息
<item><prgn>ltrace</prgn>: 跟踪库函数调用
</list>
</sect2>
 
<sect2>使用内存查漏工具进行调试
<p>
&debian;中有几个内存查漏工具。
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package> (没有软件包，从 
 <url id="&memwatch-home;" name="memwatch"> 获取。)
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item>来自 <url id="&parasofthome;" name="Parasoft"> 的 <tt>Insure++</tt>(非自由软件，商业付费)
</list>
<p>
亦可查阅<url id="&mallocdebughome;" 
  name="Debugging Tools for Dynamic Storage Allocation and Memory Management">.

<sect1>Flex &ndash; 更好的 Lex
<p>
<prgn>flex</prgn> 是一个快速的词法分析机生成器。
<p>
<prgn>flex</prgn> 参考资源：
<list compact>
<item><tt>info flex</tt> (教程)
<item><manref name="flex" section="1">
</list>
<p>
需要提供你自己的 <prgn>main()</prgn> 或 <prgn>yywrap()</prgn>，或者你的
<file>program.l</file> 象这样不带library编译(<prgn>yywrap</prgn> 是一个宏；<tt>&percnt;option main</tt> 隐含地打开了 <tt>&percnt;option
noyywrap</tt>)：
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
另外，还可以在 <prgn>cc</prgn> 命令行末尾加上 <tt>-lfl</tt> 链接选项进行编译(象 AT&amp;T-Lex 使用 <tt>-ll</tt> 一样)，此时就不需要 <tt>&percnt;option</tt> 了。
</sect1>

<sect1>Bison &ndash; 更好的 Yacc
<p>
&debian; 中有几个软件包提供了与 Yacc 兼容的 LALR 词法生成器：
<p>
<list compact>
 <item><package>bison</package>: GNU LALR parser generator
 <item><package>byacc</package>: The Berkeley LALR parser generator
 <item><package>btyacc</package>: Backtracking parser generator based on <package>byacc</package>
</list>
<p>
<prgn>bison</prgn> 参考资源：
<list compact>
<item><tt>info bison</tt> (教程)
<item><manref name="bison" section="1">
</list>
<p>
需要提供自己的 <prgn>main()</prgn> 和 <prgn>yyerror()</prgn>。<prgn>main()</prgn> 调用 <prgn>yyparse()</prgn>，而 <prgn>yyparse()</prgn> 调用 <prgn>yylex()</prgn>，通常由 FleX 创建。
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> 一个 shell 脚本生成工具，由它生成的脚本能自动配置软件源码包，以适用于各种使用全套 GNU build 系统的类 UNIX 系统。
<p>
<prgn>autoconf</prgn> 会生成配置脚本 <prgn>configure</prgn>。<prgn>configure</prgn> 使用
<file>Makefile.in</file> 模版自动创建自定义 <file>Makefile</file>。
 
<sect2>编译并安装程序
<p>
&debian; 不会改动 <file>/usr/local/</file> 下的文件(参阅<ref id="diverse">)。所以如果是从源码编译程序，并将其安装到 <file>/usr/local/</file> 下，是不会影响到 &debian; 的。
<example>
$ cd src
$ ./configure --prefix=/usr/local
$ make
$ make install # this puts the files in the system
</example>

<sect2>卸载程序
<p>
如果仍保存有源码，对其使用了 <prgn>autoconf</prgn>/<prgn>automake</prgn>，并且记得是如何进行配置的：
<example>
$ ./configure <var>all-of-the-options-you-gave-it</var>
# make uninstall
</example>
<p>
另一种方法是，如果可以确定安装过程将文件都放在了 <file>/usr/local/</file>，并且该目录下没有什么别的重要文件，可用下面的命令将其全部删除：
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
如果不能确定文件安装到什么位置，最好使用 <package>checkinstall</package>，该命令可提供明确的卸载路径。
</sect1>

</sect>
<sect id="cgi">Web
<p>
通过下面的方法来制作一个基本的交互动态网页：
<list compact>
<item>使用 HTML 表单在浏览器里显示查询。
<item>填写和点击表单提交，将从浏览器传送一个将参数
<footnote>
这里 <tt>%nn</tt> 是用来编码的十六进制 <tt>nn</tt> 字符。
</footnote>
编码的 URL 到服务器。例如：
<list compact>
<item><tt>http://www.foo.dom/cgi-bin/program.pl?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.foo.dom/cgi-bin/program.py?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
<item><tt>http://www.foo.dom/program.php?VAR1=VAL1&amp;VAR2=VAL2&amp;VAR3=VAL3</tt>
</list>
<item>在 web 服务器上的 CGI 程序(任何一个 <prgn>program.*</prgn> 程序)
将接受编码的 "<tt>VAR1=VAL1 VAR2=VAL2 VAR3=VAL3</tt>" 参数作为环境变量
“<tt>QUERY_STRING</tt>” 的内容，并执行该环境变量。
<item>CGI 程序的<tt>标准输出</tt> 将作为一个交互动态网页输出到 web 浏览器。
</list>
出于安全的考虑，最好不要手工写新的程序来分析 CGI 参数。
在 Perl (参阅 <ref id="perl">)、Python (参阅 <ref id="python">)
和 <url id="&phphome;"name="PHP"> 中，有即定的模块具备这些功能。
当需要在客户端存储数据的时候，使用 cookies。
当需要在客户端进行数据处理的时候，经常使用 javascript。
<p>
更多信息，请参阅 <url id="http://hoohoo.ncsa.uiuc.edu/cgi/" name="The Common
Gateway Interface">、<url id="&apachehome;" name="The Apache Software 
Foundation"> 和 <url id="&javascripthome;" name="JavaScript">。
<p>
在浏览器地址栏里面直接输入编码的 URL 
<tt>&google-eg;</tt>，可以在 Google 搜索 “CGI tutorial”。
这也是一个查看 CGI 脚本在 Google 服务器上执行的好方法。
<!--
http://www.google.com/search?hl=en&ie=UTF-8&q=CGI+tutorial
http://stein.cshl.org/WWW/CGI/
http://stein.cshl.org/WWW/docs/handout.html
http://stein.cshl.org/WWW/software/mailmerge/
-->

<sect id="doc-prep">准备文档
<p>

<sect1 id="roff"><tt>roff</tt> 排版
<p>
传统上，<tt>roff</tt> 是主要的 Unix 文字处理系统。
<p>
参阅 <manref name="roff" section="7">、<manref name="groff" section="7">、<manref name="groff" section="1">、<manref name="grotty" section="1">、<manref name="troff" section="1">、<manref name="groff_mdoc" section="7">、<manref name="groff_man" section="7">、<manref name="groff_ms" section="7">、<manref name="groff_me" section="7">、<manref name="groff_mm" section="7"> 以及 <tt>info groff</tt>。
<p>
<prgn>-me</prgn> 宏提供了一个不错了说明文档。如果使用的是 groff(1.18或更新的版本)，找到 <file>&f-meintro;</file> 并执行下面的命令：
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
下面的命令将生成一个完整的纯文本文件：
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
如果想打印出来，可使用 PostScript 输出：
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>




<sect1 id="sgml">SGML
<p>
准备工作：
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
<package>debiandoc-sgml</package> 参考资源：
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em><url name="DocBook: The Definitive Guide"
   id="&f-docbook-defguide;"></em>，作者 Walsh 和 Muellner，(O'Reilly 出版社)
      (<package>&p-docbook-defguide;</package> 软件包)
</list>
<p>
SGML 能管理多种格式的文档。更简单的 SGML 系统是 Debiandoc，本文档就使用到它完成的。只需对原始的文本文件的下列字符进行少许转换：
<!-- nbsp bug in PDF ? -->
<list compact>
<item>"&lt;" --&gt; <tt>&amp;lt;</tt>
<item>"&gt;" --&gt; <tt>&amp;gt;</tt>
<item>"&nbsp;" --&gt; <tt>&amp;nbsp;</tt> (非中断空格)
<item>"&amp;" --&gt; <tt>&amp;amp;</tt>
<item>"&percnt;" --&gt; <tt>&amp;percnt;</tt>
<item>"(c)" --&gt; <tt>&amp;copy;</tt>
<item>"&ndash;" --&gt; <tt>&amp;ndash;</tt>
<item>"&mdash;" --&gt; <tt>&amp;mdash;</tt>
</list>
<p>
设置章节为非打印注释，输入：
<example>
&lt;!-- State issue here ... --&gt;
</example>
设置章节为可控注释，输入：
<example>
&lt;![ &percnt;FIXME; [ State issue here ... ]]&gt;
</example>
在 SGML 中，仅条目的<em>首次声明</em>(first definition)有效。例如：
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
最终结果是“Data 1”。如果第一行使用“IGNORE”而非“INCLUDE”，则最终结果为“Data 2”(第二行是一个候选声明)。同样，重复出现的短语可分别提前在文档中定义。
<example>
&lt;!entity <var>whoisthis</var> "my"&gt;
Hello &amp;<var>whoisthis</var>; friend.
This is &amp;<var>whoisthis</var>; book.
</example>
该定义的结果如下：
<example>
Hello my friend.
This is my book.
</example>
可参阅 <url id="&examples;" name="examples"> 目录中简短的 SGML 样例文件<file>sample.sgml</file>。
<p>
当 SGML 文档逐渐变大时，作为后端文本处理器使用的 TeX 偶尔会错误。
参阅 <ref id="texlatex">。

<!-- XXX FIXME XXX: Add XML section-->

<sect1 id="texlatex">TeX/LaTeX
<p>
准备：
<example>
# tasksel # select Miscellaneous  --&gt; TeX/LaTeX environment
</example>
LaTeX 参考：
<list compact>
<item><url id="&tetex-howto;" name="The teTeX HOWTO: The Linux-teTeX Local Guide">
<item><manref name="tex" section="1">
<item><manref name="latex" section="1">
<item><em>The TeXbook</em>, by Donald E. Knuth, (Addison-Wesley)
      <footnote>
本书的 TeX 源文件放在
        <url id="&texbooksource;">。<url id="&texbookmacros;"> 含有大部分它所需要的宏。在注释掉第 7 行到第 10 行，并且增加 <tt>\input manmac \proofmodefalse</tt> 后，你可以使用 <prgn>tex</prgn> 处理这个文档。
	<p>
强烈推荐购买这本书(以及其它 Donald E. Knuth 的书)来代替使用其在线版本。
但是源文件是 TeX 输入的一个很好的例子。
       </footnote>
<item><em>LaTeX - A Document Preparation System</em>, by Leslie Lamport,
      (Addison-Wesley)
<item><em>The LaTeX Companion</em>, by Goossens, Mittelbach, Samarin,
      (Addison-Wesley)
</list>
<p>
这是一个很强大的排字环境。许多 SGML 处理器使用  LaTeX 作为他们的后端文本处理器。
由 <package>lyx</package>、<package>lyx-xforms</package>和
<package>lyx-qt</package> 提供的 Lyx，以及由 <package>texmacs</package> 提供的 
GNU TeXmacs 为 LaTeX 提供了一个好的“所见及所得”的编辑环境，然而，许多人选择使用 Emacs 和 Vim 作为源代码编辑器。
<p>
有许多在线资源存在：
<list compact>
<item><url id="&f-tetex-doc;" name="teTeX - A Documentation Guide">
      (<package>&p-tetex-doc;</package> 软件包)
<!-- translators please add the following documents: 
1) "The Not So Short Introduction to LaTeX2e"
(&f-tetex-doc; links to an English copy on harddisk (slightly outdated))
There exist many translations (and MUCH more documents in ../):
ftp://ftp.dante.de/tex-archive/info/lshort/
2) ftp://ftp.dante.de/tex-archive/info/<your-language>

PS: I (Jens) don't like the following references (too short, external)
-->
<item><url id="&pfaffbenhome;" name="A Quick Introduction to LaTeX">
<item><url id="&latexlyx;" name="A Simple Guide to Latex/Lyx">
<item><url id="&latexbasic;" name="Word Processing Using LaTeX">
<item><url id="&local-guide;" name="Local User Guide to teTeX/LaTeX">
</list>
当 SGML 文档不断增大后，TeX 偶尔会出错。可通过修改 <file>/etc/texmf/texmf.cnf</file>，增加缓冲池的容量来解决这个问题(更好的方法是编辑 <file>/etc/texmf/texmf.d/95NonPath</file> 然后运 行<prgn>update-texmf</prgn>)。

<sect1 id="literate">文学编程
<p>
有文学的程序员书写包含代码的文档来代替包含文档的代码。
这种方法确保程序有一个好的文档。
<p>
关于文学编程的更多信息，参阅
<url id="&literatehome;" name="Literate Programming">。

<sect2 id="noweb">Noweb
<p>
准备：
<example>
# apt-get install nowebm
</example>
Noweb 参考：
<list compact>
<item><url id="&nowebhome;" name="Noweb --- A Simple, Extensible Tool for Literate Programming">
<item><manref name="noweb" section="1">
</list>
<p>
这是一个类 WEB 的文学编程工具，独立于编程语言。由于提供了扩展而更简单。
<footnote>
这个 WEB 和 World Wide Web <strong>没有</strong> 任何关系。
WEB (用于 PASCAL) 和 CWEB (用于 C/C++) 是传统的文学编程工具。
</footnote>
当 <prgn>noweb</prgn> 被调用的时候，它将程序的源代码输出到在 noweb 中提到的文件中，它还将创建一个用于文档排版的 TeX 文件。
<p>
&debian; <package>ifupdown</package> 软件包是一个很好的例子。
<example>
$ apt-get source ifupdown
$ cd ifupdown*
$ make ifupdown.pdf ifupdown.ps
</example>

<sect2 id="doxygen">Doxygen
<p>
准备：
<example>
# apt-get install doxygen doxygen-doc doxygen-gui
</example>
Doxygen 参考(由 <prgn>doxygen</prgn> 创建)：
<list compact>
<item><url id="&doxygenhome;" name="Homepage">
<item><url id="/usr/share/doc/doxygen-doc/html/index.html">
</list>
<p>
它能够为 C++、C、 Java、 IDL 和某些范围的 PHP 和 C# 程序产生 HTML、 RTF、 Unix 手册页、 PostScript 和 PDF(使用 LaTeX)文档。
Doxygen 与 JavaDoc (1.1)、 Qt-Doc 和 KDOC 兼容，它有特定的设计用来与用  Troll Tech 的 
<url id="&qthome;" name="Qt"> 工具包制作的项目兼容。
他甚至可以为没有文档的程序创建从属图、协作图和图形化的类分层图。输出类似于 Qt 的文档。

<sect id="packaging">打包
<p>
准备工作：
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
                  &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # if Potato
</example>
有关打包的参考资源：
<list compact>
 <item><ref id="pkg-basics"> (basics)
 <item>Debian New Maintainers' Guide (tutorial)
 <item><manref name="dh-make" section="1">
 <item>Debian Developer's Reference (best practice)
 <item>Debian Policy Manual (authoritative)
 <item>Packaging Manual (Potato) 
</list>

<sect1 id="pack-binary">单个二进制文件打包
<p>
Joey Hess 的快速和粗糙的打包法：生成一个单独的二进制包
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mypackage
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: my little package
 Don't expect much.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">使用工具打包
<p>
使用 <prgn>dh_make</prgn> 软件包中的 <package>dh-make</package> 工具创建一个基线包，接着按照 <manref
name="dh-make" section="1"> 中描述的方法打包。会用到 <prgn>debian/rules</prgn> 中的 <prgn>debhelper</prgn>。
<p>
一个较老的方法是使用 <package>debmake</package> 软件包中的 <prgn>deb-make</prgn>。不需要 <prgn>debhelper</prgn> 脚本，仅需要 shell 环境。请不要再使用这种方法。
<p>
有关多种源码包的例子，参阅“mc”(<tt>dpkg-source -x
mc_4.5.54.dsc</tt>)，其中用到 Adam Heath(<email>doogie@debian.org</email>)的“sys-build.mk”以及“glibc”(<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>)它由后来的 Joel Klecker(<email>espy@debian.org</email>)所写的另一个系统打包。

</sect>

</chapt>
