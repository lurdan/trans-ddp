<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.22"  -->

<chapt id="gnupg">GnuPG

<p>
参考资源：
<list compact>
<item><manref name="gpg" section="1">. 
<item><file>&dochome;gnupg/README.gz</file>
<item><em>GNU 隐私手册</em>位于
 <file>&dochome;gnupg-doc/GNU_Privacy_Handbook/</file>
 (安装 <package>gnupg-doc</package> 软件包)
</list>

<sect>安装 GnuPG
<p>
<example>
# gpg --gen-key                   # 生成新的密钥
# gpg --gen-revoke <var>my_user_ID</var>     # 为 <var>my_user_ID</var> 生成吊销密钥
# host -l pgp.net | grep www|less # 查找 pgp keyservers
</example>
配置文件 <file>$HOME/.gnupg/gpg.conf</file>(或是先前的位置 <file>$HOME/.gnupg/options</file>)中一个完好的预设 keyserver 包含：
<example>
keyserver hkp://subkeys.pgp.net
</example>
必须注意<strong>不能创建 2 个以上的 sub-keys</strong>，如果这样做了，pgp.net 上的 keyservers 会<strong>废除</strong>(corrupt)你的密钥。使用新版的 <package>gnupg</package>(>1.2.1-2)来处理这些废除的 subkeys。参阅 <url id="&gpg-subkeys;">。
<p>
</sect>

<sect>使用 GnuPG
<p>
文件处理：
<example>
$ gpg  [options]  <var>command  [args]</var>
$ gpg {--armor|-a} {--sign|-s} <var>file</var> # 对 file 签名，并保存在文本文件 <var>file</var>.asc 中
$ gpg --clearsign <var>file</var>              # clear-sign 信息
$ gpg --clearsign --not-dash-escaped <var>patchfile</var>  # clear-sign patchfile
$ gpg --verify <var>file</var>                 # 校验 clear-signed <var>file</var>
$ gpg -o <var>file.sig</var> {-b|--detach-sig} <var>file</var> # create detached signature
$ gpg --verify <var>file.sig</var> <var>file</var>        # 用 <var>file.sig</var> 校验 <var>file</var>
$ gpg -o <var>crypt_file</var> {--recipient|-r} <var>name</var> {--encrypt|-e} <var>file</var> 
        # public-key encryption intended for name
$ gpg -o <var>crypt_file</var> {--symmetric|-c} <var>file</var> # 对称加密
$ gpg -o <var>file</var> --decrypt crypt_file  # 解密
</example>
</sect>

<sect>管理 GnuPG
<p>
密钥管理：
<example>
$ gpg --edit-key <var>user_ID</var>               # “help”获得帮助，交互式
$ gpg -o <var>file</var> --exports                # 将所有密钥导出到 <var>file</var> 
$ gpg --imports <var>file</var>                   # 从 <var>file</var> 导出所有密钥
$ gpg --send-keys <var>user_ID</var>              # 将 <var>user_ID</var> 的密钥发送给 keyserver
$ gpg --recv-keys <var>user_ID</var>              # 从 keyserver 接收 <var>user_ID</var> 的密钥
$ gpg --list-keys <var>user_ID</var>              # 列出 <var>user_ID</var> 的密钥
$ gpg --list-sigs <var>user_ID</var>              # 列出 <var>user_ID</var> 的 sig
$ gpg --check-sigs <var>user_ID</var>             # 检查 <var>user_ID</var> 的 sig
$ gpg --fingerprint <var>user_ID</var>            # 检查 <var>user_ID</var> 的指纹
$ gpg --list-sigs | grep '^sig' | grep '[User id not found]' \
  | awk '{print $2}' | sort -u | xargs gpg --recv-keys # 获取未知的密钥
  # 更新所有未知 sigs.
$ gpg --refresh-keys                   #更新本地 keyring
</example>
Trust 代码：
<example>
-         没指定任何 ownertrust / 还没进行计算。
e         Trust 计算失败。
q         没有足够的信息进行计算。
n         该密钥不可信。
m         最低限度的可信(Marginally trusted)。
f         完全可信(Fully trusted)。
u         绝对可信(Ultimately trusted)。
</example>
下面的操作将我的 key “<var>A8061F32</var>” 上载到公共 keyserver <tt>hkp://subkeys.pgp.net</tt>：
<example>
$ gpg --keyserver hkp://subkeys.pgp.net --send-keys <var>A8061F32</var>
</example>
</sect>

<sect>在应用程序中使用 GnuPG
<p>
<sect1>在 Mutt 中使用 GnuPG
<p>
如果 GnuPG 程序速度很慢，可以将以下内容加入 <file>~/.muttrc</file>
以阻止它自动启动，并使其能在 index 菜单下按‘<tt>S</tt>’手动启动。
<example>
macro index S ":toggle pgp_verify_sig\n"
set pgp_verify_sig=no
</example>

<sect1 id="vimgpg">在 Vim 中使用 GnuPG
<p>
将 <url id="&examples;"
name="examples subdirectory"> 下的 <file>_vimrc</file> 文件的内容加入到 <file>~/.vimrc</file> 就可以运行 GnuPG了。

</chapt>
