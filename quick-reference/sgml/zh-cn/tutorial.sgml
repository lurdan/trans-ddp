<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.94"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="tutorial">&debian; 指南
<p>
这一节为真正的新手提供一个熟悉的 &debian; 世界，如果您已经使用了一段时间的
类 unix 操作系统，那么您应该已经了解我在这里所说的一切。那么请用这个来做一个实战
检验。
<sect id="first">开始了
<p>
<!-- new content -->
在您的电脑上安装完 &debian; 系统以后，您需要学习一点东西以便使用它，让我们来给您
做一个快速的培训。

<sect1 id="login-root">用超级用户登录到命令提示符
<p>
<!-- new content -->
在重新启动系统的时候，您处在一个图形的登录界面，或者字符界面的登录界面，这个
取决于您初始安装时所选择了那些软件包，简单的说，如果您现在处在图形登录界面，
那么按下 Ctrl-Alt-F1
<footnote>
左边的 Ctrl 键和左边的 Alt 键和 F1 键同时按下
</footnote>
来获得字符界面。
<p>
假设您的主机名是 <tt><var>foo</var></tt>,那么登录提示符看起来是这样的：
<example>
<var>foo</var> login:
</example>
输入 <tt>root</tt>，然后按回车键，然后会提示输入密码，就是您在安装过程中所输入的
密码。在& debian; 系统中，按照 Unix 的习惯，密码是不可见的。然后系统就会输出欢迎
信息而且给出 root 的命令提示符等待您的输入。
<footnote>
如果在 <file>/etc/motd</file> 里编辑了欢迎信息，将会有不同。
</footnote>
<example>
<var>foo</var> login: root
Password:
Last login: Sun Oct 26 19:04:09 2003 on tty3
Linux <var>foo</var> 2.4.22-1-686 #6 Sat Oct 4 14:09:08 EST 2003 i686 GNU/Linux

Most of the programs included with the Debian GNU/Linux system are
freely redistributable; the exact distribution terms for each program
are described in the individual files in /usr/share/doc/*/copyright

an GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

root@<var>foo</var>:root#
</example>
<p>
您现在已经准备好通过 root 的命令提示符进行系统的管理。这个 root 帐户也被称为超级
用户或者特权用户。拥有这个帐户，您将可以做任何事情：
<list compact>
<item>读，写和删除任何文件而不用去理会它们所要求的权限
<item>设置文件的归属，以及系统里面任何文件的访问权限
<item>登录到任何帐户而不需要他们的密码
</list>
<p>
通过和别人共享 root 用户的密码来共享 root 帐户是一个非常糟糕的想法。而使用程序比如
<manref name="sudo"section="8">是共享管理权限的好方法。
<p>
请注意，优先使用非特权用户登录被认为是一个好的 Unix 习惯，哪怕是您要进行管理活动，
在必要的时候您也可以使用 <tt>sudo</tt>，<tt>super</tt> 或者 <tt>su -c</tt> 来
获得有限的 root 权限。
参阅 <ref id="sudo">.
<footnote>
我自己也承认自己以前过多的使用了超级用户，因为那样很方便而且我当时很粗心。
</footnote>

<sect1 id="newbiefix">设置最小的新手环境
<p>
<!-- new content -->
我认为学习一个电脑系统就像学习一门新的外语。尽管书本指南是有帮助的，但是您需要
练习使用帮助工具。在这个情况下，我认为安装一些额外的软件包是一个好主意，比如
<package>mc</package>，
<package>vim</package>，<package>lynx</package>，
<package>doc-linux-text</package> 和
<package>debian-policy</package>。
<footnote>
安装 <package>gpm</package>、
<package>emacs21</package> 和 <package>doc-linux-html</package> 也是一个好注意。参阅
<ref id="gpm"> 和 <ref id="edit">。
</footnote>
<example>
# apt-get update
 ...
# apt-get install mc vim lynx doc-linux-text debian-policy
 ...
</example>
如果您已经安装了这些软件包，那么什么都不需要安装了。

<sect1 id="newuser">添加一个用户
<p>
<!-- new content -->
在安装过程中，您通常已经创建了一个非特权用户来接收发送给 root 帐户的 e-mail。
<footnote>
我倾向于把在安装过程中添加的那个用户命名为 <tt>admin</tt> 但是这个是一个很霸道的
名字。
</footnote>
因此您也不希望用这个特殊的帐户来进行下面的训练，那么您需要创建另外一个帐户。
<p>
假设您希望新帐户的名字叫 <tt><var>penguin</var></tt>,
输入:
<example>
root@<var>foo</var>:root# adduser <var>penguin</var>
... 回答所有的问题
</example>
这样就可以了。
<footnote>
您可能想把这个用户 <tt><var>penguin</var></tt> 加入到 <tt>adm</tt> 组里面去，以此来
获得很多在 <file>/var/log/</file> 目录下日志文件的读取权限。查看 <manref name="passwd" section="5">、<manref name="group" section="5">、<manref name="shadow" section="5">、<manref name="group" section="5">、<manref name="vipw" section="8">和 
<manref name="vigr" section="8">。为了得到官方的关于用户和群组的意思，可以查看
最近版本的 <url id="&f-users-and-groups;" name="Users and Groups"> 文档。
</footnote>
在更进一步之前，我们先来学习一点东西

<sect1 id="sw-console">在不同的控制台之间切换
<p>
<!-- modified old content -->
在默认的 &debian; 系统中，有 6 个独立的伪终端，比如，您可以把 PC 的 VGA 字符终端当作
 6 个可以选择的 VT-100 终端来使用。从一个切换终端到另外一个，你只需要同时按下左 Alt 键
和 F1&ndash;F6 键。任何一个伪终端都可以让不同的用户独立登录。多用户环境是 Unix 的
一个很优秀的、使人迷恋的特性。
<p>
<!-- new content -->
如果你偶然的在装有 X 装口系统的系统上按下了 Alt-F7，控制台就会切换到图形界面，然后
再按下 Ctrl-Alt-F1 可以重新回到字符界面。您可以尝试在在不同的控制台之间切换，然后
再换回到原来的那个，您慢慢就会习惯于这样做。
<sect1 id="shutdown">怎样关闭机器
<p>
<!-- heavily modified content -->
就像任何其它现代的操作系统一样，任何文件操作都会在内存当中缓存数据，&debian;
操作系统也需要一个适当的过程，让电脑电源关闭之前保证这些文件的一致性，您可以在
 root 命令提示符下使用下面的命令来关闭系统。
<example>
# shutdown -h now
</example>
上面是在正常的多用户模式下面的方法。如果您是处在单用户模式，您可以在 root 用户的
命令提示符下使用下面的命令：
<example>
# poweroff -i -f
</example>
可选择的其它方式，比如您可以用 Ctrl-Alt-Delete 来关闭系统
<footnote>
在控制台将左边的 Ctrl 键，左边的 Alt 键和 Delete 键同时按下。在系统默认的情况下，这样
会导致系统重新启动。您需要修改文件 <file>/etc/inittab</file> 系统。让命令 <prgn>shutdown</prgn> 加上 <tt>-h</tt> 选项，就像 <ref id="post-inst"> 描述的一样。
</footnote>
<p>
等待系统在屏幕上输出"System halted"之后您就可以关闭电源了。如果 APM 和 ACPI 选项在 
BIOS 和 Linux 内核里面都配置好了的话，系统会自动关闭电源。可以看 <ref id="apm"> 获
得详细信息。
<sect1 id="playtime">玩的时间
<p>
<!-- new content -->
现在您已经准备好使用 &debian; 系统了，而不用担心有任何冒险，因为您使用的非特权用
户<tt><var>penguin</var></tt>。
<footnote>
这是因为 &debian; 系统，就算刚刚完成默认的安装，就已经被设置好了文件权限，防止非
特权用户损坏系统。当然，可能仍然有一些系统漏洞可以利用，不过那些关心这些事情的
人不应该阅读这一节，而是应该去阅读
<url id="&securing-debian-howto;" name="Securing Debian Manual">.
</footnote>
<p>
让我们先登录到 <tt><var>penguin</var></tt> 用户。
如果您现在正在 root 用户的命令提示符下面，输入 Crtl-D
<footnote>
左边的 Ctrl 键和 d 件同时按下。我们不需要按下 shift 键，虽然它才真正表示"control D"。
</footnote>
在 root 用户提示符下面关闭 root 的 shell 以后我们就返回了登录提示符。输入您刚创建的新
用户名 <tt><var>penguin</var></tt> 和对应的密码。
<footnote>
如果您输入的是 <tt>root</tt> 和对应的密码，而不是 <tt><var>penguin</var></tt>，
那么您将登录到 <tt>root</tt> 用户下面。这个过程只有当您需要 <tt>root</tt> 用户的时
候才会发生。
</footnote>
您将会获得如下的命令提示符
<example>
<var>penguin</var>@<var>foo</var>:<var>penguin</var>$
</example>
<p>
从现在开始，为了简单起见我们将使用简化的命令提示符，我们将使用：
<list compact>
<item><tt>#</tt> : root 的命令提示符
<item><tt>$</tt> : 非特权用户的命令提示符
</list>
<p>
我们将先用简单的方法 <ref id="mc"> 来学习 &debian;，稍后使用较好的方法 <ref id="unixlike">。

<sect id="mc">Midnight Commander (MC)
<p>
<!-- old content -->
Midnight Commander (MC)是 Linux 控制台和其它终端环境中的 GNU“瑞士军刀”。这给予了新
受一个菜单驱动控制台的体验，它比 Unix 标准命令容易学的多。
<!-- New content -->
<p>
用命令来研究 &debian; 系统。这个是最好的学习方法。请只用方向键和回车键来访问下
面的地址：
<list compact>
<item><file>/etc</file> 和它的子目录。
<item><file>/var/log</file> 和它的子目录。
<item><file>/usr/share/doc</file> 和它的子目录。
<item><file>/sbin</file> and <file>/bin</file>
</list>
<sect1 id="mc-enhance">提高 MC
<p>
<!-- modified old content -->
为了让 MC 在退出的时候改变工作目录，您需要修改 <file>~/.bashrc</file>(或者
<file>/etc/bash.bashrc</file>，它被 <file>.bashrc</file> 调用)，在它的手册页
<manref name="mc" section="1"> 里面的
<tt>-P</tt> 选项下，可以获取更详细的信息。
<footnote>
如果您对我在这里所说的不是很清楚，您可以稍后测试。
</footnote>
<sect1 id="mc-start">启动 MC
<p>
<!-- modified old content -->
<example>
$ mc
</example>
在 MC 中用户可轻而易举使用菜单完成所有的文件操作。可以按 F1 获得帮助，您可以只用方向键和功能键来操作 MC。
<footnote>
如果在一个终端内，象用于日文的 <prgn>kon</prgn> 和 <prgn>kterm</prgn>，
某些图形字符有问题，
给 MC 命令行增加一个 <tt>-a</tt> 选项，有助于阻止这个问题发生。
</footnote>

<sect1 id="mc-fm">MC 里的文件管理器
<p>
<!-- old content -->
默认状态下，所有文件列于两个目录面板。一种实用的方式是将右边窗口设定为“information”，用来查看文件访问权限等信息。下面是一些基本的击键。如果<prgn>gpm</prgn> daemon在运行，你还可以使用鼠标。(在MC中进行剪切和粘贴操作时别忘了按下shift键。)
<list compact>
<item>F1: 帮助菜单
<item>F3: 内置文件阅读器
<item>F4: 内置编辑器
<item>F9:  激活折叠菜单
<item>F10: 退出 Midnight Commander
<item>Tab: 在两个窗口间移动
<item>Insert: 为多文件操作生成文件如拷贝
<item>Del: 删除文件(小心&mdash;请设置 MC 为安装删除模式)
<item>方向键: 与各自的名字一致
</list>

<sect1>MC 里的命令行技巧
<p>
<!-- old content -->
<list compact>
<item><prgn>cd</prgn>命令可改变焦点屏幕中的目录位置。
<item>Control-Enter 或 Alt-Enter 可以将文件名拷贝到命令行。在编辑命令行时可与 <prgn>cp</prgn> 或 <prgn>mv</prgn>命令结合使用。
<item>Alt-Tab 显示焦点文件所属文件或目录的文件名
<item>可指定 MC 两个目录窗口的起始目录；例如 <tt>mc /etc /root</tt>。
<item>Esc + <var>numberkey</var> == F<var>n</var>(例如
      Esc + '1' = F1, etc.;
      Esc + '0' = F10)
<item>Esc- key == Alt-key (= Meta,
      M-); 例如Esc + 'c'等价于 Alt-c
<!-- control characters are referred with the upper case. -->
</list>

<sect1 id="mcedit">MC 里面的编辑器
<p>
<!-- almost old content check &rarr; and last few lines in this sect1 -->
内置编辑器的剪切-粘贴方式很有意思。按 F3 在起始处做标记，再次按 F3 在终止处做标记，这时中间的选中部分会高亮显示。然后你可以移动光标到某处按下 F6，被选中部分就会移到该处。如果你按下的是 F5，选中部分就会拷贝到该处。F2 用来存盘，F10 退出，所有方向键的作为和它们的名字一样直观。
<p>
该编辑器可直接打开某个文件：
<example>
$ mc -e filename_to_edit
$ mcedit filename_to_edit
</example>
<p>
虽然它不是多窗口编辑器，但你可利用 Linux 多控制台的特性达到相同的效果。要在窗口间进行拷贝操作，可使用 Alt-F<var>n</var> 切换虚拟控制台，然后使用“File-&gt;Insert file”或“File-&gt;Copy to file”将一个文件中的内容拷贝到另一个文件。
<!-- Osamu: you could try "&rarr;" instead of "-&gt;" to get a right arrow
above. It's valid SGML, but I don't know if all browsers support it. 
Jens: "&rarr;" doesn't split a line in "->" (after "-")

For this version 1, let us keep it as is for consistency.  
I will think about it for version 2,  Thanks. 

Anyway, PS/PDF compile is real problem (Jens: LaTeX supports \rightarrow!)
I see .. but for now I do this not to hack LaTeX
-->
<p>
可指定任何外部编辑器作为内置编辑器。
<p>
许多程序使用环境变量 <tt>EDITOR</tt> 或 <tt>VISUAL</tt> 来决定使用哪个编辑器。如果你用不惯 <prgn>vim</prgn>，可在 <file>~/.bashrc</file> 中加上几行来指定新的 <tt>mcedit</tt>：
<example>
...
export EDITOR=mcedit
export VISUAL=mcedit
...
</example>
<p>
我强烈推荐将它们设定为 <tt>vim</tt>。在 Linux/Unix 世界里就该使用 <prgn>vi(m)</prgn> 命令。
<footnote>
坦白的说，<prgn>vi</prgn> 或者 <prgn>nvi</prgn> 是您可以随处找到的程序。我会为新手
选择 <prgn>vim</prgn>，因为我们可以很熟悉的按F1来获得帮助，而且它本身也更强大。
<p>
如果您不适应 <prgn>vim</prgn>，您也可以继续使用 <prgn>mcedit</prgn> 来进行绝大多
数的维护工作。因为 <prgn>mcedit</prgn>  是8-bit***(它不关心文本编码)，这在编辑一
些未知编码文件的时候会有一些优势。<prgn>mcedit</prgn>不能正确显示 UTF-8 文件。
</footnote>
<sect1>MC 里的阅读器
<p>
<!-- almost old content -->
非常精巧的阅读器。它是在文档中搜索单词的利器。在 <file>/usr/share/doc</file> 目录下我总是用它，面对大量的 Linux 资料用它浏览是最快的方法。阅读器可以直接找开文件：
<example>
$ mc -v filename_to_view
</example>

<sect1>MC 的自动启动特性
<p>
<!-- almost old content, tar.gz and deb are new -->
在文件上按 Enter，会激活相关的程序操作该文件。这是 MC 的一个极方便的特点。
<example>
executable file:        执行命令
man, html file:    将文件内容传入阅读器程序
tar, gz, deb file: 象浏览子目录一样浏览它的内容
</example>
为了使这些阅读器和虚拟文件的属性能够被查看，不要将可阅读文件设成可执行文件。可在 MC 文件菜单中改变文件属性或使用 <prgn>chmod</prgn> 命令。

<sect1>MC 里的 FTP 虚拟文件系统
<p>
<!-- old content -->
MC 可通过 FTP 访问文件。按 F9 转到菜单栏，输入’p’激活 FTP 虚拟文件系统。按 <tt>username:passwd@hostname.domainname</tt> 格式输入 URL，远程文件目录就会以本地目录的方式显示出来。
<p>
<!-- new content -->
在 URL 里试着用 <tt>&ftp-debian;</tt> 来浏览 &debian; 存档文件。看<ref id="ftparchives"> 就知道这些是怎么被识别的了。
<sect id="unixlike">类 Unix 工作环境 
<p>
<!-- new content -->
尽管 MC 让您能够做绝大多数的事情，但是利用 shell 来学习命令行工具，和熟悉类 Unix 系统
的工作环境还是很重要的。
<footnote>
在指南的这一章里，shell 指的是 <prgn>bash</prgn>。要了解更多不同的的 shell，看 <ref id="shell">。
</footnote>
<sect1 id="sp-keys">特殊的按键组合
<p>
<!-- practically new content -->
在类 Unix 环境里，有一些按键有特殊的意思。
<footnote>
在一个普通的 Linux 字符控制台，只有左手边的 Ctrl 和 Alt 的键会按照期望工作。 
</footnote>
<list compact>
<item>Ctrl-U: 擦除一行光标前面的部分。
<item>Ctrl-H: 擦除光标前面的一个字符。
<item>Ctrl-D: 终止输入。(退出 shell，如果您正在使用 shell 的话)。
<item>Ctrl-C: 终止当前正在运行的程序。
<item>Ctrl-Z: 暂停程序。 (把它放到后台运行请看<ref id="cmd-back">)
<item>Ctrl-S: 停止向屏幕输出。
<footnote>
您可以禁止这些终端属性，使用：
<manref name="stty" section="1">.
</footnote>
<item>Ctrl-Q: 重新激活向屏幕输出。
</list>
<p>
默认的 shell，<prgn>bash</prgn>，
有历史编辑和 tab 补齐功能。
<list compact>
<item>up-arrow:  开始历史命令搜索。
<item>Ctrl-R:  开始增量历史命令搜索。
<item>TAB: 完整的把文件名输入到命令行。
<item>Ctrl-V TAB: 输入 TAB 而不是扩展命令行。
</list>
<p>
其他一些需要记住的按键组合。
<list compact>
<item>Ctrl-Alt-Del:挂起或者重新启动系统 <ref id="post-inst">.
<item>Left-click-and-drag mouse: 选择并且拷贝到剪贴板。
<item>Click middle mouse button: 使用剪贴板的内容粘贴。
<item>Meta-key (Emacs terminology) 传统的是使用
Left-Alt-key. 但是有些系统使用 Windows-key 实现
Meta-key.
</list>
这里，为了在 Linux 字符界面下使用鼠标，您需要使用 <prgn>gpm</prgn> 服务。
<footnote>
在 X Window 环境下，鼠标函数是和在 Xterm 程序里一样进行处理的。
</footnote>
查看<ref id="gpm">。
<sect1 id="unixcmds">基本 Unix 命令
<p>
<!-- new content -->
让我们来学习基本的 Unix 命令。
<footnote>
这里我将按照通常的方法来使用”Unix”。所有科隆 unix 的系统都提供等价的命令。&debian; 也不例外。
如果有些命令没有像您想像的那样工作的话，不要着急。这些例子并不表示它们能正常工作。
</footnote>
使用非特权用来执行下面的所有的命令。
<tt><var>penguin</var></tt> :
<list compact>
<item><tt>pwd</tt>
<list compact>
<item>显示当前工作路径。
</list>
<item><tt>whoami</tt>
<list compact>
<item>显示当前用户名。
</list>
<item><tt>file <var>foo</var></tt>
<list compact>
<item>显示 <var>foo</var> 文件的属性。
</list>
<item><tt>type -p <var>commandname</var></tt>
<list compact>
<item>显示命令 <tt><var>commandname</var></tt> 所的的地方。
<item><tt>which <var>commandname</var></tt> 也可以用来做这个 .
<footnote>
如果在 shell 里面使用 <tt>alias</tt>的话，它们的输出就会不同了。
</footnote>
</list>
<item><tt>type <var>commandname</var></tt>
<list compact>
<item>显示命令 <tt><var>commandname</var></tt> 的信息。
</list>
<item><tt>apropos <var>key-word</var></tt>
<list compact>
<item>找到和 <tt><var>key-word</var></tt> 相关的命令。
<item><tt>man -k <var>key-word</var></tt> 也可以做到
</list>
<item><tt>whatis <var>commandname</var></tt>
<list compact>
<item>显示该命令的一句话帮助。
<tt><var>commandname</var></tt>.
</list>
<item><tt>man -a <var>commandname</var></tt>
<list compact>
<item>显示命令的解释信息。
<tt><var>commandname</var></tt>. (Unix style)
</list>
<item><tt>info <var>commandname</var></tt>
<list compact>
<item>显示很长的命令解释
<tt><var>commandname</var></tt>.  (GNU style)
</list>
<tt>ls</tt>
<list compact>
<item>列出目录内容 (非以.开始的文件和目录)
<footnote>
Unix 有一个传统，隐藏文件名用 “<tt>.</tt>” 开头的文件。
它们是包含配置信息和用户参数的传统文件。
</footnote>
</list>
<item><tt>ls -a</tt>
<list compact>
<item>列出目录内容(所有的文件和目录)
</list>
<item><tt>ls -A</tt>
<list compact>
<item>列出目录内容。(几乎所有的文件和目录，略去“<file>..</file>”和“<file>.</file>”)
</list>
<item><tt>ls -la</tt>
<list compact>
<item>列出目录所有文件和目录的详细信息。查看<ref id="file-system">。
</list>
<item><tt>ls -d *</tt>
<list compact>
<item>列出当前目录下的目录名称，而不是目录下的内容。
</list>
<item><tt>lsof <var>foo</var></tt>
<list compact>
<item>显示文件 <tt><var>foo</var></tt> 的打开状态。
</list>
<item><tt>mkdir <var>foo</var></tt>
<list compact>
<item>在当前目录下创建一个新的目录 <tt><var>foo</var></tt>。
</list>
<item><tt>cd <var>foo</var></tt>
<list compact>
<item>切换到当前目录下或者在变量 <tt>CDPATH</tt> 中列出来的目录 <file><var>foo</var></file>。在 <manref name="builtins" section="7"> 查看命令 <prgn>cd</prgn>。
</list>
<item><tt>cd /</tt>
<list compact>
<item>切换到根目录。
</list>
<item><tt>cd</tt>
<list compact>
<item>切换到用户主目录。
</list>
<item><tt>cd /<var>foo</var></tt>
<list compact>
<item>切换到绝对路径 <file>/<var>foo</var></file> 所指定的目录。
</list>
<item><tt>cd ..</tt>
<list compact>
<item>切换到上一级目录。
</list>
<item><tt>cd ~<var>foo</var></tt>
<list compact>
<item>切换到用户主目录下的 <tt><var>foo</var></tt> 目录去。
</list>
<item><tt>cd -</tt>
<list compact>
<item>切换到上一次所去的目录。
</list>
<item><tt>&lt;/etc/motd pager</tt>
<list compact>
<item>使用默认的分页程序查看文件 <file>/etc/motd</file> 的内容，参照<ref id="cmd-stdin">。
<footnote>
&debian;默认的分页查看程序是 <prgn>more</prgn>，它不能回滚。用命令 <tt>apt-get install less</tt> 安装软件包 <package>less</package>，<prgn>less</prgn> 就变成默认的
分页查看程序，您可以用鼠标来控制回滚。
</footnote>
</list>
<item><tt>touch <var>junkfile</var></tt>
<list compact>
<item>创建一个空文件 <file><var>junkfile</var></file>。
</list>
<item><tt>cp <var>foo</var> <var>bar</var></tt>
<list compact>
<item>拷贝一个已有的文件 <file><var>foo</var></file> 到新文件 <file><var>bar</var></file>。
</list>
<item><tt>rm <var>junkfile</var></tt>
<list compact>
<item>删除文件<file><var>junkfile</var></file>
</list>
<item><tt>mv <var>foo</var> <var>bar</var></tt>
<list compact>
<item>把已有的文件 <file><var>foo</var></file> 重命名为 <file><var>bar</var></file>
</list>
<item><tt>mv <var>foo</var> <var>bar/baz</var></tt>
<list compact>
<item>把已有的文件 <file><var>foo</var></file> 移动到新位置并重命名为 <file><var>bar/baz</var></file>。目录 <file><var>bar</var></file> 必须存在。
</list>
<item><tt>chmod 600 <var>foo</var></tt>
<list compact>
<item>让已经存在的文件 <file><var>foo</var></file> 其他人不能读写。(所有人都
不能执行)。
</list>
<item><tt>chmod 644 <var>foo</var></tt>
<list compact>
<item>使文件 <file><var>foo</var></file> 其他的人可以读，但是不能写。(所有人
都不能执行)
</list>
<item><tt>chmod 755 <var>foo</var></tt>
<list compact>
<item>使文件 <file><var>foo</var></file> 其他的人能读不能写。(所有人都可以执行)
</list>
<item><tt>top</tt>
<list compact>
<item>全屏显示进程信息。输入”q”退出。
</list>
<item><tt>ps aux | pager</tt>
<list compact>
<item>用 BSD 风格输出所有正在运行的进程的信息。参照 <ref id="cmd-pipe">。
</list>
<item><tt>ps -ef | pager</tt>
<list compact>
<item>用 system-V 风格来输出所有正在运行的进程的信息。
</list>
<item><tt>ps aux | grep -e "[e]xim4*"</tt>
<list compact>
<item>显示 <prgn>exim4</prgn> 进程，或者运行 <prgn>exim</prgn> 的进程。输入 <tt>man grep</tt> 可以从 <manref name="grep" section="1"> 的手册页学习正则表达式。
<footnote>
<tt>[</tt> 和 <tt>]</tt> 使得 <prgn>grep</prgn> 在正则表达式中不会匹配自己。<tt>4*</tt> 在正则表达式中表示出现 0 或者多次的 4 这样就使得 <prgn>grep</prgn> 能够同时匹配 <prgn>exim</prgn> 和 <prgn>exim4</prgn>。尽管 <tt>*</tt> 在 shell 里和正则表达式里都作为文件名的通配符，但是他们的含义是不一样的。
</footnote>
</list>
<item><tt>ps axf | pager</tt>
<list compact>
<item>用 ASCII 艺术形式来显示运行所有进程信息。
</list>
<item><tt>kill <var>1234</var></tt>
<list compact>
<item>杀死进程号为 <var>1234</var> 的进程。
查看<ref id="kill">。
</list>
<item><tt>grep -e "<var>pattern</var>" *.html</tt>
<list compact>
<item>找到当前目录下面所有以 .html 结尾的文件中含有"<var>pattern</var>"的行，并显示它们。
</list>
<item><tt>gzip <var>foo</var></tt>
<list compact>
<item>用Lempel-Ziv(LZ77)压缩算法压缩<file><var>foo</var></file>，生成<file><var>foo</var>.gz</file>。
</list>
<item><tt>gunzip <var>foo</var>.gz</tt>
<list compact>
<item>将文件 <file><var>foo</var>.gz</file> 解压缩生成 <file><var>foo</var></file>。
</list>
<item><tt>bzip2 <var>foo</var></tt>
<list compact>
<item>将文件 <file><var>foo</var>.bz2</file> 解压缩生成 <file><var>foo</var></file>。
</list>
<item><tt>tar -xvvf <var>foo.tar</var></tt>
<list compact>
<item>从打包文件 <file><var>foo</var>.tar</file> 解出文件来。
</list>
<item><tt>tar -xvvzf <var>foo</var>.tar.gz</tt>
<list compact>
<item>从打包压缩的文件 <file><var>foo</var>.tar.gz</file> 中解开文件。
</list>
<item><tt>tar -xvvf --bzip2 <var>foo.tar.bz2</var></tt>
<list compact>
<item>从文件 <file><var>foo</var>.tar.bz2</file> 解压缩文件。
<footnote>
<tt>--bzip2</tt> 在这里代替了选项 <tt>-j</tt> 以确保在老的 Potato 里面的 tar 也能工作。</footnote>
</list>
<item><tt>tar -cvvf <var>foo</var>.tar <var>bar</var>/</tt>
<list compact>
<item>把目录 <file><var>bar</var>/</file> 的内容打包存放到 <file><var>foo</var>.tar</file> 存档中。
</list>
<item><tt>tar -cvvzf <var>foo</var>.tar.gz <var>bar</var>/</tt>
<list compact>
<item>把目录 <file><var>bar</var>/</file> 的内容打包并且压缩存放到 <file><var>foo</var>.tar.gz</file> 存档中。
</list>
<item><tt>tar -cvvf --bzip2 <var>foo</var>.tar.bz2 <var>bar</var>/</tt>
<list compact>
<item>把目录 <file><var>bar</var>/</file> 中的内容打包存放到 <file><var>foo</var>.tar.bz2</file> 存档里面。
<footnote>
<tt>--bzip2</tt>用在这里也是为了保证兼容性。
</footnote>
</list>
<item><tt>zcat README.gz | pager</tt>
<list compact>
<item>实用默认的分页显示程序 pager 来显示压缩文件 <file>README.gz</file> 中的内容。
</list>
<item><tt>zcat README.gz &gt; foo</tt>
<list compact>
<item>使用文件 <file>README.gz</file> 解开后的内容创建一个文件 <file>foo</file>。
</list>
<item><tt>zcat README.gz &gt;&gt; foo</tt>
<list compact>
<item>把文件 <file>README.gz</file> 解开后的内容追加到文件 <file>foo</file> 的后面(如果文件不存在的话，就会创建一个)。
</list>
<item><tt>find . -name <var>pattern</var></tt>
<list compact>
<item>用 shell 找到匹配 <tt><var>pattern</var></tt> 的文件名(慢一些)。
</list><item><tt>locate -d . <var>pattern</var></tt>
<list compact>
<item>用 shell 找到匹配 <tt><var>pattern</var></tt> 的文件名(使用已有的规则的数据库，快一些)。
</list>
<!--
<item>
<list compact>
<item><tt></tt>
</list>
-->
</list>
<p>
请用上面的这些命令来查看您的系统的目录和其他的信息，以此来熟练一些操作。如果您
对上面的这些控制台命令有任何不明白的地方，请首先阅读帮助手册，比如下面的命令就是
好的开始：
<example>
$ man man
$ man bash
$ man ls
</example>
<p>
现在也是时候启动 <prgn>vim</prgn> 然后按下 F1 键了。您最少也应该阅读开始的 35 行。然后把光标移动到 <tt>|tutor|</tt>，再按下 Ctrl-]就可以做在线测试了。查看<ref id="edit">可以学到更多关于编辑器的知识。
<p>
<!-- slightly changed to make it looks OK for PDF and PS -->
请注意许多来自于 GNU 和 BSD 的类 Unix 命令都会在您进行如下操作的时候(或者您没有给出任何参数)给出简单的帮助：
<example>
$ <var>commandname</var> --help
$ <var>commandname</var> -h
</example>
<p>
您也可以参照<ref id="tips">里的例子来进行自我测试。
<sect1 id="cmd-exec">命令执行
<p>
<!-- new content -->
现在您已经比较了解应该如何使用 &debian; 系统了。让我们来更深入的了解 &debian; 系统
的命令执行结构。
<footnote>
在这里我简单的为新手讲讲。查看 <manref name="bash" section="1"> 来获得详细解释。
</footnote>

<sect1 id="cmd-simple">简单的命令
<p>
<!-- new content -->
一个简单的命令是如下面的序列
<enumlist compact>
<item>可变的声明 (可选)
<item>命令的名字
<item>参数 (可选)
<item>重定向 (可选：<tt>&gt;</tt> , <tt>&gt;&gt;</tt> ,
<tt>&lt;</tt> , <tt>&lt;&lt;</tt>, 等等)
<item>控制操作 (可选：<tt>&amp;&amp;</tt> , <tt>||</tt> ;
&lt;换新行&gt; , <tt> ; </tt> , <tt>&amp;</tt> , <tt>(</tt> , <tt>)</tt>
)
</enumlist>
<p>
想了解更多复杂命令的解释和应用请查看<ref id="clprocess">。
<sect1 id="cmd-env">命令执行和环境变量
<p>
<!-- new content -->
典型的使用 shell 来执行命令情况如下：
<footnote>
为了得到和下面一样的输出，您需要安装法语 locale，查看<ref id="locales">。这个对于这个指南来说不是必须的，只是为了指出可能会出现的影响。
</footnote>
<example>
$ date
Sun Oct 26 08:17:20 CET 2003
$ LC_ALL=fr_FR date
dim oct 26 08:17:39 CET 2003
</example>
这里 <prgn>date</prgn> 程序是在前台执行的。环境变量 <tt>LC_ALL</tt> 是：
<list compact>
<item>取消设置 (系统默认的和 <tt>C</tt>)作为第一个命令 
<item>设置为 <tt>fr_FR</tt> (French locale) 作为第二个命令。
</list>
绝大多数的命令并没有预先定义各种环境变量。像上面的例子选择如下方式：
<example>
$ LC_ALL=fr_FR
$ date
dim oct 26 08:17:39 CET 2003
</example>
正如您所看到的，命令的输出和环境变量设置有关，上面产生的是法语输出。如果您
想这个环境变量在子进程中也能够得到继承的话(e.g.,执行 shell 脚本的时候)，您需要
使用下面的方式。
<example>
$ export LC_ALL
</example>


<sect1 id="cmd-path">命令搜索路径
<p>
<!-- new content -->
当您在 shell 提示符里面输入一个命令的时候，shell 就会在 <tt>PATH</tt> 环境变量所列出的目录里面去查找。<tt>PATH</tt> 环境变量的值也被叫做 shell 的查找目录。
<p>
在默认安装的 &debian; 中，用户的 <tt>PATH</tt> 环境变量里面也许没有包含 <file>/sbin/</file>。因此如果您想运行一些命令比如 <file>/sbin/</file> 目录下的 <prgn>ifconfig</prgn>，您就必须在 <tt>PATH</tt> 环境变量里面包含它。<tt>PATH</tt> 环境变量一般是在初始化文件 <file>~/.bash_profile</file> 里面设置的，参看<ref id="bashconf">。

<sect1 id="cmd-opt">命令行选项
<p>
<!-- new content -->
一些命令带有参数，参数部分以<tt>-</tt>或者<tt>--</tt>开始的被称做选项。可以用来控制命令的行为。
<example>
$ date
Mon Oct 27 23:02:09 CET 2003
$ date -R
Mon, 27 Oct 2003 23:02:40 +0100
</example>
这里命令行参数 <tt>-R</tt> 改变了命令 <prgn>date</prgn> 的表现以让它输出符合 RFC-2822 的日期字符串。

<sect1 id="cmd-wild">Shell 通配符
<p>
<!-- new content -->
通常您需要用命令来处理一组文件，但是您又不想输出所有的文件名。shell <strong>通配符</strong>使得这个成为可能。
<list compact>
<item><tt>*</tt>
<list compact>
<item>这个匹配 0 个或者多个字符。
<item>它不会匹配以"<tt>.</tt>"开始的文件名.
</list>
<item><tt>?</tt>
<list compact>
<item>这个仅匹配一个字符。
</list>
<item><tt>[...]</tt>
<list compact>
<item>这个匹配[]里面的某个字符。
</list>
<item><tt>[a-z]</tt>
<list compact>
<item>这个匹配字符 <tt>a</tt> 到 <tt>z</tt> 之间的某个字符。
</list>
<item><tt>[^...]</tt>
<list compact>
<item>这个匹配任意不包含在 [] 里面的字符(不包含字符"^").
</list>
</list>
<p>
作为练习。请尝试着运行下面的命令并思考一下：
<example>
$ mkdir junk; cd junk; touch 1.txt 2.txt 3.c 4.h .5.txt
$ echo *.txt
1.txt 2.txt
$ echo *
1.txt 2.txt 3.c 4.h
$ echo *.[hc]
3.c 4.h
$ echo .*
. .. .5.txt
$ echo .[^.]*
.5.txt
$ echo [^1-3]*
4.h
$ cd ..; rm -rf junk
</example>

<sect1 id="cmd-return">命令返回值
<p>
每个命令都返回一个值和它返回的状态。
<list compact>
<item>返回 0 表示命令被正确执行
<item>返回非 0 的值表示命令没有正确执行。
</list>
返回值可以在命令执行后马上用 shell 用变量 <tt>$?</tt> 来访问。
<example>
$ [ 1 = 1 ] ; echo $?
0
$ [ 1 = 2 ] ; echo $?
1
</example>
请注意，在 shell 中的逻辑上下文中使用这些返回值的时候 <strong>success</strong> 被看做逻辑值 <strong>TRUE</strong>。这个多少有一点不直观，因为 <strong>success</strong> 等价于值 <strong>zero</strong>。
<p>
参看<ref id="shell-cond">。

<sect1 id="cmd-typical">典型的命令序列
<p>
<!-- new content in this whole sect1 and sect2s -->
在我们阅读了这些惯用的 shell 命令以后，让我们试者记住它们。参看<ref id="shell-param">，<ref id="shell-redirect">，<ref id="shell-cond">，和<ref id="clprocess">。

<sect2 id="cmd-back"><tt>command &amp;</tt>
<p>
<prgn>command</prgn> 在子 shell 的 <strong>background</strong> 运行。后台任务让多成程序能够运行在一个 shell 里面。
<p>
管理这些后台任务的请求需要 shell 内建的：
<prgn>jobs</prgn>，<prgn>fg</prgn>，<prgn>bg</prgn> 和 <prgn>kill</prgn>。请查看
<manref name="bash" section="1"> 这一小节中的“SIGNALS”，“JOB CONTROL”，“SHELL
BUILTIN COMMANDS”。的相关内容。
<footnote>
&debian; 是一个多任务的操作系统。
</footnote>
<sect2 id="cmd-pipe"><tt>command1 | command2</tt>
<p>
<prgn>command1</prgn> 的标准输出被直接输入到 <prgn>command2</prgn> 的标准输入。
两个命令都可能<strong>并行</strong>地运行。这个被称作<strong>pipeline</strong>。

<sect2 id="cmd-list"><tt>command1 ; command2</tt>
<p>
<prgn>command1</prgn><prgn>command2</prgn> 被有序的执行。

<sect2 id="cmd-and"><tt>command1 &amp;&amp; command2</tt>
<p>
<prgn>command1</prgn> 如果执行成功的话那么再执行 <prgn>command2</prgn>。只有当 <prgn>command1</prgn><strong> 并且 </strong><prgn>command2</prgn> 都运行成功的话上面的命令序列才会成功返回。

<sect2 id="cmd-or"><tt>command1 || command2</tt>
<p>
<prgn>command1</prgn> 被执行以后，如果不成功的话，<prgn>command2</prgn> 也会被执行。当 <prgn>command1</prgn> <strong> 或者 </strong><prgn>command2</prgn> 有一个执行成功的话，上面的序列就会返回真值。
<sect2 id="cmd-stdout"><tt>command &gt; <var>foo</var></tt>
<p>
把 <prgn>command</prgn> 的标准输出重定向到文件 <tt><var>foo</var></tt>。(覆盖内容)

<sect2 id="cmd-stdout2"><tt>command &gt;&gt; <var>foo</var></tt>
<p>
把 <prgn>command</prgn> 的标准输出重定向到文件 <tt><var>foo</var></tt>。(追加)

<sect2 id="cmd-stderr"><tt>command &gt; <var>foo</var> 2&gt;&amp;1</tt>
<p>
同时把 <prgn>command</prgn> 的标准输出和标准出错信息重定向到文件 <tt><var>foo</var></tt>。

<sect2 id="cmd-stdin"><tt>command &lt; <var>foo</var></tt>
<p>
把 <prgn>command</prgn> 的标准输入重定向到一个文件 <tt><var>foo</var></tt>。
<example>
$ &lt;/etc/motd pager
... (the greetings)
$ pager &lt;/etc/motd
... (the greetings)
$ pager /etc/motd
... (the greetings)
$ cat /etc/motd | pager
... (the greetings)
</example>
尽管上面 4 个方法都显示同样的内容，但是最后一个多运行了 <prgn>cat</prgn> 命令。而且不必要的浪费了资源。
<sect1 id="cmd-alias">命令别名
<p>
<!-- new content -->
您可以给一个命令序列起一个别名。比如：
<example>
$ alias la='ls -la'
</example>
现在， <prgn>la</prgn> 就成了 <tt>ls -la</tt> 命令的简写用来列出所有文件的详细信息。
<p>
您可以用 <prgn>type</prgn> 来显示命令的详细路径或者其他身份。比如：
<example>
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to `ls -la'
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
</example>
这里 <prgn>ls</prgn> 在最近被查找过了，而 file 没有，因此 <prgn>ls</prgn> 被"hashed"，i.e.，shell 有一个内部的记录可以用来快速的找到 <prgn>ls</prgn> 的地址。

<sect id="text-process">类 Unix 文本处理
<p>
在类 Unix 的系统中,有几个文本处理工具经常用到。
<list compact>
<item>非正则表达式的方法有：
<list compact>
<item><prgn>head</prgn> 显示文件的开始部分。
<item><prgn>tail</prgn> 显示文件的结尾部分。
<item><prgn>sort</prgn> 给文件中的每一行排序。
<item><prgn>uniq</prgn> 删除文件中重复的行。
<item><prgn>tr</prgn> 转换或者删除字符。
<item><prgn>diff</prgn> 把文件中的内容一行一行的比较。
</list>
<item>基本的正则表达式 Basic regular expression (BRE) :
<list compact>
<item><prgn>grep</prgn> 按模式匹配文本。
<item><prgn>ed</prgn> 一个原始的行编辑器。
<item><prgn>sed</prgn> 一个流编辑器。
<item><prgn>vi</prgn> 一个屏幕编辑器。
<item><prgn>emacs</prgn> 一个屏幕编辑器。
</list>
<item>扩展的正则表达式 Extended regular expression (ERE) is used:
<list compact>
<item><prgn>egrep</prgn> 按模式匹配文本。
<item><prgn>awk</prgn> 进行简单的文本处理。
查看<ref id="awk">.
<item><prgn>perl</prgn>做非常难以想像的文本处理。
查看<ref id="perl">.
</list>
</list>
查看<ref id="perl-i">，<ref id="scrp-snip"> 和 <ref id="perl-mad">
可以找到一些脚本的例子。


<sect1 id="regex">正则表达式
<p>
正则表达式用在很多文本处理工具里面。它们和 shell 的通配符比较相似(查看<ref id="cmd-wild">)，但是它们更复杂也更强大。
<p>
正则表达式是由文本字符和<strong>元字符</strong>组成的，用来描述匹配模式。元字符是有特殊意义的字符。它们有两种主要的形式 BRE 和 ERE，主要取决于<ref id="text-process">里面是如何描述的。
<p>
在扩展的正则表达式(EREs)里面<strong>元字符</strong>包括"<tt> \ . [ ] ^ &dollar; * + ? ( ) { } | </tt>"。正则表达式表示：
<list compact>
<item><tt>c</tt>
<list compact>
<item>这个用来匹配非元字符 "<tt>c</tt>".
</list>
<item><tt>\c</tt>
<list compact>
<item>这个用来匹配原本的字符"<tt>c</tt>".
</list>
<item><tt>.</tt>
<list compact>
<item>这个用来匹配任意字符包括换行符。
</list>
<item><tt>^</tt>
<list compact>
<item>这个用来匹配字符串的开始。
</list>
<item><tt>&dollar;</tt>
<list compact>
<item>这个用来匹配字符串的结尾。
</list>
<item><tt>\&lt;</tt>
<list compact>
<item>这个用来匹配一个单词的开始。
</list>
<item><tt>\&gt;</tt>
<list compact>
<item>这个用来匹配一个单词的结尾。
</list>
<item><tt>[abc...]</tt>
<list compact>
<item>这个字符序列用来匹配 "<tt>abc...</tt>"中的任意字符。
</list>
<item><tt>[^abc...]</tt>
<list compact>
<item>这个否定的字符序列匹配所有的字符除了
"<tt>abc...</tt>".
</list>
<item><tt>r*</tt>
<list compact>
<item>这个匹配以"<tt>r</tt>"
开始的后面有 0 个或者多个字符的字符串。
</list>
<item><tt>r+</tt>
<list compact>
<item>这个匹配以"<tt>r</tt>"
开始的后面有一个或者多个字符的表达式。
</list>
<item><tt>r?</tt>
<list compact>
<item>以"<tt>r</tt>"
开始后面有 0 个或者 1 个其他的字符。
</list>
<item><tt>r1|r2</tt>
<list compact>
<item>匹配"<tt>r1</tt>"或者"<tt>r2</tt>"。
</list>
<item><tt>(r1|r2)</tt>
<list compact>
<item>匹配"<tt>r1</tt>"或者 "<tt>r2</tt>"并且把它当作一个<strong>分类</strong>
正则表达式。
</list>
</list>
<p>
在BREs里面<strong>元字符</strong>"<tt> + ? ( ) { } | </tt>"不再具有它们特殊的含义，而是使用的有反斜杠的版本"<tt>\+ \? \( \) \{ \} \| </tt>"。因此分组<tt>(r1|r2)</tt>需要被表示成<tt>\(r1|r2\)</tt>。
因为 <prgn>emacs</prgn>，虽然基本上是 BRE，但是它把"<tt> + ? </tt>"当作元字符。因此不需要特别表示它们。查看<ref id="replaceex">来了解构造分组是如何使用的。
<p>
举个例子，<prgn>grep</prgn> 可以用正则表达式来搜索文本：
<example>
$ egrep 'GNU.*LICENSE|Yoyodyne' /usr/share/common-licenses/GPL
                    GNU GENERAL PUBLIC LICENSE
		    GNU GENERAL PUBLIC LICENSE
	Yoyodyne, Inc., hereby disclaims all copyright interest in the program
</example>
<sect1 id="replaceex">替换表达式
<p>
在替换表达式里面，下面的字符有特殊的含义：
<list>
<item><tt>&amp;</tt>
<list compact>
<item>这个会替换正则表达式所匹配的部分。(在 <prgn>emacs</prgn> 里面用 <tt>\&amp;</tt>)
</list>
<item><tt>\<var>n</var></tt>
<list compact>
<item>这个会替换 <var>n</var>-th<strong> 括号</strong>正则表达式所匹配的内容。
</list>
</list>
在 Perl 里面，<tt>&dollar;<var>n</var></tt> 替换了 <tt>\<var>n</var></tt>，<tt>&amp;</tt> 也没有特殊的含义。
<p>
举个例子：
<example>
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/'
zzz=1abc2efg3hij4=
$ echo zzz1abc2efg3hij4 | \
  sed -e 's/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/$2===$1/'
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
  perl -pe 's/(1[a-z]*)[0-9]*(.*)$/=&=/'
zzz=&=
</example>
请特别注意这些<strong>括号</strong>正则表达式的格式，以及这些被匹配的文本在文本处理工具里面是如何使用的。
<p>
这些正则表达式可以用来控制光标的运动和编辑器里面的文本替换。
<p>
请阅读所有相关手册来学习这些命令。

<sect id="unixfile">类 Unix 文件系统
<p>
<!-- 
This part is inspired by GPLed Debian Tutorial by Havoc Pennington, and
mount manual pages.  Organized by Osamu Aoki for Debian Reference
-->
在 GNU/Linux 和其他的类 Unix 操作系统里面<strong>文件</strong>都被放在<strong>目录</strong>。
<footnote>
在其它一些系统中，<strong>目录</strong> 被称为 <strong>文件夹</strong>。
</footnote>
所有的<strong>文件</strong>和<strong>目录</strong>都被排列在一棵很大的树里面，
即文件层次树，他的根是<file>/</file>。
<p>
这些文件和目录可以跨多个设备。<manref name="mount" section="8">命令可以把一些设备挂载到文件系统树里面来。反之<manref name="umount" section="8">可以把设备卸载。

<sect1 id="file-basics">Unix 文件基础
<p>
<!-- new content -->
这里是一些最基础的：
<list compact>
<item>文件名是区分大小写的，<file>MYFILE</file> 和文件 <file>MyFile</file> 是<strong>不同</strong>的文件。

<item>跟目录指的是<file>/</file>不要把这个”root”和root用户相混淆了。参看<ref id="login-root">。

<item>任何目录都有一个可以由任意字母或者符号组成的名字，但是<file>/</file>是<strong>例外</strong>。
<footnote>
尽管您<strong>可以使用</strong>任意的字母或者符号来作为文件名，但是实际中这是一
个很糟糕的想法。最好避开那些在命令行有特殊意义的字符比如，空格、制表符、换行符和其它一些特殊字符：
<tt>{ } ( ) [ ] ' ` &quot; \ / &gt &lt | ; ! # &amp; ^ * % @ $</tt> 。
<p>
如果您想在文件名里面把单词分开，比较好的选择是使用点号、连接符(短横线)、和下划线。您也可以将每个单词的首字母大写，<tt>LikeThis</tt>。
</footnote>
根目录是一个例外：它的名字是 <file>/</file> (读做”slash"或者根目录)它不能被重命名。

<item>任何一个目录都是有下面几种形式给出的，<strong>完全限制的文件名</strong>，<strong>绝对文件名</strong>，或者<strong>路径</strong>，给出所有需要经过的目录序列。这三种形式是等价的。所有的绝对文件名都以<file>/</file>目录开始，在目录和目录或者目录和文件之间用<file>/</file>隔开。最开始的<file>/</file>是一个目录的名字，但是后面的仅仅是文件名的分隔符。
<p>
上面的这些话看起来让人很费解。那么看看下面的例子吧：
<example>
/usr/share/keytables/us.map.gz
</example>
这就是一个完整限制的文件名；有些人把它叫做<strong>路径</strong>。然而人们经常
单独把 <file>us.map.gz</file> 作为文件名。
<footnote>
这也是单词 <strong>path</strong> 的另外一种用法。参看<ref id="cmd-path">。真正的意思可以从上下文中很容易的理解。
</footnote>

<item>根目录有很多分支，比如 <file>/etc/</file>和<file>/usr/</file>。这些子目录
又分出很多子目录来，比如 <file>/etc/init.d/</file> 和 <file>/usr/local/</file>。
所有的加起来被称作<strong>目录树</strong>。
<p>
您可以想像，一个绝对文件名就是从树的根基(<file>/</file>)到一个分支的末端(文件)的路由。您也会听到别人把目录树叫做<strong>家庭</strong>树：这样子目录就有
<strong>双亲</strong>，路径就显示了所有文件完整的血缘关系。
<p>
除此之外，还有相对路径，它从其它的地方开始而不是根目录。您可能还记得 <file>../</file>指的是上一级目录。

<item>没有哪一个目录是和物理设备紧密关联的，比如您的磁盘。这个和 DOS,CP/M,Windows 系统不一样的，它们所有的路径都是以一个设备名开始的，比如 <tt>C:\</tt>，参看<ref
id="file-system">。
</list>

<p>
关于文件层次的详细信息以及最好的操作练习可以在这里找到 <url id="&f-fhs;" name="Filesystem Hierarchy Standard">。作为一个初学者，您需要记住下面的事实：
<list compact>
<item><file>/</file>
<list compact>
<item>简单的一个<file>/</file>表示根目录。
<p>
</list>
<item><file>/etc/</file>
<list compact>
<item>这个是大多数系统配置文件存放的地方。
</list>
<item><file>/var/log/</file>
<list compact>
<item>这个是系统日志存放的地方。
</list>
<item><file>/home/</file>
<list compact>
<item>这个目录是存放所有非特权用户的主目录的。
</list>
</list>

<sect1 id="file-system">&debian; 中的文件系统概念
<p>
<!-- old content modified with fs.h reference -->
按照 Unix 的传统， &debian; 为存放物理数据的磁盘或者其它存储设备，还有这些硬件设
备之间的交互提供文件系统，比如控制台屏幕和远程串行终端就用联合的方式表示。
<p>
每个在 &debian; 系统上的文件，目录，命名管道，或者物理设备都有一个数据结构被称作
<strong>inode</strong>，它被用来描述设备用用的属性，比如设备所有者，所属于的组，
上次访问时间等等。参看 <url id="&f-inode-def;"> 来获得 <tt>struct inode</tt> 在 &debian; GNU/Linux系统中的详细信息。
<p>
这些表现出来的统一的物理入口是非常强大的，因为它们使得可以使用同样的命令和同样
的操作来访问完全不同的设备。
<p>
您所有的文件都可以在一个次方上面，----或者您有 20 个磁盘，有些是在网络上其它的计算机上面，
在 GNU/Linux 系统中每个文件和目录都与其拥有者(主人)和拥有组相关联。所有的文件信息都保存在一个称为 <strong>inode</strong> 的数据结构中。

<sect1 id="file-perm">文件和目录的访问权限
<p>
文件和目录的访问权限对如下 3 类用户进行了分别定义：
<list compact>
<item>文件<strong>拥有者</strong>(u)， 
<item>文件拥有者所在<strong>用户组</strong>中的其它成员(g)，和
<item>所有<strong>其它</strong>用户(o)。
</list>
<p>
每个文件均拥有下列三种权限：
<list compact>
<item><strong>read</strong> (r): 查看文件内容
<item><strong>write</strong> (w): 修改文件
<item><strong>execute</strong> (x): 如同命令一样执行文件
</list>
<p>
每个目录均拥有下列三种权限：
<list compact>
<item><strong>read</strong> (r): 列出目录内容
<item><strong>write</strong> (w): 在目录中增删文件
<item><strong>execute</strong> (x): 访问目录中的文件
</list>
在此，对目录的 <strong>execute</strong> 权限，不仅意味着允许查看目录下文件的内容，还允许查看文件的其它信息如文件大小、修改时间。
<p>

<prgn>ls</prgn>可用来显示目录和文件的这些信息。参阅
<manref name="ls" section="1">。使用 <prgn>ls</prgn> 的 <tt>-l</tt> 选项，就会按如下顺序显示下列信息：
<list compact>
<item><strong>文件类型</strong>(第1个字符)
 <list compact>
 <item><tt>-</tt>: 普通文件
 <item><tt>d</tt>: 目录
 <item><tt>l</tt>: 符号链接
 <item><tt>c</tt>: 字符型设备节点
 <item><tt>b</tt>: 块设备节点
 <item><tt>p</tt>: 命名管道
 <item><tt>s</tt>: 套接字
 </list>
<item>文件访问<strong>权限</strong>(接下来的 9 个字符，每3个一组依次代表 user、group 和 other)。
<item>文件的<strong>硬链接数</strong> 
<item>文件拥有 <strong>user</strong> 的用户名
<item>文件所属 <strong>group</strong> 的用户组名
<item>文件的字符数<strong>大小</strong> (bytes)
<item>文件的<strong>时间和日期</strong> (mtime)
<item>文件的<strong>名称</strong>
</list>
<p>
在 root 账号下可使用 <prgn>chown</prgn> 改变文件的拥有者。要改变文件的所属组，可以文件拥有者或 root 的身份运行 <prgn>chgrp</prgn>。要改变目录的访问权限，可以文件拥有者或 root 的身份运行 <prgn>chmod</prgn>。
<example>
# chown <var>newowner</var> foo
# chgrp <var>newgroup</var> foo
# chmod  [ugoa][+-=][rwx][,...] foo
</example>
细节请参见 <manref name="chown" section="1">、
<manref name="chgrp" section="1"> 和
<manref name="chmod" section="1">。

<p>
例如，可以 root 帐号下创建一个目录树，并使其拥有者为 <var>foo</var>，所属组为 <var>bar</var>：
<example>
# cd /some/location/
# chown -R <var>foo</var>:<var>bar</var> .
# chmod -R ug+rwX,o=rX .
</example>
<p>
下面是 3 个更特殊的权限：
<list compact>
<item><strong>set user ID</strong> (s 或 S 代替 user's x), 
<item><strong>set group ID</strong> (s 或 S 代替  group's x), 
<item><strong>sticky bit</strong> (t 或 T 代替  other's x).
</list>
在此，如果隐藏在特殊权限后面的执行权限标位没有设置，则 <prgn>ls -l</prgn> 的输出中，这些标识位将使用大写字母。
<p>
为可执行文件设置 <strong>set user ID</strong> 位将允许用户以该文件拥有者的 ID 来执行该文件(例如以 <strong>root</strong> 身份)。同样，为可执行文件设置 <strong>set group ID</strong> 将允许用户以该文件所属组的ID来执行该文件(例如以 <strong>root</strong> 身份)。因为这些设置将引起安全风险，所以使用这些特性时要格外小心。
<p>
为目录设置 <strong>set group ID</strong>，则该目录会使用 BSD-like 文件创建方案，即目录中所有新创建的文件均属于该目录所属的 <strong>group</strong>。
<p>
为目录设置 <strong>sticky bit</strong> 可防止非文件拥有者移动目录中的文件。为确保全局可写目录如 <file>/tmp</file> 或组可写目录中的文件内容不被修改，不仅要关闭文件的 <strong>写</strong> 权限，还应设置目录的 <strong>sticky bit</strong>，否则，任何对该目录有写权限的用户均可以将该文件移动到别处，然后在原地创建一个同名文件。
<p>
这儿有一些有关文件权限的有趣例子。
<example>
$ ls -l /etc/passwd /etc/shadow /dev/ppp /usr/sbin/pppd
crw-rw----    1 root     dip      108,   0 Jan 18 13:32 /dev/ppp
-rw-r--r--    1 root     root         1051 Jan 26 08:29 /etc/passwd
-rw-r-----    1 root     shadow        746 Jan 26 08:29 /etc/shadow
-rwsr-xr--    1 root     dip        234504 Nov 24 03:58 /usr/sbin/pppd
$ ls -ld /tmp /var/tmp /usr/local /var/mail /usr/src
drwxrwxrwt    4 root     root         4096 Feb  9 16:35 /tmp
drwxrwsr-x   10 root     staff        4096 Jan 18 13:31 /usr/local
drwxrwsr-x    3 root     src          4096 Jan 19 08:36 /usr/src
drwxrwsr-x    2 root     mail         4096 Feb  2 22:19 /var/mail
drwxrwxrwt    3 root     root         4096 Jan 25 02:48 /var/tmp
</example>
<p>
在 <manref name="chmod" section="1"> 命令里，有一种替代的数字模式来描述文件权限。这种数字模式使用 3 到 4 个八进制数字(以 8 为基)。
每个数字相应如下：
<list compact>
<item>第一个可选数字： <strong>set user ID</strong> (=4)、
 <strong>set group ID</strong> (=2) 和 <strong>sticky bit</strong> (=1)之和
<item>第二个数字： <strong>user</strong> 的 <strong>read</strong> (=4)、<strong>write</strong> (=2) 和
<strong>execute</strong> (=1) 权限之和
<item>第三个数字： 同上，用于 <strong>group</strong>
<item>第四个数字： 同上，用于 <strong>other</strong>
</list>
<p>
这听起来复杂，但实际上相当简单。 
从 <tt>ls -l</tt> 命令的输出中，看第(2-10)列，把它们作为二进制(以2为基)文件权限(“-”表示“0”,“rwx” 表示“1”)的表示方式来读，
这种数字模式值将使你理解八进制(以 8 为基)的文件权限表示。
<footnote>
当然，这种方法当然只能够在 3 位数字模式下使用。
</footnote>
例如，尝试：
<example>
$ touch <var>foo</var> <var>bar</var>
$ chmod u=rw,go=r <var>foo</var>
$ chmod 644 <var>bar</var>
$ ls -l <var>foo</var> <var>bar</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>foo</var>
-rw-r--r--    1 penguin  penguin  0 Nov  3 23:30  <var>bar</var>
</example>
<p>
默认的文件权限掩码使用 shell 内建命令 <prgn>umask</prgn> 设置。
参见 <manref name="builtins" section="7">。
</sect1>

<sect1 id="timestamp">时间戳
<p>
GNU/Linux 的文件有3种类型的时间戳：
<list compact>
<item><strong>mtime</strong>: 修改时间 (<tt>ls -l</tt>),
<item><strong>ctime</strong>: 状态改变时间 (<tt>ls -lc</tt>)，以及
<item><strong>atime</strong>: 最近访问时间 (<tt>ls -lu</tt>).
</list>
注意 <strong>ctime</strong> 并非文件创建时间。
<list compact>
<item>覆盖一个文件会改变所有三类时间 <strong>mtime</strong>、<strong>ctime</strong> 和 <strong>atime</strong> 所有三类时间。
<item>改变文件的访问权限或拥有者会改变文件的 <strong>ctime</strong> 和 <strong>atime</strong>。
<item>读文件会改变文件的 <strong>atime</strong>。
</list>
注意，在 &debian; 系统中，即便是简单的读文件通常会引起文件的写操作，从而更新 <strong>inode</strong> 上的 <strong>atime</strong> 信息。使用 <tt>noatime</tt> 选项来挂载文件系统，可使用系统忽略该操作，从而加速文件的访问和读取。参阅 <manref name="mount" section="8">。
<p>
<!-- new content -->
使用 <manref name="touch" section="1"> 命令来改变存在文件的时间戳。
</sect1>

<sect1 id="links">链接
<p>
在2种方法将文件 <var>foo</var> 关联到不同的文件名 <var>bar</var>。
<list compact>
<item><strong>hardlink</strong>(硬链接)相当于现存文件的另一个名字。(<tt>ln <var>foo</var> <var>bar</var></tt>)，
<item><strong>symbolic link</strong>(符号链接),或者“symlink”，是通过名字指向另外一个文件的特殊文件。(<tt>ln -s <var>foo</var> <var>bar</var></tt>)。
</list>
下面的例子显示了链接数的改变和使用 <prgn>rm</prgn> 命令时产生的微妙差异。
<example>
$ echo "Original Content" &gt; <var>foo</var>
$ ls -l <var>foo</var>
-rw-r--r--    1 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ ln <var>foo</var> <var>bar</var>     # 硬链接 
$ ln -s <var>foo</var> <var>baz</var>  # 符号链接
$ ls -l <var>foo</var> <var>bar</var> <var>baz</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>bar</var>
lrwxrwxrwx    1 osamu    osamu           3 Feb  9 22:28 <var>baz</var> -&gt; <var>foo</var>
-rw-r--r--    2 osamu    osamu           4 Feb  9 22:26 <var>foo</var>
$ rm <var>foo</var>
$ echo "New Content" &gt; <var>foo</var>
$ cat <var>bar</var>
Original Content
$ cat <var>baz</var>
New Content
</example>
<!-- minor update below -->
上例中符号链接均拥有名义上的文件访问权限“rwxrwxrwx”，它们的有效访问权限均由它们所指向的文件来定义。

<p>
<file>.</file> 链接到它所属的目录，因此任何新目录的链接数都从 2 开始计算。<file>..</file> 链接到父目录，因些目录链接数会随新的子目录数的增长而增长。

<sect1 id="fifo">命名管道(FIFOs)
<p>
<!-- DDP Debian Tutorial content -->
<p>
命名管道是一个行为象一个管道的文件。把某些东西放入命名管道文件，它从另外的一端出来。因此，它被称为
FIFO，或 First-In-First-Out：首先放入管道的东西将首先从另外一端出来。
<p>
如果写东西到一个命名管道，在写的东西在管道被读出之前，写的进程不会中止。如果从一个命名管道读，读的进程在中止之前，一直处于等待状态，直到有东西可以读为止。命名管道的大小始终为零 --- 它不储存数据，象 shell <tt>|</tt>
一样，它仅仅连接两个进程。然而，
这个管道有一个名字，两个进程没有必要在同一个命令行运行，或者由同一个用户运行。
<p>
做下面的操作来尝试：
<example>
$ cd; mkfifo mypipe
$ echo "hello" &gt;mypipe &amp; # 放入后台
[1] <var>5952</var>
$ ls -l mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:18 mypipe
$ cat mypipe
hello
[1]+  Done                    echo hello &gt;mypipe
$ ls mypipe
prw-r--r--    1 penguin penguin  0 2003-11-06 23:20 mypipe
$ rm mypipe
</example>

<sect1 id="sockets">套接字
<p>
<!-- new content -->
套接字类似于命名管道(FIFO)，它允许进程交换信息。
对于套接字，那些进程不必要在同时运行，也没有必要是同一个祖先进程的子进程。
它是进程间通讯的端点。
信息交换可以通过网络发生在不同的主机之间。

<sect1 id="device">设备文件
<p>
<!-- DDP Debian Tutorial content, modified -->
设备文件是系统上物理的或者虚拟的设备，比如说硬盘、显卡、显示器或者键盘。
一个虚拟设备的例子是控制台，由 <tt>/dev/console</tt> 表示。
<p>
有两种类型的设备： 
<list compact>
<item><strong>字符设备</strong>
<list compact>
<item>一次能够访问一个字符，那就是说，从设备读或者写的最小的数据单元是一个字符(byte)。
</list>
<item><strong>块设备</strong>
<list compact>
<item>一定是访问一个叫块的大单元，它含有许多字符。
硬盘是一个块设备。
</list>
</list>
<p>
设备文件可以被读写，尽管设备文件包含二进制数据，而这些二进制数据对人类来说是费解的乱码。
向设备文件直接写数据，有时侯对解决硬件连接故障有用。
比如说，将一个文本文件导出到打印机设备 <file>/dev/lp0</file>，
或者发送调制解调器命令到一个适当的串口 <file>/dev/ttyS0</file>。 
但是，除非是慎重的操作，它有可能造成一个大的破坏。
所以请小心。

<sect2 id="devnull"><file>/dev/null</file> 等等
<p>
<!-- DDP Debian Tutorial content, modifies -->
<p>
<file>/dev/null</file> 是一个特殊的设备文件，它忽略写给它的任何东西。
如果不需要某些东西，把它扔到 <file>/dev/null</file>。
它本质上是一个无底洞。
如果从 <file>/dev/null</file> 读东西，将会立即得到文件结束符(EOF)。 
<p>
<file>/dev/zero</file> 是类似的，只是从它读的话，将会得到
<tt>\0</tt> 字符(不与数字零的 ASCII 码相同)。  
参阅 <ref
id="dummyfile">。

<sect2 id="node">设备号
<p>
<!-- new content -->
按例子执行 <prgn>ls</prgn>，将显示设备号。
<example>
$ ls -l /dev/hda /dev/ttyS0 /dev/zero
brw-rw----    1 root     disk       3,   0 Mar 14  2002 /dev/hda
crw-rw----    1 root     dialout    4,  64 Nov 15 09:51 /dev/ttyS0
crw-rw-rw-    1 root     root       1,   5 Aug 31 03:03 /dev/zero
</example>
在这里：
<list compact>
<item><file>/dev/hda</file> 主设备号为 3，次设备号为 0。
属于 <tt>disk</tt>
组的用户有读写访问权。
<item><file>/dev/ttyS0</file> 主设备号为 4，次设备号为 64。
属于 <tt>dialout</tt>
组的用户有读写访问权。
<item><file>/dev/zero</file> 主设备号为 1,次设备号为 5。
所有人都有读写访问权。
</list>
<p>
在老的系统中，安装过程使用
<prgn>/sbin/MAKEDEV</prgn> 命令来创建设备号。
参阅 <manref name="MAKEDEV" section="8">。
<p>
在新的系统中，
<file>/dev</file> 下的文件系统通过设备文件系统自动生成，
设备文件系统与 <file>/proc</file> 文件系统类似。

<sect1 id="procfs"><file>/proc</file> 文件系统
<p>
<!-- modified heavily, original from Debian Guide -->
<file>/proc</file> 文件系统是一个伪文件系统，它包含系统信息和正在运行的进程信息。
<p>
当注意到一个特殊的文件
<file>/proc/kcore</file> 时，人们经常恐慌，因为它通常很巨大。
该文件(或多或少)是计算机内存的一个拷贝。
它被用来调试内核，
实际上它并不存在，所以不必担心它的大小。
<p>
参阅 <ref id="proc-sys"> 和 <manref name="proc" section="5">。

<sect id="xtuto">X 窗口系统
<p>
<!-- practically new content -->
参阅 <ref id="x">。

<sect1 id="xstart">启动 X 窗口系统
<p>
X 窗口系统能够使用类似
<prgn>xdm</prgn> 的图形登录守护启动，或者在控制台下输入如下的命令启动：
<example>
$ exec startx
</example>

<sect1 id="xmenu">X 窗口系统下的菜单
<p>
X 环境能够与许多窗口管理器协作，各个窗口管理器的用户界面有很大不同。
请记住，右击根窗口将显示一个选择菜单。这个功能总是存在。
<list compact>
<item>得到 shell 命令提示符，从菜单启动 Xterm ：
<list compact>
<item>"XShells" --&gt; "XTerm".
</list>
<item>浏览有图形的网页，从菜单启动 Mozilla：
<list compact>
<item>"Apps" --&gt; "Net" --&gt; "Mozilla Navigator".
</list>
<item>浏览有图形的 PDF 文件，从菜单启动 Xpdf：
<list compact>
<item>"Apps" --&gt; "Viewers" --&gt; "Xpdf".
</list>
</list>
<p>
如果没有发现菜单条目，请安装适当的软件包。参阅
<ref id="apt-install">。

<sect1 id="xkeys"> X 窗口系统键盘序列
<p>
当运行 X 窗口系统时，下面是一些需要记住的重要键盘序列。
<list compact>
<item>Ctrl-Alt-F1 到 F6:  切换到其它伪终端(从 X 系统、DOSEMU 等。)
<item>Alt-F7:               切换回 X 窗口
<item>Ctrl-Alt-minus:       改变 X 窗口的屏幕解析度(减号为数字键盘的键)
<item>Ctrl-Alt-plus:        在 X 窗口内以相反的方向改变屏幕解析度(加号为数字键盘的键)
<item>Ctrl-Alt-Backspace:   中止 X 服务器程序
<item>Alt-X, Alt-C, Alt-V:  通常在 Windows/Mac 下与  Ctrl-
键联合的粘贴、拷贝和剪切键，在
Netscape Composer 等程序中，使用 Alt- 键代替。
</list>

<sect id="cmd-study">进一步学习
<p>
目前，推荐阅读来自
<url id="&tldp-guide;" name="The Linux Documentation Project: Guides">
的关键用户手册。
<list compact>
<item>"The Linux System Administrators' Guide",
<list compact>
<item>覆盖了系统运行、处理用户账号、备份和配置系统的各个方面的内容。
<item>软件包： <package>&p-sysadmin-guide;</package>
<item>文件： <url id="&f-sysadmin-guide;">
<item>网址： <url id="&w-sysadmin-guide;">
</list>
<item>"The Linux Network Administrator's Guide, Second Edition",
<list compact>
<item>在 Linux 环境下网络管理的简单参考
<item>软件包： <package>&p-netadmin-guide;</package>
<item>文件：<url id="&f-netadmin-guide;">
<item>网址：<url id="&w-netadmin-guide;">
</list>

 <item>"Linux: Rute User's Tutorial and Exposition"
 <list compact>
  <item>覆盖 GNU/Linux 系统管理的精装书(有在线版)
  <item>作者：Paul Sheer
  <item>出版：Prentice Hall 
  <item>软件包：<package>&p-rutebook;</package> (从 <tt>non-free</tt>)
  <item>文件： <file>&f-rutebook;</file>
  <!--
  <item>网址：<url id="&rutehome;">
  -->
 </list>

</list>
<p>
更多资源参阅 <ref id="support">。
</chapt>
