<!-- CVS revision of this document "# Revision is not used here.#"  -->
<!-- CVS revision of original english document "1.112"  -->

<chapt id="tips">Astuces &debian;


<sect id="booting">Démarrer le système
<p>
Consultez le <url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> du LDP pour
des informations détaillées sur l'invite de démarrage.

<sect1 id="crackroot">«&nbsp;J'ai oublié le mot de passe de root&nbsp;!&nbsp;» (1)
<p>
On peux démarrer dans le compte administrateur (root) sans connaître le mot de
passe de root si on a un accès au clavier de la console.  (Cela suppose qu'il
n'y a pas de mot de passe requis pour le BIOS ni pour le chargeur de démarrage
comme <prgn>lilo</prgn> qui empêche de lancer le système).
<p>
Cette procédure ne nécessite ni disquette de démarrage externe ni changement 
dans les réglages du BIOS. Ici, "Linux" est le nom du noyau Linux par défaut 
qui lance le système Debian.
<p>
A l'écran d'invite de <prgn>lilo</prgn>, dès que <tt>boot:</tt> apparaît (il
faut appuyer sur la touche MAJ sur certains systèmes pour éviter le démarrage automatique et lorsque <prgn>lilo</prgn> utilise le framebuffer il faut appuyer sur TAB pour voir les options que vous tapez), entrez&nbsp;:
<example>
boot: Linux init=/bin/sh
</example>
Le système lance alors le noyau et exécute <file>/bin/sh</file> au lieu du
processus <prgn>init</prgn> standard. Vous avez maintenant les droits et le
shell de l'administrateur root. Puisque <file>/</file> est monté en lecture
seule et que beaucoup de partitions ne sont pas encore montées, vous devez
faire ce qui suit pour obtenir un système à peu près fonctionnel.
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(Si la seconde colonne de <file>/etc/passwd</file> est «&nbsp;x&nbsp;» pour
tous les utilisateurs, votre système utilise les "shadow passwords" (NdT&nbsp;:
mots de passes cachés), et il faut éditer <file>/etc/shadow</file>.) Une entrée
vide dans la seconde colonne de l'un de ces fichiers désactive le mot de passe.
Maintenant le système peut être lancé sans le mot de passe de root.
Debian (au moins après Potato) nécessite d'entrer un mot de passe si le
système est lancé au niveau d'exécution (runlevel) 1, ce que d'anciennes
distributions ne faisait pas.
<p>
C'est une bonne idée d'avoir un éditeur minimum dans <file>/bin</file> au cas
où <file>/usr</file> ne serait pas accessible (voir <ref id="bin-editor">).
<p>
Vous pouvez aussi installer le paquet <package>sash</package>. Si le système
ne démarre plus, lancez&nbsp;:
<example>
boot: Linux init=/bin/sash
</example>
<prgn>sash</prgn> sert de substitution intéractive à <prgn>sh</prgn> même
lorsque <file>/bin/sh</file> est inutilisable. Il est lié statiquement, et
inclut beaucoup d'utilitaires standard (tapez «&nbsp;help&nbsp;» à l'invite
pour une liste).
</sect1>

<sect1 id="crackroot2">«&nbsp;J'ai oublié le mot de passe de root&nbsp;!&nbsp;» (2)
<p>
Démarrez depuis n'importe quel ensemble de disquettes de boot/root.  Si
<file><var>/dev/hda3</var></file> est la partition racine originale, la suite
vous laissera éditer le fichier de mots de passe aussi facilement que
précédemment.
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
L'avantage de cette méthode sur la précédente est qu'on n'est pas obligé de
connaître le mot de passe de <prgn>lilo</prgn>, mais on doit pouvoir régler le
BIOS pour que le système se lance depuis la disquette ou le CD.
</sect1>

<sect1>Je ne peux pas lancer le système
<p>
Pas de problème, personne ne prend la peine de faire une disquette de
démarrage lors de l'installation. Si <prgn>lilo</prgn> est cassé, récupérez la
disquette de démarrage de l'installation de Debian (rescue). Démarrez depuis
cette disquette. A l'invite de démarrage, en supposant que la partition racine
de Linux est <file><var>/dev/hda12</var></file> et que vous voulez le niveau
d'exécution (runlevel) 3, entrez&nbsp;:
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
Vous avez maintenant lancé un système presque totalement fonctionnel 
depuis le noyau présent sur la disquette. (Il peut y avoir quelques problèmes 
et messages d'erreur mineurs à cause d'un manque dans les options du noyau ou 
d'un module absent.)
<p>
Voyez aussi <ref id="un-bootable"> si votre système est planté.
<p>
Si vous avez besoin d'une disquette de démarrage personnalisée, suivez les
instructions de <prgn>readme.txt</prgn> sur la disquette de secours.
</sect1>

<sect1 id="no-x-start">«&nbsp;Je veux désactiver X au démarrage&nbsp;!&nbsp;»
<p>
Suivre <tt>unstable/sid</tt> est sympa, mais un bogue de <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn>, ou <prgn>wdm</prgn> lancé pendant le
processus de démarrage peut faire mal.
<p>
D'abord, obtenez un shell avec root en tapant ce qui suit à l'invite de
démarrage&nbsp;:
<example>
boot: <var>Linux</var> vga=normal s
</example>
Là, <var>Linux</var> est le nom de l'image du noyau que vous démarrez,
«&nbsp;vga=normal&nbsp;» s'assure que <prgn>lilo</prgn> s'exécute en mode VGA,
et «&nbsp;s&nbsp;» (ou «&nbsp;S&nbsp;») est le paramètre passé à
<prgn>init</prgn> pour lancer le mode mono-utilisateur. Entrez le mot de passe
de root à l'invite.
<p>
Il existe quelques moyens de désactiver tous les démons X qui démarrent&nbsp;:
<list>
<item>lancez <tt>update-rc.d <var>?</var>dm stop 99 1 2 3 4 5 6 .</tt>
<item>insérez «&nbsp;exit 0&nbsp;» au début de tous les fichiers
<file>/etc/init.d/<var>?</var>dm</file>
<item>renommez tous les fichiers
<file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file> en
<file>/etc/rc2.d/K99<var>?</var>dm</file>
<item>supprimez tous les fichiers
<file>/etc/rc<var>2</var>.d/S99<var>?</var>dm</file>
<item>exécutez <tt>:&gt;/etc/X11/default-display-manager</tt>
</list>
Ici, <file>rc<var>2</var>.d</file> doit correspondre au niveau de
fonctionnement spécifié dans <file>/etc/inittab</file>. De plus,
<file><var>?</var>dm</file> signifie tous les fichiers parmi <prgn>xdm</prgn>,
<prgn>gdm</prgn>, <prgn>kdm</prgn>, et <prgn>wdm</prgn>.
<p>
Seul le premier est le «&nbsp;véritable moyen unique&nbsp;» de &debian;. Le
dernier est facile mais marche seulement sur &debian; et nécessite que vous
reconfiguriez le gestionnaire d'affichage par la suite avec
<prgn>dpkg-reconfigure</prgn>. Les autres sont des méthodes génériques pour
désactiver des démons.
<p>
Vous pouvez toujours lancer X avec la commande <prgn>startx</prgn> depuis une
console.
</sect1>

<sect1 id="bootprompt">Autres astuces avec l'invite de démarrage
<p>
Le système peut être lancé à un niveau d'exécution particulier et avec des
options de configurations en utilisant l'invite de démarrage de
<prgn>lilo</prgn>.  Les détails sont données dans le
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Si vous voulez lancer le système au niveau d'exécution 4, entrez la ligne 
suivante à l'invite de <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Si vous voulez lancer le système en mode de fonctionnement mono-utilisateur 
normal, et que vous connaissez le mot de passe de root, un des exemples 
suivants à l'invite de <prgn>lilo</prgn> fonctionnera. 
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Si vous voulez lancer le système en utilisant moins de mémoire vive que le
système n'en a en réalité (par exemple 48Mo sur un ordinateur qui a 64Mo),
utilisez la commande suivante à l'invite de démarrage de <prgn>lilo</prgn> :
<example>
boot: Linux mem=48M
</example>
Assurez-vous de ne pas spécifier plus de mémoire que le système n'en a en
réalité, sinon le noyau va planter. Si vous avez plus de 64Mo de mémoire vive,
128Mo par exemple, à moins de spécifier <tt>mem=128M</tt> à l'invite de
<prgn>lilo</prgn> ou d'inclure une ligne "append" similaire dans
<file>/etc/lilo.conf</file>, les vieux noyaux et/ou les cates mères avec un
vieux BIOS n'utiliseront pas la mémoire au-delà des 64Mo.
</sect1>

<sect1 id="bootgrub">Comment configurer les paramètres de démarrage de GRUB
<p>
GRUB est un nouveau gestionnaire de démarrage issu du projet Hurd et est
beaucoup plus flexible que Lilo mais a une manière différente de gérer les
paramètres de démarrage.
<example>
grub&gt; find /vmlinuz
grub&gt; root (hd0,0)
grub&gt; kernel /vmlinuz root=/dev/hda1
grub&gt; initrd /initrd
grub&gt; boot
</example>
Là, vous devez connaître les noms de périphériques de Hurd&nbsp;:
<example>
the Hurd/GRUB           Linux               MSDOS/Windows
 (fd0)               /dev/fd0            A:
 (hd0,0)             /dev/hda1           C: (habituellement)
 (hd0,3)             /dev/hda4           F: (habituellement)
 (hd1,3)             /dev/hdb4           ?
</example>
Voir <file>&f-grub;</file> et <file>&f-grub-doc;</file> pour les détails.
</sect>

<sect>Enregistrer les activités

<sect1 id="script">Enregistrer les activités du shell
<p>
L'administration système est une série d'activités beaucoup plus élaborées
dans un environnement Unix que dans un environnement de PC ordinaire. Soyez
sûr de connaître les méthodes de configuration de base si vous avez besoin de
réparer les problèmes d'un système. Les interfaces graphiques des outils de
configuration peuvent avoir l'air agréable et commode, mais sont parfois
limitées surtout dans de telles situations.
<p>
Dans ce contexte, enregistrer les activités du shell est une bonne habitude, 
surtout si l'on est root.
<p>
Sous Emacs&nbsp;: utilisez <tt>M-x shell</tt> pour démarrer l'enregistrement
dans le buffer, et utilisez <tt>C-x C-w</tt> pour écrire le contenu du buffer
dans un fichier.
<p>
Sous le shell&nbsp;: utilisez la commande <prgn>screen</prgn> avec «&nbsp;^A
H&nbsp;» comme décrit à la section <ref id="screen"> ou la commande <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 .... faites ce que vous voulez ...
 Ctrl-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
La méthode suivante peut être utilisée à la place de <prgn>script</prgn>.
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>Enregistrer les activités sous X
<p>
Si vous avez besoin d'enregistrer l'image d'une application sous X, y compris
une fenêtre de <prgn>xterm</prgn>, utilisez <prgn>gimp</prgn>. Il peut capturer
une fenêtre isolée ou l'écran entier. Des alternatives existent comme
<prgn>xwd</prgn> (paquet <package>xbase-clients</package>), <prgn>import</prgn>
(<package>imagemagick</package>), ou <prgn>scrot</prgn>
(<package>scrot</package>).
</sect1>


</sect>

<sect id="archiving">Copier et archiver un sous-répertoire entier
<sect1>Commandes de base pour copier un sous-répertoire entier
<p>
En cas de réarrangement de la structure de fichiers, déplacez le contenu des 
dossiers y compris les liens par les commandes&nbsp;:
<example>
Méthode classique :
# cp -a /source/directory /dest/directory # version GNU de cp
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
S'il y a des liens durs, la méthode suivante est nécessaire :
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
Si le système de fichier est distant :
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
S'il n'y a pas de fichiers liés :
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
Ici, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> et <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
La méthode de copie d'un sous-répertoire entier est basée sur l'information
fournie par Manoj Srivastava <email>srivasta@debian.org</email> sur la liste de
diffusion debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Traditionnellement, <prgn>cp</prgn> n'était pas réellement utilisable
puisqu'il ne déréférence pas les liens symboliques, ni ne préserve les liens
durs. Une autre chose à considérer était les fichiers à faible densité (avec
des trous).
<p>
La version GNU de <prgn>cp</prgn> a dépassé ces limitations&nbsp;; cependant,
sur un système non GNU, <prgn>cp</prgn> peut toujours avoir ces problèmes. De
plus, on ne peut pas générer de petites archives portables avec
<prgn>cp</prgn>.
<example>
&percnt; cp -a . newdir
</example>

<sect1><prgn>tar</prgn>
<p>
<prgn>tar</prgn> a éliminé certains des problèmes que <prgn>cp</prgn> avait
avec les liens symboliques. Cependant, bien que <prgn>cpio</prgn> gère les
fichiers spéciaux, le <prgn>tar</prgn> traditionnel ne les gère pas.
<p>
<prgn>tar</prgn> gère de multiples liens durs en plaçant une copie du lien sur
la bande, mais le nom de cette copie est le <em>seul</em> que vous pouvez
utiliser pour récupérer le fichier&nbsp;; <prgn>cpio</prgn> met une copie pour
chaque lien, et vous pouvez le récupérer en utilisant n'importe lequel des
noms.
<p>
La commande  <prgn>tar</prgn> a changé l'option pour les fichiers
<file>.bz2</file> entre Potato et Woody, donc utilisez <tt>--bzip2</tt> dans
des scripts au lieu de <tt>-I</tt> (Potato) ou <tt>-j</tt> (Woody).
</sect1>

<sect1><prgn>pax</prgn>
<p>
C'est le nouvel utilitaire d'archivage portable, compatible POSIX (IEEE Std
1003.2-1992, pages 380-388 (section 4.48) et pages 936-940 (section E.4.48)),
"qui chante et danse". <prgn>pax</prgn> lit, écrit, et liste les fichiers
d'une archive, et copie des hiérarchies de répertoires. <prgn>pax</prgn>
travaille indépendament du format de l'archive et supporte un grand nombre de
formats d'archives.
<p>
Les implémentations de <prgn>pax</prgn> sont récentes et encore chaudes.
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 ou
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn> stocke ou extrait les fichiers dans ou à partir d'une
archive <prgn>cpio</prgn> ou <prgn>tar</prgn>. L'archive peut être un autre
fichier sur le disque, une bande magnétique ou un tube.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> permet de mieux gérer les archives au format
<prgn>cpio</prgn>. Il est généralement plus rapide que <prgn>cpio</prgn>,
fournit plus d'options pour les bandes magnétiques, gère mieux les erreurs de
données en entrée et supporte des archives multi-volume en utilisation
intéractive. <prgn>afio</prgn> peut créer des archives compressées qui sont
plus sûres que les archives compressées de <prgn>tar</prgn> ou
<prgn>cpio</prgn>. <prgn>afio</prgn> est utilisé au mieux en tant que machine
à archiver dans un script de sauvegarde.
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
Toutes mes sauvegardes sur bande sont faites avec <prgn>afio</prgn>.
</sect1>
</sect>

<sect id="diff-backup">Sauvegarde différentielle et synchronisation de données
<p>
La sauvegarde différentielle et la synchronisation de données peuvent être
implémentés par plusieurs méthodes&nbsp;:
<list>
<item><package>rcs</package>&nbsp;: sauvegarde et historique, texte seulement
<item><package>rdiff-backup</package>&nbsp;: sauvegarde et historique. liens
symboliques OK.
<item><package>pdumpfs</package>&nbsp;: sauvegarde et historique à l'intérieur
d'un système de fichier. liens symboliques OK.
<item><package>rsync</package>&nbsp;: synchronisation dans un seul sens
<item><package>unison</package>&nbsp;: synchronisation dans deux sens
<item><package>cvs</package>&nbsp;: synchronisation dans plusieurs sens avec
sauvegarde et historique sur un serveur, texte seulement, mûr. Voir <ref
id="cvs">.
<item><package>arch</package>&nbsp;: synchronisation dans plusieurs sens avec
sauvegarde et historique sur un serveur, pas de «&nbsp;répertoire de
travail&nbsp;».
<item><package>subversion</package>&nbsp;: synchronisation dans plusieurs sens
avec sauvegarde et historique sur un serveur, Apache.
</list>
La combinaison d'une des méthodes décrites dans la section <ref
id="archiving"> et le processus régulier automatisé décrit dans la section
<ref id="cronjob"> permet de faire un bon système de sauvegarde.
<p>
Je vais décrire trois outils faciles à utiliser.

<sect1 id="rdiff-backup">Sauvegarde différentielle avec rdiff
<p>
<package>rdiff-backup</package> offre une sauvegarde bonne et simple avec
historique différentiel pour n'importe quel type de fichiers y compris des
liens symboliques. Pour sauvegarder la plus grande partie de <file>~/</file>
vers <file>/mnt/backup</file>&nbsp;:
<example>
$ rdiff-backup --include ~/tmp/keep --exclude ~/tmp  ~/ /mnt/backup
</example>
Pour restaurer les données d'il y a trois jours de cette archive vers
<file>~/old</file>&nbsp;:
<example>
$ rdiff-backup -r 3D /mnt/backup ~/old
</example>
Voir <manref name="rdiff-backup" section="1">.

<sect1 id="pdumpfs-backup">Sauvegarde quotidienne avec
<package>pdumpfs</package>
<p>
<package>pdumpfs</package> est un système simple de sauvegarde quotidienne
similaire à <prgn>dumpfs</prgn> du système Plan9, et qui garde chaque
image quotidienne. Vous pouvez accéder aux images antérieures n'importe quand
pour récupérer un fichier d'un certain jour. Sauvegardons votre répertoire
personnel avec <prgn>pdumpfs</prgn> et <prgn>cron</prgn>&nbsp;!
<p>
<prgn>pdumpfs</prgn> construit une image <tt>AAAA/MM/JJ</tt> dans le répertoire
destination. Tous les fichiers source sont copiés vers le répertoire de l'image
la première fois que <prgn>pdumpfs</prgn> est exécuté. A partir de la deuxième
fois, <prgn>pdumpfs</prgn> copie seulement les ficheirs modifiés ou créés et
stocke les fichiers inchangés avec des liens durs vers les fichiers du jour
précédent, pour économiser de l'espace disque.
<example>
$ pdumpfs <var>src-dir</var> <var>dest-dir</var> [<var>dest-basename</var>]
</example>
Voir <manref name="pdumpfs" section="8">.
</sect1>

<sect1 id="backup">Sauvegarde différentielle régulière avec RCS
<p>
<package>changetrack</package> enregistre les changements des fichiers texte
de configuration dans des archives RCS régulièrement.
Voir <manref name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>
</sect>


<sect>Récupération d'un système bloqué
<sect1 id="kill">Tuer un processus
<p>
Exécutez <prgn>top</prgn> pour voir quel processus agit bizarrement. Appuyez
sur «&nbsp;P&nbsp;» pour trier par temps CPU utilisé, «&nbsp;M&nbsp;» pour
trier par mémoire utilisée, et «&nbsp;k&nbsp;» pour tuer un processus.
Autrement, <tt>ps aux | less</tt> (style BSD) ou <tt>ps -efH | less</tt>
(style System V) peut être utilisé. La syntaxe System V affiche le numéro de
processus parent <tt>PPID</tt> qui peut être utilisé pour tuer des processus
zombie (defunct).
<p>
Utilisez <prgn>kill</prgn> pour tuer (ou envoyer un signal à) un processus à
partir de son numéro de processus, ou <prgn>killall</prgn> pour faire la même
chose à partir du nom de la commande du processus. Signaux fréquemment
utilisés&nbsp;:
<example>
 1 : HUP,  redémarre un démon
15 : TERM, termine un process normalement
 9 : KILL, tue un process
</example>

</sect1>

<sect1>Alt-SysRq
<p>
L'option de compilation du noyau "Magic SysRq key" donne une assurance contre
un mauvais fonctionnement du système.
Appuyer sur Alt-SysRq sur un i386, suivi par une des touches <tt>r 0
k e i s u b</tt>, agit magiquement.  
<p>
Un`R'aw récupère le clavier en cas de plantage de logiciels comme X.  Mettre
le niveau de log de la console à `0' réduit le nombre de messages d'erreur.
sa`K' (touche d'attention système, NdT&nbsp;: system attention key en Anglais)
tue tous les processus de la console vituelle courante. t`E'rminate tue tous
les processus du terminal courant excepté <prgn>init</prgn>. k`I'll tue tous
les processus excepté <prgn>init</prgn>.
<p>
`S'ync, `U'mount, et re`B'oot permettent de se sortir de très mauvaises
situations.
<p>
Des informations détaillées se trouvent dans
<file>/usr/share/doc/kernel-doc-<var>version</var>/Documentation/sysrq.txt.gz</file>
ou <file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>


<sect id="nifty">Petites commandes utiles à se rappeler

<sect1>Pager
<p>
<prgn>less</prgn> est le <em>pager</em> (visualisateur de contenu des
fichiers). Appuyez sur `h' pour de l'aide. Il peut faire beaucoup plus que
<prgn>more</prgn>. <prgn>less</prgn> peut être amélioré en exécutant <tt>eval
$(lesspipe)</tt> ou <tt>eval $(lessfile)</tt> dans les scripts de démarrage du
shell. Plus d'information dans <file>&f-lessopen;</file>. L'option <tt>-R</tt>
permet l'affichage de caractères bruts et active les séquences d'échappement
couleur ANSI. Voir <manref name="less" section="1">.
<p>
<prgn>w3m</prgn> peut être une bonne solution de rechange pour les systèmes de
code (EUC).

<sect1>Mémoire libre
<p>
<prgn>free</prgn> et <prgn>top</prgn> donnent de bonnes informations sur les
ressources mémoire. Ne vous inquiétez pas de la taille de "used" sur la ligne
"Mem:", lisez plutôt la ligne en-dessous (38792 dans l'exemple ci-dessous).
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
La quantité exacte de mémoire physique peut être confirmée par <tt>grep
'^Memory' /var/log/dmesg</tt>, qui dans notre cas d'exemple donne
«&nbsp;Memory: 256984k/262144k available (1652k kernel code, 412k reserved,
2944k data, 152k init)&nbsp;».
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Environ 5Mo ne sont pas utilisables par le système parce que le noyau les
utilise.
</sect1>

<sect1>Régler l'heure (BIOS)
<p>
<example>
# date MMJJhhmmAAAA
# hwclock --utc --systohc
# hwclock --show
</example>
Cela va régler l'heure du système et du matériel à JJ/MM hh:mm, AAAA.
L'heure est affichée selon le fuseau horaire local, mais le matériel utilise
UTC.
<p>
Si l'heure matérielle (BIOS) est réglée en GMT, changez le réglage pour <tt>UTC=yes</tt> dans le fichier <file>/etc/default/rcS</file>.

<sect1>Régler l'heure (NTP)
<p>
Référence&nbsp;: <url id="&time-howto;" name="Managing Accurate Date and Time
HOWTO">.
<p>
<sect2>Régler l'heure avec une connexion Internet permanente
<p>
Régler l'horloge système automatiquement via un serveur distant&nbsp;:
<example>
# ntpdate <var>server</var>
</example>
Il est bon d'avoir cette commande dans <file>/etc/cron.daily</file> si votre
système possède une connexion permanente à Internet.

<sect2>Régler l'heure avec une connexion Internet intermitente
<p>
Utilisez le paquet <package>chrony</package>.
</sect1>

<sect1 id="setterm">Comment contrôler des possibilités de la console comme l'écran de veille
<p>
Pour désactiver l'écran de veille, utilisez les commandes suivantes.
<p>
En mode console&nbsp;:
<example>
# setterm -powersave off
</example>
<p>
Démarrez la console kon2 (kanji) avec&nbsp;:
<example>
# kon -SaveTime 0
</example>
<p>
Sous X&nbsp;:
<example>
# xset s off
 ou
# xset -dpms
 ou
# xscreensaver-command -prefs
</example>
Lisez les pages de manuel correspondantes pour contrôler d'autres possibilités
de la console. Voir aussi <manref name="stty" section="1"> pour changer et
afficher la configuration du terminal.
</sect1>

<sect1 id="getent">Chercher dans la base de données administrative
<p>
La Glibc offre <manref name="getent" section="1"> pour chercher dans les
entrées des bases de données administratives, càd., passwd, group, hosts,
services, protocols, ou networks.
<example compact>
getent database [key ...]
</example>

<sect1>Désactiver le son (beep)
<p>
On peut toujours débrancher le haut-parleur PC ;-)
Pour le shell Bash&nbsp;:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Messages d'erreur sur l'écran de la console
<p>
Afin de ne pas avoir de messages d'erreur sur l'écran, le premier endroit à
regarder est <file>/etc/init.d/klogd</file>. Réglez <tt>KLOGD="-c
<var>3</var>"</tt> dans ce script et lancez <tt>/etc/init.d/klogd
restart</tt>. Une autre méthode est de lancer <tt>dmesg -n<var>3</var></tt>.
<p>
Voici la signification des niveaux d'erreur&nbsp;:
<list compact>
<item>0: KERN_EMERG,   system is unusable
<item>1: KERN_ALERT,   action must be taken immediately
<item>2: KERN_CRIT,    critical conditions
<item>3: KERN_ERR,     error conditions
<item>4: KERN_WARNING, warning conditions
<item>5: KERN_NOTICE,  normal but significant condition
<item>6: KERN_INFO,    informational
<item>7: KERN_DEBUG,   debug-level messages
</list>
<p>
Si un message d'erreur particuler vous embête, pensez à faire une rustine
facile pour le noyau comme <file>shutup-abit-bp6</file> (disponible dans le
<url id="&examples;" name="sous-répertoire des exemples">).
<p>
Un autre endroit à regarder peut être le fichier
<file>/etc/syslog.conf</file>&nbsp;; vérifiez si les messages d'erreurs ne
sont pas envoyés vers une console.
</sect1>

<sect1>Régler la console
<p>
Les consoles sur les systèmes Unix sont habituellement accédées par des
fonctions de la bibliothèque (n)curses. Cela donne à l'utilisateur une méthode
indépendante du terminal pour mettre à jour les caractères sur l'écran avec
une optimisation raisonnable. Voir <manref name="ncurses" section="3X"> et
<manref name="terminfo" section="5">.
<p>
Sur un système &debian;, il existe beaucoup d'entrées prédéfinies&nbsp;:
<example>
$ toe | less                  # toutes les entrées
$ toe /etc/terminfo/ | less   # entrées reconfigurables
</example>
Exportez votre sélection dans une variable d'environnement <tt>TERM</tt>.
<p>
Si l'entrée terminfo pour <prgn>xterm</prgn> ne marche pas avec un
<prgn>xterm</prgn> non Debian, changez le type de terminal de
«&nbsp;xterm&nbsp;» à l'une des versions limitée en options comme
«&nbsp;xterm-r6&nbsp;» lorsque vous vous connectez à un système Debian à
distance. Voir <file>&f-libncurse;</file> pour plus d'information.
«&nbsp;dumb&nbsp;» est le plus petit dénominateur commun pour terminfo.
</sect1>

<sect1>Remettre la console dans un état sain
<p>
Lorsque l'écran devient illisible après <tt>$ cat
<var>fichierbinaire</var></tt> (il se peut que vous ne voyiez pas la commande
en tapant)&nbsp;:
<example>
$ reset
</example>
</sect1>

<sect1 id="dos2unix">Convertir des fichiers texte DOS vers Unix
<p>
Pour convertir un fichier texte DOS (fin de ligne <tt>^M^J</tt>) en fichier
texte Unix (<tt>^J</tt>)&nbsp;:
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1 id="recode">Convertir un fichier texte avec <prgn>recode</prgn>
<p>
Ce qui suit convertit les fichiers entre les caractères de fin de ligne DOS,
Mac et Unix&nbsp;:
<example>
$ recode /cl../cr &lt;<var>dos.txt</var> &gt;<var>mac.txt</var>
$ recode /cr.. &lt;<var>mac.txt</var> &gt;<var>unix.txt</var>
$ recode ../cl &lt;<var>unix.txt</var> &gt;<var>dos.txt</var>
</example>
<prgn>recode</prgn> convertir aussi les fichiers entre les différents jeux de
caractères et surfaces&nbsp;:
<example>
$ recode <var>charset1</var>/<var>surface1</var>..<var>charset2</var>/<var>surface2</var> \
 &lt;<var>input.txt</var> &gt;<var>output.txt</var>
</example>
Les jeux de caractères les plus courants sont (voir aussi <ref
id="base-locale">)
<footnote>
<prgn>recode</prgn> permet des alias plus pratiques que <prgn>iconv</prgn>.
</footnote>
&nbsp;:
<list compact>
<item><tt>us</tt> &mdash; ASCII (7 bits)
<item><tt>l1</tt> &mdash;  ISO Latin-1 (ISO-8859-1, Europe de l'Ouest, 8 bits)
<item><tt>EUCJP</tt> &mdash; EUC-JP pour le Japonais (Unix)
<item><tt>SJIS</tt> &mdash; Shift-JIS pour le Japonais (Microsoft)
<item><tt>ISO2022JP</tt> &mdash; codage mail pour le Japonais (7 bits)
<item><tt>u2</tt> &mdash; UCS-2 (Universal Character Set, 2 octets)
<item><tt>u8</tt> &mdash; UTF-8 (Universal Transformation Format, 8 bits)
</list>
Les surfaces les plus courantes sont
<footnote>
Fins de lignes&nbsp;:
<list compact>
<item>Retour chariot signifie ASCII 13, ASCII 0xD, ^M, ou \r.
<item>Remplissage de ligne signifie ASCII 10, ASCII 0xA, ^J, or \n.
</list>
</footnote>
&nbsp;:
<list compact>
<item><tt>/cr</tt> &mdash; Retour chariot comme fin de ligne (texte Mac)
<item><tt>/cl</tt> &mdash; Retour chariot - remplissage de ligne comme fin de
ligne (texte DOS)
<item><tt>/</tt> &mdash; Remplissage de ligne comme fin de ligne (texte Unix)
<item><tt>/d1</tt> &mdash; sortie décimale lisible par un humain
<item><tt>/x1</tt> &mdash; sortie hexadécimale lisible par un humain
<item><tt>/64</tt> &mdash; texte codé Base64
<item><tt>/QP</tt> &mdash; texte codé Quoted-Printable
</list>
Pour plus de détails, voir la description de <tt>info recode</tt>.
<p>
Il existe aussi des outils de conversion plus spécialisés&nbsp;:
<list compact>
<item>conversion de jeux de caractères&nbsp;:
<list compact>
<item><prgn>iconv</prgn> &mdash; conversions de codages de locales
<item><prgn>konwert</prgn> &mdash; conversions de codages variés
</list>
<item>conversion de fichiers binaires&nbsp;:
<list compact>
<item><prgn>uuencode</prgn> et <prgn>uudecode</prgn> &mdash; pour Unix
<item><prgn>mimencode</prgn> &mdash; pour le courriel
</list>
</list>
</sect1>

<sect1 id="perl-i">Substitutions à l'aide des expressions rationnelles
<p>
Pour remplacer toutes les occurences de <var>FROM_REGEX</var> par
<var>TO_REGEX</var> dans tous les fichiers <var>FILES</var> ...&nbsp;:
<example>
$ perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_REGEX</var>/g;' <var>FILES</var> ...
</example>
<tt>-i</tt> est pour «&nbsp;édition sur place&nbsp;», <tt>-p</tt> est pour
«&nbsp;boucle implicite sur <var>FILES</var> ...&nbsp;». Si la substitution est
complexe, vous pouvez faciliter le retour sur des erreurs en utilisant le
paramètre <tt>-i.bak</tt> au lieu de <tt>-i</tt>&nbsp;; cela permet de garder
les fichiers originaux en leur ajoutant le suffixe <tt>.bak</tt>.
</sect1>

<sect1>Editer un fichier avec un script
<p>
Le script suivant supprime les lignes 5 à 10 et 16 à 20.
<example>
#!/bin/bash
ed $1 &lt;&lt;EOF
16,20d
5,10d
w
q
EOF
</example>
Les commandes de <prgn>ed</prgn> sont les mêmes que celles de <prgn>vi</prgn>
en mode commande. L'édition de fichiers de cette façon rend facile la création
de scripts.
</sect1>

<sect1>Extraire des différences et introduire des mises à jour dans un fichier source
<p>
Suivez l'une de ces procédures pour extraire les différences par rapport au
fichier source et créer des fichiers diff unifiés <var>file.patch0</var> ou
<var>file.patch1</var> selon l'emplacement du fichier&nbsp;:
<example>
$ diff -u <var>file.old</var> <var>file.new1</var> &gt; <var>file.patch0</var>
$ diff -u <var>old/file</var> <var>new1/file</var> &gt; <var>file.patch1</var>
</example>
Le fichier diff (aussi appelé rustine ou patch) est utilisé pour envoyer des
mises à jour du programme. Celui qui le reçoit peut appliquer cette mise à
jour à un autre fichier <var>file</var> avec&nbsp;:
<example>
$ patch -p0 <var>file</var> &lt; <var>file.patch0</var>
$ patch -p1 <var>file</var> &lt; <var>file.patch1</var>
</example>
Si vous avez trois versions d'un code source, vous pouvez les mélanger plus
efficacement avec <prgn>diff3</prgn>&nbsp;:
<example>
$ diff3 -m <var>file.mine</var> <var>file.old</var> <var>file.yours</var> &gt; <var>file</var>
</example>
</sect1>

<sect1>Convertir un gros fichier en plusieurs petits
<p>
<example>
$ split -b 650m <var>file</var>   # sépare <var>file</var> en morceaux de 650Mo
$ cat x* &gt;<var>largefile</var>    # assemble les fichiers en 1 gros fichier
</example>
</sect1>

<sect1>Extraire des données d'un tableau contenu dans un fichier texte
<p>
Considérons un fichier texte <file>DPL</file> dans lequel tous les
responsables précédents du projet &debian; (DPL, Debian Project Leader) et
leur date d'investiture sont listés séparés par des espaces dans un tableau.
<example>
Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   January 1998
Wichert Akkerman  January 1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr March   2003
</example>
AWK est fréquemment utilisé pour extraire des données à partir de ce type de
tableaux.
<example>
$ awk '{ print $3 }' &lt;DPL                   # mois d'investiture
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' &lt;DPL          # DPL appelé Ian
Ian     Murdock   August  1993
Ian     Jackson   January 1998
$ awk '($2=="Perens") { print $3,$4 }' &lt;DPL # quand Perens a été investi
April 1996
</example>
<p>
Des shells comme Bash peuvent aussi être utilisés pour ce genre de fichiers&nbsp;:
<example>
$ while read first last month year; do
    echo $month
  done &lt;DPL
... même sortie que le premier exemple Awk
</example>
Ici, la commande de Bash <prgn>read</prgn> utilise les caractères de $IFS
(internal field separators, séparateurs de champs internes) pour séparer les
lignes en mots.
<p>
Si vous changez $IFS à ":", vous pouvez traiter le fichier
<file>/etc/passwd</file> avec le shell&nbsp;:
<example>
$ oldIFS="$IFS"   # garde l'ancienne valeur
$ IFS=":"
$ while read user password uid gid rest_of_line; do
    if [ "$user" = "osamu" ]; then
      echo "$user's ID is $uid"
    fi
  done < /etc/passwd
osamu's ID is 1001
$ IFS="$oldIFS"   # remet l'ancienne valeur
</example>
(Si Awk est utilisé pour faire cela, utilisez <tt>FS=":"</tt> pour régler le
séparateur de champs.)
<p>
IFS est aussi utilisé par le shell pour séparer les résultats de l'expansion
de paramètres, de la substitution de commande, et l'expansion arithmétique.
Celles-ci ne sont pas effectuées à l'intérieur de guillemets simples ou
doubles. La valeur par défaut de IFS est &lt;space&gt;, &lt;tab&gt; et
&lt;newline&gt;.
<p>
Faites attention en utilisant IFS. Des choses étranges peuvent survenir,
lorsque le shell interprète certaines parties du script comme
<strong>entrée</strong>.
<example>
$ IFS=":,"                        # utilise ":" et "," come IFS
$ echo IFS=$IFS,   IFS="$IFS"     # echo est une commande Bash
IFS=  , IFS=:,
$ date -R                         # une simple sortie de commande
Sat, 23 Aug 2003 08:30:15 +0200
$ echo $(date -R)                 # sous-shell --&gt; entrée vers
                                    le shell principal
Sat  23 Aug 2003 08 30 36 +0200
$ unset IFS                       # restaure la valeur par défaut
$ echo $(date -R)
Sat, 23 Aug 2003 08:30:50 +0200
</example>
</sect1>


<sect1 id="scrp-snip">Bouts de scripts pour les tubes
<p>
Les scripts suivants font des choses sympa avec les tubes.
<example>
find /usr | egrep -v "/usr/var|/usr/tmp|/usr/local"
                     # trouve tous les fichiers de /usr sauf certains
xargs -n 1 <var>command</var>   # exécute <var>command</var> avec tous les arguments de stdin
xargs -n 1 echo |    # place chaque argument séparé par des espaces
                       sur une ligne
xargs echo      |    # fusionne toutes les lignes en une seule
grep -e <var>pattern</var>|     # extrait les lignes contenant <var>pattern</var>
cut -d: -f3 -|
        # extrait le 3e champ séparé par <var>:</var> (fichier passwd, etc.)
awk '{ print $3 }' | # extrait le 3e champ séparé par des espaces
awk -F'\t' '{ print $3 }' |
        # extrait le 3e champ séparé par des tabulations
col -bx |            # supprime les retour-arrières et transforme
                       les tabulations en espaces
expand -|            # transforme les tabulations
sort -u|             # trie et supprime les doublons

tr '\n' ' '|         # concatène les lignes en une seule
tr '\r' ''|          # supprime CR
tr 'A-Z' 'a-z'|      # convertit les majuscules en minuscules
sed 's/^/# /'|       # change chaque ligne en commentaire
sed 's/\<var>.ext</var>//g'|    # supprime <var>.ext</var>
sed  -n -e 2p|       # affiche la 2e ligne
head -n 2 -|         # affiche les 2 premières lignes
tail -n 2 -|         # affiche les 2 dernières lignes
</example>
</sect1>

<sect1>Bouts de scripts pour boucler sur chaque fichier
<p>
Les façons suivantes de boucler sur chaque fichier correspondant à
<tt>*.<var>ext</var></tt> assure une gestion correcte des noms de fichiers
atypiques comme ceux ayant des espaces et effectuent la même chose&nbsp;:
<list>
<item>Boucle shell (ceci est une entrée multi-ligne avec <tt>PS2="&gt; "</tt>)
<footnote>
Si vous tapez ceci sur une seule ligne, vous devez ajouter des points-virgule
pour marquer la fin des commandes shell.
</footnote>&nbsp;:
<example>
for <var>x</var> in *.<var>ext</var>; do
  if test -f "$<var>x</var>"; then
    <var>command</var> "$<var>x</var>"
  fi
done
</example>
<item><prgn>find</prgn> et <prgn>xargs</prgn>&nbsp;:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' -print0 | \
 xargs -0 -n 1 <var>command</var>
</example>
<item><prgn>find</prgn> avec l'option <tt>-exec</tt> et une commande&nbsp;:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec <var>command</var> '{}' \;
</example>
<item><prgn>find</prgn> avec l'option <tt>-exec</tt> et un script shell&nbsp;:
<example>
find . -type f -maxdepth 1 -name '*.<var>ext</var>' \
 -exec sh -c "<var>command</var> '{}' && echo 'successful'" \;
</example>
</list>
</sect1>

<sect1 id="perl-mad">Série de courts scripts en Perl
<p>
Tous les scripts Awk peuvent être réécrits avec Perl. Par exemple&nbsp;:
<example>
awk '($2=="1957") { print $3 }'|
</example>
peut être remplacé par l'une des lignes suivantes au choix&nbsp;:
<example>
perl -ne '@f=split; if ($f[1] eq "1957") { print "$f[2]\n"}' |
perl -ne 'if ((@f=split)[1] eq "1957") { print "$f[2]\n"}' |
perl -ne '@f=split; print $f[2] if ( $f[1]==1957 )' |
perl -lane 'print $F[2] if $F[1] eq "1957"' |
</example>
<p>
On peut enlever tous les espaces dans les arguments de <prgn>perl</prgn> dans
la ligne précédente et prendre avantage de la conversion automatique entre les
nombres et les chaînes de caractères en Perl&nbsp;:
<example>
perl -lane 'print$F[2]if$F[1]eq+1957' |
</example>
Voir <manref name="perlrun" section="1"> pour les options de la ligne de
commande. Pour des scripts Perl plus fous, le site <url id="&perlgolf;"> peut
être intéressant.
</sect1>

<sect1>Récupérer du texte ou une archive de liste de diffusion à partir d'une
page web
<p>
Les commandes suivantes récupèrent une page web dans un fichier texte. Très
utile pour copier des configurations depuis le Web.
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>textf
ile</var>
</example>
<prgn>links</prgn> et <prgn>w3m</prgn> peuvent aussi être utilisés, avec de
légères différences dans le rendu.
<p>
S'il s'agit d'une archive de liste de diffusion, utilisez <prgn>munpack</prgn>
pour obtenir les contenus MIME à partir du texte.
</sect1>

<sect1>Imprimer joliment une page web
<p>
Les commandes suivantes vont lire une page web et l'imprimer sur une
imprimante/dans un fichier PostScript.
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Voir <ref id="lprlpd">. Regardez aussi <prgn>a2ps</prgn> et <prgn>mpage</prgn>
pour créer des fichiers PostScript.
</sect1>

<sect1>Imprimer joliment une page de manuel
<p>
Les commandes suivantes impriment une page de manuel sur une imprimante/un
fichier PostScript.
<example>
$ man -Tps <var>some-man-page</var> | lpr
$ man -Tps <var>some-man-page</var> | mpage -2 | lpr
</example>
</sect1>

<sect1>Joindre deux fichiers PostScript ou PDF
<p>
Vous pouvez joindre deux fichiers PostScript ou PDF.
<example>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite \
  -sOutputFile=<var>bla.ps</var> -f <var>foo1.ps</var> <var>foo2.ps</var>
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite \
  -sOutputFile=<var>bla.pdf</var> -f <var>foo1.pdf</var> <var>foo2.pdf</var>
</example>
</sect1>

<sect1>Mesurer la durée d'une commande
<p>
Affiche le temps pris par un processus.
<example>
# time <var>commande</var> &gt;/dev/null
real    0m0.035s       # durée sur l'horloge (temps réel écoulé)
user    0m0.000s       # durée en mode utilisateur
sys     0m0.020s       # durée en mode noyau
</example>
</sect1>

<sect1>Commande <prgn>nice</prgn>
<p>
Utilisez <prgn>nice</prgn> (du paquet GNU <package>shellutils</package>) pour
régler la «&nbsp;gentillesse&nbsp;» (valeur <em>nice</em>) d'une commande lors
de son exécution. <prgn>renice</prgn> (paquet <package>bsdutils</package>) ou
<prgn>top</prgn> peuvent changer la valeur <em>nice</em> d'un processus. Le
processus le plus lent (priorité la plus basse) aura une valeur de 19&nbsp;;
les valeurs négatives sont <em>not-nice</em> (NdT&nbsp;: litt. pas gentilles),
une valeur de -20 étant donnée au processus le plus rapide (priorité la plus
haute). Seul le superutilisateur peut donner des valeurs <em>nice</em>
négatives.
<example>
# nice  -19 <var>top</var>                                         # très gentil
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # très rapide
</example>
Parfois, une valeur extrême de <em>nice</em> fait plus de mal que de bien au
système. Utilisez cette commande en faisant attention.
</sect1>

<sect1 id="cronjob">Programmer des activités (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Utilisez <prgn>cron</prgn> et <prgn>at</prgn> pour programmer des tâches sous
Linux. Consultez <manref name="at" section="1">, <manref name="crontab"
section="5">, <manref name="crontab" section="8">.
<p>
Exécutez la commande <tt>crontab -e</tt> pour créer ou éditer un fichier
crontab pour programmer des événements régulièrement. Exemple de fichier
crontab&nbsp;:
<example>
# utilise /bin/sh pour exécuter les commandes, quoi que dise /etc/passwd
SHELL=/bin/sh
# envoie un courrier électronique à Paul contenant tous les résultats,
# quelle que soit la personne à qui appartienne la crontab
MAILTO=paul
# Minute Heure JourDuMois Mois JourDeLaSemaine commande
# est exécuté à 00:05 chaque jour
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# est exécuté à 14:15 le 1e de chaque mois -- le résultat est envoyé à Paul
# par courrier électronique
15 14 1  * *   $HOME/bin/monthly
# est exécuté à 22:00 chaque jour de la semaine(1-5), ennuie Joe.
# &percnt; pour une nouvelle ligne, dernier &percnt; pour cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Where are your kids?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# est exécuté à 03:40 le premier lundi de chaque mois
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
Exécutez la commande <prgn>at</prgn> pour programmer une tâche unique :
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1 id="screen">Changement de console avec <prgn>screen</prgn>
<p>
Le programme <prgn>screen</prgn> permet d'exécuter plusieurs terminaux
virtuels avec un shell intéractif sur chacun, sur un unique terminal physique
ou émulateur de terminal. Même si vous utilisez les consoles virtuelles de
Linux ou plusieurs fenêtres <prgn>xterm</prgn>, explorer <prgn>screen</prgn>
vaut le coup, de par son nombre de possibilités, qui incluent
<list compact>
<item>un historique,
<item>le copier/coller,
<item>l'enregistrement de l'affichage,
<item>une entrée de digraphe, et
<item>la possibilité de <strong>détacher</strong> une session
<prgn>screen</prgn> du terminal pour la réattacher plus tard.
</list>

<sect2>Scénario d'accès distant
<p>
Si vous vous connectez fréquemment sur une machine Linux depuis un terminal
distant ou en utilisant un terminal VT100, <prgn>screen</prgn> vous facilitera
la vie avec la possibilité de <strong>détacher</strong> une session.
<p>
<enumlist compact>
<item>Supposez que vous êtes connectés via une connexion téléphonique, et que
vous exécutez une session <prgn>screen</prgn> complexe avec des éditeurs et des
programmes ouverts dans plusieurs fenêtres.
<item>Vous avez alors besoin de quitter votre terminal, mais vous ne voulez pas
perdre votre travail en raccrochant.
<item>Tapez simplement <tt>^A d</tt> pour détacher la session, puis
déconnectez-vous. (Ou encore plus rapide, tapez <tt>^A DD</tt> pour que
<prgn>screen</prgn> détache la session et déconnecte lui-même.)
<item>Quand vous vous connectez de nouveau, entrez la commande <tt>screen
-R</tt>, et <prgn>screen</prgn> va automatiquement réattacher toutes les
fenêtres que vous aviez ouvertes.
</enumlist>

<sect2>Commandes typiques de <prgn>screen</prgn>
<p>
Une fois que <prgn>screen</prgn> est démarré, toutes les entrées au clavier
sont envoyées à la fenêtre excepté la combinaison de touches de commande, par
défaut <tt>^A</tt>. Toutes les commandes <prgn>screen</prgn> sont entrées en
tapant <tt>^A</tt> et une touche unique [ainsi que des paramètres]. Commandes
utiles&nbsp;:
<example>
^A ?     affiche un écran d'aide (affiche les combinaisons de touches)
^A c     crée une nouvelle fenêtre et l'affiche
^A n     va à la fenêtre suivante
^A p     va à la fenêtre précédente
^A <var>0</var>     va à la fenêtre numéro <var>0</var>
^A w     affiche la liste des fenêtres
^A a     envoie Ctrl-A à la fenêtre courante
^A h     enregistre une copie de la fenêtre courante dans un fichier
^A H     commence/termine l'enregistrement de la fenêtre courante dans
         un fichier
^A ^X    verrouille le terminal (protection par mot de passe)
^A d     détache la session screen du terminal
^A DD    détache la session screen du terminal et déconnecte
</example>
Ceci est seulement un petit aperçu des possibilités de <prgn>screen</prgn>.
S'il y a quelquechose que vous souhaiteriez que <prgn>screen</prgn> fasse pour
vous, il y a des chances qu'il puisse ! Consultez <manref name="screen" section="1"> pour plus de détails.

<sect2>Backspace et/ou Ctrl-H dans une session <prgn>screen</prgn>
<p>
Si la touche backspace et/ou Ctrl-H ne marchent plus correctement lorsque vous
exécutez <prgn>screen</prgn>, éditez <file>/etc/screenrc</file>, trouvez la
ligne
<example compact>
bindkey -k kb stuff "\177"
</example>
et commentez-la (càd, ajoutez «&nbsp;#&nbsp;» devant).

</sect1>

<sect1 id="net-test">Bases pour tester un réseau
<p>
Installez les paquets
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (noyau 2.2)
<package>iptables</package> (noyau 2.4), et
<package>net-tools</package>, puis&nbsp;:
<example>
$ ping <var>yahoo.com</var>            # teste la connexion Internet
$ traceroute <var>yahoo.com</var>      # trace les paquets IP
$ ifconfig                  # affiche la configuration de la machine
$ route -n                  # affiche la configuration de routage
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # affiche les enregistrements DNS de <var>host.dom</var>
      # sur <var>dns-server.com</var> pour un enregistrement <var>{a|mx|any}</var>
$ ichains  -L -n |less      # affiche le filtre de paquets (noyau 2.2)
$ iptables -L -n |less      # affiche le filtre de paquets (noyau 2.4)
$ netstat -a                # recherche tous les ports ouverts
$ netstat -l --inet         # recherche tous les ports en écoute
$ netstat -ln --tcp         # recherche tous les ports tcp en écoute
                              (affichage numérique)
</example>
</sect1>

<sect1 id="flush-mail">Vider les courriers électroniques de la file locale
<p>
Pour vider la file locale des courriers électroniques présents&nbsp;:
<example>
# exim -q    # vide les courriers électroniques en attente
# exim -qf   # vide tous les courriers électroniques
# exim -qff  # vide même les courriers électroniques gelés
</example>
<tt>-qff</tt> est peut-être une meilleure option pour le script
<file>/etc/ppp/ip-up.d/exim</file>.
Pour Sarge, remplacez <prgn>exim</prgn> par <prgn>exim4</prgn>.
</sect1>

<sect1 id="remove-mail">Supprimer les courriers électroniques gelés de la file locale
<p>
Pour supprimer les courriers électroniques gelés de la file locale en
renvoyant un message d'erreur&nbsp;:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
Pour Sarge, remplacez <prgn>exim</prgn> par <prgn>exim4</prgn>.
</sect1>

<sect1>Redélivrer le contenu de <file>mbox</file>
<p>
Vous devez redélivrer manuellement les courriels dans vos boîtes triées de
votre répertoire personnel depuis le fichier
<file>/var/mail/<var>username</var></file> si votre répertoire personnel est
devenu plein ou si <prgn>procmail</prgn> a planté. Après avoir fait de
l'espace dans le répertoire personnel, lancez&nbsp;:
<example>
# /etc/init.d/exim stop
# formail -s procmail &lt;/var/mail/<var>username</var>
# /etc/init.d/exim start
</example>
Pour Sarge, remplacez <prgn>exim</prgn> par <prgn>exim4</prgn>.
</sect1>

<sect1>Supprimer le contenu d'un fichier
<p>
Pour supprimer le contenu d'un fichier, par exemple un fichier de journal,
n'utilisez pas <tt>rm</tt> pour effacer le fichier et créer ensuite un fichier
vide, parce que le fichier peut toujours être accédé entre les commandes. Ce
qui suit est une façon sûre de supprimer le contenu d'un fichier.
<example>
$ :&gt;<var>file-to-be-cleared</var>
</example>
</sect1>

<sect1 id="dummyfile">Fichiers fantômes
<p>
Les commandes suivantes créent des fichiers fantômes ou vides.
<example>
$ dd if=/dev/zero    of=<var>filename</var> bs=1k count=5 # 5Ko sans contenu
$ dd if=/dev/urandom of=<var>filename</var> bs=1M count=7 # 7Mo de contenu aléatoire
$ touch <var>filename</var> # crée un fichier de taille 0
                   (si le fichier existe, met à jour mtime)
</example>
Par exemple, les commandes suivantes exécutées depuis le shell de la disquette
de dméarrage &debian; efface tout le contenu du disque dur
<file>/dev/hda</file>.
<example>
# dd if=/dev/urandom of=/dev/hda ; dd if=/dev/zero of=/dev/hda
</example>

</sect1>

<sect1 id="chroot"><prgn>chroot</prgn>
<!-- updated using the idea from Colin Walters walters@debian.org -->
<p>
Le programme <prgn>chroot</prgn>, <manref name="chroot" section="8">, nous
permet de lancer plusieurs environnements GNU/Linux simultanément sur un seul
système sans redémarrer.
<p>
On peut aussi lancer un programme demandant des ressources comme
<prgn>apt-get</prgn> ou <prgn>dselect</prgn> dans le chroot d'une machine
rapide. On monte alors par NFS le système de fichiers d'une machine auxiliaire
lente sur la machine rapide, en lecture/écriture, le point de montage étant le
répertoire chroot.

<sect2 id="chroot-debian">Exécuter plusieurs versions de &debian; avec
<prgn>chroot</prgn>
<p>
Un environnment chroot &debian; peut aisément être créé par la commande
<prgn>debootstrap</prgn> de Woody. Par exemple, pour créer un chroot Sid sur
<var>/sid-root</var> avec une connexion Internet rapide&nbsp;:
<example>
main # cd / ; mkdir <var>/sid-root</var>
main # debootstrap sid <var>/sid-root</var> <var>http://ftp.debian.org/debian/</var>
... regardez le système se télécharger
main # echo "proc-sid <var>/sid-root</var>/proc proc none 0 0" >> /etc/fstab
main # mount proc-sid <var>/sid-root</var>/proc -t proc
main # cp /etc/hosts <var>/sid-root</var>/etc/hosts
main # chroot <var>/sid-root</var> /bin/bash
chroot # cd /dev; /sbin/MAKEDEV generic ; cd -
chroot # apt-setup # set-up /etc/apt/sources.list
chroot # vi /etc/apt/sources.list # mettre la source sur unstable
chroot # dselect  # ou aptitude, installez mc et vim :-)
</example>
<p>
A ce point, vous devriez avoir un systÃ¨me &debian; complètement fonctionnel,
avec lequel vous pouvez jouer sans avoir peur de toucher votre installation
&debian; principale.
<p>
Cette astuce avec <prgn>debootstrap</prgn> peut aussi être utilisée pour
installer &debian; sur un système dans utiliser le disque d'installation
&debian; mais celui d'une autre distribution GNU/Linux. Voir <url
id="&setup-chroot;">.

<sect2 id="chroot-console">Configurer login pour <prgn>chroot</prgn>
<p>
Taper <tt>chroot <var>/sid-root</var> /bin/bash</tt> est facile, mais cela
garde toutes les variables d'environnement, ce que vous pouvez ne pas vouloir,
et apporte d'autres problèmes. Une meilleure approche est d'exécuter un autre
processus login sur un terminal virtuel différent où vous pouvez vous
connecter au chroot directement.

<p>
Puisque, sur les systèmes &debian; par défaut, les consoles Linux sont de
<tt>tty1</tt> à <tt>tty6</tt> et X Window System sur <tt>tty7</tt>,
configurons une console chroot sur <tt>tty8</tt>. Après avoir créé un système
chroot comme décrit dans <ref id="chroot-debian">, exécutez ce qui suit en
root sur le système principal&nbsp;:
<example>
main # echo "8:23:respawn:/usr/sbin/chroot <var>/sid-root</var> "\
       "/sbin/getty 38400 tty8"  >> /etc/inittab
main # init q    # reload init
</example>

<sect2 id="chroot-x">Configurer X pour <prgn>chroot</prgn>
<p>
Vous voulez exécuter les dernières version de X et GNOME en toute sécurité
dans votre chroot&nbsp;? C'est possible&nbsp;! L'exemple suivant permet
d'exécuter GDM sur le terminal virtuel <tt>vt9</tt>.
<p>
D'abord, installez un système chroot comme décrit dans <ref
id="chroot-debian">. Avec le root du système principal, copiez les fichiers de
configration importants vers le système chroot.
<example>
main # cp /etc/X11/XF86Config-4 <var>/sid-root</var>/etc/X11/XF86Config-4
main # chroot <var>/sid-root</var> # ou utilisez la console chroot
chroot # cd /dev; /sbin/MAKEDEV generic ; cd -
chroot # apt-get install gdm gnome x-window-system
chroot # vi /etc/gdm/gdm.conf # faites s/vt7/vt9 dans la section [servers]
chroot # /etc/init.d/gdm start
</example>
Ici, <file>/etc/gdm/gdm.conf</file> a été édité pour que la console virtuelle
de lancement soit <tt>vt9</tt> au lieu de <tt>vt7</tt>. 
<p>
Maintenant vous pouvez facilement passer de l'environnement X du chroot à
celui du système principal simplement en changeant de terminal virtuel, par
exemple en utilisant Ctrl-Alt-F7 et Ctrl-Alt-F9. Amusez-vous bien&nbsp;!
<p>
[FIXME] Ajouter un commentaire et un lien vers le script <prgn>gdm</prgn> du
chroot.

<sect2 id="chroot-dist">Exécuter d'autres distributions avec
<prgn>chroot</prgn>
<p>
Un environnement chroot avec une autre distribution peut facilement être créé.
Vous installez un système sur une partition séparée en utilisant son
installateur. Si sa partition racine est
<file><var>/dev/hda9</var></file>&nbsp;:
<example>
main # cd / ; mkdir <var>/other-dist</var>
main # mount -t ext3 <var>/dev/hda9</var> <var>/other-dist</var>
main # chroot <var>/other-dist</var> /bin/bash
</example>
La suite est similaire à <ref id="chroot-debian">, <ref id="chroot-console">,
et <ref id="chroot-x">.

<sect2 id="chroot-build">Compiler un paquet avec <prgn>chroot</prgn>
<p>
Il existe un paquet chroot plus spécialisé, <package>pbuilder</package>, qui
construit un système chroot et compile un paquet dans le chroot. C'est un
système idéal pour vérifier que les dépendances de compilation d'un paquet
sont correctes, et pour être sûr que des dépendances non nécessaires ou
fausses n'existent dans le paquet résultant.
</sect1>

<sect1>Comment vérifier les liens durs
<p>
Vous pouvez vérifier si deux fichiers sont le même avec deux liens durs
avec&nbsp;:
<example>
$ ls -li <var>file1</var> <var>file2</var>
</example>

<sect1>Monter une image de disque dur
<p>
Si <file><var>file.img</var></file> contient l'image d'un disque dur et que le
disque dur original avait une configuration <var>xxxx</var> = (octets/secteur)
* (secteurs/cylindres), les commandes suivantes vont le monter sur
<file>/mnt</file>&nbsp;:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
Notez que la plupart des disques durs ont 512 octets/secteur.

<sect1 id="smbmount">Samba
<p>
Bases pour récupérer des fichiers depuis Windows&nbsp;:
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # monte un répertoire Windows sous Linux
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # list the shares on a computer
</example>
<p>
Les voisins de Samba peuvent être trouvés depuis Linux&nbsp;:
<example>
# smbclient -N -L <var>ip_address_of_your_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>


<sect1>Utilitaires pour les systèmes de fichiers étrangers
<p>
Un grand nombre de systèmes de fichiers est supporté par le noyau Linux, et
peuvent être utilisés simplement en montant les périphériques les contenant.
Pour certains systèmes de fichiers, il existe aussi des outils spécifiques
permettant de les utiliser sans les monter. Ces opérations sont accomplies par
des programmes en espace utilisateur, et donc le support du système de
fichiers par le noyau n'est pas nécessaire.
<list compact>
<item><package>mtools</package>&nbsp;: pour le système de fichiers MSDOS
(MS-DOS, Windows)
<item><package>cpmtools</package>&nbsp;: pour le système de fichiers CP/M
<item><package>hfsutils</package>&nbsp;: pour le système de fichiers HFS
(anciens Macintosh)
<item><package>hfsplus</package>&nbsp;: pour le système de fichiers HFS+
(Macintosh modernes)
</list>
Pour créer et vérifier un système de fichiers FAT MSDOS, le paquet
<package>dosfstools</package> est utile.
</sect1>

</sect>

<sect id="oops">Fautes courantes à éviter
<p>
Voici quelques exemples d'actions dangereuses. Les aspects négatifs seront
amplifiés si vous utilisez le compte <tt>root</tt>.


<sect1 id="rm-rf-star"><tt>rm -rf .*</tt>
<p>
<!--
I know using quotes here are irregular but it is hard to read without it.
-->
Dans <tt>rm -rf .*</tt>, "<tt>.*</tt>" est remplacé et contient "<tt>.</tt>"
and "<tt>..</tt>", ce qui, si vous en avez les privilèges, supprime aussi tous
les répertoires <strong>à côté</strong> du répertoire courant.
<p>
<list compact>
<item>"<tt>rm -rf .</tt>"&nbsp;: supprime tout sous le répertoire courant, le
répertoire y compris.
<item>"<tt>rm -rf *</tt>"&nbsp;: supprime tous les fichiers et répertoires ne
commençant pas par un point sous le répertoire courant.
<item>"<tt>rm -rf .[^.]*</tt>"&nbsp;: supprime tous les fichiers et
répertoires commençant par un point sous le répertoire courant.
<item>"<tt>rm -rf .*</tt>"&nbsp;: supprime tout sous le répertoire parent et
le répertoire parent lui-même.
</list>

<sect1 id="rm-passwd"><tt>rm /etc/passwd</tt>
<p>
La perte de fichiers importants comme <file>/etc/passwd</file> par stupidité
est dur. Le système &debian; en effectue des sauvegardes régulières dans
<file>/var/backups/</file>. Lorsque vous restaurez ces fichiers, vous devez
manuellement configurer les permissions.
<example>
# cp /var/backups/passwd /etc/passwd
# chmod 644 /etc/passwd
</example>
Voir aussi <ref id="recover-status">.

</chapt>
