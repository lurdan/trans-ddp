<!-- CVS revision of this document "$Revision: 1.7 $"  -->
<!-- CVS revision of original english document "1.23"  -->
<chapt id="system">Notions fondamentales sur Debian
<![%FIXME[<p>===Proof reading: NONE ===]]>

<!-- 

Mereged from 4 SGML files in FAQ Feburuary 2002
  ftparchives.sgml, 
  pkg_basics.sgml, 
  pkgtools.sgml, 
  uptodate.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1
 sect1 moved to sect2

Commented out reference to arches, should rewrite it to reference to 
release manual/install manual soon.
 
Pieces imported from other parts of FAQ.
 Small section from customizing.sgml regarding init/runlevel is added.
 Small section from customizing.sgml regarding diverse is added.
 Small section from software.sgml regarding nonenglish is added.

Mereged from another SGML files in FAQ Feburuary 2002
  kernel.sgml

Then retitled under "Debian fundamentals" with 
 chapt moved to sect
 sect moved to sect1

Titles of sect/sect1 are changed to suits "Debian reference"

All minor edits I did left tracing information as comments.

Several sections were actually deleted since two consecutive -'s
made it impossible to comment out.

Also rewrote section to suite more for ptato and woody.
Unless slink is used, howmany people care dpkg-ftp :)

-->

<p>
Ce chapitre donne des informations sur les notions fondamentales de Debian
pour des non-développeurs. Pour des informations officielles, voir :
<list>
<item>Charte Debian
<item>Manuel du paquetage Debian (potato)
<item>Référence du développeur Debian
<item>Guide des nouveaux responsables Debian
</list>
listés dans la section <ref id="references">.

<p>
Si l'on recherche des explications basées sur des solutions et sans les
détails, se référer directement à <ref id="package"> ou aux chapitres
appropriés.
<p>
Ce chapitre consiste en une réorganisation de documents pris dans la FAQ
Debian, afin qu'un administrateur système Debian puisse débuter.

<!-- 
"FTP archives" is now changed as simple "archives" since it can be reached 
throgh HTTP and other method
-->

<sect id="ftparchives">Les archives Debian

<sect1 id="dirtree">Structure de répertoires

<p>Les logiciels paquetés pour &debian; sont disponibles dans un des nombreux
arbres de répertoires sur chaque <url id="&mirror-site;" name="site mirroir
Debian"> accessible par FTP ou HTTP.

<p>Les répertoires suivants sont sur chaque mirroir Debian sous le répertoire
<tt>debian</tt> : 
<taglist>
  <tag><em>/dists/</em>:
    <item>Ce répertoire contient les "distributions", et est utilisé pour
accéder aux paquets actuellement disponibles dans les versions et pre-versions
de Debian. Certains vieux paquets et fichiers <tt>Packages.gz</tt> sont
toujours là.
  <tag><em>/pool/</em>:
    <item>Nouvelle place de tous les paquets des versions et pre-versions de
Debian.
  <tag><em>/tools/</em>:
    <item>Utilitaires DOS pour créer des disquettes de démarrage, partitionner
un disque dur, compresser/décompresser des fichiers, et démarrer Linux.
  <tag><em>/doc/</em>:
    <item>La documentation de base de Debian, tel que la FAQ, les instructions
pour faire un rapport de bogues, etc.
  <tag><em>/indices/</em>:
    <item>Le fichier <file>Maintainers</file> et les fichiers <file>override</file>
  <tag><em>/project/</em>:
    <item>Principalement du matériel pour les développeurs seulement, comme :
    <taglist>
      <tag><em>project/experimental/</em>:
        <item>Ce répertoire contient des paquets et des outils qui sont en
développement, et sont encore en état de test alpha. Les utilisateurs ne
devraient pas utiliser des paquets de ce répertoire parce qu'ils peuvent être
dangereux même pour des utilisateurs expérimentés.
      <tag><em>project/orphaned/</em>:
        <item>Paquets qui ont été abandonnés par leur ancien mainteneur et ont
été retirés de la distribution.
    </taglist>
</taglist>

<sect1 id="dists">Distributions Debian

<p>Normalement il y a trois distributions Debian dans le répertoire
<tt>dists</tt>. Leurs noms sont la distribution "stable", la distribution
"testing" et la distribution "unstable". Quelquefois il y a aussi la
distribution "frozen" (see <ref id="frozen">). Chaque distribution est définie
par un lien symbolique vers le répertoire réel, utilisant un nom de code et
situé dans le répertoire <tt>dists</tt>.

<sect1 id="stable">La distribution <tt>stable</tt>

<p>La distribution "stable" est dans le répertoire <tt>stable</tt> :
<list>
  <item>stable/main/ :
  Ce répertoire contient les paquets constituant la version la plus récente du
système &debian;.

  <p>Ces paquets sont aussi conformes aux <url name="Principes du logiciel
libre selon Debian" id="&social-contract;#guidelines">, et sont tous
utilisables et redistribuables librement.

  <item>stable/non-free/ :
  Ce répertoire contient des paquets dont la distribution est restreinte et
nécessite que les distributeurs prennent soigneusement en compte les exigences
spécifiées par la licence.

  <p>Par exemple, certains paquets ont une licence qui interdit la
distribution commerciale. D'autres peuvent être redistribués mais sont en fait
des partagiciels et non des logiciels libres. Les licences de chacun de ces
paquets doivent être étudiées, et dans certains cas négociées, avant que les
paquets soient inclus dans une redistribution (par exemple, sur un CD-ROM).

  <item>stable/contrib/ :
  Ce répertoire contient des paquets qui sont conformes aux principes du
logiciel libre selon Debian  et <em>distribuables librement</em>, mais
dépendent d'un paquet qui <em>n'est pas</em> distribuable librement et n'est
ainsi disponible que dans la section non-free.
</list>
<p>L'état courant de la distribution <tt>stable</tt> est accessible sur
la page web <url id="&stable-problems;" name="Les problèmes de 'stable'">.

<sect1 id="testing">La distribution <tt>testing</tt>

<p>Les paquets sont enregistrés dans le répertoire <tt>testing</tt> après
avoir subi une certaine quantité de tests dans <tt>unstable</tt>. Les nouveaux
paquets sont situés dans le répertoire <tt>pool</tt> <ref id="pools">. Les
sous-répertoires <tt>main</tt>, <tt>contrib</tt> et <tt>non-free</tt> sont
aussi présents dans <tt>testing</tt>, séparés par les mêmes critères que pour
<tt>stable</tt>.

<p>Les paquets doivent être synchronisés pour toutes les architectures où ils
sont compilés et ne doivent pas avoir de dépendances qui les rendent
ininstallables ; ils doivent aussi avoir moins de bogues critiques pour une
sortie de version que ceux de <tt>unstable</tt>. De cette façon, on espère que
<tt>testing</tt> est toujours prête à être candidate à une sortie. Plus de
détails sur le méchanisme sont disponibles à <url id="&testing-notes;">.

<p>L'état courant de la distribution <tt>testing</tt> est accessible
sur les sites suivants (en Anglais) :
<list>
<item><url id="&update-excuses;" 
         name="update excuses">
<item><url id="&testing-problems;" 
         name="testing problems">
<item><url id="&release-critical;" 
         name="Release-critical bugs">
<item><url id="&qa-base-bugs;" 
         name="Base system bugs">
<item><url id="&qa-standard-bugs;" 
         name="bugs in standard and task packages">
<item><url id="&qa-bugs;" 
         name="other bugs and bug squashing party notes">
</list>

<sect1 id="unstable">La distribution <tt>unstable</tt>

<p>Les paquets sont enregistrés dans le répertoire <tt>unstable</tt> après
avoir été téléchargées dans l'archive Debian et y restent jusqu'à ce qu'ils
soient déplacés dans <tt>testing</tt> après quelque temps. Les nouveaux
paquets sont situés dans le répertoire <tt>pool</tt> <ref id="pools">. Les
sous-répertoires <tt>main</tt>, <tt>contrib</tt> et <tt>non-free</tt> sont
aussi présents dans <tt>unstable</tt>, et ont les mêmes fonctions que dans
<tt>stable</tt>.

<p>La distribution <tt>unstable</tt> contient une image du système en
développement le plus récent. Les utilisateurs sont encouragés à utiliser et
tester ces paquets, mais sont prévenus de leur état. L'avantage à utiliser
<tt>unstable</tt> est que vous êtes toujours à jour avec la dernière version du
projet &debian;&mdash;mais si ça casse, vous en découvrez les désavantages :-)

<p>L'état courant de la distribution <tt>unstable</tt> est accessible à la
page web : <url id="&unstable-problems;" name="Problèmes de unstable">.

<!-- Above was enough
<sect1 id="sid">The "sid" distribution

<p><em>sid</em> or <em>unstable</em> is the place where most of the packages
are initially uploaded. It will never be released directly, because packages
which are to be released will first have to be included in <em>testing</em>,
in order to be released in <em>stable</em> later on. sid contains packages
for both released and unreleased architectures.

<p>The name "sid" also comes from the "Toy Story" animated motion picture:
Sid was the boy next door who destroyed toys :-)
-->

<sect1 id="frozen">La distribution <tt>frozen</tt>

<p>Lorsque la distribution <tt>testing</tt> est mûre, elle est gelée (NdT :
frozen en Anglais), c'est-à-dire que l'on n'accepte plus de nouveau code,
seulement des corrections de bogues, si nécessaire. De plus, un nouvel arbre
testing est créé dans le répertoire <tt>dists</tt>, avec un nouveau nom de
code. La distribution frozen subit quelques mois de test, avec par
intermittence des mises à jour et des gelées complètes, ce qu'on appelle des
`cycles de test'.

<p>On garde une trace des bogues de la distribution frozen qui peuvent retarder
la sortie d'un paquet ou qui peuvent retarder la sortie de la distribution
complète. Lorsque le nombre de bogues descend en dessous des valeurs maximum
acceptables, la distribution frozen devient stable, est sortie, et la
distribution stable précédente devient obsolète (et est déplacée dans les
archives).

<sect1 id="codenames">Les noms de code de la distribution Debian

<p>Les noms des répertoires physiques dans le répertoire <tt>dists</tt>, comme
<tt>potato</tt> et <tt>woody</tt>, sont juste des noms de code. Lorsqu'une
distribution Debian est en développement, elle n'a pas de numéro de version
mais un nom de code. Le but de ces noms de code est de faciliter le travail
des mirroirs de la distribution Debian (si un répertoire réel comme
<tt>unstable</tt> changeait soudainement son nom en <tt>stable</tt>, beaucoup
de données seraient à télécharger de nouveau).

<!-- XXX update for new distros -->
<p>Actuellement, <tt>stable</tt> est un lien symbolique vers <tt>potato</tt>
(càd &debian; &release;) et <tt>testing</tt> est un lien symbolique vers
<tt>woody</tt>. Cela signifie que <tt>potato</tt> est l'actuelle distribution
stable et <tt>woody</tt> l'actuelle distribution testing.

<p><tt>unstable</tt> est un lien symbolique permanent vers <tt>sid</tt>, car
<tt>sid</tt> est toujours la distribution unstable.

<sect1 id="oldcodenames">Noms de code utilisés dans le passé

<p>Les autres noms de code qui ont déjà été utilisés sont : <tt>buzz</tt> pour
la version 1.1, <tt>rex</tt> pour la version 1.2, <tt>bo</tt> pour les
versions 1.3.x, <tt>hamm</tt> pour la version 2.0, et <tt>slink</tt> pour la
version 2.1.

<p>Tandis que les distributions les plus récentes sont gardées sous le
répertoire <tt>debian</tt> de chaque mirroir Debian, les archives des
anciennes distributions Debian comme <tt>slink</tt> sont gardées dans le
répertoire <tt>debian-archive</tt> sur chaque mirroir Debian.

<sect1 id="sourceforcodenames">Source d'inspiration pour les noms de code

<p>Jusqu'ici, les noms de code viennent des caractères du film "Toy Story" par
Pixar.
<list>
  <item><em>buzz</em> (Buzz Lightyear) est le cosmonaute,
  <item><em>rex</em> est le tyranosaure,
  <item><em>bo</em> (Bo Peep) est la fille qui s'occupe du mouton,
  <item><em>hamm</em> est la tirelire en forme de cochon,
  <item><em>slink</em> (Slinky Dog) est le chien,
  <item><em>potato</em> est, bien sûr, Mr. Potato
  <item><em>woody</em> est le cowboy,
  <item><em>sid</em> est le garçon d'à côté qui détruit les jouets.
</list>
<!--
  more info in http://www.pixar.com/feature/toystory/toystory.html 
  or better yet http://us.imdb.com/M/title-exact?Toy%20Story%20(1995)
  or actually:
    http://us.imdb.com/Title?0114709 for TS1
    http://us.imdb.com/Title?0120363 for TS2
  we shouldn't put the links in, Pixar needs no additional propaganda
-->
<!--
  characters not used from Toy Story (yet):
    - Sarge and The Green Plastic Army Men
    - Andy (the kid)
    - Etch (Etch-a-Sketch) (the blackboard)
    - Snake
    - Robot
    - Scud (Sid's dog)
  and additional characters from Toy Story 2, also not yet used:
    - Jessie (the Yodelling Cowgirl)
    - Zurg (the Emperor)
    - Wheezy (the penguin)
    - Hannah (owner of Jessie)
    - Stinky Pete the Prospector (the old fat guy)
    - Mrs. Davis (Andy's Mom)
    - Barbie
-->

<sect1 id="pools">Le répertoire <tt>pool</tt>

<p>Historiquement, les paquets étaient gardés dans le sous-répertoire
<tt>dists</tt> correspondant à la distribution qui les contenait. Il apparut
que cela posait certains problèmes, tels que la grande consommation de bande
passante sur les mirroirs lorsque des changements majeurs étaient effectués.

<p>Les paquets sont maintenant gardés dans un large `bassin' (NdT : pool en
Anglais), structuré selon le nom du paquet source. Pour rendre cela gérable,
le bassin est subdivisé par section (<tt>main</tt>, <tt>contrib</tt> et
<tt>non-free</tt>) et par la première lettre du nom du paquet source. Ces
répertoires contiennent plusieurs fichiers : les paquets binaires pour chaque
architecture, et les paquets source à partir desquels les paquets binaires ont
été générés.

<p>Vous pouvez trouver où se trouve chaque paquet en lançant une commande
comme <tt>apt-cache showsrc <var>mypackagename</var></tt> et en lisant la
ligne `Directory:'. Par exemple, les paquets <package>apache</package> sont
dans <file>pool/main/a/apache/</file>. Il y a tellement de paquets
<tt>lib*</tt> qu'ils sont traités différemment : par exemple, les paquets
<package>libpaper</package> sont dans <file>pool/main/libp/libpaper/</file>.

<p>Les répertoires <tt>dists</tt> sont toujours utilisés pour les fichiers
d'index utilisés par des logiciels comme <tt>apt</tt>. De plus, les anciennes
distributions n'ont pas été converties pour utiliser les bassins donc vous
verrez des chemins contenant des distributions comme potato ou woody dans le
champ d'en-tête Filename.

<p>Normalement, vous n'avez pas à vous occuper de cela, puisque le nouvel
<tt>apt</tt> et probalement l'ancien <tt>dpkg-ftp</tt> (voir <ref
id="howtocurrent">) vont gérer cela de façon transparente. Si vous souhaitez
plus d'information, consultez <url id="&pool-faq;" name="Debian Package Pools
FAQ"> (en Anglais).

<!-- bumped up from sect2 to sect1 -->
<sect1 id="sid-history">Notes historiques sur <tt>sid</tt>

<p>Lorsque la <tt>sid</tt> d'aujourd'hui n'existait pas, l'organisation de
l'archive Debian avait un défaut majeur : on supposait que lorsqu'une
architecture était créée dans la distribution <tt>unstable</tt> courante, elle
sortirait lorsque cette distribution deviendrait la nouvelle <tt>stable</tt>.
Ce n'était pas le cas pour beaucoup d'architectures, ce qui entrainait que ces
répertoires devaient être déplacés lors d'une sortie. Cela n'était pas pratique
parce que cela consommerait beaucoup de bande passante.

<p>Les administrateurs de l'archive contournèrent le problème pendant
plusieurs années en plaçant les binaires des architectures non sorties dans un
répertoire spécial nommé <tt>sid</tt>.  Lors de la sortie de ces
architectures, un lien était créé entre la <tt>stable</tt> courante et
<tt>sid</tt>, et à partir de là elles étaient créées dans l'arbre
<tt>unstable</tt> de façon normale. Cette disposition était quelque peu
troublante pour les utilisateurs.

<p>Avec l'arrivée des bassins de paquets (voir <ref id="pools">) pendant le
développement de la distribution <tt>woody</tt>, les paquets binaires ont
commencé à être stockés à un emplacement standard dans le bassin, quelle que
soit la distribution, de façon à ce que sortir une distribution ne cause plus
de grande consomation de bande passante sur les mirroirs (il y a, cependant,
beaucoup de consommation de bande passante graduellement pendant le
développement).

<sect1 id="incoming">Paquets téléchargés dans <file>incoming</file>
<p>
Les paquets téléchargés sont d'abord placés dans <url id="&incoming;"> avant
que l'on ne vérifie s'il vienne bien d'un développeur Debian. Une fois la
vérification effectuée, ils sont déplacés de <tt>incoming</tt> vers
<tt>unstable</tt>.
<p>
En cas d'urgence, vous pouvez vouloir installer des paquets de
<tt>incoming</tt> avant qu'ils n'atteignent <tt>unstable</tt>. Vous pouvez les
récupérer manuellement, vérifier la signature GPG et les MD5sums donnés dans
les fichiers <file>.changes</file> et <file>.dsc</file>, et ensuite les
installer.
</sect1>

<sect1 id="archsections">Sections architectures
<!--
What are all those directories inside <tt>dists/stable/main</tt>?
Simplified this !!!
-->

<p>Dans chacun des arbres de répertoires majeurs
(<file>dists/stable/main</file>, <file>dists/stable/non-free</file>,
<file>dists/unstable/main/</file>, etc.), les paquets binaires résident dans
des sous-répertoires dont le nom indique l'architecture pour laquelle ils ont
été compilés.

<list>
  <item>binary-all/, pour les paquets indépendants de l'architecture
    Cela inclut, par exemple, des scripts Perl, ou de la documentation pure.
  <item>binary-.../, pour les paquets qui s'exécutent sur une plateforme
particulière.
  <!-- Yes I simplified this -->
</list>

<p>Veuillez noter que les paquets binaires pour <tt>testing</tt> et
<tt>unstable</tt> ne résident plus dans ces répertoires, mais dans le
répertoire de haut niveau <tt>pool</tt>. Les fichiers d'index
(<file>Packages</file> et <file>Packages.gz</file>) ont été gardés, cependant,
pour une compatibilité arrière.

<p>Pour les architectures binaires supportées, consultez les Notes de version
de chaque distribution. Elles sont disponibles aux adresses suivantes : 
<url id="&stable-release;" name="liens vers les notes de version de stable"> et
<url id="&testing-release;" name="liens vers les notes de version de testing">.

<!-- Removed, above release note shall be enough.
<p>See <ref id="arches"> for more information.
-->

<sect1 id="source">Le code source

<p>Le code source est inclut pour tout le système Debian. De plus, les termes
de la licence de la plupart des logiciels du système <em>requièrent</em> que
le code source soit distribué avec le programme, ou qu'une offre permettant
d'obtenir le code source accompagne le programme.

<p>Normalement, le code source est distribué dans les répertoires
<tt>source</tt>, qui sont parallèles aux répertoires contenant les binaires
spécifiques à une architecture, ou plus récemment dans le répertoire
<tt>pool</tt> (voir <ref id="pools">). Pour récupérer le code source sans
avoir à être familier avec la structure de l'archive Debian, essayez une
commande comme <tt>apt-get source
<var>mypackagename</var></tt>.

<p>Certains paquets, notamment <package>pine</package>, sont seulement
disponibles sous forme de paquet source, à cause de limitations de leur
licence. (Récemment, le paquet <package>pine-tracker</package> a été fourni
pour faciliter l'installation de Pine.) Les procédures décrites dans <ref
id="port"> et <ref
id="packaging"> permettent de construire un paquet manuellement.

<p>Le code source peut être ou ne pas être disponible pour les paquets dans
les répertoires <tt>contrib</tt> et <tt>non-free</tt>, qui ne font pas
formellement partie du système Debian.

<sect id="pkg_basics">Debian Package Management System

<sect1 id="package-basics">Overview of Debian packages

<p>Packages generally contain all of the files necessary to implement
a set of related commands or features.  There are two types of Debian
packages:
<list>
  <item><em>Binary packages</em>, which contain executables, configuration
  files, man/info pages, copyright information, and other documentation.
  These packages are distributed in a Debian-specific archive format
  (see <ref id="deb-format">); they are usually distinguished by having
  a '.deb' file extension. Binary packages can be unpacked using the Debian
  utility <tt>dpkg</tt>; details are given in its manual page.
  
  <item><em>Source packages</em>, which consist of a <tt>.dsc</tt> file
  describing the source package (including the names of the following
  files), a <tt>.orig.tar.gz</tt> file that contains the original
  unmodified source in gzip-compressed tar format and usually a
  <tt>.diff.gz</tt> file that contains the Debian-specific changes to the
  original source.  The utility <tt>dpkg-source</tt> packs and unpacks
  Debian source archives; details are provided in its manual page.
</list>

<p>Installation of software by the package system uses "dependencies" which
are carefully designed by the package maintainers.  These dependencies are
documented in the <tt>control</tt> file associated with each package.
For example, the package containing the GNU C compiler (<package/gcc/)
"depends" on the package <package/binutils/ which includes the linker and
assembler. If a user attempts to install <package/gcc/ without having first
installed <package/binutils/, the package management system (dpkg) will send
an error message that it also needs <package/binutils/, and stop installing
<package/gcc/. (However, this facility can be overridden by the insistent
user, see <manref name="dpkg" section="8">.)  See more in <ref id="depends">
below.

<p>Debian's packaging tools can be used to:
<list>
  <item>manipulate and manage packages or parts of packages,
  <item>aid the user in the break-up of packages that must be transmitted
    through a limited-size medium such as floppy disks,
  <item>aid developers in the construction of package archives, and
  <item>aid users in the installation of packages which reside on a remote
    <!--FTP-->Debian archive site.
</list>

<sect1 id="deb-format">Debian <!--binary--> package format

<p>A Debian "package", or a Debian archive file, contains the executable
files, libraries, and documentation associated with a particular suite of
program or set of related programs.  Normally, a Debian archive file has
a filename that ends in <tt>.deb</tt>.

<p>The internals of this Debian binary packages format are described in
the <manref name="deb" section="5"> manual page. This internal format is
subject to change (between major releases of &debian;), therefore please
always use <manref name="dpkg-deb" section="8"> for manipulating <tt>.deb</tt>
files.

<!-- Below added by Osamu XXX Not sure but should be right -->

<p>At least up to "woody" distribution, any Debian archive files have been
able to be manipulated by standard Unix commands <prgn>ar</prgn> 
and <prgn>tar</prgn> even when dpkg commands are not available.

<sect1 id="pkgname">Naming convention of the Debian package file names
<!--
Why are Debian package file names so long? 
-->
<p>The Debian <!--binary--> package file names conform to the following convention:
&lt;foo&gt;_&lt;VersionNumber&gt;-&lt;DebianRevisionNumber&gt;.deb

<p>Note that <tt>foo</tt> is supposed to be the package name. As a check,
one can learn the package name associated with a particular Debian archive
file (.deb file) in one of these ways:
<list>
  <item>inspect the "Packages" file in the directory where it was stored
  at a Debian <!--FTP--> archive site.  This file contains a stanza describing
  each package; the first field in each stanza is the formal package name.
  
  <item>use the command <tt>dpkg --info foo_VVV-RRR.deb</tt> (where VVV and
  RRR are the version and revision of the package in question, respectively).
  This displays, among other things, the package name corresponding to the
  archive file being unpacked.
</list>

<p>The <tt>VVV</tt> component is the version number specified by the
upstream developer.  There are no standards in place here, so the version
number may have formats as different as "19990513" and "1.3.8pre1".

<p>The <tt>RRR</tt> component is the Debian revision number, and is
specified by the Debian developer (or an individual user if he chooses
to build the package himself).  This number corresponds to the revision
level of the Debian package, thus, a new revision level usually signifies
changes in the Debian Makefile (<tt>debian/rules</tt>), the Debian control
file (<tt>debian/control</tt>), the installation or removal scripts
(<tt>debian/p*</tt>), or in the configuration files used with the package.


<!-- This get too detailed
<sect1 id="controlfile">The Debian control file
-->

<sect1 id="conffile">Preservation of the local configuration
<!--
What is a Debian conffile
-->
<p>Preservation of user configurable files are enabled through Debian
conffiles mechanism.  User configuration files (usually placed in 
<tt>/etc</tt>) are specified in the <tt>conffiles</tt> within Debian package
system.  The package management system guarantees not to overwrite these 
files when the package is upgraded.
<!-- 
<p>Conffiles is a list of configuration files (usually placed in <tt>/etc</tt>)
that the package management system will not overwrite when the package is
upgraded. This ensures that local values for the contents of these files
will be preserved, and is a critical feature enabling the in-place upgrade
of packages on a running system.
-->
<p>To determine exactly which files are preserved during an upgrade, run:
  <example>dpkg --status package</example>
And look under "Conffiles:".

<p>
Specifics regarding the contents of a Debian conffiles file are provided
in the Debian Policy Manual, section 11.7, see <ref id="references">.

<sect1 id="maintscripts">Debian maintenance scripts
<!--
What is a Debian preinst, postinst, prerm, and postrm
  script?
-->
<p><!--These files--> 
Debian maintenance scripts
are executable scripts which are automatically run before
or after a package is installed. Along with a file named <tt>control</tt>,
all of these files are part of the "control" section of a Debian archive file.

<p>The individual files are:
<taglist>
<tag/preinst/
  <item>This script executes before that package will be unpacked from its
  Debian archive (".deb") file. Many 'preinst' scripts stop services for
  packages which are being upgraded until their installation or upgrade is
  completed (following the successful execution of the 'postinst' script).

<tag/postinst/
  <item>This script typically completes any required configuration of the
  package <tt>foo</tt> once <tt>foo</tt> has been unpacked from its Debian
  archive (".deb") file. Often, 'postinst' scripts ask the user for input,
  and/or warn the user that if he accepts default values, he should remember
  to go back and re-configure that package as the situation warrants.
  Many 'postinst' scripts then execute any commands necessary to start or
  restart a service once a new package has been installed or upgraded.

<tag/prerm/
  <item>This script typically stops any daemons which are associated with
  a package.  It is executed before the removal of files associated with
  the package.

<tag/postrm/
  <item>This script typically modifies links or other files associated with
  <tt>foo</tt>, and/or removes files created by the package. (Also see
  <ref id="virtual">.)
</taglist>

<p>Currently all of the control files can be found in directory
<tt>/var/lib/dpkg/info</tt>. The files relevant to package <tt>foo</tt>
begin with the name "foo" and have file extensions of "preinst", "postinst",
etc., as appropriate.  The file <tt>foo.list</tt> in that directory
lists all of the files that were installed with the package <tt>foo</tt>.
(Note that the location of these files is a dpkg internal; you should not
rely on it.)

<sect1 id="priority">Package priority
<!--
What is a Required/Important/Standard/Optional/Extra
package?
-->
<p>Each Debian package is assigned a <em>priority</em> by the distribution
maintainers, as an aid to the package management system.  The priorities are:

<list>
  <item><strong>Required</strong>: packages that are necessary for the proper
    functioning of the system.
    <p>This includes all tools that are necessary to repair system defects.
    You must not remove these packages or your system may become totally broken
    and you may probably not even be able to use dpkg to put things back.
    Systems with only the Required packages are probably unusable, but they do
    have enough functionality to allow the sysadmin to boot and install more
    software.
  <item><strong>Important</strong> packages should be found on any Unix-like
    system.
    <p>Other packages which the system will not run well or be usable without
    will be here. This does <em>NOT</em> include Emacs or X11 or TeX or any
    other large applications. These packages only constitute the bare
    infrastructure.
  <item><strong>Standard</strong> packages are standard on any Linux system,
    including a reasonably small but not too limited character-mode system.
    <p>This is what will install by default if users do not select anything
    else. It does not include many large applications, but it does include
    Emacs (this is more of a piece of infrastructure than an application)
    and a reasonable subset of TeX and LaTeX (if this turns out to be
    possible without X).
  <item><strong>Optional</strong> packages include all those that you might
    reasonably want to install if you did not know what it was, or do not
    have specialized requirements.
    <p>This includes X11, a full TeX distribution, and lots of applications.
  <item><strong>Extra</strong>: packages that either conflict with others
    with higher priorities, are only likely to be useful if you already know
    what they are, or have specialized requirements that make them
    unsuitable for "Optional".
</list>

<sect1 id="virtual">Virtual Package

<p>A virtual package is a generic name that applies to any one of a group
of packages, all of which provide similar basic functionality. For example,
both the <tt>tin</tt> and <tt>trn</tt> programs are news readers, and
should therefore satisfy any dependency of a program that required a news
reader on a system, in order to work or to be useful.
They are therefore both said to provide the "virtual package" called
<tt>news-reader</tt>.

<p>Similarly, <tt>exim</tt> and <tt>sendmail</tt> both provide the
functionality of a mail transport agent.  They are therefore said to
provide the virtual package, "mail transport agent".
If either one is installed, then any program depending on the
installation of a <tt>mail-transport-agent</tt> will be satisfied by
the existence of this virtual package.

<p>Debian provides a mechanism so that, if more than one package which
provide the same virtual package is installed on a system, then system
administrators can set one as the preferred package. The relevant command
is <tt>update-alternatives</tt>, and is described further in
<ref id="alternatives">.

<sect1 id="depends">Package dependencies
<!--
What is meant by saying that a package
  Depends/Recommends/Suggests/Conflicts/Replaces/Provides another package?
-->
<p>The Debian package system has a range of package "dependencies"
which are designed to indicate (in a single flag) the level at which
Program A can operate independently of the existence of Program B on
a given system:
<list>
  <item>Package A <em>depends</em> on Package B if B absolutely must
    be installed in order to run A.  In some cases, A depends not only
    on B, but on a version of B.  In this case, the version dependency is
    usually a lower limit, in the sense that A depends on any version
    of B more recent than some specified version.
  <item>Package A <em>recommends</em> Package B, if the package maintainer
    judges that most users would not want A without also having the
    functionality provided by B.
  <item>Package A <em>suggests</em> Package B if B contains files that
    are related to (and usually enhance) the functionality of A.
  <item>Package A <em>conflicts</em> with Package B when A will not
    operate if B is installed on the system.  Most often, conflicts are
    cases where A contains files which are an improvement over those in B.
    "Conflicts" are often combined with "replaces".
  <item>Package A <em>replaces</em> Package B when files installed
    by B are removed and (in some cases) over-written by files in A.
  <item>Package A <em>provides</em> Package B when all of the files and
    functionality of B are incorporated into A.  This mechanism provides
    a way for users with constrained disk space to get only that part of
    package A which they really need.
</list>

<p>More detailed information on the use of each these terms can be found
in the Packaging manual and the Policy manual.

<p>It should be reminded that <tt>dselect</tt> has more fine grained 
control over packages specified by <em>recommends</em> and 
<em>suggests</em> than <tt>apt-get</tt> which simply pulls all 
the packages specified by <em>recommends</em> and leaves all
the packages specified by <em>suggests</em>.  Both programs in modern 
form use APT as their back-end.

<sect1 id="pre-depends">Meaning of Pre-Depends

<p>"Pre-Depends" is a special dependency. In the case of most packages,
<tt>dpkg</tt> will unpack its archive file (i.e., its <tt>.deb</tt> file)
independently of whether or not the files on which it depends exist on the
system.  Simplistically, unpacking means that <tt>dpkg</tt> will extract
the files from the archive file that were meant to be installed on your
file system, and put them in place.  If those packages <em>depend</em> on
the existence of some other packages on your system, <tt>dpkg</tt> will
refuse to complete the installation (by executing its "configure" action)
until the other packages are installed.

<p>However, for some packages, <tt>dpkg</tt> will refuse even to unpack
them until certain dependencies are resolved.  Such packages are said
to "Pre-depend" on the presence of some other packages.
The Debian project provided this mechanism to support the safe upgrading
of systems from <tt>a.out</tt> format to <tt>ELF</tt> format, where
the <em>order</em> in which packages were unpacked was critical. There are
other large upgrade situations where this method is useful, e.g. the
packages with the required priority and their LibC dependency.

<p>As before, more detailed information about this can be found in the
Packaging manual.

<sect1 id="pkgstatus">Package status
<!--
What is meant by unknown/install/remove/purge/hold in
  the package status?
-->
<p> Package status can be "unknown", "install", "remove", "purge", or 
"hold".
These "want" flags tell what the user wanted to do with a package (as
indicated either by the user's actions in the "Select" section of
<tt>dselect</tt>, or by the user's direct invocations of <tt>dpkg</tt>).

<p>Their meanings are:
<list>
  <item>unknown  - the user has never indicated whether he wants the package
  <item>install  - the user wants the package installed or upgraded
  <item>remove   - the user wants the package removed, but does not want to
    remove any existing configuration files.
  <item>purge    - the user wants the package to be removed completely,
    including its configuration files.
  <item>hold     - the user wants this package not to be processed, i.e., he
    wants to keep the current version with the current status whatever that is.
</list>

<sect1 id="puttingonhold">Holding back packages from the upgrade
<!--
How do I put a package on hold?
Made major rewite to accomodate new /etc/apt/preferences in progress
-->
<p>There may be two mechanisms of holding back packages from the upgrade, 
through "dpkg", or, in woody, through APT.

<p>With dpkg, you just have to export the list of package selections, with:
  <example>dpkg --get-selections &gt; selections.txt</example>
Then edit the resulting file <file/selections.txt/, change the line
containing the package you wish to hold, e.g. <package/libc6/, from this:
  <example>libc6                                           install</example>
to this:
  <example>libc6                                           hold</example>
Save the file, and reload it into dpkg database with:
  <example>dpkg --set-selections &lt; selections.txt</example>
Or, if one knew package name to hold, simply run:
  <example>echo libc6 hold | dpkg --set-selections</example>
This process holds packages at the install process of each package file.

<p>The same effect can be obtained through dselect. One just have to enter 
the [S]elect screen, find the
package you wish to hold in its present state, and press the `=' key (or
`H'). The changes will go live immediately after you exit the [S]elect
screen.

<p>APT system in the new woody distribution has an new alternative mechanism 
to hold packages at archive retrieval process using <tt>Pin-Priority</tt>.
See manual page <manref name="apt_preferences" section="5">.

<!--- XXX apt-howto, apt_preferences, pointer withing this.  -->

<sect1 id="sourcepkgs">Source package

<p>
<!--
Debian source packages can't actually be "installed", they are just
unpacked in whatever directory you want to build the binary packages they
produce.
-->
Source packages are distributed in a directory called <tt>source</tt>, and
you can either download them manually, or use
  <example>apt-get source foo</example>
to fetch them (see <manref name="apt-get" section="8"> manual page on how
to setup APT for doing that).

<!-- XXX 
Pointer to building package   
mention deb-src thing here 
-->

<sect1 id="sourcebuild">Build binary packages from a source package

<p>You will need all of foo_*.dsc, foo_*.tar.gz and foo_*.diff.gz to compile
the source (note: there is no .diff.gz for a Debian native package).

<p>Once you have them, if you have the <package/dpkg-dev/ package installed,
the following command:
  <example>dpkg-source -x foo_version-revision.dsc</example>
will extract the package into a directory called <tt>foo-version</tt>.

<p>If you want just to compile the package, you may cd into
<tt>foo-version</tt> directory and issue the command
  <example>debian/rules build</example>
to build the program, then
  <example>debian/rules binary</example>
as root, to build the package, and then
  <example>dpkg -i ../foo_version-revision_arch.deb</example>
to install the newly-built package.

<!-- XXX woody has simpler commands and build-depends -->

<sect1 id="creatingdebs">Creating new Debian packages

<p>For more detailed description on this, read the New Maintainers' Guide,
available in the <package/maint-guide/ package, or at
<url id="&maint-guide;" name="&urlname;">.
<!--
<url id="ftp://ftp.debian.org/debian/doc/package-developer/maint-guide.html.tar.gz">.
-->
<!--
<sect id="pkgtools">Package Management Tools
Once many were moved up here but now moved down
-->

<!-- 
Rerely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-deb">dpkg-deb
Removed below
-->

<!--
move up contents as a part of APT
<sect2 id="apt-get">apt-get
-->

<!--
Rerely use command for woody, exclude but mention its manual page above.
<sect2 id="dpkg-split">dpkg-split
removed
-->

<!--
Moved down
<sect1 id="updaterunning">Upgrade running system
Debian claims to be able to update a running program;
  how is this accomplished?
-->

<!--
<sect1 id="whatpackages">How can I tell what packages are already installed
  on a Debian system?
removed dpkg list and status things here
-->

<!-- these information are in debian.sgml and above
<sect1 id="filesearch">How can I find out what package produced a particular
  file?
removed dpkg list and status things here
-->

<sect id="uptodate">Upgrade Debian System

<p>One of Debian goals is to provide a consistent upgrade path and a secure
upgrade process, and we always do our best to make the new release smoothly
upgradable from the previous ones. In case there's some important note to
add to the upgrade process, the packages will alert the user, and often
provide a solution to a possible problem.

<p>You should also read the Release Notes, document that describes the
details of specific upgrades, shipped on all Debian CDs, and available on
the WWW at <url id="&stable-release;"> or <url id="&testing-release;">.

<p>
Practical guide is provided in <ref id="package">.  This section 
describes fundamental detail.

<!-- XXX make this into generic link -->

<!-- Obsolete, removed
<sect1 id="libc5to6upgrade">How can I upgrade my Debian 1.3.1 (or earlier)
  distribution, based on libc5, to 2.0 (or later), based on libc6?
...
This paragraph is obsolete.
-->

<sect1 id="howtocurrent">Methods for upgrading Debian system

<p>One could simply execute an anonymous ftp or wget call to a Debian archive, then
peruse the directories until he finds the desired file, and then fetch it,
and finally install it using <tt>dpkg</tt>.  Note that <tt>dpkg</tt>
will install upgrade files in place, even on a running system.
Sometimes, a revised package will require the installation of a newly revised
version of another package, in which case the installation will fail
until/unless the other package is installed.

<p>Many people find this approach much too time-consuming, since Debian
evolves so quickly -- typically, a dozen or more new packages are uploaded
every week.  This number is larger just before a new major release.
To deal with this avalanche, many people prefer to use an automated
programs.  Several specialized package management tools are available 
for this purpose.

<sect1 id="pkgtools">Package management tools overview

<!-- reorganize this and following section in a compact section -->
<!--
<sect1 id="pkgprogs">What programs does Debian provide for managing its
  packages?
  Insert overview and
  bump sect2 to sect1
-->
<p>Debian package management system has 2 focuses, i.e., the manipulation 
of the package file itself and the retrieval of package files from 
the Debian archive.  <tt>dpkg</tt> is the former. <tt>APT</tt> and
<tt>dselect</tt> are the latters.

<sect1 id="dpkg">dpkg

<p>This is the main program to manipulate package files.
<p>For more information, install <package/dpkg/ package and read
<manref name="dpkg" section="8">.


<p><prgn>dpkg</prgn> comes with several primitive supplemental programs.

<list>
<item>dpkg-deb: Manipulate <tt>.deb</tt>) files. 
 <manref name="dpkg-deb" section="1">
<item>dpkg-ftp: Older package file retrieval command. 
 <manref name="dpkg-ftp" section="1">
<item>dpkg-mountable: Older package file retrieval command. 
 <manref name="dpkg-mountable" section="1">
<item>dpkg-split: Splits large package into smaller files. 
 <manref name="dpkg-split" section="1">
</list>

<prgn>dpkg-ftp</prgn> and <prgn>dpkg-mountable</prgn> are obsoleted by 
the introduction of APT system.

<!-- Insert APT and apt-get here: -->
<sect1 id="apt">APT

<p>APT is an advanced interface to the Debian packaging system. 
<prgn>apt-get</prgn>, <prgn>apt-cache</prgn> and <prgn>apt-cdrom</prgn> 
are the command-line tool for handling packages.  These also function 
as the user's "back-end" programs to other tools, such as <prgn/dselect/ 
and <prgn/aptitude/.

<p>For more information, install <package/apt/ package and read
<manref name="apt-get" section="8">,
<manref name="apt-cache" section="8">,
<manref name="apt-cdrom" section="8">,
<manref name="apt.conf" section="5">,
<manref name="sources.list" section="5">, 
<manref name="apt_preferences" section="5"> (woody), and
<file>/usr/share/doc/apt/guide.html/index.html</file>.

<p>Alternative source of information exists as
<url id="&apt-howto;" name="APT HOWTO">.
This can be installed by <package/apt-howto/ at
<file>/usr/share/doc/apt-howto/en/apt-howto-en.html/index.html</file>.

<p><tt>apt-get upgrade</tt> and <tt>apt-get dist-upgrade</tt> have a 
tendency to pull-in all packages listed under "Suggests:".  
To avoid this, use <prgn>dselect</prgn>.

<!-- removed boring APT info -->

<!-- bump from sect2 to sect1 -->
<sect1 id="dselect-basics">dselect

<p>This program is a menu-driven user interface to the Debian package management
system. It is particularly useful for first-time installations and
large-scale upgrades.

<p>For more information, install <package/install-doc/ package and read
<file>/usr/share/doc/install-doc/dselect-beginner.en.html</file> or
<url id="&dselect-beginner;" name="dselect Documentation for Beginners">.

<!-- removed boring dselect info -->

<!-- move this up and make this sect1
<sect2 id="apt">APT
-->
<!-- remove this and mention above in dpkg
<sect2 id="dpkg-ftp">dpkg-ftp
-->
<!-- remove this
<sect2 id="mirror">mirror
-->

<!-- remove this section and mention above in dpkg
<sect2 id="dpkg-mountable">dpkg-mountable
-->

<!--
<sect1 id="upgradesingle">Must I go into single user mode in order to
  upgrade a package?

<p>No.  Packages can be upgraded in place, even in running systems.
Debian has a <tt>start-stop-daemon</tt> program that is invoked to stop,
then restart running process if necessary during a package upgrade.
-->

<sect1 id="updaterunning">Upgrade running system

<p>The kernel (file system) in &debian; systems supports replacing files even
while they're being used.

<p>We also provide a program called <prgn/start-stop-daemon/ which is used
to start daemons at boot time or to stop daemons when the kernel runlevel is
changed (e.g., from multi-user to single-user or to halt). The same program
is used by installation scripts when a new package containing a daemon is
installed, to stop running daemons, and restart them as necessary.

<p>It is noteworthy to mention that the Debian system does not require 
use of the single user mode to upgrade running system.

<sect1 id="savedebs">Downloaded and cached .deb archive files

<p>If you have downloaded the files to your disk (which is not
absolutely necessary, see above for the description of dpkg-ftp),
then after you have installed the packages, you can remove them from
your system.

<p>If APT is used, these files are cached in
<file>/var/cache/apt/archives/</file> directory.  
You may erase them after installation or copy to another machine's
<file>/var/cache/apt/archives/</file> directory to save downloading
during following installations.

<!-- insert apt-get clean... thing and dselect configuration here XXXX -->

<sect1 id="keepingalog">Record keeping for upgrade

<p><prgn/dpkg/ keeps a record of the packages that have been unpacked,
configured, removed, and/or purged, but does not (currently) keep a log
of terminal activity that occured while a package was being so manipulated.

<p>The simplest way to work around this is to run your
<prgn>dpkg</prgn>/<prgn>dselect</prgn>/<prgn>apt-get</prgn>/whatever
sessions within the <manref name="script" section="1"> program.

<sect id="boot">Boot process of Debian

<sect1 id="init"><tt>init</tt> program

<p>Like all Unices, Debian boots up by executing the program <tt>init</tt>.
The configuration file for <tt>init</tt> (which is <tt>/etc/inittab</tt>)
specifies that the first script to be executed should
be <tt>/etc/init.d/rcS</tt>.  This script checks and mounts file systems,
loads modules, starts the network services, sets the clock, performs other
initialization, and then runs all of the scripts (except those with a `.'
in the filename) in <tt>/etc/rc.boot/</tt>. Any scripts in the latter
directory are usually reserved for system administrator use, and using them
in packages is deprecated.

<sect1 id="runlevels">Runlevels

<p>After completing the boot process, <tt>init</tt> executes all start
scripts in a directory specified by the default runlevel (this runlevel
is given by the entry for <tt>id</tt> in <tt>/etc/inittab</tt>).
Like most <!-- all? SGK --> System V compatible Unices, Linux has 7 runlevels:
<list>
  <item>0 (halt the system),
  <item>1 (single-user mode),
  <item>2 through 5 (various multi-user modes), and
  <item>6 (reboot the system).
</list>
Debian systems come with id=2, which indicates that the default
runlevel will be '2' when the multi-user state is entered, and the
scripts in <tt>/etc/rc2.d/</tt> will be run.

<p>In fact, the scripts in any of the directories, <tt>/etc/rcN.d/</tt>
are just symbolic links back to scripts in <tt>/etc/init.d/</tt>.  However,
the <em>names</em> of the files in each of the <tt>/etc/rcN.d/</tt>
directories are selected to indicate the <em>way</em> the scripts in
<tt>/etc/init.d/</tt> will be run.  Specifically, before entering any
runlevel, all the scripts beginning with 'K' are run; these scripts kill
services.  Then all the scripts beginning with 'S' are run; these scripts
start services.  The two-digit number following the 'K' or 'S' indicates
the order in which the script is run.  Lower numbered scripts are executed
first.

<p>This approach works because the scripts in <tt>/etc/init.d/</tt> all
take an argument which can be either `start', `stop', `reload', `restart'
or `force-reload' and will then do the task indicated by the argument.
These scripts can be used even after a system has been booted, to control
various processes.

<p>For example, with the argument `reload' the command
  <example>/etc/init.d/sendmail reload</example>
sends the sendmail daemon a signal to reread its configuration file.

<sect1 id="custombootscripts">Customize boot process
<p>
It looks as if Debian does not use
  <tt>rc.local</tt> to customize the boot process; what facilities
  are provided?

<p>Suppose a system needs to execute script <tt>foo</tt> on start-up,
or on entry to a particular (System V) runlevel.  Then the system
administrator should:
<list>
  <item>Enter the script <tt>foo</tt> into the directory <tt>/etc/init.d/</tt>.
  <item>Run the Debian command <tt>update-rc.d</tt> with appropriate
  arguments, to set up links between the (command-line-specified) directories
  rc?.d and <tt>/etc/init.d/foo</tt>.  Here, '?' is a number from 0 through 6
  and corresponds to each of the System V runlevels.
  <item>Reboot the system.
</list>

<p>The command <tt>update-rc.d</tt> will set up links between files in
the directories rc?.d and the script in <tt>/etc/init.d/</tt>.
Each link will begin with a 'S' or a 'K', followed by a number, followed
by the name of the script.  Scripts beginning with 'S' in
<tt>/etc/rcN.d/</tt> are executed when runlevel <tt>N</tt> is entered.
Scripts beginning with a 'K' are executed when leaving runlevel <tt>N</tt>.

<p>One might, for example, cause the script <tt>foo</tt> to execute at
boot-up, by putting it in <tt>/etc/init.d/</tt> and installing the links with
<tt>update-rc.d foo defaults 19</tt>.  The argument 'defaults' refers
to the default runlevels, which are 2 through 5.  The argument '19' ensures
that <tt>foo</tt> is called before any scripts containing numbers 20
or larger.

<sect id="diverse">Support of diversity
<p>
Debian offers several avenues to accommodate any wishes of the system 
administrator without breaking the system. 
<list>
<item><prgn>dpkg-divert</prgn>, see <ref id="dpkg-divert">.
<item><prgn>equivs</prgn>, see <ref id="equivs">.
<item><prgn>update-alternative</prgn>, see <ref id="alternatives">.
<item><prgn>make-kpkg</prgn> can accommodate many boot loaders. 
      See <manref name="make-kpkg" section="1">.
</list>
Any files under <file>/usr/local/</file> belongs to the system administrator 
and &debian; will not touch them. Most (or all) files under <file>/etc</file> are 
<tt>conffiles</tt> and &debian; will not overwrite them upon upgrade unless 
the system administrator requests so explicitly.

<sect id="nonenglish">Non-English locale

<p>
<url id="&intro-i18n;" name="Introduction to i18n"> is aimed at the developers 
but also useful for the system administrators.
<list>
  <item>&debian; is distributed with keymaps for nearly two dozen
    keyboards, and with utilities (in the <tt>kbd</tt> package) to install,
    view, and modify the tables. <!-- XXXX kbd or console ??? -->
    <p>The installation prompts the user to specify the keyboard he will use.
  <item>Vast majority of the software we packaged supports entering
    non-US-ASCII characters used in other Latin languages (e.g. ISO-8859-1
    or ISO-8859-2), and a number of programs support multi-byte languages
    such as Japanese or Chinese.
  <item>Currently, support for German-, Spanish-, Finnish-, French-,
    Hungarian-, Italian-, Japanese-, Korean- and Polish-language
    manual pages is provided through the <tt>manpages-LANG</tt> packages
    (where LANG is the two-letter ISO country code). To access an NLS manual
    page, the user must set the shell LC_MESSAGES variable to the appropriate
    string.
    <p>For example, in the case of the Italian-language manual pages,
    LC_MESSAGES needs to be set to 'italian'.  The <prgn/man/ program will
    then search for Italian manual pages under <tt>/usr/share/man/it/</tt>.
</list>

<sect id="kernel-details">Debian and the kernel

<sect1 id="non-debian-kernel">Compile a kernel from non-debian source

<p><!--Yes.  But you have-->
One has to understand the Debian policy with respect to headers.

<p>The Debian C libraries are built with the most recent <em>stable</em>
releases of the <strong>kernel</strong> headers.

<p>For example, the Debian-1.2 release used version 5.4.13 of the headers.
This practice contrasts with the Linux kernel source packages distributed
at all Linux FTP archive sites, which uses even more recent versions of
the headers.  The kernel headers distributed with the kernel source are
located in <tt>/usr/include/linux/include/</tt>.

<p>If you need to compile a program with kernel headers that are newer
than those provided by <package/libc6-dev/, then you must add
<tt>-I/usr/src/linux/include/</tt> to your command line when compiling.
This came up at one point, for example, with the packaging of the
automounter daemon (<package/amd/).  When new kernels changed some
internals dealing with NFS, <tt>amd</tt> needed to know about them.
This required the inclusion of the latest kernel headers.

<sect1 id="customkernel">Tools to build custom kernels

<p>Users who wish to (or must) build a custom kernel are encouraged to
download the package <package/kernel-package/.  This package contains
the script to build the kernel package, and provides the capability to
create a Debian kernel-image package just by running the command
  <example>make-kpkg kernel_image</example>
in the top-level kernel source directory.
Help is available by executing the command
  <example>make-kpkg --help</example>
and through the manual page <manref name="make-kpkg" section="8">.

<p>Users must separately download the source code for the most recent
kernel (or the kernel of their choice) from their favorite Linux archive
site, unless a kernel-source-version package is available (where "version"
stands for the kernel version). See <ref id="kernel-compile">.

<p>Detailed instructions for using the <package/kernel-package/ package
are given in the file <tt>/usr/doc/kernel-package/README</tt>. 

<!-- TODO: check out a new source of details, this README isn't too useful,
  I'm told (joy) -->

<sect1 id="alt-boot">Alternative boot loader
<p>
To employ alternative boot loaders such as <package/grub/ or
<package/loadlin/, copy the compiled Linux kernel <file>bzimage</file> 
to other locations (e.g., to /boot/grub or to an <tt>MS-DOS</tt> partition).
</sect1>

<sect1 id="custombootdisk">Custom boot floppy

<p>This task is greatly aided by the Debian package <package/boot-floppies/,
normally found in the <tt>admin</tt> section of the Debian FTP archive.
Shell scripts in this package produce boot floppies in the <tt>SYSLINUX</tt>
format.  These are <tt>MS-DOS</tt> formatted floppies whose master boot
records have been altered so that they boot Linux directly (or whatever
other operating system has been defined in the syslinux.cfg file on the
floppy). Other scripts in this package produce emergency root disks and
can even reproduce the base disks.

<p>You will find more information about this in the
<tt>/usr/doc/boot-floppies/README</tt> file after installing the
<package/boot-floppies/ package.

<sect1 id="modules">Special provisions to deal with modules

<p>Debian's <package/modconf/ package provides a shell script
(<tt>/usr/sbin/modconf</tt>) which can be used to customize the
configuration of modules.  This script presents a menu-based interface,
prompting the user for particulars on the loadable device drivers
in his system.  The responses are used to customize the file
<tt>/etc/modules.conf</tt> (which lists aliases, and other arguments that
must be used in conjunction with various modules) through files in
<tt>/etc/modutils/</tt>, and <tt>/etc/modules</tt> (which lists the
modules that must be loaded at boot time).

<p>Like the (new) Configure.help files that are now available to support
the construction of custom kernels, the modconf package comes with a
series of help files (in <tt>/usr/lib/modules_help/</tt>) which provide
detailed information on appropriate arguments for each of the modules.

<!-- XXXX need section for initrd -->

<sect1 id="removeoldkernel">De-install an old kernel package

<p>Yes.  The <tt>kernel-image-NNN.prerm</tt> script checks to see whether
the kernel you are currently running is the same as the kernel you are trying
to de-install.  Therefore you can remove unwanted kernel image packages using
this command:

<example>dpkg --purge --force-remove-essential kernel-image-NNN</example>

(replace "NNN" with your kernel version and revision number, of course)
</sect>
