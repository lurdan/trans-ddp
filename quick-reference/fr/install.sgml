<!-- CVS revision of this document "$Revision: 1.13 $"  -->
<!-- CVS revision of original english document "1.45"  -->

<CHAPT ID="install">Installation du système &debian;
<p>
La documentation officielle pour installer Debian est située à 
<url id="&stable-info;">, et
<url id="&stable-install;">.
<p>
Sa version de développement est située à
<url id="&testing-info;" >, et
<url id="&testing-install;"> (en développement, parfois elle n'existe pas).
<p>
Bien que «&nbsp;&book-title;&nbsp;» ait été commencé à l'époque de Potato, la
majeure partie de son contenu a été mis à jour pour &stabledebian; et &testingdebian;.

<sect>Astuces générales sur l'installation du système Linux
<p>
En vue de minimiser les risques associés aux paquets de «&nbsp;testing&nbsp;»
et «&nbsp;unstable&nbsp;», c'est une bonne habitude de configurer votre système
Linux principal en dual boot avec un autre système Linux plus petit et stable.

<sect1>Compatibilité matérielle
<p>
Linux est compatible avec la plupart des matériels PC. Linux peut être
installé sur presque tout système. Pour moi il a été aussi facile à installer
que Windows 95/98/Me.  Il semble que la liste des compatibilités matérielles
s'allonge encore.
<p>
Si vous possédez un PC portable, consultez :
<url id="&linonlap;" name="Linux on Laptops">
pour identifier sa situation.
<p>
Ma recommandation pour le matériel type PC de bureau est «&nbsp;soyez juste
conservateur&nbsp;»&nbsp;:
<list compact>
<item>SCSI plutôt qu'IDE pour le travail, disque dur IDE/ATAPI pour
l'utilisation privée.
<item>CD-ROM (ou CD-RW) IDE/ATAPI.
<item>PCI plutôt qu'ISA, surtout pour la carte réseau.
<item>Utilisez une carte réseau de base. Des cartes Tulip sur bus PCI, NE2000
sur bus ISA conviennent bien.
<item>Évitez PCMCIA (portables) lors de la première tentative d'installation de
Linux.
<item>Pas de clavier ou de souris USB, ... à moins de vouloir faire face à un
défi.
</list>
<p>
Pour une machine lente, extraire son disque dur et le connecter dans une autre
machine plus rapide pour accélérer l'installation est une bonne idée.  
</sect1>

<sect1>Déterminer le matériel et les puces du PC
<p>
Durant l'installation, on sera interrogé sur le matériel ou les puces. Parfois,
ces informations ne sont pas toujours faciles à trouver. Voici une
méthode&nbsp;:
<enumlist compact>
  <item>Ouvrez le PC et inspectez l'intérieur. 
  <item>Notez les chiffres qui sont sur la grande puce de la carte graphique,
  de la carte réseau, sur la puce à côté des ports série et la puce à côté des
  ports IDE.
  <item>Notez les noms des cartes imprimés au dos des cartes PCI et ISA.
</enumlist>
</sect1>

<sect1>Trouver le matériel du PC avec &debian;
<p>
Les commandes suivantes sur un système Linux devraients donner quelqu'idée sur
le matériel présent et la configuration.
<example>
$ /usr/sbin/lspci -v |less
$ pager /proc/pci
$ pager /proc/interrupts
$ pager /proc/ioports
</example>
Ces commandes peuvent être lancées pendant le processus d'installation à partir de la console en appuyant sur ALT-F2.
</sect1>

<sect1>Trouver le matériel du PC avec d'autres systèmes d'exploitation (SE)
<p>
D'autres sources d'information concernant le matériel peuvent être obtenues
avec d'autres SE.
<p>
Installez une autre distribution Linux commerciale. La détection du matériel
tend à être meilleure que celle de Debian, pour l'instant. Ceci peut changer
avec la nouvelle Woody.
<p>
Installez Windows. La configuration matérielle peut être obtenue en faisant un
clic droit sur «&nbsp;Poste de travail&nbsp;» pour aller sur Propriétés /
Gestionnaire de périphériques. Enregistrez toutes les ressources d'information
comme IRQ, I/O port address, DMA. Quelques vieilles cartes ISA doivent être
configurées sous DOS et utilisées en conséquence.
</sect1>

<sect1>Le Mythe Lilo 
<p>
Lilo est limité à 1024 cylindres. &mdash;FAUX !
<p>
Les versions récentes de <prgn>lilo</prgn> utilisées depuis Debian Potato
supportent lba32.  Si le BIOS de la carte mère est assez récent pour supporter
lba32, <prgn>lilo</prgn> devrait être capable de charger au-delà de la vieille
limite des 1024 cylindres.
<p>
Assurez-vous simplement d'ajouter la ligne «&nbsp;lba32&nbsp;» vers le début
de votre fichier <prgn>lilo.conf</prgn> si vous avez gardé un vieux
<prgn>lilo.conf</prgn>.
</sect1>

<sect1 id="bootfloppy">Choix des disquettes de boot
<p>
Pour Potato, j'aimais bien les disquettes IDEPCI pour installer une machine de
bureau.

Pour Woody, j'aime bien les disquettes bf2.4. Elles utilisent une version de
<package>boot-floppies</package> pour créer les disquettes de démarrage.
<p>
Si vous avez une carte réseau PCMCIA, vous devez utiliser les disquettes de
démarrage standard (plus grand nombre de disquettes, mais tous les pilotes de
périphériques sont disponibles) et configurer la carte réseau dans le
dialogue PCMCIA&nbsp;; n'essayez pas de la configurer dans le dialogue de
configuration réseau standard.
<p>
Pour des systèmes spéciaux, vous pouvez avoir besoin de créer une disquette de
secours personnalisée. Cela peut être fait en remplaçant l'image du noyau
appelée «&nbsp;linux&nbsp;» sur la disquette de secours &debian; par une autre
image compressée du noyau compilée ailleurs pour la machine.  Les détails sont
documentés dans le fichier <file>readme.txt</file> de la disquette de secours.
La disquette est formattée au format MSDOS, aussi vous pouvez utiliser
n'importe quel système pour lire et éditer ce fichier.  Ceci peut rendre la
vie plus facile à ceux qui possèdent une carte réseau spéciale, etc.
<p>
Pour Sarge, le paquet <package>debian-installer</package> et/ou
<package>pgi</package> est à utiliser pour créer les disquettes de démarrage.
</sect1>

<sect1>Installation
<p>
Suivez les instructions officielles à
<url id="&stable-install;">
ou
<url id="&testing-install;"> (en développement, parfois elles n'existent pas).
<p>
Si vous installez un système avec les disquettes de démarrage de la
distribution de testing, il vous faudra peut-être ouvrir une console en
appuyant sur <tt>ALT-F2</tt> et remplacer manuellement les entrées
<tt>stable</tt> par <tt>testing</tt> pour ajuster les sources APT.
<p>
J'ai l'habitude d'installer <prgn>lilo</prgn> à un endroit comme
<file>/dev/hda3</file>, en installant <prgn>mbr</prgn> sur
<file>/dev/hda</file>. Cela minimise les risques de recouvrir l'information de
démarrage.
<p>
Voici ce que je choisis lors du processus d'installation.
<list compact>
<item>MD5 passwords «&nbsp;yes&nbsp;»
<item>shadow passwords «&nbsp;yes&nbsp;»
<item>Installation «&nbsp;advanced&nbsp;» (dselect **) et sélection de
 <list compact>
  <item>exclure emacs (si sélectionné), nvi, tex, telnet, talk(d)&nbsp;;
  <item>inclure mc, vim, nano-tiny ou elvis-tiny.
  <p>
  Voir <ref id="dselect">. Même si vous êtes un fan d'Emacs, laissez-le pour
  le moment et utilisez nano pendant l'installation. De même, évitez
  d'installer de gros paquets comme TeX (Potato le faisait) à ce point-là.
  Voir <ref id="bin-editor"> pour la raison de l'installation de nano-tiny ou
  elvis-tiny ici.
 </list>
<item>Pour toutes les questions de configuration pendant l'installation de
chaque paquet&nbsp;: «&nbsp;y&nbsp;» (remplace version courante).
<item><package>exim</package>&nbsp;: sélectionner 2 pour envoyer le courrier
électronique par le serveur SMTP du FAI.
</list>
<p>
Pour plus d'informations sur dselect, voir <ref id="dselect">.
</sect1>

<sect1>Nom d'hôte et IP à utiliser pour le réseau local
<p>
J'utilise un sous-réseau de classe C à la maison,
<example>
Internet
   |
   +--- FAI externe fournit le service POP (accédé par fetchmail)
   | 
  le FAI fournit les services DHCP et relai SMTP
   |                     :
  Modem Cable        (Téléphone)
   |                     :
Port externe de la passerelle&nbsp;: eth0 (IP donnée par le DHCP du FAI)
 utilise un vieux PC portable (IBM Thinkpad, 486 DX2 50 MHz, 20 MB RAM)
 tourne avec le noyau Linux 2.4 et le système de fichiers ext3
 tourne avec le paquet «&nbsp;ipmasq&nbsp;» (avec fortification, NAT et pare-feu)
 tourne avec le paquet «&nbsp;dhcp-client&nbsp;» configuré pour eth0 (remplace les paramètres DNS)
 tourne avec le paquet «&nbsp;dhcp&nbsp;» configuré pour eth1
 tourne avec «&nbsp;exim&nbsp;» comme hôte intelligent (mode 2)
 tourne avec «&nbsp;fetchmail&nbsp;» avec un long intervalle (fall back)
 tourne avec «&nbsp;bind&nbsp;» comme	serveur de nom en cache pour l'Internet depuis le réseau local
				serveur de nom officiel pour le domaine du réseau local
 tourne avec «&nbsp;ssh&nbsp;» sur les ports 22 et 8080 (connexions depuis n'importe où)
 tourne avec «&nbsp;squid&nbsp;» comme serveur de cache pour l'archive Debian (pour APT)
Port interne de la passerelle&nbsp;: eth1 (IP = 192.168.1.1, fixe)
                         |
         +--- LAN Switch (10 base T) ---+
         |                              |
Quelques clients avec IP fixe    Quelques clients DHCP
(IP = 192.168.1.2-127, fixe)     (IP = 192.168.1.128-200, dynamique)
</example>
Voir <ref id="gateway"> pour les détails de la configuration d'une passerelle
pour le réseau local.
</sect1>

<sect1>Comptes utilisateurs
<p>
Afin d'avoir une organisation cohérente entre toutes les machines, quelques
premiers comptes sont toujours les mêmes sur mon système.
<p>
Je crée toujours un premier compte utilisateur avec un nom comme "admin"
(uid=1000). Tous les messages de root sont redirigés dessus. Ce compte est
membre du groupe <tt>adm</tt> (voir <ref id="wheel">), à qui l'on peut donner
beaucoup des privilèges de root au travers des programmes <prgn>su</prgn> en
utilisant PAM ou <prgn>sudo</prgn>. Voir <ref id="newuser"> pour les détails.
</sect1>

<sect1>Création des systèmes de fichiers
<p>
<sect2>Partition du disque dur
<p>
Je préfère avoir différentes partitions pour différentes arborescences de
répertoires, afin de limiter les dommages en cas de plantage du système. Par
exemple&nbsp;:
<example>
/          == (/ + /boot + /bin + /sbin)
           == 50Mo+
/tmp       == 100Mo+
/var       == 100Mo+
/home      == 100Mo+
/usr       == 700Mo+ avec X
/usr/local == 100Mo
</example>
<p>
La taille du répertoire <file>/usr</file> dépend beaucoup des applications
X-Window et de la documentation. <file>/usr</file> peut être de 300Mo si l'on
n'utilise que le terminal, tandis que 2Go&ndash;3Go n'est pas inhabituel si
l'on installe un certain nombre d'applications Gnome.

Lorsque <file>/usr</file> devient trop gros, déplacer
<file>/usr/share/</file> vers une autre partition est le meilleur remède. Avec
un noyau 2.4 récent, <file>/</file> peut avoir besoin de plus de 200Mo.

<p>
Par exemple, le statut actuel de la machine qui sert de passerelle Internet
est le suivant (sortie de la commande <tt>df -h</tt>)&nbsp;:
<example>
Filesystem            Size  Used Avail Use&percnt; Mounted on
/dev/hda3             300M  106M  179M  38&percnt; /
/dev/hda7             100M   12M   82M  13&percnt; /home
/dev/hda8             596M   53M  513M  10&percnt; /var
/dev/hda6             100M  834k   94M   1&percnt; /var/lib/cvs
/dev/hda9             596M  222M  343M  40&percnt; /usr
/dev/hda10            596M  130M  436M  23&percnt; /var/cache/apt/archives
/dev/hda11            1.5G  204M  1.2G  14&percnt; /var/spool/squid
</example>
(La grande taille de <file>/var/spool/squid</file> est pour le proxy en vue du
téléchargement des paquetages.)
<p>
Ci-dessous la sortie de <tt>fdisk -l</tt> pour donner une idée.
<example>
# fdisk -l /dev/hda # comment

/dev/hda1             1        41    309928+   6  FAT16 # DOS
/dev/hda2            42        84    325080   83  Linux # (pas utilisé)
/dev/hda3   *        85       126    317520   83  Linux # Principal
/dev/hda4           127       629   3802680    5  Extended
/dev/hda5           127       143    128488+  82  Linux swap
/dev/hda6           144       157    105808+  83  Linux
/dev/hda7           158       171    105808+  83  Linux
/dev/hda8           172       253    619888+  83  Linux
/dev/hda9           254       335    619888+  83  Linux
/dev/hda10          336       417    619888+  83  Linux
/dev/hda11          418       629   1602688+  83  Linux
</example>
Quelques partitions inutilisées existent. Elles sont réservées pour installer
une seconde distribution Linux ou une réserve d'espace pour une arborescence de
répertoires en expansion.

<sect2>Monter les systèmes de fichiers

<p>
Montez les systèmes de fichiers ci-dessus proprement avec le fichier
<file>fstab</file> suivant&nbsp;:

<example>
# /etc/fstab: information du fichier système statique.
#
# file system	mount point	type	options		       dump pass
/dev/hda3	/		ext2	defaults,errors=remount-ro 0 1
/dev/hda5	none		swap	sw			0 0
proc		/proc		proc	defaults		0 0
/dev/fd0	/floppy		auto	defaults,user,noauto	0 0
/dev/cdrom	/cdrom		iso9660	defaults,ro,user,noauto	0 0
#
# conserve les partitions séparées
/dev/hda7	/home		ext2	rw			0 2
/dev/hda8	/var		ext2	rw			0 2
/dev/hda6	/var/lib/cvs	ext2	rw			0 2
/dev/hda9	/usr		ext2	rw			0 2
/dev/hda10	/var/cache/apt/archives ext2	rw		0 2

# une très grande partition pour le cache proxy
/dev/hda11	/var/spool/squid ext2	rw			0 2

# backup bootable sous DOS
/dev/hda1	/mnt/dos	vfat	rw,noauto		0 0
# backup bootable sous système Linux (pas fait)
/dev/hda2	/mnt/linux	ext2	rw,noauto		0 0
#
# montages nfs 
mickey:/	/mnt/mickey	nfs	ro,noauto,intr		0 0
goofy:/		/mnt/goofy	nfs	ro,noauto,intr		0 0
# minnie:/ /mnt/minnie smbfs ro,soft,intr,credentials={filename} 0 2
</example>
Pour NFS, j'utilise <tt>noauto,intr</tt> avec l'option par défaut
<tt>hard</tt>. De cette façon, il est possible d'arrêter un processus
bloqué par une déconnexion en utilisant Control-C.
<p>
Pour une machine sous Windows connectée avec Samba (smbfs),
<tt>rw,auto,soft,intr</tt> peut être une bonne idée. Voir <ref id="samba">.
<p>
Pour un lecteur de disquettes, utiliser <tt>noauto,rw,sync,user,exec</tt>
prévient les corruptions de données après une éjection accidentelle du disque
sans le démonter, mais cela ralentit l'écriture.

<sect2>Montage autofs
<p>
Points clés pour le montage automatique&nbsp;:
<list compact>
<item>Charger le module <tt>vfat</tt> pour autoriser
<file>/etc/auto.misc</file> à contenir <tt>fstype=auto</tt>&nbsp;:
<example>
# modprobe vfat # avant d'essayer d'accéder à la disquette
 ... ou pour automatiser cela,
# cat >>/etc/modules
vfat
^D
 ... et redémarrer le système
</example>
<item>Editer le fichier <file>/etc/auto.misc</file> comme suit&nbsp;:
<example>
floppy -fstype=auto,sync,nodev,nosuid,gid=100,umask=000 :/dev/fd0
 ... où gid=100 est «&nbsp;users&nbsp;».
</example>
<item>Créer des liens dans <file>/home/<var>user</var></file>,
<file>cdrom</file> et <file>floppy</file>, qui pointent respectivement vers
<file>/var/autofs/misc/cdrom</file> et <file>/var/autofs/misc/floppy</file>.
<item>Ajoutez <var>user</var> au groupe «&nbsp;users&nbsp;».
</list>

<sect2>Montage NFS
<p>
Le serveur Linux nfs externe (goofy) se trouve derrière un pare-feu
(passerelle). J'ai une politique de sécurité très relâchée sur LAN puisque je
suis le seul à l'utiliser. Pour obtenir un accès nfs, le côté du serveur nfs a
besoin qu'on ajoute <file>/etc/exports</file> comme suit&nbsp;:
<example>
# /etc/exports: la liste des contrôle d'accès pour les systèmes de fichier
# qui peuvent être exportés vers les clients NFS.  Voir exports(5).
/       (rw,no_root_squash)
</example>
Ceci est utile pour activer le serveur nfs en plus de l'installation et de
l'activation d'un client/serveur nfs.
<p>
Je crée généralement une seule partition de 2Go pour une installation
expérimentale et/ou secondaire et paresseuse de Linux, pour plus de simplicité.
Je partage optionnellement les partitions swap et <file>/tmp</file> pour ces
installations.  Le schéma de multi-partitionnement est trop complexe pour ces
usages.  Si on a besoin d'un système simple utilisé en console, 500Mo peuvent
être largement suffisants.
</sect1>

<sect1>Lignes directrices pour la mémoire DRAM 
<p>
Ce qui suit sont des indications grossières pour la DRAM.
<example>
  4 Mo :  Minimum suffisant pour faire fonctionner le noyau Linux.
 16 Mo :  Minimum pour un usage du système en mode console.
 32 Mo :  Minimum pour un système X simple.
 64 Mo :  Minimum pour un système X avec GNOME/KDE.
128 Mo :  Confortable pour le système X avec GNOME/KDE.
256+Mo :  Pourquoi pas si ça vous chante. La DRAM est bon marché.
</example>
L'option de boot <tt>mem=4m</tt> (ou lilo <tt>append="mem=4m"</tt>) montrera
comment le système se comporterait en ayant 4Mo de mémoire installée.  Un
paramètre de démarrage pour <prgn>lilo</prgn> est requis pour un système ayant
plus de 64Mo de mémoire avec un vieux BIOS.
</sect1>

<sect1>Espace de Swap
<p>
J'utilise la ligne directrice suivante&nbsp;:
<list compact>
<item>Chaque partition de swap est &lt; 128 Mo (avec un vieux noyau 2.0), &lt;
2 Go (avec les noyaux récents)
<item>Total = soit (1 à 2 fois la taille de la RAM) soit (128 Mo à 2 Go)
<item>Installation sur des disques différents et montage avec les options
<tt>sw,pri=1</tt> dans <file>/etc/fstab</file>. Cela permet de s'assurer que
le noyau fait du RAID par bandes sur les partitions de swap et offre des
performances maximum.
<item>Utilisation de la partie centrale du disque, si possible.
</list>
<p>
Même si vous n'en avez pas besoin, de l'espace de swap (128&nbsp;Mo) est
requis, sinon le système ralentit avant de planter avec un programme qui
manque de mémoire.
</sect1>
</sect>

<sect>Configuration de Bash
<p>
Je modifie les scripts de démarrage à mon goût sur tout le système :
<example>
/etc/bash.bashrc        Remplace avec un script personnalisé
/etc/profile            Garde copie de la distribution ( \w -&gt; \W)
/etc/skel/.bashrc       Remplace avec une copie privée
/etc/skel/.profile      Remplace avec une copie privée
/etc/skel/.bash_profile Remplace avec une copie privée
~/.bashrc           Remplace avec une copie privée pour tous les comptes
~/.profile          Remplace avec une copie privée pour tous les comptes
~/.bash_profile     Remplace avec une copie privée pour tous les comptes
</example>
<url id="examples/" name="Voir détails dans mon exemple."> 
J'aime les systèmes transparents, j'ai donc paramétré umask à 002 ou 022.
<p>
<tt>PATH</tt> est paramétré par les fichiers de configuration suivants, dans
cet ordre.
<example>
/etc/login.defs  - avant que le shell paramètre PATH
/etc/profile     (peut appeler /etc/bash.bashrc)
~/.bash_profile  (peut appeler ~/.bashrc)
</example>
</sect>

<sect>Configuration de la souris 
<p>
<sect1>Souris PS/2
<p>
Dans le cas d'un connecteur de souris de type PS/2 sur une carte mère ATX, la
succession de signaux sera&nbsp;:
<example>
mouse -&gt; /dev/psaux -&gt; gpm -&gt; /dev/gpmdata = /dev/mouse -&gt; X
</example>
Ici, un lien symbolique <file>/dev/mouse</file> est créé et pointe vers
<file>/dev/gpmdata</file> pour accomoder certains utilitaires de configuration
et faciliter la reconfiguration.
<p>
Cette succession de signaux permet au clavier ou à la souris d'être déconnecté
et réinitialisé en redémarrant <prgn>gpm</prgn> après reconnexion. X restera
activé !
<p>
Le protocole du signal entre la sortie de <prgn>gpm</prgn> et l'entrée de X
peut être implémenté de deux façons, soit "ms3" (protocole des souris séries
Microsoft à 3 boutons) soit "brut" (protocole de la souris connectée), et ce
choix impose le choix du protocol utilisé pour configurer X.
<p>
Voici des exemples de configuration pour les souris Logitech 3 boutons
PS/2,(souris Unix traditionnelle).

<sect2 id="gpmms3">Le protocole ms3
<p>
<example>
/etc/gpm.conf                 /etc/X11/X86Config ou X86Config4
=============================================================
device=/dev/psaux		Section "Pointer"
responsiveness=			Protocol    "IntelliMouse"
repeat_type=ms3			Device      "/dev/mouse"
type=autops2
append=""
</example>
Si cette approche est utilisée, l'ajustement du type de souris est fait
simplement en éditant le fichier <file>gpm.conf</file> et la configuration de
X reste la même.
<p>
Si une souris PS/2 à 2 boutons normale est utilisée, configurez le protocole X
à <tt>Microsoft</tt> et activez <tt>Emulate3Buttons</tt>.

<sect2 id="gpmraw">Le protocole brut
<p>
<example>
etc/gpm.conf               /etc/X11/X86Config or X86Config-4
=============================================================
device=/dev/psaux		Section "Pointer"
responsiveness=			Protocol    "IntelliMouse"
repeat_type=raw			Device      "/dev/mouse"
type=autops2
append=""
</example>
Si vous utilisez cette approche, l'ajustement du type de souris est fait en
éditant le fichier <file>gpm.conf</file> et en ajustant la configuration de X.
<p>
Si une souris normale à 2 boutons PS/2 est utilisée, configurez le protocole X
à <tt>PS/2</tt> et activez <tt>Emulate3Buttons</tt>.
<p>
Si vous décidez de ne pas utiliser le démon <prgn>gpm</prgn> avec X, pointez
simplement le lien symbolique <file>/dev/mouse</file> vers
<file>/dev/psaux</file> après avoir stoppé le démon <prgn>gpm</prgn>.

<sect2>Comment adapter différentes souris
<p>
Si vous utilisez une version de <prgn>gpm</prgn> antérieure à Woody, utilisez
<tt>ps2</tt> à la place de <tt>autops2</tt> dans <file>gpm.conf</file>. Le
type de périphérique <tt>autops2</tt> est supposé détecter la plupart des
souris PS/2 du marché. Pour trouver les types de souris disponibles, tapez
<tt>gpm -t help</tt>. Pour certaines souris à roulette sur port PS/2,
l'utilisation de <tt>imps2</tt> dans <file>gpm.conf</file> aidera.
<p>
Pour <prgn>gpm</prgn>, la différence de protocole entre une souris 2 boutons
et une souris 3 boutons est détectée automatiquement et ajustée.
<p>
Pour certains portables Toshiba récents&nbsp;: activez <prgn>gpm</prgn> avant
PCMCIA dans le script d'initialisation System-V. Ceci évite à
<prgn>gpm</prgn> de planter. Étrange, mais vrai.
<p>
Lorsque <ref id="gpmraw"> est utilisé, la configuration de X doit être ajustée
au protocole réel de la souris. Pour une souris à roulette typique, utilisez
<tt>IMPS/2</tt>.
<p>
<url id="examples/" name="Voir mes exemples de scripts pour des détails"> et
<manref name="gpm" section="8">.

<sect1>Souris USB
<p>
Assurez vous d'avoir&nbsp;:
<list compact>
<item>«&nbsp;Input Core Support&nbsp;» et «&nbsp;Input Core Support/Mouse
Support&nbsp;» activés dans le noyau ou en modules.
<item>«&nbsp;Support for USB&nbsp;», «&nbsp;Preliminary USB device
filesystem&nbsp;», «&nbsp;UHCI&nbsp;» ou «&nbsp;OHCI&nbsp;» et «&nbsp;USB HID
Support&nbsp;» activés dans le noyau ou en modules.
</list>
<p>
Si vous n'utilisez pas devfs, créez une node de périphérique
<file>/dev/input/mice</file> avec comme major 13 et minor 63, comme
suit&nbsp;:
<example>
# cd /dev
# mkdir input
# mknod input/mice c 13 63
</example>
<p>
Pour les souris à 3 boutons Logitech, la configuration devrait être&nbsp;:
<example>
/etc/gpm.conf                 /etc/X11/X86Config or X86Config-4
===============================================================
device=/dev/input/mice        Section "InputDevice"
responsiveness=                 Option "Protocol" "ImPS/2"
repeat_type=ms3                 Option "Device" "/dev/input/mice"
type=ps2                        Option "ZAxisMapping" "4 5"
append=""                     EndSection
</example>
[Cette section sur les souris USB a été écrite par Jan Michael C Alonzo
<email>jmalonzo@softhome.net</email>.]
<p>
Pour Woody, repeat_type=raw, type=autops2, et pointer "Device" vers
<file>/dev/gpmdata</file> dans la configuration de X11 peut marcher (Osamu,
non testé).
<p>
Voir <url id="&linuxusb;" name="Linux USB Project"> pour plus d'information.
</sect>

<sect>Configuration NFS
<p>
Configurer NFS dans <file>/etc/exports</file>.
<example>
# echo "/ *.domainname-for-lan-hosts(rw,no_root_squash,nohide)" \
        &gt;&gt; /etc/exports
</example>
<url id="examples/" name="Voir détails dans mon exemple.">.
</sect>

<sect id="samba">Configuration Samba
<p>
Références&nbsp;:
<list compact>
<item><url id="&sambahome;">
<item>paquet <package>samba-doc</package>
</list>
<p>
Configurer Samba en mode «&nbsp;partage&nbsp;» est plus facile pour créer un
partage du disque de type WfW. Mais il est mieux de le configurer en mode
«&nbsp;utilisateur&nbsp;». 
<p>
Samba peut être configuré à l'aide de <prgn>debconf</prgn> ou
<prgn>vi</prgn>&nbsp;:
<example>
# dpkg-reconfigure --priority=<var>low</var> samba # dans Woody
# vi /etc/samba/smb.conf
</example>
<url id="examples/" name="Voir détails dans mon script d'exemple.">
<p>
Ajouter un nouvel utilisateur au fichier smbpasswd peut être fait par
<prgn>smbpasswd</prgn>&nbsp;:
<example>
$su -c "smbpasswd -a username"
</example>
Assurez-vous de l'utilisation des mots de passe cryptés pour une meilleure
compatibilité.
<p>
Le rang de l'OS signifie ce qui suit et plus grand est le nombre, plus haute
est la priorité du serveur.
<example>
0:      Samba avec des comportements relâchés
1:      Wfw 3.1, Win95, Win98, Win/me?
16:     Win NT WS 3.51
17:     Win NT WS 4.0
32:     Win NT SVR 3.51
33:     Win NT SVR 4.0
255:    Samba avec beaucoup de puissance
</example>
Assurez-vous que les utilisateurs sont membres du groupe possédant le
répertoire qui est partagé et que le bit d'exécution du répertoire est
positionné à accès.
</sect>

<sect>Configuration de l'imprimante 
<p>
La méthode traditionnelle est d'utiliser <prgn>lpr</prgn>/<prgn>lpd</prgn>. Il
existe un nouveau système, CUPS&trade; (Common UNIX Printing System). PDQ est
une autre approche. Voir le <url id="&printing-howto;" name="Linux Printing
HOWTO"> pour plus d'information.

<sect1 id="lprlpd"><prgn>lpr</prgn>/<prgn>lpd</prgn>
<p>
Pour les <em>spoolers</em> comme <prgn>lpr</prgn>/<prgn>lpd</prgn> (paquets
<package>lpr</package>, <package>lprng</package>, et
<package>gnulpr</package>), configurez <file>/etc/printcap</file> comme suit
s'ils sont connectés à une imprimante PostScript ou texte&nbsp;:
<example>
<var>lp</var>|<var>alias</var>:\
	:sd=/var/spool/lpd/<var>lp</var>:\
	:mx#0:\
	:sh:\
	:lp=/dev/lp0:
</example>
Signification des lignes ci-dessus&nbsp;:
<list compact>
<item>En-tête&nbsp;:  <var>lp</var> &mdash; nom de la queue, <var>alias</var>
= alias
<item>mx#0 &mdash; taille de fichier maximum illimitée
<item>sh &mdash; suppression de l'impression de la première page d'en-tête
<item>lp=/dev/lp0 &mdash; périphérique local, ou port@host pour une machine
distante
</list>
C'est une bonne configuration si vous utilisez une imprimante PostScript. De
plus, lors de l'impression depuis une machine Windows avec Samba, c'est une
bonne configuration pour n'importe quelle imprimante supportée par Windows
(communication bi-directionnelle non supportée). Il faut sélectionner
l'imprimante correspondante sous Windows.
<p>
Si vous n'avez pas d'imprimante PostScript, il faut configurer un système de
filtre avec <prgn>gs</prgn>. Il existe beaucoup d'outils d'auto-configuration
pour configurer <file>/etc/printcap</file>.
Voici quelques options&nbsp;:
<list compact>
<item><package>gnulpr</package>, (<package>lpr-ppd</package>) et 
  <package>printtool</package> &mdash; j'utilise celle-là.
  <item><package>lpr</package> et <package>apsfilter</package>
  <item><package>lpr</package> et <package>magicfilter</package>
  <item><package>lprng</package> et <package>lprngtool</package>
  <item><package>lprng</package> et <package>apsfilter</package>
  <item><package>lprng</package> et <package>magicfilter</package>
  <!-- I can think of more combinations but I add them if someone  
    actually report me they got it working with them.  -->
</list>
<p>
Pour exécuter des outils de configuration graphiques comme
<prgn>printtool</prgn>, voir <ref id="ss-xsu"> pour obtenir les privilèges de
root. Les queues d'imprimante créées avec <prgn>printtool</prgn> utilisent
<prgn>gs</prgn> et agissent comme des imprimantes PostScript. Donc, lorsque
vous y accédez, utilisez des pilotes PostScript. Du côté de Windows,
«&nbsp;Apple LaserWriter&nbsp;» est le standard.
</sect1>

<sect1 id="cups">CUPS&trade
<p>
Installez le Système d'Impression Commun pour UNIX (Common UNIX Printing
System, ou CUPS&trade;)&nbsp;:
<example>
# apt-get install cupsys cupsomatic-ppd 
# apt-get install cupsys-bsd cupsys-driver-gimpprint
</example>
<!-- CUPS dependencies: Recommends are installed automatically -->
<p>
Ensuite, configurez le système avec n'importe quel navigateur Web&nbsp;:
</p>
<p>
<example>
$ <var>mybrowser</var> http://localhost:631
</example>
</p>
</sect1>
</sect>

<sect>Autres conseils de configuration de l'hôte

<sect1>Installer quelques paquets supplémentaires après l'installation
<p>
Une fois rendu à ce point, vous avez un système &debian; petit mais
fonctionnel. Il est temps d'installer des paquets plus gros.
<list>
<item>Lancez <prgn>tasksel</prgn>. Voir <ref id="tasksel">.
<p>
Vous pouvez choisir ces options si vous en avez besoin&nbsp;:
<list compact>
<item>Utilisateur &mdash; X window system
<item>Développement &mdash; C et C++
<item>Développement &mdash; Python
<item>Développement &mdash; Tcl/Tk
<item>Divers &mdash; environnement TeX/LaTeX
<item>Pour les autres &mdash; je préfère utiliser <prgn>tasksel</prgn> comme
guide en regardant les composants listés dans «&nbsp;Task Info&nbsp;» et en
les installant manuellement avec <prgn>dselect</prgn>.
</list>

<item>Lancez <prgn>dselect</prgn>.
<p>
Là, la première chose à faire est de sélectionner votre éditeur de texte
favori, et tout programme dont vous avez besoin. Vous pouvez installer
plusieurs variantes d'Emacs en même temps. Voir <ref id="dselect"> et <ref
id="pop-editor">.
<p>
De plus, vous pouvez remplacer des paquets par défaut avec d'autres ayant plus
d'options.
<list compact>
<item>lynx-ssh (à la place de lynx)
<item>... <!-- Add list in generic way. -->
</list>
<item>...
</list>

J'édite habituellement <file>/etc/inittab</file> pour éteindre plus facilement
ma machine.
<example>
...
# Que faire lorsque CTRL-ALT-DEL est pressé.
ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -h now
...
</example>
</sect1>

<sect1>Modules
<p>
Les modules pour les pilotes de périphériques sont configurés lors de
l'installation initiale. <prgn>modconf</prgn> permet de configurer les modules
ensuite au travers d'une interface utilisant des menus. Ce programme est utile
lorsque des modules ont été oubliés lors de l'installation ou lorsqu'un
nouveau noyau est installé.
<p>
Le nom des modules à précharger est listé dans <file>/etc/modules</file>.
J'utilise <prgn>lsmod</prgn> et <prgn>depmod</prgn> pour les contrôler
manuellement.
<p>
De plus, assurez-vous d' ajouter quelques lignes dans
<file>/etc/modules</file> pour mettre en route ip-masquerading (ftp etc.) pour
les noyaux 2.4. Voir <ref id="kernel-modules">, et notamment <ref
id="kernel-net">.

</sect1>

<sect1>Configuration de base de CD-RW 
<p>
Éditer les fichiers suivants&nbsp;:
<example>
/etc/lilo.conf  (ajouter append="hdc=ide-scsi", 
                 lancer lilo pour activer)
/dev/cdrom      (lien relatif # cd /dev; ln -sf scd0 cdrom)
/etc/modules    (ajouter "ide-scsi" et "sg".  Si besoin est "sr" 
                 après cela.)
</example>
Voir <ref id="cdrw"> pour les détails.
</sect1>

<sect1 id="apm">Grande capacité mémoire et arrêt automatique 
<p>
Éditer <file>/etc/lilo.conf</file> comme suit pour configurer les paramètres
de démarrage pour une grande capacité mémoire (pour les noyaux 2.2) et
l'arrêt automatique (pour apm)&nbsp;:
<example>
append="mem=128M apm=on apm=power-off"
</example>
Lancer <prgn>lilo</prgn> pour installer cette configuration.
<tt>apm=power-off</tt> est requis pour un noyau multiprocesseur (SMP).  La même
chose peut être faite directement à l'invite de démarrage. Voir <ref
id="bootprompt">.
<p>
Si apm est compilé comme module comme c'est le cas par défaut dans les noyaux
2.4 de Debian, lancez <tt># insmod apm power_off=1</tt> après le boot ou
configurez <file>/etc/modules</file> par :
<example>
# echo "apm power_off=1" &gt;&gt;/etc/modules
</example>
<p>
Autrement, compiler le support ACPI permet d'atteindre le même
but avec les nouveaux noyaux et semble plus compatible avec SMP (requiert une
carte mère récente).  Le noyau 2.4 avec une carte mère récente devrait
correctement détecter les grandes capacité mémoire.
<example>
CONFIG_PM=y
CONFIG_ACPI=y
...
CONFIG_ACPI_BUSMGR=m
CONFIG_ACPI_SYS=m
</example>
et ajouter les lignes suivantes dans <file>/etc/modules</file> selon cet ordre.
<example>
ospm_busmgr
ospm_system
</example>
ou recompiler le noyau avec toutes les options ci-dessus en cochant
«&nbsp;y&nbsp;». Dans tous les cas, avec ACPI, aucun des paramètres de
l'invite de démarrage n'est requis.
</sect1>

<sect1 id="killecn">Étranges problèmes d'accès à certains sites web
<p>
Les noyaux Linux récents activent ECN par défaut, ce qui peut causer des
problèmes d'accès à certains sites web situés derrière de mauvais routeurs.
Pour vérifier l'état d'ECN&nbsp;
<example>
# cat /proc/sys/net/ipv4/tcp_ecn
 ... ou
# sysctl net.ipv4.tcp_ecn
</example>
Pour le désactiver, utilisez&nbsp;
<example>
# echo "0" > /proc/sys/net/ipv4/tcp_ecn
 ... ou
# sysctl -w net.ipv4.tcp_ecn=0
</example>
Pour désactiver TCP ECN à chaque démarrage, éditer
<file>/etc/sysctl.conf</file> et ajouter&nbsp;:
<example>
net.ipv4.tcp_ecn = 0
</example>
</sect1>

<sect1>Configuration d'une connexion RTC avec PPP
<p>
Installer le paquet <package>pppconfig</package> pour configurer l'accès par
PPP.
<example>
# apt-get install pppconfig
# pppconfig
 ... suivez les indications pour configurer PPP
# adduser <var>user_name</var> dip
 ... autorise <var>user_name</var> à appeler avec PPP
</example>
Un accès PPP peut être initié par l'utilisateur (<var>user_name</var>)&nbsp;:
<example>
$ pon <var>ISP_name</var>   # démarre l'accès PPP au FAI
 ... amusez-vous bien sur l'Internet
$ poff <var>ISP_name</var> # arrête l'accès PPP, <var>ISP_name</var> est
optionnel
</example>
Voir <file>&f-ppp-readme;</file> pour plus de détails.
<p>
D'une autre façon, le paquet <package>wvdial</package> peut être utilisé pour
configurer l'accès PPP.
</sect1>

<sect1>Autre configuration à vérifier dans <file>/etc</file>
<p>
Vous pouvez avoir envie d'ajouter un fichier <file>/etc/cron.deny</file>, qui
manque dans l'installation standard de Debian (vous pouvez copier
<file>/etc/at.deny</file>).
</sect1>

</sect>

</chapt>



