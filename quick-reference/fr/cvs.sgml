<!-- CVS revision of this document "$Revision: 1.10 $"  -->
<!-- CVS revision of original english document "1.23"  -->
<chapt id="cvs">CVS
<p>
Consultez <file>/usr/share/doc/cvs/html-cvsclient</file>,
<file>/usr/share/doc/cvs/html-info</file>, <file>/usr/share/doc/cvsbook</file>
avec lynx ou lancez <tt>info cvs</tt> et <tt>man cvs</tt> pour de l'information
détaillée.

<sect id="cvs-inst">Installation d'un serveur CVS
<p>
La configuration suivante autorise un enregistrement sur le dépôt CVS seulement par
un membre du groupe «&nbsp;src&nbsp;», et l'administration de cvs seulement par un membre
du groupe «&nbsp;staff&nbsp;», ceci afin de réduire les risques de conflits.
<example>
# cd /var/lib; umask 002 ; sudo mkdir cvs # [Woody] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=<var>/var/lib/cvs</var>
# cd $CVSROOT
# chown root:src .  # utiliser «&nbsp;staff&nbsp;» pour restreindre plus pour un projet débutant      
# chmod 3775 .      # si la ligne précédente utilise «&nbsp;staff&nbsp;», alors régler sur 2775
# cvs -d <var>/var/lib/cvs</var> init # il est plus prudent de spécifier -d explicitement ici&nbsp;!
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect>

<sect id="cvs-examples">Exemples de sessions CVS
<p>
Ce qui suit configure les environnements de shell pour l'accès au dépôt CVS.

<sect1>CVS anonyme (téléchargement seulement)
<p>
Accès distant en lecture seule&nbsp;:
<example>
$ export CVSROOT=:pserver:<var>anonymous@cvs.qref.sf.net:/cvsroot/qref</var>
$ cvs login
$ cvs -z3 co <var>qref</var>
</example>
</sect1>

<sect1>Utilisation d'un serveur CVS local 
<p>
Accès local depuuis un shell sur la même machine&nbsp;:
<example>
$ export CVSROOT=<var>/var/lib/cvs</var>
</example>
</sect1>

<sect1>Utilisation d'un pserver CVS distant
<p>
Accès distant sans SSH (utilise le protocole RSH de <prgn>cvs</prgn>)&nbsp;:
<example>
$ export CVSROOT=:pserver:<var>account@cvs.foobar.com:/var/lib/cvs</var>
$ cvs login
</example>
Cela peut être sujet à des attaques d'écoute de ligne.
</sect1>

<sect1>Utilisation d'un CVS distant avec <prgn>ssh</prgn>
<p>
Accès distant avec SSH&nbsp;:
<example>
$ export CVSROOT=:ext:<var>account@cvs.foobar.com:/var/lib/cvs</var>
</example>
ou pour SourceForge&nbsp;:
<example>
$ export CVSROOT=:ext:<var>account@cvs.qref.sf.net:/cvsroot/qref</var>
</example>
Vous pouvez aussi utiliser l'authentification RSA (<ref id="ssh-rsa">), qui
élimine la demande du mot de passe.
</sect1>

<sect1>Créer une nouvelle archive CVS
<p>
Pour,
<example>
OBJET               VALEUR           SIGNIFICATION
Arbre source&nbsp;:      ~/<var>project-x</var>       Tous le code source
Nom du Projet&nbsp;:     <var>project-x</var>         Nom pour ce projet
Balise vendeur&nbsp;:    <var>Main-branch</var>       Balise pour la branche entière
Balise de version&nbsp;: <var>Release-original</var>  Balise pour une version spécifique
</example>
Ensuite,
<example>
$ cd ~/<var>project-x</var>                 # va dans le répertoire du source
 ... crée un arbre source ...
$ cvs import -m <var>"Start project-x" project-x Main-branch Release-initial</var>
$ cd ..; rm -R ~/<var>project-x</var>
</example>
</sect1>

<sect1>Travailler avec CVS
<p>
Pour travailler avec <var>project-x</var> en utilisant le dépôt CVS local&nbsp;:
<example>
$ cd                            # va à la zone de travail.
$ cvs co <var>project-x</var>              # importe les sources du CVS en local
$ cd<var>project-x</var> 
 ... effectuez des changements au contenu ...
$ cvs diff -u                   # similaire à diff -u repository/ local/
$ cvs ci -m "<var>Décrire les changements</var>"   # sauvegarde les sources locales sur CVS
$ vi <var>newfile_added</var>
$ cvs add <var>newfile_added</var>
$ cvs ci -m "<var>Ajout de newfile_added</var>"
$ cvs up                        # récupère la dernière version du CVS
 ... attention aux lignes commençant par "C <var>filename</var>"
 ... le code non modifié est déplacé vers `.#<var>filename</var>.version'.
 ... rechercher "&lt;&lt;&lt;&lt;&lt;&lt;&lt;" et "&gt;&gt;&gt;&gt;&gt;&gt;&gt;" dans <var>filename</var>.
$ cvs tag <var>Release-1</var>             # ajoute une balise de version
... modifiez un peu plus ...
$ cvs tag -d <var>Release-1</var>          # enlève une balise de version
$ cvs ci -m "<var>commentaires supplémentaires</var>"
$ cvs tag <var>Release-1</var>             # rajoute une balise de version
$ cd                            # retourne à la zone de travail.
$ cvs co -r <var>Release-initial</var> -d <var>old</var> <var>project-x</var>
... récupère la version originale dans le répertoire <var>old</var>
$ cd old
$ cvs tag -b <var>Release-initial-bugfixes</var> # création d'une branche (-b)
 ... Maintenant vous pouvez travailler sur l'ancienne version (Tag=sticky)
$ cvs update
 ... L'arbre des sources a maintenant la balise permanente "Release-initial-bugfixes"
 ... Travaillez sur cette branche
$ cvs up # synchronise avec les autres développeurs de la branche
$ cvs ci -m "<var>ajout à la branche</var>"
$ cvs update -kk -A
 ... Enlève la balise collante et oublie le contenu
 ... Met à jour depuis le tronc principal sans le remplacement des mots-clé
$ cvs update -kk -j <var>Release-initial-bugfixes</var>
 ... Ajoute la branche <var>Release-initial-bugfixes</var> au tronc principal
 ... sans le remplacement des mots-clé. Réparez les conflits avec un éditeur
$ cvs ci -m "<var>merge Release-initial-bugfixes</var>"
$ cd
$ tar -cvzf <var>old-project-x.tar.gz</var> <var>old</var>     # crée une archive, -j pour bz2
$ cvs release -d <var>old</var>               # supprimez les sources locales (optionnel)
</example>
Options utiles à se rappeler (premier argument de <prgn>cvs</prgn>)&nbsp;:
<example>
-n      lancement sec, sans effet
-t      message des étapes de l'activité cvs
</example>
</sect1>

<sect1>Exportation de fichiers à partir de CVS
<p>
Pour avoir la dernière version par CVS, utiliser «&nbsp;tomorrow&nbsp;»&nbsp;:
<example>
$ cvs ex -D tomorrow <var>module_name</var>
</example>
</sect1>

<sect1>Administrer CVS
<p>
Ajouter un alias à un projet (serveur local)&nbsp;:
<example>
$ su - admin           # un membre de l'équipe
$ export CVSROOT=<var>/var/lib/cvs</var>
$ cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "<var>px</var> -a <var>project-x</var>" &gt;&gt;modules
$ cvs ci -m "<var>Maintenant px est un alias pour project-x</var>"
$ cvs release -d .
$ exit                 # control-D pour quitter su
$ cvs co -d <var>project</var> <var>px</var>
 ... récupère <var>project-x</var> (alias:<var>px</var>) de CVS vers le répertoire du projet
$ cd project
 ... faites les changements de contenu ...
</example>
</sect1>
</sect>

<sect id="cvs-trouble">Résoudre les problèmes de CVS

<sect1>Permissions de fichiers dans le dépôt
<p>
CVS ne va pas écraser le fichier du dépôt courant mais va le remplacer par un
autre.  Ainsi, <em>la permission en écriture sur le répertoire de dépôt</em>
est critique.  Pour chaque nouvelle création d'un dépôt, lancez ce qui suit
pour vous assurer que cette condition et remplie.
<example>
# cd <var>/var/lib/cvs</var>
# chown -R root:src <var>repository</var>
# chmod -R ug+rwX   <var>repository</var>
# chmod    2775     <var>repository</var> # si besoin est, ça et les sous-répertoires
</example>
</sect1>

<sect1>Bit d'exécution 
<p>
Le bit d'exécution de fichier est conservé lorsqu'on quitte la session.  Si on
observe n'importe quel problème de permission d'exécution dans les fichiers de
contrôle, on peut changer la permission sur ce fichier dans le dépôt CVS avec
la commande suivante.
<example>
# chmod ugo-x <var>filename</var>
</example>
</sect1>

</sect>

<sect id="cvs-short">Commandes CVS
<p>
Voici les commandes CVS avec leurs raccourcis.
<example>
{add|ad|new} [-k kflag] [-m 'message'] files...
{admin|adm|rcs} [rcs-options] files...
{annotate|ann} [options] [files...]
{checkout|co|get} [options] modules...
{commit|ci|com}   [-lnR]  [-m  'log_message'  |  -f  file] \
        [-r revision] [files...]
{diff|di|dif} [-kl] [rcsdiff_options] [[-r rev1 | -D date1] \
        [-r rev2 |  -D date2]] [files...]
{export|ex|exp} [-flNn] -r rev|-D date [-d dir] [-k kflag] module...
{history|hi|his} [-report] [-flags] [-options args] [files...]
{import|im|imp} [-options] repository vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] rlog-options [files...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...
{release|re|rel} [-d] directories...
{remove|rm|delete} [-lR] [files...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  tag  |  -D  date] \
         symbolic_tag modules...
{status|st|stat} [-lR] [-v] [files...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r tag | -D date]  [-f] \
         symbolic_tag [files...]
{update|up|upd} [-AdflPpR] [-d] [-r tag|-D date] files...
</example>
</sect>

</chapt>
