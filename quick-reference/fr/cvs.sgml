<!-- CVS revision of this document "$Revision: 1.8 $"  -->
<!-- CVS revision of original english document "1.16"  -->
<chapt id="cvs">CVS
<p>
Consultez <file>/usr/share/doc/cvs/html-cvsclient</file>,
<file>/usr/share/doc/cvs/html-info</file>, <file>/usr/share/doc/cvsbook</file>
avec lynx ou lancez <tt>info cvs</tt> et <tt>man cvs</tt> pour de l'information
détaillée.

<sect id="cvs-inst">Installation d'un serveur CVS
<p>
La configuration suivante autorise un "commit" sur le dépôt cvs seulement par
un membre du groupe "src", et l'administration de cvs seulement par un membre
du groupe "staff", ceci afin de réduire les risques de conflits.
<example>
# cd /var/lib; umask 002 ; sudo mkdir cvs # [WOODY] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=/var/lib/cvs
# cd $CVSROOT
# chown root:src .         
        # "staff" => restriction importante pour un projet débutant.
# chmod 3775 .
        # Si la ligne précédente utilise "staff", alors régler sur 2775
# cvs -d=/var/lib/cvs init 
        # il est plus prudent de spécifier explicitement -d ici !
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect>

<sect id="cvs-examples">Exemples de sessions CVS

<sect1>CVS anonyme (téléchargement seulement)
<p>
<example>
$ export CVSROOT=:pserver:anonymous@cvs.qref.sf.net:/cvsroot/qref
$ cvs login
$ cvs -z3 co qref
</example>
</sect1>

<sect1>Utilisation d'un serveur CVS local 
<p>
<example>
$ export CVSROOT=/var/lib/cvs
</example>
</sect1>

<sect1>Utilisation d'un pserver CVS distant
<p>
Ceci n'est pas très sûr, mais convenable pour du CVS anonyme :
<example>
$ export CVSROOT=:pserver:account@cvs.foobar.com:/var/lib/cvs
$ cvs login
</example>
</sect1>

<sect1>Utilisation d'un CVS distant avec <prgn>ssh</prgn>
<p>
Vous pouvez aussi utiliser l'authentification RSA (<ref id="ssh-rsa">) qui
élimine la demande du mot de passe.
<example>
$ export CVSROOT=:ext:account@cvs.foobar.com:/var/lib/cvs
</example>
ou pour SourceForge :
<example>
$ export CVSROOT=:ext:account@cvs.qref.sf.net:/cvsroot/qref
</example>
</sect1>

<sect1>Créer une nouvelle archive CVS
<p>
Pour,
<example>
OBJET               VALEUR           SIGNIFICATION
Arbre source :      ~/projet-x       Tous les codes sources
Nom du Projet :     projet-x         Nom pour ce projet
Balise vendeur :    Main-branch      Balise pour la branche entière
Balise de version : Release-original Balise pour une version spécifique
</example>
Ensuite,
<example>
$ cd ~/projet-x                 # va dans le répertoire du source
 ... créer un arbre source ...
$ cvs import -m "Start projet-x" projet-x Main-branch Release-initial
$ cd ..; rm -R ~/projet-x
</example>
</sect1>

<sect1>Travailler avec CVS
<p>
Pour rappeler et travailler sur les sources locales de projet-x avec une
archive CVS :
<example>
$ cd                            # va à la zone de travail.
$ cvs co project-x              # importe les sources du CVS en local
$ cd project-x
 ... effectuez des changements au contenu ...
$ cvs diff -u                   # similaire à diff -u repository/ local/
$ cvs ci -m "Description"       # sauvegarde les sources locales sur CVS
$ vi newfile_added
$ cvs add newfile_added
$ cvs ci -m "Ajout de newfile_added"
$ cvs up                        # récupère la dernière version du CVS
$ cvs tag Release-1             # ajoute une balise de version
... modifiez un peu plus ...
$ cvs tag -d Release-1          # enlève une balise de version
$ cvs ci -m "commentaires supplémentaires"
$ cvs tag Release-1             # rajoute une balise de version
$ cd                            # retourne à la zone de travail.
$ cvs co -r Release-initial -d old project-x 
... récupère la version originale dans le répertoire old
$ cd old
$ cvs tag -b Release-initial-bugfixes # balise création d'une branche (-b)
 ... Maintenant vous pouvez travailler sur l'ancienne version
$ cvs update -r Release-initial-bugfixes
 ... L'arbre des sources a maintenant la balise permanente "Release-initial-bugfixes"
 ... Travaillez sur cette branche
$ cvs up # synchronise avec les autres développeurs de la branche
$ cvs ci -m "ajout à la branche"
$ cvs update -r HEAD # change la branche en tronc principal HEAD
$ cvs update -kk -j Release-initial-bugfixes
 ... Ajoute la branche au tronc principal sans le remplacement des mots clé
 ... fixez les conflits avec un éditeur
$ cvs ci -m "merge Release-initial-bugfixes into the main trunk"
$ cd
$ tar -cvzf old-project-x.tar.gz old     # créez une archive, -j pour bz2
$ cvs release -d old               # supprimez les sources locales (optionnel)
</example>
Options utiles à se rappeler (utiliser juste après <prgn>cvs</prgn>) :
<example>
-n      lancement sec, sans effet
-t      message des étapes de l'activité cvs
</example>
</sect1>

<sect1>Exportation de fichiers à partir de CVS
<p>
Pour avoir la dernière version par CVS, utiliser "tomorrow" :
<example>
$ cvs ex -D tomorrow module_name
</example>
</sect1>

<sect1>Administrer CVS
<p>
Ajouter un alias à un projet (serveur local) :
<example>
$ su - admin           # un membre de l'équipe
Password:
$ export CVSROOT=/var/lib/cvs ; cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "px -a project-x" &gt;&gt;modules
$ cvs ci -m "Now px is an alias for project-x"
$ cvs release -d .
$ exit                 # control-D pour quitter su
$ cvs co -d project px 
 ... projet-x (alias:px) de CVS au répertoire du projet
$ cd project
 ... faites les changements pour les contenus
</example>
</sect1>
</sect>

<sect id="cvs-trouble">Résoudre les problèmes de CVS

<sect1>Permissions de fichiers dans le dépôt
<p>
CVS ne va pas écraser le fichier du dépôt courant mais va le remplacer par un
autre.  Ainsi, <em>la permission en écriture sur le répertoire de dépôt</em>
est critique.  Pour chaque nouvelle création d'un dépôt, lancez ce qui suit
pour vous assurer que cette condition et remplie.
<example>
# cd /var/lib/cvs
# chown -R root:src repository
# chmod -R ug+rwX   repository
# chmod    2775     repository # si besoin est, ça et les sous-répertoires
</example>
</sect1>

<sect1>Bit d'exécution 
<p>
Le bit d'exécution de fichier est conservé lorsqu'on quitte la session.  Si on
observe n'importe quel problème de permission d'exécution dans les fichiers de
contrôle, on peut changer la permission sur ce fichier dans le dépôt CVS avec
la commande suivante.
<example>
# chmod ugo-x nom_du_fichier
</example>
</sect1>

</sect>

<sect id="cvs-short">Commandes CVS
<p>
<example>
{add|ad|new} [-k kflag] [-m 'message'] files...
{admin|adm|rcs} [rcs-options] files...
{annotate|ann} [options] [files...]
{checkout|co|get} [options] modules...
{commit|ci|com}   [-lnR]  [-m  'log_message'  |  -f  file] \
        [-r revision] [files...]
{diff|di|dif} [-kl] [rcsdiff_options] [[-r rev1 | -D date1] \
        [-r rev2 |  -D date2]] [files...]
{export|ex|exp} [-flNn] -r rev|-D date [-d dir] [-k kflag] module...
{history|hi|his} [-report] [-flags] [-options args] [files...]
{import|im|imp} [-options] repository vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] rlog-options [files...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...
{release|re|rel} [-d] directories...
{remove|rm|delete} [-lR] [files...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  tag  |  -D  date] \
         sym_bolic_tag modules...
{status|st|stat} [-lR] [-v] [files...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r tag | -D date]  [-f] \
         sym_bolic_tag [files...]
{update|up|upd} [-AdflPpR] [-d] [-r tag|-D date] files...
</example>
</sect>

</chapt>
