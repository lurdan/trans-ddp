<!-- CVS revision of this document "$Revision: 1.19 $"  -->
<!-- CVS revision of original english document "1.38"  -->
<!--Line width ruler (ruler uses 78 characters)     34567890123456789012345-->

<chapt id="vcs">Systèmes de contrôle de version

<sect id="cvs">Concurrent Versions System (CVS)
<p>
Consultez <file>/usr/share/doc/cvs/html-cvsclient</file>,
<file>/usr/share/doc/cvs/html-info</file>, <file>/usr/share/doc/cvsbook</file>
avec <prgn>lynx</prgn> ou lancez <tt>info cvs</tt> et <tt>man cvs</tt> pour de
l'information détaillée.

<sect1 id="cvs-inst">Installation d'un serveur CVS
<p>
La configuration suivante autorise un enregistrement sur le dépôt CVS
seulement par un membre du groupe «&nbsp;src&nbsp;», et l'administration de
cvs seulement par un membre du groupe «&nbsp;staff&nbsp;», ceci afin de
réduire les risques de conflits.
<example>
# cd <var>/var/lib</var>; umask 002; mkdir <var>cvs</var> # [Woody] FSH
# apt-get install cvs cvs-doc cvsbook
# export CVSROOT=<var>/var/lib/cvs</var>
# cd $CVSROOT
# chown root:src .  # utiliser « staff » pour restreindre plus
                      pour un projet débutant      
# chmod 3775 .      # si la ligne précédente utilise « staff »,
                      alors régler sur 2775
# cvs -d <var>/var/lib/cvs</var> init # il est plus prudent de spécifier
                                        -d explicitement ici !
# cd CVSROOT
# chown -R root:staff .
# chmod 2775 .
# touch val-tags 
# chmod 664 history val-tags
# chown root:src history val-tags
</example>
<p>
</sect1>

<sect1 id="cvs-examples">Exemples de sessions CVS
<p>
Ce qui suit configure les environnements de shell pour l'accès au dépôt CVS.

<sect2>CVS anonyme (téléchargement seulement)
<p>
Accès distant en lecture seule&nbsp;:
<example>
$ export CVSROOT=:pserver:<var>anonymous@cvs.sf.net:/cvsroot/qref</var>
$ cvs login
$ cvs -z3 co <var>qref</var>
</example>
</sect2>

<sect2>Utilisation d'un serveur CVS local 
<p>
Accès local depuuis un shell sur la même machine&nbsp;:
<example>
$ export CVSROOT=<var>/var/lib/cvs</var>
</example>
</sect2>

<sect2>Utilisation d'un pserver CVS distant
<p>
Accès distant sans SSH (utilise le protocole RSH de <prgn>cvs</prgn>)&nbsp;:
<example>
$ export CVSROOT=:pserver:<var>account@cvs.foobar.com:/var/lib/cvs</var>
$ cvs login
</example>
Cela peut être sujet à des attaques d'écoute de ligne.
</sect2>

<sect2>Utilisation d'un CVS distant avec <prgn>ssh</prgn>
<p>
Accès distant avec SSH&nbsp;:
<example>
$ export CVSROOT=:ext:<var>account@cvs.foobar.com:/var/lib/cvs</var>
</example>
ou pour SourceForge&nbsp;:
<example>
$ export CVSROOT=:ext:<var>account@cvs.sf.net:/cvsroot/qref</var>
</example>
Vous pouvez aussi utiliser l'authentification RSA (<ref id="ssh-rsa">), qui
élimine la demande du mot de passe.
</sect2>

<sect2>Créer une nouvelle archive CVS
<p>
Pour,
<example>
OBJET               VALEUR           SIGNIFICATION
Arbre source :      ~/<var>project-x</var>       Tous le code source
Nom du Projet :     <var>project-x</var>         Nom pour ce projet
Balise vendeur :    <var>Main-branch</var>       Balise pour la branche entière
Balise de version : <var>Release-original</var>  Balise pour une version spécifique
</example>
Ensuite,
<example>
$ cd ~/<var>project-x</var>                 # va dans le répertoire du source
 ... crée un arbre source ...
$ cvs import -m <var>"Start project-x" project-x Main-branch Release-initial</var>
$ cd ..; rm -R ~/<var>project-x</var>
</example>
</sect2>

<sect2>Travailler avec CVS
<p>
Pour travailler avec <var>project-x</var> en utilisant le dépôt CVS local&nbsp;:
<example>
$ cd                            # va à la zone de travail.
$ cvs co <var>project-x</var>              # importe les sources du CVS en local
$ cd<var>project-x</var> 
 ... effectuez des changements au contenu ...
$ cvs diff -u                   # similaire à diff -u repository/ local/
$ cvs up -C <var>modified_file</var>       # undo changes to a file
$ cvs ci -m "<var>Décrire les changements</var>"   # sauvegarde les sources locales
                                          sur CVS
$ vi <var>newfile_added</var>
$ cvs add <var>newfile_added</var>
$ cvs ci -m "<var>Ajout de newfile_added</var>"
$ cvs up                        # récupère la dernière version du CVS
 ... pour créer les sous-répertoires récemment ajoutés, utilisez
 ... "cvs up -d -P" à la place
 ... attention aux lignes commençant par "C <var>filename</var>"
 ... le code non modifié est déplacé vers `.#<var>filename</var>.version'
 ... rechercher "&lt;&lt;&lt;&lt;&lt;&lt;&lt;" et "&gt;&gt;&gt;&gt;&gt;&gt;&gt;" dans <var>filename</var>
$ cvs tag <var>Release-1</var>             # ajoute une balise de version
... modifiez un peu plus ...
$ cvs tag -d <var>Release-1</var>          # enlève une balise de version
$ cvs ci -m "<var>commentaires supplémentaires</var>"
$ cvs tag <var>Release-1</var>             # rajoute une balise de version
$ cd                            # retourne à la zone de travail.
$ cvs co -r <var>Release-initial</var> -d <var>old</var> <var>project-x</var>
... récupère la version originale dans le répertoire <var>old</var>
$ cd old
$ cvs tag -b <var>Release-initial-bugfixes</var> # création d'une branche (-b)
 ... maintenant vous pouvez travailler sur l'ancienne version (Tag=sticky)
$ cvs update
 ... l'arbre des sources a maintenant la balise permanente
     "Release-initial-bugfixes"
 ... travaillez sur cette branche
$ cvs up # synchronise avec les autres développeurs de la branche
$ cvs ci -m "<var>ajout à la branche</var>"
$ cvs update -kk -A
 ... enlève la balise collante et oublie le contenu
 ... met à jour depuis le tronc principal sans le remplacement des mots-clé
$ cvs update -kk -j <var>Release-initial-bugfixes</var>
 ... fusionne la branche <var>Release-initial-bugfixes</var> avec le tronc principal
 ... sans le remplacement des mots-clé.
     Réparez les conflits avec un éditeur
$ cvs ci -m "<var>merge Release-initial-bugfixes</var>"
$ cd
$ tar -cvzf <var>old-project-x.tar.gz</var> <var>old</var>     # crée une archive, -j pour bz2
$ cvs release -d <var>old</var>     # supprimez les sources locales (optionnel)
</example>
Options utiles à se rappeler (premier argument de <prgn>cvs</prgn>)&nbsp;:
<example>
-n      lancement sec, sans effet
-t      message des étapes de l'activité cvs
</example>
</sect2>

<sect2>Exportation de fichiers à partir de CVS
<p>
Pour avoir la dernière version par CVS, utiliser «&nbsp;tomorrow&nbsp;»&nbsp;:
<example>
$ cvs ex -D tomorrow <var>module_name</var>
</example>
</sect2>

<sect2>Administrer CVS
<p>
Ajouter un alias à un projet (serveur local)&nbsp;:
<example>
$ su - admin           # un membre de l'équipe
$ export CVSROOT=<var>/var/lib/cvs</var>
$ cvs co CVSROOT/modules
$ cd CVSROOT
$ echo "<var>px</var> -a <var>project-x</var>" &gt;&gt;modules
$ cvs ci -m "<var>Maintenant px est un alias pour project-x</var>"
$ cvs release -d .
$ exit                 # Ctrl-D pour quitter su
$ cvs co -d <var>project</var> <var>px</var>
 ... récupère <var>project-x</var> (alias:<var>px</var>) de CVS vers le répertoire du projet
$ cd project
 ... faites les changements de contenu ...
</example>
</sect2>

<sect1 id="cvs-trouble">Résoudre les problèmes de CVS

<sect2>Permissions de fichiers dans le dépôt
<p>
CVS ne va pas écraser le fichier du dépôt courant mais va le remplacer par un
autre.  Ainsi, <em>la permission en écriture sur le répertoire de dépôt</em>
est critique.  Pour chaque nouvelle création d'un dépôt, lancez ce qui suit
pour vous assurer que cette condition et remplie.
<example>
# cd <var>/var/lib/cvs</var>
# chown -R root:src <var>repository</var>
# chmod -R ug+rwX   <var>repository</var>
# chmod    2775     <var>repository</var> # si besoin est, ça et les sous-répertoires
</example>
</sect2>

<sect2>Bit d'exécution 
<p>
Le bit d'exécution de fichier est conservé lorsqu'on quitte la session.  Si on
observe n'importe quel problème de permission d'exécution dans les fichiers de
contrôle, on peut changer la permission sur ce fichier dans le dépôt CVS avec
la commande suivante.
<example>
# chmod ugo-x <var>filename</var>
</example>
</sect2>

</sect1>

<sect1 id="cvs-short">Commandes CVS
<p>
Voici les commandes CVS avec leurs raccourcis.
<example>
{add|ad|new} [-k kflag] [-m 'message'] files...
{admin|adm|rcs} [rcs-options] files...
{annotate|ann} [options] [files...]
{checkout|co|get} [options] modules...
{commit|ci|com}   [-lnR]  [-m  'log_message'  |  -f  file] \
        [-r revision] [files...]
{diff|di|dif} [-kl] [rcsdiff_options] [[-r rev1 | -D date1] \
        [-r rev2 |  -D date2]] [files...]
{export|ex|exp} [-flNn] -r rev|-D date [-d dir] [-k kflag] module...
{history|hi|his} [-report] [-flags] [-options args] [files...]
{import|im|imp} [-options] repository vendortag releasetag...
{login|logon|lgn}
{log|lo|rlog} [-l] rlog-options [files...]
{rdiff|patch|pa} [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...
{release|re|rel} [-d] directories...
{remove|rm|delete} [-lR] [files...]
{rtag|rt|rfreeze} [-falnR]  [-b]  [-d]  [-r  tag  |  -D  date] \
         symbolic_tag modules...
{status|st|stat} [-lR] [-v] [files...]
{tag|ta|freeze} [-lR] [-F] [-b] [-d] [-r tag | -D date]  [-f] \
         symbolic_tag [files...]
{update|up|upd} [-AdflPpR] [-d] [-r tag|-D date] files...
</example>
</sect1>

<sect id="svn">Subversion
<p>
Subversion est un système de contrôle de version de nouvelle génération qui a
pour but de remplacer CVS. Les développeurs le considèrent actuellement en
étape «&nbsp;alpha&nbsp;», mais il est probablement assez stable pour la
plupart des utilisations. Aujourd'hui, Subversion est seulement disponible
dans Debian <tt>unstable</tt>.
<sect1 id="svn-inst">Installation d'un serveur Subversion
<p>
Le meta-paquet <package>subversion</package> dépend des paquets dont on
a besoin (<package>libapache2-dav-svn</package> et
<package>subversion-tools</package>) pour configurer un serveur.
<sect2>Configurer un dépôt
<p>
Actuellement, le paquet <package>subversion</package> ne configure pas un
dépôt, donc il faut le configurer à la main. Un emplacement possible pour un
dépôt est <file>/var/local/repos</file>.
<p>
Créer le répertoire&nbsp;:
<example>
# mkdir -p /var/local/repos
</example>
Créer la base de données du dépôt&nbsp;:
<example>
# svnadmin create /var/local/repos
</example>
Mettre le dépôt en écriture par le serveur web&nbsp;:
<example>
# chown -R www-data:www-data /var/local/repos
</example>
</sect2>
<sect2>Configuration d'Apache2
<p>
Pour permettre l'accès au répertoire par authentification des utilisateurs,
ajoutez (ou décommentez) ce qui suit à
<file>/etc/apache2/httpd.conf</file>&nbsp;:
<example>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/local/repos
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
  Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</example>
Ensuite, créer un fichier d'authentification des utilisateurs avec la
commande&nbsp;:
<example>
htpasswd2 -c /etc/subversion/passwd some-username
</example>
Relancez Apache2, et votre nouveau dépôt Subversion sera accessible par l'URL
http://<var>hostname</var>/repos.
</sect2>
</sect1>
<sect1 id="svn-cvs">Déplacer un dépôt CVS vers Subversion
</sect1>
<sect1 id="svn-usage">Exemples d'utilisation de Subversion
<p>
Les sections suivantes vous enseignent comment utiliser les différentes
commandes de Subversion.

<sect2>Créer une nouvelle archive Subversion
<p>
Pour créer une nouvelle archive Subversion, tapez ce qui suit&nbsp;:
<example>
$ cd ~/<var>your-project</var>         # go to your source directory
$ svn import http://localhost/repos <var>your-project</var> \
  <var>project-name</var> -m "initial project import"
</example>
<p>
Cela crée un répertoire nommé <var>project-name</var> dans votre dépôt
Subversion qui contient vos fichiers de projet. Regardez sur
http://localhost/repos/ s'il est là.
</sect2>

<sect2>Travailler avec Subversion
<p>
Travail sur <var>project-y</var> en utilisant Subversion&nbsp;:
<example>
$ cd                            # aller dans le répertoire de travail
$ svn co http://localhost/repos/<var>project-y</var>  # récupérer les sources
$ cd <var>project-y</var>
 ... travailler ...
$ svn diff                      # similaire à diff -u repository/ local/  
$ svn revert <var>modified_file</var>      # annuler les changements sur un
fichier
$ svn ci -m "<var>Describe changes</var>"  # mettre vos changements sur le
dépôt
$ vi <var>newfile_added</var>
$ svn add <var>newfile_added</var>
$ svn add <var>new_dir</var>               # ajoute récursivement tous les
fichiers de new_dir
$ svn add -N <var>new_dir2</var>           # ajoute le répertoire
non-récursivement
$ svn ci -m "Added <var>newfile_added</var>, <var>new_dir</var>,
<var>new_dir2</var>"
$ svn up                        # fusionne la dernière version du dépôt
$ svn log                       # affiche tous les changements
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>project-y-branch</var> \
      -m "creating my branch of <var>project-y</var>"  # ajouter une branche
<var>project-y</var>
$ svn copy http://localhost/repos/<var>project-y</var> \
      http://localhost/repos/<var>proj-y_release1.0</var> \
      -m "<var>project-y</var> 1.0 release"    # ajoute une borne de version
 ... notez qu'ajouter une branche ou une borne est pareil.
 ... la seule différence est que l'on peut effectuer des
 ... changements sur une branche et pas sur une borne.

 ... faire des changements sur la branche ...

$ # fusionne la copie de la branche vers la copie principale
$ svn merge http://localhost/repos/<var>project-y</var> \
   http://localhost/repos/<var>project-y-branch</var>
$ svn co -r 4 http://localhost/repos/<var>project-y</var> # récupère la
                                                 revision 4
</example>

</sect2>

</sect1>
</sect>
</chapt>
