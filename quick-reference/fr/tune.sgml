<!-- CVS revision of this document "$Revision: 1.13 $"  -->
<!-- CVS revision of original english document "1.30"  -->

<chapt id="tune">Configurer un système &debian;
<p>
Ce chapitre décrit seulement les bases de la configuration du système. Lire
<ref id="install"> est pré-requis pour ce chapitre.
<p>
Pour ceux qui sont intéressés par la sécurité, il est hautement recommandé de
lire <url id="&securing-debian-howto;" name="Securing Debian Manual"> qui
se trouve aussi dans le paquet <package>&p-securing-debian-howto;</package>.

<sect id="init-hints">Astuces sur l'initialisation du système
<p>
Voir <ref id="init"> pour les bases sur les scripts d'initialisation de
&debian;.

<sect1 id="init-defaults">Personnaliser les scripts d'initialisation
<p>
&debian; utilise le système de scripts d'initialisation sys-V. Bien que ces
scripts d'initialisation dans <file>/etc/init.d/*</file> soient marqués comme
des fichiers de configuration et que les administrateurs système soient libres
de les modifier, la personnalisation de ces scripts d'initialisation grâce aux
fichiers de <file>/etc/defaults/*</file> est l'approche préférable.
<p>
Par exemple <file>/etc/init.d/rcS</file> peut être utilisé pour personnaliser
les défauts au démarrage pour <prgn>motd</prgn>, <prgn>sulogin</prgn>, etc.

<sect1 id="syslogd">Personnaliser le journal du système
<p>
Le journal du système peut être configuré par le fichier
<file>/etc/syslog.conf</file>. Utilisez le paquet <package>colorize</package>
pour colorier les fichiers du journal.
Voir <manref name="syslogd" section="8"> et <manref name="syslog.conf"
section="5">.
</sect1>

<sect1 id="hdtune">Optimisation de l'accès au matériel
<p>
Quelques outils pour l'optimisation du matériel sont donnés à l'administrateur
système avec &debian;.
<list>
<item><package>hdparm</package>
 <list compact>
<item>Optimisation du disque dur. Très efficace.
<item>Dangereux. Il faut lire <manref name="hdparm" section="8"> d'abord.
<item><tt>hdparm -tT <var>/dev/hda</var></tt> pour tester la vitesse du
disque.
<item><tt>hdparm -c1 -d1 -u1 -m16 -A <var>/dev/hda</var></tt> pour accélérer
un système IDE moderne. (Cela peut être dangereux.)
 </list>

<item><package>setserial</package>
 <list compact>
<item>Collection d'outils pour gérer les ports série.
 </list>

<item><package>scsitools</package>
 <list compact>
<item>Collection d'outils pour gérer le matériel SCSI.
 </list>

<item><package>memtest86</package>
 <list compact>
<item>Collection d'outils pour gérer la mémoire.
 </list>

<item><package>hwtools</package>
 <list compact>
<item>Collection d'outils pour la gestion bas niveau du matériel.
  <list compact>
   <item>irqtune&nbsp;: change la priorité d'IRQ des périphériques pour
   autoriser ceux qui ont besoin d'une priorité haute et d'un service rapide
   (par exemple ports série, modems) à l'avoir.
   <item>scanport&nbsp;: scanne l'espace I/O de 0x100 à 0x3ff pour trouver les
   périphériques ISA installés.
   <item>inb&nbsp;: un petit programme rapide qui lit un port I/O et retourne
   la valeur en hexadécimal et en binaire.
  </list>

 </list>

<item><package>schedutils</package>
 <list compact>
<item>Utilitaires pour l'ordonnanceur Linux.
<item><prgn>taskset</prgn>, <prgn>irqset</prgn>, <prgn>lsrt</prgn> et
<prgn>rt</prgn> sont inclus.
<item>Avec <prgn>nice</prgn> et <prgn>renice</prgn> (non inclus), ils
permettent un contrôle complet des paramètres de l'ordonnancement des
processus.
 </list>

</list>

<sect>Contrôle d'accès

<sect1 id="loginctrl">Contrôle d'accès avec PAM et login
<p>
PAM (<em>Pluggable Authentication Modules</em>, Modules d'Authentification
Greffables) fournit le contrôle de la connexion.
<example>
/etc/pam.d/*             # fichiers de contrôle de PAM
/etc/pam.d/login         # fichier de contrôle de PAM pour la connexion
/etc/security/*          # paramètres des modules de PAM
/etc/securetty           # contrôle les connexions de root sur la console
/etc/login.defs          # contrôle le comportement de login
</example
<p>
Changez le contenu du fichier <file>/etc/pam.d/login</file> comme suit, si
vous voulez des terminaux non sécurisés mais ne demandant pas de mot de passe.
Faites le à vos propres risques.
<example>
#auth       required   pam_unix.so nullok
auth       required   pam_permit.so
</example>
Des astuces similaires peuvent être appliquées pour <prgn>xdm</prgn>,
<prgn>gdm</prgn>, ..., pour avoir une console X sans mot de passe.
<p>
Le nombre maximum de processus peut être réglé avec <tt>ulimit -u 1000</tt>
dans un shell Bash ou avec la configuration de
<file>/etc/security/limits.conf</file>. D'autres paramètres comme
<tt>core</tt> peuvent être réglés d'une façon similaire. La valeur initiale de
<prgn>PATH</prgn> peut être réglée dans le fichier
<file>/etc/login.defs</file> avant le script de démarrage du shell.
<p>
La documentation de PAM est dans le paquet <package>libpam-doc</package>. Le
Guide de l'Administrateur d'un Système Linux-PAM couvre la
configuration de PAM, les modules disponibles, etc. La documentation inclut
aussi le Guide du Développeur d'Applications Linux-PAM et le
Guide du Développeurs de Modules Linux-PAM.
</sect1>

<sect1 id="wheel">Pourquoi <prgn>GNU su</prgn> ne supporte pas le groupe <tt>wheel</tt>
<p>
C'est la célèbre phrase de Richard M. Stallman à la fin de l'ancienne page
<tt>info su</tt>. Ne pas s'inquiéter&nbsp;: le <prgn>su</prgn> actuel de
&debian; utilise PAM, donc on peut restreindre l'accès de <prgn>su</prgn> à
n'importe quel groupe en utilisant <prgn>pam_wheel.so</prgn> dans
<file>/etc/pam.d/su</file>. Ce qui suit réglera le groupe <tt>adm</tt> du
système &debian; comme équivalent du groupe BSD <tt>wheel</tt> et autorisera
<prgn>su</prgn> sans mot de passe pour les membres du groupe.
<example>
# anti-RMS configuration in /etc/pam.d/su
auth       required   pam_wheel.so group=adm

# Wheel members to be able to su without a password
auth       sufficient pam_wheel.so trust group=adm
</example>

<sect1>Signification des groupes
<p>
Quelques groupes intéressants&nbsp;:
<list compact>
<item>Le groupe <tt>root</tt> est le groupe <tt>wheel</tt> par défaut pour
<prgn>su</prgn> si <prgn>pam_wheel.so</prgn> est utilisé sans l'argument
<tt>group=</tt>.
<item>Le groupe <tt>adm</tt> peut lire les fichiers du journal.
<item>Le groupe <tt>cdrom</tt> peut être utilisé localement pour donner accès
au lecteur de CDROM à un ensemble d'utilisateurs.
<item>Le groupe <tt>floppy</tt> peut être utilisé localement pour donner accès
au lecteur de disquettes à un ensemble d'utilisateurs.
<item>Le groupe <tt>audio</tt> peut être utilisé localement pour donner accès
à un périphérique audio à un ensemble d'utilisateurs.
<item>Le groupe <tt>src</tt> possède le code source, y compris les fichiers de
<file>/usr/src</file>. Il peut être utilisé localement pour donner la
possibilité de gérer le code source du système à un utilisateur.
<item>Le groupe <tt>staff</tt> est utile pour donner la possibilité de faire
des choses dans <file>/usr/local</file> et créer des répertoires dans
<file>/home</file> à plus d'administrateurs système (support/junior).
</list>
<p>
Pour une liste complète, voir la section «&nbsp;FAQ&nbsp;» dans <url
id="&securing-debian-howto;" name="Securing Debian Manual">, qui se trouve
aussi dans le paquet <package>&p-securing-debian-howto;</package>.

<sect1 id="sudo"><prgn>sudo</prgn> &ndash; un environnement de travail plus sûr
<p>
J'utilise <prgn>sudo</prgn> principalement comme protection contre ma
stupidité. Utiliser <prgn>sudo</prgn> est toujours mieux que d'utiliser le
système avec le compte root.
<p>
Installez <prgn>sudo</prgn> et activez-le en configurant /etc/<url
id="&examples;" name="sudoers">. Réglez aussi les possibilités de <tt>sudo</tt>
pour les groupes dans <file>&dochome;sudo/OPTIONS</file>.
<p>
Cette configuration fournit aux membres du groupe «&nbsp;staff&nbsp;» un accès
à toutes les commandes lancées en tant que root avec <prgn>sudo</prgn> et
donne aux membres du groupe «&nbsp;src&nbsp;» un accès à certaines commandes
lancées en tant que root avec <prgn>sudo</prgn>.
<p>
L'avantage de <prgn>sudo</prgn> est qu'il requiert seulement les mots de passe
utilisateurs pour se connecter et que l'activité est surveillée. C'est un
moyen simple de donner des pouvoirs à un administrateur débutant. Par
exemple&nbsp;:
<example>
$ sudo chown -R <var>myself</var>:<var>mygrp</var> .
</example>
<p>
Bien sûr, si vous connaissez le mot de passe de root (comme beaucoup
d'utilisateurs individuels), n'importe quelle commande peut être lancée en
tant que root depuis un compte utilisateur&nbsp;:
<example>
$ su -c "shutdown -h now"
Password:
</example>
(Je sais que je devrais limiter les privilèges du compte administrateur avec
<prgn>sudo</prgn>. Mais comme c'est mon serveur personnel, je ne me suis
pas encore embêté avec ça.)
<p>
Un autre programme permet à des utilisateurs ordinaires de lancer des
commandes avec les privilèges de root, voir le paquet
<package>super</package>.
</sect1>

<sect1 id="tcpd">Contrôle d'accès aux démons
<p>
Le <em>super-serveur</em> internet, <prgn>inetd</prgn>, est exécuté lors du
démarrage par <file>/etc/rc2.d/S20inetd</file> (pour le niveau d'exécution 2)
qui est un lien vers <file>/etc/init.d/inetd</file>.
<prgn>inetd</prgn> permet de n'exécuter qu'un démon qui en invoque plusieurs
autres, réduisant ainsi la charge du système.
<p>
Lorsqu'une requête pour un service arrive, le protocole et le service sont
identifiés en regardant dans la base de données stockée dans
<file>/etc/protocols</file> et <file>/etc/services</file>.
Pour un service internet normal, <prgn>inetd</prgn> utilise
<file>/etc/inetd.conf</file>. Pour un service basé sur Sun-RPC,
<prgn>inetd</prgn> utilise <file>/etc/rpc.conf</file>.
<p>
Pour la sécurité du système, assurez-vous de désactiver les services non
utilisés dans <file>/etc/inetd.conf</file>. Les services Sun-RPC doivent être
actifs pour NFS et d'autres programmes basés sur RPC.
<p>
Parfois, <prgn>inetd</prgn> n'exécute pas le serveur demandé directement, mais
exécute le programme d'enveloppe de démon TCP/IP <prgn>tcpd</prgn> avec le
serveur demandé comme argument dans <file>/etc/inetd.conf</file>. Dans ce cas,
<prgn>tcpd</prgn> lance le serveur approprié après avoir enregistré dans le
journal la requête et avoir fait quelques autres vérifications en utilisant
les fichiers <file>/etc/hosts.deny</file> et <file>/etc/hosts.allow</file>.
<p>
Si vous avez un problème avec l'accès à distance sur un système &debian;
récent, commentez la ligne "ALL: PARANOID" dans <file>/etc/hosts.deny</file>
si elle existe.
<p>
Pour plus de détails, voir
<manref name="inetd" section="8">,
<manref name="inetd.conf" section="5">,
<manref name="protocols" section="5">,
<manref name="services" section="5">,
<manref name="tcpd" section="8">,
<manref name="hosts_access" section="5">, et
<manref name="hosts_options" section="5">.
<p>
Pour plus d'information sur Sun-RPC, voir
<manref name="rpcinfo" section="8">,
<manref name="portmap" section="8">, et
<file>&f-portmap;</file>.

<sect1 id="ldap">Lightweight Directory Access Protocol
<p>
Références&nbsp;:
<list compact>
<item><url id="&openldaphome;" name="OpenLDAP">
<item>OpenLDAP Admin Guide dans le paquet <package>openldap-guide</package>
<item>LDP: <url id="&ldap-linux-howto;" name="LDAP Linux HOWTO">
<item>LDP: <url id="&ldap-implementation-howto;" name="LDAP Implementation
HOWTO">
<item><url id="&ldap-use1;" name="OpenLDAP, extensive use reports">
<item><url id="&ldap-use2;" name="Open LDAP with Courier IMAP and Postfix">
</list>
</sect>


<sect id="cdrw">Graveur de CD
<p>
Les graveurs de CD sur interface ATAPI/IDE sont devenus des périphériques
courants. Le CD un bon média pour sauvegarder et archiver un système pour un
utilisateur individuel ayant besoin d'une capacité &lt; 640 Mo. Pour des
informations plus officielles, consultez le <url id="&cd-writing-howto;"
name="CD-Writing-HOWTO"> du LDP.

<sect1>Introduction
<p>
D'abord, sachez qu'une interruption de l'envoi des données vers le
graveur entraînera des erreurs irrécupérables sur le CD. Prenez donc un graveur
avec un cache aussi gros que possible. Si le prix n'a pas d'importance, optez
pour une version SCSI plutôt qu'ATAPI/IDE. Si vous avez le choix de
l'interface IDE sur laquelle connecter le graveur, préférez celle sur bus PCI
(une de celles de la carte mère) plutôt qu'une sur bus ISA (carte SB16, etc.).
<p>
Un graveur connecté sur interface IDE doit être piloté par le pilote IDE-SCSI
et non par le pilote CD IDE habituel. Le pilote SCSI générique doit aussi être
activé. Pour cela, deux approches existent pour les noyaux distribués avec
des distributions modernes (à la date de mars 2001).
</sect1>

<sect1>Première approche&nbsp;: modules + <prgn>lilo</prgn>
<p>
Ajoutez la ligne suivante à <file>/etc/lilo.conf</file> si vous utilisez le
noyau distribué avec Debian. Si vous utilisez plusieurs options, listez-les en
les séparant par des espaces.
<example>
append="hdx=ide-scsi ignore=hdx"
</example>
Ici, le graveur, accédé par le pilote ide-scsi, est identifié par
<tt>hdx</tt>, où <em>x</em> représente&nbsp;:
<example>
hdb      esclave sur le premier port IDE
hdc      maître sur le second port IDE
hdd      esclave sur le second port IDE
hde ... hdh  sur un port IDE externe
</example>
Lancez les commandes suivantes, en tant que root, pour activer les options
après avoir terminé la configuration&nbsp;:
<example>
# lilo
# shutdown -h now
</example>
</sect1>


<sect1>Seconde approche&nbsp;: recompiler le noyau
<p>
Debian utilise <prgn>make-kpkg</prgn> pour créer le noyau.  Utilisez la
nouvelle option <tt>--append_to_version</tt> avec make-kpkg pour créer
plusieurs images du noyau.
Utilisez la configuration suivante avec <tt>make menuconfig</tt>&nbsp;:
<list>
<item>bzImage
<item>Excluez le pilote CD IDE (non obligatoire mais c'est plus simple comme ça)
<item>Ajoutez ide-scsi et sg, ou compilez-les en tant que modules
</list>
</sect1>

<sect1>Étapes post-configuration
<p>
Le support pour le graveur peut être activé dans le noyau lors du démarrage
avec les commandes suivantes&nbsp;:
<example>
# echo ide-scsi &gt;&gt;/etc/modules
# echo sg       &gt;&gt;/etc/modules
# cd /dev; ln -sf scd0 cdrom
</example>
Une activation manuelle peut aussi être effectuée avec&nbsp;:
<example>
# modprobe ide-scsi
# modprobe sg
</example>
Après un redémarrage, vous pouvez vérifier l'installation avec&nbsp;:
<example>
$ dmseg|less
# apt-get install cdrecord
# cdrecord -scanbus
</example>
<p>
[Par Warren Dodge] Quelquefois, il peut y avoir des conflits entre
<tt>ide-scsi</tt> et <tt>ide-cd</tt> s'il y a à la fois un lecteur de CDROM
et un graveur CD-R/RW sur le système. Essayez d'ajouter ce qui suit dans votre
fichier <file>/etc/modutils/aliases</file>, exécutez
<prgn>update-modules</prgn> et redémarrez.
<example>
pre-install      ide-scsi      modprobe ide-cd
</example>
Cela force le pilote IDE à être chargé avant <tt>ide-scsi</tt>. Le pilote
<tt>ide-cd</tt> prend le contrôle du lecteur de CDROM ATAPI &mdash; tout ce
qu'on ne lui a pas dit d'<strong>ignorer</strong>. Cela laisse simplement les
périphériques ignorés au contrôle de <tt>ide-scsi</tt>.
</sect1>

<sect1>Image de CD (bootable)
<p>
Pour créer un CDROM contenant des fichiers contenus dans le répertoire
<file>target-directory/</file> en tant qu'image nommée
<file>cd-image.raw</file> (CD bootable, format Joliet TRANS.TBL. Pour un CD
non bootable, enlevez les options <tt>-b</tt> et <tt>-c</tt>), insérez une
disquette de démarrage dans le premier lecteur de disquette et faites&nbsp;:
<example>
# dd if=<var>/dev/fd0</var> <var>target-directory/boot.img</var>
# mkisofs -r -V <var>volume_id</var> -b <var>boot.img</var> -c <var>bootcatalog</var> -J -T \
        -o <var>cd-image.raw</var> <var>target_directory/</var>
</example>
<p>
Une utilisation amusante est de créer un CDROM DOS bootable. Si
<file><var>boot.img</var></file> contient l'image d'une disquette de démarrage
DOS, le CDROM démarrera comme si une disquette DOS était dans le premier
lecteur de disquette (A:). Faire cela avec freeDOS est encore plus
intéressant. 
<p>
L'image créée peut être vérifiée en la montant en utilisant le périphérique de
boucle (loop device).
<example>
# mount -t iso9660 -o ro,loop <var>cd-image.raw</var> /cdrom
# cd /cdrom
# mc
# umount /cdrom
</example>
</sect1>

<sect1>Graver un CD
<p>
Premier test avec les commandes suivantes (cas d'un graveur double vitesse)
<example>
# nice --10 cdrecord -dummy speed=2 dev=0,0 <var>disk.img</var>
</example>
Si le test est réussi, gravez un CD-R avec
<example>
# nice --10 cdrecord -v -eject speed=2 dev=0,0 <var>disk.img</var>
</example>
Ou gravez un CD-RW avec
<example>
# nice --10 cdrecord -v -eject blank=fast speed=2 dev=0,0 <var>disk.img</var>
</example>
Certains graveurs de CD marchent mieux avec
<example>
# nice --20 cdrecord -v blank=all speed=2 dev=0,0
</example>
suivi de
<example>
# nice --10 cdrecord -v -eject speed=2 dev=0,0 <var>disk.img</var>
</example>
Deux étapes sont nécessaires pour empêcher que des fins d'attente SCSI lors du
formatage n'interfèrent avec l'étape de gravure. Les arguments passés à
<prgn>nice</prgn> peuvent avoir besoin d'un ajustement.
</sect1>

<sect1>Créer l'image d'un CD
<p>
Certains CD-R et CD commerciaux ont des secteurs parasites à la fin qui les
rendent incopiables par <prgn>dd</prgn> (le CD de Windows 98 est l'un d'eux).
Le paquet <package>cdrecord</package> comprend la commande
<prgn>readcd</prgn>. Utilisez-la pour copier le contenu de n'importe quel CD
dans un fichier image. S'il s'agit d'un CD de données, montez-le et exécutez
<prgn>mount</prgn> pour connaître sa taille. Divisez le nombre affiché (en
blocs de 1024 octets) par 2 pour connaître le nombre de secteurs du CD (2048
octets). Lancez <prgn>readcd</prgn> avec les bonnes options et utilisez
l'image du CD pour graver un CD-R/RW.
<example>
# readcd <var>target</var> <var>lun</var> <var>scsibusno</var> # choisissez la
fonction 11
</example> 
Ici, positionnez tous les paramètres de ligne de commande à 0 dans la plupart
des cas. Parfois, le nombre de secteurs donné par <prgn>readcd</prgn> est trop
important !  Utilisez le nombre donné par mount pour de meilleurs résultats.
<example>
Mon CD-R         = +2 secteurs
CD de MS Windows = +1 secteur, càd +2048 octets
</example>
</sect1>

<sect1>Images de CD Debian
<p>
Pour obtenir les dernières informations, consultez le
<url id="http://cvs.debian.org/debian-cd/" name="site Debian CD."> 
<p>
Si vous avez une connexion Internet rapide, installez par le réseau en
utilisant&nbsp;:
<list compact>
<item>quelques <url id="&debian-floppyinst;" name="images de disquettes">.
<item>une <url id="&debian-netinst;" name="image de CD minimale">.
</list>
<p>
Si vous n'avez pas de connexion Internet rapide, achetez des CD depuis un <url
id="&debian-venders;" name="vendeur de CD">.
<p>
Merci de ne pas gâcher la bande passante en téléchargeant des images de CD
standard à moins que vous ne soyez un testeur d'images de CD (même avec la
nouvelle méthode jigdo).
<p>
Une image de CD à noter est celle de <url id="&knoppix;" name="KNOPPIX -
Système de Fichier Linux Fonctionnel sur CD">. Ce CD démarre avec un système
&debian; fonctionnel sans s'installer sur le disque dur.

<!-- old document section
$ export CVSROOT=anonymous@cvs.debian.org:/cvs/debian-boot
$ cvs co debian-cd
</example>
Les commandes suivantes permettent de créer une image de CD :
<example>
# apt-get install debian-cd
# cd /etc/debian-cd
# vim CONF.sh
$ . CONF.sh
$ make distclean
$ make status
$ make list COMPLETE=1 SIZELIMIT1=555000000 SRCSIZELIMIT=665000000
$ make official_images
 ou si vous souhaitez seulement des images avec les binaires :
$ make bin-official_images
-->
</sect1>

<sect1>Système de sauvegarde sur CD-R
<p>
Permet de copier les fichiers de configuration et de données importants sur
CD-R. Utilisez le script suivant&nbsp;:
<url id="examples/" name="backup">
</sect1>

<sect1>Copier un CD audio sur un CD-R
<p>
Je n'ai pas testé cela personnellement&nbsp;:
<example>
# apt-get get install cdrecord cdparanoia
# cdparanoia -s -B
# cdrecord dev=0,0,0 speed=2 -v -dao -eject defpregap=1 -audio *.wav
</example>
ou,
<example>
# apt-get install cdrdao #disk at once
# cdrdao read-cd --device /dev/cdrom --paranoia-mode 3 my_cd # lit le CD
# cdrdao write --device /dev/cdrom --speed 8 my_cd    # grave un nouveau CD
</example>
<prgn>cdrdao</prgn> fait une vraie copie (pas de trous, etc.).
</sect1>
</sect>

<sect id="x">Le programme X
<p>
<taglist>
<tag><ref id="xsrvr">
<item>un programme sur la machine locale qui affiche des fenêtres X et/ou un
bureau sur le moniteur (CRT, LCD) d'un utilisateur et accepte des entrées au
clavier et à la souris.
<tag><ref id="xclnt">
<item>un programme sur une machine (locale ou distante) qui exécute un
logiciel d'application compatible avec X-Window.
</taglist>
Cela inverse l'utilisation habituelle de «&nbsp;serveur&nbsp;» et
«&nbsp;client&nbsp;» dans d'autres contextes.  Pour plus de détails,
référez-vous au <manref name="X" section="7">, au <url id="&xwindowuser-howto;"
name="XWindow-User-HOWTO">, et au <url id="&remote-xapps-howto;" name="Remote X
Apps mini-HOWTO"> du LDP.
<p>
Il y a plusieurs façons de faire accepter les connexions distantes d'un client
X (côté application) à un serveur X (côté affichage)&nbsp;:
<list>
<item><prgn>xhost</prgn>
<list compact>
<item>le mécanisme de liste d'hôtes (non sûr).
<item>protocole non chiffré (sujet à des attaques d'écoute de ligne).
<item>à ne pas utiliser, si possible.
<item>voir <ref id="xhost"> et <manref name="xhost" section="1x">.
</list>
<item><prgn>xauth</prgn>
<list compact>
<item>le mécanisme des cookies magiques du MIT (non sûr mais mieux que <prgn>xhost</prgn>).
<item>protocole non chiffré (sujet à des attaques d'écoute de ligne).
<item>à utiliser seulement pour des connexions locales.
<item>voir <ref id="ss-xsu"> et <manref name="xauth" section="1x">.
</list>
<item><prgn>xdm</prgn>, <prgn>wdm</prgn>, <prgn>gdm</prgn>, <prgn>kdm</prgn>,...
<list compact>
<item>voir <manref name="xdm" section="1x"> et <manref name="Xsecurity"
section="7"> pour les bases du contrôle d''accès à un affichage X.
<item>voir <manref name="wdm" section="1x">, <manref name="gdm" section="8">,
et <manref name="kdm.options" section="5"> pour plus d'information, si ces
programmes sont installés.
<item>voir <ref id="sys-v"> pour savoir comment désactiver <prgn>xdm</prgn>
pour avoir accès à la console Linux après le démarrage sans purger le paquet
<prgn>xdm</prgn>.
</list>
<item><prgn>ssh -X</prgn>
<list compact>
<item>mécanisme de redirection de port à travers SSH (sûr).
<item>protocole chiffré (gâchis de ressources en utilisation locale).
<item>à utiliser pour des connexions distantes.
<item>voir <ref id="xssh">.
</list>
</list>
Toutes les méthodes de connexion distante, sauf <prgn>ssh</prgn>, ont besoin
de l'activation des connexions TCP/IP au serveur X. Voir <ref id="xtcp">.

<sect1 id="xsrvr">Serveur X
<p>
Consultez <manref name="XFree86" section="1"> pour des informations sur le
serveur X.
<p>
Pour (re)configurer X4 sous Woody, exécutez&nbsp;:
<example>
# dpkg-reconfigure --p=low xserver-xfree86
</example>
<p>
Exécution du serveur X depuis une console locale&nbsp;:
<example>
$ startx -- :&lt;display&gt; vtXX 
par exemple&nbsp;:
$ startx -- :1 vt8
... exécution sur un terminal vt8 connecté à localhost:1
</example>
</sect1>

<sect1 id="xclnt">Client X
<p>
La plupart des clients X peuvent être démarrés comme ceci&nbsp;:
<example>
client $ xterm -geometry 80x24+30+200 -fn 6x10 -display <var>hostname</var>:0 &amp;
</example>
Ici, les arguments de ligne de commande optionnels signifient&nbsp;:
<list>
<item><tt>-geometry
<var>WIDTH</var>x<var>HEIGHT</var>+<var>XOFF</var>+<var>YOFF</var></tt>&nbsp;: 
taille initiale et emplacement de la fenêtre.

<item><tt>-fn <var>FONTNAME</var></tt>&nbsp;: police utilisée pour l'affichage
du texte.
 <tt><var>FONTNAME</var></tt> peut être&nbsp;:
<list compact>
<item>a14&nbsp;: Taille normale
<item>a24&nbsp;: Grande taille
<item>... (consultez les polices disponibles avec <tt>xlsfont</tt>.)
</list>
<item><tt>-display <var>displayname</var></tt>&nbsp;: le nom du serveur X à
utiliser.
 <tt><var>displayname</var></tt> peut être&nbsp;:
<list compact>
<item><tt><var>hostname</var>:<var>D.S</var></tt> signifie écran <var>S</var>
sur affichage <var>D</var> de l'hôte <tt>hostname</tt>&nbsp;; le serveur X de
cet affichage écoute le port TCP 6000+D.

<item><tt><var>host</var>/unix:<var>D.S</var></tt> signifie écran <var>S</var>
sur affichage <var>D</var> de l'hôte <tt>host</tt>&nbsp;; le serveur X de cet
affichage écoute la socket UNIX <file>/tmp/.X11-unix/XD</file> (et n'est donc
utilisable depuis <tt><var>host</var></tt>).

<item><tt><var>:D.S</var></tt>  est équivalent
à <tt><var>host</var>/unix:<var>D.S</var></tt>, où <tt>host</tt> est le nom de
l'hôte local
</list>
</list>
<p>
Le <tt><var>displayname</var></tt> (nom d'affichage) par défaut pour un
programme client X (côté application) peut être défini par la variable
d'environnement DISPLAY. Par exemple, avant de lancer un programme client X, on
peut exécuter l'une des commandes suivantes pour cela&nbsp;:
<example>
$ export DISPLAY=:0 
        # Valeur par défaut, machine locale avec premier écran X
$ export DISPLAY=<var>hostname.fulldomain.name</var>:0.2
$ export DISPLAY=localhost:0
</example>
</sect1>

<sect1 id="xtcp">Connexion TCP/IP à X
<p>
Comme les connexions TCP/IP distantes sans chiffrage peuvent être sujettes à
des attaques d'écoute de ligne, la configuration par défaut de X de &debian;
désactive les sockets TCP/IP. Pensez à utiliser <prgn>ssh</prgn> pour des
connexions X distantes (see <ref id="xssh">).
<p>
La méthode décrite ici n'est pas encouragée à moins que l'on soit dans un
environnement très sûr derrière un bon pare-feu et en présence d'utilisateurs
de confiance uniquement. La configuration suivante sur le serveur X restaure
les connexions TCP/IP&nbsp;:
<example>
# find /etc/X11 -type f -print0 | xargs -0 grep nolisten
/etc/X11/xinit/xserverrc:exec /usr/bin/X11/X -dpi 100 -nolisten tcp
</example>
Supprimez <tt>-nolisten</tt> pour permettre les connexions TCP/IP à X.
</sect1>
 
<sect1 id="xhost">Connexion X distante&nbsp;: <prgn>xhost</prgn>
<p>
<prgn>xhost</prgn> autorise l'accès en se basant sur les noms d'hôtes, ce qui
n'est pas sûr du tout.  Les commandes suivantes permettent de désactiver la
vérification de l'hôte et autorisent des connexions de n'importe où si les
connexions TCP/IP sont autorisées ( (see <ref id="xtcp">)&nbsp;:
<example>
$ xhost +
</example>
Vous pouvez réactiver la vérification de l'hôte avec&nbsp;:
<example>
$ xhost -
</example>
<p>
<prgn>xhost</prgn> ne fait pas la différence entre les utilisateurs sur l'hôte
distant. De plus, les noms d'hôtes (les adresses en fait) peuvent être
falsifiés.
<p>
Cette méthode doit être évitée même avec des critères sur les hôtes plus
restrictifs si vous êtes sur un réseau dans lequel vous ne pouvez avoir
confiance (par exemple avec une connexion PPP sur Internet).  Voir <manref
name="xhost" section="1x">.
</sect1>

<sect1 id="xssh">Connexion X distante&nbsp;: <prgn>ssh</prgn>
<p>
L'utilisation de <prgn>ssh</prgn> active une connexion sûre d'un serveur X
local vers un serveur d'applications distant.
<list>
<item>Réglez <tt>X11Forwarding</tt> et <tt>AllowTcpForwarding</tt> à
<tt>yes</tt> dans <file>/etc/ssh/sshd_config</file> sur l'hôte distant.
<item>Démarrez le serveur X sur la station locale.
<item>Démarrez un <prgn>xterm</prgn> sur l'hôte local.
<item>Lancez <prgn>ssh</prgn> pour établir une connexion vers le site distant.
<example>
localname @ localhost $ ssh -q -X -l loginname remotehost.domain
Password:
.....
</example>
<item>Lancez des applications X sur le site distant.
<example>
loginname @ remotehost $ gimp &
</example>
</list>
Cette méthode permet l'affichage du client X distant comme s'il était connecté
par une socket UNIX locale.
</sect1>

<sect1 id="xtermfaq"><prgn>xterm</prgn>
<p>
Apprenez tout sur <prgn>xterm</prgn> à l'adresse <url id="&xtermfaq;">.
</sect1>

<sect1 id="ss-xsu">Devenir root sous X
<p>
Si une application graphique a besoin d'être lancée avec les privilèges de
root, utilisez les procédures suivantes pour le faire à partir du serveur X
d'un utilisateur. N'essayez jamais de démarrer un serveur X depuis le compte
root, pour vous garder d'éventuels risques de sécurité.
<p>
Démarrez le serveur X avec un utilisateur normal et ouvrez un
<prgn>xterm</prgn>. Ensuite&nbsp;:
<example>
$ XAUTHORITY=$HOME/.Xauthority
$ export XAUTHORITY
$ su root
Password:*****
# printtool &
</example>
Lorsque vous utilisez cette astuce pour effectuer un <prgn>su</prgn> vers un
utilisateur non root, faites attention à ce que le fichier
<file>$HOME/.Xauthority</file> soit lisible par le groupe de cet utilisateur.
<p>
Cette séquence de commandes peut être automatisée en ajoutant quelques
fichiers. Depuis le compte root, créez le fichier
<file>/etc/X11/Xsession.d/00xfree86-common_environment</file> avec les lignes
suivantes&nbsp;:
<example>
if [ -f "$HOME/.xenvironment" ]; then
    . $HOME/.xenvironment
fi
</example>
Depuis le compte utilisateur, créez le fichier
<file>$HOME/.xenvironment</file>, avec les lignes suivantes&nbsp;:
<example>
# Cela permet que X marche quand je fais un su pour devenir root
if [ -z "$XAUTHORITY" ]; then
    XAUTHORITY=$HOME/.Xauthority
    export XAUTHORITY
fi
</example>
Ensuite, exécutez <prgn>su</prgn> (pas <tt>su -</tt>) dans une fenêtre
<prgn>xterm</prgn> de l'utilisateur.  Maintenant vous pouvez exécuter des
applications graphiques avec les privilèges de root sur l'écran X d'un
utilisateur normal.  Cette astuce fonctionne tant que le Xsession par défaut
est utilisé. Si un utilisateur personnalise <file>$HOME/.xinit</file> ou
<file>$HOME/.xsession</file>, la variable d'environnement <tt>XAUTHORITY</tt>
mentionnée ci-dessus doit être positionnée de la même façon dans ces scripts.

<p>Une autre méthode est d'utiliser le paquet <package>sudo</package>&nbsp;:
<example>
$ sudo xterm
... ou
$ sudo -H -s
</example>
Ici le fichier <file>/root/.bashrc</file> doit contenir&nbsp;:
<example>
if [ $SUDO_USER ]; then
    sudo -H -u $SUDO_USER xauth extract - $DISPLAY | xauth merge -
fi
</example>
Cela marche bien même si le répertoire home de l'utilisateur est sur une
partition NFS, puisque root ne lit pas le fichier <file>.Xauthority</file>.
<p>
Il existe aussi des paquets spécialisés dans ce but&nbsp;:
<package>kdesu</package>, <package>gksu</package>, <package>gksudo</package>,
<package>gnome-sudo</package>, et <package>xsu</package>. Enfin, trois autres
méthodes peuvent être utilisées pour atteindre des résultats similaires&nbsp;:
créer un lien symbolique depuis <file>/root/.Xauthority</file> vers celui de
l'utilisateur&nbsp;; utiliser le script <url id="&suxhome;"
name="&quot;sux&quot;">&nbsp;; ou mettre <tt>xauth merge
~<var>USER_RUNNING_X</var>/.Xauthority</tt> dans le script d'initialisation de
root.
<p>
Plus d'informations sur la <url id="&deb-dev-su;" name="liste de diffusion
debian-devel">.
</sect1>

<sect1 id="xfs-tt">Polices TrueType dans X
<p>
Le <prgn>xfs</prgn> standard de XFree86-4 fonctionne bien avec les polices
TrueType. Il faut installer un autre serveur de polices comme
<prgn>xfs-xtt</prgn> si vous utilisez XFree86-3.
<p>
Vous avez simplement besoin de vous assurer que les applications que vous
voulez utiliser avec les polices TrueType sont liées avec les bibliothèques
libXft ou libfreetype (vous n'avez probablement pas à vous en soucier si vous
utilisez des .deb précompilés).
<p>
Souvenez-vous d'installer les fichiers de polices et de générer les fichiers
<file>fonts.{scale,dir}</file> afin que les fontes puissent être indexées et
utilisées.
<p>
Puisque les polices <strong>libres</strong> sont parfois limitées,
l'installation ou le partage de certaines polices TrueType commerciales est
une option pour les utilisateurs &debian;. Afin de rendre ce processus facile
pour l'utilisateur, il existe certains paquets&nbsp;:
<list compact>
<item><package>ttf-commercial</package>
<item><package>msttcorefonts</package> (Plus utile depuis 08/2002 à cause d'un
changement de politique chez MS)
</list>
Vous aurez ainsi une très bonne sélection de polices TT au prix de la
contamination de votre système <strong>libre</strong> par des polices
non-libres.

<sect1 id="ss-browser">Navigateur Web (graphique)
<p>
Il existe quelques paquets de navigateurs web disponibles avec la sortie de
Woody&nbsp;:
<list compact>
<item><package>mozilla</package>Le navigateur Mozilla (nouveau)
<item><package>galeon</package>Navigateur basé sur Mozilla avec une interface Gnome (nouveau)
<item><package>konqueror</package>Navigateur KDE
<item><package>amaya-gtk</package>Navigateur de référence du W3C
<item><package>amaya-lesstif</package>Navigateur de référence du W3C
<item><package>netscape-...</package> (plusieurs, vieux)
<item><package>communicator-...</package> (plusieurs, vieux)
<item>...
</list>
La version de <package>mozilla</package> doit correspondre avec la version que
<package>galeon</package> requiert. A part l'interface graphique, ces deux
logiciels partagent le moteur de rendu HTML Gecko.
<p>
Des ajouts pour les navigateurs comme <package>mozilla</package> et
<package>galeon</package> peuvent être activés en installant des fichiers
<tt>*.so</tt> directement dans le répertoire <file>plugin</file> et en
relançant les navigateurs.
<p>
Ressources&nbsp;:
<list compact>
<item>Java&nbsp;: installer le binaire "J2SE" depuis <url id="&javasunhome;">.
<item>Flash&nbsp;: installer le binaire "Macromedia Flash Player 5" depuis
<url id="&flashhome;">.
<item><package>freewrl</package>&nbsp;: navigateur VRML et plugin Netscape
<item>...
</list>
</sect1>

<sect1 id="x-cjk">CJK et X
<p>
Références&nbsp;:
<list compact>
<item><ref id="l10n">
<item><url id="&suse-cjk;" name="Pages Suse pour CJK">
</list>
<p>
Ici, essayons pour le Japonais&nbsp;:
<list>
<item>installer les paquets pour le Japonais&nbsp;:
 <list compact>
 <item><package>kinput2-canna-wnn</package> &mdash; un serveur d'entrée pour
 les applications X11.
 <item><package>kterm</package>, <package>mlterm</package>, et
 <package>jfbterm</package>&nbsp;: terminaux compatibles avec le Japonais.
 <item><package>egg</package> &mdash; Input Method Architecture for Emacsen
 <item><package>canna</package> &mdash; un système d'entrée japonais (serveur
 et dictionnaire).
 <item><package>freewnn-jserver</package> &mdash; système de conversion Kana
 vers Kanji.
 <item>... et tous les paquets de polices japonaises.
 </list>
 <p>
 En réalité, utilisez <prgn>tasksel</prgn> ou <prgn>aptitude</prgn> pour
 sélectionner «&nbsp;Japanese Environment&nbsp;» et éviter d'installer des
 logiciels qui entrent en conflit avec le système normal.
 <item>ajouter une locale qui supporte les caractères japonais (par exemple
 ja_JP.UTF-8, voir <ref id="l10n">).
 <item>ajouter les valeurs d'environnement suivantes dans
 <file>~/.xenvironment</file> en utilisant la même astuce que dans <ref
 id="ss-xsu">.
<example>
XMODIFIERS="@im=kinput2"
LC_CTYPE=ja_JP.UTF-8 # locale japonaise
</example>
(Ou faites le manuellement dans un <prgn>xterm</prgn> avant de lancer une
application.)
<item>activer XIM <prgn>kinput2</prgn> en ajoutant <tt>*inputMethod:
kinput2</tt> dans votre fichier de ressources X (on dirait que Debian le
fait).
<item>Quelques applications (comme <prgn>mlterm</prgn>) permettent aussi de
configurer <tt>*inputMethod:</tt> dynamiquement au lancement (appuyez sur
Ctrl-BoutonSouris-3 dans mlterm).
<p>
</list>
Une fois l'application démarrée, vous devez appuyer sur
<strong>Shift+Espace</strong> et une fenêtre devrait s'ouvrir indiquant que
vous pouvez entrer des caractères japonais.
</sect>

<sect id="ssh">SSH
<p>
SSH (Secure SHell) est le moyen sécurisé de se connecter à d'autres machines
au travers d'Internet. Une version libre de SSH appelée OpenSSH est disponible
dans le paquet <package>ssh</package> de  &debian;.

<sect1 id="ssh-basics">Bases
<p>
Installez d'abord le serveur et le client OpenSSH.
<example>
# apt-get update && apt-get install ssh
</example>
L'entrée non-US doit être présente dans le fichier
<file>/etc/apt/source.list</file> Le fichier
<file>/etc/ssh/sshd_not_to_be_run</file> ne doit pas être présent si l'on veut
exécuter le serveur OpenSSH.
<p>
SSh possède 2 protocoles d'identification&nbsp;:
<list>
<item>Protocole SSH version 1&nbsp;:
 <list compact>
<item>la version de Potato supporte seulement ce protocole.
<item>méthodes d'identification disponibles&nbsp;:
  <list compact>
<item>RSAAuthentication&nbsp;: identification basée sur une clé RSA
<item>RhostsAuthentication&nbsp;: identification basée sur .rhosts (non sûr,
désactivé)
<item>RhostsRSAAuthentication&nbsp;: identification .rhosts combinée avec clé
RSA (désactivé)
<item>ChallengeResponseAuthentication&nbsp;: identification par
challenge-response RSA
<item>PasswordAuthentication&nbsp;: identification basée sur un mot de passe
  </list>
 </list>
<item>Protocole SSH version 2&nbsp;:
 <list compact>
<item>les versions d'après Woody utilisent ce protocole par défaut.
<item>méthodes d'identification disponibles&nbsp;:
  <list compact>
<item>PubkeyAuthentication&nbsp;: identification de l'utilisateur basée sur
une clé publique
<item>HostbasedAuthentication&nbsp;: identification par <file>.rhosts</file>
ou <file>/etc/hosts.equiv</file> combinée avec identification de l'hôte par
clé publique (désactivé)
<item>ChallengeResponseAuthentication&nbsp;: identification par
challenge-response RSA
<item>PasswordAuthentication&nbsp;: identification basée sur un mot de passe
  </list>
 </list>
</list>

<p>
Faites attention avec ces différences si vous migrez vers Woody ou si vous
utilisez un système non &debian;.
<p>
Voir <file>/usr/share/doc/ssh/README.Debian.gz</file>,
<manref name="ssh" section="1">,
<manref name="sshd" section="8">,
<manref name="ssh-agent" section="1">, et
<manref name="ssh-keygen" section="1"> pour plus de détails.

<p>
Les fichiers suivants sont les fichiers de configuration importants.

<list>

<item><file>/etc/ssh/ssh_config</file>&nbsp;: valeurs par défaut pour le
client SSH. Voir <manref name="ssh" section="1">. Entrées à noter&nbsp;:

 <list compact>
<item><tt>Host</tt>&nbsp;: Restreint les entrées suivantes (jusqu'au prochain
Host) aux hôtes qui correspondent au motif donné après le mot clé.
<item><tt>Protocol</tt>&nbsp;: Spécifie la version du protocole SSH. Par
défaut, «&nbsp;2,1&nbsp;».
<item><tt>PreferredAuthentications</tt>&nbsp;: Spécifie la méthode
d'identification pour le client SSH2. Par défaut,
«&nbsp;hostbased,publickey,keyboard-interactive,password&nbsp;».
<item><tt>ForwardX11</tt>&nbsp;: Désactivé par défaut. Peut être outrepassé
par l'option <tt>-X</tt> en ligne de commande.
 </list>

<item><file>/etc/ssh/sshd_config</file>&nbsp;: valeurs par défaut pour le
serveur SSH. Voir <manref name="sshd" section="8">. Entrées à noter&nbsp;:

 <list compact>
<item><tt>ListenAddress</tt>&nbsp;: Spécifie les adresses locales que
<prgn>sshd</prgn> doit écouter. Plusieurs options sont permises.
<item><tt>AllowTcpForwarding</tt>&nbsp;: Désactivé par défaut.
<item><tt>X11Forwarding</tt>&nbsp;: Désactivé par défaut.
 </list>

<item><file>$HOME/.ssh/authorized_keys</file>&nbsp;: liste de clés publiques
par défaut utilisées pour se connecter à ce compte sur cette machine. Voir
<manref name="ssh-keygen" section="1">.

<item><file>$HOME/.ssh/identity</file>&nbsp;: Voir <manref name="ssh-add"
section="1"> et <manref name="ssh-agent" section="1">.
</list>

<p>
Les commandes suivantes permettent de démarrer une connexion <prgn>ssh</prgn>.
<example>
$ ssh username@hostname.domain.ext
$ ssh -1 username@hostname.domain.ext # Force SSH version 1
</example>
Pour un utilisateur, <prgn>ssh</prgn> est plus intelligent que
<prgn>telnet</prgn> (il ne crashe pas avec ^]).
</sect1>

<sect1 id="ssh-forward">Redirection de port &ndash; tunnel SMTP/POP3
<p>
Pour établir un tunnel pour se connecter au port 25 de <var>remote-server</var>
depuis le port 4025 de la machine locale, et au port 110 de
<var>remote-server</var> depuis le port 4110 de la machine locale par
<prgn>ssh</prgn>, exécutez les commandes suivantes sur la machine locale&nbsp;:
<example>
# ssh -q -L 4025:remote-server:25 4110:remote-server:110 \
           username@remote-server
</example>
C'est un moyen sécurisé d'effectuer une connexion vers un serveur SMTP/POP3 au
travers d'Internet. Positionnez l'entrée <tt>AllowTcpForwarding</tt> à
<tt>yes</tt> dans <file>/etc/ssh/sshd_config</file> sur la machine distante.
</sect1>

<sect1 id="ssh-rsa">Se connecter avec moins de mots de passe
<p>
On peut éviter de se rappeler le mot de passe pour chaque système distant en
utilisant RSAAuthentication (protocole SSH1) ou PubkeyAuthentication
(protocole SSH2).
<p>
Sur le système distant, le contenu de <file>/etc/ssh/sshd_config</file> doit
contenir «&nbsp;RSAAuthentication yes&nbsp;» ou «&nbsp;PubkeyAuthentication
yes&nbsp;».
<p>
Générez ensuite les clés d'identification localement et installez la clé
publique sur le système distant&nbsp;:
<example>
$ ssh-keygen          # RSAAuthentication&nbsp;: clé RSA1 pour SSH1
$ cat .ssh/id_rsa.pub | ssh user1@remote \
        "cat - &gt;&gt;.ssh/authorized_keys"
...
$ ssh-keygen -t rsa   # PubkeyAuthentication&nbsp;: clé RSA pour SSH2
$ cat .ssh/id_rsa.pub | ssh user1@remote \
        "cat - &gt;&gt;.ssh/authorized_keys"
...
$ ssh-keygen -t dsa   # PubkeyAuthentication&nbsp;: clé DSA pour SSH2
$ cat .ssh/id_dsa.pub | ssh user1@remote \
        "cat - &gt;&gt;.ssh/authorized_keys"
</example>
On peut changer la phrase de passe par la suite avec <tt>ssh-keygen -p</tt>.
Assurez-vous de vérifier la configuration en testant la connexion. En cas de
problème, utilisez <tt>ssh -v</tt>.
<p>
Vous pouvez ajouter des options dans les entrées de
<prgn>authorized_keys</prgn> pour limiter les hôtes et exécuter des commandes
spécifiques. Consultez <manref name="sshd" section="8"> pour plus de détails.
<p>
Notez que SSH2 fait une identification de type
<tt>HostbasedAuthentication</tt>. Pour que cela fonctionne, il faut régler la
configuration de <tt>HostbasedAuthentication</tt> à <tt>yes</tt> dans
<file>/etc/ssh/sshd_config</file> sur le serveur et
<file>/etc/ssh/ssh_config</file> ou <file>$HOME/.ssh/config</file> sur le
client.
</sect1>

<sect1 id="ssh-client">Clients SSH étrangers
<p>
Il existe quelques clients SSH gratuits disponibles pour des systèmes non
Unix.
<taglist>
<tag>Windows
<item><url id="&puttyhome;" name="puTTY"> (GPL)
<tag>Windows (cygwin)
<item>SSH in <url id="&cygwinhome;" name="cygwin"> (GPL)
<tag>Macintosh Classic
<item><url id="&macsshhome;" name="macSSH"> (GPL) [Notez que Mac OS X inclut
OpenSSH&nbsp;; utilisez <tt>ssh</tt> depuis l'application Terminal]
</taglist>
Voir <url id="&sfdochome;" name="SourceForge.net, documentation du site">,
«&nbsp;6. CVS Instructions&nbsp;».

<sect1 id="ssh-agent">SSH agent
<p>
<!-- XXX FIXME XXX ssh-agent can be improved -->
Mettez simplement votre clé publique dans <file>~/.ssh/authorized_keys</file>,
et c'est bon&nbsp;:
<example>
$ ssh-agent
$ # copiez la sortie dans votre shell
$ ssh-add .ssh/identity
$ # ou ssh-add .ssh/id_dsa selon le nom de votre clé privée
$ scp <var>remote.host.with.public.key</var>
</example>
Pour plus d'information, consultez <manref name="ssh-agent" section="1"> et
<manref name="ssh-add" section="1">.
</sect1>

<sect1 id="ssh-trouble">Problèmes
<p>
Si vous rencontrez des problèmes, vérifiez les permission du fichier de
configuration et lancez <prgn>ssh</prgn> avec l'option <tt>-v</tt>.
<p>
Utilisez <tt>-P</tt> si vous êtes root et avez des problèmes avec un
pare-feu&nbsp;; cela évite d'utiliser des ports serveur 1&ndash;1023.
<p>
Si les connexions <prgn>ssh</prgn> vers un site distant arrêtent subitement de
fonctionner, cela peut être suite à des bidouilles de l'administrateur,
sûrement un changement de <prgn>host_key</prgn> pendant une maintenance du
système. Après s'être assuré que c'est bien le cas et que personne n'essaie de
se faire passer pour la machine distante par une bidouille, on peut se
reconnecter en enlevant l'entrée <prgn>host_key</prgn> de
<file>~/.ssh/known_hosts</file> sur la machine locale.
</sect1>
</sect>

<sect id="mail">Logiciels de courrier électronique
<p>
La configuration du courrier électronique se divise en trois parties&nbsp;:
<list>
<item>MTA&nbsp;: <prgn>exim</prgn>
<item>MUA&nbsp;: <prgn>mutt</prgn>
<item>Utilitaires&nbsp;: <prgn>procmail</prgn>, <prgn>fetchmail</prgn>,
<prgn>mail</prgn>,...
</list>

<sect1>Agent de transport de courrier électronique (Exim)
<p>
Références&nbsp;:
<list compact>
<item>paquets <package>exim-doc</package> et <package>exim-doc-html</package>
<item><url id="&eximhome;">
</list>
<p>
Utilisez <prgn>exim</prgn> comme agent de transport de courrier électronique
(Mail Transport Agent, MTA).
Configurez-le&nbsp;:
<example>
/etc/exim.conf          "eximconfig" pour créer et éditer
/etc/inetd.conf         mettez smtp en commentaire pour exécuter exim en tant
que daemon
/etc/email-addresses    ajoutez les listes d'adresses sources spoofées
Vérifiez le filtre avec exim -brw, -bf, -bF, -bV, ... etc.
</example>
</sect1>

<sect1>Tout récupérer pour les adresses e-mail non existantes (Exim)
<p>
Dans <file>/etc/exim/exim.conf</file> (Woody ou plus), dans la partie
DIRECTORS, à la fin (après localuser: director) ajoutez une directive
"catch-all" qui correspond à toutes les adresses que la directive précédente
ne pouvait résoudre (par Miquel van Smoorenburg)&nbsp;:
<example>
catchall:
  driver = smartuser
    new_address = webmaster@mydomain.com
</example>
<p>
Si vous souhaitez une recette plus détaillée pour chaque domaine virtuel,
ajoutez ce qui suit à la fin de <file>exim.conf</file> (par moi, pas bien
testé)&nbsp;:
<example>
*@yourdomain.com ${lookup{$1}lsearch*{/etc/email-addresses} \
        {$value}fail} T
</example>
Et ajoutez une entrée «&nbsp;*&nbsp;» dans <file>/etc/email-addresses</file>.
</sect1>

<sect1>Utilitaire de courrier électronique (fetchmail)
<p>
<prgn>fetchmail</prgn> est exécuté en mode démon et récupère le courrier
électronique du compte POP3 du FAI sur le système de mail local. Configurez&nbsp;:
<example>
/etc/init.d/fetchmail   voir ci-dessous pour le script
/etc/rc?.d/???fetchmail exécutez update-rc.d fetchmail defaults 30
/etc/fetchmailrc        fichier de configuration (chown 600)
/etc/init.d/fetchmail
</example>
<p>
Les informations pour démarrer fetchmail en mode démon depuis un script
<prgn>init.d</prgn> dans Potato ne sont pas claires (Woody corrige
cela). Voir <url id="examples/" name="/etc/init.d/fetchmail et
/etc/fetchmailrc">.
<p>
Si vos en-têtes de courriers électroniques sont contaminées par des ^M dûs au
logiciel de courrier électronique de votre FAI, ajoutez «&nbsp;stripcr&nbsp;»
aux options dans <file>$HOME/.fetchmailrc</file>&nbsp;:
<example>
options fetchall no keep stripcr
</example>
</sect1>

<sect1>Utilitaire de courrier électronique (procmail)
<p>
<prgn>procmail</prgn> est un filtre pour le courrier électronique délivré.
Il faut créer un <file>$HOME/.procmailrc</file> pour chaque compte qui
l'utilise.
Exemple&nbsp;: <url id="examples/" name="_procmailrc">.
</sect1>

<sect1>Agent pour utilisateur de courrier électronique (Mutt)
<p>
Utilisez <prgn>mutt</prgn> comme agent pour utilisateur de courrier
électronique (Mail User Agent, MUA) associé à <prgn>vim</prgn>.
Personnalisez-le dans
<file>~/.muttrc</file>&nbsp;:
<example>
# utiliser le mode visuel et "gq" pour reformater les citations
set editor="vim -c 'set tw=72 et ft=mail'"
#
# sélection des en-têtes prise dans le manuel ("Sven's Draconian header
# weeding")
#
ignore *
unignore from: date subject to cc
unignore user-agent x-mailer
hdr_order from subject to cc date user-agent x-mailer
auto_view application/msword
....
</example>
Ajoutez ce qui suit dans <file>/etc/mailcap</file> ou
<file>$HOME/.mailcap</file> pour afficher les courriers électroniques en HTML
et les attachements MS Word dans le message&nbsp;:
<example>
text/html; lynx -force_html &percnt;s; needsterminal;
application/msword; /usr/bin/antiword '&percnt;s'; copiousoutput;
description="Microsoft Word Text"; nametemplate=&percnt;s.doc
</example>

</sect1>

</sect>

<sect id="l10n">Localisation et support des langues nationales
<p>
&debian; est internationalisé et supporte un nombre toujours plus élevé de
langues et de conventions locales. La sous-section suivante liste quelques
formes de la diversité que &debian; supporte actuellement, et la sous-section
suivante parle de la <strong>localisation</strong>, processus de
personnalisation de votre environnment de travail pour permettre l'entrée et
l'affichage de votre langue et conventions pour les dates, les formats
numériques et monétaires, et d'autres aspects d'un système qui diffèrent selon
votre région.

<sect1 id="languages">Support des langues
<p>
<taglist>
 <tag>Clavier
  <item>&debian; est distribuée avec le support pour près de deux douzaines de
  claviers, et avec des utilitaires (dans le paquet <tt>kbd</tt> ) pour
  installer, visualiser et modifier les tables de caractères.
  <p>Si vous avez besoin d'installer un clavier différent, exécutez simplement
<example>
#dpkg-reconfigure console-date
</example>
  et debconf vous demandera la carte de clavier à utiliser.
 <tag>Données
  <item>La grande majorité des paquets de logiciels Debian supporte l'entrée
  de caractères non US-ASCII grâce à la technologie des <tt>locales</tt>
  offerte par la glibc (voir <ref id="locales">.
   <list compact>
   <item>Propres en 8 bits&nbsp;: presque tous les programmes
   <item>Autres langues latines (par exemple ISO-8859-1 ou ISO-8859-2)&nbsp;:
   majorité des programmes
   <item>langues multi-octets comme le Japonais ou le Coréen&nbsp;: beaucoup
   de nouvelles applications
   </list>
 <tag>Affichage
  <item>X supporte toutes les polices. La liste inclut non seulement les
  polices 8 bits mais aussi des polices 16 bits comme pour le Chinois, le
  Japonais et le Coréen. Voir <ref id="x-cjk">.
 <tag>Traduction
  <item>Des traductions existent pour beaucoup de messages texte et documents
  qui sont affichés par le système &debian;, comme les messages d'erreur,
  l'affichage standard des programmes, les menus et les pages de manuel.
  Actuellement, le support pour les langues Allemand, Espagnol, Finlandais,
  Français, Hongrois, Italien, Japonais, Koréen et Polonais dans les pages de
  manuel est fourni par les paquets <tt>manpages-<var>LANG</var></tt> (où
  <var>LANG</var> est le code ISO à deux lettres du pays).
  <p>
  Pour accéder à une page de manuel NLS, l'utilisateur doit configurer la
  variable du shell LC_MESSAGES de la façon appropriée. Par exemple, dans le
  cas des pages de manuel en Italien, LC_MESSAGES doit être positionnée à
  <tt>it</tt>. Le programme <prgn/man/ cherchera alors les pages de manuel en
  Italien sous <file>/usr/share/man/it/</file>. Voir <ref id="locales"> pour
  plus d'information sur la configuration des variables de locale.
</taglist>

<sect1 id="locales">Locales
<p>
Debian supporte la technologie <strong>locale</strong>. C'est un mécanisme
qui permet aux programmes de fournir un affichage et des fonctionnalités
adaptés aux conventions locales comme le jeu de caractères, le format de la
date et de l'heure, le symbole de la monnaie, et ainsi de suite. Il utilise
des variables d'environnement pour déterminer le comportement approprié. Par
exemple, en supposant que vous avez les locales Anglais américain et Français
installées sur votre système, les messages d'erreur de beaucoup de programmes
peuvent être bilingues&nbsp;:
<example>
$ LANG="en_US" cat foo
cat: foo: No such file or directory
$ LANG="fr_FR" cat foo
cat: foo: Aucun fichier ou répertoire de ce type
</example>
La glibc offre le support pour cette fonctionnalité dans la bibliothèque. Voir
<manref name="locale" section="7">.

<sect1 id="activate-locales">Activer le support des locales
<p>
Debian n'est <strong>pas</strong> livrée avec toutes les locales disponibles
précompilées. Consultez le fichier <file>/usr/lib/locale</file> pour voir
quelles locales (à part le défaut, «&nbsp;C&nbsp;») sont compilées pour votre
système. Si celle dont vous avez besoin n'est pas présente, vous avez deux
possibilités&nbsp;:
<list compact>
 <item>Editer <file>/etc/locale.gen</file> pour ajouter la locale souhaitée,
 et lancer <prgn>locale-gen</prgn> en tant que root pour la compiler. Voir
 <manref name="locale-gen" section="8"> et les pages de manuel listées dans la
 section «&nbsp;Voir aussi&nbsp;».
 <item>Lancer <tt>dpkg-reconfigure locales</tt> pour reconfigurer le paquet
 <package>locales</package>. Ou s'il n'est pas déjà installé, l'installation
 de <package>locales</package> invoquera l'interface debconf pour choisir les
 locales désirée et les compiler.
</list>

<sect1 id="env-locale">Activer une locale particulière
<p>
Les variables d'environnement suivantes sont évaluées dans cet ordre pour
fournir les valeurs de locale aux programmes&nbsp;:
<enumlist>
<item>LANGUAGE&nbsp;: cette variable d'environnement consiste en une liste de
locales séparées par deux points verticaux, dans l'ordre de priorité. Utilisé
seulement si la locale POSIX est positionnée à une valeur autre que "C" [dans
Woody&nbsp;; la version de Potato a toujours priorité sur la locale POSIX]. (GNU
extension)
<item>LC_ALL&nbsp;: Si cette variable est non nulle, sa valeur est utilisée
pour toutes les catégories de locales. (POSIX.1) Habituellement "" (null).
<item>LC_*&nbsp;: Si cette variable est non nulle, sa valeur est utilisée pour
la catégorie correspondante. (POSIX.1) Habituellement "C".
<p>
Les variables LC_* sont&nbsp;:
 <list compact>
<item>LC_CTYPE&nbsp;: Classification des caractères et conversion de casse.
<item>LC_COLLATE&nbsp;: Ordre de collation.
<item>LC_NUMERIC&nbsp;: Formats des nombres non monétaires.
<item>LC_MONETARY&nbsp;: Formats monétaires.
<item>LC_MESSAGES&nbsp;: Formats des messages d'information et de diagnostic
et des réponses intéractives.
<item>LC_PAPER&nbsp;: Taille du papier.
<item>LC_NAME&nbsp;: Formats des noms.
<item>LC_ADDRESS&nbsp;: Formats des adresses et information sur les lieux.
<item>LC_TELEPHONE&nbsp;: Formats des numéros de téléphone.
<item>LC_MEASUREMENT&nbsp;: Unités de mesure (Metric ou Other).
<item>LC_IDENTIFICATION&nbsp;: Donnée générale sur l'information de la locale.
 </list>
<item>LANG&nbsp;: Si cette variable est non nulle, et que LC_ALL n'est pas
définie, sa valeur est utilisée pour toutes les catégories de locales LC_*
sans valeur définie. (POSIX.1) Habituellement, "C".
</enumlist>
Notez que certaines applications (par exemple Netscape 4) ignorent les valeurs
LC_*.
<p>
Le programme <prgn>locale</prgn> peut afficher la locale active et les locales
disponibles&nbsp;; voir <manref name="locale" section="1">. (NOTE&nbsp;:
<tt>locale -a</tt> liste toutes les locales du système&nbsp;; cela ne signifie
pas qu'elles sont toutes compilées&nbsp;! Voir <ref id="activate-locales">.)
<p>
NdT&nbsp;: pour configurer &debian; pour le Français avec le support de
l'Euro, voir le document <url
id="http://www.debian.org/doc/manuals/fr/debian-fr-howto/" name="Utiliser et
configurer Debian pour le Français">.

<sect1 id="beyond-locale">Après <tt>locale</tt>
<p>
Certains programmes peuvent nécessiter une configuration en plus de la
<tt>locale</tt> pour obtenir un environnement de travail confortable.
<p>
Le paquet <package>language-env</package> avec sa commande
<prgn>set-language-env</prgn> est un script qui facilite la configuration de
l'environnement de langue nationale sur un système &debian;.
<p>
De plus, des entrées spécifiques à chaque langue dans le système de
«&nbsp;tâches&nbsp;» que l'on accède avec <prgn>tasksel</prgn> ou
<prgn>aptitude</prgn> sont une autre ressource utile.
<p>
Pour un example avec X, voir <ref id="x-cjk">.
<p>
Pour plus d'information, voir <url id="&suse-cjk;" name="Pages Suse pour
CJK">. Voir aussi le document sur l'internationalisation, <url
id="&intro-i18n;" name="Introduction to i18n">. Il est destiné aux développeurs
mais est aussi utile aux administrateurs système.

</sect1>
</sect>
</chapt>
