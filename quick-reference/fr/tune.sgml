<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.14"  -->
<chapt id="tune">Configurer un système Debian GNU/Linux

<sect id="sudo"><prgn>sudo</prgn> - un environnement de travail plus sûr
<p>
J'utilise <prgn>sudo</prgn> principalement comme protection contre ma
stupidité. Utiliser <prgn>sudo</prgn> est toujours mieux que d'utiliser le
système avec le compte root.
<p>
Installez <prgn>sudo</prgn> et activez-le en configurant
<url id="examples/" name="/etc/sudoers">.
<p>
Cette configuration fournit aux membres du groupe staff un accès à toutes les
commandes lancées en tant que root avec <prgn>sudo</prgn> et donne aux membres
du groupe src un accès à certaines commandes lancées en tant que root avec
<prgn>sudo</prgn>.
<p>
L'avantage de <prgn>sudo</prgn> est qu'il requiert seulement les mots de passe
utilisateurs pour se connecter et que l'activité est surveillée. C'est un
moyen simple de donner des pouvoirs à un administrateur débutant. Par exemple
:
<example>
$ sudo chown -R myself:mygrp .
</example>
<p>
Bien sûr, si vous connaissez le mot de passe de root (comme beaucoup
d'utilisateurs individuels), n'importe quelle commande peut être lancée en
tant que root depuis un  compte utilisateur.
<example>
$ su -c "shutdown -h now"
Password:
</example>
(Je sais que je devrais limiter les privilèges du compte administrateur avec
<prgn>sudo</prgn>. Mais comme c'est mon serveur personnel, je ne me suis
pas encore embêté avec ça.)
<p>
Un autre programme permet à des utilisateurs ordinaires de lancer des
commandes avec les privilèges de root; consultez le paquet
<package>super</package>.
</sect>

<sect id="backup">Sauvegarde des fichiers de configuration
<p>
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect>

<sect id="cdrw">Graveur de CD
<p>
Un graveur de CD sur interface ATAPI/IDE est devenu un matériel courant. C'est
un bon média pour sauvegarder et archiver un système pour un utilisateur
individuel ayant besoin d'une capacité &lt; 640 Mo. Pour des informations plus
officielles, consultez
<file>/usr/share/doc/HOWTO/en-txt/CD-Writing-HOWTO.txt.gz</file> (LDP).
Assurez-vous de récupérer une version parue après 2000.

<sect1>Introduction
<p>
D'abord, sachez qu'une interruption de l'envoi des données vers le
graveur entraînera des erreurs irrécupérables sur le CD. Prenez donc un graveur
avec un cache aussi gros que possible. Si le prix n'a pas d'importance, optez
pour une version SCSI plutôt qu'ATAPI/IDE. Si vous avez le choix de
l'interface IDE sur laquelle connecter le graveur, préférez celle sur bus PCI
(une de celles de la carte mère) plutôt qu'une sur bus ISA (carte SB16, etc.).
<p>
Un graveur connecté sur interface IDE doit être piloté par le pilote IDE-SCSI
et non par le pilote CD IDE habituel. Le pilote SCSI générique doit aussi être
activé. Pour cela, deux approches existent pour les noyaux distribués avec
des distributions modernes (à la date de mars 2001).
</sect1>

<sect1>Première approche : modules + <prgn>lilo</prgn>
<p>
Ajoutez la ligne suivante à <file>/etc/lilo.conf</file> si vous utilisez le
noyau distribué avec Debian. Si vous utilisez plusieurs options, listez-les en
les séparant par des espaces.
<example>
append="hdx=ide-scsi"
</example>
Ici, le graveur, accédé par le pilote ide-scsi, est identifié par
<tt>hdx</tt>, ou <em>x</em> représente :
<example>
hdb      esclave sur le premier port IDE
hdc      maître sur le second port IDE
hdd      esclave sur le second port IDE
hde-hdh  sur un port IDE externe
</example>
Lancez les commandes suivantes, en tant que root, pour activer les options
après avoir terminé la configuration :
<example>
# lilo
# shutdown -h now
</example>
</sect1>


<sect1>Seconde approche : recompiler le noyau
<p>
Debian utilise <prgn>make-kpkg</prgn> pour créer le noyau.  Utilisez la
nouvelle option <tt>--append_to_version</tt> avec make-kpkg pour créer
plusieurs images du noyau.
Utilisez la configuration suivante avec <tt>make menuconfig</tt> :
<list>
<item>bzImage
<item>Excluez le pilote CD IDE (non obligatoire mais c'est plus simple comme ça)
<item>Ajoutez ide-scsi et sg, ou compilez les en tant que modules
</list>
</sect1>

<sect1>Etapes post-configuration
<p>
Le support pour le graveur peut être activé dans le noyau lors du démarrage
avec les commandes suivantes :
<example>
# echo ide-scsi &gt;&gt;/etc/modules
# echo sg       &gt;&gt;/etc/modules
# cd /dev; ln -sf scd0 cdrom
</example>
Une activation manuelle peut aussi être effectuée avec :
<example>
# modprobe ide-scsi
# modprobe sg
</example>
Après un redémarrage, vous pouvez vérifier l'installation avec :
<example>
$ dmseg|less
# apt-get install cdrecord
# cdrecord -scanbus
</example>
</sect1>

<sect1>Image de CD (bootable)
<p>
Pour créer un CD-ROM contenant des fichiers contenus dans le répertoire
<file>target-directory/</file> en tant qu'image nommée
<file>cd-image.raw</file> (CD bootable, format Joliet TRANS.TBL. Pour un CD
non bootable, enlevez les options <tt>-b</tt> et <tt>-c</tt>), insérez une
disquette de démarrage dans le premier lecteur de disquette et faites :
<example>
# dd if=/dev/fd0 target-directory/boot.img 
# mkisofs -r -V volume_id -b boot.img -c bootcatalog -J -T \
        -o cd-image.raw target_directory/
</example>
<p>
Une utilisation amusante est de créer un CD-ROM DOS bootable. Si
<file>boot.img</file> contient l'image d'une disquette de démarrage DOS, le
CD-ROM démarrera comme si une disquette DOS était dans le premier lecteur de
disquette (A:). Faire cela avec freeDOS est encore plus intéressant. 
<p>
L'image créée peut être vérifiée en la montant en utilisant le périphérique de
boucle (loop device).
<example>
# mount -t iso9660 -o ro,loop cd-image.raw /cdrom
# cd /cdrom
# mc
# umount /cdrom
</example>
</sect1>

<sect1>Graver un CD
<p>
Premier test avec les commandes suivantes (cas d'un graveur double vitesse) :
<example>
# nice --20 cdrecord -dummy speed=2 dev=0,0 disk.img
</example>
Si le test est réussi, gravez un CD-R avec :
<example>
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img
</example>
Ou gravez un CD-RW avec :
<example>
# nice --20 cdrecord -v -eject blank=fast speed=2 dev=0,0 disk.img
</example>
</sect1>


<sect1>Créer l'image d'un CD
<p>
Certains CD-R et CD commerciaux ont des secteurs parasites à la fin qui les
rendent incopiables par <prgn>dd</prgn> (le CD de Windows 98 est l'un d'eux).
Le paquet <package>cdrecord</package> comprend la commande
<prgn>readcd</prgn>. Utilisez-la pour copier le contenu de n'importe quel CD
dans un fichier image. S'il s'agit d'un CD de données, montez-le et exécutez
<prgn>mount</prgn> pour connaître sa taille. Divisez le nombre affiché (en
blocs de 1024 octets) par 2 pour connaître le nombre de secteurs du CD (2048
octets). Lancez <prgn>readcd</prgn> avec les bonnes options et utilisez
l'image du CD pour graver un CD-R/RW.
<example>
# readcd [target] [lun] [scsibusno] # selectionnez la fonction 11
</example> 
Ici, positionnez tous les paramètres de ligne de commande à 0 dans la plupart
des cas. Parfois, le nombre de secteurs donné par <prgn>readcd</prgn> est trop
important !  Utilisez le nombre donné par mount pour de meilleurs résultats.
<example>
Mon CD-R         = +2 secteurs
CD de MS Windows = +1 secteur, càd +2048 octets
</example>
</sect1>

<sect1>Créer des images de CD Debian
<p>
Pour obtenir les dernières informations, consultez le site 
<url id="http://cvs.debian.org/debian-cd/" name="Debian CD site."> 
Les dernières versions des logiciels peuvent être obtenues par CVS anonyme.
<example>
$ export CVSROOT=anonymous@cvs.debian.org:/cvs/debian-boot
$ cvs co debian-cd
</example>
Les commandes suivantes permettent de créer une image de CD :
<example>
# apt-get install debian-cd
# cd /etc/debian-cd
# vim CONF.sh
$ . CONF.sh
$ make distclean
$ make status
$ make list COMPLETE=1 SIZELIMIT1=555000000 SRCSIZELIMIT=665000000
$ make official_images
 ou si vous souhaitez seulement des images avec les binaires :
$ make bin-official_images
</example>
</sect1>

<sect1>Système de sauvegarde sur CD-R
<p>
Permet de copier les fichiers de configuration et de données importants sur
CD-R. Utilisez le script suivant :
<url id="examples/" name="backup">
</sect1>

<sect1>Copier un CD audio sur un CD-R
<p>
Je n'ai pas testé personnellement les commandes suivantes :
<example>
# apt-get get install cdrecord cdparanoia
# cdparanoia -s -B
# cdrecord dev=0,0,0 speed=2 -v -dao -eject defpregap=1 -audio *.wav
</example>
ou,
<example>
# apt-get install cdrdao #disk at once
# cdrdao read-cd --device /dev/cdrom --driver generic-mmc \
        --paranoia-mode 3 my_cd # read cd
# cdrdao write --device /dev/cdrom --driver generic-mmc --speed 8 \
        my_cd # write a new CD
</example>
<prgn>cdrdao</prgn> fait une vraie copie... (pas de trous, etc.)
</sect1>
</sect>

<sect>XFree86
<p>
Un "serveur X" est une machine qui affiche une fenêtre et/ou un bureau X sur
un écran et accepte des entrées au clavier et à la souris. Un "client X" est
une machine qui exécute des logiciels compatibles avec X-Window. L'utilisation
quelque peu inversée des mots serveur et client avec X est assez troublante
pour être notée. Pour plus de détails, référez-vous à
<file>XWindow-User-HOWTO.gz</file> (LDP) et <file>mini/Remote-X-Apps.gz</file>
(LDP).

<sect1>Serveur X
<p>
Consultez <manref name="XFree86" section="1"> pour des informations sur le
serveur X.
<p>
Pour (re)configurer X4 sous Woody, exécutez :
<example>
# dpkg-reconfigure --p=low xserver-xfree86
</example>
<p>
Exécution du serveur X depuis une console locale :
<example>
$ startx -- :&lt;display&gt; vtXX 
eg.:
$ startx -- :1 vt8
... 'exécution sur un terminal vt8 connecté à localhost:1
</example>
Il y a plusieurs façons de faire accepter les connexions distantes d'un client
X (côté application) à un serveur X (côté affichage) : la liste d'hôtes
(<prgn>xhost</prgn>), les cookies magiques (<prgn>xauth</prgn>) et la
redirection de port avec <prgn>ssh</prgn> (secure shell). J'explique les plus
faciles, <prgn>xhost</prgn> (non sûr) et <prgn>ssh</prgn> (sûr) ci-dessous.
</sect1>

<sect1>Client X
<p>
Le client X (côté application) sait sur quel affichage se connecter en
utilisant la variable d'environnement DISPLAY. Par exemple, avant de lancer le
client X, l'exécution des commandes suivantes permet de la changer :
<example>
$ export DISPLAY=:0 
        # Valeur par défaut, machine locale avec premier écran X
$ export DISPLAY=hostname.fulldomain.name:0.2
$ export DISPLAY=localhost:0
</example>
Ici, 
<list>
<item><tt>hostname:<var>D.S</var></tt> signifie écran <var>S</var> sur
affichage <var>D</var> de l'hôte <tt>hostname</tt> ; le serveur X de cet
affichage écoute le port TCP 6000+D.
<item><tt>host/unix:<var>D.S</var></tt> signifie écran <var>S</var> sur
affichage <var>D</var> de l'hôte <tt>host</tt> ; le serveur X de cet affichage
écoute la socket UNIX <file>/tmp/.X11-unix/XD</file> (et n'est donc utilisable
que depuis <tt>host</tt>).
<item><tt>:<var>D.S</var></tt> est équivalent à
<tt>host/unix:<var>D.S</var></tt>, où <tt>host</tt> est le nom de l'hôte local
</list>
Ce paramètre peut être recouvert en donnant au client X l'argument <tt>-display
hostname:0</tt> sur la ligne de commande lors de l'exécution.
</sect1>


<sect1>Connexion X distante : <prgn>xhost</prgn>
<p>
<prgn>xhost</prgn> autorise l'accès en se basant sur les noms d'hôtes, ce qui
n'est pas sécurisé. En l'utilisant derrière un firewall avec des utilisateurs
de confiance, les commandes suivantes permettent de désactiver la vérification
de l'hôte et autorisent des connexions de n'importe où.
<example>
$ xhost +
</example>
Vous pouvez réactiver la vérification de l'hôte avec :
<example>
$ xhost -
</example>
<p>
Ce mécanisme ne fait pas la différence entre les utilisateurs sur l'hôte
distant. De plus, les noms d'hôtes (les adresses en fait) peuvent être
falsifiés. Cela est très mauvais si vous êtes sur un réseau dans lequel vous
ne pouvez avoir confiance (par exemple avec une connexion PPP sur Internet).
</sect1>

<sect1>Connexion X distante : <prgn>ssh</prgn>
<p>
C'est un moyen sécurisé et simple de se connecter d'un serveur X local vers un
serveur d'applications distant. Démarrez le serveur X sur la station locale.
Démarrez un xterm et lancez <prgn>ssh</prgn> pour établir une connexion vers
le site distant. Ensuite, utilisez les commandes des applications X du serveur
distant pour les lancer à partir de l'invite xterm. 
<example>
localname @ localhost $ ssh -q -X -l loginname remotehost.domain
Password:
.....
loginname @ remotehost $ gimp &
</example>
</sect1>
</sect>

<sect id="ssh">SSH
<p>
SSH (Secure SHell) est le moyen sécurisé de se connecter à d'autres machines
au travers d'Internet. J'utilise OpenSSH. Dans Woody, SSH2 est utilisé.
Attention à la migration.

<sect1 id="ssh-basics">Bases
<p>
Le paquet non-US <package>ssh</package> doit être disponible à l'installation.
<example>
# apt-get install ssh
</example>
Les commandes suivantes permettent de démarrer une connexion <prgn>ssh</prgn>.
<example>
$ ssh username@hostname.domain.ext
$ ssh -1 username@hostname.domain.ext # Force SSH version 1
</example>
Pour un utilisateur, <prgn>ssh</prgn> est plus intelligent que
<prgn>telnet</prgn> (il ne crashe pas avec ^]).
</sect1>

<sect1 id="ssh-forward">Redirection de port &ndash; tunnel smtp/pop3
<p>
Pour établir un tunnel pour connecter au port 25 de <var>remote-server</var>
depuis le port 4025 de la machine locale, et au port 110 de
<var>remote-server</var> depuis le port 4110 de la machine locale par
<prgn>ssh</prgn>, exécutez les commandes suivantes sur la machine locale :
<example>
# ssh -q -L 4025:remote-server:25 4110:remote-server:110 \
           username@remote-server
</example>
C'est un moyen sécurisé d'effectuer une connexion vers un serveur SMTP/POP3 au travers d'Internet.
</sect1>

<sect1 id="ssh-rsa">Se connecter avec un minimum de passwords &ndash; RSAAuthentication
<p>
<em>[POTATO-SSH1]</em>
On peut éviter de se rappeler le mot de passe pour chaque système distant en utilisant RSAAuthentication.
<p>
Sur le système distant, le contenu de <file>/etc/ssh/sshd_config</file> doit
contenir "RSAAuthentication yes". Lancez ensuite :
<example>
$ ssh-keygen
$ cat .ssh/identity.pub | ssh user1@remote \
        "cat - &gt;&gt;.ssh/authorized_keys"
</example>
On peut changer la phrase-passe par la suite avec <tt>ssh-keygen -p</tt>.
Vérifiez bien la configuration en testant la connexion. En cas de problème,
utilisez <tt>ssh -v</tt>.
<p>
Vous pouvez ajouter des options dans les entrées de
<prgn>authorized_keys</prgn> pour limiter les hôtes et exécuter des commandes
spécifiques. Consultez <manref name="sshd" section="8"> pour plus de détails.
<p>
<em>[WOODY-SSH2]</em>
On peut éviter de se rappeler du mot de passe pour chaque système distant.
Exécutez les commandes suivantes sans phrase-passe.
<example>
$ ssh-keygen -t rsa
$ cat .ssh/id_rsa.pub | ssh user1@remote \
        "cat - &gt;&gt;.ssh/authorized_keys"
</example>
On peut changer la phrase-passe par la suite avec <tt>ssh-keygen -p</tt>.
Assurez-vous de vérifier la configuration en testant la connexion. En cas de
problème, utilisez <tt>ssh -v</tt>.
<p>
Vous pouvez ajouter des options dans les entrées de
<prgn>authorized_keys</prgn> pour limiter les hôtes et exécuter des commandes
spécifiques. Consultez <manref name="sshd" section="8"> pour plus de détails.
<p>
SSH2 contient HostbasedAuthentication. Pour que cela fonctionne, il se peut
que vous deviez ajuster les réglages dans <file>/etc/ssh/ssh_config</file> sur
le client :
<list>
<item>Set "HostbasedAuthentication yes"
<item>If there is a PreferredAuthentications line, "hostbased" should be the
first option (this is the default setting for <prgn>ssh</prgn>)
</list>
<p>
<![%FIXME[<p>=== Add info on "ssh-agent" ===]]>
</sect1>

<sect1 id="ssh-trouble">Problèmes
<p>
Si vous rencontrez des problèmes, vérifiez les permission du fichier de
configuration et lancez <prgn>ssh</prgn> avec l'option <tt>-v</tt>.
<p>
Utilisez <tt>-P</tt> si vous êtes root et avez des problèmes avec un firewall
car cela évite d'utiliser des ports serveur (1&ndash;1023).  <p> Suite à des
erreurs de l'administrateur du site distant, la connexion <prgn>ssh</prgn>
peut ne plus fonctionner. Cela peut être causé par un changement de
<prgn>host_key</prgn> pendant la maintenance du système. Après s'être assuré
que c'est bien le cas et que personne n'essaie de se faire passer pour la
machine distante par une bidouille, on peut se reconnecter en enlevant
l'entrée <prgn>host_key</prgn> de <file>~/.ssh/known_hosts</file> sur la
machine locale.
</sect1>


</sect>
</chapt>
