<!-- CVS revision of this document "$Revision: 1.17 $"  -->
<!-- CVS revision of original english document "1.30"  -->

<chapt id="tips">Astuces &debian;

<sect>Démarrer le système
<p>
Consultez le <url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> du LDP pour
des informations détaillées sur l'invite de démarrage.

<sect1 id="crackroot">"J'ai oublié le mot de passe de root !" (1)
<p>
On peux démarrer dans le compte administrateur (root) sans connaître le mot de
passe de root si on a un accès au clavier de la console.  (Cela suppose qu'il
n'y a pas de mot de passe requis pour le BIOS ni pour le chargeur de démarrage
comme <prgn>lilo</prgn> qui empêche de lancer le système).
<p>
Cette procédure ne nécessite ni disquette de démarrage externe ni changement 
dans les réglages du BIOS. Ici, "Linux" est le nom du noyau Linux par défaut 
qui lance le système Debian.
<p>
A l'écran d'invite de <prgn>lilo</prgn>, dès que <tt>boot:</tt> apparaît (il
faut appuyer sur la touche MAJ sur certains systèmes), entrez&nbsp;:
<example>
boot: Linux init=/bin/sh
</example>
Le système lance alors le noyau et exécute <file>/bin/sh</file> au lieu du
processus <prgn>init</prgn> standard. Vous avez maintenant les droits et le
shell de l'administrateur root. Puisque <file>/</file> est monté en lecture
seule et que beaucoup de partitions ne sont pas encore montées, vous devez
faire ce qui suit pour obtenir un système à peu près fonctionnel.
<example>
init-2.03# mount -n -o remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(Si la seconde colonne de <file>/etc/passwd</file> est «&nbsp;x&nbsp;» pour
tous les utilisateurs, votre système utilise les "shadow passwords" (NdT&nbsp;:
mots de passes cachés), et il faut éditer <file>/etc/shadow</file>.) Une entrée
vide dans la seconde colonne de l'un de ces fichiers désactive le mot de passe.
Maintenant le système peut être lancé sans le mot de passe de root.
Debian (au moins après Potato) nécessite d'entrer un mot de passe si le
système est lancé au niveau d'exécution (runlevel) 1, ce que d'anciennes
distributions ne faisait pas.
<p>
C'est une bonne idée d'avoir un éditeur minimum dans <file>/bin</file> au cas
où <file>/usr</file> ne serait pas accessible (voir <ref id="bin-editor">).
<p>
Vous pouvez aussi installer le paquet <package>sash</package>. Si le système
ne démarre plus, lancez&nbsp;:
<example>
boot: Linux init=/bin/sash
</example>
<prgn>sash</prgn> sert de substitution intéractive à <prgn>sh</prgn> même
lorsque <file>/bin/sh</file> est inutilisable. Il est lié statiquement, et
inclut beaucoup d'utilitaires standard (tapez «&nbsp;help&nbsp;» à l'invite
pour une liste).
</sect1>

<sect1>"J'ai oublié le mot de passe de root !" (2)
<p>
Démarrez depuis n'importe quel ensemble de disquettes de boot/root.  Si
<file><var>/dev/hda3</var></file> est la partition racine originale, la suite
vous laissera éditer le fichier de mots de passe aussi facilement que
précédemment.
<example>
# mkdir <var>fixit</var>
# mount <var>/dev/hda3</var> <var>fixit</var>
# cd <var>fixit</var>/etc
# vi shadow
# vi passwd
</example>
<p>
L'avantage de cette méthode sur la précédente est qu'on n'est pas obligé de
connaître le mot de passe de <prgn>lilo</prgn>, mais on doit pouvoir régler le
BIOS pour que le système se lance depuis la disquette ou le CD.
</sect1>

<sect1>Je ne peux pas lancer le système
<p>
Pas de problème, personne ne prend la peine de faire une disquette de
démarrage lors de l'installation. Si <prgn>lilo</prgn> est cassé, récupérez la
disquette de démarrage de l'installation de Debian (rescue). Démarrez depuis
cette disquette. A l'invite de démarrage, en supposant que la partition racine
de Linux est <file><var>/dev/hda12</var></file> et que vous voulez le niveau
d'exécution (runlevel) 3, entrez&nbsp;:
<example>
boot: rescue root=<var>/dev/hda12</var> 3
</example>
Vous avez maintenant lancé un système presque totalement fonctionnel 
depuis le noyau présent sur la disquette. Il peut y avoir quelques problèmes 
et messages d'erreur mineurs à cause d'un manque dans les options du noyau ou 
d'un module absent.
<p>
Si vous avez besoin d'une disquette de démarrage personnalisée, lisez 
<file>readme.txt</file> sur la disquette rescue.
</sect1>

<sect1 id="bootprompt">Autres astuces avec l'invite de démarrage.
<p>
Le système peut être lancé à un niveau d'exécution particulier et avec des
options de configurations en utilisant l'invite de démarrage de
<prgn>lilo</prgn>.  Les détails sont données dans le
<url id="&bootprompt-howto;" name="BootPrompt-HOWTO"> (LDP).
<p>
Si vous voulez lancer le système au niveau d'exécution 4, entrez la ligne 
suivante à l'invite de <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Si vous voulez lancer le système en mode de fonctionnement mono-utilisateur 
normal, et que vous connaissez le mot de passe de root, un des exemples 
suivants à l'invite de <prgn>lilo</prgn> fonctionnera. 
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Si vous voulez lancer le système en utilisant moins de mémoire vive que le
système n'en a en réalité (par exemple 48Mo sur un ordinateur qui a 64Mo),
utilisez la commande suivante à l'invite de démarrage de <prgn>lilo</prgn> :
<example>
boot: Linux mem=48M
</example>
Assurez-vous de ne pas spécifier plus de mémoire que le système n'en a en
réalité, sinon le noyau va planter. Si vous avez plus de 64Mo de mémoire vive,
128Mo par exemple, à moins de spécifier <tt>mem=128M</tt> à l'invite de
<prgn>lilo</prgn> ou d'inclure une ligne "append" similaire dans
<file>/etc/lilo.conf</file>, les vieux noyaux et/ou les cates mères avec un
vieux BIOS n'utiliseront pas la mémoire au-delà des 64Mo.
</sect1>
</sect>

<sect>Enregistrer les activités

<sect1 id="script">Enregistrer les activités du shell
<p>
L'administration système est une série d'activités beaucoup plus élaborées
dans un environnement Unix que dans un environnement de PC ordinaire. Soyez
sûr de connaître les méthodes de configuration de base si vous avez besoin de
réparer les problèmes d'un système. Les interfaces graphiques des outils de
configuration peuvent avoir l'air agréable et commode, mais sont parfois
limitées surtout dans de telles situations.
<p>
Dans ce contexte, enregistrer les activités du shell est une bonne habitude, 
surtout si l'on est root.
<p>
Sous Emacs&nbsp;: utilisez <tt>M-x shell</tt> pour démarrer l'enregistrement
dans le buffer, et utilisez <tt>C-x C-w</tt> pour écrire le contenu du buffer
dans un fichier.
<p>
Sous le shell&nbsp;: utilisez la commande <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 .... faites ce que vous voulez ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
La méthode suivante peut être utilisée à la place de <prgn>script</prgn>.
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>

<sect1>Enregistrer les activités sous X
<p>
Si vous avez besoin d'enregistrer l'image d'une application sous X, y compris
une fenêtre de xterm, utilisez <prgn>gimp</prgn>. Il peut capturer une
fenêtre isolée ou l'écran entier. Des alternatives existent comme
<prgn>xwd</prgn> (paquet <package>xbase-clients</package>),
<prgn>import</prgn> (<package>imagemagick</package>), ou <prgn>scrot</prgn>
(<package>scrot</package>).
</sect1>

<sect1 id="backup">Enregistrer les changements aux fichiers de configuration
<p>
Le paquet <package>Changetrack</package> enregistrera les changements aux
fichiers de configuration dans des archives RCS. Voir <manref
name="changetrack" section="1">.
<example>
# apt-get install changetrack
# vi changetrack.conf
</example>
</sect1>

</sect>

<sect>Copier et archiver un sous-répertoire entier
<sect1>Commandes de base pour copier un sous-répertoire entier
<p>
En cas de réarrangement de la structure de fichiers, déplacez le contenu des 
dossiers y compris les liens par les commandes&nbsp;:
<example>
Méthode classique&nbsp;:
# cp -a /source/directory /dest/directory # version GNU de cp
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
S'il y a des liens durs, la méthode suivante est nécessaire&nbsp;:
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
Si le système de fichier est distant&nbsp;:
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
S'il n'y a pas de fichiers liés&nbsp;:
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
Ici, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> et <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
La méthode de copie d'un sous-répertoire entier est basée sur l'information
fournie par Manoj Srivastava &lt;srivasta@debian.org&gt; sur la liste de
diffusion debian-user@lists.debian.org.
</sect1>

<sect1><prgn>cp</prgn>
<p>
Traditionnellement, <prgn>cp</prgn> n'était pas réellement utilisable
puisqu'il ne déréférence pas les liens symboliques, ni ne préserve les liens
durs. Une autre chose à considérer était les fichiers à faible densité (avec
des trous).
<p>
La version GNU de <prgn>cp</prgn> a dépassé ces limitations&nbsp;; cependant,
sur un système non GNU, <prgn>cp</prgn> peut toujours avoir ces problèmes. De
plus, on ne peut pas générer de petites archives portables avec
<prgn>cp</prgn>.
<example>
&percnt; cp -a . newdir
</example>
<sect1><prgn>tar</prgn>
<p>
<prgn>tar</prgn> a éliminé certains des problèmes que <prgn>cp</prgn> avait
avec les liens symboliques. Cependant, bien que <prgn>cpio</prgn> gère les
fichiers spéciaux, le <prgn>tar</prgn> traditionnel ne les gère pas.
<p>
<prgn>tar</prgn> gère de multiples liens durs en plaçant une copie du lien sur
la bande, mais le nom de cette copie est le <em>seul</em> que vous pouvez
utiliser pour récupérer le fichier&nbsp;; <prgn>cpio</prgn> met une copie pour
chaque lien, et vous pouvez le récupérer en utilisant n'importe lequel des
noms.
<p>
La commande  <prgn>tar</prgn> a changé l'option pour les fichiers
<file>.bz2</file> entre Potato et Woody, donc utilisez <tt>--bzip2</tt> dans
des scripts au lieu de <tt>-I</tt> (Potato) ou <tt>-j</tt> (Woody).
</sect1>

<sect1><prgn>pax</prgn>
<p>
C'est le nouvel utilitaire d'archivage portable, compatible POSIX (IEEE Std
1003.2-1992, pages 380-388 (section 4.48) et pages 936-940 (section E.4.48)),
"qui chante et danse". <prgn>pax</prgn> lit, écrit, et liste les fichiers
d'une archive, et copie des hiérarchies de répertoires. <prgn>pax</prgn>
travaille indépendament du format de l'archive et supporte un grand nombre de
formats d'archives.
<p>
Les implémentations de <prgn>pax</prgn> sont récentes et encore chaudes.
<example>
# apt-get install pax
$ pax -rw -p e . newdir
 ou
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1><prgn>cpio</prgn>
<p>
<prgn>cpio</prgn> stocke ou extrait les fichiers dans ou à partir d'une
archive <prgn>cpio</prgn> ou <prgn>tar</prgn>. L'archive peut être un autre
fichier sur le disque, une bande magnétique ou un tube.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1><prgn>afio</prgn>
<p>
<prgn>afio</prgn> permet de mieux gérer les archives au format
<prgn>cpio</prgn>. Il est généralement plus rapide que <prgn>cpio</prgn>,
fournit plus d'options pour les bandes magnétiques, gère mieux les erreurs de
données en entrée et supporte des archives multi-volume en utilisation
intéractive. <prgn>afio</prgn> peut créer des archives compressées qui sont
plus sûres que les archives compressées de <prgn>tar</prgn> ou
<prgn>cpio</prgn>. <prgn>afio</prgn> est utilisé au mieux en tant que machine
à archiver dans un script de sauvegarde.
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
Toutes mes sauvegardes sur bande sont faites avec <prgn>afio</prgn>.
</sect1>

</sect>


<sect>Récupération d'un système bloqué
<sect1>Tuer un processus
<p>
Exécutez <prgn>top</prgn> pour voir quel processus agit bizarrement. Appuyez
sur «&nbsp;P&nbsp;» pour trier par temps CPU utilisé, «&nbsp;M&nbsp;» pour
trier par mémoire utilisée, et «&nbsp;k&nbsp;» pour tuer un processus.
<p>
Utilisez <prgn>kill</prgn> pour tuer (ou envoyer un signal à) un processus à
partir de son numéro de processus, ou <prgn>killall</prgn> pour faire la même
chose à partir du nom de la commande du processus. Signaux fréquemment
utilisés :
<example>
 1: HUP,  redémarre un daemon (NdT : serveur)
15: TERM, termine un process normalement
 9: KILL, tue un process
</example>

</sect1>

<sect1>ALT-SysRQ
<p>
L'option de compilation du noyau "Magic SysRq key" donne une assurance contre
un mauvais fonctionnement du système.
Appuyer sur <tt>ALT-SysRQ</tt> sur un i386, suivi par une des touches <tt>r 0
k e i s u b</tt>, agit magiquement.  
<p>
Un`R'aw récupère le clavier en cas de plantage de logiciels comme X.  Mettre
le niveau de log de la console à `0' réduit le nombre de messages d'erreur.
sa`K' (touche d'attention système, NdT&nbsp;: system attention key en Anglais)
tue tous les processus de la console vituelle courante. t`E'rminate tue tous
les processus du terminal courant excepté init. k`I'll tue tous les processus
excepté init.
<p>
`S'ync, `U'mount, et re`B'oot permettent de se sortir de très mauvaises
situations.
<p>
Les noyaux de l'installation par défaut de Debian ne sont pas compilés avec
cette option au moment où ce document est écrit. Recompilez le noyau pour
activer cette fonction. Des informations détaillées se trouvent dans
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file> ou
<file>/usr/src/<var>kernel-version</var>/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>


<sect>Petites commandes utiles à se rappeler

<sect1>Pager
<p>
<prgn>less</prgn> est le <em>pager</em> (visualisateur de contenu des
fichiers). Appuyez sur `h' pour de l'aide. Il peut faire beaucoup plus que
<prgn>more</prgn>. <prgn>less</prgn> peut être amélioré en exécutant <tt>eval
$(lesspipe)</tt> ou <tt>eval $(lessfile)</tt> dans les scripts de démarrage du
shell. Plus d'information dans <file>&f-lessopen;</file>. L'option <tt>-R</tt>
permet l'affichage de caractères bruts et active les séquences d'échappement
couleur ANSI. Voir <manref name="less" section="1">.
<p>
<prgn>w3m</prgn> peut être une bonne solution de rechange pour les systèmes de
code (EUC).

<sect1>Mémoire libre
<p>
<prgn>free</prgn> et <prgn>top</prgn> donnent de bonnes informations sur les
ressources mémoire. Ne vous inquiétez pas de la taille de "used" sur la ligne
"Mem:", lisez plutôt la ligne en-dessous (38792 dans l'exemple ci-dessous).
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
La quantité exacte de mémoire physique peut être confirmée par <tt>grep
'^Memory' /var/log/dmesg</tt>, qui dans notre cas d'exemple donne
«&nbsp;Memory: 256984k/262144k available (1652k kernel code, 412k reserved,
2944k data, 152k init)&nbsp;».
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Environ 5Mo ne sont pas utilisables par le système parce que le noyau les
utilise.
</sect1>

<sect1>Régler l'heure (BIOS)
<p>
<example>
# date MMJJhhmmAAAA
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Cela va régler l'heure du système et du matériel à JJ/MM hh:mm, AAAA.
L'heure est affichée selon le fuseau horaire local, mais le matériel utilise
UTC.

<sect1>Régler l'heure (NTP)
<p>
Référence&nbsp;: <url id="&time-howto;" name="Managing Accurate Date and Time
HOWTO">.
<p>
<sect2>Régler l'heure avec une connexion Internet permanente
<p>
Régler l'horloge système automatiquement via un serveur distant&nbsp;:
<example>
# ntpdate <var>server</var>
</example>
Il est bon d'avoir cette commande dans <file>/etc/cron.daily</file> si votre
système possède une connexion permanente à Internet.

<sect2>Régler l'heure avec une connexion Internet intermitente
<p>
Utilisez le paquet <package>chrony</package>.
</sect1>

<sect1>Comment désactiver l'écran de veille
<p>
En mode console&nbsp;:
<example>
# setterm -powersave off
</example>
<p>
Démarrez la console kon2 (kanji) avec&nbsp;:
<example>
# kon -SaveTime 0
</example>
<p>
Sous X&nbsp;:
<example>
# xset s off
 ou
# xset -dpms
 ou
# xscreensaver-command -prefs
</example>
Lisez les pages de manuel correspondantes.
</sect1>

<sect1 id="getent">Chercher dans la base de données administrative
<p>
La Glibc offre <manref name="getent" section="1"> pour chercher dans les
entrées des bases de données administratives, càd., passwd, group, hosts,
services, protocols, ou networks.
<example compact>
getent database [key ...]
</example>

<sect1>Désactiver le son (beep)
<p>
On peut toujours débrancher le haut-parleur PC ;-)
Pour le shell&nbsp;:
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc
</example>
</sect1>

<sect1>Messages d'erreur sur l'écran de la console
<p>
Afin de ne pas avoir de messages d'erreur sur l'écran, le premier endroit à
regarder est <file>/etc/init.d/klogd</file>. Réglez <tt>KLOGD="-c
<var>3</var>"</tt> dans ce script et lancez <tt>/etc/init.d/klogd
restart</tt>. Une autre méthode est de lancer <tt>dmesg -n<var>3</var></tt>.
<p>
Voici la signification des niveaux d'erreur&nbsp;:
<list compact>
<item>0: KERN_EMERG,   system is unusable
<item>1: KERN_ALERT,   action must be taken immediately
<item>2: KERN_CRIT,    critical conditions
<item>3: KERN_ERR,     error conditions
<item>4: KERN_WARNING, warning conditions
<item>5: KERN_NOTICE,  normal but significant condition
<item>6: KERN_INFO,    informational
<item>7: KERN_DEBUG,   debug-level messages
</list>
<p>
Si un message d'erreur particuler vous embête, pensez à faire une rustine
facile pour le noyau comme <file>shutup-abit-bp6</file> (disponible dans le
<url id="&examples;" name="sous-répertoire des exemples">).
<p>
Un autre endroit à regarder peut être le fichier
<file>/etc/syslog.conf</file>&nbsp;; vérifiez si les messages d'erreurs ne
sont pas envoyés vers une console.
</sect1>

<sect1>Régler la console
<p>
Les consoles sur les systèmes Unix sont habituellement accédées par des
fonctions de la bibliothèque (n)curses. Cela donne à l'utilisateur une méthode
indépendante du terminal pour mettre à jour les caractères sur l'écran avec
une optimisation raisonnable. Voir <manref name="ncurses" section="3X"> et
<manref name="terminfo" section="5">.
<p>
Sur un système &debian;, il existe beaucoup d'entrées prédéfinies&nbsp;:
<example>
$ toe | less                  # toutes les entrées
$ toe /etc/terminfo/ | less   # entrées reconfigurables
</example>
Exportez votre sélection dans une variable d'environnement <tt>TERM</tt>.
<p>
Si l'entrée terminfo pour xterm ne marche pas avec un xterm non Debian,
changez le type de terminal de «&nbsp;xterm&nbsp;» à l'une des versions
limitée en options comme «&nbsp;xterm-r6&nbsp;» lorsque vous vous connectez à
un système Debian à distance. Voir <file>&f-libncurse;</file> pour plus
d'information. «&nbsp;dumb&nbsp;» est le plus petit dénominateur commun pour
terminfo.
</sect1>

<sect1>Remettre la console dans un état sain
<p>
Lorsque l'écran devient illisible après <tt>$ cat
<var>fichierbinaire</var></tt> (il se peut que vous ne voyiez pas la commande
en tapant)&nbsp;:
<example>
$ reset
</example>
</sect1>

<sect1>Convertir des fichiers texte DOS vers Unix
<p>
Pour convertir un fichier texte DOS (fin de ligne <tt>^M^J</tt>) en fichier
texte Unix (<tt>^J</tt>)&nbsp;:
<example>
# apt-get install sysutils
$ dos2unix <var>dosfile</var>
</example>
</sect1>

<sect1>Modifier des fichiers grâce aux expressions rationnelles
<p>
Pour remplacer toutes les occurences de <var>FROM_REGEX</var> par
<var>TO_REGEX</var> dans tous les fichiers <var>FILES</var> ...&nbsp;:
<example>
# perl -i -p -e 's/<var>FROM_REGEX</var>/<var>TO_REGEX</var>/g;' <var>FILES</var> ...
</example>
<tt>-i</tt> est pour «&nbsp;édition sur place&nbsp;», <tt>-p</tt> est pour
«&nbsp;boucle implicite sur <var>FILES</var> ...&nbsp;». Si la substitution est
complexe, vous pouvez faciliter le retour sur des erreurs en utilisant le
paramètre <tt>-i.bak</tt> au lieu de <tt>-i</tt>&nbsp;; cela permet de garder
les fichiers originaux en leur ajoutant le suffixe <tt>.bak</tt>.
</sect1>

<sect1>Convertir un gros fichier en plusieurs petits
<p>
<example>
$ split -b 650m <var>file</var>   # sépare <var>file</var> en morceaux de 650Mo
$ cat x* ><var>largefile</var>    # assemble les fichiers en 1 gros fichier
</example>
</sect1>

<sect1>Bouts de scripts pour les tubes
<p>
Les scripts suivants font des choses sympa avec les tubes.
<example>
xargs -n 1 <var>command</var>
        # exécute <var>command</var> avec tous les arguments de stdin
xargs -n 1 echo|
        # place chaque argument séparé par des espaces sur une ligne
grep -e pattern|     # extrait les lignes contenant <var>pattern</var>
cut -d: -f3 -|       # extrait le 3e champ séparé par <var>:</var> 
                     # (fichier passwd, etc.)
col -bx |            # supprime backspace et transforme les tabulations en espaces
expand -|            # transforme les tabulations
sort -u|             # trie et supprime les doublons
tr '\n' ' '|         # concatène les lignes en une seule
tr '\r' ''|          # supprime CR
tr 'A-Z' 'a-z'|      # convertit les majuscules en minuscules
sed 's/^/# /'|       # change chaque ligne en commentaire
sed 's/\<var>.ext</var>//g'|    # supprime <var>.ext</var>
sed  -n -e 2p|       # affiche la 2e ligne
head -n 2 -|         # affiche les 2 premières lignes
tail -n 2 -|         # affiche les 2 dernières lignes
</example>
</sect1>

<sect1>Récupérer du texte ou une archive de liste de diffusion à partir d'une
page Web
<p>
Les commandes suivantes récupèrent une page web dans un fichier texte. Très
utile pour copier des configurations depuis le Web.
<example>
$ lynx -dump http://<var>www.remote-site.com/help-info.html</var> &gt;<var>textf
ile</var>
</example>
<prgn>links</prgn> et <prgn>w3m</prgn> peuvent aussi être utilisés, avec de légères différences dans le rendu.
<p>
S'il s'agit d'une archive de liste de diffusion, utilisez <prgn>munpack</prgn>
pour obtenir les contenus MIME à partir du texte.
</sect1>

<sect1>Imprimer joliement une page Web
<p>
Les commandes suivantes vont lire une page Web sur une imprimante/un fichier
PostScript.
<example>
$ apt-get install html2ps
$ html2ps <var>URL</var> | lpr
</example>
Voir <ref id="lprlpd">. Regardez aussi <prgn>a2ps</prgn> et <prgn>mpage</prgn> pour créer des fichiers PostScript.
</sect1>

<sect1>Mesurer la durée d'une commande
<p>
Affiche le temps pris par un processus.
<example>
# time <var>commande</var> &gt;/dev/null
real    0m0.035s       # durée sur l'horloge (temps réel écoulé)
user    0m0.000s       # durée en mode utilisateur
sys     0m0.020s       # durée en mode noyau
</example>
</sect1>

<sect1>Commande <prgn>nice</prgn>
<p>
Utilisez <prgn>nice</prgn> (du paquet GNU <package>shellutils</package>) pour
régler la «&nbsp;gentillesse&nbsp;» (valeur <em>nice</em>) d'une commande lors
de son exécution. <prgn>renice</prgn> (paquet <package>bsdutils</package>) ou
<prgn>top</prgn> peuvent changer la valeur <em>nice</em> d'un processus. Le
processus le plus lent (priorité la plus basse) aura une valeur de 19&nbsp;;
les valeurs négatives sont <em>not-nice</em> (NdT&nbsp;: litt. pas gentilles),
une valeur de -20 étant donnée au processus le plus rapide (priorité la plus
haute). Seul le superutilisateur peut donner des valeurs <em>nice</em>
négatives.
<example>
# nice  -19 <var>top</var>                                         # très gentil
# nice --20 <var>cdrecord -v -eject speed=2 dev=0,0 disk.img</var> # très rapide
</example>
Parfois, une valeur extrême de <em>nice</em> fait plus de mal que de bien au système. Utilisez cette commande en faisant attention.
</sect1>

<sect1>Programmer des activités (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Utilisez <prgn>cron</prgn> et <prgn>at</prgn> pour programmer des tâches sous
Linux. Consultez <manref name="at" section="1">, <manref name="crontab"
section="5">, <manref name="crontab" section="8">.
<p>
Exécutez la commande <tt>crontab -e</tt> pour créer ou éditer un fichier
crontab pour programmer des événements régulièrement. Exemple de fichier
crontab :
<example>
# utilise /bin/sh pour exécuter les commandes, quoi que dise /etc/passwd
SHELL=/bin/sh
# envoie un courrier électronique à Paul contenant tous les résultats, quelle
# que soit la personne a qui appartienne la crontab
MAILTO=paul
# Minute Heure JourDuMois Mois JourDeLaSemaine commande
# est exécuté à 00:05 chaque jour
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# est exécuté à 14:15 le 1e de chaque mois -- le résultat est envoyé à Paul
# par courrier électronique
15 14 1  * *   $HOME/bin/monthly
# est exécuté à 22:00 chaque jour de la semaine(1-5), ennuie Joe. &percnt; pour une
# nouvelle ligne, dernier &percnt; pour cc.
0 22 *   * 1-5 mail -s "It's 10pm" joe&percnt;Joe,&percnt;&percnt;Where are your kids?&percnt;.&percnt;&percnt;
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# est exécuté à 03:40 le premier lundi de chaque mois
40 3 1-7 * *   [ "$(date +&percnt;a)" == "Mon" ] && command -args
</example>
Exécutez la commande <prgn>at</prgn> pour programmer une tâche unique :
<example>
$ echo '<var>command -args</var>'| at 3:40 monday
</example>
</sect1>

<sect1>Changement de console avec <prgn>screen</prgn>
<p>
Le programme <prgn>screen</prgn> permet d'exécuter plusieurs terminaux virtuels
avec un shell intéractif sur chacun, sur un <strong>unique</strong> terminal
physique ou émulateur de terminal. Même si vous utilisez les consoles
virtuelles de Linux ou plusieurs fenêtres xterm, explorer <prgn>screen</prgn>
vaut le coup, de par son nombre de <strong>possibilités</strong>, qui incluent
<list compact>
<item>un historique,
<item>le copier/coller,
<item>l'enregistrement de l'affichage,
<item>une entrée de digraphe, et
<item>la possibilité de <strong>détacher</strong> une session
<prgn>screen</prgn> du terminal pour la réattacher plus tard.
</list>

<sect2>Scénario d'accès distant
<p>
Si vous vous connectez fréquemment sur une machine Linux depuis un terminal
distant ou en utilisant un terminal VT100, <prgn>screen</prgn> vous facilitera
la vie avec la possibilité de <strong>détacher</strong> une session.
<p>
<enumlist compact>
<item>Supposez que vous êtes connectés via une connexion téléphonique, et que
vous exécutez une session <prgn>screen</prgn> complexe avec des éditeurs et des
programmes ouverts dans plusieurs fenêtres.
<item>Vous avez alors besoin de quitter votre terminal, mais vous ne voulez pas
perdre votre travail en raccrochant.
<item>Tapez simplement <tt>^A d</tt> pour détacher la session, puis
déconnectez-vous. (Ou encore plus rapide, tapez <tt>^A DD</tt> pour que
<prgn>screen</prgn> détache la session et déconnecte lui-même.)
<item>Quand vous vous connectez de nouveau, entrez la commande <tt>screen
-R</tt>, et <prgn>screen</prgn> va automatiquement réattacher toutes les
fenêtres que vous aviez ouvertes.
</enumlist>

<sect2>Commandes typiques de <prgn>screen</prgn>
<p>
Une fois que <prgn>screen</prgn> est démarré, toutes les entrées au clavier
sont envoyées à la fenêtre excepté la combinaison de touches de commande, par
défaut <tt>^A</tt>. Toutes les commandes <prgn>screen</prgn> sont entrées en
tapant <tt>^A</tt> et une touche unique [ainsi que des paramètres]. Commandes
utiles&nbsp;:
<example>
^A ?     affiche un écran d'aide (affiche les combinaisons de touches)
^A c     crée une nouvelle fenêtre et l'affiche
^A n     va à la fenêtre suivante
^A p     va à la fenêtre précédente
^A <var>0</var>     va à la fenêtre numéro <var>0</var>
^A w     affiche la liste des fenêtres
^A a     envoie Ctrl-A à la fenêtre courante
^A h     enregistre une copie de la fenêtre courante dans un fichier
^A H     commence/termine l'enregistrement de la fenêtre courante dans
         un fichier
^A ^X    verrouille le terminal (protection par mot de passe)
^A d     détache la session screen du terminal
^A DD    détache la session screen du terminal et déconnecte
</example>
Ceci est seulement un petit aperçu des possibilités de <prgn>screen</prgn>.
S'il y a quelquechose que vous souhaiteriez que <prgn>screen</prgn> fasse pour
vous, il y a des chances qu'il puisse ! Consultez <manref name="screen" section="1"> pour plus de détails.

<sect2>Backspace et/ou Ctrl-H dans une session <prgn>screen</prgn>
<p>
Si la touche backspace et/ou Ctrl-H ne marchent plus correctement lorsque vous
exécutez <prgn>screen</prgn>, éditez <file>/etc/screenrc</file>, trouvez la
ligne&nbsp;:
<example>
bindkey -k kb stuff "\177"
</example>
et commentez-la (càd, ajoutez «&nbsp;#&nbsp;» devant).

<sect2>Programme équivalent de <prgn>screen</prgn> pour X
<p>
Consultez <prgn>xmove</prgn>. Voir <manref name="xmove" section="1">.

</sect1>

<sect1>Bases pour tester un réseau
<p>
Installez les paquets
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (noyau 2.2)
<package>iptables</package> (noyau 2.4), et
<package>net-tools</package>, puis&nbsp;:
<example>
$ ping <var>yahoo.com</var>            # teste la connexion Internet
$ traceroute <var>yahoo.com</var>      # trace les paquets IP
$ ifconfig                  # affiche la configuration de la machine
$ route -n                  # affiche la configuration de routage
$ dig <var>[@dns-server.com] host.dom [{a|mx|any}]</var> |less
      # affiche les enregistrements DNS de <var>host.dom</var>
      # sur <var>dns-server.com</var> pour un enregistrement <var>{mx|any}</var>
$ ichains  -L -n |less      # affiche le filtre de paquets (noyau 2.2)
$ iptables -L -n |less      # affiche le filtre de paquets (noyau 2.4)
$ netstat -a                # recherche tous les ports ouverts
$ netstat -l --inet         # recherche tous les ports en écoute
$ netstat -ln --tcp         # recherche tous les ports tcp en écoute (affichage numérique)
</example>
</sect1>

<sect1>Vider les courriers électroniques de la file locale
<p>
Pour vider la file locale des courriers électroniques présents&nbsp;:
<example>
# exim -q    # vide les courriers électroniques en attente
# exim -qf   # vide tous les courriers électroniques
# exim -qff  # vide même les courriers électroniques gelés
</example>
<tt>-qff</tt> est peut-être une meilleure option pour le script
<file>/etc/ppp/ip-up.d/exim</file>.
</sect1>

<sect1>Supprimer les courriers électroniques gelés de la file locale
<p>
Pour supprimer les courriers électroniques gelés de la file locale en
renvoyant un message d'erreur&nbsp;:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Supprimer le contenu d'un fichier
<p>
Pour supprimer le contenu d'un fichier, par exemple un fichier de journal,
n'utilisez pas <tt>rm</tt> pour effacer le fichier et créer ensuite un fichier
vide, parce que le fichier peut toujours être accédé entre les commandes. Ce
qui suit est une façon sûre de supprimer le contenu d'un fichier.
<example>
$ :&gt;<var>file-to-be-cleared</var>
</example>
</sect1>

<sect1>Fichiers fantômes
<p>
Les commandes suivantes créent des fichiers fantômes ou vides.
<example>
$ dd if=/dev/zero    of=<var>filename</var> bs=1k count=5 # 5Ko sans contenu
$ dd if=/dev/urandom of=<var>filename</var> bs=1m count=7 # 7Mo de contenu aléatoire
$ touch <var>filename</var> # crée un fichier de taille 0 (si le fichier existe, met à jour mtime)
</example>
</sect1>

<sect1><prgn>chroot</prgn>
<p>
Supposez que vous avez installé une distribution Linux complète (cela peut être
une autre version de &debian; ou même une distribution Red Hat) dans
<file><var>/dev/hda1</var></file> et que vous exécutez un autre système Linux
installé sur <file><var>/dev/hda2</var></file>. Vous pouvez exécuter le système
de <file><var>/dev/hda1</var></file> sans redémarrer le système de
<file><var>/dev/hda2</var></file> en partageant le même noyau.
<example>
# mount <var>/dev/hda1 /mnt/target</var>
 ... en supposant que <var>/dev/hda1</var> contient un système
# chroot /mnt/target
 ... Maintenant le contenu de <var>/dev/hda1</var> est vu comme répertoire racine /
# mount proc /proc              # au cas où
 ... exécutez les commandes depuis <var>/dev/hda1</var>
</example>
Cela permet d'installer stable/testing/unstable sur une machine. De plus,
on peut exécuter un programme nécessitant beaucoup de mémoire comme
<prgn>dselect</prgn> en le lançant sur une machine pendant que l'on monte par
NFS une machine auxiliaire en r/w et que l'on pointe <prgn>chroot</prgn> vers
la machine auxiliaire.
<p>
Il est facile de créer un système <prgn>chroot</prgn> avec la commande
<prgn>debootstrap</prgn> de Woody.
<example>
# mkdir <var>potatochroot</var>
# debootstrap potato <var>potatochroot</var>
# chroot <var>potatochroot</var>
# apt-setup # configure /etc/apt/sources.list
</example>
<p>
Il existe un paquet chroot plus spécialisé, <package>pbuilder</package>, qui
construit un système chroot et compile un paquet dans le chroot. C'est un
système idéal pour vérifier que les dépendances de compilation d'un paquet
sont correctes, et pour être sûr que des dépendances non nécessaires ou
fausses n'existent dans le paquet résultant.
</sect1>

<sect1>Monter une image de disque dur
<p>
Si <file><var>file.img</var></file> contient l'image d'un disque dur et que le
disque dur original avait une configuration <var>xxxx</var> = (octets/secteur)
* (secteurs/cylindres), les commandes suivantes vont le monter sur
<file>/mnt</file>&nbsp;:
<example>
# mount -o loop,offset=<var>xxxx</var> <var>file.img</var> /mnt
</example>
Notez que la plupart des disques durs ont 512 octets/secteur.

<sect1>Samba
<p>
Bases pour récupérer des fichiers depuis Windows&nbsp;:
<example>
# mount -t smbfs -o <var>username=myname,uid=my_uid,gid=my_gid</var> \
        <var>//server/share /mnt/smb</var>  # monte un répertoire Windows sous Linux
# smbmount <var>//server/share /mnt/smb</var> \
        -o "<var>username=myname,uid=my_uid,gid=my_gid</var>"
# smbclient -L <var>192.168.1.2</var> # list the shares on a computer
</example>
Les voisins de Samba peuvent être trouvés depuis Linux&nbsp;:
<example>
# smbclient -N -L <var>ip_address_of_your_PC</var> | less
# nmblookup -T "*"
</example>
</sect1>

</sect>

</chapt>
