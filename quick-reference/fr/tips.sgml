<!-- CVS revision of this document "$Revision: 1.8 $"  -->
<!-- CVS revision of original english document "1.22"  -->
<chapt id="tips">Astuces &debian;

<sect>Démarrer le système
<p>
Voir /usr/share/doc/HOWTO/BootPrompt-HOWTO.txt.gz (LDP) pour des informations
détaillées sur l'invite de démarrage.

<sect1 id="crackroot">J'ai oublié le mot de passe de root (1)
<p>
On peux démarrer dans le compte administrateur (root) sans connaître 
le mot de passe de root si on a un accès au clavier de la console. 
On suppose qu'il n'y a pas de mot de passe requis pour le BIOS ni pour 
le chargeur de démarrage (lilo par exemple) qui empeche de lancer le système.
<p>
Cette procédure ne nécessite ni disquette de démarrage externe ni changement 
dans les réglages du BIOS. Ici, "Linux" est le nom du noyau Linux par défaut 
qui lance le système Debian.
<p>
A l'écran d'invite de lilo (Certains systèmes nécessitent de presser la 
touche MAJ), entrez :
<example>
boot: Linux init=/bin/sh
</example>
Le système lance alors le noyau et exécute /bin/sh au lieu du processus init 
standard. Vous avez maintenant les droits et le shell de l'administrateur 
root. Puisque / est monté en lecture seule et que de plusieurs partitions 
du (ou des) disque(s) dur(s), vous devez faire ce qui suit pour obtenir un 
système à peu près fonctionnel.
<example>
init-2.03# mount -n -t remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
(Si la seconde colonne de <file>/etc/passwd</file> est "x" pour tous les
utilisateurs, votre système utilise les "shadow passwords" (NdT : mots de
passes cachés), et il faut éditer <file>/etc/shadow</file>.) Une entrée vide
dans la seconde colonne de l'un de ces fichiers désactive le mot de passe.
Maintenant Le système peut être lancé sans le mot de passe de root.
Contrairement à de plus anciennes versions de Linux, la version actuelle de
Debian (potato) nécessite d'entrer un mot de passe si le système est lancé au
niveau d'exécution (runlevel) 1.
</sect1>

<sect1>J'ai oublié le mot de passe de root (2)
<p>
Lancer depuis n'importe quel ensemble de disquettes de boot/root. 
Si /dev/hda3 est la partition racine originale, la suite vous laissera 
éditer le fichier de mots de passe aussi facilement que précédemment. 
<example>
# mkdir fixit
# mount /dev/hda3 fixit
# cd fixit/etc
# vi shadow
# vi passwd
</example>
<p>
L'avantage de cette méthode sur la précédente est qu'on n'est pas obligé de
connaître le mot de passe de <prgn>lilo</prgn>, mais on doit pouvoir régler le
BIOS pour que le système se lance depuis la disquette ou le CD.
</sect1>

<sect1>Je ne peux pas lancer le système
<p>
Pas de problème, personne ne prend la peine de faire une disquette de
démarrage lors de l'installation. Si <prgn>lilo</prgn> est cassé, récupérez la
disquette de démarrage de l'installation de Debian (rescue). Démarrez depuis
cette disquette. A l'invite de démarrage, en supposant que la partition racine
de Linux est <file>/dev/hda12</file> et que vous voulez le niveau d'exécution
(runlevel) 3, entrez :
<example>
boot: rescue root=/dev/hda12 3
</example>
Vous avez maintenant lancé un système presque totalement fonctionnel 
depuis le noyau présent sur la disquette. Il peut y avoir quelques problèmes 
et messages d'erreu mineurs à cause d'un manque dans les options du noyau ou 
d'un module absent.
<p>
Si vous avez besoin d'une disquette de démarrage personnalisée, lisez 
<file>readme.txt</file> sur la disquette rescue.
</sect1>

<sect1 id="bootprompt">Autres astuces avec l'invite de démarrage.
<p>
Le système peut être lancé à un niveau d'exécution particulier et avec des
options de configurations en utilisant l'invite de démarrage de
<prgn>lilo</prgn>.  Les détails sont données dans
<file>BootPrompt-HOWTO.txt.gz</file>.
<p>
Si vous voulez lancer le système au niveau d'exécution 4, entrez la ligne 
suivante à l'invite de <prgn>lilo</prgn>.
<example>
boot: Linux 4
</example>
<p>
Si vous voulez lancer le système en mode de fonctionnement mono-utilisateur 
normal, et que vous connaissez le mot de passe de root, un des exemples 
suivants fonctionne. 
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Si vous voulez lancer le système en utilisant moins de mémoire vive que le
système n'en a en réalité,(par exemple 48MB sur un ordinateur qui a 64MB),
l'entrée suivante à l'invite de démarrage de <prgn>lilo</prgn> marche.
<example>
boot: Linux mem=48M
</example>
Assurez-vous de ne pas spécifier plus de mémoire que le système n'en a en
réalité, sinon le noyau va planter. Si vous avez plus de 64MB de mémoire vive,
comme 128MB par exemple, à moins de spécifier <tt>mem=128M</tt> à l'invite de
<prgn>lilo</prgn> ou d'inclure une ligne "append" similaire dans
<file>/etc/lilo.conf</file>, les vieux noyaux et/ou les cates mères avec un
vieux BIOS n'utiliseront pas la mémoire au-delà des 64MB.
</sect1>
</sect>

<sect>Enregistrer les activités
<sect1 id="script">Enregistrer les activités du shell
<p>
L'administration système est une série d'activités beaucoup plus élaborées 
dans un environnement Unix que dans un environnement de PC ordinaire. Soyez 
sur de connaître les méthodes de configuration les plus basiques en cas de 
récupération de système. Les interfaces graphiques des outils de configuration 
peuvent avoir l'air agréable et commode, mais sont parfois limitées surtout 
dans de telles situations.
<p>
Dans ce contexte, enregistrer les activités du shell est une bonne habitude, 
surtout si l'on est root.
<p>
Sous Emacs: utilisez <tt>M-x shell</tt> pour démarrer l'enregistrement dans le 
buffer, et utilisez <tt>C-x C-w</tt> pour écrire le contenu du buffer dans un 
fichier.
<p>
dans le shell: utilisez la commande <prgn>script</prgn>.
<example>
$ script
Script started, file is typescript
 .... faites ce que vous voulez ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
La méthode suivante peut être utilisée à la place de <prgn>script</prgn>.
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>
<sect1>Enregistrer les activités sous X
<p>
Si vous avez besion d'enregistrer l'image d'une application sous X en
comprenant l'affichage graphique du terminal X, utilisez <prgn>gimp</prgn>. Il
peut "capturer" une fenêtre isolée ou l'écran entier.  Des alternatives
existent comme <prgn>xwd</prgn> (paquet <package>xbase-clients</package>),
<prgn>import</prgn> (<package>imagemagick</package>), ou <prgn>scrot</prgn>
(<package>scrot</package>).
</sect1>
</sect>

<sect>Copy and archive a whole subdirectory
<sect1>Basic commands for copying a whole subdirectory
<p>
En cas de réarrangement de la sructure de fichiers, déplacez le contenu des 
dossiers y compris les liens par les commandes:
<example>
Standard method:
# cp -a /source/directory /dest/directory # must be GNU
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
If hardlink is involved, petandic method is needed:
# cd /path/to/old/directory
# find . -depth -print0 | afio -p -xv -0a /mount/point/of/new/directory
If remote:
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
If there are no linked files:
# scp -pr user1@host1.dom:/source/directory \
          user2@host2.dom:/dest/directory
</example>
Ici, <prgn>scp</prgn> &lt;==&gt; <prgn>rcp</prgn> et <prgn>ssh</prgn>
&lt;==&gt; <prgn>rsh</prgn>.
<p>
Method of copy a whole subdirectory is based on the information provided by 
Manoj Srivastava &lt;srivasta@debian.org&gt; on debian-user@lists.debian.org.
</sect1>

<sect1>cp
<p>
Traditionally, cp was not really a candidate since it did not
derenference symbolic links, or preserve hard links
either. Another thing to consider was sparse files (with
holes).
<p>
GNU cp has overcome these limitations, however, on a non GNU
system, cp could still have problems. Also, you can't genrate
small, portable archives using cp.
<example>
% cp -a . newdir
</example>
<sect1>tar
<p>
Tar overcame some of the problems that cp had with symbolic
links. However, `cpio' handles special files; traditional
`tar' doesn't.
<p>								
`tar's way of handling multiple hard links to a file places
only one copy of the link on the tape, but the name attached
to that copy is the <em>only</em> one you can use to retrieve the
file; `cpio's way puts one copy for every link, but you can
retrieve it using any of the names.
</sect1>

<sect1>pax
<p>
The new, POSIX (IEEE Std 1003.2-1992, pages 380-388 (section
4.48) and pages 936-940 (section E.4.48)), all singing, all
dancing, Portable archive interchange utility.  pax will read,
write, and list the members of an archive file, and will copy
directory hierarchies.  pax operation is independent of the
specific archive format, and supports a wide variety of
different archive formats.
<p>
pax implementations are still new and wet behind the ears.
<example>
$ pax -rw -p e . newdir
 or
$ find . -depth  | pax -rw -p e  newdir
</example>
</sect1>

<sect1>cpio
<p>
copies files into or out of a cpio or tar archive, The archive
can be another file on the disk, a magnetic tape, or a pipe.
<example>
$ find . -depth -print0 | cpio --null --sparse -pvd new-dir
</example>
</sect1>

<sect1>afio
<p>
Afio is a better way of dealing with cpio-format archives. It is
generally faster than cpio, provides more diverse magnetic tape
options and deals somewhat gracefully with input data corruption.  It
deals somewhat gracefully with input data corruption.  Supports
multi-volume archives during interactive operation.  Afio can make
compressed archives that are much safer than compressed tar or cpio
archives.  Afio is best used as an `archive engine' in a backup
script.
<example>
$ find . -depth -print0 | afio -px -0a new-dir
</example>
All my backups onto tape use afio. 
</sect1>

</sect>

<sect>Modifier les fichiers grâce aux expressions régulières
<p>
Pour remplacer toutes les occurences de FROM_REGEX par TO_REGEX dans tous 
les fichiers FILES ...:
<example>
# perl -i -p -e 's/FROM_REGEX/TO_REGEX/g;' FILES ...
</example>
<tt>-i</tt> est pour "édition sur place", <tt>-p</tt> est pour "boucle
implicite sur FILES ...". Si la substitution est complexe, vous pouvez
faciliter le retour sur des erreurs en utilisant le paramètre <tt>-i.bak</tt>
au lieu de <tt>-i</tt>; cela permet de garder les fichiers originaux en leur
ajoutant le suffixe <tt>.bak</tt>.
</sect>


<sect>Récupération d'un système bloqué
<sect1>Tuer le processus
<p>
Exécutez <prgn>top</prgn> pour voir quel processus agit bizarrement. Appuyez
sur "P" pour trier par temps CPU utilisé, "M" pour trier par mémoire utilisée,
et "k" pour tuer un processus.
<p>
Utilisez <prgn>kill</prgn> pour tuer (ou envoyer un signal à) un processus à
partir de son numéro de processus, ou <prgn>killall</prgn> pour faire la même
chose à partir du nom de la commande du processus. Signaux fréquemment
utilisés :
<example>
 1: HUP,  redémarre un daemon (NdT : serveur)
15: TERM, termine un process normalement
 9: KILL, tue un process
</example>

</sect1>

<sect1>ALT-SysRQ
<p>
L'option de compilation du noyau "Magic SysRq key" donne une assurance contre
un mauvais fonctionnement du système.
Appuyer sur <tt>ALT-SysRQ</tt> sur un i386, suivi par une des touches <tt>r 0
k e i s u b</tt>, agit magiquement.  
<p>
Un<tt>R</tt>aw récupère le clavier en cas de plantage de logiciels comme X.
Mettre le niveau de log de la console à <tt>0</tt> réduit le nombre de
messages d'erreur. sa<tt>K</tt> (touche d'attention système, NdT : system
attention key en Anglais) tue tous les processus de la console vituelle
courante. t<tt>E</tt>rminate tue tous les processus du terminal courant
excepté init. k<tt>I</tt>ll tue tous les processus excepté init.
<p>
<tt>S</tt>ync, <tt>U</tt>mount, et re<tt>B</tt>oot permettent de se sortir de
très mauvaises situations.
<p>
Les noyaux de l'installation par défaut de Debian ne sont pas compilés avec
cette option au moment où ce document est écrit. Recompilez le noyau pour
activer cette fonction. Des informations détaillées se trouvent dans
<file>/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz</file>.

</sect1>
</sect>

<sect>Fichiers de configuration

<sect1 id="loginctrl">Contrôle des connexions
<p>
<![%FIXME[<p>=== Expansion needed here ===]]>
<example>
/etc/securetty           # contrôle les connexions root sur la console
/etc/hosts.{allow|deny}  # contrôle l'accès aux services par machine
/etc/pam.d/login         # contrôle les connexions
</example>
<p>
Mettez en commentaire "ALL: PARANOID" dans le fichier
<file>/etc/hosts.deny</file>.
<p>
Changez le contenu du fichier <file>/etc/pam.d/login</file> comme suit, si
vous voulez des terminaux certes non sécurisés, mais sans mot de passe; à
utiliser à vos propres risques.
<example>
#auth       required   pam_unix.so nullok
auth       required   pam_permit.so
</example>
NFS et d'autres programmes basés sur RPC nécessitent "sunrpc portmapper" pour
les connexions (<manref name="portmap" section="8">).
</sect1>

<sect1>Valeurs par défaut
<p>
<example>
/etc/defaults/rcS        # Valeurs par défaut pour le démarrage (motd, sulogin,...)
/etc/syslog.conf         # Mode de log du système
</example>
Le paquet <package>colorize</package> permet de coloriser les fichiers de log
du système.
</sect1>
</sect>
<sect>Petites commandes utiles à se rappeler
<sect1>Mémoire libre
<p>
<prgn>free</prgn> et <prgn>top</prgn> donnent de bonnes informations sur les
ressources mémoire. Ne vous inquiétez pas sur la taille de "used" sur la ligne
"Mem:", lisez plutôt la ligne en-dessous (38792 dans l'exemple ci-dessous).
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
La quantité exacte de mémoire physique peut être confirmée par <tt>grep
'^Memory' /var/log/dmesg</tt>, qui dans notre cas d'exemple donne "Memory:
256984k/262144k available (1652k kernel code, 412k reserved, 2944k data, 152k
init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free to dmesg = 256984k = Total - kernel - reserved - data - init
Free to shell = 257136k = Total - kernel - reserved - data
</example>
Environ 5Mo ne sont pas utilisables par le système parce que le noyau les
utilise.
</sect1>

<sect1>Régler l'heure (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
Cela va régler l'heure du système et du matériel à MM/DD hh:mm, CCYY.
L'heure est affichée selon le fuseau horaire local, mais le matériel utilise
UTC.
<p>
Régler l'horloge système automatiquement via un serveur distant :
<example>
# ntpdate &lt;server&gt;
</example>
Il est bon d'avoir cette commande dans <file>/etc/cron.daily</file> si votre
système possède une connexion permanente à Internet.
</sect1>

<sect1>Comment désactiver l'écran de veille
<p>
En mode console :
<example>
# setterm -powersave off
</example>
<p>
Démarrez la console kon2 (kanji) avec :
<example>
# kon -SaveTime 0
</example>
<p>
En mode X :
<example>
# xset s off
 ou
# xset -dpms
 ou
# xscreensaver-command -prefs
</example>
Lisez les pages de manuel correspondantes.
</sect1>

<sect1>Désactiver le son (beep)
<p>
On peut toujours débrancher le haut-parleur PC ;-)
Pour le shell :
<example>
echo "set bell-style none"&gt;&gt; ~/.inputrc:
</example>
</sect1>

<sect1>Messages d'erreur sur l'écran de la console
<p>
Par défaut dans Debian, <file>/etc/syslog.conf</file> est configuré pour
écrire par-dessus l'écran de la console. Editez la dernière partie de ce
fichier pour changer ce comportement.
<p>
Lancez aussi <tt>dmesg -n1</tt> pour rendre silencieux les messages d'erreur à
l'écran.
</sect1>

<sect1>Remettre la console dans un état sain
<p>
Lorsque l'écran devient illisible après <tt>$ cat binaryfile</tt> (il se peut
que vous ne voyiez pas la commande en tapant) :
<example>
$ reset
</example>
</sect1>

<sect1>Convertir des fichiers texte DOS vers Unix
<p>
Pour convertir un fichier texte DOS (fin de ligne ^M^J) en fichier texte Unix
(^J) :
<example>
# apt-get install sysutils
$ dos2unix dosfile
</example>
</sect1>

<sect1>Convertir un gros fichier en plusieurs petits
<p>
<example>
$ split -b 650m file   # Sépare "file" en morceaux de 650Mo
$ cat x* >largefile    # Assemble les fichiers en 1 gros fichier
</example>
</sect1>

<sect1>Bouts de scripts pour les tubes
<p>
Les scripts suivants font des choses sympa avec les tubes.
<example>
xargs -n 1 command   
        # exécute "command" avec tous les arguments de stdin
xargs -n 1 echo|     
        # place chaque argument séparé par des espaces sur une ligne
grep -e pattern|     # extrait les lignes contenant "pattern"
cut -d: -f3 -|       # extrait le 3e champ séparé par : 
                     # (fichier passwd, etc.)
col -bx | # supprime backspace et transforme les tabulations en espaces
expand -|            # transforme les tabulations
sort -u|             # trie et supprime les doublons
tr '\n' ' '|         # concatène les lignes en une seule
tr '\r' ''|          # supprime CR
tr 'A-Z' 'a-z'|      # convertit les majuscules en minuscules
sed 's/^/# /'|       # change chaque ligne en commentaire
sed 's/\.ext//g'|    # supprime .ext
sed  -n -e 2p|       # affiche la 2e ligne
head -n 2 -|         # affiche les 2 premières lignes
tail -n 2 -|         # affiche les 2 dernières lignes
</example>
</sect1>

<sect1>Récupérer du texte ou une archive de liste de diffusion à partir d'une
page web
<p>
Les commandes suivantes récupèrent une page web dans un fichier texte. Très
utile pour copier des configurations depuis le Web.
<example>
$ lynx -dump http://www.remote-site.com/help-info.html &gt;textfile
</example>
<p>
S'il s'agit d'une archive de liste de diffusion, utilisez <tt>munpack</tt>
pour obtenir les contenus MIME à partir du texte.
</sect1>

<sect1>Mesuré la durée d'une commande
<p>
Affiche le temps pris par un processus.
<example>
# time df >/dev/null
real    0m0.035s       # durée sur l'horloge (temps réel écoulé)
user    0m0.000s       # durée en mode utilisateur
sys     0m0.020s       # durée en mode noyau
</example>
</sect1>

<sect1>Commande <prgn>nice</prgn>
<p>
Utilisez <prgn>nice</prgn> (du paquet GNU shellutils) pour régler la valeur
"nice" d'une commande lors de son exécution. <prgn>renice</prgn> (bsdutild) ou
<prgn>top</prgn> peuvent changer la valeur "nice" d'une processus. Le
processus le plus lent (priorité la plus basse) aura une valeur de 19 ; les
valeurs négatives sont "not-nice" (NdT : litt. pas gentilles ; jeu de mot sur
"nice"), une valeur de -20 étant donnée au processus le plus rapide (priorité
la plus haute). Seul le superutilisateur peut donner des valeurs "nice"
négatives.
<example>
# nice  -19 top                                         # très "nice"
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img # très rapide
</example>
</sect1>

<sect1>Programmer des activités (<prgn>cron</prgn>, <prgn>at</prgn>)
<p>
Utilisez <prgn>cron</prgn> et <prgn>at</prgn> pour programmer des tâches sous
Linux. Consultez <manref name="at" section="1">, <manref name="crontab"
section="5">, <manref name="crontab" section="8">.
<p>
Exécutez la commande <tt>crontab -e</tt> pour créer ou éditer un fichier
crontab pour programmer des événements régulièrement. Exemple de fichier
crontab :
<example>
# utilise /bin/sh pour exécuter les commandes, quoi que dise /etc/passwd
SHELL=/bin/sh
# envoie un courrier électronique à Paul contenant tous les résultats, quelle
# que soit la personne a qui appartienne la crontab
MAILTO=paul
# Minute Heure JourDuMois Mois JourDeLaSemaine commande
# est exécuté à 00:05 chaque jour
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# est exécuté à 14:15 le 1e de chaque mois -- le résultat est envoyé à Paul
# par courrier électronique
15 14 1  * *   $HOME/bin/monthly
# est exécuté à 22:00 chaque jour de la semaine(1-5), ennuie Joe. % pour une
# nouvelle ligne, dernier % pour cc.
0 22 *   * 1-5 mail -s "It's 10pm" joe%Joe,%%Where are your kids?%.%%
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# est exécuté à 03:40 le premier lundi de chaque mois
40 3 1-7 * *   [ "$(date +%a)" == "Mon" ] && command -args
</example>
Exécutez la commande <prgn>at</prgn> pour programmer une tâche unique :
<example>
$ echo 'command -args'| at 3:40 monday
</example>
</sect1>

<sect1>Changement de console avec <prgn>screen</prgn>
<p>
Le programme <prgn>screen</prgn> permet d'exécuter plusieurs terminaux
virtuels avec un shell intéractif sur chacun, sur un unique terminal physique
ou émulateur de terminal. Même si vous utilisez les consoles virtuelles de
Linux ou plusieurs fenêtres xterm, explorer <prgn>screen</prgn> vaut le coup,
de par son nombre de possibilités, qui incluent un historique, le
copier/coller, l'enregistrement de l'affichage, une entrée de digraphe, et la
possibilité de détacher une session <prgn>screen</prgn> du terminal pour la
réattacher plus tard. Si vous vous connectez fréquemment sur une machine Linux
depuis un terminal distant ou en utilisant un terminal VT100,
<prgn>screen</prgn> vous facilitera la vie.
<p>
Une fois que <prgn>screen</prgn> est démarré, toutes les entrée clavier sont
envoyées à la fenêtre excepté la combinason de touche de commande, par défaut
<tt>^A</tt>. Toutes les commandes <prgn>screen</prgn> sont entrées en tapant
<tt>^A</tt> et une touche unique [ainsi que des paramètres]. Commandes utiles
:
<example>
^A ?     affiche un écran d'aide (affiche les combinaisons de touches)
^A c     crée une nouvelle fenêtre et l'affiche
^A n     va à la fenêtre suivante
^A p     va à la fenêtre précédente
^A 0     va à la fenêtre numéro 0
^A w     affiche la liste des fenêtres
^A a     envoie Ctrl-A à la fenêtre courante
^A h     enregistre une copie de la fenêtre courante dans un fichier
^A H     commence/Termine l'enregistrement de la fenêtre courante dans
         un fichier
^A ^X    verrouille le terminal (protection par mot de passe)
^A d     détache la session screen du terminal
^A DD    détache la session screen du terminal et déconnecte
</example>
La possibilité de détachement de <prgn>screen</prgn> est très puissante.
Supposez que vous êtes connectés via une connexion téléphonique, et que vous
exécutez une session <prgn>screen</prgn> complexe avec des éditeurs et des
programmes ouverts dans plusieurs fenêtres. Vous avez alors besoin de quitter
votre terminal, mais vous ne voulez pas perdre votre travail en raccrochant.
Tapez simplement <tt>^A d</tt> pour détacher la session, puis
déconnectez-vous. (Ou encore plus rapide, tapez <tt>^A DD</tt> pour que
<prgn>screen</prgn> détache la session et déconnecte lui-même.) Quand vous
vous connectez de nouveau, entrez la commande <tt>screen -R</tt>, et
<prgn>screen</prgn> va automatiquement réattacher toutes les fenêtres que vous
aviez ouvertes.
<p>
Ceci est seulement un petit aperçu des possibilités de <prgn>screen</prgn>.
S'il y a quelquechose que vous souhaiteriez que <prgn>screen</prgn> fasse pour
vous, il y a des chances qu'il puisse ! Faites "man screen" pour plus de
détails.
<p>
<em>Note :</em> Si la touche backspace et/ou Ctrl-H ne marchent plus
correctement lorsque vous exécutez <prgn>screen</prgn>, éditez
<file>/etc/screenrc</file>, trouvez la ligne :
<example>
bindkey -k kb stuff "\177"
</example>
et commentez-la (càd, ajoutez "#" devant).
<![%FIXME[<p>=== Add "xmove" for X if desired ===]]>
</sect1>


<sect1>Bases pour tester une réseau
<p>
Install  
<package>netkit-ping</package>, 
<package>traceroute</package>,
<package>dnsutils</package>,
<package>ipchains</package> (for 2.2 Kernel),
<package>iptables</package> (for 2.4 Kernel), and
<package>net-tools</package> packages and:
<example>
$ ping yahoo.com            # teste la connexion Internet
$ traceroute yahoo.com      # trace les paquets IP
$ ifconfig                  # affiche la configuration de la machine
$ route -n                  # affiche la configuration de routage
$ dig [@dns-server.com] host.dom [{a|mx|any}] |less
      # affiche les enregistrements DNS de host.com 
      # [sur dns-server.com] pour un enregistrement [{mx|any}]
$ ichains  -L -n |less      # affiche le filtre de paquets (noyau 2.2)
$ iptables -L -n |less      # affiche le filtre de paquets (noyau 2.4)
$ netstat -a                # recherche tous les ports ouverts
$ netstat -l --inet         # recherche tous les ports listening
$ netstat -ln --tcp   # recherche tous les ports listening tcp (numeric)
</example>
</sect1>

<sect1>Vider les courriers électroniques de la file locale
<p>
Pour vider la file locale des courriers électroniques présents :
<example>
# exim -q    # flush waiting mails
# exim -qf   # flush all mails
# exim -qff  # flush even frozen mails
</example>
"-qff" may be better for /etc/ppp/ip-up.d/exim script.
</sect1>

<sect1>Remove frozen mails from local spool
<p>
To remove frozen mail from the local spool with the delivery error message:
<example>
# exim -Mg `mailq | grep frozen | awk '{ print $3 }'`
</example>
</sect1>

<sect1>Supprimer le contenu d'un fichier
<p>
N'utilisez pas <tt>rm</tt> si le fichier est accédé par d'autres.
<example>
$ :>file-to-be-cleared
</example>
</sect1>

<sect1>Fichiers fantômes
<p>
<example>
$ dd if=/dev/zero    of=filename bs=1k count=5 # 5Ko sans contenu
$ dd if=/dev/urandom of=filename bs=1m count=7 # 7Mo de contenu aléatoire
$ touch filename # crée un fichier de 0o ou met à jour mtime 
                 # (NdT : date de dernière modification)
</example>
</sect1>

<sect1>chroot
<p>
Vous pouvez créer un système indépendant qui utilise le même noyau.
<example>
# mount /dev/hda1 /mnt/target   
        # en supposant que /dev/hda1 contient un système
# chroot /mnt/target
... Maintenant le contenu de /dev/hda1 est vu comment répertoire racine /
# mount proc /proc              # au cas où
... Exécutez les commandes depuis /dev/hda1
</example>
Cela permet stable/testing/unstable d'être installés sur une machine. De plus,
on peut exécuter un programme nécessitant beaucoup de mémoire comme
<prgn>dselect</prgn> en le lançant sur une machine pendant que l'on monte par
NFS une machine auxiliaire en r/w et que l'on pointe <prgn>chroot</prgn> vers
la machine auxiliaire.
<p>
chroot system can easily be created by <prgn>debootstrap</prgn> command 
in woody.
<example>
# mkdir potatochroot
# debootstrap potato potatochroot
# chroot potatochroot
# apt-setup # set-up /etc/apt/sources.list
</example>
</sect1>

<sect1>Samba
<p>
Bases pour récupérer des fichiers depuis Windows :
<example>
# mount -t smbfs -o username=myname,uid=my_uid,gid=my_gid \
      //server/share /mnt/smb  # monte un répertoire Windows sous Linux
# smbmount //server/share /mnt/smb \
      -o "username=myname,uid=my_uid,gid=my_gid"
# smbclient -L 192.168.1.2 # liste les partages d'une machine
</example>
</sect1>

</sect>

</chapt>
