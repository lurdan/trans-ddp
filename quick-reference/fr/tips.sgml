<!-- CVS revision of this document "$Revision: 1.2 $"  -->
<!-- CVS revision of original english document "1.4"  -->
<chapt id="tips">Astuces GNU/Linux 

<sect>Système de démarrage
<p>
voir BootPrompt-HOWTO.txt.gz (LDP) pour des informations détaillées sur l'invite de démarrage.

<sect1 id="crackroot">J'ai oublié le mot de passe de root (1)
<p>
On peux démarrer dans le compte administrateur (root) sans connaître 
le mot de passe de root si on a un accès au clavier de la console. 
On suppose qu'il n'y a pas de mot de passe requis pour le BIOS ni pour 
le chargeur de démarrage (lilo par exemple) qui empeche de lancer le système.
<p>
Cette procédure ne nécessite ni disquette de démarrage externe ni changement 
dans les réglages du BIOS. Ici, "Linux" est le nom du noyau Linux par défaut 
qui lance le système Debian.
<p>
A l'écran d'invite de lilo (Certains systèmes nécessitent de presser la 
touche MAJ), entrez :
<example>
boot: Linux init=/bin/sh
</example>
Le système lance alors le noyau et exécute /bin/sh au lieu du processus init 
standard. Vous avez maintenant les droits et le shell de l'administrateur 
root. Puisque / est monté en lecture seule et que de plusieurs partitions 
du (ou des) disque(s) dur(s), vous devez faire ce qui suit pour obtenir un 
système à peu près fonctionnel.
<example>
init-2.03# mount -n -t remount,rw /
init-2.03# mount -avt nonfs,noproc,nosmbfs
init-2.03# cd /etc
init-2.03# vi passwd
init-2.03# vi shadow
</example>
Une entrée vide dans la seconde colonne de l'un de ces fichiers désactive le 
mot de passe. Maintenant Le système peut être lancé sans le mot de passe de 
root. Contrairement à de plus anciennes versions de Linux, La version 
actuelle de Debian (potato) nécessite d'entrer un mot de passe si le système 
est lancé au niveau d'exécution (runlevel) 1.
</sect1>

<sect1>J'ai oublié le mot de passe de root (2)
<p>
Lancer depuis n'importe quel ensemble de disquettes de boot/root. 
Si /dev/hda3 est la partition racine originale, la suite vous laissera 
éditer le fichier de mots de passe aussi facilement que précedemment. 
<example>
# mkdir fixit
# mount /dev/hda3 fixit
# cd fixit/etc
# vi shadow
# vi passwd
</example>
<p>
L'avantage de cette méthode sur la précédente et qu'on n'est pas obligé 
de connaître le mot de passe de lilo, mais on doit pouvoir régler le BIOS 
pour que le système se lance depuis la disquette ou le CD.
</sect1>

<sect1>Je ne peux pas lancer le système
<p>
Pas de problème, personne ne prend la peine de faire une disquette de 
démarrage lors de l'installation. si lilo est cassé, récupérez la disquette 
de démarrage de l'installation de Debian (rescue). démarrez depuis cette 
disquette. A l'invite de démarrage, en supposant que la partition racine de 
Linux est /dev/hda12 et que vous voulez le niveau d'exécution (runlevel) 3, 
entrez :
<example>
boot: rescue root=/dev/hda12 3
</example>
Vous avez maintenant lancé un système presque totalement fonctionnel 
depuis le noyau présent sur la disquette. Il peut y avoir quelques problèmes 
et messages d'erreu mineurs à cause d'un manque dans les options du noyau ou 
d'un module absent.
<p>
Si vous avez besoin d'une disquette de démarrage personnalisée, lisez 
readme.txt sur la disquette rescue.
</sect1>

<sect1 id="bootprompt">Autres astuces au démarrage avec l'invite de démarrage.
<p>
Le système peut être lancé à un niveau d'exécution particulier et avec 
des options de configurations en utilisant l'invite de démarrage de lilo. 
Les détails sont données dans BootPrompt-HOWTO.txt.gz.
<p>
Si vous voulez lancer le système au niveau d'exécution 4, entrez la ligne 
suivante à l'invite de lilo.
<example>
boot: Linux 4
</example>
<p>
Si vous voulez lancer le système en mode de fonctionnement mono-utilisateur 
normal, et que vous connaissez le mot de passe de root, un des exemples 
suivants fonctionne. 
<example>
boot: Linux S
boot: Linux 1
boot: Linux -s
</example>
<p>
Si vous voulez lancer le système en utilisant moins de mémoire vive que 
le système n'en a en réalité,(par exemple 48MB sur un ordinateur 
qui a 64MB), l'entrée suivante à l'invite de démarrage de lilo marche.
<example>
boot: Linux mem=48M
</example>
Assurez-vous de ne pas spécifier plus de mémoire que le système n'en a 
en réalité, sinon le noyau va planter. Si vous avez plus de 64MB de mémoire 
vive, comme 128MB par exemple, à moins de spécifier mem=128M à l'invite de 
lilo ou d'inclure une ligne "append" similaire, les vieux noyaux ou les 
vieux BIOS MB n'utiliseront pas la mémoire au-delà des 64MB.
</sect1>
</sect>

<sect>Enregistrer les activités
<sect1 id="script">Enregistrer les activités du shell
<p>
L'administration système est une série d'activités beaucoup plus élaborées 
dans un environnement Unix que dans un environnement de PC ordinaire. Soyez 
sur de connaître les méthodes de configuration les plus basiques en cas de 
récupération de système. Les interfaces graphiques des outils de configuration 
peuvent avoir l'air agréable et commode, mais sont parfois limitées surtout 
dans de telles situations.
<p>
dans ce contexte, enregistrer les activités du shell est une bonne habitude, 
surtout si l'on est root.
<p>
Sous Emacs: utilisez "M-x shell" pour démarrer l'enregistrement dans le 
buffer, et utilisez "C-x C-w" pour écrire le contenu du buffer dans un 
fichier.
<p>
dans le shell: utilisez la commande script.
<example>
$ script
Script started, file is typescript
 .... faites ce que vous voulez ...
 Control-D
$ col -bx &lt;typescript &gt;savefile
$ vi savefile
</example>
La méthode suivante peut être utilisée à la place de script.
<example>
$ bash -i 2&gt;&amp;1 | tee typescript
</example>
</sect1>
<sect1>Enregistrer les activités sous X
<p>
Si vous avez besion d'enregistrer l'image d'une application sous X en 
comprenant l'affichage graphique du terminal X, utilisez gimp. Il peut 
"capturer" une fenêtre isolée ou l'écran entier. 
Une alternative est xwd (console).
</sect1>
</sect>

<sect>Déplacer / copier des fichiers
<p>
En cas de réarrangement de la sructure de fichiers, déplacez le contenu des 
dossiers y compris les liens par les commandes:
<example>
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        (cd /dest/directory &amp;&amp; tar xvfp - )
# cp -a /source/directory /dest/directory
# (cd /source/directory &amp;&amp; tar cf - . ) | \
        ssh user@host.dom (cd /dest/directory &amp;&amp; tar xvfp - )
S'il n'y a pas de lien:
# scp -pr user1@host1.dom:/source/directory user2@host2.dom:/dest/directory
</example>
Ici, scp &lt;==&gt; rcp et ssh &lt;==&gt; rsh.
</sect>

<sect>Modifier les fichiers grâce aux expressions régulières
<p>
Pour remplacer toutes les occurences de FROM_REGEX par TO_REGEX dans tous 
les fichiers FILES ...:
<example>
# perl -i -p -e 's/FROM_REGEX/TO_REGEX/g;' FILES ...
</example>
"-i" est pour "édition sur place", "-p" est pour "boucle implicite sur FILES ...".
</sect>


<sect>System freeze recovery
<sect1>Kill process
<p>
Run "top" to see what process is acting funny. Press "P" to sort by cpu 
time, "M" to sort by memory, and "k" to kill process.
<p>
Use "kill" and "killall" to kill (or send signal) to process by name.
<example>
 1: HUP,  restart daemon
15: TERM, normall kill
 9: KILL, kill hard.
</example>

</sect1>

<sect1>ALT-SysRQ
<p>
Insurance to system malfunction is a kernel compile option Magic SysRq key.
Pressing ALT-SysRQ on i386 with a single key 'r0keisub' do the magic. 
<p>
Un'R'aw gets back keyboard after things like X cashes.  Changing loglevel to
'0' reduces error message.  sa'K' (system attention key) kills all processes on
the current virtual console.  t'E'rm kill all processes on the current terminal
except init.  k'I'll kill all processes except init.
<p>
'S'ync, 'U'mount, and re'B'oot to get out of really bad situation.
<p>
Debian default installation kernels are not compiled with this option as I see
it now.  Recompile kernel to activate this function.  Detail information is in
/usr/share/doc/kernel-doc-version/Documentation/sysrq.txt.gz.

</sect1>
</sect>

<sect>Config files

<sect1>Login control
<p>
[FIXME]
<example>
/etc/securetty           # control root login by the console
/etc/hosts.{allow|deny}  # control login by the host
</example>
nfs etc. requires login for sunrpc.  "man 8 portmap".
</sect1>

<sect1>Defaults
<p>
<example>
/etc/defaults/rcS        # boot defaults (motd, sulogin,...)
/etc/syslog.conf         # system log mode (check "colorize" package)
</example>
</sect1>
</sect>

<sect>Nifty little commands to remember
<sect1>Free memory
<p>
"free" and "top" gives good information on memory resources.  Do not 
worry about size of "used" in "Mem:" line but read the one under it 
(38792 for below example). 
<example>
$ free -k # for 256MB machine
             total       used       free     shared    buffers cached
Mem:        257136     230456      26680      45736     116136 75528
-/+ buffers/cache:      38792     218344
Swap:       264996          0     264996
</example>
Exact physical memory can be confirmed by "grep '^Memory' /var/log/dmesg" 
which is "Memory: 256984k/262144k available (1652k kernel code, 412k 
reserved, 2944k data, 152k init)".
<example>
Total         = 262144k = 256M (1k=1024, 1M=1024k)
Free at dmesg = 256984k = Total - kernel - reserved - data - init
Free at shell = 257136k = Total - kernel - reserved - data
</example>
About 5MB is not usable by system because kernel uses them.
</sect1>

<sect1>Set time (BIOS)
<p>
<example>
# date MMDDhhmmCCYY
# hwclock --utc
# hwclock --systohc
# hwclock --show
</example>
This will set system and hardware time to MM/DD hh:mm, CCYY.
Times are displayed for local time but hardware time use UT.
<p>
System clock to correct time automatically by remote server:
<example>
# ntpdate &lt;server&gt;
</example>
This is good to have in /etc/cron.daily if on permanent connection.
</sect1>

<sect1>How to disable screensaver
<p>
In Linux console:
<example>
# setterm -powersave off
</example>
<p>
Start kon2(kanji) console with:
<example>
# kon -SaveTime 0
</example>
<p>
In X window:
<example>
# xset s off
 or
# xset -dpms
 or
# xscreensaver-command -prefs
</example>
Read the corresponding man pages.
</sect1>

<sect1>Disable sound (beep)
<p>
One can always unplug pc-speaker ;-)  For shell:
<example>
echo "set bell-style none">> ~/.inputrc:
</example>
</sect1>

<sect1>Get console back to the sane state
<p>
When screen goes bizzerk after "$ cat binaryfile", (blind typing recommended):
<example>
$ reset
</example>
</sect1>

<sect1>Convert text file from DOS to Unix style
<p>
Convert DOS (^M^J) text file to Unix file(^J).
<example>
# apt-get install sysutils
$ dos2unix dosfile
</example>
</sect1>

<sect1>Convert large file into small files
<p>
<example>
$ split -b 650m file   # split file into 650 MB chanks
$ cat x* >largefile    # amege files into 1 large file
</example>

<sect1>Script snippet for piping command
<p>
Following scripts will do nice things as a part of pipe.
<example>
xargs -n 1 command   # run command for all items from stdin
xargs -n 1 echo|     # split white space separated items into lines
grep -e pattern|     # extract lines containing pattern
cut -d: -f3 -|       # extract third field separated by :  (passwd file etc.)
col -bx |            # remove backspace and expand tabs to spaces
expand -|            # expand tabs
sort -u|             # sort and remove duplicates
tr '\n' ' '|         # concatenate lines into a line
tr '\r' ''|          # remove CR
tr 'A-Z' 'a-z'|      # convert upper case to lower case
sed 's/^/# /'|       # make each line comment
sed 's/\.ext//g'|    # remove .ext
sed  -n -e 2p|       # print a second line
head -n 2 -|         # print first 2 lines
tail -n 2 -|         # print last 2 lines
</example>
</sect1>

<sect1>Get text / ML archive from web page.
<p>
Following will read web page into a text file.
Very useful when copying configuration off web.
<example>
$ lynx -dump http://www.remote-site.com/help-info.html &gt;textfile
</example>
<p>
If this is ML archive, use "munpack" to obtain mime contents from text.
</sect1>

<sect1>Time command
<p>
Display time used by the process.
<example>
# time df >/dev/null
real    0m0.035s       # time on wall clock (elapsed real time)
user    0m0.000s       # time in user mode
sys     0m0.020s       # time in kernel mode
</example>
</sect1>

<sect1>Nice command
<p>
nice (from GNU-shutils) to set nice value upon start. renice (bsdutild) or 
top can renice process. nice (20) means slowest process.  Not-nice (-20) 
means super-user and very fast process. 
<example>
# nice  -19 top                                         # very nice
# nice --20 cdrecord -v -eject speed=2 dev=0,0 disk.img # very fast
</example>
</sect1>

<sect1>Schedule activity (cron, at)
<p>
Use "cron" and "at" to schedule task on Linux.  See "man at", "man 5
crontab" and "man 8 crontab".  
<p> 
Run "crontab" command with crontab-file to set up irregular scheduled
events.  Example of crontab-file: 
<example>
# use /bin/sh to run commands, no matter what /etc/passwd says
SHELL=/bin/sh
# mail any output to `paul', no matter whose crontab this is
MAILTO=paul
# Min Hour DayOfMonth Month DayOfWeek command (Day... are ORed)
# run at 00:05, every day
5  0  *  * *   $HOME/bin/daily.job &gt;&gt; $HOME/tmp/out 2&gt;&amp;1
# run at 14:15 on the first of every month -- output mailed to paul
15 14 1  * *   $HOME/bin/monthly
# run at 22:00 on weekdays(1-5), annoy Joe. % for newline, last % for cc:
0 22 *   * 1-5 mail -s "It's 10pm" joe%Joe,%%Where are your kids?%.%%
23 */2 1 2 *   echo "run 23 minutes after 0am, 2am, 4am ..., on Feb 1"
5  4 *   * sun echo "run at 04:05 every sunday"
# run at 03:40 on the first Monday of each month
40 3 1-7 * *   [ "$(date +%a)" == "Mon" ] && command -args
</example>
Run "at" command to schedule one time job:
<example>
$ echo 'command -args'| at 3:40 monday
</example>
</sect1>

<sect1>Console switching
<p>
[FIXME] following seems interesting
<example>
screen for console
xmove  for X
</example>
</sect1>

<sect1>Network testing basics
<p>
<example>
$ ping yahoo.com            # check intetrnet connection
$ traceroute yahoo.com      # trace ip packets
$ ifconfig                  # check host config
$ route -n                  # check routing config
$ dig [@dns-server.com] host.dom [{a|mx|any}] |less    \
      # check host.dom DNS records [@ dns-server.com] for a [{mx|any}] record
$ ichains  -L -n |less      # check packet filter (2.2 kernel)
$ iptables -L -n |less      # check packet filter (2.4 kernel)
$ netstat -a | grep LISTEN  # find out all open ports (needs net-tools)
</example>
</sect1>

<sect1>Flush mails from local spool
<p>
To flush mails from local spool:
<example>
$ su -c "exim -q"
</example>
</sect1>

<sect1>Clear file contents
<p>
Do not use "rm" in case it is accessed by others.
<example>
$ :>file-to-be-cleared
</example>
</sect1>

<sect1>Dummy files
<p>
<example>
$ dd if=/dev/zero    of=filename bs=1k count=5 # 5KB of zero content
$ dd if=/dev/urandom of=filename bs=1m count=7 # 7MB of random content
$ touch filename                        #  create 0B file or update mtime
</example>
</sect1>

<sect1>chroot
<p>
You can create independent system sharing same kernel.
<example>
# mount /dev/hda1 /mnt/target   # suppose /dev/hda1 contain 1 system
# chroot /mnt/target
... Now it looks like root is /dev/hda1 contents
# mount proc /proc              # just in case
... run command within /dev/hda1
</example>
This enables stable/testing/unstable to be loaded on one machine.  Also, one
may run memory hungry program such as dselect running on a host machine while
NSF mounting satelite machine to a host as r/w and chroot into there.
</sect1>

<sect1>Samba
<p>
Basics of getting file from Windoze:
<example>
# mount -t smb -o username=myname,uid=my_uid,gid=my_gid\
   //server/share/mnt/smb/ # mount Windows file to Linux
# smbclient -L 192.168.1.2 # list the shares on a computer
</example>
</sect1>

</sect>

</chapt>


