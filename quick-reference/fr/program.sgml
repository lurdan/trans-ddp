<!-- CVS revision of this document "$Revision: 1.9 $"  -->
<!-- CVS revision of original english document "1.18"  -->
<chapt id="program">Programmation
<p>
N'utilisez pas "test" comme nom d'exécutable pour un fichier de test. <prgn>test</prgn>
est une commande du shell.
<sect>Où commencer
<p>
<em>Linux Programming Bible</em> (John Goerzen/IDG books)
<p>
Documents et exemples sous <file>/usr/share/doc/&lt;packages&gt;</file>
<p>
Beaucoup de longs documents informatifs peuvent être obtenus sur papier par
<url id="&gnuhome;" name="GNU">.
<p>
Les quatres sections suivantes contiennent quelques scripts d'exemple dans
différents langages pour créer un fichier texte d'information sur les comptes
utilisateur qui peut être ajouté à <file>/etc/passwd</file>, avec par exemple
le programme <prgn>newusers</prgn>. Chaque script prend en entrée un fichier
contenant des lignes de la forme <tt>prénom nom mot_de_passe</tt>. (Les
répertoires "home" des utilisateurs ne seront pas créés avec ces scripts.)
</sect>

<sect id="bash">BASH
<p>
<em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
<example>
$ info bash
$ mc   /usr/share/doc/bash/examples/ /usr/share/doc/bash/
</example>
(Il faut installer le paquet <package>bash-doc</package> pour avoir les fichiers d'exemple.)
<p>
Court exemple de programme (crée un nouvel utilisateur) :
<example>
#!/bin/bash
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>
</sect>

<sect>AWK
<p>
<em>Effective awk Programming</em>, 3rd edition, et <em>sed &amp; awk</em>,
2nd edition (O'Reilly)
<example>
$ man awk
</example>
Court exemple de programme (crée un nouvel utilisateur) :
<example>
#!/usr/bin/awk -f
# Script pour créer un fichier utilisable avec la commande 'newusers' à partir
# d'un fichier contenant des IDs utilisateur et des mots de passe sous la
# forme :
# Prénom Nom Mot_de_passe
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
	startuid = ARGV[1]
	delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
	  "...where startUID is the starting userid " \
	  "to add, and file is \n" \
	  "an input file in form firstname last name password\n" \
	)
	exit
    }

    infile = ARGV[1]
    printf( "Starting UID: %s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n",  \
	user, passwd, uid, gid, first, last, user \
	)
}
</example>
</sect>

<sect>PERL
<p>
<em>Programming Perl</em>, 3rd edition (O'Reilly)
<example>
$ man perl
</example>
Court exemple de programme (crée un nouvel utilisateur) :
<example>
#!/usr/bin/perl
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
	if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Installer le module Perl <var>module name</var> :
<example>
# perl -MCPAN -e 'install <var>module name</var>'
</example>
 
</sect>

<sect>PYTHON
<p>
<em>Learning Python</em> (O'Reilly).
C'est un interpréteur sympa.
<example>
$ man python
</example>
Court exemple de programme (crée un nouvel utilisateur) :
<example>
#! /usr/bin/env python
import sys, string

# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input file name. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirstname lastname password\n"
		return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crash with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n" %  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: %d\n" % uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: %s\n\n" % infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>MAKE
<p>
<em>Managing Projects with make</em>, 2nd edition (O'Reilly)
<example>
$ info make
</example>
Variables automatiques simples :
<p>
Syntaxe des règles :
<example>
Cible: [ Prérequis ... ]
&lt; TAB &gt; command1
&lt; TAB &gt; -command2 # peut générer une erreur
&lt; TAB &gt; @command3 # pas d'echo
</example>
Chaque ligne est interprétée par le shell après la substitution des variables
par make.
Utiliser <tt>\</tt> à la fin d'une ligne pour continuer le script.
Utiliser <tt>$$</tt> pour entrer <tt>$</tt> pour les variables d'environnement
du script shell.
<p>
Equivalents des règles implicites :
<example>
.c:   header.h == %  : %.c header.h
.o.c: header.h == %.c: %.o header.h
</example>
Variables automatiques pour les règles ci-dessus :
<example>
foo.o: new1.c new2.c.c old1.c new3.c
$@ == foo.o                         (cible)
$< == new1.c                        (premier)
$? == new1.c new2.c new3.c          (plus récent)
$^ == new1.c new2.c.c old1.c new3.c (tout)
$* == `%' motif correspondant dans le motif cible.
</example>
Référence des variables :
<example>
foo1 := bar    # expansion unique
foo2  = bar    # expansion récursive
foo3 += bar    # ajoute
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:%.c=%.o) 
OBJS := $(patsubst %.c,%.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extrait "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Exécuter <tt>make -p -f/dev/null</tt> pour voir les règles automatiques
internes.
</sect>

<sect>C
<p>
Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 2nd edition
(Prentice Hall).
Pour obtenir la référence de la bibliothèque C GNU :
<example>
# apt-get install glibc6-doc manpages-dev
</example>
Pour lire la référence de la bibliothèque C GNU, utilisez "<prgn>info
libc</prgn>".
Pour chaque fonction, "printf" par exemple, utilisez "<prgn>man 3
printf</prgn>".

<sect1>Programme simple en C (gcc)
<p>
Un exemple simple pour compiler <prgn>example.c</prgn> avec la bibliothèque
<prgn>libm</prgn> dans l'exécutable <prgn>run_example</prgn> :
<example>
$ cat exmple.c 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
	double x;
	char y[11];
	x=sqrt(argc+7.5);
	strncpy(y, argv[0], 10); /* prevent buffer overflow */
	y[10] = '\0'; /* fill to make sure end with '\0' */
	printf("%5i, %5.3f, %10s, %10s\n", argc, x, y, argv[1]);
	return 0;
}

$ gcc -Wall -g -o run_example exmple.c -lm
$ ./run_example
    1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
    2, 3.082, ./run_exam, 1234567890qwerty
</example>
Ici, <tt>-l<strong>m</strong></tt> est nécessaire pour lier la bibliothèque
<tt>lib<strong>m</strong></tt>, pour utiliser sqrt(). La bibliothèque est en
fait dans <file>/lib</file> sous le nom <file>libm.so.6</file> qui est un lien
symbolique vers <file>libm-2.1.3.so</file>.
<p>
Regardez le dernier paramètre dans le texte imprimé. Il y a plus de 10
caractères imprimés alors que <tt>%10s</tt> est spécifié.
<p>
L'utilisation de fonctions effectuant des opérations sur des pointeurs sans
vérifier la limite, comme <prgn>sprintf</prgn> et <prgn>strcpy</prgn>, est
dépréciée pour prévenir les exploits de dépassement de buffer, annulant les
effets ci-dessus. Utilisez <prgn>snprintf</prgn> et <prgn>strncpy</prgn> à la
place.
</sect1>

<sect1>Déboguer (<prgn>gdb</prgn>)
<p>
<url id="&gdbtutorial;" name="Didacticiel GDB"> (NdT : en
Anglais)
<p>
Utilisez <prgn>gdb</prgn> pour déboguer des programmes compilés avec l'option
<tt>-g</tt>.
Beaucoup de commandes peuvent être abbréviées. L'expansion par tab marche
comme avec le shell.
<example>
$ info gdb
...
$ gdb program
(gdb) b 1                # positionne un point d'arrêt à la ligne 1
(gdb) run arg1 arg2 arg3 # exécute le programme
(gdb) next               # ligne suivante
...
(gdb) step               # pas en avant
...
(gdb) p parm             # affiche parm
...
(gdb) p parm=12          # met la valeur de parm à 12
</example>
<p>
Les commandes suivantes sont aussi utiles :
<list>
<item><prgn>ldd</prgn> :    affiche les dépendances des bibliothèques partagées
<item><prgn>strace</prgn> : trace les appels et signaux système
<item><prgn>ltrace</prgn> : trace les appels aux bibliothèques
</list>
<p>
Pour déboguer depuis emacs, référez-vous à <ref id="editkey">.
</sect1>

<sect1>Flex &ndash; un meilleur Lex
<p>
Vous devez fournir vos propres <prgn>main()</prgn> et <prgn>yywrap()</prgn>, ou
votre <prgn>program.l</prgn>. Il ne devrait pas y avoir besoin de bibliothèque
pour compiler. (<prgn>yywrap</prgn> est une macro ; <tt>%option main</tt>
active <tt>%option noyywrap</tt> implicitement) :
<example>
%option main
%%
.|\n	ECHO ;
%%
</example>
Autrement, vous pouvez compiler avec l'option du linker -l<tt>fl</tt> à la fin
de la ligne de commande de <prgn>cc</prgn>, comme ATT-Lex avec -l<tt>l</tt>
(pas de %option nécessaire).
</sect1>

<sect1>Bison &ndash; un meilleur Yacc
<p>
Vous devez fournir vos propres <prgn>main()</prgn> et <prgn>yyerror()</prgn>.
<prgn>main()</prgn> appelle <prgn>yyparse()</prgn> qui appelle
<prgn>yylex()</prgn>, habituellement créé avec Flex.
<example>
%%

%%
</example>
</sect1>

<sect1>Autoconf &ndash; uninstall
<p>
SI vous avez toujours les sources et SI elles utilisent autoconf/automake et
SI vous vous souvenez comment vous avez configuré la compilation :
<example>
$ ./configure les-options-de-configuration
# make uninstall
</example>
</sect1>

</sect>

<sect>SGML
<p>
Un moyen de gérer plusieurs formats pour un document est SGML. Un SGML plus
facile est offert avec debiandoc, qui est utilisé ici. Cela requiert des
conversions mineurs dans le fichier texte original, pour les caractères
suivants :
<example>
&lt;   &amp;lt;
&gt;   &amp;gt;
&amp;   &amp;amp;
&copy;   &amp;copy;
&ndash;   &amp;ndash;
&mdash;   &amp;mdash;
</example>
Pour marquer une section en tant que commentaire non imprimable, faites :
<example>
&lt;!-- State issue here ... --&gt;
</example>
Pour marquer une section en tant que commentaire ou pas à l'impression, faites
:
<example>
&lt;![ %FIXME [ State issue here ... ]]&gt;
</example>
En SGML, la <em>première définition</em> d'une entité l'emporte. Par exemple :
<example>
&lt;!entity % qref "INCLUDE"&gt;
&lt;![ %qref [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
Cela termine en tant que "Data 1". Si la première ligne inclut "IGNORE" au
lieu de "INCLUDE", cela termine en tant que "Data 2" (la deuxième ligne est
conditionnelle).
<p>
Pour plus de détails, faites <tt>apt-get install
debiandoc-sgml-doc</tt>. Lisez aussi <em>DocBook: The Definitive
Guide</em>, by Walsh and Muellner (O'Reilly).
</sect>

<sect id="packaging">Paquetage
<p>
Lisez la documentation fournie dans le paquet
<package>packaging-manual</package> (Potato) ou
<package>debian-policy</package> (Woody).
<p>
Utilisez <prgn>dh_make</prgn> du paquet <package>dh-help</package> pour créer
l'architecture du paquet.  Ensuite, suivez les instructions de <manref
name="dh-make" section="1">, qui utilise <prgn>debhelper</prgn> dans
<prgn>debian/rules</prgn>.
<p>
Une autre approche est d'utiliser <prgn>deb-make</prgn> du paquet
<package>debmake</package>. Cela n'utilise aucun script <prgn>debhelper</prgn>
et dépend seulement du shell.
<p>
Pour plusieurs paquets source, voir "mc" (<tt>dpkg-source -x
mc_4.5.54.dsc</tt>) qui utilise "sys-build.mk" par Adam Heath
(<email>doogie@debian.org</email>) et "glibc" (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>) qui utilise un autre système par Joel Klecker
(<email>espy@debian.org</email>).
</sect>

</chapt>
