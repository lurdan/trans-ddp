<!-- CVS revision of this document "$Revision: 1.15 $"  -->
<!-- CVS revision of original english document "1.30"  -->

<chapt id="program">Programmation
<p>
N'utilisez pas «&nbsp;test&nbsp;» comme nom d'exécutable pour un fichier de
test. <prgn>test</prgn> est une commande du shell.

<sect>Où commencer
<p>
Références&nbsp;:
<list compact>
<item>Documents et exemples sous <file>&dochome;<var>packages</var></file>
<item><url id="&uno-jclark;" name="Unix / Programming Information">
<item><em>Linux Programming Bible</em> (John Goerzen/IDG books)
</list>
<p>
Beaucoup de longs documents informatifs peuvent être obtenus sur papier par
<url id="&gnuhome;" name="GNU">.
<p>
Les quatres sections suivantes contiennent quelques scripts d'exemple dans
différents langages pour créer un fichier texte d'information sur les comptes
utilisateur qui peut être ajouté à <file>/etc/passwd</file>, avec par exemple
le programme <prgn>newusers</prgn>. Chaque script prend en entrée un fichier
contenant des lignes de la forme <tt>prénom nom mot_de_passe</tt>. (Les
répertoires «&nbsp;home&nbsp;» des utilisateurs ne seront pas créés avec ces scripts.)
</sect>

<sect id="shell">Shell
<p>
Lire des scripts shell est le <strong>meilleur</strong> moyen de comprendre
comment un système Unix fonctionne. Ici, je donne quelques pointeurs et
rappels sur la programmation du shell.

<sect1 id="bash">Bash &ndash le shell intéractif standard de <strong>GNU</strong>
<p>
Références pour Bash&nbsp;:
<list compact>
<item><manref name="bash" section="1">
<item><tt>info bash</tt>
<item><url id="&bashprogintro-howto;" name="BASH Programming - Introduction
HOWTO"> du LDP comme information pour commencer
<item><tt>mc &dochome;bash/examples/ &dochome;bash/</tt>
 <p>
 (Installez le paquet <package>bash-doc</package> pour avoir les exemples.)
<item><em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
</list>
<p>
Court exemple de programme (crée des entrées de compte pour
<prgn>newusers</prgn> à partir de l'entrée standard)&nbsp;:
<example>
#!/bin/bash
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>

<sect1 id="posix-shell">Shells POSIX
<p>
Plusieurs paquets fournissent un shell POSIX dans &debian;&nbsp;:
<list compact>
 <item><package>dash</package> (Sarge)
 <list compact>
  <item>Priorité&nbsp;: optionnel
  <item>Taille installé&nbsp;: 176
  <item>Le plus petit et le plus rapide &mdash; le meilleur pour le démarrage initial
 </list>
 <item><package>ash</package> (Woody)
 <list compact>
  <item>Priorité&nbsp;: optionnel
  <item>Taille installé&nbsp;: 180
  <item>Plus petit et plus rapide &mdash; bon pour le démarrage initial
 </list>
 <item><package>bash</package>
 <list compact>
  <item>Essentiel&nbsp;: yes
  <item>Priorité&nbsp;: requis
  <item>Taille installé&nbsp;: 580
  <item>Plus gros et plus complet &mdash; beaucoup d'extensions sont implémentées
 </list>
 <item><package>pdksh</package>
 <list compact>
  <item>Priorité&nbsp;: optionnel
  <item>Taille installé&nbsp;: 408
  <item>Clone complet du ksh d'AT&amp;T
 </list>
</list>
<p>
Si vous écrivez des scripts shell portables, il vaut mieux les écrire comme
scripts shell POSIX. Utilisez <file>/bin/sh</file> lié vers <prgn>ash</prgn>
ou (<prgn>dash</prgn>) pour tester sa conformité POSIX. Évitez d'écrire des
scripts avec des <strong>bashismes</strong>.

<sect1 id="shell-param">Paramètres du shell
<p>
Plusieurs <strong>paramètres spéciaux</strong> à se rappeler&nbsp;:
<example compact>
$0      = nom du shell ou du script shell
$1      = premier argument
 ...
$9      = neuvième argument
$#      = nombre de paramètres
"$*"    = "$1 $2 $3 $4 ... $<var>n</var>"
"$@"    = "$1" "$2" "$3" "$4" ... "$<var>n</var>"
$?      = état de sortie de la commande la plus récente
$$      = PID du script shell
$!      = PID du processus en arrière-plan le plus récent
</example>
<p>
<strong>Expansions des paramètres</strong> de base à se rappeler&nbsp;:
<example compact>
    Forme        Si <var>var</var> est positionné(*)    Si <var>var</var> n'est pas positionné(*)
${<var>var</var>:-<var>string</var>}  $<var>var</var>                <var>string</var>
${<var>var</var>:+<var>string</var>}  <var>string</var>              null
${<var>var</var>:=<var>string</var>}  $<var>var</var>                <var>string</var>
                                    (et lance <var>var</var>=<var>string</var>)
${<var>var</var>:?<var>string</var>}  $<var>var</var>                (affiche <var>string</var> et sort)
</example>
Ici, les deux points «&nbsp;:&nbsp;» dans tous ces opérateurs est optionnel.
<list compact>
<item>Avec «&nbsp;:&nbsp;» = l'opérateur teste l'existence et la non nullité.
<item>Sans «&nbsp;:&nbsp;» = l'opérateur teste l'existence seulement.
</list>
<p>
<strong>Substitutions de paramètres</strong> de base à se rappeler&nbsp;:
<example compact>
    Forme        Résultat
${<var>var</var>&percnt;<var>suffix</var>}   Supprime le plus petit motif <var>suffix</var>
${<var>var</var>&percnt;&percnt;<var>suffix</var>}  Supprime le plus grand motif <var>suffix</var>
${<var>var</var>#<var>prefix</var>}   Supprime le plus petit motif <var>prefix</var>
${<var>var</var>##<var>prefix</var>}  Supprime le plus grand motif <var>prefix</var>
</example>

<sect1 id="shell-redirect">Redirection du shell
<p>
<strong>Redirection</strong> de base à se rappeler (ici le [n] est un nombre optionnel)&nbsp;:
<example compact>
[n]&gt; <var>file</var>     Redirige la sortie standard (ou n) vers <var>file</var>.
[n]&gt;&gt; <var>file</var>    Ajoute la sortie standard (ou n) à <var>file</var>.
[n]&lt; <var>file</var>     Redirige l'entrée standard (ou n) depuis <var>file</var>.
[n1]&gt;&amp;n2      Redirige la sortie standard (ou n1) vers n2
&gt; <var>file</var> &gt;&2    Redirige l'entrée et l'erreur standards vers <var>file</var>.
| <var>command</var>     Crée un tuyau (pipe) de l'entrée standard (ou n) vers <var>command</var>.
&gt;&2 | <var>command</var> Crée un tuyau (pipe) de l'entrée et l'erreur standards vers <var>command</var>.
</example>

<sect1 id="shell-cond">Opérateurs conditionnels du shell
<p>
Toutes les commandes retournent un <strong>état de sortie</strong> qui peut
être utilisé par les expressions conditionnelles&nbsp;:
<list compact>
<item>Succès&nbsp;: 0 (Vrai)
<item>Erreur&nbsp;: 1 - 255 (Faux)
</list>
Notez que l'utilisation de la valeur 0 signifie «&nbsp;vrai&nbsp;»
contrairement à d'autres domaines de l'informatique.
De même, `[' est l'équivalent de la commande <prgn>test</prgn>, qui évalue ses
arguments jusqu'à `]' comme expression conditionnelle.
<p>
<strong>Expressions conditionnelles</strong> de base à se rappeler&nbsp;:
<example compact>
<var>command</var> && <var>si_succès_lance_cette_commande_aussi</var>
<var>command</var> || <var>si_échec_lance_cette_commande_aussi</var>

if [ <var>expression_conditionnelle</var> ]; then
 <var>si_succès_lance_cette_commande</var>
else
 <var>si_échec_lance_cette_commande</var>
fi
</example>
<p>
Les opérateurs de comparaison de <strong>fichiers</strong> dans les
expressions conditionnelles sont&nbsp;:
<example compact>
-e <var>file</var>         Vrai si <var>file</var> existe.
-d <var>file</var>         Vrai si <var>file</var> existe et est un répertoire.
-f <var>file</var>         Vrai si <var>file</var> existe et est un fichier normal.
-w <var>file</var>         Vrai si <var>file</var> existe et est en écriture.
-x <var>file</var>         Vrai si <var>file</var> existe et est exécutable.
<var>file1</var> -nt <var>file2</var> Vrai si <var>file1</var> est plus récent que <var>file2</var>. (modification)
<var>file1</var> -ot <var>file2</var> Vrai si <var>file1</var> est plus vieux que <var>file2</var>. (modification)
<var>file1</var> -ef <var>file2</var> Vrai si ce sont les numéros de périphérique et d'inode.
</example>
<p>
Les opérateurs de comparaison de <strong>chaînes</strong> dans les expressions
conditionnelles sont&nbsp;:
<example compact>
     -z <var>str</var>    Vrai si la longueur de <var>str</var> est zéro.
     -n <var>str</var>    Vrai si la longueur de <var>str</var> est différente de zéro.
<var>str1</var> == <var>str2</var>   Vrai si les chaînes sont égales.
<var>str1</var> = <var>str2</var>    Vrai si les chaînes sont égales.
               ( = peut être utilisé à la place de == )
<var>str1</var> != <var>str2</var>   Vrai si les chaînes ne sont pas égales.
<var>str1</var> &lt;  <var>str2</var>   Vrai si <var>str1</var> est classée avant <var>str2</var> (dépend de la locale).
<var>str1</var> &gt;  <var>str2</var>   Vrai si <var>str1</var> est classée après <var>str2</var> (dépend de la locale).
</example>
<p>
Les opérateurs de comparaison <strong>arithmétique</strong> entière dans les
expressions conditionnelles sont <tt>-eq</tt>, <tt>-ne</tt>, <tt>-lt</tt>,
<tt>-le</tt>, <tt>-gt</tt>, ou <tt>-ge</tt>.
</sect1>

<sect1 id="clprocess">Traitement de la ligne de commande
<p>
Le shell traite un script de la façon suivante&nbsp;:
<list compact>
<item>séparation en <strong>motifs</strong> par les caractères&nbsp;: ESPACE, TAB, NEWLINE, ;, (, ), &lt;, &gt;, |, &amp;
<item>recherche de <strong>mots clé</strong> si pas entre "..." ou '...' (boucle)
<item>expansion des <strong>alias</strong> si pas entre "..." ou '...' (boucle)
<item>expansion des <strong>accolades</strong>, A{b|c} -> Ab Ac, si pas entre "..." ou '...'
<item>expansion des <strong>tilde</strong>, ~<var>user</var> -> $HOME/$USER, si pas entre "..." ou '...'
<item>expansion des <strong>paramètres</strong>, $<var>PARAMETER</var>, si pas entre '...'
<item>expansion des <strong>substitutions de commandes</strong>, $(<var>command</var>), si pas entre '...'
<item>séparation en <strong>mots</strong> avec $IFS si pas entre "..." ou '...'
<item>expansion des <strong>noms de chemins</strong> *?[] si pas entre "..." ou '...'
<item>recherche de la <strong>commande</strong>
<list compact>
<item>fonction
<item>commande interne
<item>fichier dans $PATH
</list>
<item>boucle
</list>
<p>
Des guillemets simples dans des guillemets doubles n'ont pas d'effet.

</sect1>

</sect>

<sect>Awk
<p>
Références pour Awk&nbsp;:
<list compact>
<item><em>Effective awk Programming</em>, 3rd edition (O'Reilly)
<item><em>Sed &amp; awk</em>, 2nd edition (O'Reilly)
<item><manref name="mawk" section="1"> et <manref name="gawk" section="1">
<item><tt>info gawk</tt>
</list>
<p>
Court exemple de programme (crée des entrées de compte pour
<prgn>newusers</prgn>)&nbsp;:
<example>
#!/usr/bin/awk -f
# Script pour créer un fichier utilisable avec la commande 'newusers' à partir
# d'un fichier contenant des IDs utilisateur et des mots de passe sous la
# forme :
# Prénom Nom Mot_de_passe
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
        startuid = ARGV[1]
        delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
          "...where startUID is the starting userid " \
          "to add, and file is \n" \
          "an input file in form firstname last name password\n" \
        )
        exit
    }

    infile = ARGV[1]
    printf( "Starting UID: &percnt;s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n",  \
        user, passwd, uid, gid, first, last, user \
        )
}
</example>
<p>
Deux paquets fournissent un <package>awk</package> POSIX dans &debian;&nbsp;:
<list compact>
 <item><package>mawk</package>
 <list compact>
  <item>Priorité&nbsp;: requis
  <item>Taille installé&nbsp;: 228
  <item>Plus petit et beaucoup plus rapide &mdash; bon pour l'installation par défaut
  <item>Des limites définies à la compilation existent
  <list compact>
   <item>NF = 32767
   <item>sprintf buffer = 1020
  </list>
 </list>
 <item><package>gawk</package>
 <list compact>
  <item>Priorité&nbsp;: Optionnel
  <item>Taille installé&nbsp;: 1708
  <item>Plus gros et plus complet &mdash; beaucoup d'extensions sont implémentées
  <list compact>
   <item>Version d'UNIX System V Release 4
   <item>awk de Bell Labs
   <item>spécifiques à GNU
  </list>
 </list>
</list>
</sect>

<sect>Perl
<p>
C'est <strong>l'</strong>interpréteur sur un système Unix.
<p>
Références pour Perl&nbsp;:
<list compact>
<item><manref name="perl" section="1">
<item><em>Programming Perl</em>, 3rd edition (O'Reilly)
</list>
<p>
Court exemple de programme (crée une entrée <prgn>newusers</prgn>)&nbsp;:
<example>
#!/usr/bin/perl
# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
        if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Installer le module Perl <var>modulename</var>&nbsp;:
<example>
# perl -MCPAN -e 'install <var>modulename</var>'
</example>
 
</sect>

<sect>Python
<p>
C'est un interpréteur orienté objet sympa.
<p>
Références pour Python&nbsp;:
<list compact>
<item><manref name="python" section="1">
<item><em>Learning Python</em> (O'Reilly).
</list>
<p>
Court exemple de programme (crée une entrée <prgn>newusers</prgn>)&nbsp;:
<example>
#! /usr/bin/env python
import sys, string

# (C) Osamu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input file name. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirstname lastname password\n"
                return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # crashe si le nombre de paramètres est mauvais :-)
        user = first[0] + last
        gid = uid
        lineout = "&percnt;s:&percnt;s:&percnt;d:&percnt;d:&percnt;s &percnt;s,,/home/&percnt;s:/bin/bash\n" &percnt;  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: &percnt;d\n" &percnt; uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: &percnt;s\n\n" &percnt; infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>Make
<p>
Références pour Make&nbsp;:
<list compact>
<item><tt>info make</tt>
<item><manref name="make" section="1">
<item><em>Managing Projects with make</em>, 2nd edition (O'Reilly)
</list>
<p>
Variables automatiques simples&nbsp;:
<p>
Syntaxe des règles&nbsp;:
<example>
<var>Target</var>: [ <var>Prerequisite</var> ... ]
 [TAB]  <var>command1</var>
 [TAB]  -<var>command2</var> # ignore les erreurs
 [TAB]  @<var>command3</var> # supprime l'écho
</example>
Ici, <tt>[TAB]</tt> est un code TAB.
Chaque ligne est interprétée par le shell après la substitution des variables
par make.
Utiliser <tt>\</tt> à la fin d'une ligne pour continuer le script.
Utiliser <tt>$$</tt> pour entrer <tt>$</tt> pour les variables d'environnement
du script shell.
<p>
Equivalents des règles implicites&nbsp;:
<example>
.c:   header.h == &percnt;  : &percnt;.c header.h
.o.c: header.h == &percnt;.c: &percnt;.o header.h
</example>
Variables automatiques pour les règles ci-dessus&nbsp;:
<example>
foo.o: new1.c new2.c.c old1.c new3.c
$@ == foo.o                         (cible)
$< == new1.c                        (premier)
$? == new1.c new2.c new3.c          (plus récent)
$^ == new1.c new2.c.c old1.c new3.c (tout)
$* == `&percnt;' motif correspondant dans le motif cible.
</example>
Référence des variables&nbsp;:
<example>
foo1 := bar    # expansion unique
foo2  = bar    # expansion récursive
foo3 += bar    # ajoute
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:&percnt;.c=&percnt;.o) 
OBJS := $(patsubst &percnt;.c,&percnt;.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extrait "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Exécuter <tt>make -p -f/dev/null</tt> pour voir les règles automatiques
internes.
</sect>

<sect>C
<p>
Préparation&nbsp;:
<example>
# apt-get install glibc6-doc manpages-dev
</example>
<p>
Références pour le C&nbsp;:
<list compact>
<item><tt>info libc</tt> (C library function reference)
<item><manref name="gcc" section="1">
<item><manref name="<var>nom_de_la_fonction_de_la_bibliothèque_C</var>" section="3">
<item>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 2nd edition (Prentice Hall).
</list>
<p>

<sect1>Programme simple en C (<prgn>gcc</prgn>)
<p>
Un exemple simple pour compiler <prgn>example.c</prgn> avec la bibliothèque
<prgn>libm</prgn> dans l'exécutable <prgn>run_example</prgn>&nbsp;:
<example>
$ cat &gt; example.c  &lt;&lt; EOF
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
        double x;
        char y[11];
        x=sqrt(argc+7.5);
        strncpy(y, argv[0], 10); /* empêche un dépassement de tampon */
        y[10] = '\0'; /* remplissage pour être sûr que la chaîne finit par '\0' */
        printf("&percnt;5i, &percnt;5.3f, &percnt;10s, &percnt;10s\n", argc, x, y, argv[1]);
        return 0;
}
EOF
$ gcc -Wall -g -o run_example exmple.c -lm
$ ./run_example
        1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
        2, 3.082, ./run_exam, 1234567890qwerty
</example>
Ici, <tt>-l<strong>m</strong></tt> est nécessaire pour lier la bibliothèque
<tt>lib<strong>m</strong></tt>, pour utiliser sqrt(). La bibliothèque est en
fait dans <file>/lib</file> sous le nom <file>libm.so.6</file> qui est un lien
symbolique vers <file>libm-2.1.3.so</file>.
<p>
Regardez le dernier paramètre dans le texte affiché. Il y a plus de 10
caractères affichés alors que <tt>&percnt;10s</tt> est spécifié.
<p>
L'utilisation de fonctions effectuant des opérations sur des pointeurs sans
vérifier la limite, comme <prgn>sprintf</prgn> et <prgn>strcpy</prgn>, est
dépréciée pour prévenir les exploits de dépassement de tampon, annulant les
effets ci-dessus. Utilisez <prgn>snprintf</prgn> et <prgn>strncpy</prgn> à la
place.
</sect1>

<sect1>Déboguer

<sect2>Deboguer avec <prgn>gdb</prgn>
<p>
Préparation&nbsp;:
<example>
# apt-get install gdb
</example>
<p>
Références pour <prgn>gdb</prgn>&nbsp;:
<list compact>
<item><tt>info gdb</tt> (didacticiel)
<item><manref name="gdb" section="1">
</list>
<p>
Utilisez <prgn>gdb</prgn> pour déboguer des programmes compilés avec l'option
<tt>-g</tt>.
Beaucoup de commandes peuvent être abbréviées. L'expansion par tab marche
comme avec le shell.
<example>
$ gdb program
(gdb) b 1                # positionne un point d'arrêt à la ligne 1
(gdb) run <var>arg1 arg2 arg3</var> # exécute le programme
(gdb) next               # ligne suivante
...
(gdb) step               # pas en avant
...
(gdb) p parm             # affiche parm
...
(gdb) p parm=12          # met la valeur de parm à 12
</example>
<p>
Pour déboguer depuis Emacs, référez-vous à <ref id="editkey">.
</sect2>

<sect2 id="ss-ldd">Vérifier les dépendances sur des bibliothèques
<p>
Utilisez <prgn>ldd</prgn> pour trouver les dépendances d'un programme sur des
bibliothèques&nbsp;:
<example>
$ ldd /bin/ls
        librt.so.1 => /lib/librt.so.1 (0x4001e000)
        libc.so.6 => /lib/libc.so.6 (0x40030000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x40153000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</example>
Pour que <prgn>ls</prgn> marche dans un environnement <prgn>chroot</prgn>é,
les bibliothèques suivantes doivent être disponibles dans votre environnement
<prgn>chroot</prgn>é.
<p>
Les commandes suivantes sont aussi utiles&nbsp;:
<list>
<item><prgn>strace</prgn> : trace les appels et signaux système
<item><prgn>ltrace</prgn> : trace les appels aux bibliothèques
</list>
</sect2>

<sect2>Déboguer avec des outils de détection des fuites de mémoire
<p>
Il y a plusieurs outils de détection des fuites de mémoire disponibles dans
&debian;.
<p>
<list compact>
<item><package>njamd</package>
<item><package>valgrind</package>
<item><package>dmalloc</package>
<item><package>electric-fence</package>
<item><package>memprof</package>
<item><package>memwatch</package>
<item><package>mpatrol</package>
<item><package>leaktracer</package>
<item><package>libgc6</package>
<item><tt>Insure++</tt> de <url id="&parasofthome;" name="Parasoft">.
(non-libre, commercial gratuit)
</list>
<p>
Consultez aussi <url id="&mallocdebughome;" name="Debugging Tools for Dynamic
Storage Allocation and Memory Management">.

<sect1>Flex &ndash; un meilleur Lex
<p>
<prgn>flex</prgn> est un générateur rapide d'analyseur lexical.
<p>
Références pour <prgn>flex</prgn>&nbsp;:
<list compact>
<item><tt>info flex</tt> (didacticiel)
<item><manref name="flex" section="1">
</list>
<p>
Vous devez fournir vos propres <prgn>main()</prgn> et <prgn>yywrap()</prgn>, ou
votre <prgn>program.l</prgn> devrait ressembler à ce qui suit pour compiler
sans bibliothèque. (<prgn>yywrap</prgn> est une macro&nbsp;;
<tt>&percnt;option main</tt>active <tt>&percnt;option noyywrap</tt>
implicitement)&nbsp;:
<example>
&percnt;option main
&percnt;&percnt;
.|\n    ECHO ;
&percnt;&percnt;
</example>
Autrement, vous pouvez compiler avec l'option de l'éditeur de liens
-l<tt>fl</tt> à la fin de la ligne de commande de <prgn>cc</prgn> (comme
ATT-Lex avec -l<tt>l</tt>).  <tt>&percnt;option</tt> n'est pas nécessaire dans
ce cas.
</sect1>

<sect1>Bison &ndash; un meilleur Yacc
<p>
Quelques paquets fournissent un générateur d'analyseur LALR compatible avec Yacc dans
&debian;&nbsp;:
<p>
<list compact>
 <item><package>bison</package>&nbsp;: générateur d'analyseur LALR GNU
 <item><package>byyacc</package>&nbsp;: générateur d'analyseur avec retour
 arrière basé sur byacc
</list>
<p>
Références pour <prgn>bison</prgn>&nbsp;:
<list compact>
<item><tt>info bison</tt> (didacticiel)
<item><manref name="bison" section="1">
</list>
<p>
Vous devez fournir vos propres <prgn>main()</prgn> et <prgn>yyerror()</prgn>.
<prgn>main()</prgn> appelle <prgn>yyparse()</prgn> qui appelle
<prgn>yylex()</prgn>, habituellement créé avec Flex.
<example>
&percnt;&percnt;

&percnt;&percnt;
</example>
</sect1>

<sect1>Autoconf
<p>
<prgn>autoconf</prgn> est un otil pour produire des scripts shell qui
configurent automatiquement les paquets de code source pour s'adapter aux
nombreux systèmes Unix qui utilisent le système de compilation GNU entier.
<p>
<prgn>autoconf</prgn> produit le script de configuration
<prgn>configure</prgn>. <prgn>configure</prgn> crée automatiquement un
<prgn>Makefile</prgn> personnalisé et <prgn>Makefile.am</prgn>.

<sect2>Compiler et installer un programme
<p>
&debian; ne touche pas aux fichiers de <file>/usr/local</file> (voir <ref
id="diverse">). Donc si vous compilez un programme depuis le source, installez
le dans <file>/usr/local</file> pour qu'il n'interfère pas avec &debian;.
<example>
$ cd src
$ ./configure --prefix=/usr/loca
$ make
$ make install # cela met les fichiers dans le système
</example>

<sect2>Désinstaller un programme
<p>
SI vous avez toujours les sources et si elles utilisent
<prgn>autoconf</prgn>/<prgn>automake</prgn> et si vous vous souvenez comment
vous avez configuré la compilation&nbsp;:
<example>
$ ./configure <var>les-options-de-configuration</var>
# make uninstall
</example>
<p>
Autrement, si vous êtes absolument sûr que le processus d'installation n'a mis
des fichiers que sous <file>/usr/local</file> et qu'il n'y a rien d'important
là, vous pouvez supprimer tout son contenu avec&nbsp;:
<example>
# find /usr/local -type f -print0 | xargs -0 rm -f
</example>
Si vous n'êtes pas sûr de l'emplacement des fichiers installés, vous devriez
considérer l'utilisation de <package>checkinstall</package> qui fournit un
moyen de désinstallation propre.
</sect1>

</sect>

<sect>Préparation de documents
<p>

<sect1>Traitement de texte <tt>roff</tt>
<p>
Traditionnellement, <tt>roff</tt> est le système de traitement de texte principal d'Unix.
<p>
Voir <manref name="roff" section="7">,
<manref name="groff" section="7">,
<manref name="groff" section="1">,
<manref name="grotty" section="1">,
<manref name="troff" section="1">,
<manref name="groff_mdoc" section="7">,
<manref name="groff_man" section="7">,
<manref name="groff_ms" section="7">,
<manref name="groff_me" section="7">,
<manref name="groff_mm" section="7">, et
«&nbsp;<tt>info groff</tt>&nbsp;».
<p>
Un bon didacticiel sur les macros <prgn>-me</prgn> existe. Si vous avez groff
(1.18 ou plus récent), cherchez le fichier <file>&f-meintro;</file> et faites
ce qui suit&nbsp;:
<example>
$ zcat &f-meintro; | \
     groff -Tascii -me - | less -R
</example>
Ce qui suit construira un fichier texte&nbsp;:
<example>
$ zcat &f-meintro; | \
    GROFF_NO_SGR=1 groff -Tascii -me - | col -b -x &gt; <var>meintro.txt</var>
</example>
Pour imprimer, utilisez la sortie PostScript.
<example>
$ groff -Tps <var>meintro.txt</var> | lpr
$ groff -Tps <var>meintro.txt</var> | mpage -2 | lpr
</example>




<sect1>SGML
<p>
Préparation&nbsp;:
<example>
# apt-get install debiandoc-sgml debiandoc-sgml-doc
</example>
Références pour <prgn>debiandoc-sgml</prgn>&nbsp;:
<list compact>
<item><file>&f-debiandoc-sgml;</file>
<item><manref name="debiandoc-sgml" section="1">
<item><em>DocBook: The Definitive Guide</em>, par Walsh et Muellner (O'Reilly)
</list>
<p>
SGML permet de gérer plusieurs formats pour un document.  Un système SGML
facile est Debiandoc, qui est utilisé ici. Cela requiert des conversions
mineurs dans le fichier texte original, pour les caractères suivants&nbsp;:
<example>
&lt;   &amp;lt;
&gt;   &amp;gt;
"&nbsp;" "&amp;nbsp;"  (espace non séquable)
&amp;   &amp;amp;
&percnt;   &amp;percnt;
&copy;   &amp;copy;
&ndash;   &amp;ndash;
&mdash;   &amp;mdash;
</example>
Pour marquer une section en tant que commentaire non imprimable, faites&nbsp;:
<example>
&lt;!-- Indiquez le problème ici ... --&gt;
</example>
Pour marquer une section en tant que commentaire ou pas à l'impression, faites&nbsp;:
<example>
&lt;![ &percnt;FIXME; [ Indiquez le problème ici ... ]]&gt;
</example>
En SGML, la <em>première définition</em> d'une entité l'emporte. Par exemple&nbsp;:
<example>
&lt;!entity &percnt; qref "INCLUDE"&gt;
&lt;![ &percnt;qref; [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
Cela termine en tant que «&nbsp;Data 1&nbsp;». Si la première ligne inclut
«&nbsp;IGNORE&nbsp;» au lieu de «&nbsp;INCLUDE&nbsp;», cela termine en tant
que «&nbsp;Data 2&nbsp;» (la deuxième ligne est une expression
conditionnelle). De plus, les phrases souvent répétées peuvent être définies à
l'avance séparément du contexte.
<example>
&lt;!entity <var>whoisthis</var> "my"&gt;
Hello &amp;<var>whoisthis</var>; friend.
This is &amp;<var>whoisthis</var>; book.
</example>
Le résultat est&nbsp;:
<example>
Hello my friend.
This is my book.
</example>
Voir le court exemple de SGML <file>sample.sgml</file> dans les <url
id="&examples;" name="exemples">.
<p>
Lorsque des documents SGML deviennent plus gros, TeX cause parfois des
erreurs. Il faut augmenter la taille du bassin dans
<file>/etc/texmf/texmf.cnf</file> (ou mieux éditez
<file>/etc/texmf/texmf.d/95NonPath</file> et lancez <prgn>update-texmf</prgn>)
pour réparer cela.
</sect>

<sect id="packaging">Paquetage
<p>
Préparation&nbsp;:
<example>
# apt-get install &p-debian-policy; &p-developers-reference; \
        &p-maint-guide; dh-make debhelper
# apt-get install packaging-manual # dans le cas de Potato
</example>
Références pour le paquetage&nbsp;:
<list compact>
 <item><ref id="pkg-basics"> (bases)
 <item>Guide des nouveaux responsables Debian (didacticiel)
 <item><manref name="dh-make" section="1">
 <item>Référence du développeur Debian (meilleure utilisation)
 <item>Charte Debian (officielle)
 <item>Manuel de paquetage (Potato)
</list>

<sect1 id="pack-binary">Paqueter un binaire seul
<p>
Méthode rapide et sale pour paqueter un binaire seul par Joey Hess.
<example>
# mkdir -p mypkg/usr/bin mypkg/DEBIAN
# cp binary mypkg/usr/bin
# cat &gt; mypkg/DEBIAN/control
Package: mypackage
Version: 1
Architecture: i386
Maintainer: Joey Hess &lt;joeyh@debian.org&gt;
Description: my little package
Don't expect much.
^D
# dpkg-deb -b mypkg
</example>

<sect1 id="pack-dh-make">Paqueter avec des outils
<p>
Utilisez <prgn>dh_make</prgn> du paquet <package>dh-make</package> pour créer
l'architecture du paquet.  Ensuite, suivez les instructions de <manref
name="dh-make" section="1">, qui utilise <prgn>debhelper</prgn> dans
<prgn>debian/rules</prgn>.
<p>
Une approche plus ancienne est d'utiliser <prgn>deb-make</prgn> du paquet
<package>debmake</package>. Cela n'utilise aucun script <prgn>debhelper</prgn>
et dépend seulement du shell.
<p>
Pour plusieurs paquets source, voir «&nbsp;mc&nbsp;» (<tt>dpkg-source -x
mc_4.5.54.dsc</tt>) qui utilise «&nbsp;sys-build.mk&nbsp;» par Adam Heath
(<email>doogie@debian.org</email>) et «&nbsp;glibc&nbsp;» (<tt>dpkg-source -x
glibc_2.2.4-1.dsc</tt>) qui utilise un autre système par feu Joel Klecker
(<email>espy@debian.org</email>).

</sect>

</chapt>
