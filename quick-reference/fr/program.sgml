<!-- CVS revision of this document "$Revision: 1.5 $"  -->
<!-- CVS revision of original english document "1.16"  -->
<chapt id="program">Programmation
<p>
N'utilisez pas "test" comme nom d'exécutable pour un fichier de test. "test"
est une commande du shell.
<sect>Où commencer
<p>
<em>Linux Programming Bible</em> (John Goerzen/IDG books)
<p>
Documents et exemples sous /usr/share/doc/&lt;packages&gt;
<p>
Beaucoup de longs documents informatifs peuvent être obtenus sur papier par
<url id="http://www.gnu.org/" name="GNU">.
<p>
Les quatres sections suivantes contiennent quelques scripts d'exemple dans
différents langages pour créer un fichier texte d'information sur les comptes
utilisateur qui peut être ajouté à /etc/passwd, avec par exemple le programme
"newusers". Chaque script prend en entrée un fichier contenant des lignes de
la forme <tt>prénom nom mot_de_passe</tt>. (Les répertoires "home" des
utilisateurs ne seront pas créés avec ces scripts.)
</sect>

<sect>BASH
<p>
<em>Learning the bash Shell</em>, 2nd edition (O'Reilly)
<example>
$ info bash
$ mc   /usr/share/doc/bash/examples/ /usr/share/doc/bash/
</example>
Example court de programme (crée un nouvel utilisateur) :
<example>
#!/bin/bash
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
pid=1000;
while read n1 n2 n3 ; do
if [ ${n1:0:1} != "#" ]; then
let pid=$pid+1
echo ${n1}_${n2}:password:${pid}:${pid}:,,,/home/${n1}_${n2}:/bin/bash
fi
done
</example>
</sect>

<sect>AWK
<p>
<em>Effective awk Programming</em>, 3rd edition, et <em>sed &amp; awk</em>,
2nd edition (O'Reilly)
<example>
$ man awk
</example>
Example court de programme (crée un nouvel utilisateur) :
<example>
#!/usr/bin/awk -f
# Script pour créer un fichier utilisable avec la commande 'newusers' à partir
# d'un fichier contenant des IDs utilisateur et des mots de passe sous la
# forme :
# Prénom Nom Mot_de_passe
# Copyright (c) KMSelf Sat Aug 25 20:47:38 PDT 2001
# Distributed under GNU GPL v 2, or at your option, any later version.
# This program is distributed WITHOUT ANY WARRANTY.

BEGIN {
    # Assign starting UID, GID
    if ( ARGC &gt; 2 ) {
	startuid = ARGV[1]
	delete ARGV[1]
    }
    else {
        printf( "Usage:  newusers startUID file\n" \
	  "...where startUID is the starting userid " \
	  "to add, and file is \n" \
	  "an input file in form firstname last name password\n" \
	)
	exit
    }

    infile = ARGV[1]
    printf( "Starting UID: %s\n\n", startuid )
}

/^#/ { next }

{
    ++record
    first = $1
    last = $2
    passwd = $3
    user= substr( tolower( first ), 1, 1 ) tolower( last )
    uid = startuid + record - 1
    gid = uid
    printf( "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n",  \
	user, passwd, uid, gid, first, last, user \
	)
}
</example>
</sect>

<sect>PERL
<p>
<em>Programming Perl</em>, 3rd edition (O'Reilly)
<example>
$ man perl
</example>
Example court de programme (crée un nouvel utilisateur) :
<example>
#!/usr/bin/perl
# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
$pid=1000;
while (&lt;STDIN&gt;) {
	if (/^#/) { next;}
        chop;
        $pid++;
        ($n1, $n2, $n3) = split / /;
        print $n1,"_",$n2,":", $n3, ":",$pid,
                  ":",$pid,",,,/home/",$n1,"_",$n2,":/bin/bash\n"
}
</example>
<p>
Installer le module Perl &lt;module name&gt; :
<example>
# perl -MCPAN -e 'install &lt;module name&gt;'
</example>
 
</sect>

<sect>PYTHON
<p>
<em>Learning Python</em> (O'Reilly).
C'est un interpréteur sympa.
<example>
$ man python
</example>
Example court de programme (crée un nouvel utilisateur) :
<example>
#! /usr/bin/env python
import sys, string

# (C) Osmu Aoki Sun Aug 26 16:53:55 UTC 2001 Public Domain
# Ported from awk script by KMSelf Sat Aug 25 20:47:38 PDT 2001
# This program is distributed WITHOUT ANY WARRANTY.

def usages():
    print \
"Usage:  ", sys.argv[0], " start_UID [filename]\n" \
"\tstartUID is the starting userid to add.\n" \
"\tfilename is input file name. If not specified, standard input.\n\n" \
"Input file format:\n"\
"\tfirstname lastname password\n"
		return 1

def parsefile(startuid):
    #
    # main filtering
    #
    uid = startuid
    while 1:
        line = infile.readline()
        if not line:
            break
        if line[0] == '#':
            continue
        (first, last, passwd) = string.split(string.lower(line))
        # above crash with wrong # of parameters :-)
        user = first[0] + last
        gid = uid
        lineout = "%s:%s:%d:%d:%s %s,,/home/%s:/bin/bash\n" %  \
            (user, passwd, uid, gid, first, last, user)
        sys.stdout.write(lineout)
        +uid

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usages()
    else:
        uid = int(sys.argv[1])
        #print "# UID start from: %d\n" % uid
        if len(sys.argv) &gt; 1:
            infilename   = string.join(sys.argv[2:])
            infile = open(infilename, 'r')
            #print "# Read file from: %s\n\n" % infilename
        else:
            infile = sys.stdin
        parsefile(uid)
</example>
</sect>

<sect>MAKE
<p>
<em>Managing Projects with make</em>, 2nd edition (O'Reilly)
<example>
$ info make
</example>
Variables automatiques simples :
<p>
Syntaxe des règles :
<example>
Cible: [ Prérequis ... ]
&lt; TAB &gt; command1
&lt; TAB &gt; -command2 # peut générer une erreur
&lt; TAB &gt; @command3 # pas d'echo
</example>
Chaque ligne est interprétée par le shell après la substitution des variables
par make.
Utiliser "\" à la fin d'une ligne pour continuer le script.
Utiliser "$$" pour entrer "$" pour les variables d'environnement du script
shell.
<p>
Equivalents des règles iplicites :
<example>
.c:   header.h == %  : %.c header.h
.o.c: header.h == %.c: %.o header.h
</example>
Variables automatiques pour les règles ci-dessus :
<example>
foo.o: new1.c new2.c.c old1.c new3.c
$@ == foo.o                         (cible)
$< == new1.c                        (premier)
$? == new1.c new2.c new3.c          (plus récent)
$^ == new1.c new2.c.c old1.c new3.c (tout)
$* == `%' motif correspondant dans le motif cible.
</example>
Référence des variables :
<example>
foo1 := bar    # expansion unique
foo2  = bar    # expansion récursive
foo3 += bar    # ajoute
SRCS := $(wildcard *.c)
OBJS := $(foo:c=o)
OBJS := $(foo:%.c=%.o) 
OBJS := $(patsubst %.c,%.o,$(foo)) 
DIRS  = $(dir directory/filename.ext) # Extrait "directory"
$(notdir NAMES...), $(basename NAMES...), $(suffix NAMES...) ...
</example>
Exécuter "make -p -f/dev/null" pour voir les règles internes automatiques.
</sect>

<sect>C
<p>
Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 2nd edition
(Prentice Hall).
Pour obtenir la référence de la bibliothèque C GNU :
<example>
# apt-get install glibc6-doc manpages-dev
</example>
Pour lire la référence de la bibliothèque C GNU, utilisez "<prgn>info
libc</prgn>".
Pour chaque fonction, "printf" par exemple, utilisez "<prgn>man 3
printf</prgn>".

<sect1>Programme simple en C (gcc)
<p>
Un exemple simple pour compiler "example.c" avec la bibliothèque "libm" dans
l'exécutable "run_example" :
<example>
$ cat exmple.c 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv, char **envp){
	double x;
	char y[11];
	x=sqrt(argc+7.5);
	strncpy(y, argv[0], 10); /* prevent buffer overflow */
	y[10] = '\0'; /* fill to make sure end with '\0' */
	printf("%5i, %5.3f, %10s, %10s\n", argc, x, y, argv[1]);
	return 0;
}

$ gcc -Wall -g -o run_example exmple.c -lm
$ ./run_example
    1, 2.915, ./run_exam,     (null)
$ ./run_example 1234567890qwerty
    2, 3.082, ./run_exam, 1234567890qwerty
</example>
Ici, "-l<em>m</em>" est nécessaire pour lier la bibliothèque "lib<em>m</em>",
pour utiliser sqrt(). La bibliothèque est en fait dans "/lib" avec le nom
"libm.so.6" qui est un lien symbolique vers "libm-2.1.3.so".
<p>
Regardez le dernier paramètre dans le texte imprimé. Il y a plus de 10
caractères imprimés alors que "%10s" est spécifié.
<p>
L'utilisation de fonctions effectuant des opérations sur des pointeurs sans
vérifier la limite, comme sprintf et strcpy, est dépréciée pour prévenir les
exploits de dépassement de buffer, annulant les effets ci-dessus. Utilisez
snprintf et strncpy à la place.
</sect1>

<sect1>Déboguer (gdb)
<p>
<url id="http://www.dirac.org/linux/gdb" name="Didacticiel GDB"> (NdT : en
Anglais)
<p>
Utilisez gdb pour déboguer des programmes compilés avec l'option -g.
Beaucoup de commandes peuvent être abbréviées. L'expansion par tab marche
comme avec le shell.
<example>
$ info gdb
...
$ gdb program
(gdb) b 1                # positionne un point d'arrêt à la ligne 1
(gdb) run arg1 arg2 arg3 # exécute le programme
(gdb) next               # ligne suivante
...
(gdb) step               # pas en avant
...
(gdb) p parm             # affiche parm
...
(gdb) p parm=12          # met la valeur de parm à 12
</example>
Pour déboguer depuis emacs, référez-vous à <ref id="editkey">.
</sect1>

<sect1>Flex &ndash; un meilleur Lex
<p>
Vous devez fournir vos propre main() et yywrap(), ou votre programme. Il ne
devrait pas y avoir besoin de bibliothèque pour compiler. (yywrap est une
MACRO)
("%option main" active "%option noyywrap" implicitement) :
<example>
%option main
%%
.|\n	ECHO ;
%%
</example>
Autrement, vous pouvez compiler avec l'option du linker -l<em>fl</em> à la fin
de la ligne de commande de cc, comme ATT-Lex avec -l<em>l</em> (pas de %option
nécessaire).
</sect1>

<sect1>Bison &ndash; un meilleur Yacc
<p>
Vous devez fournir vos propres main() et yyerror(). main() appelle yyparse()
qui appelle yylex(), habituellement créé avec Flex.
<example>
%%

%%
</example>
</sect1>

<sect1>Autoconf &ndash; uninstall
<p>
SI vous avez toujours les sources et SI elles utilisent autoconf/automake et
SI vous vous souvenez comment vous avez configuré la compilation :
<example>
$ ./configure les-options-de-configuration
# make uninstall
</example>
</sect1>

</sect>

<sect>SGML
<p>
Un moyen de gérer plusieurs formats pour un document est SGML. Un SGML plus
facile est offert avec debiandoc, qui est utilisé ici. Cela requiert des
conversions mineurs dans le fichier texte original, pour les caractères
suivants :
<example>
&lt;   &amp;lt;
&gt;   &amp;gt;
&amp;   &amp;amp;
&copy;   &amp;copy;
&ndash;   &amp;ndash;
&mdash;   &amp;mdash;
</example>
Pour marquer une section en tant que commentaire non imprimable, faites :
<example>
&lt;!-- State issue here ... --&gt;
</example>
Pour marquer une section en tant que commentaire ou pas à l'impression, faites
:
<example>
&lt;![ %FIXME [ State issue here ... ]]&gt;
</example>
En SGML, la <em>première définition</em> d'une entité l'emporte. Par exemple :
<example>
&lt;!entity % qref "INCLUDE"&gt;
&lt;![ %qref [ &lt;!entity param "Data 1"&gt; ]]&gt;
&lt;!entity param "Data 2"&gt;
&amp;param;
</example>
Cela termine en tant que "Data 1". Si la première ligne inclut "IGNORE" au
lieu de "INCLUDE", cela termine en tant que "Data 2" (la deuxième ligne est
conditionnelle).
<p>
Pour plus de détails, faites "<prgn>apt-get install
debiandoc-sgml-doc</prgn>". Lisez aussi <em>DocBook: The Definitive
Guide</em>, by Walsh and Muellner (O'Reilly).
</sect>

<sect>Paquetage
<p>
Lisez la documentation fournie dans le paquet "packaging-manual" (Potato) ou
"debian-policy" (Woody).
<p>
Utilisez dh_make dans le paquet dh-help pour créer l'architecture du paquet.
Ensuite, suivez les instructions de "<prgn>man dh_make</prgn>", qui utilise
debhelper dans debian/rulers.
<p>
Une autre approche est d'utiliser deb-make dans le paquet debmake. Cela
n'utilise aucun script debhelper et dépend seulement du shell.
<p>
Pour plusieurs paquets source, voir "mc" (dpkg-source -x mc_4.5.54.dsc) qui
utilise "sys-build.mk" par Adam Heath &lt;doogie@debian.org&gt; et "glibc"
(dpkg-source -x glibc_2.2.4-1.dsc) qui utilise un autre système par Joel
Klecker &lt;espy@debian.org&gt;.
</sect>

</chapt>
