<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % shareddata   SYSTEM "../release-notes.ent" > %shareddata;
]>

<!-- English version: 8568 -->
<!-- Translators: Felipe Augusto van de Wiel <faw@debian.org>, -2009. -->
<!--              Marcelo Gomes de Santana <marcgsantana@yahoo.com.br, 2011. -->
<!-- Revisors: Chanely Marques <chanelym@gmail.com>, 2011 -->
<!-- Brazilian l10n team <debian-l10n-portuguese@lists.debian.org> -->

<chapter id="ch-upgrading" lang="pt_BR">
<title>Atualizações a partir do Debian &oldrelease; (&oldreleasename;)</title>
<section id="backup">
<title>Preparando para a atualização</title>
<para>
Nós sugerimos que antes de atualizar você também leia as informações em
<xref linkend="ch-information"/>. Este capítulo aborda potenciais problemas
que não estão diretamente relacionados ao processo de atualização, mas que
ainda podem ser importantes conhecer antes que você comece.
</para>
<section id="data-backup">
<title>Faça backup de quaisquer dados ou informações de configuração</title>
<para>
Antes de atualizar o seu sistema, é fortemente recomendado que você faça um
backup completo ou, pelo menos, faça backup de quaisquer dados ou informações
de configuração que você não possa perder. As ferramentas de atualização e
o processo são bastante confiáveis, mas uma falha de hardware no meio de uma
atualização pode resultar em um sistema severamente danificado.
</para>
<para>
As principais coisas que você terá que fazer backup são os conteúdos do
<filename>/etc</filename>, <filename>/var/lib/dpkg</filename>,
<filename>/var/lib/apt/extended_states</filename> e a saída do
<literal>dpkg --get-selections "*"</literal> (as aspas são importantes).
Se você utiliza o <command>aptitude</command> para gerenciar pacotes em
seu sistema, você também terá que fazer backup do
<filename>/var/lib/aptitude/pkgstates</filename>.
</para>
<para>
O processo de atualização em si não modifica nada no diretório
<filename>/home</filename>. No entanto, alguns aplicativos (ex. partes
da suíte Mozilla e os ambientes de área de trabalho GNOME e KDE) são
conhecidos por sobrescrever as configurações existentes dos usuários
com novos padrões, quando uma nova versão do aplicativo é iniciada pela
primeira vez por um usuário. Como precaução, você pode fazer um backup
dos arquivos e diretórios ocultos (<quote>dotfiles</quote>) nos diretórios
home dos usuários. Esse backup pode ajudar a recuperar ou recriar antigas
configurações. Você também pode informar os usuários sobre isso.
</para>
<para>
Qualquer operação de instalação de pacote deve ser executada com privilégios
de superusuário, para isso, faça login como <literal>root</literal> ou
use o <command>su</command> ou o <command>sudo</command> para obter
os direitos de acesso necessários.
</para>
<para>
A atualização possui algumas pré-condições; você deve verificá-las antes
de começar a executar a atualização.
</para>
</section>

<section id="inform-users">
<title>Avise os usuários com antecedência</title>
<para>
É sensato informar a todos os usuários com antecedência sobre qualquer
atualização que você esteja planejando, embora os usuários que acessem o seu
sistema via uma conexão <command>ssh</command> pouco devam notar durante a
atualização, e devam ser capazes de continuar trabalhando. 
</para>
<para>
Se você desejar tomar precauções extras, faça backup ou desmonte a partição
<filename>/home</filename> antes de atualizar.
</para>
<para>
Você terá que fazer uma atualização de kernel quando atualizar para o
&releasename;, então, uma reinicialização será necessária. 
<!-- Not for Squeeze: 
Typically, this will be done after the upgrade is finished. -->
</para>
</section>

<!-- Based on information/complains from upgrade-reports, such as #602797 -->
<section id="services-downtime">
<title>Prepare-se para a indisponibilidade dos serviços</title>

<para>
Poderão haver serviços que são oferecidos pelo sistema, que estão associadas
aos pacotes que serão incluídos na atualização. Se esse for o caso, por favor,
note que, durante a atualização, esses serviços serão interrompidos enquanto os
seus pacotes associados estão sendo substituídos e configurados. Durante esse
tempo, esses serviços não estarão disponíveis.
</para>

<para>
O tempo exato de indisponibilidade desses serviços irá variar dependendo do
número de pacotes sendo atualizados no sistema, e isso também inclui o tempo
no qual o administrador do sistema responde às perguntas de configuração
das diferentes atualizações de pacotes (se existirem). Observe que, se o
processo de atualização for deixado sem acompanhamento e o sistema solicitar
uma entrada ao longo da atualização, existe uma grande possibilidade dos
serviços ficarem indisponíveis<footnote><para>Se a prioridade do debconf
estiver configurada em um nível muito alto você pode evitar o avisos de
configuração, mas os serviços que dependem de respostas predefinidas,
que não são aplicáveis aos seu sistema, irão falhar ao iniciar.
</para></footnote> por um período significativo de tempo.
</para>

<para>
Se o sistema que estiver sendo atualizado fornecer serviços críticos aos
seus usuários ou à rede<footnote><para>Por exemplo: serviços de DNS ou DHCP,
especialmente quando não há redundância ou substituto em caso se falha
(<quote>failover</quote>). No caso do DHCP, os usuários finais poderão ser
desconectados da rede se o tempo de concessão (<quote>lease time</quote>) for
menor do que o tempo que leva para completar o processo de atualização.</para>
</footnote>, você pode reduzir o tempo de indisponibilidade se fizer uma
atualização mínima do sistema, como descrita em
<xref linkend="minimal-upgrade"/>, seguida de uma atualização do kernel e
reinicialização (veja <xref linkend="upgrading-udev"/>), e então atualizar
os pacotes associados aos seus serviços críticos. Atualize esses pacotes
antes de fazer a atualização completa descrita em
<xref linkend="upgrading-full"/>. Dessa forma, você pode garantir que esses
serviços essenciais estejam funcionando e disponíveis durante o processo
de atualização completa, e o seu tempo de indisponibilidade será reduzido.
</para>

</section>

<section id="recovery">
<title>Preparar para recuperação</title>
<para>
Por conta das inúmeras mudanças no kernel entre o &oldreleasename; e o
&releasename; relativas a drivers, descoberta de hardware e a nomeação e
ordenamento de arquivos de dispositivo, existe um risco real de você ter
problemas ao reinicializar o seu sistema após a atualização. Muitos problemas
possíveis conhecidos são documentados neste e nos próximos capítulos destas
Notas de Lançamento.
</para>
<para>
Por essa razão faz sentido garantir que você seja capaz de recuperar
o seu sistema caso não consiga reinicializar ou, para sistemas gerenciados
remotamente, não conseguir levantar a rede.
</para>

<!-- FIXME: Is there a risk in Lenny for this to happen? -->
<!-- Another option would be an automatic reboot to a previous kernel using
Davor Ocelic's testnet script or similar --> 
<para>
Se você estiver atualizando remotamente através de um link <command>ssh</command>
é altamente recomendado que você tome as precauções necessárias para ser capaz
de acessar o servidor por meio de um terminal serial remoto. Existe uma chance
de que, após atualizar o kernel e reinicializar, alguns dispositivos sejam
renomeados (como descrito em <xref linkend="device-reorder"/> ) e você tenha
que corrigir a configuração do sistema por meio de um console local. Além disso,
se o sistema for reinicializado acidentalmente no meio de uma atualização,
existe uma chance de que precise recuperá-lo usando um console local.
</para>
<!-- FIXME: The next paragraph might not be true for Lenn? -->
<para>
A coisa mais óbvia a tentar primeiro é reinicializar com seu kernel antigo.
Entretanto, por várias razões documentadas em outro lugar neste documento,
não é garantido que isso funcione.
</para>
<para>
Se isso falhar, você precisará de uma forma alternativa de inicializar seu
sistema, e assim poder acessá-lo e repará-lo. Um opção é usar uma imagem
especial de recuperação ou um live CD de Linux. Após a inicialização a partir
dele, você deverá ser capaz de montar o seu sistema de arquivos raiz e fazer
<literal>chroot</literal> nele para investigar e corrigir o problema.
</para>

<!-- FIXME: Consider putting this option first, as it should be the
recommended rescue method -->
<para>
Outra opção que nós gostaríamos de recomendar é usar o <emphasis>modo de
recuperação</emphasis> do Instalador Debian do &releasename;. A vantagem de
usar o instalador é que você pode escolher, entre os seus vários métodos de
instalação, aquele que melhor se adéqua à sua situação. Para mais informações,
por favor, consulte a seção <quote>Recuperando um Sistema Quebrado</quote> no
capítulo 8 do <ulink url="&url-install-manual;">Guia de Instalação</ulink> e
a <ulink url="&url-wiki;DebianInstaller/FAQ">FAQ do Instalador Debian</ulink>.
</para>
<section id="recovery-initrd">
<title>Terminal de depuração durante a inicialização usando initrd</title>
<para>
O <systemitem role="package">initramfs-tools</systemitem> inclui um terminal
de depuração<footnote><para> Esse recurso pode ser desabilitado adicionando
o parâmetro <literal>panic=0</literal> aos seus parâmetros de inicialização.
</para> </footnote> nas initrds que ele gera. Se por exemplo a initrd for
incapaz de montar o seu sistema de arquivos raiz, você será deixado nesse 
terminal de depuração que tem comandos básicos disponíveis para ajudar a 
rastrear o problema e possivelmente corrigi-lo.
</para>
<para>
Coisas básicas a serem verificadas: presença dos arquivos de dispositivo
corretos em <filename>/dev</filename>; quais módulos estão carregados
(<literal>cat /proc/modules</literal>); saída do <command>dmesg</command>
com erros de carregamento de drivers. A saída do <command>dmesg</command>
também exibirá que arquivos de dispositivo foram associados a quais discos;
você deve verificar isso com a saída do <literal>echo $ROOT</literal> para
certificar-se que o sistema de arquivos raiz está no dispositivo esperado.
</para>
<para>
Se você conseguir resolver o problema, digitando <literal>exit</literal> irá
deixar o terminal de depuração e continuar o processo de inicialização do
ponto em que falhou. Claro que você também precisará corrigir o problema
básico e gerar novamente a initrd, pois assim, a próxima inicialização não
falhará novamente.
</para>
</section>

</section>

<section id="upgrade-preparations">
<title>Preparar um ambiente seguro para a atualização</title>
<para>
A atualização da distribuição deve ser feita localmente, a partir de um
console virtual em modo texto (ou um terminal serial conectado diretamente),
ou remotamente através de um link <command>ssh</command>. 
</para>
<important>
  <para>
  Se você estiver usando alguns serviços VPN (tal como <systemitem
  role="package">tinc</systemitem>) eles podem não estar disponíveis
  ao longo do processo de atualização. Por favor, veja 
  <xref linkend="services-downtime"/>.
  </para>
</important>
<para>
A fim de conseguir uma margem extra de segurança quando atualizar remotamente,
nós sugerimos que você execute o processo de atualização no console virtual
fornecido pelo programa <command>screen</command>, que permite uma reconexão
segura e garante que o processo de atualização não seja interrompido mesmo
se o processo de conexão remota falhar.
</para>
<important>
  <para>
    Você <emphasis>não</emphasis> deve atualizar utilizando <command>telnet</command>,
    <command>rlogin</command>, <command>rsh</command>, ou a partir de uma sessão X
    gerenciada por <command>xdm</command>, <command>gdm</command>
    ou <command>kdm</command>, etc, na máquina que você estiver atualizando.
    Isso é porque cada um desses serviços pode muito bem ser terminado 
    durante a atualização, o que pode resultar em um sistema
    <emphasis>inacessível</emphasis> que está apenas parcialmente atualizado.
    O uso do aplicativo <command>update-manager</command> do GNOME é
    <emphasis>fortemente des-recomendado</emphasis> para atualizações para novas
    versões, pois essa ferramenta precisa que a sessão da área de trabalho
    se mantenha ativa.
  </para>
</important>

<programlisting condition="fixme">
TODO: surely gdm/kdm are sane?
(vorlon) haha, no, gdm is not; I had that thought, and tested a gdm
         restart on my live session ;)
</programlisting>

</section>

<section id="purge-splashy">
<title>Remover pacotes conflitantes</title>
<para>
Devido ao bug <ulink url="&url-bts;512951">#512951</ulink>, o pacote <systemitem
role="package">splashy</systemitem> precisa ser expurgado antes da atualização.
<screen>
# apt-get purge splashy
</screen>
</para>
</section>

</section>

<section id="system-status">
<title>Verificando o estado do sistema</title>
<para>
O processo de atualização descrito neste capítulo foi idealizado para
atualizações a partir de sistemas &oldreleasename; <quote>puros</quote>
sem pacotes de terceiros. Para uma maior confiabilidade do processo de
atualização, você pode remover pacotes de terceiros do seu sistema antes
de começar a atualização.
</para>
<para>
Atualizações diretas a partir de versões mais antigas do que a &oldrelease;
(&oldreleasename;) não são suportadas.
Por favor, sigas as instruções nas <ulink
url="http://www.debian.org/releases/&oldreleasename;/releasenotes">Notas
de Lançamento para &debian; &oldrelease;</ulink> para atualizar para &oldrelease;
primeiro.
</para>
<para>
Esse procedimento também assume que o seu sistema foi atualizado para a versão
pontual mais recente do &oldreleasename;. Se você não tiver feito isso ou
estiver inseguro, siga as instruções em <xref linkend="old-upgrade"/>.
</para>

<section id="review-actions">
<title>Rever as ações pendentes no gerenciador de pacotes</title>
<para>
Em alguns casos, o uso do <command>apt-get</command> para instalação de pacotes,
ao invés do <command>aptitude</command>, pode fazer o <command>aptitude</command>
considerar um pacote como <quote>não usado</quote> e agendá-lo para remoção. Em
geral, você deve certificar-se que o sistema está totalmente atualizado e 
<quote>limpo</quote> antes de proceder com a atualização.
</para>
<para>
Por causa disso, você deve rever se existem quaisquer ações pendentes no
gerenciador de pacotes <command>aptitude</command>. Se um pacote estiver agendado
para remoção ou atualização no gerenciador de pacotes, ele pode impactar
negativamente no procedimento de atualização. Note que para corrigir isso só
é possível se o seu <filename>sources.list</filename> ainda apontar para
o <emphasis>&oldreleasename;</emphasis> e não para <emphasis>stable</emphasis>
ou <emphasis>&releasename;</emphasis>; veja <xref
linkend="old-sources"/>.
</para>
<para>
Para fazer esta revisão, inicie o <command>aptitude</command> em <quote>modo visual</quote> e
pressione <keycap>g</keycap> (<quote>Go</quote>). Se ele mostrar quaisquer ações, você
deve revê-las e corrigi-las ou implementar as ações sugeridas. Se nenhuma ação for
sugerida será apresentada uma mensagem dizendo <quote>Nenhum pacote está agendado
para ser instalado, removido ou atualizado</quote>.
</para>
</section>

<section id="disable-apt-pinning">
<title>Desabilitando o APT pinning</title>
<para>
Se você tiver configurado o APT para instalar determinados pacotes a partir de
uma distribuição diferente da stable (ex. da testing), você pode ter que mudar
sua configuração de APT pinning (guardada em <filename>/etc/apt/preferences</filename>)
para permitir a atualização dos pacotes para as versões existentes na nova versão
stable. Maiores informações sobre APT pinning podem ser encontradas em <citerefentry>
<refentrytitle>apt_preferences</refentrytitle> <manvolnum>5</manvolnum>
</citerefentry>.
</para>
</section>

<section id="package-status">
<title>Verificando o estado dos pacotes</title>
<para>
Independentemente do método usado para atualização, é recomendado que você
primeiro verifique o estados de todos, e verifique se todos estão em um estado
atualizável. O seguinte comando irá exibir quaisquer pacotes que tenham um
estado de <quote>Half-Installed</quote> ou <quote>Failed-Config</quote>, e
aqueles com algum estado de erro.
</para>
<screen>
# dpkg --audit
</screen>
<para>
Você também pode inspecionar o estado de todos os pacotes em seu sistema usando
<command>dselect</command>, <command>aptitude</command>, ou com comandos como:
</para>
<screen>
# dpkg -l | pager
</screen>
<para>
ou
</para>
<screen>
# dpkg --get-selections "*" &gt; ~/curr-pkgs.txt
</screen>
<para>
É desejável remover quaisquer retenções (holds) em pacotes antes da atualização.
Se qualquer pacote que seja essencial para a atualização estiver retido, a
atualização irá falhar.
</para>
<para>
Note que o <command>aptitude</command> usa um método para registrar os pacotes
que estão retidos diferente do <command>apt-get</command> e do
<command>dselect</command>. Você pode identificar pacotes retidos
pelo <command>aptitude</command> com
</para>
<screen>
# aptitude search "~ahold"
</screen>
<para>
Se você quiser verificar quais pacotes você tem retidos pelo
<command>apt-get</command>, você deve usar
</para>
<screen>
# dpkg --get-selections | grep hold
</screen>
<para>
Se você alterou e recompilou um pacote localmente, e não o renomeou ou
colocou uma época na versão, você deve colocá-lo em retenção para evitar que
seja atualizado.
</para>
<para>
O estado do pacote em <quote>hold</quote> pelo <command>apt-get</command> pode
ser alterado usando:
</para>
<screen>
# echo <replaceable>package_name</replaceable> hold | dpkg --set-selections
</screen>
<para>
Substitua <literal>hold</literal> por <literal>install</literal> para remover o
o estado de <quote>hold</quote>.
</para>
<para>
Se existir alguma coisa que você precisa corrigir, é melhor certificar-se que
o seu <filename>sources.list</filename> ainda se refere a &oldreleasename; como
explicado em <xref linkend="old-sources"/>.
</para>
</section>

<section id="proposed-updates">
  <title>A seção <quote>proposed-updates</quote></title>
  <para>
    Se você tiver a seção <quote><literal>proposed-updates</literal></quote>
    presente no seu arquivo <filename>/etc/apt/sources.list</filename> , você
    deve removê-la desse arquivo antes de tentar atualizar o seu
		sistema. Essa é uma precaução para reduzir a probabilidade de
		conflitos.
  </para>
</section>

<!-- FIXME: REVIEW for Squeeze this was written for Lenny - drop? (jfs) -->
<section id="userbackports">
<title>Fontes não oficiais e <quote>backports</quote></title>
<para>
Se você tiver quaisquer pacotes não-Debian no seu sistema, você deve estar
ciente de que esses podem ser removidos durante a atualização por causa de
de dependências conflitantes. Se esses pacotes foram instalados pela adição
de um repositório extra no seu <filename>/etc/apt/sources.list</filename>,
você deve verificar se esse repositório também oferece pacotes compilados
para o &releasename; e alterar a linha da fonte de acordo, ao mesmo tempo,
assim como suas linhas dos fontes (src) para os pacotes Debian.
</para>
<para>
Alguns usuários podem ter versões <quote>backported</quote> (atualizadas
retroativamente) <quote>mais novas</quote> não-oficiais dos pacotes que
<emphasis>estão</emphasis> no Debian instaladas no seu sistema &oldreleasename;.
Tais pacotes são mais prováveis de causar problemas durante a atualização,
pois podem resultar em conflitos de arquivo<footnote><para> O sistema de
gerenciamento de pacotes do Debian normalmente não permite que um pacote
remova ou atualize um arquivo pertencente a outro pacote, a menos que tenha
sido definido para substituir esse pacote. </para> </footnote>.
Em <xref linkend="trouble"/> existem algumas informações de como lidar com
conflitos de arquivos se eles ocorrerem.
</para>

</section>

</section>

<section id="upgrade-process">
<title>Preparando as fontes para o APT</title>
<para>
Antes de iniciar a atualização você deve ajustar as listas de pacote no
arquivo de configuração do <systemitem role="package">apt</systemitem>,
o <filename>/etc/apt/sources.list</filename>.
</para>
<para>
O <systemitem role="package">apt</systemitem> irá considerar todos os
pacotes que possam ser encontrados através de qualquer linha iniciada por
<quote><literal>deb</literal></quote>, e irá instalar o pacote com o número
de versão mais elevado, dando prioridade à primeira linha do arquivo
(assim, onde você tiver múltiplas localizações de espelhos, normalmente
indicará primeiro um disco rígido, depois o <acronym>CD-ROM</acronym>s,
e então os espelhos HTTP/FTP).
</para>

<para>
Uma versão pode frequentemente ser referida tanto pelo seu codinome (ex.
<literal>&oldreleasename;</literal>, <literal>&releasename;</literal>) como 
pelo seu nome de estado (i.e. <literal>oldstable</literal>, <literal>stable</literal>,
<literal>testing</literal>, <literal>unstable</literal>). Referir-se a uma
uma versão pelo seu codinome tem a vantagem que você nunca será surpreendido
por uma nova versão, e por essa razão a abordagem é adotada aqui. Isso
significa certamente que você mesmo terá que ficar atento aos anúncios de
lançamento. Se ao invés disso você usar o nome de estado, verá apenas o
carregamento das atualizações dos pacotes disponíveis assim que um lançamento
acontecer.
</para>

<section id="network">
<title>Adicionar fontes da Internet ao APT</title>
<para>
A configuração padrão é definida para instalação a partir dos principais
servidores do Debian na Internet, mas você pode querer modificar o
<filename>/etc/apt/sources.list</filename> para usar outros espelhos,
preferencialmente um espelho que esteja localizado o mais próximo de você.
</para>
<para>
Os endereços dos espelhos HTTP ou FTP do Debian podem ser encontrados em <ulink
url="&url-debian-mirrors;"></ulink> (veja na seção <quote>lista de espelhos do
Debian</quote>). Espelhos HTTP geralmente são mais rápidos do que espelhos FTP.
</para>
<para>
Por exemplo, suponha que seu espelho Debian mais próximo seja
<literal>&url-debian-mirror-eg;</literal>. Quando examinar esse espelho
com um navegador web ou programa de FTP, você notará que o diretório
principal está organizado assim:
</para>
<programlisting>
&url-debian-mirror-eg;/debian/dists/&releasename;/main/binary-&architecture;/...
&url-debian-mirror-eg;/debian/dists/&releasename;/contrib/binary-&architecture;/...
</programlisting>
<para>
Para usar esse espelho com o <systemitem role="package">apt</systemitem>, você adiciona esta
linha ao seu arquivo <filename>sources.list</filename>:
</para>
<programlisting>deb &url-debian-mirror-eg;/debian &releasename; main contrib</programlisting>
<para>
Note que o `<literal>dists</literal>' é adicionado implicitamente, e os argumentos após
o nome da versão são usados para expandir o caminho em múltiplos diretórios.
</para>
<para>
Após adicionar suas novas fontes, desabilite as linhas <quote><literal>deb</literal></quote>
já existentes em <filename>sources.list</filename> pondo um sinal de
cerquilha (<literal>#</literal>) no início delas.
</para>
</section>

<section id="localmirror">
<title>Adicionando fontes ao APT para um espelho local</title>
<para>
Ao invés de usar espelhos de pacotes HTTP ou FTP, você pode querer modificar
o <filename>/etc/apt/sources.list</filename> para usar um espelho em um disco
local (possivelmente montado sobre <acronym>NFS</acronym>).
</para>
<para>
Por exemplo, seu espelho de pacotes pode estar sob
<filename>/var/ftp/debian/</filename>, e ter diretórios principais assim:
</para>
<programlisting>
/var/ftp/debian/dists/&releasename;/main/binary-&architecture;/...
/var/ftp/debian/dists/&releasename;/contrib/binary-&architecture;/...
</programlisting>
<para>
Para usar esse com o <systemitem role="package">apt</systemitem>, adicione esta linha ao seu
arquivo <filename>sources.list</filename>:
</para>
<programlisting>deb file:/var/ftp/debian &releasename; main contrib</programlisting>
<para>
Note que o `<literal>dists</literal>' é adicionado implicitamente, e os argumentos após
o nome da versão são usados para expandir o caminho em múltiplos diretórios.
</para>
<para>
Após adicionar suas novas fontes, desabilite as linhas <quote><literal>deb</literal></quote>
já existentes em <filename>sources.list</filename> pondo um sinal de
cerquilha (<literal>#</literal>) no início delas.
</para>
</section>

<section id="cdroms">
<title>Adicionando fontes ao APT a partir de um CD-ROM ou DVD</title>
<para>
Se você quiser usar <emphasis>apenas</emphasis> CDs, comente as linhas <quote><literal>deb</literal></quote>
já existentes em <filename>/etc/apt/sources.list</filename> pondo
um sinal de cerquilha (<literal>#</literal>) no início delas.
</para>
<para>
Certifique-se de que existe uma linha em <filename>/etc/fstab</filename> que habilite
a montagem do seu drive de CD-ROM no ponto de montagem <filename>/cdrom</filename>
(o ponto de montagem <filename>/cdrom</filename> certo é requerido pelo
<command>apt-cdrom</command>). Por exemplo, se <filename>/dev/hdc</filename>
for seu drive de CD-ROM, o <filename>/etc/fstab</filename> deve conter uma linha
como:
</para>
<programlisting>
/dev/hdc /cdrom auto defaults,noauto,ro 0 0
</programlisting>
<para>
Note que não deve haver <emphasis>nenhum espaço</emphasis> entre as palavras
<literal>defaults,noauto,ro</literal> no quarto campo.
</para>
<para>
Para verificar se funciona, insira um CD e tente executar
</para>
<screen>
# mount /cdrom    # isso montará o CD no ponto de montagem
# ls -alF /cdrom  # isso deve exibir o diretório raiz do CD
# umount /cdrom   # isso desmontará o CD
</screen>
<para>
Depois, execute:
</para>
<screen>
# apt-cdrom add
</screen>
<para>
para cada CD-ROM com arquivos executáveis do Debian que você tiver, para
adicionar os dados a respeito de cada CD à base de dados do APT.
</para>
</section>

</section>

<section id="upgradingpackages">
<title>Atualizando pacotes</title>
<para>
A forma recomendada para atualizar a partir de versões anteriores do &debian; é
usar a ferramenta de gerenciamento de pacotes <command>apt-get</command>. Nos
lançamentos anteriores, o <command>aptitude</command> era recomendado para esse
propósito, mas as versões recentes do <command>apt-get</command> fornecem uma
funcionalidade equivalente e também têm se mostrado mais coerentes nos
resultados obtidos nas atualizações.
</para>
<para>
Não esqueça de montar todas as partições necessárias (especialmente as partições
raiz e <filename>/usr</filename>) com permissões de leitura e escrita, com
um comando como:
</para>
<screen>
# mount -o remount,rw /<replaceable>ponto-de-montagem</replaceable>
</screen>
<para>
Em seguida você deve confirmar novamente se as entradas das fontes do APT (em
<filename>/etc/apt/sources.list</filename>) referem-se tanto ao
<quote><literal>&releasename;</literal></quote> quanto ao <quote><literal>stable</literal></quote>. Não devem
haver quaisquer entradas de fontes que apontem para o &oldreleasename;.
<note>
  <para>
    As linhas de fontes de um CD-ROM podem às vezes se referir à
    <quote><literal>unstable</literal></quote>; embora isso possa ser confuso,
    você <emphasis>não</emphasis> deve alterá-las.
  </para>
</note>
</para>

<section id="record-session">
<title>Gravando a sessão</title>
<para>
É fortemente recomendado que você utilize o programa <command>/usr/bin/script</command>
para gravar uma transcrição da sessão de atualização. Então, se um problema
ocorrer, você terá um registro do que aconteceu e, se necessário, poderá fornecer
informações precisas em um relatório de bug. Para iniciar a gravação, digite:
</para>
<screen>
# script -t 2&gt;~/upgrade-&releasename;<replaceable>passo</replaceable>.time -a ~/upgrade-&releasename;<replaceable>passo</replaceable>.script
</screen>
<para>
ou semelhante. Se você tiver que reexecutar o typescript (ex. se você tiver que
reinicializar o sistema) use valores diferentes para o <replaceable>passo</replaceable>
para indicar que passo da atualização você está registrando. Não ponha o arquivo
de transcrição em um diretório temporário como <filename>/tmp</filename> ou
<filename>/var/tmp</filename> (arquivos nesses diretórios podem ser excluídos
durante a atualização ou durante qualquer reinicialização).
</para>
<para>
A transcrição também permitirá que você reveja informações que rolaram para
fora da tela. Se você estiver no console do sistema, apenas mude para VT2
(usando <keycombo action='simul'><keycap>Alt</keycap><keycap>F2</keycap></keycombo>)
e, após se autenticar, use
<literal>less -R ~root/upgrade-&releasename;.script</literal> para ver
o arquivo.
</para>
<para>
Depois que você tiver completado a atualização, pode parar o <command>script</command>
digitando <literal>exit</literal> no prompt.
</para>

<programlisting condition="fixme">
TODO: (jfs) Could mention the script I provided in #400725 which is useful if
you have not dumped the timing file
</programlisting>

<para>
Se você tiver usado a opção <emphasis>-t</emphasis> para o
<command>script</command> você pode usar o programa <command>scriptreplay</command>
para reproduzir toda a sessão:
</para>
<screen>
# scriptreplay ~/upgrade-&releasename;.time ~/upgrade-&releasename;.script
</screen>
</section>

<section id="updating-lists">
<title>Atualizando a lista de pacotes</title>
<para>
Primeiro, a lista de pacotes disponíveis para a nova versão precisa ser obtida.
Isso é feito executando:
</para>
<screen>
# apt-get update
</screen>
</section>

<section id="sufficient-space">
<title>Certifique-se que você tem espaço suficiente para a atualização</title>
<para>
Você tem que se certificar, antes de atualizar o seu sistema, que você tem
espaço em disco rígido suficiente quando iniciar a atualização completa do
sistema descrita em <xref linkend="upgrading-full"/>. Primeiro, qualquer
pacote necessário para instalação que for obtido pela rede é armazenado em
<filename>/var/cache/apt/archives</filename> (e no subdiretório
<filename>partial/</filename>, durante o download), então você deve
certificar-se que tem espaço suficiente na partição do sistema de arquivos
que mantém o <filename>/var/</filename> para download temporário dos pacotes que
serão instalados em seu sistema. Após o download, você provavelmente precisará
de mais espaço em outras partições de sistema para ambas as instalações de
pacotes atualizados (que podem conter executáveis maiores ou mais dados) e
novos pacotes que serão puxados pela atualização. Se o seu sistema não tiver
espaço suficiente você pode acabar com uma atualização incompleta que pode ser
difícil de recuperar.
</para>
<para>
O <command>apt-get</command> pode exibir informações detalhadas do espaço
em disco necessário para a instalação. Antes de executar a atualização, você
pode ver essa estimativa executando:
</para>
<screen>
# apt-get -o APT::Get::Trivial-Only=true dist-upgrade
[ ... ]
XXX atualizados, XXX novos instalados, XXX para remover e XXX não atualizados.
Necessário obter xx.xMB de arquivos.
Após esta operação, AAAMB de espaço de disco adicional serão usados.
</screen>
<note>
<para>
Ao executar esse comando no início do processo de atualização, pode dar um erro,
devido às razões descritas nas próximas seções. Nesse casso, você precisará
esperar até que tenha feito a atualização do sistema mínimo como em
<xref linkend="minimal-upgrade"/> e atualizado o seu kernel,
antes de executar esse comando para estimar o espaço em disco.
</para>
</note>

<para>
Se você não tiver espaço suficiente em disco para a atualização, o <command>apt-get</command>
irá avisá-lo com uma mensagem como esta:
</para>
<screen>
E: Você não tem espaço livre suficiente em /var/cache/apt/archives/.
</screen>

<para>Nessa situação, certifique-se de liberar espaço
suficiente antes. Você pode:
</para>
<itemizedlist>
<listitem>
<para>
Remover pacotes que tenham sido previamente baixados para instalação (em
<filename>/var/cache/apt/archives</filename>). A limpeza do chace de pacotes
executando <command>apt-get clean</command> irá remover todos os arquivos de pacote
previamente baixados.
</para>
</listitem>
<listitem>
<para>
Remover pacotes esquecidos. Se você tiver o
<systemitem role="package">popularity-contest</systemitem> instalado, você pode usar
o <command>popcon-largest-unused</command> para listar os pacotes que você não usa
que ocupam mais espaço. Você também pode usar o <command>deborphan</command> ou
o <command>debfoster</command> para localizar pacotes obsoletos (veja <xref
linkend="obsolete"/> ). Alternativamente, você pode iniciar o <command>aptitude</command>
em <quote>modo visual</quote> e localizar pacotes obsoletos em
<quote>Pacotes Obsoletos e Criados Localmente</quote>.
</para>
</listitem>
<listitem>
<para>
Remover pacotes que ocupam espaço demais e não são necessários atualmente
(você sempre pode reinstalá-los após a atualização). Você pode listar os
pacotes que mais ocupam espaço em disco com o <command>dpigs</command>
(disponível no pacote <systemitem role="package">debian-goodies</systemitem>)
ou com o <command>wajig</command> (executando <literal>wajig size</literal>).
</para>
<para>
Você pode listar os pacotes que mais ocupam espaço em disco com o
<systemitem role="package">aptitude</systemitem>. Inicie o
<command>aptitude</command> em <quote>modo visual</quote>, selecione
<menuchoice><guimenu>Visões</guimenu><guimenuitem>Nova lista de pacotes
plana</guimenuitem></menuchoice>, pressione <keycap>l</keycap> e digite
<literal>~i</literal>, pressione <keycap>S</keycap> e digite
<literal>~installsize</literal>, então terá uma boa lista para trabalhar.
</para>
</listitem>
<listitem>
<para>
  Remover traduções e arquivos de localização do sistema se eles não forem
  necessários. Você pode instalar o pacote <systemitem
  role="package">localepurge</systemitem> e configurá-lo para que apenas
  alguns locales selecionados sejam mantidos no sistema. Isso reduzirá
  o espaço de disco consumido em <filename>/usr/share/locale</filename>.
</para>
</listitem>
<listitem>
<para>
   Mover temporariamente para um outro sistema, ou remover permanentemente,
   registros do sistema existentes em <filename>/var/log/</filename>.
</para>
</listitem>

<listitem>
  <para>
    Usar um <filename>/var/cache/apt/archives</filename> temporário:
    Você pode usar um diretório de cache temporário de um outro sistema
    de arquivos (dispositivo de armazenamento <acronym>USB</acronym>,
    disco rígido temporário, sistema de arquivos já em uso, ...)
  </para>
  <note>
    <para>
      Não use uma montagem <acronym>NFS</acronym> pois a conexão
			de rede pode ser interrompida durante a atualização.
    </para>
  </note>
    <para>
  Por exemplo, se você tiver um drive <acronym>USB</acronym> montado
  em <filename>/media/usbkey</filename>:
  <orderedlist>
    <listitem>
      <para>
	remova os pacotes que tenham sido previamente baixados para
	instalação:

	<screen># apt-get clean</screen>
      </para>
    </listitem>
    <listitem>
      <para>
	copie o diretório
	<filename>/var/cache/apt/archives</filename> para o
	dispositivo <acronym>USB</acronym>:

	<screen># cp -ax /var/cache/apt/archives /media/usbkey/</screen>
      </para>
    </listitem>
    <listitem>
      <para>
	monte o diretório de cache temporário no atual:

	<screen># mount --bind /media/usbkey/archives /var/cache/apt/archives</screen>
      </para>
    </listitem>
    <listitem>
      <para>
	após a atualização, restaure o diretório
	<filename>/var/cache/apt/archives</filename> original:

	<screen># umount /media/usbkey/archives</screen>
      </para>
    </listitem>
    <listitem>
      <para>
	remova o <filename>/media/usbkey/archives</filename> restante.
      </para>
    </listitem>
  </orderedlist>
  Você pode criar o diretório de cache temporário em qualquer sistema
  de arquivos que esteja montado em seu sistema.
  </para>
  </listitem>

<listitem>
  <para>
    Faça uma atualização mínima do sistema (veja <xref linkend="minimal-upgrade"/>)
    ou atualizações parciais do sistema seguidas por uma atualização completa.
		Isso permitirá atualizar o sistema parcialmente, e permite limpar
		o cache de pacotes antes da atualização completa.
  </para>
</listitem>

</itemizedlist>


<para>
Note que para remover pacotes com segurança, é aconselhável mudar o seu
<filename>sources.list</filename> de volta para &oldreleasename; como descrito
em <xref linkend="old-sources"/>.
</para>
</section>


<section id="minimal-upgrade">
<title>Atualização mínima do sistema</title>
<para>
Em alguns casos, a atualização completa feita (como descrito abaixo) diretamente
pode remover um grande número de pacotes que você queira manter. Nós portanto
recomendamos um processo de atualização em duas partes, primeiro uma atualização
mínima para superar esses conflitos, depois uma atualização completa como
descrito em <xref linkend="upgrading-full"/>. 
</para>
<para>
Para fazer isso primeiro, execute:
</para>
<screen>
# apt-get upgrade
</screen>
<para>
Isso tem o efeito de atualizar aqueles pacotes que podem ser atualizados sem
a necessidade de que quaisquer outros pacotes sejam removidos ou instalados.
</para>

<para>
A atualização mínima do sistema também pode ser útil quando o sistema estiver
com espaço apertado e uma atualização completa não puder ser feita devido às
restrições de espaço.
</para>

</section>

<!-- For more information See BTS #571255 and #602397 -->
<!-- NOTE (jfs-2010-11-06) Upgrade tests for Squeeze have shown
that this is not absolutely required, users could do a dist-upgrade
and then reboot. This is, however, the recommended path to be on the 
safe side -->
<section id="upgrading-udev">
<title>Atualizando o kernel e o udev</title>
<para>
A versão do <systemitem role="package">udev</systemitem> no &releasename;
requer um kernel da versão 2.6.26 ou mais novo com a opção
<literal>CONFIG_SYSFS_DEPRECATED</literal> desabilitada e a opções
<literal>CONFIG_INOTIFY_USER</literal> e
<literal>CONFIG_SIGNALFD</literal> habilitadas. Porque os kernels
do Debian padrão no &oldreleasename; (versão 2.6.26) têm o
<literal>CONFIG_SYSFS_DEPRECATED</literal> habilitado, e a versão do
<systemitem role="package">udev</systemitem> no &oldreleasename; não 
fornecerá todas as funcionalidades esperadas pelos kernels mais recentes,
um cuidado especial deve ser tomado quando atualizar para evitar pôr o seu
sistema em um estado não-inicializável.
</para>
<para>
Inicializar o kernel 2.6.26 a partir do &oldreleasename; com o <systemitem
role="package">udev</systemitem> do &releasename; pode resultar em uma falha
na atribuição de nomes aos dispositivos de rede, e também irá falhar ao
aplicar certas permissões adicionais aos dispositivos de bloco (tal como
acesso pelo grupo <literal>disk</literal>). 
O software em si parecerá estar funcionando, mas algumas regras
(por exemplo, regras baseadas em rede) não serão carregadas corretamente.
É portanto fortemente recomendado que você atualize o kernel por conta própria
neste momento, para garantir que um kernel compatível está disponível antes
da atualização do <systemitem role="package">udev</systemitem>.
</para>
<!-- FIXME: Review if we have to upgrade the kernel *and* udev
at the same time here -->
<para>
Para proceder com essa atualização do kernel, execute:
</para>
<screen>
# apt-get install linux-image-2.6-<replaceable>variante</replaceable>
</screen>
<para>
Veja <xref linkend="kernel-metapackage"/> para ajuda na determinação de qual
variante do kernel você deve instalar.
</para>
<para>
A mudança de alguns firmwares para pacotes separados no repositório non-free
(veja <xref linkend="nonfree-firmware"/>) significa que pode ser necessário
instalar pacotes de firmware adicionais após a atualização para o novo kernel.
Tenha cuidado com as mensagens de aviso da instalação do kernel ou scripts de
geração do initramfs, e certifique-se que os pacotes de firmware necessários
estão instalados.
</para>
<para arch="i386;amd64">
Os usuários do gerenciador de inicialização<systemitem role="package">grub</systemitem>
devem certificar-se de que o <command>update-grub</command> é executado como
parte da atualização do kernel, ou executá-lo manualmente.
</para>
<para>
Imediatamente após a atualização do kernel, você também deve instalar o novo
<systemitem role="package">udev</systemitem> para minimizar o risco de outra
incompatibilidade causada por usar o udev antigo com um kernel novo <footnote>
<para>Também existem incompatibilidades conhecidas entre o kernel antigo e o
<systemitem role="package">udev</systemitem> novo. Se você encontrar problemas
após a reinicialização com o kernel novo, terá que desfazer a atualização do
<systemitem role="package">udev</systemitem> para utilizar o antigo.</para>
</footnote>. 
Você pode fazer isso executando:
</para>
<!-- TODO (2010-11-6): Needs to be tested, maybe the ugprade to udev might not
work due to the preinst checks introduced by the maintainer -->
<screen>
# apt-get install udev
</screen>

<para>
Você deve reinicializar o sistema
<footnote><para>Se você estiver registrando a atualização como descrito em
<xref linkend="upgradingpackages"/>, por favor, use novamente o <command>script</command>
para registrar os próximos passos da atualização após a reinicialização
para registrar o resultado das ações descritas em <xref linkend="upgrading-full"/>.
</para></footnote>
depois de ter atualizado o kernel e o <systemitem role="package">udev</systemitem>.
</para>

</section>


<section id="upgrading-full">
<title>Atualizando o sistema</title>
<para>
Uma vez que você tenha cumprido os passos anteriores, agora está pronto para
continuar com a parte principal da atualização. Execute:
</para>
<screen>
# apt-get dist-upgrade
</screen>
  <note>
    <para>
      O processo de atualização para as outras versões recomendava
      o uso do <command>aptitude</command> para a atualização. Essa
      ferramenta não é recomendada para atualizações do &oldreleasename; 
      para o &releasename;.
    </para>
  </note>
<para>
Isso irá realizar uma atualização completa do sistema, i.e. instalar as versões
mais novas disponíveis de todos os pacotes, e resolver todas as mudanças de
dependências possíveis entre pacotes em lançamentos diferentes. Se necessário,
irá instalar alguns pacotes novos (normalmente novas versões de bibliotecas,
ou pacotes renomeados), e remover quaisquer pacotes obsoletos em conflito.
</para>
<para>
Quando atualizar a partir de um conjunto de CD-ROMs (ou DVDs), será pedido
para inserir CDs específicos em vários pontos durante a atualização. Você
pode ter que inserir o mesmo CD várias vezes; isso é devido aos pacotes
inter-relacionados que foram espalhados através dos CDs.
</para>
<para>
As novas versões dos pacotes instalados atualmente que não puderem ser
atualizadas sem mudar o estado da instalação de um outro pacote, serão
deixadas em sua versão atual (exibidas como <quote>held back</quote>).
Isso pode ser resolvido tanto utilizando o <command>aptitude</command>
para escolher esses pacotes para instalação como tentando
<literal>apt-get -f install <replaceable>package</replaceable></literal>.
</para>
</section>

</section>

<section id="trouble">
<title>Possíveis problemas durante a atualização</title>

<para>
As seções seguintes descrevem problemas conhecidos que podem aparecer
durante uma atualização para o &releasename;.
</para>

<section id="cryptoloop">
<title>Suporte a cryptoloop não incluído no kernel Linux do &releasename;</title>
<para>
O suporte para cryptoloop foi abandonado nos pacotes do kernel Linux incluídos
no Debian &release;. Instalações já existentes que utilizem cryptoloop
precisam ser transferidas para dm-crypt antes da atualização.
</para>
</section>

<section id="expected-removals">
<title>Remoções esperadas</title>
<para>
O processo de atualização para o &releasename; pode solicitar a remoção de
pacotes no sistema. A lista exata dos pacotes irá variar dependendo dos
conjuntos de pacotes que você tenha instalados. Estas notas de lançamento
dão conselhos gerais sobre essas remoções, mas se estiver em dúvida, é
recomendado que você examine as remoções de pacotes propostas por cada
método antes de prosseguir.
</para>

<!-- FIXME: This needs to be reviewed based on real upgrade logs (jfs) -->
<!-- Alternative, another source of information is the UDD
'not-in-testing' page: http://udd.debian.org/bapase.cgi?t=testing -->
<para>
Alguns pacotes comuns que espera-se que sejam removidos incluem:
<systemitem role="package">autofs</systemitem> (substituído por
<systemitem role="package">autofs5</systemitem>),
<systemitem role="package">dhcp3</systemitem> (substituído por
<systemitem role="package">isc-dhcp</systemitem>),
<systemitem role="package">madwifi-source</systemitem>,
<systemitem role="package">python-setuptools</systemitem> e
<systemitem role="package">python2.4</systemitem> (substituído por
<systemitem role="package">python2.6</systemitem>).

Para mais informações sobre pacotes obsoletos no &releasename;, veja <xref
linkend="obsolete"/>.
</para>

</section>

<section id="apt-error-operation">
<title>Erros executando aptitude ou apt-get</title>
<para>
Se uma operação falha usando <command>aptitude</command>, <command>apt-get</command>,
ou <command>dpkg</command> com o erro
</para>
<!-- TODO (jfs): Review the message, it has changed in apt-get to
"Dynamic MMap ran out of room. Please increase the size of APT::Cache-Limit. "
"Current value: %lu. (man 5 apt.conf)" -->
<screen>
E: Dynamic MMap ran out of room
</screen>
<para>
O espaço de cache padrão está insuficiente. Você pode resolver isso
tanto removendo ou comentando linhas que você não precisa em
<filename>/etc/apt/sources.list</filename> como aumentando o tamanho do cache.
O tamanho do cache pode ser aumentado pelo ajuste <literal>APT::Cache-Limit</literal>
no <filename>/etc/apt/apt.conf</filename>. O seguinte comando irá ajustá-lo
para um valor que deverá ser suficiente para a atualização:
</para>
<screen>
# echo 'APT::Cache-Limit "12500000";' &gt;&gt; /etc/apt/apt.conf
</screen>
<para>
Isso pressupõe que você ainda não possui essa variável definida nesse arquivo.
</para>

</section>

<section id="conflicts-loops">
<title>Loops de conflitos ou pré-dependências</title>

<para>
Algumas vezes é necessário habilitar a opção <literal>APT::Force-LoopBreak</literal>
no APT para que seja possível remover temporariamente um pacote essencial,
devido a um loop de Conflitos/Pré-Dependências. O <command>apt-get</command> irá
alertá-lo sobre isso e cancelar a atualização. Você pode contornar isso
especificando a opção <literal>-o APT::Force-LoopBreak=1</literal> na linha
de comando do <command>apt-get</command>.
</para>
<para>
É possível que uma estrutura de dependências do sistema possa estar tão
corrompida de modo que necessite de intervenção manual. Normalmente isso
significa usar o
<command>apt-get</command> ou
</para>
<screen>
# dpkg --remove <replaceable>package_name</replaceable>
</screen>
<para>
para eliminar alguns dos pacotes problemáticos, ou
</para>
<screen>
# apt-get -f install
# dpkg --configure --pending
</screen>
<para>
Em casos extremos, você poderá ter que forçar a reinstalação com um comando como
</para>
<screen>
# dpkg --install <replaceable>/path/to/package_name.deb</replaceable>
</screen>

</section>

<section id="file-conflicts">
<title>Conflitos de arquivos</title>

<para>
Os conflitos de arquivos não devem ocorrer se você atualizar a partir de
um sistema <quote>puro</quote> &oldreleasename;, mas podem ocorrer se você
tem <quote>backports</quote> não oficiais instalados. Um conflito de arquivo
irá resultar em um erro como:
</para>
<screen>
Descompactando <replaceable>&lt;package-foo&gt;</replaceable> (de <replaceable>&lt;package-foo-file&gt;</replaceable>) ...
dpkg: erro processando <replaceable>&lt;package-foo&gt;</replaceable> (--install):
 tentando sobrescrever `<replaceable>&lt;some-file-name&gt;</replaceable>',
 o qual também está no pacote <replaceable>&lt;package-bar&gt;</replaceable>
dpkg-deb: sub-processo de colagem morto pelo sinal (pipe quebrado)
 Erros foram encontrados enquanto processando:
 <replaceable>&lt;package-foo&gt;</replaceable>
</screen>
<para>
Você pode tentar resolver um conflito de arquivo com a remoção forçada do
pacote mencionado na <emphasis>última</emphasis> linha da mensagem de erro:
</para>
<screen>
# dpkg -r --force-depends <replaceable>package_name</replaceable>
</screen>
<para>
Após consertar as coisas, você deve ser capaz de continuar a atualização
repetindo os comandos do <command>apt-get</command> descritos anteriormente.
</para>

</section>

<section id="configuration-changes">
<title>Mudanças de configuração</title>

<para>
Durante a atualização, serão feitas perguntas com relação a configuração ou
reconfiguração de diversos pacotes. Quando você for perguntado se algum
arquivo no diretório <filename>/etc/init.d</filename>, ou o arquivo
<filename>/etc/manpath.config</filename> deve ser substituído pela versão do
mantenedor do pacote, normalmente é necessário responder `yes' para
garantir a coerência do sistema. Você sempre pode reverter para as versões
antigas, já que serão guardadas com uma extensão <literal>.dpkg-old</literal>.
</para>
<para>
Se você não tiver certeza do que fazer, anote o nome do pacote ou arquivo e
resolva em um momento posterior. Você pode procurar no arquivo transcrito
para rever as informações que estavam na tela durante a atualização.
</para>
</section>

<section id="console-change">
<title>Mudança de sessão para o console</title>
<para>
Se você estiver executando a atualização usando o console local do sistema
você pode achar que em alguns momentos durante a atualização o console é
comutado para uma visão diferente e você perde a visibilidade do processo
de atualização. Por exemplo, isso acontece em sistemas desktop quando o
<command>gdm</command> é reiniciado.
</para>
<para>
Para recuperar o console onde a atualização estava em execução você terá que
usar <keycombo action='simul'><keycap>Ctrl</keycap><keycap>Alt</keycap>
<keycap>F1</keycap></keycombo> para mudar de volta para o terminal 1 se
estiver na tela de inicialização gráfica ou use <keycombo action='simul'>
<keycap>Alt</keycap><keycap>F1</keycap></keycombo> se estiver no console 
local em modo texto. Substitua F1 pela tecla de função com o mesmo número
do terminal virtual onde a atualização estava em execução. Você também
pode usar <keycombo action='simul'><keycap>Alt</keycap><keycap>Seta Esquerda
</keycap></keycombo> ou <keycombo action='simul'><keycap>Alt</keycap><keycap>
Seta Direita</keycap></keycombo> para mudar entre os diferentes terminais 
em modo texto.
</para>
</section>

<section id="package-specific-issues">
<title>Cuidados especiais com pacotes específicos</title>
<para>
Na maioria dos casos, os pacotes deverão atualizar sem problemas entre
&oldreleasename; e &releasename;. Existe um pequeno número de casos onde
alguma intervenção pode ser necessária, seja antes ou durante a atualização;
esses estão detalhados a seguir baseados por pacote.
</para>
<section id="issues-evolution">
<title>Evolution</title>
<para>
Evolution (o cliente de e-mail da área de trabalho GNOME) foi atualizado da
versão <literal>2.22</literal> para a <literal>2.30</literal>. Isso muda o 
formato de armazenamento usado pelo pacote para dados locais e existe uma
possibilidade de perda de dados se a atualização for feita enquanto o
<systemitem role="package">evolution</systemitem> estiver em execução.
A saída do próprio aplicativo pode não ser suficiente, uma vez que vários 
componentes relacionados continuarão a ser executados em segundo plano.
Para evitar possíveis problemas, é recomendado que você saia completamente
da seu ambiente de área de trabalho antes de iniciar a atualização para o
&releasename;.
</para>
<para>
Como parte do processo de atualização, o <systemitem
role="package">evolution</systemitem> irá verificar se todos os processos
relacionados estão em execução e recomendará que eles sejam fechados. Uma
segunda verificação dos processo será então realizada; se necessário, será
oferecida uma escolha entre permitir que os processo remanescentes sejam
mortos ou abortar a atualização, para resolver a situação manualmente.
</para>
</section>
</section>
<!-- End of 'trouble' section -->
</section>

<!-- TODO: need to be reviewed with information from http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=571255 -->
<section id="newkernel">
<title>Atualizando o seu kernel e pacotes relacionados</title>
<para>
Esta seção explica como atualizar o seu kernel e identifica potenciais
problemas relacionados com essa atualização. Você pode instalar um dos
pacotes <systemitem role="package">linux-image-*</systemitem> fornecidos
pelo Debian, ou compilar um kernel customizado a partir do fonte.
</para>
<para>
Note que muitas das informações nesta seção são baseadas na suposição de
que você esteja usando um dos kernels modulares do Debian, juntamente com o
<systemitem role="package">initramfs-tools</systemitem> e o <systemitem
role="package">udev</systemitem>. Se você escolher utilizar um kernel
customizado que não requeira uma initrd ou se você utiliza um gerador de
initrd diferente, algumas das informações podem não ser relevantes para você.
</para>
<section id="kernel-metapackage">
<title>Instalando o meta-pacote do kernel</title>
<para>
Quando você fizer dist-upgrade do &oldreleasename; para o &releasename;, é
fortemente recomendado que você instale um novo meta-pacote linux-image-2.6-* .
Esse pacote pode ser automaticamente instalado pelo processo dist-upgrade.
Você pode verificar isso executando:
</para>
<screen>
# dpkg -l "linux-image*" | grep ^ii
</screen>
<para>
Caso você não veja nenhuma saída, então você precisará instalar um novo
pacote linux-image manualmente. Para ver uma lista de meta-pacotes
linux-image-2.6 disponíveis, execute:
</para>
<screen>
# apt-cache search linux-image-2.6- | grep -v transition
</screen>

<!-- FIXME: Review the Example for Squeeze -->
<para>
Se você estiver inseguro sobre qual pacote selecionar, execute
<literal>uname -r</literal> e procure um pacote com um nome semelhante. Por
exemplo, caso você veja '<literal>2.6.26-2-686</literal>', é recomendado que
você instale <systemitem role="package">linux-image-2.6-686</systemitem>. 
Você também pode usar <command>apt-cache</command> para ver uma longa descrição
de cada pacotes a fim de ajudar a escolher o melhor disponível. Por exemplo:
</para>
<screen>
# apt-cache show linux-image-2.6-686
</screen>
<para>
Você deverá então usar <literal>apt-get install</literal> para instalá-lo.
Uma vez que o novo kernel esteja instalado você deverá reinicializar assim que
for possível, para obter os benefícios oferecidos pela nova versão do kernel.
</para>
<para>
Para os mais aventurosos existe uma forma fácil de compilar seu próprio kernel
customizado no &debian;. Instale a ferramenta <systemitem
role="package">kernel-package</systemitem> e leia a documentação em
<filename>/usr/share/doc/kernel-package</filename>. Alternativamente,
você também pode usar os fontes do kernel, fornecidos no pacote <systemitem
role="package">linux-source-2.6</systemitem>. Você pode fazer uso do alvo
<literal>deb-pkg</literal> disponível no makefile dos fontes para construir
um pacote executável. Existem algumas diferenças nessas duas abordagens, por
favor, consulte a respectiva documentação do pacote.
</para>
<para>
Se possível, é vantagem atualizar o pacote do kernel separadamente do
principal <literal>dist-upgrade</literal> para reduzir as chances de ter
um sistema temporariamente não-inicializável.
Note que isso deverá ser feito somente após o processo de atualização mínima
descrito em <xref linkend="minimal-upgrade"/>.
</para>
</section>

<!-- FIXME: REVIEW for Squeeze this was written for Lenny - drop? (jfs) -->
<section id="device-reorder">
<title>Reordenamento da enumeração de dispositivos</title>
<para>
No &oldreleasename; e posteriores, um novo mecanismo do kernel para descoberta
de hardware pode mudar a ordem na qual os dispositivos são descobertos no seu
sistema a cada inicialização, afetando os nomes dos dispositivos que lhes
forem atribuídos. Por exemplo, se você tiver duas placas de rede que são
associadas a dois drivers diferentes, as referências dos dispositivos eth0
e eth1 podem ser trocadas.
</para>
<para>
Para dispositivos de rede, esse reordenamento normalmente é evitado pelas
definições em <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>
para o <systemitem role="package">udev</systemitem>. Uma vez que essas regras
já existiam no &oldreleasename;, nenhuma ação adicional deverá ser necessária
quando fizer a atualização para o &releasename; para obter o benefício dos
nomes fixos nos dispositivos de rede. Por favor, note entretanto que esse
mecanismo udev significa que um nome de determinado dispositivo de rede está
amarrado a uma determinada parte do hardware; se você, por acaso, substituir
placas de rede em um sistema &releasename; implantado, a nova placa irá obter
um novo nome de interface ao invés de usar o já existente. Para reutilizar um
nome de dispositivo já existente para um novo hardware, você precisará 
excluir a entrada associada do
<filename>/etc/udev/rules.d/70-persistent-net.rules</filename>.
</para>
<para>
Para dispositivos de armazenamento, você pode evitar esse reordenamento usando
o <systemitem role="package">initramfs-tools</systemitem> e o configurando
para carregar os módulos do driver do dispositivo de armazenamento na mesma
ordem em que estão atualmente carregados. Entretanto, à luz de outras
mudanças no subsistema de armazenamento do kernel Linux, como descrito em
<xref linkend="ide-pata-transition"/>, geralmente isso não merece o esforço
e, ao invés disso, é recomendado usar nomes de dispositivos que sejam fixos
ao longo do tempo, tais como os pseudônimos UUID<footnote><para>Alguns
dispositivos, tais como aqueles usados pelo crypt, RAID ou LVM têm
identificadores não-UUID fixos. Nesses casos, você deverá usar o nome dos
dispositivos, que já são não-ambíguos e fixos.</para></footnote>
no diretório <filename>/dev/disk/by-uuid/</filename> ou nomes de dispositivos
LVM em <filename>/dev/mapper/</filename>.
</para>
</section>

<!-- FIXME: REVIEW for Squeeze this was written for Lenny - drop? (jfs) -->
<section id="boot-timing">
<title>Problemas com o tempo de inicialização</title>
<para>
Se uma initrd criada com o <systemitem role="package">initramfs-tools</systemitem>
for usada para inicializar o sistema, em alguns casos a criação dos arquivos
de dispositivo pelo <systemitem role="package">udev</systemitem> pode ocorrer
muito tarde para que os scripts inicialização atuem.
</para>
<para>
O sintoma mais comum é que a inicialização irá falhar porque o sistema de
arquivos raiz não pode ser montado e você é deixado em uma shell de depuração.
Mas se você verificar posteriormente, todos os dispositivos que são necessários
estão presentes em <filename>/dev</filename>. Isso foi observado em casos onde
o sistema de arquivos raiz está em um disco <acronym>USB</acronym> ou em um
<acronym>RAID</acronym>, especialmente se for usado <acronym>LILO</acronym>
<indexterm><primary>LILO</primary></indexterm>.
</para>
<para>
Uma forma de contornar esse problema é usar o parâmetro de inicialização
<literal>rootdelay=<replaceable>9</replaceable></literal>. O valor para o
timeout (em segundos) talvez precise ser ajustado.
</para>
</section>

</section>

<!--
No tasks left in this section, so comment the whole thing out.
-->
<section id="nownownow" condition="fixme">
<title>Coisas para fazer antes de reinicializar</title>
<para>
Quando o <literal>apt-get dist-upgrade</literal> terminar, a atualização
<quote>formal</quote> estará completa, mas existem algumas outras coisas 
com as quais deve-se ter cuidado <emphasis>antes</emphasis> da próxima
reinicialização.
</para>

<!-- FIXME: Probably dropable since lilo is no longer setup in Lenny -->
<programlisting condition="fixme">
Provavelmente, não há mais necessidade alguma de executar o lilo manualmente
na atualização, o /etc/kernel/postinst.d/zz-lilo executa o lilo
incondicionalmente na atualização do kernel; mas não jogue tudo isso fora
até que os mantenedores do lilo confirmem que não é necessário na
atualização para o gerenciador de inicialização do segundo estágio.
</programlisting>

<!-- FIXME: REVIEW for Squeeze this was written for Lenny - drop? (jfs) -->
<section arch="i386;amd64" id="rerunlilo" condition="fixme">
<title>Reexecute o lilo</title>
<para>
Se você estiver usando o <systemitem role="package">lilo</systemitem> como 
seu gerenciador de inicialização (que é o padrão para algumas instalações do
&oldreleasename;), é fortemente recomendado que você reexecute o
<command>lilo</command> após a atualização. O pacote <systemitem role="package">
lilo</systemitem> irá se oferecer para fazer isso por você, mas caso você
recuse ou não veja o aviso, deverá executar o lilo manualmente:
</para>
<screen>
# /sbin/lilo
</screen>
<para>
Note que isso é necessário mesmo se você não tiver atualizado o kernel do
seu sistema, já que o segundo estágio do <command>lilo</command> irá mudar 
devido à atualização do pacote.
</para>
<para>
Além disso, reveja o conteúdo do seu <filename>/etc/kernel-img.conf</filename> e
certifique-se que você tem <literal>do_bootloader = Yes</literal> nele. Dessa
forma, o gerenciador de inicialização sempre será reexecutado após uma
atualização do kernel.
</para>
<para>
Se você encontrar quaisquer problemas quando executar o <command>lilo</command>,
reveja os links simbólicos no <filename>/</filename> ou <filename>/boot</filename>
para <filename>vmlinuz</filename> e <filename>initrd</filename> e o conteúdo
do seu <filename>/etc/lilo.conf</filename> em busca de divergências.
</para>
<para>
Se você esqueceu de reexecutar o <command>lilo</command> antes da reinicialização
ou se o sistema for acidentalmente reinicializado antes que você possa fazer
isso manualmente, a inicialização do seu sistema pode falhar. Ao invés do
prompt do lilo, você verá apenas <literal>LI</literal> quando inicializar o
sistema<footnote><para> Para mais informações sobre códigos de erro de
inicialização do <command>lilo</command> por favor, veja <ulink
url="http://tldp.org/HOWTO/Bootdisk-HOWTO/a1483.html">The Linux Bootdisk
HOWTO</ulink>. </para> </footnote>. Veja <xref linkend="recovery"/> para
informações de como recuperar essa situação.
</para>
</section>

<!-- FIXME: REVIEW for Squeeze this was written for Lenny - drop? (jfs) -->
<section id="mdadm" condition="fixme">
<title>Atualizando o mdadm</title>
<programlisting condition="fixme">TODO: Remove for lenny?</programlisting>
<para>
O mdadm agora precisa de um arquivo de configuração para montar arranjos MD
(<acronym>RAID</acronym>) a partir da ramdisk inicial e durante a sequência
de inicialização do sistema. Certifique-se de ler e agir de acordo com as
instruções em <filename>/usr/share/doc/mdadm/README.upgrading-2.5.3.gz</filename>
após o pacote ter sido atualizado <emphasis role="strong">e antes de você
reinicializar</emphasis>. A última versão desse arquivo está disponível em <ulink
url="http://svn.debian.org/wsvn/pkg-mdadm/mdadm/trunk/debian/README.upgrading-2.5.3?op=file"></ulink>;
por favor, consulte-a em caso de problemas.
</para>
</section>

</section>

<section id="boot-hangs" condition="fixme">
  <title>A inicialização do sistema trava em <quote><literal>Waiting for root
  file system</literal></quote></title>
  <subtitle>Procedimento para recuperar o <filename>/dev/hda</filename>
  que tornou-se <filename>/dev/sda</filename></subtitle>

  <para>
    Alguns usuários têm relatado que uma atualização pode fazer com que o kernel
    não encontre a partição raiz do sistema após a reinicialização do sistema. 
  </para>

  <para>
    Nesse caso, a inicialização do sistema irá travar na seguinte mensagem:
    <screen>Waiting for root file system ...</screen>
    e após alguns segundos um prompt vazio do busybox irá aparecer.
  </para>

  <para>
    Esse problema pode ocorrer quando a atualização do kernel introduz a
    utilização da nova geração de drivers <acronym>IDE</acronym>.
    A convenção de nomenclatura de disco <acronym>IDE</acronym> para os
    drivers antigos era <literal>hda</literal>, <literal>hdb</literal>,
    <literal>hdc</literal>, <literal>hdd</literal>. Os novos drivers
    irão nomear os mesmos discos, respectivamente como <literal>sda</literal>,
    <literal>sdb</literal>, <literal>sdc</literal>, <literal>sdd</literal>.
  </para>
  <para>
    O problema aparece quando a atualização não gera um novo arquivo
    <filename>/boot/grub/menu.lst</filename> para levar em consideração a nova
    convenção de nomenclatura. Durante a inicialização, o Grub irá passar uma
    partição raiz do sistema para o kernel que o mesmo não encontra. Também 
    pode aparecer durante a montagem de sistemas de arquivos, se o 
    <filename>/etc/fstab</filename> não tiver sido atualizado de acordo.
    Embora o processo de atualização para o &releasename; deva atender ambas as
    situações automaticamente.
  </para>

  <para>
    Se você tiver encontrado esse problema após a atualização, pule para
    <xref linkend="how-to-recover"/>. Para evitar o problema antes da
    atualização leia adiante.
  </para>

  <section id="avoid-problems-before-upgrading">
    <title>Como evitar o problema antes da atualização</title>

    <para>
      É possível evitar esse problema inteiramente usando um identificador para
      o sistema de arquivos raiz que não muda de uma inicialização para outra.
      Existem dois métodos possíveis para fazer isso - rotulando o sistema de
      arquivos, ou usando o identificador único universal de sistema de arquivos
      (<acronym>UUID</acronym>). Esses métodos são suportados no Debian desde
      a versão etch.
    </para>

    <para>
      As duas abordagens têm vantagens e desvantagens. A abordagem de rotulagem
      é mais legível, mas pode haver problemas se outro sistema de arquivos em
      sua máquina tiver o mesmo rótulo. A abordagem <acronym>UUID</acronym> é
      mais desagradável, mas ter dois <acronym>UUID</acronym>s conflitantes é
			altamente incomum.
    </para>

    <para>
      Para os exemplos abaixo nós assumimos que o sistema de arquivos raiz
      está em <filename>/dev/hda6</filename>. Nós também assumimos que o seu
      sistema tem uma instalação do udev funcionando e sistemas de arquivos
      ext2 ou ext3.
    </para>

    <para>
      Para implementar a abordagem de rotulagem:
      <orderedlist>
	<listitem>
	  <para>
	    Rotule o sistema de arquivos (o nome deve ser de &lt; 16 caracteres)
	    executando o comando:
	    <command>e2label /dev/hda6 rootfilesys</command>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Edite o <filename>/boot/grub/menu.lst</filename> e mude a linha:
	    <programlisting># kopt=root=/dev/hda6 ro</programlisting>
	    para
	    <programlisting># kopt=root=LABEL=rootfilesys ro</programlisting>
	    <note>
	      <para>
		Não remova o <literal>#</literal> no início da
		linha, ele precisa existir.
	      </para>
	    </note>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Atualize as linhas do <literal>kernel</literal> em
	    <filename>menu.lst</filename> executando o comando
	    <command>update-grub</command>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Edite o <filename>/etc/fstab</filename> e mude a linha que
	    monta a partição <filename>/</filename> , e.g.:

	    <programlisting>/dev/hda6     /     ext3  defaults,errors=remount-ro 0 1</programlisting>

	    para

	    <programlisting>LABEL=rootfilesys     /     ext3  defaults,errors=remount-ro 0 1</programlisting>

	    A mudança que importa aqui é a primeira coluna, você
      não precisa modificar as outras colunas dessa linha.
	  </para>
	</listitem>
      </orderedlist>
    </para>

    <para>
      Para implementar a abordagem <acronym>UUID</acronym>:
      <orderedlist>
	<listitem>
	  <para>
	    Encontre o identificador único universal do seu sistema de arquivos executando:
	    <command>ls -l /dev/disk/by-uuid | grep hda6</command>. Você também pode usar
      <command>blkid /dev/hda6</command>.

	  </para>
        
	  <para>
            Se você listar o conteúdo em <filename>/dev/disk/by-uuid</filename>,
            você deve obter uma linha semelhante a esta:
	    <screen>lrwxrwxrwx 1 root root 24 2008-09-25 08:16 d0dfcc8a-417a-41e3-ad2e-9736317f2d8a -> ../../hda6</screen>
          </para>
          <!-- TODO: Put the output of vol_id instead, since this is *before* the upgrade -->
          <para>
          Se você usar <command>blkid</command>, você deve obter uma saída semelhante a esta:
          <screen>/dev/hda6: UUID="d0dfcc8a-417a-41e3-ad2e-9736317f2d8a" TYPE="ext3"</screen>
          </para>

          <para>
	    O <acronym>UUID</acronym> é o nome do link simbólico
	    para <filename>/dev/hda6</filename> i.e.:
	    <literal>d0dfcc8a-417a-41e3-ad2e-9736317f2d8a</literal>.
	    <note>
	      <para>
		O <acronym>UUID</acronym> do seu sistema de arquivos
		será uma seqüência de caracteres diferente.
	      </para>
	    </note>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Edite o <filename>/boot/grub/menu.lst</filename> e mude a linha:
	    <programlisting># kopt=root=/dev/hda6 ro</programlisting>
	    para usar UUID em seu lugar:
	    <programlisting># kopt=root=UUID=d0dfcc8a-417a-41e3-ad2e-9736317f2d8 ro</programlisting>
	    <note>
	      <para>
		Não remova o <literal>#</literal> no início da
		linha, ele precisa existir.
	      </para>
	    </note>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Atualize as linhas do <literal>kernel</literal> em
	    <filename>menu.lst</filename> executando o comando
	    <command>update-grub</command>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Edite o <filename>/etc/fstab</filename> e mude a linha que monta a partição <filename>/</filename> , e.g.:

	    <programlisting>/dev/hda6     /     ext3  defaults,errors=remount-ro 0 1</programlisting>

	    para

	    <programlisting>UUID=d0dfcc8a-417a-41e3-ad2e-9736317f2d8  /  ext3  defaults,errors=remount-ro 0 1</programlisting>

	    A mudança que importa aqui é a primeira coluna, você
      não precisa modificar as outras colunas dessa linha.
	  </para>
	</listitem>
      </orderedlist>
    </para>
  </section>

<!-- FIXME: This section might not be relevant anymore for Squeeze
  but could be turned into a generic section on how to recover from
  issues -->
  <section id="how-to-recover">
    <title>Como se recuperar do problema após a atualização</title>

    <section id="solution1">
      <title>Solução 1</title>
      <para>
	Isso é apropriado quando o Grub apresenta a interface de menu para
  seleção da entrada a partir da qual você pretende inicializar. 
	Caso tal menu não apareça, tente pressionar a tecla <keycap>Esc</keycap>
  antes que o kernel inicialize a fim de fazê-la aparecer. Caso você
  não consiga chegar nesse menu, tente a <xref linkend="solution2"/> ou
  a <xref	linkend="solution3"/>.
      </para>

<!-- FIXME: If kept for Squeeze adjust the kernel version to that of Lenny -->
      <orderedlist>
	<listitem>
	  <para>
	    No menu do Grub, destaque a entrada a partir da qual você pretende
      inicializar. Pressione a tecla <keycap>e</keycap> para editar as
      opções relacionadas a essa entrada. Você verá algo como:

	    <screen>root (hd0,0)
kernel /vmlinuz-2.6.32-5-686 root=/dev/hda6 ro
initrd /initrd.img-2.6.32-5-686</screen>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Destaque a linha

	    <screen>kernel /vmlinuz-2.6.32-5-686 root=/dev/hda6 ro</screen>

	    pressione a tecla <keycap>e</keycap> e substitua
	    <literal>hd<replaceable>X</replaceable></literal> por
	    <literal>sd<replaceable>X</replaceable></literal>
	    (<varname>X</varname> sendo a letra
	    <literal>a</literal>, <literal>b</literal>,
	    <literal>c</literal> ou <literal>d</literal> dependendo do
	    seu sistema). Em meu exemplo a linha se torna:

	    <screen>kernel /vmlinuz-2.6.32-5-686 root=/dev/sda6 ro</screen>

	    Então pressione <keycap>Enter</keycap> para gravar a
	    modificação. Se outras linhas apresentam
	    <literal>hd<replaceable>X</replaceable></literal>, mude
	    essas linhas também. Não modifique a entrada semelhante a
	    <literal>root (hd0,0)</literal>. Uma vez que todas as
	    modificações foram feitas, pressione a tecla <keycap>b</keycap>.
	    E seu sistema deverá agora inicializar como de costume.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Agora que o seu sistema inicializou, você precisa corrigir esse
	    problema permanentemente. Pule para <xref
	    linkend="avoid-problems-before-upgrading"/> e aplique um dos
	    dois procedimentos propostos.
	  </para>
	</listitem>
      </orderedlist>
    </section>

    <section id="solution2">
      <title>Solução 2</title>

      <para>
	Inicialize a partir da mídia de instalação do &debian;
	(<acronym>CD</acronym>/<acronym>DVD</acronym>) e quando
	solicitado, escolha <literal>rescue</literal> para iniciar o modo de
  recuperação. Selecione o seu idioma, localização, e mapeamento do
  teclado; então deixe-o configurar a rede (não importa se for bem
  sucedido ou não). Após um tempo, deve ser pedido para selecionar
  a partição que você quer usar como sistema de arquivos raiz.
  As opções propostas irão parecer com algo como:

	<screen>/dev/sda1
/dev/sda2
/dev/sda5
/dev/sda6</screen>
      </para>

      <para>
	Se você souber em qual partição está o seu sistema de arquivos raiz,
  escolha a que for adequada. Se você não souber, apenas tente com a
  primeira. Caso reclame de uma partição inválida de sistema de arquivos
  raiz, tente com a próxima, e assim por diante. Tentar uma após a outra
  não deverá danificar as suas partições e se você tiver apenas um sistema
  operacional instalado no seu disco, você deve encontrar facilmente a
  partição correta do sistema de arquivos raiz. Se você tiver vários
  sistemas operacionais instalados no seu disco, seria melhor saber
  exatamente qual é a partição correta.
      </para>

      <para>
	Uma vez que você escolheu uma partição, será oferecida uma variedade de
  opções. Escolha a opção de execução de um terminal na partição selecionada.
  Caso reclame que não pode fazer isso então tente com outra partição.
      </para>

      <para>
	Agora você deve ter acesso ao shell como usuário <literal>root</literal> no
  seu sistema de arquivos raiz montado no <filename>/target</filename>. Você
  precisa acessar o conteúdo dos diretórios <filename>/boot</filename>,
  <filename>/sbin</filename> e <filename>/usr</filename> no seu disco rígido,
  que agora deve estar disponível sob
	<filename>/target/boot</filename>,
	<filename>/target/sbin</filename> e
	<filename>/target/usr</filename>. Se esses diretórios precisarem
  ser montados a partir de outras partições, então faça.
	(veja o <filename>/etc/fstab</filename> se você não tiver ideia
  de qual partição montar).
      </para>

      <para>
	Pule para <xref linkend="avoid-problems-before-upgrading"/> e
	aplique um dos dois procedimentos propostos para corrigir o problema
  permanentemente. Então digite <literal>exit</literal> para sair do
  terminal de recuperação e selecione <literal>reboot</literal> para
	reinicializar o sistema como de costume (não esqueça de remover a
	mídia inicializável).
      </para>
    </section>

    <section id="solution3">
      <title>Solução 3</title>

      <orderedlist>
	<listitem>
	  <para>
	    Inicialize a partir da sua distribuição LiveCD favorita, tal como Debian
	    Live, Knoppix, ou Ubuntu Live.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Monte a partição aonde está o seu diretório <filename>/boot</filename>.
	    Se você não souber qual delas é, use a saída do comando
      <command>dmesg</command> para descobrir se o seu disco
	    é conhecido como <literal>hda</literal>,
	    <literal>hdb</literal>, <literal>hdc</literal>,
	    <literal>hdd</literal> ou <literal>sda</literal>,
	    <literal>sdb</literal>, <literal>sdc</literal>,
	    <literal>sdd</literal>. Uma vez que você saiba em qual disco
	    trabalhar, por exemplo <literal>sdb</literal>, digite o
	    seguinte comando para ver a tabela de partição do disco
	    e localizar a partição correta:
            <command>fdisk -l /dev/sdb</command>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Supondo que você tenha montado a partição correta sob
	    <filename>/mnt</filename> e que essa partição contém
	    o diretório <filename>/boot</filename> e seu conteúdo,
	    edite o arquivo <filename>/mnt/boot/grub/menu.lst</filename>.
	  </para>
	  <para>
	    Localize a seção semelhante a:
	    <programlisting>## ## End Default Options ##

title           Debian GNU/Linux, kernel 2.6.32-5-686
root            (hd0,0)
kernel          /vmlinuz-2.6.32-5-686 root=/dev/hda6 ro
initrd          /initrd.img-2.6.32-5-686

title           Debian GNU/Linux, kernel 2.6.32-5-686 (single-user mode)
root            (hd0,0)
kernel          /vmlinuz-2.6.32-5-686 root=/dev/hda6 ro single
initrd          /initrd.img-2.6.32-5-686

### END DEBIAN AUTOMAGIC KERNELS LIST</programlisting>

	    e substitua todos <literal>hda</literal>,
	    <literal>hdb</literal>, <literal>hdc</literal>,
	    <literal>hdd</literal> por
	    <literal>sda</literal>, <literal>sdb</literal>,
	    <literal>sdc</literal>, <literal>sdd</literal>, conforme apropriado.
			Não modifique a linha semelhante a:

	    <programlisting>root            (hd0,0)</programlisting>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Reinicialize o sistema, remova o LiveCD e o seu sistema
	    deverá inicializar corretamente.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Quando tiver inicializado, aplique um dos dois
	    procedimentos propostos em <xref
	    linkend="avoid-problems-before-upgrading"/> para corrigir
	    o problema permanentemente.
	  </para>
	</listitem>
      </orderedlist>
    </section>
  </section>
</section>

<section id="for-next">
<title>Preparando-se para a próxima versão</title>
<para>
Após a atualização existem diversas coisas que você pode fazer para
preparar-se para a próxima versão.
</para>
<itemizedlist>
<listitem>
<para>
Remova pacotes obsoletos e não usados como descrito em <xref linkend="obsolete"/>.
Você deve rever que arquivos de configuração eles usam e considerar expurgar
os pacotes para remover seus arquivos de configuração.
</para>
</listitem>
</itemizedlist>

<section id="update-grub" arch="amd64;i386">
<title>Atualização para o GRUB 2</title>
<para>
Durante a atualização, normalmente será oferecida a opção para
"carregar em cadeia" ("chainload") o GRUB 2: ou seja, para manter o GRUB
Legacy como o gerenciador de inicialização principal, mas para adicionar a
ele uma opção para carregar o GRUB 2 e então iniciar o seu sistema &debian;
a partir dele. Isso permite que você verifique se o GRUB 2 funciona no seu
sistema antes de se comprometer a usá-lo permanentemente.
</para>
<para>
Uma vez que você tenha confirmado que o GRUB 2 funciona, você deverá passar
a usá-lo adequadamente: a configuração do carregamento em cadeia é destinada
apenas para ser usada temporariamente.
Você pode fazer isso executando <command>upgrade-from-grub-legacy</command>.
</para>
<para>
O Manual do GRUB tem <ulink
url="http://www.gnu.org/software/grub/manual/grub.html#Changes-from-GRUB-Legacy">mais
informações</ulink> sobre as mudanças entre GRUB Legacy e GRUB 2,
algumas das quais podem exigir mudanças para configurações complexas. Se você
não tiver modificado sua configuração do gerenciador de inicialização, você
não precisa fazer mais nada.
</para>

</section>

</section>

<section id="deprecated">
<title>Componentes obsoletos</title>
<para>
Com a próxima versão do &debian; &nextrelease; (codinome
&nextreleasename;) alguns recursos estarão obsoletos. Os usuários
precisarão migrar para outras alternativas para evitar 
aborrecimento quando atualizar para &nextrelease;.
</para>

<para>
Isso inclui os seguintes recursos:
</para>

<itemizedlist>

<listitem>
<!-- http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=574529
     http://lists.debian.org/debian-devel-announce/2009/10/msg00003.html -->
<para>
OpenVZ e Linux-Vserver: o &debian; &release; será a última versão
a incluir conjuntos de recursos de virtualização do kernel Linux fora da
linha principal. Isso significa que os conjuntos de recursos do OpenVZ e 
Linux-Vserver deverão ser considerados obsoletos, e os usuários deverão
migrar para soluções de virtualização mescladas do upstream linux-2.6
como KVM, Contêineres Linux ou Xen.
</para>
</listitem>

<listitem>
  <para>
    O pacote <systemitem role="package">gdm</systemitem> (Gerenciador de Tela
    do GNOME versão 2.20) se tornará obsoleto pelo <systemitem
    role="package">gdm3</systemitem>, uma versão reescrita. Veja <xref
    linkend="gnome-desktop-changes" /> para mais informações.
  </para>
</listitem>

</itemizedlist>


</section>

<section id="obsolete">
<title>Pacotes obsoletos</title>
<para>
Ao introduzir diversos milhares de novos pacotes, o &releasename; também
aposenta e omite mais de quatro mil pacotes antigos que estavam no
&oldreleasename;. Não é fornecido um caminho de atualização para esses
pacotes obsoletos. Apesar de nada o impedir de continuar a usar um pacote
obsoleto enquanto o desejar, o projeto Debian irá normalmente descontinuar o
suporte de segurança para o mesmo um ano após o lançamento do &releasename;
<footnote><para> Ou enquanto não existir outro lançamento durante esse
período de tempo. Normalmente apenas duas versões estáveis são
suportadas em um dado momento. </para> </footnote>, e não irá fornecer
normalmente outro suporte nesse período. É recomendado substituí-los
por alternativas disponíveis, se houverem.
</para>
<para>
Existem muitas razões pela quais os pacotes podem ter sido removidos da
distribuição: eles não são mais mantidos pelo upstream; não existe mais nenhum
Desenvolvedor Debian interessado em manter os pacotes; a funcionalidade que
eles fornecem foi substituída por um software diferente (ou uma nova versão);
ou eles não são mais considerados adequados para o &releasename; devido a bugs
nos mesmos. Nesse último caso, os pacotes podem ainda estar presentes na
distribuição <quote>unstable</quote>.
</para>
<para>
A detecção de quais pacotes são <quote>obsoletos</quote> em um sistema
atualizado é fácil, já que as interfaces de gerenciamento de pacotes irão
marcá-los como tal. Se você estiver usando o <command>aptitude</command>,
você verá uma lista desses pacotes na entrada <quote>Pacotes Criados Localmente
e Obsoletos</quote>. O <command>dselect</command> fornece uma seção semelhante
mas a lista que ele apresenta pode ser diferente.
</para>
<para>
Além disso, se você tiver usado o <command>aptitude</command> ou
<command>apt-get</command> para instalar pacotes manualmente no &oldreleasename;,
ele terá mantido o registro desses pacotes que você instalou manualmente e 
será capaz de marcar como obsoletos aqueles pacotes obtidos apenas por
dependências que não são mais necessárias se um pacote tiver sido removido.
O <command>aptitude</command> e <systemitem role="package">apt</systemitem>,
ao contrário do <command>deborphan</command>, não marcarão para remoção pacotes
que você instalou manualmente, ao contrário dos que foram instalados
automaticamente por meio de dependências. Para remover automaticamente pacotes
que não sejam mais usados, execute:
</para>
<screen>
# apt-get autoremove
</screen>
<para>
Existem ferramentas adicionais que você pode usar para localizar pacotes
obsoletos tais como <command>deborphan</command>, <command>debfoster</command> ou
<command>cruft</command>. O <command>deborphan</command> é altamente recomendado,
apesar que ele irá (no modo padrão) relatar apenas bibliotecas obsoletas: pacotes
nas seções <quote><literal>libs</literal></quote> ou <quote><literal>oldlibs</literal></quote>
que não sejam usados por quaisquer outros pacotes. Não remova cegamente os
pacotes que estas ferramentas apresentarem, especialmente se você estiver
usando opções agressivas diferentes do padrão, que são propensas a produzir
falsos positivos. É altamente recomendado que você reveja manualmente os
pacotes sugeridos para remoção (i.e. seu conteúdo, tamanho e descrição)
antes que você os remova.
</para>
<para>
O <ulink url="&url-bts;">Sistema de Rastreamento de Bugs</ulink>
frequentemente fornece informações adicionais sobre a razão da remoção do pacote.
Você deveria rever tanto os relatórios de bug arquivados quanto os relatórios de
bug para o <ulink
url="&url-bts;cgi-bin/pkgreport.cgi?pkg=ftp.debian.org&amp;archive=yes">pseudo-pacote
ftp.debian.org</ulink>.
</para>
<!-- FIXME: Review for Squeeze - more obsolete packages probably need to be listed here -->
<!-- TODO: 
Use the following reources for more information:

 - http://alioth.debian.org/~spaillard/udd-release-notes-src-with-RM

 - http://www.klabs.be/~fpiat/linux/comp-dist2/squeeze/
(alternatively)
 - Use the change-release information and sort by popcon 
-->
<para>
  A lista dos pacotes obsoletos inclui:
  <itemizedlist>
    <listitem>
      <para>
      A suíte de gerenciamento de conteúdo <systemitem role="package">plone</systemitem>. 
      Isso foi feito a pedido dos desenvolvedores para usar o Instalador
      Unificado	para Linux, que eles consideram sua única plataforma de
      implantação suportada. A ferramenta recomendada para instalação do
      Plone em um sistema &debian; é o Instalador Unificado, disponível
      para download em <ulink url="http://plone.org/" />
      </para>
    </listitem>
    <listitem>
      <para>
        O <systemitem role="package">nessus</systemitem>, servidor de varredura
        de vulnerabilidades e suas bibliotecas associadas e outros programas.
        Ele ficou obsoleto em favor do software fornecido pela OpenVAS que
        inclui <systemitem role="package">openvas-server</systemitem> e
        <systemitem role="package">openvas-client</systemitem>. Como não
	      existe caminho de atualização automática você terá que instalar
	      o OpenVAS e passar manualmente as configurações do serviço Nessus
	      (usuários, certificados, etc.) para o OpenVAS.
      </para>
    </listitem>
    <listitem>
      <para>
        O sucessor do <systemitem role="package">postgresql-8.3</systemitem>
        é o <systemitem role="package">postgresql-8.4</systemitem>.
      </para>
    </listitem>
    <listitem>
      <para>
        O sucessor do <systemitem role="package">mysql-server-5.0</systemitem>
        é o <systemitem role="package">mysql-server-5.1</systemitem>.
      </para>
    </listitem>
    <listitem>
      <para>
        O sucessor do <systemitem role="package">python2.4</systemitem>
        é o <systemitem role="package">python2.6</systemitem>.
      </para>
    </listitem>
    <listitem>
      <para>
        O software Java 5 inclui os pacotes <systemitem
        role="package">sun-java5-jre</systemitem> e <systemitem
        role="package">sun-java5-bin</systemitem>, o sucessor é o Java 6:
        <systemitem role="package">sun-java6-jre</systemitem> e
        pacotes associados.
      </para>
    </listitem>
    <!-- apt-proxy RM: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=576821 -->
    <listitem>
      <para>
      O <systemitem role="package">apt-proxy</systemitem> não é mais
      fornecido, as alternativas para essa ferramenta incluem
      <systemitem role="package">apt-cacher-ng</systemitem>,
      <systemitem role="package">apt-cacher</systemitem> e
      <systemitem role="package">approx</systemitem>. Embora não
      exista caminho de atualização automática, os usuários do <systemitem
      role="package">apt-proxy</systemitem> podem mudar para essas alternativas
			instalando manualmente qualquer um desses pacotes.
      </para>
    </listitem>
    <listitem>
      <para>
      Alguns dos drivers de vídeo do Xorg não estão mais disponíveis
      no &releasename; e são obsoletos. Isso inclui
      <systemitem role="package">xserver-xorg-video-cyrix</systemitem>,
      <systemitem role="package">xserver-xorg-video-i810</systemitem>,
      <systemitem role="package">xserver-xorg-video-imstt</systemitem>,
      <systemitem role="package">xserver-xorg-video-nsc</systemitem>,
      <systemitem role="package">xserver-xorg-video-sunbw2</systemitem>, e
      <systemitem role="package">xserver-xorg-video-vga</systemitem>.
      Eles podem ser removidos por meio da atualização. Os usuários devem
      instalar o <systemitem role="package">xserver-xorg-video-all</systemitem>
      como alternativa.
      </para>
    </listitem>
    <listitem>
      <para>
      O utilitário usado no &oldreleasename; para exibir uma imagem de abertura
      no momento da inicialização, <systemitem role="package">usplash</systemitem>,
      não está mais disponível. Ele foi substituído pelo
      <systemitem role="package">plymouth</systemitem>.
      </para>
    </listitem>
  </itemizedlist>
</para>

<section id="dummy">
<title>Pacotes fictícios</title>
<para>
Alguns pacotes do &oldreleasename; foram separados em diversos pacotes no
&releasename;, muitas vezes para melhorar a manutenção do sistema. Para
facilitar o caminho de atualização em tais casos, o &releasename; geralmente
fornece pacotes <quote>fictícios</quote>: pacotes vazios que têm o mesmo nome
como nos antigos pacotes do &oldreleasename; com dependências que fazem com
que os novos pacotes sejam instalados. Esses pacotes <quote>fictícios</quote>
são considerados pacotes obsoletos após a atualização e podem ser seguramente
removidos.
</para>
<para>
A maioria (mas não todas) das descrições dos pacotes fictícios indica o seu
propósito. As descrições de pacotes para pacotes fictícios não são uniformes,
entretanto, assim você também pode localizar o <command>deborphan</command>
com as opções <literal>--guess-<replaceable>*</replaceable></literal> (ex.
<literal>--guess-dummy</literal>) úteis para detectá-los em seu sistema.
Note que alguns pacotes fictícios não têm como finalidade serem removidos
após uma atualização mas são, ao invés disso, usados para acompanhar a atual
versão disponível de um programa ao longo do tempo.
</para>
</section>

</section>

</chapter>
