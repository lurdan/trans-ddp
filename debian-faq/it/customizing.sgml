<!-- retain these comments for translator revision tracking -->
<!-- Original version: $Revision: 1.14 $ -->
<chapt id="customizing">Personalizzare la propria installazione di &debian;

<sect id="papersize">Come ci si pu&ograve; assicurare che tutti i programmi usino
  lo stesso formato per la carta?

<p>Si installi il pacchetto <package/libpaper1/ che chieder&agrave; il formato
carta predefinito per tutto il sistema. Questa impostazione sar&agrave;
memorizzata nel file <tt>/etc/papersize</tt>.

<p>Gli utenti possono sovrascrivere l'impostazione del formato carta usando la
variabile d'ambiente <tt>PAPERSIZE</tt>. Per dettagli, si veda la pagina di manuale
<manref name="papersize" section="5">.

<sect id="hardwareaccess">Come si pu&ograve; fornire accesso alle periferiche hardware senza
  compromettere la sicurezza?

<p>Molti file di device nella directory <tt>/dev</tt> appartengono a
gruppi predefiniti. Per esempio, <tt>/dev/fd0</tt> appartiene al gruppo
<tt>floppy</tt> e <tt>/dev/dsp</tt> appartiene al gruppo <tt>audio</tt>.

<p>Se si vuole che un certo utente abbia accesso ad uno di questi
device, si aggiunga l'utente al gruppo a cui appartiene il device, cio&egrave; si faccia:
  <example>adduser utente gruppo</example>
In questo modo non si dovranno cambiare i permessi dei file di device.

<p>Se lo si fa dall'interno di una shell utente o di un ambiente con
interfaccia grafica si deve fare il logout e nuovamente il login per
poter diventare un membro effettivo del gruppo specificato. Per
controllare a quali gruppi si appartiene eseguire <tt>groups</tt>.

<p>Si noti che, a partire dall'introduzione di <tt>udev</tt>, se si
cambiano i permessi di una periferica hardware questi potrebbero essere
modificati all'avvio per alcuni device; se ci&ograve; accade alle periferiche
hardware a cui si &egrave; interessati, sar&agrave; necessario modificare in modo
appropriato le regole in <tt>/etc/udev</tt>.

<sect id="consolefont">Come caricare un tipo di carattere per la console all'avvio nella maniera Debian?

<p>I pacchetti <package/kbd/ e <package/console-tools/ lo supportano:
si modifichi il file <tt>/etc/kbd/config</tt> o <tt>/etc/console-tools/config</tt>.

<sect id="appdefaults">Come si possono configurare le impostazioni
  predefinite per l'applicazione di un programma X11?

<p>I programmi X di Debian installano le loro risorse di applicazione
nella directory <tt>/etc/X11/app-defaults/</tt>. Se si vogliono personalizzare
globalmente le applicazioni X, si mettano le proprie personalizzazioni in questi file. Sono
marcati come file di configurazione, quindi il loro contenuto sar&agrave; preservato durante gli
aggiornamenti.

<sect id="booting">Ogni distribuzione sembra avere un metodo di avvio
  differente. Cosa dire di quello di Debian?

<p>Come tutti gli Unix, Debian si avvia eseguendo il programma <tt>init</tt>.
Il file di configurazione per <tt>init</tt> (che &egrave; <tt>/etc/inittab</tt>)
specifica che il primo script da eseguire dovrebbe essere
<tt>/etc/init.d/rcS</tt>. Questo script esegue tutti gli script in <tt>/etc/rcS.d/</tt>
usando il comando source o generando un sottoprocesso, a seconda della loro
estensione, per effettuare un'inizializzazione come verificare e montare i file system,
caricare moduli, avviare i servizi di rete, impostare l'orologio ed effettuare altre
inizializzazioni. Poi, per compatibilit&agrave;, esegue anche i file
(eccetto quelli con un '.' nel nome del file) in <tt>/etc/rc.boot/</tt>. Ogni
script in quest'ultima directory &egrave; solitamente riservato all'uso da
parte degli amministratori di sistema e il loro uso all'interno di
pacchetti &egrave; deprecato.

<p>Dopo aver completato il processo di avvio, <tt>init</tt> esegue tutti gli script di
avvio dentro una directory specificata dal livello di esecuzione (runlevel) predefinito
(questo runlevel &egrave; dato dalla voce <tt>id</tt> in <tt>/etc/inittab</tt>).
Come la maggior parte degli Unix <!-- all? SGK --> compatibili con il System V, Linux ha
7 runlevel:
<list>
  <item>0 (ferma il sistema),
  <item>1 (modalit&agrave; singolo-utente),
  <item>2 - 5 (varie modalit&agrave; multi-utente) e
  <item>6 (riavvia il sistema).
</list>
I sistemi Debian vengono forniti con id=2, che indica che il runlevel predefinito
sar&agrave; "2" quando si entra nello stato multiutente, e che gli script in
<tt>/etc/rc2.d/</tt> verranno eseguiti.

<p>Di fatto, gli script in ognuna delle directory <tt>/etc/rcN.d/</tt>
sono solo collegamenti simbolici agli script in <tt>/etc/init.d/</tt>. Comunque,
i <em>nomi</em> dei file in ognuna delle directory <tt>/etc/rcN.d/</tt>
sono selezionati per indicare il <em>modo</em> in cui gli script in
<tt>/etc/init.d/</tt> vengono eseguiti. Specificatamente, prima di
entrare in qualsiasi
runlevel, sono eseguiti tutti gli script che iniziano con "K"; questi script uccidono
i servizi. Poi vengono eseguiti tutti gli script che iniziano con "S"; questi script
avviano i servizi. Il numero a due cifre che segue la 'K' o la 'S' indica
l'ordine in cui lo script sar&agrave; eseguito. Gli script con un numero minore sono
eseguiti prima.

<p>Questo approccio funziona perch&eacute; tutti gli script in <tt>/etc/init.d/</tt>
accettano un argomento che pu&ograve; essere "start", "stop", "reload", "restart"
o "force-reload" e svolgeranno poi il compito indicato dall'argomento.
Questi script possono essere usati anche dopo che un sistema &egrave; stato avviato, per
controllare vari processi.

<p>Per esempio, con l'argomento "reload" il comando
  <example>/etc/init.d/sendmail reload</example>
invia al demone sendmail un segnale di rileggere il suo file di configurazione.

<sect id="custombootscripts">Sembra che Debian non usi <tt>rc.local</tt> per personalizzare
  il processo di avvio; che facilitazioni vengono fornite?

<p>Si supponga che un sistema necessiti di eseguire lo script <tt>pippo</tt> all'avvio
o all'ingresso di un particolare runlevel (System V). Allora l'amministratore di sistema
dovrebbe:
<list>
  <item>Mettere lo script <tt>pippo</tt> nella directory <tt>/etc/init.d/</tt>.
  <item>Eseguire il comando Debian <tt>update-rc.d</tt> con gli argomenti
  appropriati, per specificare quali runlevel devono avviare il servizio
  e quali dovrebbero fermarlo.
  <item>Considerare l'opportunit&agrave; di riavviare il sistema per
  controllare che il servizio venga avviato correttamente (nell'ipotesi
  che si sia impostato il suo avvio nel runlevel
  predefinito). Altrimenti avviarlo manualmente eseguendo
  "<tt>/etc/init.d/pippo start</tt>".
</list>

<!-- <p>Il comando <tt>update-rc.d</tt> imposter&agrave; i link tra i file nelle directory -->
<!-- rc?.d e lo script in <tt>/etc/init.d/</tt>. -->
<!-- Ogni link inizier&agrave; con una 'S' o una 'K', seguita da un numero, seguito -->
<!-- dal nome dello script. Gli script in <tt>/etc/rcN.d/</tt> che iniziano con 'S' -->
<!-- vengono eseguiti quando si entra nel runlevel <tt>N</tt>. -->
<!-- Gli script che iniziano con 'K' sono eseguiti quando si lascia il runlevel <tt>N</tt>. -->

<p>Si pu&ograve;, per esempio, fare in modo che lo script <tt>pippo</tt> venga eseguito
all'avvio, mettendolo in <tt>/etc/init.d/</tt> ed eseguendo
<tt>update-rc.d pippo defaults 19</tt>. L'argomento "defaults" fa riferimento
ai runlevel predefiniti, il che significa (almeno in assenza di blocchi di
commento LSB che specifichino diversamente) che il servizio viene
avviato nei runlevel dal 2 al 5 e che viene fermato nei runlevel 0, 1 e
6. (Quasiasi direttiva Default-Start e Default-Stop in <tt>pippo</tt> ha
la precedenza quando si usa la versione sysv-rc di update-rc.d, ma viene
ignorata dalla versione attuale (v0.8.10) di file-rc di update-rc.d.)
L'argomento "19" assicura che <tt>pippo</tt> venga chiamato dopo che
siano stati completati tutti gli script il cui numero &egrave; minore di 19 e
prima di tutti gli script con numero uguale o maggiore di 20.

<sect id="interconffiles">Come si comporta il sistema di manutenzione
dei pacchetti nel caso di pacchetti che contengono file di
configurazione per altri pacchetti? 

<p>Alcuni utenti desiderano creare, per esempio, un nuovo server
installando un gruppo di pacchetti Debian ed un
pacchetto generato localmente che consiste di file di configurazione.
Questa non &egrave; generalmente una buona idea, perch&eacute; <prgn/dpkg/ non sapr&agrave;
nulla di quei file di configurazione se sono in un pacchetto
differente, e potrebbe scrivere configurazioni in conflitto quando uno
dei paccheti del "gruppo" iniziale viene aggiornato.

<p>Piuttosto, si crei un pacchetto locale che modifichi i file
di configurazione del "gruppo" di pacchetti Debian che interessano.
Allora <prgn/dpkg/ e il resto del sistema di gestione dei pacchetti vedono che i
file sono stati modificati dall'"amministratore di sistema" locale e non
cercano di sovrascriverli quando quei pacchetti verranno aggiornati.

<!-- check against dpkg-divert description -->
<sect id="divert">Come sovrascrivere un file installato da un pacchetto in modo che ne venga
  usata una versione differente?

<p>Si supponga che l'amministratore o un utente locale desideri usare un programma
"login-local" piuttosto del programma "login" fornito dal pacchetto <package/login/
di Debian.

<p><strong/Non/:
<list>
  <item>Si sovrascriva <tt>/bin/login</tt> con <tt>login-local</tt>.
</list>
Il sistema di gestione dei pacchetti non sapr&agrave; di questo cambiamento e semplicemente
sovrascriver&agrave; il <tt>/bin/login</tt> personalizzato ogni volta che <tt>login</tt> (o
qualsiasi altro pacchetto che fornisce <tt>/bin/login</tt>) verr&agrave; installato o aggiornato.

<!-- XXX dpkg-divert: is this correct ? -->
<p>Invece,
<list>
  <item>Si esegua:
    <example>dpkg-divert --divert /bin/login.debian /bin/login</example>
  in modo che tutte le future installazioni del pacchetto <package/login/ di Debian
  scrivano il file <tt>/bin/login</tt> in <tt>/bin/login.debian</tt>.
  <item>Poi si esegua:
    <example>cp login-local /bin/login</example>
  per muovere il proprio programma al suo posto.
</list>

<p>Eseguire <tt>dpkg-divert --list</tt> per vedere quali deviazioni
siano attualmente attive sul proprio sistema.

<p>I dettagli sono forniti nella pagina di manuale <manref name="dpkg-divert" section="8">.

<sect id="localpackages">Come si pu&ograve; far s&igrave; che un pacchetto generato
  localmente venga incluso nella
  lista dei pacchetti disponibili che il sistema di gestione dei pacchetti conosce?

<p>Si esegua il comando:

<example>
dpkg-scanpackages BIN_DIR OVERRIDE_FILE [PREFISSOPERCORSO] > mio_Packages
</example>

<p>dove:
  <list>
    <item>BIN-DIR &egrave; la directory dove sono contenuti i file di archivio
    Debian (che solitamente hanno estensione ".deb").
    <item>OVERRIDE_FILE &egrave; un file che viene modificato dai manutentori della distribuzione
    ed &egrave; solitamente situato, per i pacchetti Debian nella sezione
    "main" in <tt>indices/override.main.gz</tt> nell'archivio FTP Debian.
    Pu&ograve; essere ignorato per pacchetti locali.
    <item>PREFISSOPERCORSO &egrave; una stringa <em>opzionale</em> che pu&ograve;
    essere posta prima del file
    <tt>mio_Packages</tt> prodotto. <!-- [NdT: precede il nome del pacchetto nel campo Filename del file -->
    <!-- my_Packages creato] -->
  </list>

<p>Una volta che si &egrave; creato il file <tt>mio_Packages</tt>, si informi il sistema
di gestione dei pacchetti usando il comando:

<example>
dpkg --merge-avail mio_Packages
</example>

<p>Se si sta usando APT, si pu&ograve; anche aggiungere il repository locale al proprio file
<manref name="sources.list" section="5">.

<sect id="diverse">Ad alcuni utenti piace mawk, ad altri gawk; ad alcuni piace vim,
  ad altri elvis; ad alcuni piace trn, ad altri tin; come supporta Debian
  le diversit&agrave;?

<p>Ci sono diversi casi in cui due pacchetti forniscono due versioni
differenti di un programma, che forniscono entrambe le
stesse funzionalit&agrave; fondamentali. Gli utenti possono preferire l'una
rispetto all'altra per abitudine o perch&eacute; l'interfaccia utente di
un pacchetto &egrave; in qualche modo pi&ugrave; piacevole di quella di un altro.
Altri utenti sullo stesso sistema possono fare una scelta differente.

<p>Debian usa un sistema di pacchetti "virtuali" per permettere
agli amministratori di sistema di scegliere (o lasciare che gli utenti
scelgano) i propri strumenti preferiti quando ce ne sono due
o pi&ugrave; che forniscono la stessa funzionalit&agrave; di base pur continuando
ancora a soddisfare i requisiti in termini di dipendenze dei pacchetti
senza specificare un particolare pacchetto.

<p>Per esempio, potrebbero esistere due differenti versioni di lettori di newsgroup
su un sistema. Il pacchetto del server per newsgroup potrebbe
"raccomandare" la presenza di
<em>un qualche</em> lettore di newsgroup sul sistema, ma la scelta tra <tt>tin</tt>
e <tt>trn</tt> &egrave; lasciata all'utente. Ci&ograve; &egrave; realizzato avendo
entrambi i pacchetti <package/tin/ e <package/trn/ che forniscono il pacchetto
virtuale <package/news-reader/. <em>Quale</em> programma venga chiamato
&egrave; determinato da un collegamento che punta dal file con il nome del pacchetto virtuale
<tt>/etc/alternatives/news-reader</tt> al file selezionato,
per esempio <tt>/usr/bin/trn</tt>.

<p>Un solo collegamento &egrave; insufficiente per supportare pienamente l'uso di
un programma alternativo; normalmente, le pagine di manuale e
possibilmente anche altri file di supporto devono essere selezionati.
Lo script Perl <tt>update-alternatives</tt> fornisce un mezzo per assicurarsi che tutti
i file associati con uno specifico pacchetto siano selezionati come i predefiniti di sistema.

<p>Per esempio, per verificare quale eseguibile fornisce "x-window-manager", si esegua:
  <example>update-alternatives --display x-window-manager</example>
Se lo si vuole cambiare, si esegua:
  <example>update-alternatives --config x-window-manager</example>
e si seguano le istruzioni sullo schermo (sostanzialmente si prema il numero
vicino alla voce che si preferisce).

<p>Se, per qualche ragione, un pacchetto non si registra da solo
come un window manager (si segnali il baco se c'&egrave; un errore) o se si usa un
window manager dalla directory /usr/local, le selezioni sullo
schermo non conterranno la propria voce preferita. Si pu&ograve;
aggiornare il collegamento attraverso opzioni da riga di comando, cos&igrave;:
  <example>update-alternatives --install /usr/bin/x-window-manager \
  x-window-manager /usr/local/bin/wmaker-cvs 50</example>

<p>Il primo argomento dell'opzione '--install' &egrave; il collegamento simbolico che
punta a /etc/alternatives/NOME, dove NOME &egrave; il secondo argomento.
Il terzo argomento &egrave; il programma al quale /etc/alternatives/NOME
dovrebbe puntare e il quarto argomento &egrave; la priorit&agrave; (maggiore &egrave; il
valore maggiore &egrave; la probabilit&agrave; che l'alternativa sia scelta automaticamente).

<p>Per rimuovere un'alternativa che si &egrave; aggiunta si esegua semplicemente:
  <example>update-alternatives --remove x-window-manager /usr/local/bin/wmaker-cvs</example>
