<!-- Subversion revision of original English document "3629" -->
<chapt id="customizing">Налаштування вашої &debian;

<sect id="papersize">Як мені переконатись, що всі програми 
  використовують однаковий розмір паперу?

<p>Встановіть пакунок <package/libpaper1/ і він встановить 
однаковий розмір паперу для всієї системи. Ця настройка буде 
збережена у файлі <tt>/etc/papersize</tt>.

<p>Користувачі можуть перепризначити розмір паперу за допомогою 
змінної середовища <tt>PAPERSIZE</tt>. Деталі описано на сторінці 
довідки <manref name="papersize" section="5">.

<sect id="hardwareaccess">Як мені надати доступ до периферійних 
  пристроїв не ставлячи під загрозу безпеку системи?

<p>Багато пристроїв у теці <tt>/dev</tt> належать деяким наперед 
визначеним групам. Наприклад, <tt>/dev/fd0</tt> належить групі 
<tt>floppy</tt>, а <tt>/dev/dsp</tt>&nbsp;— групі <tt>audio</tt>.

<p>Якщо ви хочете дати якомусь користувачеві доступ до цих пристроїв, 
просто включіть його у відповідну групу, наприклад ось таким чином:
  <example>adduser user group</example>
В цьому випадку вам не потрібно буде змінювати права доступу до пристрою.

<sect id="consolefont">Яким чином в Debian задати консольний шрифт
   при завантаженні?

<p>Цю можливість підтримують пакунки <package/kbd/ та <package/console-tools/, 
відредагуйте конфігураційні файли <tt>/etc/kbd/config</tt> або ж 
<tt>/etc/console-tools/config</tt>.

<sect id="appdefaults">Як я можу змінити стандартні настройки додатків для X11?

<p>Графічні програми для Debian записують стандартні налаштування 
додатків у теку <tt>/etc/X11/app-defaults/</tt>. Якщо ви хочете змінити 
їх глобально, запишіть ваші зміни саме у ці файли. Вони позначаються як 
конфігураційні, отож не будуть замінені під час оновлень.

<sect id="booting">Схоже, що кожна збірка завантажується по-своєму. 
  Розкажіть, як це робить Debian.

<p>Як і всі інші Юнікси, Debian завантажується запускаючи програму 
<tt>init</tt>. Її конфігураційний файл (<tt>/etc/inittab</tt>) вказує, 
що першим має виконуватись сценарій <tt>/etc/init.d/rcS</tt>. 
Він запускає всі інші сценарії з теки <tt>/etc/rcS.d/</tt>, виконуючи ї
х безпосередньо, або ж відбруньковуючи, в залежності від їх розширення, 
щоб провести ініціалізацію системи (наприклад, перевірити та змонтувати 
файлові системи, завантажити модулі, запустити мережеві служби, налаштувати 
годинник та ін.). Далі, щоб дотримуватись сумісності, він запускає файли 
(за винятком тих, що містять крапки в назві) з теки <tt>/etc/rc.boot/</tt>. 
Ця тека, зазвичай, вважається зарезервованою для адміністраторських цілей 
і використання його пакунками є ознакою поганого тону.

<p>Після завершення завантажувального процесу <tt>init</tt> запускає 
всі стартові сценарії з теки, котра визначається типовим рівнем запуску 
(який задається відповідним записом <tt>id</tt> у <tt>/etc/inittab</tt>). 
Як і більшість System V-сумісних Юніксів, Linux має 7 рівнів запуску:
<list>
  <item>0 (зупинка системи),
  <item>1 (однокористувацький режим),
  <item>від 2 до 5 (різні багатокористувацькі режими), та
  <item>6 (перезавантаження системи).
</list>
Системи Debian як правило постачаються з id=2. Це означає, що 
типовим рівнем запуску буде '2', з багатокористувацьким режимом, 
при котрому будуть виконані сценарії з теки <tt>/etc/rc2.d/</tt>.

<p>Фактично в теках <tt>/etc/rcN.d/</tt> розташовуються не сценарії, 
а символічні відсилачі на сценарії в теці <tt>/etc/init.d/</tt>. 
Їх <em>назви</em> підбираються таким чином, щоб вказувати, в якій 
<em>послідовності</em> будуть запускатись відповідні сценарії з теки 
<tt>/etc/init.d/</tt>. Взагалі, перед переходом на певний рівень запуску, 
спершу виконуються сценарії, що починаються на літеру 'K'; вони зупиняють 
(англ. kill) непотрібні служби. Далі запускаються всі сценарії, 
що починаються на літеру 'S'; вони власне запускають необхідні служби. 
Двоцифрове число, що йде після 'K' або 'S' вказує на порядок запуску сценарію. 
Сценарії з меншими числами запускаються першими.

<p>Такий підхід працює тому, що сценарії в теці <tt>/etc/init.d/</tt> 
приймають аргументи з набору start, stop, reload, restart 
та force-reload і виконують відповідні завдання (англ. start&nbsp;—
запустити, stop&nbsp;— зупинити, reload&nbsp;— перевантажити, 
restart&nbsp;— перезапустити та force-reload&nbsp;— перевантажити примусово). 
Ці сценарії можуть виконуватись при завантаженні системи для контролю 
різноманітних процесів.

<p>Наприклад, з аргументом reload команда
  <example>/etc/init.d/sendmail reload</example>
відправить демону sendmail сигнал перечитати заново його конфігураційний файл.

(Debian постачає <prgn/invoke-rc.d/ в якості оболонки для запуску сценаріїв з
<tt>/etc/init.d/</tt>.)

<sect id="custombootscripts">Виходить, Debian не використовує 
  <tt>rc.local</tt> для налаштування процесу завантаження; 
  що ж в такому випадку використовується?

<p>Припустимо, при завантаженні чи при зміні рівня запуску нам потрібно 
запускати сценарій <tt>foo</tt>. Системний адміністратор в такому випадку 
повинен:
<list>
  <item>Помістити сценарій <tt>foo</tt> до теки <tt>/etc/init.d/</tt>.
  <item>Запустити команду <tt>update-rc.d</tt> з необхідними аргументами, 
  щоб створити відповідні відсилачі між теками rc?.d та <tt>/etc/init.d/foo</tt> 
  (де '?'&nbsp;— число від 1 до 6, що означає рівень запуску System V).
  <item>Перезавантажити систему.
</list>

<p>Команда <tt>update-rc.d</tt> створює відсилачі на сценарії теки 
<tt>/etc/init.d/</tt> у теці rc?.d. Кожен відсилач починається 
з літери 'S' або 'K', за якими йде номер та власне назва сценарію. 
Сценарії, що починаються на 'S' з теки <tt>/etc/rcN.d/</tt> виконуються 
при завантаженні рівня запуску <tt>N</tt>; ті, що починаються на 'K'&nbsp;—
при його зупинці.

<p>Отож сценарій <tt>foo</tt> можна запустити при завантаженні системи, 
помістивши його в <tt>/etc/init.d/</tt> та встановивши відсилачі за допомогою 
команди <tt>update-rc.d foo defaults 19</tt>. Аргумент 'defaults' позначає 
типові рівні запуску&nbsp;— від 2 до 5. Аргумент '19' вказує, що сценарій запуститься
перед будь-яким іншим, котрий починається з номера 20 або більшого.

<sect id="interconffiles">Що система керування робить з пакунками, котрі 
  містять конфігураційні файли інших пакунків?

<p>Хтось з користувачів може захотіти створити, наприклад, нову службу, 
встановивши групу пакунків Debian та створивши локальний архів, 
з їх конфігураційними файлами. Взагалі-то це не є хорошою ідеєю, 
тому що dpkg не знатиме про конфігураційні файли з такого архіву і може 
перезаписати суперечливі конфігурації при оновленні одного з пакунків такої групи.

<p>Створіть натомість локальний пакунок, що змінює конфігураційні файли 
такої групи пакунків. Після цього <prgn/dpkg/ та інші системи керування
пакунками бачитимуть, що ці файли були модифіковані локальним адміністратором 
та не старатимуться перезаписувати їх при оновленні.

<!-- check against dpkg-divert description -->
<sect id="divert">Як я можу перезаписати файл, встановлений пакунком, 
  так щоб використовувалась інша його версія?

<p>Припустимо, адміністратор, або локальний користувач хочуть 
використовувати програму login-local замість login, 
котра поставляється з пакунком <package/login/.

<p><strong/НЕ/:
<list>
  <item>перезаписуйте файл <tt>/bin/login</tt> програмою <tt>login-local</tt>.
</list>
Система керування пакунками не знатиме про цю зміну і просто перезапише 
ваш модифікований <tt>/bin/login</tt> при будь-якому встановленні чи 
оновленні пакунку <tt>login</tt> (чи будь-якого іншого, котрий постачає 
програму <tt>/bin/login</tt>).

<!-- XXX dpkg-divert: is this correct ? -->
<p>Натомість
<list>
  <item>виконайте:
    <example>dpkg-divert --divert /bin/login.debian /bin/login</example>
  для того, щоб змусити всі наступні встановлення пакунку <package/login/ 
  записувати файл <tt>/bin/login</tt> у <tt>/bin/login.debian</tt>.
  <item>після цього запустіть:
    <example>cp login-local /bin/login</example>
  щоб помістити вашу власну програму на потрібне місце.
</list>

<p>За детальнішою інформацією зверніться до сторінки підручника 
<manref name="dpkg-divert" section="8">.

<sect id="localpackages">Як мені додати свій пакунок до списку відомих 
  системі керування пакунками?

<p>Запустіть команду:

<example>
dpkg-scanpackages BIN_DIR OVERRIDE_FILE [PATHPREFIX] > my_Packages
</example>

<p>де:
  <list>
    <item>BIN-DIR&nbsp;— це тека, в котрій зберігаються файли архівів Debian 
    (що як правило мають розширення „.deb“)
    <item>OVERRIDE_FILE&nbsp;— це файл, що редагується супроводжуючими збірок 
    та зберігається як правило на FTP-сайтах архівів Debian як 
    <tt>indices/override.main.gz</tt> для пакунків зі збірки main. 
    Для локальних пакунків ви можете ігнорувати цю опцію.
    <item>PATHPREFIX&nbsp;— це <em>необов'язковий</em> ланцюжок, що може бути доданий 
    до файлу <tt>my_Packages</tt> при його створенні.
  </list>

<p>Після того, як ви сформуєте файл <tt>my_Packages</tt>, накажіть системі керування 
пакунками використовувати його за допомогою команди:

<example>
dpkg --merge-avail my_Packages
</example>

<p>Якщо ви використовуєте АРТ, ви також можете додати локальне сховище 
до вашого файлу <manref name="sources.list" section="5">.

<sect id="diverse">Деяким користувачам подобається mawk, іншим gawk; 
одні користуються vim, інші elvis; дехто уподобав trn, а дехто tin; 
як Debian підтримує такі різноманітності?

<p>Є декілька випадків, коли два пакунки забезпечують дві різні варіації
програм, кожна з котрих володіє однаковою базовою функціональністю. 
Користувачі по якихось причинах можуть надавати перевагу одній перед 
іншою. В той же час інші користувачі на тій самій системі можуть мати
інші вподобання.

<p>Debian використовує „віртуальну“ систему пакунків, щоб дозволити адміністраторам
(або дати можливість користувачам) обирати улюблені 
інструменти за наявності двох чи більше програм, котрі пропонують 
однакову базову функціональність, підтримуючи при цьому залежності 
без вказування конкретного пакунку.

<p>Наприклад, у системі є дві різні версії програм для читання новин. 
Пакунок серверу новин може рекомендувати <em>котрусь</em> із них, 
але кінцевий вибір між <tt>tin</tt> та <tt>trn</tt> робить кожен 
користувач особисто. Це забезпечується тим, що обидва ці пакунки 
забезпечують віртуальний пакунок <package/news-reader/. Котру з програм 
використовувати вказує відсилач <tt>/etc/alternatives/news-reader</tt> 
на вибраний файл, наприклад <tt>/usr/bin/trn</tt>.

<p>Сам по собі відсилач не здатен підтримувати повноцінне використання 
альтернативних програм; зазвичай сторінки довідки та можливо інші 
використовувані файли також повинні підтримуватись. Сценарій Perl 
<tt>update-alternatives</tt> дає можливість переконатись, що всі файли, 
пов'язані з певним пакунком, вибрані як типові для системи.

<p>Наприклад, щоб перевірити, які файли забезпечує x-window-manager, запустіть:
  <example>update-alternatives --display x-window-manager</example>
Якщо ви хочете щось змінити, виконайте:
  <example>update-alternatives --config x-window-manager</example>
та дотримуйтесь інструкцій на екрані (як правило, натискайте номер елементу, 
котрий вам більше подобається).

<p>Якщо з якоїсь причини пакунок не зареєстрував себе, як віконний менеджер, 
або ж ви хочете використовувати менеджер з теки /usr/local, то екранне меню 
не буде містити потрібного вам елементу. Ви можете оновити конфігурацію 
за допомогою опцій командного рядка, як наприклад:
  <example>update-alternatives --install /usr/bin/x-window-manager \
  x-window-manager /usr/local/bin/wmaker-cvs 50</example>

<p>Перший аргумент опції '--install' є символічним відсилачем, що вказує 
на /etc/alternatives/ІМ'Я, де ІМ'Я&nbsp;— другий аргумент. Третій аргумент&nbsp;— 
це програма, на котру повинен вказувати /etc/alternatives/ІМ'Я, четвертий&nbsp;—
пріоритет (чим більше значення, тим вища ймовірність автоматичного вибору 
даної програми).

<p>Щоб видалити додану альтернативу, просто запустіть:
  <example>update-alternatives --remove x-window-manager /usr/local/bin/wmaker-cvs</example>
