<!-- Files and File Systems: Havoc Pennington -->

      <p>This chapter describes how to manipulate files on your Debian
      GNU/Linux system, how those files are organized into
      <em>filesystems</em>, and how to use physical devices which
      store files (such as your hard disk).

      <sect id="files-basics"> Basic Concepts <p> Before describing
	  any actual file-manipulation tasks, there are some general
	  points to make about files.  Let's look at some files on a
	  Debian system:

	  <taglist>
	    <tag> <tt>/</tt> <item> A simple <tt>/</tt> represents the
		root directory. All other files and directories are
		contained in the root directory.

	    <tag> <tt>/home/janeq</tt> <item> This is the home
		directory of user "janeq". Reading left to right, to
		get to this directory you start in the root directory,
		enter directory <tt>home</tt>, then enter directory
		<tt>janeq</tt>.

	    <tag> <tt>/etc/X11/XF86Config</tt> <item> This is the
		configuration file for the X Window System. It resides
		in the <tt>X11</tt> subdirectory of the <tt>/etc</tt>
		directory. <tt>/etc</tt> is in turn a subdirectory of
		the root directory, <tt>/</tt>.
		
	  </taglist>
	  
	<p> Things to note:
	  <list>
	    <item>Each file or directory is designated by a
		<em>path</em>, or sequence of directories which must
		be passed through to reach it. All paths begin with
		the "root" directory.  There's a <tt>/</tt> between
		each directory or file in the path.
		
	    <item> The root directory is referred to as simply
		<tt>/</tt>. Don't confuse this "root" with the root
		user, the user on your system with "super powers." 

	    <item> Directories are arranged according to a tree
		metaphor. All paths start with the root directory. The
		root directory has a number of branches, such as
		<tt>/etc</tt> and <tt>/home</tt>. These subdirectories
		in turn branch, into still more subdirectories. The
		whole thing together is called the "directory tree." 

	      <p>You can think of a path as a route from the base of
		the tree (<tt>/</tt>) to the end of some branch (a
		file). You'll also hear people talk about the
		directory tree as if it were a <em>family</em> tree:
		thus subdirectories have "parents," and a path shows
		the complete ancestry of a file.

	    <item> There's no directory that corresponds to a physical
		device, such as your hard disk. This differs from DOS
		and Windows, where all paths begin with a device name
		such as <tt>C:\</tt>. The directory tree is meant to be
		an abstraction of the physical hardware, so you can
		use the system without knowing what the hardware
		is. All your files could be on one disk - or you could
		have 20 disks. You can't tell just by looking at the
		directory tree, and nearly all commands work just the
		same way no matter what device(s) your files are
		really on.

	    <item> Every directory except <tt>/</tt> has a name, which
		can contain any letters or symbols <em>except</em>
		<tt>/</tt>.  

		<footnote> While you <em>can</em> use
		    almost anything in a file name, in practice it's a bad
		    idea. You want to avoid any characters that often have
		    special meanings, including: <tt>{ } ( ) [ ] ' ` " \ /
		      &gt &lt | ; ! # & ^ * % @</tt> <p> Also avoid putting
		    spaces in filenames. If you want to separate words in
		    a name, good choices are the period, hyphen, and
		    underscore. You can also capitalize each word,
		    <tt>LikeThis</tt>.
		</footnote>

	    <item> Filenames are case sensitive. That is,
		<tt>README</tt> and <tt>readme</tt> are different
		files.

	  </list>

	<p> Don't worry if all this isn't completely clear yet. There
	  are many examples to come.

      </sect>

      <sect id="files-commands"> Basic file commands - a tutorial
	<p>
	  To use your system you'll have to know how to create, move,
	  rename, and delete files and directories. You'll do this
	  from the <em>shell prompt</em>, which on Debian defaults to
	  <tt>&dollar </tt>. For the tutorials in this chapter, we'll
	  assume you've already logged in, <em>not</em> as root, and
	  that you're looking at the <tt>&dollar </tt> prompt. 

	<p> The best way to learn is to try things. As long as you
	  aren't root (and haven't yet created any important files),
	  there's nothing you can mess up too seriously. So jump in -
	  type each of these commands at the prompt and press enter:

	  <enumlist>
	    <item> <tt>pwd</tt> <p> <tt>pwd</tt> stands for Present
		Working Directory. You should see the name of the
		directory you're in on the screen - probably
		<tt>/home/yourname</tt>.

	    <item> <tt>ls</tt> <p> <tt>ls</tt> stands for "list," as
		in "list files." When you type <tt>ls</tt>, you should
		see a list of all the files in your present working
		directory. If you've just installed Debian, your home
		directory may well be empty. If your present working
		directory is empty, <tt>ls</tt> will not show anything
		on the screen.

	    <item> <tt>cd /</tt> <p> <tt>cd</tt> means Change
		Directory. In this case, you've asked to change to the root
		directory. Type <tt>pwd</tt> again, and verify that you're
		presently working in the root directory. Type <tt>ls</tt>,
		and see what's in <tt>/</tt>.

	    <item> <tt>cd</tt> <p> Typing <tt>cd</tt> by itself takes you
		to your home directory - <tt>/home/yourname</tt>. Try
		<tt>pwd</tt> to verify this.

	    <item> <tt>mkdir practice</tt> <p> In your home directory,
		let's make a directory called <tt>practice</tt>. We'll use
		this directory to try out some other commands. You might
		type <tt>ls</tt> to verify that your new directory exists.

	    <item> <tt>cd practice</tt> <p> Change directory to
		<tt>practice</tt>.

	    <item> <tt>mkdir mysubdirectory</tt> <p> Create a subdirectory
		of <tt>practice</tt>.

	    <item> <tt>cp /etc/profile .</tt> <p> OK, things just got
		more complicated! <tt>cp</tt> is short for "copy."
		<tt>/etc/profile</tt> is just a random file on your
		system, don't worry about what it is for now. We've
		copied it to <tt>.</tt> - but what's <tt>.</tt>?
		<tt>.</tt> just means "the directory I'm in now," or
		present working directory. So we've created a copy of
		<tt>/etc/profile</tt>, and put it in our
		<tt>practice</tt> directory. Try typing <tt>ls</tt> to
		verify that there's indeed a file called
		<tt>profile</tt> in the present working directory.

	    <item> <tt>more profile</tt> <p> <tt>more</tt> is used to
		view the contents of text files, such as
		<tt>/etc/profile</tt>. It's called <tt>more</tt> because
		it shows a page of the file at a time, and you press the
		space bar to see more. <tt>more</tt> will exit when you
		get to the end of the file, or when you type <tt>q</tt>
		(quit). You might try typing <tt>more /etc/profile</tt> as
		well, to verify that your copy looks just like the
		original.

	    <item> <tt>mv profile mysubdirectory</tt> <p> As you might
		guess, <tt>mv</tt> stands for "move." We've moved the file
		<tt>profile</tt> from the current directory into the
		subdirectory we created earlier. Perhaps type <tt>ls
		</tt> and/or <tt>ls mysubdirectory</tt> to verify the
		move.

	    <item> <tt>cd mysubdirectory</tt> <p> Change to the
		subdirectory.

	    <item> <tt>mv profile myprofile</tt> <p> <tt>mv</tt> is
		also used to rename files - by moving them to a new
		name. Thus there's no separate <tt>rename</tt>
		command. Note that the second argument to <tt>mv</tt>
		can be a directory to move the file or directory into,
		or a new filename. <tt>cp</tt> works the same way.
		<p>As usual, you can type <tt>ls</tt> to see the
		result of <tt>mv</tt>.

	    <item> <tt>mv myprofile ..</tt> <p> Just as <tt>.</tt> means
		"the directory I'm in now," <tt>..</tt> means "parent of
		the current directory," in this case the <tt>practice</tt>
		directory we created earlier. Use <tt>ls</tt> to verify
		that that's where <tt>myprofile</tt> is now.

	    <item> <tt>cd ..</tt> <p> Change directories to the parent
		directory - in this case <tt>practice</tt>, where you
		just put <tt>myprofile</tt>.

	    <item> <tt>rm myprofile</tt> <p><tt>rm</tt> means
		"remove" - this deletes <tt>myprofile</tt>. Be careful!
		Deleting a file on a GNU/Linux system is
		<em>permanent</em> - there is no undelete. If you
		<tt>rm</tt> it, it's gone, forever.

	    <item> <tt>rmdir mysubdirectory</tt> <p><tt>rmdir</tt> is
		just like <tt>rm</tt>, only it's for directories. Notice
		that <tt>rmdir</tt> only works on empty directories - if
		the directory contains files, you must delete those files
		first, or alternatively use <tt>rm -r</tt> in place of
		<tt>rmdir</tt>.

	    <item> <tt>rmdir .</tt> <p> Oops! That didn't work. You
		can't delete a directory you're currently working in.

	    <item> <tt>cd ..</tt> <p> So move out of the current
		directory, and into its parent directory. Now you can
		type:

	    <item> <tt>rmdir practice</tt> <p> This will delete the last
		remnants of your practice session.

	  </enumlist>

	  <p>So now you know how to create, copy, move, rename, and delete
	  files and directories. You also learned some shortcuts, like
	  typing simply <tt>cd</tt> to jump to your home directory, and
	  <tt>.</tt> and <tt>..</tt> to refer to the current directory and
	  its parent, respectively.

      <sect id="files-structure"> What files are on my Debian system?
	  Where should I put my own files?

	<p>Now that you can navigate the directory tree, let's take a
	  guided tour of the files and directories you created when
	  you installed Debian. If you're curious, <tt>cd</tt> to each
	  directory and type <tt>ls</tt> to see its contents. If the
	  listing doesn't fit on the screen, try <tt>ls | more</tt>,
	  where <tt>|</tt> is the "pipe" character, generally found on
	  the same key with backslash.

	  <taglist>
	    <tag> <tt>/</tt> <item> As already mentioned, this is the root
		directory, which contains every other directory.

	    <tag> <tt>/root</tt> <item> But don't get <tt>/</tt> confused
		with <tt>/root</tt>! <tt>/root</tt> is the home directory of
		the root user, or superuser. It's a directory called
		<tt>/root</tt>, but it isn't <em>the</em> root directory
		<tt>/</tt>.

	    <tag> <tt>/home</tt> <item> This is where all normal users
		- that is, all users except root - have their home
		directories. Home directories are named after the user
		who owns them. If you're using a large system at a
		school or business, your system administrator may
		create additional directories to contain home
		directories: <tt>/home1</tt> and <tt>/home2</tt> for
		example.

	      <p> Your home directory is where you put all your
		personal work, email and other information, and
		personal configuration preferences.

	    <tag> <tt>/bin</tt> <item> This directory contains "binaries,"
		executable files which are essential to the operation of the
		system. Examples are: the shell (<tt>bash</tt>), and the
		commands you just learned such as <tt>cp</tt>.

	    <tag> <tt>/sbin</tt> <item> This directory contains "system
		binaries," things that the root user or system administrator
		might want to use, but probably you won't want to use in
		your day-to-day activities.

	    <tag> <tt>/usr</tt> <item> <tt>/usr</tt> contains most of
		the files you'll be interested in. It has many
		subdirectories: <tt>/usr/bin</tt> and
		<tt>/usr/sbin</tt> are pretty much like <tt>/bin</tt>
		and <tt>/sbin</tt>, except that the directories in
		<tt>/usr</tt> are not considered "essential to the
		operation of the system." 

		<p> While not essential to get the computer
		operating,<tt>/usr</tt> does contain the applications
		you'll use to get real work done. Also in
		<tt>/usr</tt> you'll find the <tt>/usr/man</tt>,
		<tt>/usr/info</tt>, and <tt>/usr/doc</tt> directories
		- these contain manual pages, info pages, and other
		documentation, respectively. And don't forget
		<tt>/usr/games</tt>!

	    <tag> <tt>/usr/local</tt> <item> The Debian system doesn't
		install anything in this directory. You should use it
		if you want to install software that you compile
		yourself, or any software not contained in a Debian
		package. You can also install software in your home
		directory, if you'll be the only one using it.

	    <tag> <tt>/etc</tt> <item> <tt>/etc</tt> contains all the
		system-wide configuration files. Whenever you want to
		change something that affects all users of your
		computer - such as how you connect to the internet, or
		what kind of video card you have - you'll probably
		have to log on as root and change a file in
		<tt>/etc</tt>.

	    <tag> <tt>/tmp</tt> <item> Here you'll find temporary files,
		most of them created by the system. This directory is
		generally erased on a regular basis, or every time you
		reboot the system. You can create files here if you want,
		just be aware they might get deleted automatically.

	    <tag> <tt>/var</tt> <item> <tt>/var</tt> contains "variable"
		files, that the system changes automatically. For example,
		incoming mail is stored here. The system keeps a log of its
		actions here. There are a number of other automatically
		generated files here as well. You'll mostly be interested in
		the contents of <tt>/var/log</tt>, where you can find error
		messages and try to figure out what you're system's up to if
		something goes wrong.

	  </taglist>

	<p>
	  Clearly there are many more directories on the system, too
	  many to describe every one. We'll get to some of them later in
	  the manual.

	<p>
	  For changing things, you'll usually want to confine yourself
	  to your home directory and <tt>/etc</tt>. On a Debian
	  system, there's rarely an occasion to change anything else,
	  because everything else is automatically installed for you.

	<p> <tt>/etc</tt> is used to configure the <em>system</em> as a
	  whole. You'll use your own home directory, a subdirectory of
	  <tt>/home</tt>, for configuring your own preferences, and
	  storing your personal data. The idea is that on a day-to-day
	  basis you confine yourself to <tt>/home/yourname</tt>, so
	  there's no way you can break anything. Occasionally you log in
	  as root to change something in a system-wide directory, but
	  only when absolutely necessary. Of course, if you're using
	  Debian at a school or business and someone else is the
	  system administrator, you won't have root access and will
	  only be able to change your home directory.

      </sect>


      <sect id="files-permissions"> File ownership and permissions

	<p> GNU and Unix systems are set up to allow many people to use the
	  same computer, while keeping certain files private or
	  keeping certain people from modifying certain files. You can
	  verify this for yourself:

	  <enumlist>
	    <item> Log in as yourself, i.e. <em>NOT</em> as root.

	    <item> <tt>rm /etc/resolv.conf</tt> <p> You should be told
		"Permission denied." <tt>/etc/resolv.conf</tt> is an
		essential system configuration file - you aren't allowed
		to change or remove it unless you're root. This keeps you
		from accidentally messing up the system, and if the
		computer is a public one such as at an office or school,
		it keeps users from messing up the system on purpose.

	  </enumlist>

	<p>Now type <tt>ls -l /etc/resolv.conf</tt>  <p> This should
	  give you output that looks something like this:
	  
<example>
-rw-r--r-- 1 root root 119 Feb 23 1997 /etc/resolv.conf
</example>
	  
	  The <tt>-l</tt> option to <tt>ls</tt> requests all that
	  additional information.  The info on the right is easy - the
	  size of the file is 119 bytes, the date the file was last
	  changed is Feb 23 1997, the file's name is
	  <tt>/etc/resolv.conf</tt>. On the left side of the screen,
	  things get a little more complicated.

	<p> First, the brief, technical explanation: the
	  <tt>-rw-r--r--</tt> is the <em>mode</em> of the file, the
	  <tt>1</tt> is the number of hard links to this file (or the
	  number of files in a directory), and the two <tt>root</tt> are
	  the user and group owning the file.

	<p> So that was cryptic. Let's go through it slowly (except
	the hard links part - for that see <ref
	id="files-advanced-hardlinks">).

	<sect1 id="files-permissions-groups"> Groups
	    
	  <p> Every file has two owners - a user, and a group. The
	    above case is a little confusing, since there's a group
	    called <tt>root</tt> in addition to the <tt>root</tt>
	    user. Groups are just collections of users who are
	    collectively permitted access to some part of the system.
	    A good example is a <tt>games</tt> group. Just to be mean,
	    you might set up your system so that only people in a
	    <tt>games</tt> group are allowed to play games.

	  <p> A more practical example: say you're setting up a
	    computer for a school.  You might want certain files to be
	    accessible only to teachers, not students, so you put all
	    the teachers in a single group. Then you can tell the
	    system that certain files belong to members of the group
	    <tt>teachers</tt>, and that no one else can access those
	    files. Here are some things you can do to explore groups
	    on your system:
	    
	  <enumlist>

	    <item> <tt>groups</tt> <p> Typing this at the shell prompt
		will tell you what groups you're a member of. It's likely
		that you're a member of only one group, which is identical
		to your username. (FIXME: find what the explanation for
		this is)

	    <item> <tt>more /etc/group</tt> <p> This file lists the
		groups that exist on your system. Notice the
		<tt>root</tt> group (the only member of this group is
		the root user), and the group which corresponds to
		your username. There are also groups like
		<tt>dialout</tt> (users who are allowed to dial out on
		the modem), and <tt>floppy</tt> (users who can use the
		floppy drive). However, your system is probably not
		configured to make use of these groups - it's likely
		that only root can use the floppy or the modem right
		now. For details about this file, try typing <tt>man
		group</tt>.

	    <item> <tt>ls -l /home</tt> <p> Observe how every user's
		directory is owned by that user and that user's personal
		group. (If you just installed Debian, you may be the
		only user.)

	  </enumlist>

	</sect1>
	
	<sect1 id="files-permissions-mode"> Mode
 
	<p> In addition to being owned by one user and one group, every
	  file and directory also has a mode, which determines who's
	  allowed to read, write, and execute the file. There are a few
	  other things also determined by the mode, but they're advanced
	  topics so we'll skip them for now.

	<p> The mode looks like this in the <tt>ls</tt> output:
	  <tt>-rw-r--r--</tt>. There are ten "spaces" here, but the mode
	  actually consists of twelve bits (think of bits as switches
	  which can be on or off). For now, we'll consider only nine of
	  these bits: those that control read, write, and execute
	  permissions for the user owning the file, the group owning the
	  file, and everyone on the system (sometimes called
	  "world"). Notice that three kinds of permission (read, write,
	  execute) times three sets of people who can have permission
	  (user, group, others) makes a total of nine combinations.

	<p> In the mode line, the first "space" gives the type of the
	  file. The <tt>-</tt> in this case means it's a regular
	  file. If it was <tt>d</tt>, we'd be looking at a
	  directory. There are other possibilities too complex to go
	  into now (see <ref id="files-advanced-types">).

	<p> The remaining nine "spaces" are used to display the 12
	  bits that make up the file's mode. The basic 9 bits (read,
	  write, and execute for user, group, and other) are displayed
	  as three blocks of <tt>rwx</tt>. So if all permissions are
	  turned on, the mode will look like this:
	  <tt>-rwxrwxrwx</tt>. (The remaining three bits are displayed
	  by changing the <tt>x</tt> to <tt>s</tt>, <tt>t</tt>,
	  <tt>S</tt>, or <tt>T</tt>, but this is a complex topic we're
	  saving for later.)

	<p> In this context, "read", "write", and "execute" have the
	  following meanings:

	  <list>
	    <item> Read permission, indicated by <tt>r</tt>, gives
		permission to examine the contents of a file. For
		directories, it gives permission to list the contents of
		the directory.

	    <item> Write permission, indicated by <tt>w</tt>, gives
		permission to make changes to a file. For directories, it
		gives permission to create and remove files in the
		directory.

	    <item> Execute permission, indicated by <tt>x</tt>, gives
		permission to run the file as a command. Clearly it only
		makes sense to set execute permission if the file actually
		is a command. 

		<p> Since directories can never be executed, the
		  execute bit has a different meaning. For directories,
		  execute permission means permission to access files in the
		  directory. Note that this interacts with write
		  permissions: execute permissions must be set to be able to
		  access files in a directory <em>at all</em>, so without
		  execute permission on a directory, write permission is
		  useless. Execute permission for directories is often
		  called "search" permission, since it really has nothing to
		  do with execution. "File access" permission would probably
		  be a still better name, but no one uses it.
	  </list>

	  <p> Directory modes are a little confusing, so here are some
	  examples of the effects of various combinations:

	  <list>
	    <item> <tt>r--</tt> <p> The user, group, or other with
		these permissions may list the contents of the
		directory, but nothing else. The files in the directory
		can't be read, changed, deleted, or manipulated in any
		way. The only permitted action is reading the directory
		itself, that is, seeing what files it contains.

	    <item> <tt>rw-</tt> <p> Write permission has no effect in
		the absence of execute permission, so this mode behaves
		just like the above mode.

	    <item> <tt>r-x</tt> <p> This mode permits the files in a
		directory to be listed, and permits access to those
		files. However, files can't be created or
		deleted. <em>Access</em> means that you can view,
		change, or execute the files as permitted by the
		files' own permissions.

	    <item> <tt>--x</tt> <p> Files in this directory can be
		accessed, but the contents of the directory can't be
		listed, so you have to know what filename you're
		looking for in advance (unless you're a good
		guesser). Files can't be created or deleted.

	    <item> <tt>rwx</tt> <p> You can do anything you want with
		the files in this directory, as long as it's permitted
		by the permissions on the files themselves.

	  </list>

	  <p> Directory write permission determines whether you can delete
	    files in a directory - a read-only file can be deleted, if you
	    have permission to write to the directory containing it. You
	    can't delete a file from a read-only directory, even if you're
	    allowed to make changes to the file. File permissions have
	    nothing to do with deleting files.
	    
	  <p> This also means that if you own a directory you can
	    always delete files from it, even if those files belong to
	    root.
	    
	  <p>Directory execute permission determines whether you have
	    access to files - and thus whether file permissions come
	    into play.  <em> If </em> you have execute permissions to
	    a directory, file permissions for that directory become
	    relevant. Otherwise file permissions just don't matter;
	    you can't access the files anyway.
	    
	  <p> If you have execute permission for the directory, file
	    permissions determine whether you can read the contents of
	    the file, change the file, and/or execute the file as a
	    command.
	    
	  <p> FIXME: Are the next two paragraphs correct?
	    
	  <p> Finally, permission to change permissions on a file or
	    directory is not affected by the permissions of that file
	    or directory. Rather, you can always change the
	    permissions on files or directories that you own, but not
	    on files owned by someone else, as long as you are
	    permitted access to the file. So if you can access a file
	    you own at all (that is, you have execute permission in
	    the directory containing it) then you can change its
	    permissions.
	    
	  <p> This means that you can't permanently remove permissions
	    from yourself because you can always give them back. Say
	    you remove user write permission from a file you own, then
	    try to change the file. It won't be permitted, but you can
	    always give yourself write permission again and
	    <em>then</em> change the file. The only way to lose the
	    ability to change permissions back is to lose access to
	    the file entirely.
	    
	</sect1>


	<sect1 id="files-permissions-tutorial"> Permissions in
	    practice

	  <p> FIXME: This isn't very thorough. However, it seems like
	    it thorough would make it really long and involve making
	    files as root to show the effects of different ownership,
	    etc. and perhaps it's not worth it.
	    
	  <p> To change permissions, we'll use the <tt>chmod</tt> command.

	    <enumlist>
	      
	      <item> <tt>cd; touch myfile</tt> <p> There are a couple of new
		  tricks here. First, you can use <tt>;</tt> to put two
		  commands on one line.  You can type the above as:

<example>
&dollar cd 
&dollar touch myfile
</example>
		or as:
<example>
&dollar cd; touch myfile
</example>

		and the same thing will end up happening.

		<p> Recall that <tt>cd</tt> by itself returns you to your home
		  directory.  <tt>touch</tt> is normally used to change the
		  modification time of the file to the current time, but it
		  has another interesting feature: if the file doesn't exist,
		  <tt>touch</tt> creates the file. So we're using it to create
		  a file to practice with.  Use <tt>ls -l</tt> to confirm that
		  the file has been created, and notice the permissions mode:

<example>
&dollar ls -l 
-rw-r--r-- 1 havoc havoc 0 Nov 18 22:04 myfile
</example>

		  Obviously the time and user/group names will be
		  different when you try it. The size of the file is 0,
		  since <tt>touch</tt> creates an empty
		  file. <tt>-rw-r--r--</tt> is the default permissions
		  mode on Debian (you can change this - see FIXME: add
		  ref to umask).

	      <item> <tt>chmod u+x myfile</tt> <p> This command means to
		  add (<tt>+</tt>) execute (<tt>x</tt>) permissions for the
		  user (<tt>u</tt>) who owns the file. Use <tt>ls -l</tt> to
		  see the effects.
		  
	      <item> <tt>chmod go-r myfile</tt> <p> Here we've subtracted
		  read permission from the group owning the file, and from
		  everyone else (others, <tt>o</tt>). Again use <tt>ls
		    -l</tt> to verify the effects.
		  
	      <item> <tt>chmod ugo=rx myfile</tt> <p> Here we've set
		  (<tt>=</tt>) user, group, and other permissions to read
		  and execute. This sets permissions to <em>exactly</em>
		  what you've specified, and unsets any other
		  permissions. So all <tt>rx</tt> should be set, and all
		  <tt>w</tt> should be unset. Now no one can write to the
		  file.
		  
	      <item><tt>chmod a-x myfile</tt> <p> <tt>a</tt> is a shortcut
		  for <tt>ugo</tt>, or "all". So all the <tt>x</tt>
		  permissions should now be unset.
		  
	      <item> <tt>rm myfile</tt> <p> We're removing the file, but
		  without write permissions.  <tt>rm</tt> will ask if you're
		  sure:
<example>
rm: remove `myfile', overriding mode 0444?
</example>
		  
		  You should respond by typing <tt>y</tt> and pressing
		  enter.  This is a feature of <tt>rm</tt>, not a fact
		  of permissions - permission to delete a file comes
		  from the directory permissions, and you have write
		  permission in the directory. However, <tt>rm</tt>
		  tries to be helpful, figuring that if you didn't
		  want to change the file (and thus removed write
		  permission), you don't want to delete it either, so
		  it asks you.

	  </enumlist>

	<p> What was that <tt>0444</tt> business in the question from
	    <tt>rm</tt>?  Recall that the permissions mode is a
	    twelve-digit binary number, like this:
	    <tt>000100100100</tt>.
	    <tt>0444</tt> is this binary number represented as an
	    octal (base 8) number, which is the conventional way to
	    write a mode. So you can type <tt>chmod 444
	    myfile</tt> instead of <tt>chmod ugo=r myfile</tt>. 
	    See <ref id="files-advanced-permissions-absolute">.

	</sect1>

      </sect>

      <sect id="files-filesystems"> Filesystems

	<p> At this point it's probably a good idea to explain a
	  little theory. In particular, the concept of a
	  <em>filesystem</em>.  <footnote>Some people spell it as two
	  words, i.e. "file system". A quick poll of man pages
	  (<tt>man -k filesystem</tt>, <tt>man -k 'file system'</tt>)
	  reveals about an even split. So I'm spelling it as one
	  word. You can do it however you like. :)
	    </footnote>
	  This is confusing, because it has several meanings.

	  <list>

	    <item> <em>The</em> filesystem refers to the whole
		directory tree, starting with the root directory
		<tt>/</tt>, as described above.

	    <item> A "filesystem" in general means any organization of
		files and directories on a particular physical
		device. "Organization" means the hierarchical directory
		structure, and any other information about files one
		might want to keep track of: their size, who has
		permission to change them, etc. So you might have one
		filesystem on your hard disk, and another one on each
		floppy disk.

	    <item> "Filesystem" is also used to mean a <em>type</em>
		of filesystem.  For example, MS-DOS and Windows 3.1
		organize files in a particular way, with particular
		rules: filenames can only have 8 characters, for
		example, and no permissions information is
		stored. Linux calls this the <tt>msdos</tt>
		filesystem. Linux also has its own filesystem, called
		the <tt>ext2</tt> filesystem (version two of the
		"extended" filesystem). You'll use the <tt>ext2</tt>
		filesystem pretty much all the time, unless you're
		accessing files from another operating system or have
		other special needs.
	  </list>

	<p> Any physical device you wish to use for storing files must
	  have at least one filesystem on it.  This means a filesystem
	  in the second sense - a hierarchy of files and directories,
	  along with information about them. Of course, any filesystem
	  has a type, so the third sense will come into play as
	  well. If you have more than one filesystem on a single
	  device, each filesystem can have a different type - for
	  example, you might have both a DOS partition and a Linux
	  partition on your hard disk.

	<p>It's important to distinguish the filesystem from the
	  low-level format of the disk. In the DOS and Macintosh
	  worlds, the filesystem is called the high-level format. When
	  you format a disk using one of those operating systems,
	  generally you both perform a low-level format and create a
	  file system (high-level format).  On GNU and Unix systems,
	  one generally says simply "format" to mean low-level format,
	  and "making a filesystem" to mean high-level format.

	<p>Formatting has to do with the particulars of the physical
	  device, such as the exact physical location of your data on
	  a floppy disk (on the edge or in the center of the disk for
	  example). The filesystem is the level of organization you
	  have to worry about - names of directories and files, their
	  sizes, etc.

      </sect>


      <sect id="files-devices"> How to access particular devices
      (including hard disk partitions and floppy drives)

	<p> This section describes how to mount a floppy or Zip disk,
	  the <tt>/dev</tt> directory, and distributing the directory
	  tree over multiple physical devices or partitions.

	<sect1 id="files-devices-mounting"> Mounting a filesystem

	  <p> As we said earlier, on a GNU/Linux system there's no
	    necessary correspondence between directories and physical
	    devices, as there is in DOS for example where each drive
	    has its own directory tree beginning with a letter (such
	    as <tt>C:\</tt>).

	  <p> Instead, each physical device such as a hard disk or
	    floppy disk has one or more filesystems on it. In order to
	    make a filesystem accessible, it's assigned to a
	    particular directory in another filesystem. To avoid
	    circularity, the root filesystem (which contains the root
	    directory <tt>/</tt>) is not contained by any other
	    filesystem - you have access to it automatically when you
	    boot Debian.

	    <p> A directory in one filesystem which contains another
	    filesystem is known as a <em>mount point</em>. A mount
	    point is a directory in a first filesystem on one device
	    (such as your hard disk) but which contains a second
	    filesystem, perhaps on another device (such as a floppy
	    disk). To access a filesystem, you must mount it at some
	    mount point.

	  <p> So, for example, you might mount a CD at the mount point
	    <tt>/cdrom</tt>. This means that if you look in the
	    directory <tt>/cdrom</tt>, you'll see the contents of the
	    CD. The <tt>/cdrom</tt> directory itself is actually
	    on your hard disk.  For all practical purposes
	    the contents of the CD become a part of the root
	    filesystem, and when typing commands and using programs it
	    doesn't make any difference what the actual physical
	    location of the files is. You could have created a
	    directory on your hard disk called <tt>/cdrom</tt>, and
	    put some files in it, and everything would behave in
	    exactly the same way. Once you mount a filesystem, there's
	    no need to pay any attention to physical devices.

	  <p> However, before mounting a filesystem, or to actually
	    create a filesystem on a disk that doesn't have one yet,
	    it's necessary to refer to the devices themselves. All
	    devices have names, and these are located in the
	    <tt>/dev</tt> directory. If you type <tt>ls /dev</tt> now,
	    you'll see a pretty lengthy list of every possible device
	    you could have on your Debian system.

	  <p> Possible devices include:

	    <list>

	      <item> <tt>/dev/hda</tt> is IDE drive A, usually called
		  <tt>C:\</tt> on a DOS or Windows system. In general,
		  this will be a hard drive. IDE refers to the type of
		  drive - if you don't know what it means, you probably
		  have this kind of drive, because it's the most common.

	      <item> <tt>/dev/hdb</tt> is IDE drive B, as you might
		  guess. This could be a second hard drive, or perhaps
		  a CD-ROM drive. Drives A and B are the first and
		  second (master and slave) drives on the primary IDE
		  controller. Drives C and D are the first and second
		  drives on the secondary controller.

	      <item> <tt>/dev/hda1</tt> is the first
		  <em>partition</em> of IDE drive A. Notice that
		  different drives are lettered, while specific
		  partitions of those drives are numbered as well.

	      <item> <tt>/dev/sda</tt> is SCSI disk A. SCSI is like
		  IDE, only if you don't know what it is you probably
		  <em>don't</em> have one. They're not very common in
		  home Intel PC's, though they're often used in servers
		  and Macintoshes often have SCSI disks.

	      <item> <tt>/dev/fd0</tt> is the first floppy drive,
		  generally <tt>A:\</tt> under DOS. Since floppy disks
		  don't have partitions, they only have numbers, rather
		  than the letter-number scheme used for hard
		  drives. However, for floppy drives the numbers refer
		  to the drive, and for hard drives the numbers refer to
		  the partitions.

	      <item> <tt>/dev/ttyS0</tt> is one of your serial
		  ports. <tt>/dev</tt> contains the names of many
		  devices, not just disk drives.
	    </list>

	  <p> To mount a filesystem, we want to tell Linux to
	    associate whatever filesystem it finds on a particular
	    device with a particular mount point. In the process, we
	    might have to tell Linux what kind of filesystem to look
	    for.

	</sect1>

	<sect1 id="files-devices-cdromexample"> Example: Mounting a CD-ROM
	  
	  <p> As a simple demonstration, we'll go through mounting a
	    CD-ROM, such as the one you may have used to install
	    Debian. You'll need to be root to do this, so be careful;
	    whenever you're root you have the power to mess up the
	    whole system, rather than just your own files. Also, these
	    commands assume there's a CD in your drive; you should put
	    one in the drive now.
	    
	    <enumlist>

	      <item> <tt>su</tt>
		  <p> If you haven't already, you need to either log
		  in as root or gain root privileges with the
		  <tt>su</tt> (super user) command. If you use
		  <tt>su</tt>, enter the root password when prompted.

	      <item> <tt>ls /cdrom</tt> <p> See what's in the
		<tt>/cdrom</tt> directory before you start. If you
		don't have a <tt>/cdrom</tt> directory, you may have
		to make one using <tt>mkdir /cdrom</tt>.

	      <item> <tt>mount</tt> <p> Typing simply
		  <tt>mount</tt> with no arguments lists the 
		  currently mounted filesystems.

	      <item> <tt>mount -t iso9660 <var>CD device</var> /cdrom</tt>
		  <p> For this command, you should substitute the name
		  of your CD-ROM device for <tt><var>CD device</var></tt> in
		  the above command line. If you aren't sure,
		  <tt>/dev/hdc</tt> is a good guess. If that fails,
		  try the different IDE devices: <tt>/dev/hda</tt>, etc.
		  You should see a message like:

<example>
mount: block device /dev/hdc is write-protected, mounting read-only
</example>

		<p>The <tt>-t</tt> option specifies the type of the
		  filesystem, in this case <tt>iso9660</tt>. Most CDs
		  are <tt>iso9660</tt>. The next argument is the name
		  of the device to mount, and the final argument is
		  the mount point. There are many other arguments to
		  <tt>mount</tt>; see the man page for details. (For
		  example, you could avoid the above message by
		  specifying read-only on the command line.)

		<p> Once a CD is mounted, you may find that your
		  drive tray will not open. You must unmount the CD
		  before removing it.

	      <item> <tt>ls /cdrom</tt> <p> Confirm that
		  <tt>/cdrom</tt> now contains whatever is on the CD in
		  your drive.

	      <item> <tt>mount</tt> <p> Look at the list of
		  filesystems again, noticing that your CD drive is
		  now mounted.

	      <item> <tt>umount /cdrom</tt> <p> This unmounts the
		  CD. It's now safe to remove the CD from the drive. 
		  Notice that the command is <tt>umount</tt> with no
		  "n", even though it's used to u<em>n</em>mount the 
		  filesystem.
		  
	      <item> <tt>exit</tt> <p> Don't leave yourself logged
		  on as root. Log out immediately, just to be safe.

	    </enumlist>

	</sect1>

	<sect1 id="files-devices-fstab"> <tt>/etc/fstab</tt>:
	Automating the mount process
	    
	  <p> The file <tt>/etc/fstab</tt> (it stands for
	    "file system table") contains descriptions of
	    filesystems that you mount often. These filesystems can
	    then be mounted with a shorter command, such as <tt>mount
	      /cdrom</tt>. You can also configure filesystems to mount
	    automatically when the system boots. You'll probably want
	    to mount all of your hard disk filesystems when you boot.
	   
	  <p> Look at this file now, by typing <tt>more
	    /etc/fstab</tt>. It will have two or more entries that
	    were configured automatically when you installed the
	    system. It probably looks something like this:

<example>
# /etc/fstab: static file system information.
#
# &lt;file system&gt     &lt;mount point&gt   &lt;type&gt  &lt;options&gt   &lt;dump &gt  &lt;pass&gt

/dev/hda1            /               ext2    defaults    0       1
/dev/hda3            none            swap    sw          0       0
proc                 /proc           proc    defaults    0       0

/dev/hda5            /tmp            ext2    defaults    0       2
/dev/hda6            /home           ext2    defaults    0       2
/dev/hda7            /usr            ext2    defaults    0       2

/dev/hdc             /cdrom          iso9660 ro          0       0
/dev/fd0             /floppy         auto    noauto,sync 0       0
</example>

	  <p> The first column lists the device the filesystem resides
	  on. The second lists the mount point, the third the
	  filesystem type. The line beginning <tt>proc</tt> is a
	  special filesystem explained in <ref
	  id="files-advanced-proc">. Notice that the swap partition
	  (<tt>/dev/hda3</tt> in the example) has no mount point, so
	  the mount point column contains <tt>none</tt>.
	    
	  <p>The last three columns may require some explanation.

	  <p> The fifth column is used by the <tt>dump</tt> utility to
	    decide when to back up the filesystem. FIXME: cross ref to
	    <tt>dump</tt>

	  <p> The sixth column is used by <tt>fsck</tt> to decide in
	    what order to check filesystems when you boot the
	    system. The root filesystem should have a <tt>1</tt> in
	    this field, filesystems which don't need to be checked
	    (such as the swap partition) should have a <tt>0</tt>, and
	    all other filesystems should have a <tt>2</tt>. FIXME:
	    cross ref to <tt>fsck</tt>, also, is the swap partition
	    really a filesystem?
	    
	  <p> Column four contains one or more options to use when
	    mounting the filesystem. Here's a brief summary (some of
	    these probably won't make much sense yet - they're here
	    for future reference):

	    <taglist>
	      
	      <tag> <tt>async</tt> and <tt>sync</tt> 
	      
	      <item> Do I/O synchronously or
		  asynchronously. Synchronous I/O writes changes to
		  files immediately, while asynchronous I/O may keep
		  data in buffers and write it later, for efficiency
		  reasons.  FIXME: cross ref to section on sync for
		  full explanation. Also, should recommend when to
		  choose one or the other.

	      <tag> <tt>ro</tt> and <tt>rw</tt> 
		
	      <item> Mount the filesystem read-only or read-write.
		  If you don't need to make any changes to the
		  filesystem, it's a good idea to mount it read-only
		  so you don't accidentally mess something up. Also,
		  read-only devices (such as CD-ROM drives and floppy
		  disks with write protection tabs) should be mounted
		  read-only.
		  
	      <tag> <tt>auto</tt> and <tt>noauto</tt> 

	      <item> When the system boots, or whenever you type
		  <tt>mount -a</tt>, <tt>mount</tt> tries to mount all
		  the filesystems listed in <tt>/etc/fstab</tt>. If
		  you don't want it to automatically mount a
		  filesystem, you should use the <tt>noauto</tt>
		  option. It's probably a good idea to use
		  <tt>noauto</tt> with removable media such as floppy
		  disks, because there may or may not be a disk in the
		  drive. You'll want to mount these filesystems
		  manually after you put in a disk.

	      <tag> <tt>dev</tt> and <tt>nodev</tt>
		
	      <item> Use or ignore device files on this
		  filesystem. You might use <tt>nodev</tt> if you
		  mount the root directory of another system on your
		  system - you don't want your system to try to use
		  the devices on the other system.

	      <tag> <tt>user</tt> and <tt>nouser</tt>

	      <item> Permit or forbid ordinary users to mount the
		  filesystem. <tt>nouser</tt> means that only root can
		  mount the filesystem. This is the normal
		  arrangement. You might use the <tt>user</tt> option
		  to access the floppy drive without having to be root.

	      <tag> <tt>exec</tt> and <tt>noexec</tt> 
		
	      <item> Allow or do not allow the execution of files on
		  this filesystem. Probably you won't need these options.
		  
	      <tag> <tt>suid</tt> and <tt>nosuid</tt> 
		
	      <item> Allow or do not allow the suid bit to take
		  effect. Probably you won't need these options. See
		  <ref id="files-advanced-permissions-suid">.

	      <tag> <tt>defaults</tt> 
		
	      <item> Equivalent to: <tt>rw</tt>, <tt>dev</tt>,
		  <tt>suid</tt>, <tt>exec</tt>, <tt>auto</tt>,
		  <tt>nouser</tt>, <tt>async</tt>. You can specify
		  <tt>defaults</tt> followed by other options to
		  override specific aspects of <tt>defaults</tt>.

	    </taglist>
		  
	</sect1>
	
	<sect1 id="files-devices-removable"> Removable disks
	    (floppies, Zip disks, etc.)

	  <p> How to use them - setting things up so you can
	  access them nicely from userspace.

	  <p> FIXME I'm actually not sure how to write this. What's
	    in fstab on a default installation? Should we do the manual
	    su root thing, or one of those EZ floppy mounting packages?
	    Perhaps do something with group permissions? Or just
	    the <tt>user</tt> option in fstab?
				  
	</sect1>

	<sect1 id="files-devices-preparing"> Preparing disks
	    for use: formatting and creating a filesystem
	  <p>
	</sect1>

      </sect>

      <sect id="files-misc"> Miscellaneous topics

	<sect1 id="files-misc-viewing"> Viewing the contents of
	    files

	  <p> There are several ways to look at what's in a file; each
	    one has different uses. 

	  <p> The simplest way is to use <tt>cat</tt>. <tt>cat</tt> is
	    short for "concatenate", and it dumps the contents of
	    files to the screen (actually to the <em>standard
	    output</em>, but that's in another chapter). If you pass
	    it two or more files, it dumps them to the screen in order
	    as if they were one big file - i.e., it concatenates
	    them. However, if you pass it only one file, with the
	    syntax <tt>cat <var>myfile</var></tt>, it simply dumps
	    that file to the screen. Try typing <tt>cat
	    /etc/profile</tt>, to see the contents of that file.

	  <p> The problem with <tt>cat</tt> is that it's just an
	    uncontrolled dump, which is bad if the file is longer than
	    one screen. You can't see the beginning of the file. The
	    solution is the <tt>more</tt> command, which displays a
	    file one page at a time. <tt>less</tt> does the same
	    thing, only it has more features ("less is more"). These
	    are invoked in the same way as <tt>cat</tt>: the command
	    name followed by the filename. You may have to type
	    <tt>q</tt> to exit from <tt>less</tt>, but <tt>more</tt>
	    will exit on its own when you reach the end of the file.

	  <p> These utilities are limited to viewing text files; for
	    viewing the raw form of other kinds of files you might
	    have to use a specialized utility such as <tt>od</tt>
	    (octal dump). For viewing images, word processor
	    documents, and that kind of thing, you'll need to use an
	    appropriate application. There are also many more
	    specialized ways to look at text files: for example, you
	    might look at only the end of the file, or at lines
	    containing a certain word. These more specialized tools
	    will be covered in a later chapter. FIXME: add cross reference

	</sect1>
	
	<sect1 id="files-misc-dotfiles"> Hidden files beginning with
	    <tt>.</tt>
	    
	  <p> On GNU and Unix systems, any file beginning with a
	    period (aka a dot) is normally not visible. You can see
	    them by using the <tt>-a</tt> option to <tt>ls</tt>.

	    <enumlist> 

	      <item> <tt>cd</tt> <p> <tt>cd</tt> to your home
		  directory.  

	      <item> <tt>ls -a</tt> <p> List <em>all</em> files
		  in the directory, even the dotfiles.
	    </enumlist>

	  <p>You should see a number of files, all beginning with a
	    <tt>.</tt>, that you don't normally see when you type
	    <tt>ls</tt>. You'll also see simply <tt>.</tt> and
	    <tt>..</tt>, representing this directory and its
	    parent. If you type <tt>ls -A</tt> with capital A you
	    won't see these two.

	  <p> The reason for dotfiles is that many files have nothing
	    to do with your day to day work - rather, they're used for
	    configuring your applications and storing
	    machine-generated data. Thus, they're hidden out of the
	    way so they don't clutter up the directory. 

	  <p> Dotfiles are somewhat analagous to control panels on a
	    Macintosh, or the <tt>AUTOEXEC.BAT</tt> file under DOS.
	    You can ignore them for now - later in the manual we'll
	    explain how to use some of these files to customize your
	    personal Debian settings.

	  <p> Many dotfiles have a system-wide analogue in the
	    <tt>/etc</tt> directory.  For instance, you may have a
	    <tt>.bash_profile</tt> in your directory. This corresponds to
	    <tt>/etc/profile</tt>. Changes to <tt>/etc/profile</tt> affect
	    everyone, changes to <tt>.bash_profile</tt> affect only you.

	</sect1>

	<sect1 id="files-misc-find"> Finding a file on the system

	  <p>There are two different facilities for finding files:
	    <tt>find</tt> and <tt>locate</tt>. <tt>find</tt> searches
	    the actual files in their present state. <tt>locate</tt>
	    searches an index generated by the system every morning at
	    6:42 a.m. (this is a <tt>cron</tt> job, explained
	    elsewhere in this manual). <tt>locate</tt> won't find any
	    files which were created after the index was
	    generated. However, since <tt>locate</tt> searches an
	    index, it's much faster - like using the index of a
	    book rather than looking through the whole thing.

	  <p>To compare the two ways of finding files, pretend you can't
	    remember where the X configuration file <tt>XF86Config</tt>
	    resides.

	    <enumlist>

	      <item> <tt>locate XF86Config</tt> <p> This should be pretty
		  fast. You'll get a list of filenames which <em>contain</em>
		  <tt>XF86Config</tt>, something like this:
<example>
/etc/X11/XF86Config 
/usr/X11R6/lib/X11/XF86Config
/usr/X11R6/lib/X11/XF86Config.eg
/usr/X11R6/man/man5/XF86Config.5x.gz
</example>

	      <item> <tt>find / -name XF86Config</tt> 

		<p> You will hear a lot of disk activity, and this
		  will take a lot longer. If hearing your disk grind
		  for a long time pains you, you may not want to
		  actually type this command.  Results will look
		  something like this:

<example>
/etc/X11/XF86Config 
/usr/X11R6/lib/X11/XF86Config 
find: /var/spool/cron/atjobs: Permission denied 
find: /var/spool/cron/atspool: Permission denied
find: /var/lib/xdm/authdir: Permission denied
</example>

		<p> Notice that <tt>find</tt> only found files which were
		  named <em>exactly</em> <tt>XF86Config</tt>, rather than any
		  files containing that string of letters. Also, <tt>find</tt>
		  actually tried to look in every directory on the system -
		  including some where you didn't have read permissions. Thus
		  the "Permission denied" messages.  <p> The syntax is
		  different as well. You had to specify what directory to
		  search in - <tt>/</tt> - while locate automatically chose
		  the root directory. And you had to specify a search by name,
		  using the <tt>-name</tt> option.  You could also have
		  searched for files using many other criteria, such as
		  modification date or owner.

	    </enumlist>

	  <p> In general <tt>find</tt> is a more powerful utility, and
	    <tt>locate</tt> is faster for everyday quick searches. The
	    full range of possible searches would take a long time to
	    explain; for more details type <tt>info find</tt>, which will
	    bring up the very thorough info pages on <tt>find</tt> and
	    <tt>locate</tt>.

	</sect1>

	<sect1 id="files-misc-compression"> Compressing files with
	    <tt>gzip</tt>

	  <p> Often it would be nice to make a file smaller: say to
	    download it faster, or so it takes up less space on your
	    disk. The program to do this is called <tt>gzip</tt> (GNU
	    Zip).

	    <enumlist>

	      <item> <tt>cd; cp /etc/profile ./mysamplefile</tt> <p>
		  Switch to your home directory, then copy an arbitrarily
		  chosen file (<tt>/etc/profile</tt>) to your current
		  directory in the process renaming it
		  <tt>mysamplefile</tt>. This gives us a file to play with
		  using <tt>gzip</tt>.

	      <item> <tt>ls -l</tt> <p> List the contents of the current
		  directory.  Note the size of <tt>mysamplefile</tt>.

	      <item> <tt>gzip mysamplefile</tt> <p> Compress <tt>
		    mysamplefile</tt>.

	      <item> <tt>ls -l</tt> <p> Observe the results: <tt>
		    mysamplefile</tt> is now called <tt>mysamplefile.gz
		  </tt>. It's also a good bit smaller.

	      <item> <tt>gunzip mysamplefile.gz; ls -l</tt> <p>
		  Uncompress. Observe that <tt>mysamplefile</tt> has
		  returned to its original state. Notice that to
		  <em>uncompress</em> one uses <tt>gunzip</tt>, not
		  <tt>gzip</tt>.

	      <item> <tt>rm mysamplefile</tt> <p> Remove the file, since
		  it was just to practice with.

	    </enumlist>

	<sect1 id="files-misc-split"> Splitting files into smaller
	    parts 

	  <p> Sometimes a file is too big to fit on a disk, or you
	    don't want to send a huge file over the net in a single
	    chunk. You can split the file using the <tt>split</tt>
	    utility, and reassemble it using the <tt>cat</tt>
	    (con<em>cat</em>enate) utility.
	    
	  <enumlist>
	      <item> <tt>cd; cp /bin/bash myfile; ls -l myfile</tt>
		<p> Copy the <tt>bash</tt> executable to a file in
		  your home directory called <tt>myfile</tt>. Observe that 
		  <tt>myfile</tt> occupies a little over 300,000
		  bytes, or around 300 kilobytes.

	      <item> <tt>split -b100k myfile myprefix</tt>
		<p> Splits the file into sections of 100
		kilobytes, naming the sections <tt>myprefixaa</tt>,
		<tt>myprefixab</tt>, etc. Type <tt>ls -l</tt> so see
		the results.

		<p> You can specify any number after the
		  <tt>-b</tt>: choose one that makes sense. If you
		  leave off the <tt>k</tt>, it will be understood as
		  bytes instead of kilobytes. If you use <tt>m</tt>
		  instead of <tt>k</tt>, it will be understood as
		  megabytes. 

	      <item> <tt>cat myprefix* &gt mynewfile</tt>
		<p> Concatenate all the files and write them to
		<tt>mynewfile</tt>. the <tt>*</tt> and <tt>&gt</tt>
		are tricks you'll learn in a later chapter.

	      <item> <tt>rm myfile mynewfile myprefix*</tt>
		  <p> Remove everything.

	    </enumlist>

	</sect1>


	<sect1 id="files-misc-diskspace"> Managing disk space

	  <p> Probably you don't have all the disk space you might
	    want, and your disks will eventually fill up. This section
	    will describe how to find out how much space there is, and
	    gives some tips on how to open up more space. e.g. finding
	    and sorting files by size, <tt>df</tt>, <tt>du</tt>,
	    strategic gzip, removing unecessary packages.
	</sect1>

	<sect1 id="files-misc-tar"> Backups and large-scale file
	    copying
	    
	  <p> How to use tar to copy lots of files, or back up your
	    files.  Tarballs. I'm thinking this should be a brief
	    section aimed at single-user systems, with a more thorough
	    sysadmin discussion in a different manual.

	    <p>Backup commands (contributed by Oliver Elphick, section to
	    be cleaned up and elaborated):

	    <p>dump - dumps one filesystem at a time; its command options
	    assume that you are using half-inch tape (maximum 45Mb per
	    reel) so it's a bit annoying when using DAT (2Gb or
	    more). Probably the best for regular backups.  Can't be used
	    for NFS-mounted filesystems.

	    <p>cpio - `find [directories] -print | cpio -ovH newc -B
	    >/dev/st0'

	    <p>tar - `tar cvf /dev/st0 [directories]'

	    <p>afio - like cpio; supports pre-compression of files before
	    archiving.

	    <p>tob - front-end for afio

	</sect1>

	<sect1 id="files-misc-guessing"> Guessing a file's contents
	    
	  <p> Debian comes with a utility which can guess at the
	    contents of a file for you. It is not always
	    correct. However, it is reasonably accurate, and you can
	    use it to explore your system.
	    
	    <enumlist> 
	      <item><tt>file /bin/cp</tt> <p> You should see
		  something like this:

<example>
/bin/cp: ELF 32-bit LSB executable, Intel 386, version 1, stripped
</example>

		  Skipping the technical parts, this is an executable
		  file for Intel machines.

	      <item><tt>file /etc/init.d/boot</tt>
		<p> Gives this response:

<example>
/etc/init.d/boot: Bourne shell script text
</example>

		  Meaning that this is a text file, containing a
		  Bourne shell script (see the Shells chapter). 
	    </enumlist>

	<sect1 id="files-misc-umask"> Defining default permissions
	    with <tt>umask</tt>
	    <p>
	</sect1>
	    
      </sect>
      
      <sect id="files-advanced"> Advanced Topics
	  
	<sect1 id="files-advanced-hardlinks"> The real nature of
	    files: hard links and inodes 

	  <p> Each file on your system is represented by an
	    <em>inode</em> (eye-node): an inode contains all the
	    information about the file. However, the inode is not
	    directly visible. Instead, each inode is linked into the
	    filesystem by one or more <em>hard links</em>. Hard links
	    contain the name of the file, and the inode number. The
	    inode contains the file itself, i.e., the location of the
	    information being stored on disk, its access permissions,
	    the type of the file, and so on. The system can find any
	    inode once it has the inode number.

	  <p> A single file can have more than one hard link. What
	    this means is that multiple filenames refer to the same
	    file (that is, they are associated with the same inode
	    number). However, you can't make hard links across
	    filesystems: all hard references to a particular file
	    (inode) must be on the same filesystem. (I'm guessing this
	    is because each filesystem has its own set of inodes, and
	    there will be duplicate inode numbers between filesystems.
	    FIXME: find out why for real)

	  <p> Since all hard links to a given inode are referring to <em>the
	      same file</em>, you can make changes to the file,
	    referring to it by one name, and then see those changes
	    referring to it by a different name. Try this:
	    
	    <enumlist>
	      <item> <tt>cd; echo "hello" &gt firstlink</tt>
		<p> <tt>cd</tt> to your home directory and create
		  a file called <tt>firstlink</tt> containing the word
		  "hello". What you've actually done is redirect the
		  output of <tt>echo</tt> (<tt>echo</tt> just echoes
		  back what you give to it), placing the output in
		  <tt>firstlink</tt>. See the chapter on shells for a
		  full explanation.
		  
	      <item> <tt>cat firstlink</tt> 
		<p> Confirm the contents of <tt>firstlink</tt>.
		  
	      <item> <tt>ln firstlink secondlink</tt>
		<p> Create a hard link: <tt>secondlink</tt> now points to
		  the same inode as <tt>firstlink</tt>.
		  
	      <item> <tt>cat secondlink</tt> 
		<p> Confirm that <tt>secondlink</tt> is the same as
		  <tt>firstlink</tt>
		  
	      <item> <tt>ls -l</tt> 
		<p> Notice that the number of hard links listed for
		  <tt>firstlink</tt> and <tt>secondlink</tt> is 2.
		  
	      <item> <tt>echo "change" &gt&gt secondlink</tt> 
		<p> This is another shell redirection trick - don't
		  worry about the details. We've appended the word
		  "change" to <tt>secondlink</tt>. Confirm this with
		  <tt>cat secondlink</tt>.
		  
	      <item> <tt>cat firstlink</tt> 
		<p> <tt>firstlink</tt> also has the word "change"
		  appended! It's because <tt>firstlink</tt> and
		  <tt>secondlink</tt> refer to <em>the same
		    file</em>. It doesn't matter what you call it
		  when you change it.
		  
	      <item> <tt>chmod a+rwx firstlink</tt> 
		<p> Change permissions on <tt>firstlink</tt>. Do
		  <tt>ls -l</tt> to confirm that permissions on
		  <tt>secondlink</tt> were also changed. This means
		  that permissions information is stored in the
		  inode, not in links.
		  
	      <item> <tt>rm firstlink</tt> <p> Delete this link. This
		is a subtlety of <tt>rm</tt> - it really removes
		links, not files. Now type <tt>ls -l</tt> and notice
		that <tt>secondlink</tt> is still there. Also notice
		that the number of hard links for <tt>secondlink</tt>
		has been reduced to one.
		  
	      <item> <tt>rm secondlink</tt> 
		<p> Delete the other link. When there are no more
		  links to a file, Linux deletes the file itself, that
		  is, its inode. 
	    </enumlist>

	  <p>All files work like this - even special types of files
	    such as devices (e.g. <tt>/dev/hda</tt>). 
	    
	  <p> A directory is simply a list of filenames and inode
	    numbers, that is, a list of hard links. When you create a
	    hard link, you're just adding a name-number pair to a
	    directory. When you delete a file, you're just removing a
	    hard link from a directory.

	  </sect1>
	  
	<sect1 id="files-advanced-types"> Types of files

	  <p> One detail we've been concealing up to now is that Unix
	    considers nearly everything to be a file. That includes
	    directories and devices: they're just special kinds of files.
	    
	    <p> As you may remember, the first letter of an <tt>ls
	    -l</tt> display represents the type of the file. For an
	    ordinary file, this will be simply <tt>-</tt>. Other
	    possibilities are:
	    <list> 
	      <item> <tt>d</tt> (directory)
	      <item> <tt>l</tt> (symbolic link)
	      <item> <tt>b</tt> (block device)
	      <item> <tt>c</tt> (character device)
	      <item> <tt>p</tt> (named pipe)
	      <item> <tt>s</tt> (socket)
	    </list>

	  <sect2 id="files-advanced-types-symlinks"> Symbolic links

	    <p> Symbolic links (also called symlinks or soft links)
	      are the other kind of link besides hard links. A symlink
	      is a file (with its own inode and hard link!) that "points
	      to" a hard link on any mounted filesystem. When you
	      try to read the contents of a symlink, it gives the
	      contents of the file it's pointing to rather than the
	      contents of the symlink itself. Since directories,
	      devices, and other symlinks are types of files, you can
	      point a symlink at any of those things. 

	    <p> So a hard link is a filename and an inode number. A
	      file is really an inode: a location on disk, file type,
	      permissions mode, etc. A symlink is an inode that
	      contains the name of a hard link.

	    <p> All hard links to the same file have equal
	      status. That is, one is as good as the other; if
	      you perform any operation on one it's just the
	      same as performing that operation on any of the
	      others. This is because the hard links all refer to
	      the same inode. Operations on symlinks, on the other
	      hand, sometimes affect the symlink's own inode (the one
	      containing the name of a hard link) and sometimes affect
	      the hard link being pointed to.

	    <p> There are a number of important differences between
	      symlinks and hard links:

	      <list>
		<item> Symlinks can cross filesystems. (I'm guessing
		    this is because they contain complete filenames,
		    starting with the root directory, and all complete
		    filenames are unique. Since hard links contain
		    inode numbers, they would be ambiguous if the
		    filesystem wasn't known. FIXME: find out for real)

		<item> You can make symlinks to directories, but you
		    can't make hard links to them. Directories can
		    have only one hard link: they can be listed in
		    their parent directory. You can't create
		    additional hard links to a directory. Thus, the
		    output of <tt>ls -l</tt> lists the number of hard
		    links <em>in</em> a directory, and the number of
		    hard links <em>to</em> a file.

		<item> You can only make a hard link to a file that
		    exists, because there must be an inode number to refer
		    to. However, you can make a symlink to any
		    filename, whether or not there actually is such a filename.

		<item> Removing a symlink removes only the link. It
		    has no effect on the linked-to file. Removing the
		    only hard link to a file removes the file.
		    
	      </list>

	      <p> Try this:
	      <enumlist>
		<item> <tt>cd; ln -s /tmp/me MyTmp</tt> <p>
		  <tt>cd</tt> to your home directory. <tt>ln</tt> with
		  the <tt>-s</tt> option makes a symbolic link; in
		  this case, one called <tt>MyTmp</tt> which points to
		  the filename <tt>/tmp/me</tt>.

		<item> <tt>ls -l MyTmp</tt> 
		    <p> Output should look like this:

<example>
lrwxrwxrwx   1 havoc    havoc           7 Dec  6 12:50 MyTmp -> /tmp/me
</example>

		    The date and user/group names will be different
		    for you, of course. Notice that the file type is
		    <tt>l</tt>, indicating that this is a symbolic
		    link. Also notice the permissions - symbolic links
		    always have these permissions. If you attempt to
		    <tt>chmod</tt> a symlink, you'll actually change
		    the permissions on the file being pointed to.
		    
		<item> <tt>chmod 700 MyTmp</tt>
		  <p> You should get a "No such file or directory"
		    error, because the file <tt>/tmp/me</tt> doesn't
		    exist. Notice that you could create a symlink to
		    it anyway.
		    
		<item> <tt>mkdir /tmp/me</tt>
		  <p> Create the directory <tt>/tmp/me</tt>.
		    
		<item> <tt>chmod 700 MyTmp</tt>
		  <p> Should work now.
		    
		<item> <tt>touch MyTmp/myfile</tt>
		  <p> Create a file in <tt>MyTmp</tt>.
		    
		<item> <tt>ls /tmp/me</tt>
		  <p> The file was actually created in
		  <tt>/tmp/me</tt>.

		<item> <tt>rm MyTmp</tt>
		  <p> Remove the symbolic link. Notice that this
		    removes the link, not what it points to. Thus you
		    use <tt>rm</tt> not <tt>rmdir</tt>.

		<item> <tt>rm /tmp/me/myfile; rmdir /tmp/me</tt>
		  <p> Clean up after ourselves.

	      </enumlist>

	  </sect2>

	  <sect2 id="files-misc-types-devices"> Device files

	    <p> Device files refer to physical or virtual devices on
	      your system, such as your hard disk, video card, screen,
	      or keyboard. An example of a virtual device is the
	      console, represented by <tt>/dev/console</tt>.

	    <p> There are two kinds of devices: <em>character
		devices</em> can be accessed one character at a time,
	      that is, the smallest unit of data which can be
	      written to or read from the device is a character
	      (byte).
	      
	    <p> <em>Block devices</em> must be accessed in larger
	      units called blocks, which contain a number of
	      characters. Your hard disk is a block device.
	      
	    <p> You can read and write device files just as you can
	      from other kinds of files, though the file may well
	      contain some strange incomprehensible-to-humans
	      gibberish. Writing random data to these files is
	      probably a Bad Idea. Sometimes it's useful, though: for
	      example, you can dump a postscript file into the printer
	      device <tt>/dev/lp0</tt>, or send modem commands to the
	      device file for the appropriate serial port.

	    <sect3 id="files-advanced-types-devices-creating"> How to
		create device files. <p> <tt>MAKEDEV</tt>
	    </sect3>

	    <sect3 id="files-advanced-types-devices-null"> <tt>/dev/null</tt> 
		
	      <p> <tt>/dev/null</tt> is a special device file that
		discards anything you write to it. If you don't want
		something, throw it in <tt>/dev/null</tt>. It's
		essentially a bottomless pit. If you read
		<tt>/dev/null</tt>, you'll get an end-of-file (EOF)
		character immediately. <tt>/dev/zero</tt> is similar,
		only if you read from it you get the <tt>\0</tt>
		character (not the same as the number zero).
	    </sect3>

	  <sect2 id="files-advanced-types-pipes"> Named pipes
	      (FIFOs)
	      
	    <p> A named pipe is a file that acts like a pipe. You
	      put something into the file, and it comes out the other
	      end. Thus it's called a FIFO, or First-In-First-Out: the
	      first thing you put in the pipe is the first thing to
	      come out the other end.
	      
	    <p> NOTE: The following explanation probably won't make
	      much sense until you've read about processes and using
	      the shell.

	    <p> If you write to a named pipe, the process which is
	      writing to the pipe doesn't terminate until the
	      information being written is read from the pipe. If you
	      read from a named pipe, the reading process waits until
	      there's something to read before terminating. The size
	      of the pipe is always zero - it doesn't store data, it
	      just links two processes like the shell
	      <tt>|</tt>. However, since this pipe has a name, the two
	      processes don't have to be on the same command line or
	      even be run by the same user.

	    <p> You can try it by doing the following:
	      <enumlist> 
		<item> <tt>cd; mkfifo mypipe</tt>
		    <p> Makes the pipe.

		<item> <tt>echo "hello" > mypipe &</tt>
		    <p> Puts a process in the background which tries
		    to write "hello" to the pipe. Notice that the
		    process doesn't return from the background. Try
		    simply <tt>echo "hello"</tt> without the
		    redirection to see the difference.

		<item> <tt>cat mypipe</tt> 
		  <p> At this point the <tt>echo</tt> process should
		    return, and the <tt>cat</tt> process will print
		    <tt>hello</tt>. 

		<item> <tt>rm mypipe</tt> 
		    <p> You can delete pipes just like any other file.
	      </enumlist>

	  </sect2>

	  <sect2 id="files-advanced-types-sockets"> Sockets 

	    <p> Sockets are similar to pipes, only they work over the
	      network. This is how your computer does networking, and
	      forms the basis for the internet: you may have heard of
	      "WinSock", which is sockets for Windows.

	    <p> We won't go into these further, because you probably
	      won't have occasion to use them unless you're
	      programming. However, if you see a file marked with type
	      <tt>s</tt> on your computer, you know what it is.

	  </sect2>

	</sect1>

	<sect1 id="files-advanced-proc"> The <tt>proc</tt> filesystem

	  <p> The Linux kernel makes a special filesystem available,
	    which is mounted under <tt>/proc</tt> on Debian
	    systems. This is a "pseudo-filesystem" - it doesn't really
	    exist on any of your devices. 

	  <p> The <tt>proc</tt> filesystem contains information
	    about the system and running processes. Some of the
	    "files" in <tt>/proc</tt> are reasonably understandable to
	    humans (try typing <tt>cat /proc/meminfo</tt>) and others
	    are arcane collections of numbers. Often, system utilities
	    use these to gather information and present it to you in a
	    more understandable way.

	  <p> People frequently panic when they notice one file in
	    particular - <tt>/proc/kcore</tt> - which is generally
	    huge. This is (more or less) a copy of the contents of
	    your computer's memory. It's used to debug the kernel. It
	    doesn't actually exist anywhere, so don't worry about its
	    size.

	  <p> If you want to know about all the things in
	    <tt>/proc</tt>, type <tt>man 5 proc</tt>.

	</sect1>

	<sect1 id="files-advanced-permissions"> Advanced aspects of file permissions

	  <sect2 id="files-advanced-permissions-absolute"> Using
	  numeric arguments with <tt>chmod</tt>

	    <p>Earlier in this chapter, we briefly mentioned that you
	      can set file permissions using numbers. The numeric
	      notation is called an absolute mode, as opposed to the
	      symbolic notation (e.g. <tt>u+rx</tt>) which is often
	      called a relative mode. This is because the number
	      specifies an exact mode to set, and the symbol just
	      specifies a change to make (e.g. "add user read and
	      execute permissions"). 

	    <p>The numeric mode is a series of four octal digits or
	      twelve binary digits. Each octal (base eight) digit
	      represents three binary digits: one octal digit and
	      three binary digits are two ways to represent the
	      decimal digits 0 through 7.

	    <p>Deriving a particular mode is pretty
	      straightforward. You simply add up the modes you want to
	      combine, or subtract modes you don't want. For example,
	      user permissions, with only read permission turned on,
	      would be <tt>100</tt> in binary. User permissions with
	      write only would be <tt>010</tt> binary. User
	      permissions with read and write both turned on would be
	      <tt>100 + 010 = 110</tt>. Alternatively, you could put
	      it in octal: <tt>4 + 2 = 6</tt>.

	      <p> For the full mode, simply add up digits from this table:

<example>
0001        others, execute
0002        others, write
0004        others, read
0010        group, execute
0020        group, write
0040        group, read
0100        user, execute
0200        user, write
0400        user, read
1000        sticky bit
2000        set group id
4000        set user id
</example>

	    <p>To use the table, first decide what permissions you
	    want to set. Then add up the numbers for those
	    permissions. The total is your mode. For example, to get
	    mode <tt>0755</tt>:

<example>
  0001   o=x
  0004   o=r
  0010   g=x 
  0040   g=r
  0100   u=x
  0200   u=w
+ 0400   u=r
-------
  0755  u=rwx go=rw
</example>

	    <p>You'd actually call this mode simply <tt>755</tt>,
	      without the leading <tt>0</tt>, because <tt>chmod</tt>
	      automatically adds zeroes at the beginning of the mode -
	      so simply <tt>7</tt> becomes mode <tt>0007</tt>. 

	    <p> To set a file to <tt>755</tt>, you'd type <tt>chmod
	      755 myfile</tt>.

	    <p><tt>755</tt> is a very common mode for directories, as
	      it allows anyone to use the directory but only the owner
	      to create and delete files in the directory. <tt>644</tt>
	      is the analogous mode for files, and it is also very
	      common. It allows anyone to use the file but only the
	      owner can change it. For executable files, <tt>755</tt>
	      is a common mode; this is just <tt>644</tt> plus execute
	      permissions (<tt>644 + 111 = 755</tt>).

	  </sect2>

	  <sect2 id="files-advanced-permissions-suid"> Making files suid/sgid
	    <p>
	  </sect2>

	  <sect2 id="files-advanced-permissions-sticky"> Setting the sticky bit
	    <p>
	  </sect2>
	  
	</sect1>

	<sect1 id="files-advanced-undocumented"> Other concepts not
	yet covered, but should be

	  <p> fsck, mke2fs, dd, fdisk, etc. <p> what package is a file
	    in? <p> MSDOS vs. Mac vs. Unix text files <p> sync <p>
	    chattr </sect1>

      </sect>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-doctype: ("/usr/local/src/user_manual/user.sgml")
sgml-parent-document: (/usr/local/src/user_manual/user.sgml "debiandoc" "book" "chapt" )
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
sgml-set-face:1
End:
-->
