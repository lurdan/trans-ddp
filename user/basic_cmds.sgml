<!-- Basic Commands and Tools: Oliver Elphick -->

<p>Latest update to this chapter: 14th December 1997</p>
<sect>
	<heading>What this chapter covers</heading>
      <p>
This chapter tells you how to run the basic commands that you need in
order to use Debian Linux.</p>
      <p>
We assume that you have already logged in and are in a shell where you
can enter commands.  Refer back to <ref id="logging-in"> for instructions
on how to log in.  If you are not running X-Windows, you will normally
be put in an interactive shell as soon as you log in.  If you are
running X-Windows, you should refer to <ref id="xwin"> for instructions
on how to start up a window with a shell.</p>
      <p>
The available shells are described in <ref id="shells">.  All the examples
given here assume that you are using the Bourne-Again Shell, <prgn>/bin/bash</prgn>,
though in most cases there will be no difference between the command 
syntax for any shell.  Bash is the default shell when Debian Linux is
first installed.</p>
    
      </sect>
      <sect><heading>Running commands</heading>
	<sect1>
	  <heading>How to enter commands</heading>
      <p>To run a command, type the command at the prompt, followed by any
necessary options, and then press the <tt>Enter</tt> key. The shell will
interpret the command, first handling any special shell syntax, and will
then start the command as a new process.</p>
      <p>Most commands operate silently unless they are specifically
asked to say what they are doing.  If there is no error message, the
command should have worked.</p>
    </sect1>
	<sect1>
	  <heading>How Linux finds commands</heading>
	  <p>When you type in a command name, Linux has to find the file
which contains the program you want to run.  This is how it does it:</p>
	  <p>The first word of what you type in is the command<footnote>
	      <p>There are exceptions: see the chapter on shells.</p>
	    </footnote> itself.  If this contains a slash character (<tt>/</tt>)
the whole command is taken to be a path, either absolute (if it starts with /)
or relative to the current directory.  The file indicated by that path is used,
provided that it exists, that it is executable and (in the case of a script) that
it is readable.
</p>
	  <p>If the command does not contain a slash, the shell searches for it
in your current search path.  This is a list of directories, separated one from
another by colons.  The command search path is held in the environment variable
PATH: type <tt>echo $PATH</tt> to see what it is.  For example, 
<example>

$ echo $PATH
/usr/bin:/bin:/usr/bin/X11:/usr/local/bin:/usr/games:/home/olly/bin

</example>  Each directory is searched in turn, starting at the beginning
of the list.  If a match for the name is found, the shell also considers
whether the file found is executable (and readable, if it is a script).  As
soon as such a match is found, the search stops<footnote>
	      <p>This is why system directories should be put first in the
path; this ensures that the system commands will be run in preference to
ones of the same name in user bin directories or in the current directory. If 
non-system programs are searched first, there is a security risk, because 
there may be non-standard programs with commonly-used names, and you cannot tell
what they might do.</p>
	    </footnote>.  This is why new programmers often have trouble
getting their first program to run.  They frequently call it <prgn>test</prgn> and run
it without a path; the shell finds the system program <prgn>test</prgn> first
and runs that instead.</p>
	  <p>If you need to change your path, you should add the new directories
to the end of the list; the current directory (.), if it is
included at all, should go last of all<footnote>
<p>Many people recommend that the current directory should never be included in
your path.  You can run commands in the current directory by using
<tt>./<var>command</var></tt></p></footnote>.  The
command to use is <tt>export PATH=$PATH:<var>new_directory</var></tt><footnote>
	      <p>The syntax given is for Bourne shell and its descendants.  The
syntax for C shell and its descendants is <tt>setenv PATH $PATH:<var>new_directory</var></tt></p>
	    </footnote>
.</p>

	</sect1>
      <sect1><heading>Command options</heading>
      <p>The operation of most commands can be changed by putting command
options immediately after the command name.  There are several styles of
options used, and you have to check the documentation for each command to
know what options it can take, and what they do.</p>
      <p>The most common form of option is a letter preceded by a hyphen,
thus:
<example>ls -l</example>
With this option style, several single-character options can be combined
into one, thus:
<example>ls -ali</example>
which is equivalent to
<example>ls -a -l -i</example></p>
      <p>Sometimes, single-letter options like this need an extra argument:
<example>awk -F: -f /tmp/bar /tmp/foo</example>
Here <tt>:</tt> and <tt>/tmp/bar</tt> are arguments to the options <tt>-F</tt>
and <tt>-f</tt> respectively.</p>
      <p>A few commands have options which need not be preceded by a hyphen.
The one you are most likely to use is <prgn>tar</prgn>.
<example>tar cvmf /dev/st0 /usr</example>
is the same as
<example>tar -cvmf /dev/st0 /usr</example></p>
      <p>A third option style, commonly used by GNU programs, is whole
words or phrases introduced by <tt>--</tt>.  Many commands can use both
the single-letter and whole-word options:
<example>tar --create --verbose --modification-time --file /dev/st0 /usr</example></p>
      <p>Finally, commands may define completely different option patterns
for themselves, such as options preceded by <tt>+</tt> as the opposite to
<tt>-</tt>.</p>
	</sect1>

      <sect1><heading>Essential commands</heading>
      <p>These commands are the ones you really need to know to get anything
done.</p>
      <p>We give only a brief description of the command, describing its basic use.
For full details, you should always refer to the detailed documentation of
the manual pages and the info files.</p>
<p>The brief examples given here are not by
any means the only way of doing things; the key to using Unix is to learn the
building blocks and their capabilities and become able to use them in your
own way.  Whatever the task, there is almost always more than one way to
carry it out.  Sometimes there will be five or six different ways!</p>	  	  
<p>In this chapter, things which are optional are shown <var>like this</var>. <var>Words looking like this</var> are to be replaced by
whatever is appropriate to what you are trying to do.</p>
    
      <sect2><heading>Commands for reading documentation</heading>
    <p>To avoid annoying other users by questions on elementary matters, do, please,
read the manuals!</p>
    <p>These are the commands to let you do that:

<taglist>
	<tag><prgn>man</prgn> [<var>section-number</var>] <var>subject</var></tag>
	<item><p><prgn>man</prgn> shows the manual page on the
command (use q or ctrl-C to get out of it if it doesn't terminate at the end
of the text). More details are given in <ref id="manpages">.</p>
	  <p>This command is crucial for helping you learn how
to use it and other Linux commands.</p>
	</item>
	
	<tag><prgn>info</prgn> [<var>subject</var>]</tag>
	<item><p>A lot of Debian Linux documentation is provided
in <em>info</em> format.  This is similar to a
hypertext format, in that you can jump to other sections of the documentation
by following links embedded in the text.</p>
	  <p>See <ref id="manpages"> for a full description of
how to use <prgn>info</prgn>.</p>
	</item>
	
	<tag><prgn>help</prgn> [<var>subject</var>]</tag>
	<item><p>Use <prgn>help</prgn> for on-line help about bash's built-in
commands.</p>
	  <p><prgn>help</prgn> by itself prints a list of subjects for
which you can ask for help.</p>
	</item>
      </taglist></p>
</sect2>
    <sect2><heading>Commands for basic file-handling</heading>
    <p>A fuller description of file-systems and file-handling is given in
<ref id="files">.</p>
    <p>These are the commands that you really have to know:</p>
<p>
<taglist>
		<tag><prgn>pwd</prgn></tag>
		<item><p>Show the current directory.</p>
		</item>
		<tag><prgn>cd</prgn> [<var>directory</var>]</tag>
		<item><p>Change your current directory to the named
<var>directory</var>.  If you don't specify <var>directory</var>, you will be
returned to your home directory.</p>
		</item>
		<tag><prgn>mkdir</prgn> <var>new_directory</var></tag>
		<item>
		  <p><prgn>mkdir</prgn> is used to create a new directory.
<var>new_directory</var> can be specified as a path, or as a simple name (in
which case it is created in the current directory).</p>
		</item>
		
	<tag><prgn>mv</prgn> <var>source</var> <var>target</var></tag>
	<item><p><prgn>mv</prgn> moves <var>source</var> file to
<var>target</var> and deletes <var>source</var>; <var>source</var> can be a
list of files, but in that case <var>target</var> must be a directory.</p>
	  <p>This is also the way to rename a file or directory.</p>
	</item>

	<tag><prgn>cp</prgn> <var>source</var> <var>target</var></tag>
	<item><p><prgn>cp</prgn> copies <var>source</var> to <var>target</var>. Again, <var>target</var> can be a directory and  <var>source</var> a list of
files.
</p>
	</item>

	<tag><prgn>ln</prgn> <var>source</var> <var>target</var></tag>
	<item><p><prgn>ln</prgn> links <var>source</var> to <var>target</var>
with hard or symbolic links according to the options.</p>
	</item>

	<tag><prgn>rm</prgn> <var>filelist</var></tag>
	<item><p><prgn>rm</prgn> deletes files.  With the -r option it can
delete directories and their contents.</p>
	  <p>Be very careful with <prgn>rm</prgn>; once a file is deleted, you cannot get it back.  There is no <prgn>undelete</prgn> command.</p>
	</item>

	<tag><prgn>rmdir</prgn> <var>directorylist</var></tag>
	<item><p><prgn>rm</prgn> deletes empty directories.</p>
	</item>
	<tag><prgn>chmod</prgn> <var>mode</var> <var>filelist</var></tag>
	<item><p><prgn>chmod</prgn> changes the permissions of files and
directories.  The <var>mode</var> is either an octal number, such as
<tt>644</tt>, or a symbolic representation of it, such as
<tt>u=rw,go=r</tt>.</p>
	</item>

	<tag><prgn>chown</prgn> <var>owner</var>[.<var>group</var>] <var>filelist</var></tag>
	<item><p><prgn>chown</prgn> changes the ownership of files. Use the
<tt>-R</tt> option to do this for an entire directory tree.</p>
	  <p>If .<var>group</var> is specified as well as <var>owner</var>,
the group ownership of the files is changed as well.</p>
	</item>

	<tag><prgn>chgrp</prgn> <var>group</var> <var>filelist</var></tag>
	<item><p><prgn>chgrp</prgn> changes the group ownership of files. Use the
<tt>-R</tt> option to do this for an entire directory tree.</p>
	</item>

	<tag><prgn>ls</prgn> <var>directory</var></tag>
	<item><p><prgn>ls</prgn> lists the contents of <var>directory</var>;
by default, the output is sorted.</p>
	  <p>There are more options to <prgn>ls</prgn> than to any other
command. Those most commonly used are <tt>-l</tt>, to show the file
permissions and the latest change date and <tt>-a</tt>, to show hidden
dot-files.</p>
	</item>
</taglist></p>
</sect2>
      <sect2><heading>These commands are used for managing file-systems</heading>
      <p>Files are organised into file-systems (see <ref id="files">).</p>
      <p>Every Debian Linux system (and every Unix system) has a root
file-system, called, simply, <tt>/</tt>. All files and devices in the
system, and possibly files on other systems as well, are accessible under
<tt>/</tt>.  Files are placed under directories, which may themselves be
placed in directories, and so on.  Segments of this universal tree will be
on different physical devices, or different sections (`partitions') of a
single physical device. New file-systems, each with its own directory tree,
may be grafted into the universal directory tree at arbitrary `mount-points'.
(These are simply directories which are nominated to be the head of the new
tree.)</p>
      <p>The process of grafting a segment into the main tree is called
`mounting'; the file system is mounted on a mount-point, which is a
directory.</p><p>
<taglist>
	<tag><prgn>df</prgn></tag>
	<item><p><prgn>df</prgn> lists mounted partitions and shows the amount
of space present, used and available. (The partitions will probably include
/proc, which is a special `non-existent' partition, that contains information
about the current state of the Linux kernel.)</p>
	</item>

	<tag><prgn>mount</prgn> [<var>partition</var> <var>directory</var>]</tag>
	<item><p><prgn>mount</prgn> by itself lists mounted partitions.</p>
	  <p>It is also the command to use to add a partition's file-system
into the universal directory tree.  For example:
<example>mount /dev/hda2 /usr</example></p>
	  <p>You have to be superuser (log in as <tt>root</tt> or run
<prgn>su</prgn>) in order to mount or unmount file-systems.</p>
	</item>

	<tag><prgn>umount</prgn> <var>directory</var></tag>
	<item><p><prgn>umount</prgn> removes a partition's file-system
from the universal directory tree.  For example:
<example>umount /usr</example></p>
	  <p>You have to be superuser (log in as <tt>root</tt> or run
<prgn>su</prgn>) in order to mount or unmount file-systems.</p></item>
      </taglist></p>
</sect2>

      <sect2><heading>Looking at files</heading>
      <p>Files include physical devices, executable programs and directories,
as well as text files.  It is as well not to look at compiled executables
on the screen however.  At best they will be garbage; at worst they will
make everything on the screen unreadable (see <ref id="rmacs"> for a
way to recover from this.)</p>
<p>
<taglist>
	<tag><prgn>cat</prgn> <var>textfile[s]</var></tag>
	<item><p><prgn>cat</prgn> dumps <var>textfile[s]</var> to screen without
paging (like DOS's type).  If you name more than one file, each will be
sent in order, with no break or heading.</p>
	</item>

	<tag><prgn>more</prgn> <var>textfile[s]</var></tag>
	<item><p><prgn>more</prgn> lists the <var>textfile[s]</var> to the screen
in pages so that you can read it.  Press <tt>Space-bar</tt> to move on one page,
<tt>Enter</tt> to move on one line, and <tt>b</tt> to move back one page.  Use
<tt>q</tt> or <tt>ctrl-c</tt> to quit.</p>
	  <p><prgn>more</prgn> will quit automatically when it gets to the end
of the last file.</p>
	</item>

	<tag><prgn>less</prgn> <var>textfile[s]</var></tag>
	<item><p><prgn>less</prgn> is like <prgn>more</prgn> but has more
features and somewhat different behaviour.  You have to type <tt>Q</tt> to
terminate it.</p>
	</item>

	<tag><prgn>head</prgn> <var>textfile[s]</var></tag>
	<item><p><prgn>head</prgn> is used to see the first few lines of
a file (by default, it shows 10 lines).</p>
	</item>

	<tag><prgn>tail</prgn> <var>textfile[s]</var></tag>
	<item><p><prgn>tail</prgn> is used to see the last few lines of
a file (by default, it shows 10 lines).</p>
	</item>

	<tag><prgn>od</prgn> <tt>-cx</tt> <var>file[s]</var></tag>
	<item><p><prgn>od</prgn> is used to look at the contents of binary
	files.  With no options, it displays the file contents as a series
	of octal numbers.  Since few people are fluent with this form, the
	<tt>-c</tt> and the <tt>-x</tt> options together are probably more
useful. They display the file contents
	as real characters where possible and as octal numbers if the
	characters are not displayable, with, underneath, the hexadecimal
representation.  For example: <example>
$ od -cx /bin/ls | more
0000000 177   E   L   F 001 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
        457f 464c 0101 0001 0000 0000 0000 0000
0000020 002  \0 003  \0 001  \0  \0  \0 240 217 004  \b   4  \0  \0  \0
        0002 0003 0001 0000 8fa0 0804 0034 0000
0000040 204   o  \0  \0  \0  \0  \0  \0   4  \0      \0 005  \0   (  \0
        6f84 0000 0000 0000 0034 0020 0005 0028
0000060 026  \0 025  \0 006  \0  \0  \0   4  \0  \0  \0   4 200 004  \b
        0016 0015 0006 0000 0034 0000 8034 0804
0000100   4 200 004  \b 240  \0  \0  \0 240  \0  \0  \0 005  \0  \0  \0
        8034 0804 00a0 0000 00a0 0000 0005 0000 </example><footnote><p>The alert user may have noticed that each two
bytes of the hexadecimal representation is reversed with respect to the 
characters they represent.  That is because this  example was run on
a PC, which uses little-endian architecture.  The results would be the
opposite way round on a big-endian architecture.</p></footnote></p>
	<p>The numbers in the left hand column are always octal; they
	indicate the byte offset of the first character on the line from
	the beginning of the file.</p>
	</item>

	<tag><prgn>dd</prgn> <tt>if=<var>input_file</var> of=<var>output_file</var></tt></tag>

	<item><p><prgn>dd</prgn> is used for arbitrary copying between files
and devices (either <var>file1</var> or <var>file2</var> or both could be
devices instead of files.)  You can use <prgn>dd</prgn> to copy a file
while dropping its first few bytes,  to break a file into chunks, 
to copy a disk image onto a floppy
(for instance to get a Debian boot floppy), to inspect the contents
of a tape, or anything else that your ingenuity can suggest. </p>
	</item>

	<tag><prgn>find</prgn> <var>directory</var> -name <var>filename</var></tag>
	<item><p><prgn>find</prgn> tells you where <var>filename</var> is in the
tree starting at <var>directory</var>.  This command has many other useful
options.</p>
</item>

	<tag><prgn>xargs</prgn> <var>command</var></tag>
	<item><p><prgn>xargs</prgn> is commonly used with <prgn>find</prgn>. It
breaks long lists of files given to a command into chunks that are short
enough for the shell to handle.  In this way, you can run through the
entire file system and execute some command on all the selected files. For
example, this command looks for all files in your home directory that
have been changed within the last two days, and sets group write access on
them all:
<example>find $HOME -mtime -2 | xargs chmod g+w</example></p>
	</item>

	<tag><prgn>grep</prgn> <var>pattern</var> <var>filelist</var></tag>
	<item><p><prgn>grep</prgn> scans each file in <var>filelist</var> for
lines which match <var>pattern</var> (see <ref id="regexp">).</p>
	</item>

	<tag><prgn>file</prgn> <var>file</var></tag>
	<item><p><prgn>file</prgn> reports what kind of thing <var>file</var> is.</p>
	</item>

	<tag><prgn>type</prgn> <var>file</var></tag>
	<item><p><prgn>type</prgn> says where to find <var>file</var> in your
search path.</p>
	</item>

	<tag><prgn>whereis</prgn> <var>file</var></tag>
	<item><p><prgn>whereis</prgn> is like <prgn>type</prgn>, but gives more
information.</p>
	</item>
      </taglist></p>
</sect2>
	  <sect2 id="rmacs">
	    <heading>Managing your screen</heading>
	    <p>Managing your screen can be a very frustrating experience.</p>
	    <p>When you have sat helpless for a while trying to work out
why your entire display contains total garbage, or why pressing an arrow
key puts irrelevant characters up, you may well feel that it's time to
tip the whole computer system into the dustbin and go back to the abacus.
This section offers you a lifeline.</p>
	    <p>First of all, here are some commands to handle what you can see on
your screen.  The screen can be either the whole text display or a single
text window in X.<taglist>
		<tag><prgn>tput</prgn> <tt>clear</tt></tag>
		<item>
		  <p>All VDUs attached on serial cables, and all memory-mapped
displays that emulate VDUs, including your text console and your xterm
windows, respond to special character sequences that will change the 
appearance of the whole screen, or portions of it, when they are sent to
the screen.  Usually, these sequences start with the ESCAPE character, but
they don't have to.  Because of the vast number of different VDUs produced
by many different manufacturers, mostly with different control sequences,
Linux has a database of the sequences that apply to different types of VDU.
The database appears in two forms -- the older is called termcap and the newer,
terminfo.</p>
		  <p><prgn>tput</prgn> is a command that reads the terminfo
database for the sequence named, translates that sequence to screen control 
characters and sends those characters to the screen.  The <tt>clear</tt>
sequence blanks the screen and puts the cursor in the top left hand corner.</p>
		</item>

		<tag><prgn>tput</prgn> <tt>rmacs</tt></tag>
		<item>
		  <p>If, intentionally or not, you display a binary file on
the screen, you may chance to send to the screen the sequence that makes it
display its alternative character set; this usually contains a lot of graphics
line-drawing characters, card suits, odd mathematical symbols and so on.  The
computer's attempt to display ordinary text in this character set produces
a screen containing total garbage.  The <tt>rmacs</tt>
sequence switches the display out of the alternate character set.  Use this
command to stop the display showing garbage graphics characters and make
it show proper text instead.  (The effect is usually to change new characters
sent to be proper text, but leave text already displayed as it is.)</p>
		</item>
		<tag><prgn>stty</prgn></tag>
		<item>
		  <p><prgn>stty</prgn> controls communication between a VDU
and the computer.  It controls characteristics such as the baud-rate, parity,
number of stop-bits and handshaking, all of which should be set up for you by
your system administrator (if that is you, read the System Administration manual).  In the case of your console, or of an xterm window, which
are mapped directly from memory, the line characteristics are irrelevant, but
there are certain characteristics set by <prgn>stty</prgn> which are
relevant to every kind of display.</p>
		  <p>These are some characteristics could be used by you if it
seemed necessary.  (If it <em>is</em> necessary, you may find that nothing at
all seems to work; this may be because the return key no longer works and Linux
has reverted to using the basic default, which is new line (Ctrl-J). 
If nothing at all seems to work, press Ctrl-J before entering any command
and finish your commands with Ctrl-J instead of return.)</p><p><taglist>
		      <tag><tt>sane</tt></tag>
		      <item>
			<p><tt>stty sane</tt> is one option to try if
everything has stopped working.  Remember to use Ctrl-J both before and after
the command and don't use the return key.</p>
		      </item>
		      <tag><tt>echo</tt></tag>
		      <item>
			<p>Use <tt>stty echo</tt> if what you type doesn't
appear on the screen.</p>
		      </item>
		      <tag><tt>intr '^C'</tt></tag>
		      <item>
			<p>Use <tt>stty intr '^C'</tt> to make Ctrl-C work
as your interrupt key (which will tell the running program to stop).</p>
		      </item>
		      <tag><tt>-a</tt></tag>
		      <item>
			<p>Use <tt>stty -a</tt> to show you what your
existing <prgn>stty</prgn> settings are.</p>
		      </item>
		    </taglist>
</p>
		</item>
	      </taglist>
</p>
	  </sect2>
      <sect2><heading>Compressed files</heading>
      <p>In order to save space on your disks, many files are compressed.
They are scanned by a program such as <prgn>gzip</prgn> or <prgn>compress</prgn>
and reduced in size, often to about one third of their original size.</p>
      <p>Compressed files cannot be read unless they are uncompressed
again.</p>
<p>
<taglist>
	<tag><prgn>gunzip</prgn> <var>file.suffix</var></tag>
	<item><p><prgn>gunzip</prgn> uncompresses <var>file.suffix</var>
(where <var>suffix</var>is <tt>.gz</tt> or perhaps <tt>.Z</tt>), deletes it
and writes an uncompressed file called <var>file</var>.</p>
	  <p>In spite of its name, <prgn>gunzip</prgn> cannot handle zip
format files created by <prgn>PKZIP</prgn>.  There is a <prgn>pkunzip</prgn>
program that can handle such files.</p>
	</item>

	<tag><prgn>zcat</prgn> <var>compressed_file</var></tag>
	<item><p><prgn>zcat</prgn> does the same job as <prgn>cat</prgn>, but
uncompresses <var>compressed_file</var> first, without changing it on the
disk.</p>
	</item>

	<tag><prgn>zmore</prgn> <var>compressed_file</var></tag>
	<item><p><prgn>zmore</prgn> does the same job as <prgn>more</prgn>, but
uncompresses <var>compressed_file</var> first, without changing it on the
disk.</p>
	</item>

	<tag><prgn>zless</prgn> <var>compressed_file</var></tag>
	<item><p><prgn>zless</prgn> does the same job as <prgn>less</prgn>, but
uncompresses <var>compressed_file</var> first, without changing it on the
disk.</p>
	</item>

	<tag><prgn>zgrep</prgn> <var>compressed_file</var></tag>
	<item><p><prgn>zgrep</prgn> does the same job as <prgn>grep</prgn>, but
uncompresses <var>compressed_file</var> first, without changing it on the
disk.</p>
	</item>
      </taglist></p>
</sect2>
      <sect2><heading>Commands for backup</heading>
      <p>You need to do regular backups, in order to be able to recover
your system and data in case of disaster.  In order to get full access to
all the files that need to be backed up, system backups must be done by
the superuser.  This section refers only to backups of your own home
directory and of other files to which you have access.</p>
      <p>These programs are used for backups of various kinds:</p>
<p>
<taglist>
	<tag><prgn>tar</prgn></tag>
	<item><p><prgn>tar</prgn> is designed to archive directories with all
their contents.  It has many options, but here is a simple example of
using it to create a backup of your home directory to a SCSI tape:
<example>tar cvf /dev/st0 $HOME</example>
Here is how to read the contents of a tape that has been written with <prgn>tar</prgn>:
<example>tar tf /dev/st0</example>
and here is how to restore a particular directory (with its contents) from
such a tape backup:
<example>tar xvf /dev/st0 $HOME/private/letters</example></p><p>
You can also restore a single file:
<example>tar xvf /dev/st0 $HOME/private/letters/bank.21Aug</example></p>
</item>

	<tag><prgn>cpio</prgn></tag>
	<item>
<p><prgn>cpio</prgn> is used to write individual files to a backup.  A list of
files is prepared in some way and then piped into the standard input of
<prgn>cpio</prgn>. This is how to use it to archive your home directory
to SCSI tape:
<example>find $HOME -print | cpio -ovBH newc &gt;/dev/st0</example>
Here is how to read the contents of a tape that has been written with <prgn>cpio</prgn>:
<example>cpio -itBH newc &lt;/dev/st0</example>
and here is how to restore a set of files in one directory whose names all
start with `bank' from such a tape backup:
<example>cpio -itBH newc "$HOME/private/letters/bank*" &lt;/dev/st0</example></p>
	</item>
<tag><prgn>afio</prgn></tag>
	<item>
<p><prgn>afio</prgn> is used like cpio to write individual files to a backup.  It
has the additional capability of compressing files before it writes them
on the backup.  This is useful if you have a lot of information to store on
media of limited capacity. This is how to use it to archive your home directory
to SCSI tape, using compression:
<example>find $HOME -print | afio -ovZ &gt;/dev/st0</example></p>
	</item>
      </taglist></p>
</sect2>
      <sect2>
	<heading>Printing files</heading>
      <p>There is one basic command for printing (though there are many for
specialised uses):</p><p>
      <taglist>
	<tag><prgn>lpr</prgn> <var>file</var></tag>
	<item>
        <p><prgn>lpr</prgn> prints <var>file</var> to the default printer. 
<prgn>lpr</prgn> is the user command for adding jobs to the spooler queue.  The
jobs will continue to print, even if you log out.</p>
		  <p>If you have more than one printer, you can use the option
-P<var>printer</var> to direct a job to one particular printer.</p>
	</item>

	<tag><prgn>lpq</prgn></tag>
	<item>
        <p><prgn>lpq</prgn> shows the current list of jobs on the printer
spool queue.</p>
	</item>

	<tag><prgn>lprm</prgn> <var>jobId</var></tag>
	<item>
        <p><prgn>lprm</prgn> removes the job identified by <var>jobId</var> from the
spooler queue.  If a job is already printing, this may not stop it; the job
may already be stored in the printer's memory</p>
	</item>
      </taglist></p>
      </sect2>

      <sect2>
	<heading>Changing files</heading>
      <p>See <ref id="editors"> for information on editing files.</p>

      </sect2>
      <sect2>
	<heading>Session management</heading>
      <p>A session is the series of events between logging in and 
logging out of the computer.</p>
      <p>When you first log in, you will see a prompt, which may contain 
your current machine's hostname, and perhaps the current directory.  The
prompt ends with a dollar sign: <em>$</em>, which indicates that you are
an ordinary user.  If you become superuser, the dollar sign should change
to a hash (or sharp) sign: <em>#</em>.  You need to know that you are
superuser, <em>because you can then do a great deal of damage to your system by
mistyping ordinary commands.</em></p>
      <p>These commands relate to handling your session:</p>
<p>
      <taglist>
	<tag><prgn>exit</prgn> or <prgn>logout</prgn></tag>
	<item>
	  <p>Use <prgn>exit</prgn> or <prgn>logout</prgn> to terminate your
session and log out.  All jobs you have started are terminated, unless they
were started with <prgn>nohup</prgn>, and your screen should return you
to the log-in prompt.  You can often use Ctrl-D to do the same, but that
capability can be disabled.</p>
	</item>

	<tag><prgn>su</prgn></tag>
	<item>
	  <p>Use <prgn>su</prgn> to become superuser.  You will be asked to enter a
password; this is the password for the <tt>root</tt> login.</p>
	  <p>Becoming superuser is almost the same as logging in as root.
You get the same power to do damage.  <em>Be very careful!</em></p>
	  <p>Use <prgn>exit</prgn>, <prgn>logout</prgn> or ctrl-D to stop
being superuser.</p>
	</item>

	<tag><prgn>bg</prgn> and <prgn>fg</prgn></tag>
	<item>
	  <p>If you are running one job and want to run something else in
the same screen without stopping the first job, you can put the first job
in the background by typing Ctrl-Z.  You can then run other commands.  You
can start the first job running again in the background by using
<prgn>bg</prgn>. It will continue to run in the background until it
wants to send anything to the screen; then it will stop and
wait.  You can bring it forward again and let it continue by using the
command <prgn>fg</prgn>.</p>
	</item>
	<tag><prgn>script</prgn> <var>file</var></tag>
	<item>
	  <p>Use <prgn>script</prgn> to record everything that appears on the
screen (until the next exit) in <var>file</var>.  This is useful if you need
to record what's going on in order to include it in your message when you ask
for help.  Use exit, logout or ctrl-D to stop the recording session.</p>
	</item>
	<tag><prgn>ps</prgn></tag>
	<item>
	  <p>Use <prgn>ps</prgn> to list your processes. 
<example>
$ ps
  PID  TT STAT   TIME COMMAND
 6122  p1 S      0:00 bash 
 6123  p2 S      0:00 bash 
 6408  p1 S      0:00 ftp 
 6916  p4 R      0:00 ps 
13115  p7 SW     0:00 bash 
19102  p3 SW     0:00 bash 
19497  p4 S      0:00 -bash 
19554  p3 S     11:25 uvsh 
19623  p4 S      5:37 xemacs 
21272  p6 SW     0:00 bash
</example> </p>
	  <p>You can also use ps to see all processes on the system:
<example>
$ ps -ax
  PID  TT STAT   TIME COMMAND
    1  ?  SW     0:18 init 
    2  ?  SW     0:04 kflushd 
    3  ?  SW<    0:00 kswapd 
   10  ?  S      0:18 update 
   31  ?  SW     0:00 nfsiod 
   32  ?  SW     0:00 nfsiod 
   33  ?  SW     0:00 nfsiod 
   34  ?  SW     0:00 nfsiod 
  143  ?  S      0:08 /sbin/syslogd 
  145  ?  S      0:00 klogd 
  154  ?  S      0:00 /sbin/kerneld 
  164  ?  S      0:00 inetd 
  167  ?  S      0:05 named 
  179  ?  SW     0:00 run_job 
  183  ?  SW     0:00 bootpd 
  205  ?  SW     0:00 gpm 
  209  ?  S      0:52 /usr/sbin/tcplogd 
  212  ?  SW     0:00 icmplogd 
  ... and so on ...
</example></p>
	  <p>The number in the column headed <tt>PID</tt> is the identifying
number of the process.  Under column <tt>TT</tt> is the tty (screen or window
identifier) where it is running.  A question mark here means that it is
not attached to any screen or window, but is running in the background.</p>
	</item>
	<tag><prgn>tty</prgn></tag>
	<item>
	  <p><prgn>tty</prgn> shows you which terminal (screen or window)
you are in.
<example>
$ tty
/dev/ttyp4
</example></p>
	</item>
      </taglist></p>

      </sect2>
      <sect2>
	<heading>Identity</heading>
      <p>These commands relate to your identity as a user and the machine's
own identity.</p><p>
      <taglist>
	<tag><prgn>passwd</prgn> </tag>
	<item>
	  <p>Use <prgn>passwd</prgn> to change the password that you
use when you log in.  Follow the instructions on screen about what kind
of password to choose.  When you type the password in, it doesn't show
on the screen, so you have to enter it twice, to ensure that you make
no typing errors.</p>
	</item>
	<tag><prgn>id</prgn></tag>
	<item>
	  <p><prgn>id</prgn> tells you what user you are and what group you
are in.
<example>$ id
uid=1000(olly) gid=1000(olly) groups=1000(olly),6(disk),20(dialout),25(floppy),26(tape),29(audio),34(backup),37(operator),101(priory)
</example></p>
	  <p><var>uid</var> indicates your user number, <var>gid</var> your
group number (which will be assigned to files that you create) and
<var>groups</var> lists the other groups that you are a member of.</p>
	</item>

		<tag><prgn>who -u</prgn></tag>
	<item>
<p><prgn>who -u</prgn> reports everyone who is logged on.</p>
	</item>

 <tag><prgn>uname</prgn> <tt>-a</tt></tag>                                   
        <item>                                                                   
<p><prgn>uname</prgn> <tt>-a</tt> reports the name, type and operating
system of your machine.</p>                     
        </item>                                                                  
                   
		<tag><prgn>date</prgn></tag>
	<item>
<p><prgn>date</prgn> reports the current time and date.</p>
<p>The superuser can use this command to set the date and time.</p>
	</item>


      </taglist></p>
      </sect2>
	  <sect2>
	    <heading>Turning off the computer</heading>
	    <p>Turning the computer on and off is really a system administration
subject, but I include it here because it is something that every user who
is his own administrator needs to know.  If someone else is responsible
for administering the machine, you should neither need nor be able to shut
it down.</p>


	    <p>      <taglist>
	<tag><prgn>shutdown -t 0 -h now</prgn></tag>
	<item><p>This command shuts the computer down safely.  You can also
use ctrl-alt-del if your system is set up for that.  (If you are in X, 
ctrl-alt-del will be intercepted by X. Get out of X first by using
ctrl-alt-backspace.)  Never turn off a Unix
machine without doing a safe shutdown: if you do, you will damage your
file-systems.</p>
		</item></taglist></p>
	  </sect2>
	</sect1>

	<sect1>
	  <heading>Special characters in commands</heading>
	  <p>When you type a command, certain characters have a special
meaning to the shell and are interpreted before the command starts to
run.  Full details are given in the chapter on shells, but you need to
understand what is happening, or you will get results that you did not
expect.</p>
	  <p>Shell special characters are interpreted by the shell as soon
as it is given the command.  For example, if you type <tt>ls *.bak</tt>,
the shell translates <tt>*.bak</tt> to the list of all files in the current
directory whose names end in <tt>.bak</tt>.  <em>The <prgn>ls</prgn> command
never sees the asterisk.</em>  So if you want to search for files which
actually have an asterisk in their names, you have to escape the asterisk
to stop the shell from interpreting it.<example>
linda:/tmp/junk$ ls **
fred     george*  joe      mary     peter*
linda:/tmp/junk$ ls *\*
george*  peter*
linda:/tmp/junk$ 
</example>  In the example, the first command matched all files; the second
matched only those with a literal asterisk at the end of their names.</p>
	  <p>
 The same goes for other special characters.  here is the full list:</p>
	  <p><taglist>
	      <tag>\</tag>
	      <item>
		<p>\ escapes itself and other specials</p>
	      </item>
	      <tag>[ ]</tag>
	      <item>
		<p>[ ] encloses patterns for matching a single character</p>
	      </item>
	      <tag>*</tag>
	      <item>
		<p>* stands for anything (including nothing)</p>
	      </item>
	      <tag>?</tag>
	      <item>
		<p>? stands for any single character</p>
	      </item>
	      <tag>( )</tag>
	      <item><p>( ) runs the contents of the parentheses in a sub-shell</p>
	      </item>
	      <tag>;</tag>
	      <item>
		<p>; terminates a command pipeline - use it to separate commands
     on a single line</p>
	      </item>
	      <tag>&amp;</tag>
	      <item>
		<p>&amp; runs the preceding pipeline in the background.</p>
		<p>This is the same as typing Ctrl-Z and then <prgn>bg</prgn>
		to an already running program.</p>
	      </item>
	      <tag>$word and ${word}</tag>
	      <item>
		<p>$word and 
${word} are interpreted as a shell variable (use ${word} if there
     is danger of ambiguity).  There are other characters that can follow $
     and give other meanings. (See <ref id="shells">.)</p>
	      </item>
	      <tag>``</tag>
	      <item>
		<p>The contents of the backquotes are run as a command and 
its output is used as part of this command</p>
	      </item>
	      <tag>""</tag>
	      <item>
		<p>The contents of the quotes are treated as one argument; any
specials inside the quotes, except for $ and ``, are left uninterpreted.</p>
	      </item>
	      <tag>''</tag>
	      <item>
		<p>The contents of the single quotes are passed to the
command without any interpretation.</p>
	      </item>
	      <tag>|</tag>
	      <item>
		<p>The vertical bar sign is used to indicate a pipe. The
command on the left-hand side of the pipe sends its output to the input of
the command on the right side of the pipe.</p>
	      </item>
	      <tag>&lt; and &gt;</tag>
	      <item>
		<p>These symbols are used for redirection; see below.</p>
	      </item>
	      <tag>&&</tag>
	      <item>
		<p>The double ampersand is used between two commands (on the
same line).  It tells the shell to run the second command only if the first
one was successful<footnote>
		    <p>Successful means terminating with an exit status of 0.</p>
		  </footnote>
.</p>
	      </item>
	      <tag>||</tag>
	      <item>
		<p>The double vertical bar is used between two commands (on the
same line).  It tells the shell to run the second command only if the first
one was unsuccessful.</p>
	      </item>
</taglist></p>
	  <p>
For example, <tt>ls -d /[uv]*</tt> will list  the names of all entries in
the root directory that start with u or v.  Unlike DOS, you can use
patterns like <tt>g*.gz</tt> (with the wildcard bit in the middle).
</p>
<p>These characters have a special meaning only if they are the first 
non-space character in the command:
<taglist>
<tag>!</tag>
<item><p>If ! is immediately followed by a character other than =,
it begins a history substitution; if it is followed
by a space it negates the return code of the following command pipeline.
(For more details see <ref id="shells">.)</p></item>
<tag>^</tag>
<item><p>Quick history substitution, changing one string to another:
<example>$ ls *.cc
SQLBuilder.cc      dbwindow.cc        listitem.cc
$ ^cc^h^
ls *.h
SQLBuilder.h      dbwindow.h        listitem.h
</example></p></item>
<tag>#</tag>
	      <item>
		<p># turns the line into a comment; the line is not
processed in any way.</p></item>
</taglist></p>
	  <p>Don't confuse shell special characters with special characters in regular expressions (see <ref id="regexp">).  Regular expressions must be
protected from the shell by enclosing them in single quotes.</p>
	</sect1>
	<sect1>
	  <heading>Filters</heading>
	  <p>
Many commands are filters, so you can pass the output of one command to
the input of another:

	<example>awk -F: '{print $1 " " $6}' /etc/passwd | sort</example> </p>

	  <p>This is a fundamental concept of all Unix and Unix-like systems.  
Many commands are designed to be filters.  They can therefore be used as
building blocks to make more complex commands, in whatever way is needed at
the time.</p>
	</sect1>
	<sect1>
	  <heading>Standard input, standard output and standard error</heading>
	  <p>When the shell starts a command for you, it opens files for standard
input, standard output and standard error.  By default, standard input is your
keyboard, standard output is your screen, and standard error is also your screen.
</p>
	  <p>Although the defaults are keyboard and screen, this can easily be
changed.  In fact, the shell copies its own standard input, output and error
when it starts a command, so the command inherits whatever the shell has.  A
command can change its own settings, by opening a different file, and you
can tell the shell to use a file instead of the default of keyboard or screen.</p>
	  <p>The file descriptor numbers for standard input, standard output and
standard error are 0, 1 and 2 respectively.</p>
	</sect1>
	<sect1>
	  <heading>Redirection</heading>
	  <p>
You can redirect standard input, output and error by adding
these sequences after a command:<taglist>
	      <tag>&lt;</tag>
	      <item>
		<p>&lt; <var>file</var> means take input from <var>file</var>.</p>
	      </item>
	      <tag>&gt;</tag>
	      <item>
		<p>&gt; <var>file</var> means send output to <var>file</var> (overwriting and destroying whatever is in the file already).</p>
		<p>You can use this feature to empty a file, by typing
<example>&gt;<var>file_with_unwanted_contents</var></example>
on a line by itself.</p>
	      </item>
	      <tag>&gt;&gt;</tag>
	      <item>
		<p>&gt;&gt; <var>file</var> means append output to <var>file</var>.</p>
	      </item>
	      <tag>2&gt;</tag>
	      <item>
		<p>2&gt; <var>file</var> means send error messages to <var>file</var> (overwriting).  (This means that errors can be directed separately from normal output.)
   </p>
	      </item></taglist></p>
	  <p>There are more complex aspects to redirection, which may be studied
in the shell manual pages.  </p>
	    <p>Here are some very common uses of redirection:<taglist>
		<tag><prgn>cat</prgn> [<var>filelist</var>] &gt;<var>output_file</var></tag>
		<item>
		  <p>We have already seen that <prgn>cat</prgn> can be used
to look at files.  In conjunction with redirection of standard output, it can
be used to write files as well.</p>
		  <p>If you omit <var>filelist</var>, cat will take its input
from the keyboard, until you type ctrl-D.</p>
		</item>
		<tag><prgn>echo</prgn> <var>text</var></tag>
		<item>
		  <p><prgn>echo</prgn> sends <var>text</var> to the standard
output.  It is commonly used in script programs to put text on the screen.</p>
		  <p>It can also be used with redirection of output to
write to a file.  For example, 
<example>
echo "An example file containing
two lines of text" &gt;/tmp/example
</example> and <example>
echo "A third line added to the first two" &gt;&gt;/tmp/example
</example></p>
		</item>
	      </taglist>
</p>
</sect1>
	<sect1>
	  <heading>Shell programs</heading>
	  <p>
Redirection is a simple part of shell programming, for which see the
manual pages of bash, zsh, tcsh, or whatever shell you have chosen.
A shell program is a set of commands in a file or typed in.

	<example>for f in `grep -l widgets`
	do
		sed -e 's/widgets/gadgets/g' &lt;$f ${f}gadget
		echo $f
	done</example></p>

	  <p>Once you have stored a shell program in a program file, you have to make it
executable by running chmod:
<example>
        chmod a+x <var>my_program_file</var></example></p>
</sect1>
	<sect1>
	  <heading>Errors</heading>
	  <p>
Unix commands normally execute silently unless asked to be verbose
or unless there is an error. An error means something that does not
make sense to Linux; it doesn't mean something you don't want to
happen!</p>
	  <p>  For example, I once had a client who had some unwanted files
in his root directory which were named &amp;TEMP&amp; and so on.  As superuser
in the root directory he typed

	<tt>rm -rf /&amp;*</tt>

when he should have typed

	<tt>rm -rf \&amp;*</tt>

What he actually asked for was to delete his entire file system, as a
background job.  It did too.</p></sect1>
</sect>
      <sect id="regexp">
	<heading>Regular expressions</heading>
	<p>Regular expressions are a way of specifying some text to match
without having to spell it out exactly.  Regular expressions are used inside
editors and in the grep command.  They are not the same as the limited
file pattern matching that is done by the command line.</p>
	<p>A regular expression can be very simple or very complicated.
Complicated expressions are built up by joining together simple ones.  In this
section we are only dealing with simple uses of regular expressions in the
<prgn>grep</prgn> and <prgn>zgrep</prgn> commands.  The simplest expressions
are called atoms, because they cannot be broken down any further.</p>
	<p>Here are the regular expression atoms:<taglist>
	    <tag>character</tag>
	    <item>
	      <p>Any single character matches itself.</p>
	    </item>
	    <tag>.</tag>
	    <item>
	      <p>A full stop matches any single character.</p>
	    </item>
	    <tag>[ ]</tag>
	    <item>
	      <p>A list of characters in square brackets matches any
single character provided that it occurs inside the brackets. A range of
characters can be expressed inside the brackets by specifying the two
ends of the range separated by a minus sign.  For example, the regular
expression atom <tt>[ACafjl-rx]</tt> matches any one occurrence of the letters
`A', `C', `a', `f', `j', `l', `m', `n', `o', `p', `q', `r' or `x'.</p>
<p>The effect of this atom can be reversed by making `^' the first character
inside the brackets. This means that any character matches <em>except</em>
those in the brackets.</p>
	    </item>
	    <tag>^</tag>
	    <item>
	      <p>A circumflex character <em>outside</em> square brackets
indicates the beginning of a line. (So it can only have this meaning at the
beginning of a regular expression.)</p>
	    </item>
	    <tag>$</tag>
	    <item>
	      <p>A dollar character <em>outside</em> square brackets
indicates the end of a line. (So it can only have this meaning at the
end of a regular expression.)</p>
	    </item>
	    <tag>\</tag>
	    <item>
	      <p>A backslash escapes the character that follows it; that
is, it alters that character's meaning.  For example, use <tt>\*</tt> to
signify a real asterisk, or <tt>\\</tt> to signify a real backslash.</p>
<p>Some letters have special meanings if they follow a backslash:
<tt>\t</tt> matches a tab character, <tt>\f</tt> matches a form feed
character, and so on.</p>
	    </item>
</taglist></p>
<p>The regular expression atoms can be affected by these modifiers (+ and ?
have to be preceded by a backslash when used with <prgn>grep</prgn>):
<taglist>
	    <tag><var>re</var>*</tag>
	    <item>
	      <p>A regular expression followed by an asterisk is matched by
0 or more occurrences of that regular expression.  For example, 
<tt>b*</tt> matches `', `b', `bb', `bbbbbb' and so on.</p>
	    </item>
	    <tag><var>re</var>+</tag>
	    <item>
	      <p>A regular expression followed by a plus sign is matched by
1 or more occurrences of that regular expression.  For example, 
<tt>b+</tt> matches `b', `bb', `bbbbbb' and so on.</p>
	    </item>
	    <tag><var>re</var>?</tag>
	    <item>
	      <p>A regular expression followed by a question mark is matched by
0 or one occurrences of that regular expression.  For example, 
<tt>b?</tt> matches `' or `b'.</p>
	    </item>
	  </taglist>
</p>
	<p>Here is an example of the use of a regular expression with <prgn>grep</prgn>:<example>grep '^[A-Z][a-z]\+' basic_cmds.sgml</example>  This command would list all lines in <tt>basic_cmds.sgml</tt> that start with a capital letter immediately followed by one or more lower case letters.  The plus sign is escaped
with a backslash to make it have its special meaning.  The whole regular
expression is in single quotes to protect it from being evaluated by the
shell.
</p>
      </sect>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-doctype: ("/usr/local/src/user_manual/user.sgml")
sgml-parent-document: (/usr/local/src/user_manual/user.sgml "debiandoc" "book" "chapt" )
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
sgml-set-face:1
End:
-->
