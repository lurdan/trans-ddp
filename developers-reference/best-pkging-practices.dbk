<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
    "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
  <!ENTITY % commondata SYSTEM "common.ent" > %commondata;
]>
<chapter id="best-pkging-practices">
<title>Best Packaging Practices</title>
<para>
Debian's quality is largely due to the <ulink
url="&url-debian-policy;">Debian Policy</ulink>, which
defines explicit baseline requirements which all Debian packages must fulfill.
Yet there is also a shared history of experience which goes beyond the Debian
Policy, an accumulation of years of experience in packaging.  Many very
talented people have created great tools, tools which help you, the Debian
maintainer, create and maintain excellent packages.
</para>
<para>
This chapter provides some best practices for Debian developers.  All
recommendations are merely that, and are not requirements or policy.  These are
just some subjective hints, advice and pointers collected from Debian
developers.  Feel free to pick and choose whatever works best for you.
</para>
<section id="bpp-debian-rules">
<title>Best practices for <filename>debian/rules</filename></title>
<para>
The following recommendations apply to the <filename>debian/rules</filename>
file.  Since <filename>debian/rules</filename> controls the build process and
selects the files which go into the package (directly or indirectly), it's
usually the file maintainers spend the most time on.
</para>
<section id="helper-scripts">
<title>Helper scripts</title>
<para>
The rationale for using helper scripts in <filename>debian/rules</filename> is
that they let maintainers use and share common logic among many packages.  Take
for instance the question of installing menu entries: you need to put the file
into <filename>/usr/lib/menu</filename> (or <filename>/usr/lib/menu</filename>
for executable binary menufiles, if this is needed), and add commands to the
maintainer scripts to register and unregister the menu entries.  Since this is
a very common thing for packages to do, why should each maintainer rewrite all
this on their own, sometimes with bugs?  Also, supposing the menu directory
changed, every package would have to be changed.
</para>
<para>
Helper scripts take care of these issues.  Assuming you comply with the
conventions expected by the helper script, the helper takes care of all the
details.  Changes in policy can be made in the helper script; then packages
just need to be rebuilt with the new version of the helper and no other
changes.
</para>
<para>
<xref linkend="tools"/> contains a couple of different helpers.  The most
common and best (in our opinion) helper system is <systemitem
role="package">debhelper</systemitem>.  Previous helper systems, such as
<systemitem role="package">debmake</systemitem>, were monolithic: you couldn't
pick and choose which part of the helper you found useful, but had to use the
helper to do everything.  <systemitem role="package">debhelper</systemitem>,
however, is a number of separate little <command>dh_*</command> programs.  For
instance, <command>dh_installman</command> installs and compresses man pages,
<command>dh_installmenu</command> installs menu files, and so on.  Thus, it
offers enough flexibility to be able to use the little helper scripts, where
useful, in conjunction with hand-crafted commands in
<filename>debian/rules</filename>.
</para>
<para>
You can get started with <systemitem role="package">debhelper</systemitem> by
reading <citerefentry> <refentrytitle>debhelper</refentrytitle>
<manvolnum>1</manvolnum> </citerefentry>, and looking at the examples that come
with the package.  <command>dh_make</command>, from the <systemitem
role="package">dh-make</systemitem> package (see <xref linkend="dh-make"/> ),
can be used to convert a vanilla source package to a <systemitem
role="package">debhelper</systemitem>ized package.  This shortcut, though,
should not convince you that you do not need to bother understanding the
individual <command>dh_*</command> helpers.  If you are going to use a helper,
you do need to take the time to learn to use that helper, to learn its
expectations and behavior.
</para>
<para>
Some people feel that vanilla <filename>debian/rules</filename> files are
better, since you don't have to learn the intricacies of any helper system.
This decision is completely up to you.  Use what works for you.  Many examples
of vanilla <filename>debian/rules</filename> files are available at <ulink
url="&url-rules-files;"></ulink>.
</para>
</section>

<section id="multiple-patches">
<title>Separating your patches into multiple files</title>
<para>
Big, complex packages may have many bugs that you need to deal with.  If you
correct a number of bugs directly in the source, and you're not careful, it can
get hard to differentiate the various patches that you applied.  It can get
quite messy when you have to update the package to a new upstream version which
integrates some of the fixes (but not all).  You can't take the total set of
diffs (e.g., from <filename>.diff.gz</filename>) and work out which patch sets
to back out as a unit as bugs are fixed upstream.
</para>
<para>
Unfortunately, the packaging system as such currently doesn't provide for
separating the patches into several files.  Nevertheless, there are ways to
separate patches: the patch files are shipped within the Debian patch file
(<filename>.diff.gz</filename>), usually within the
<filename>debian/</filename> directory.  The only difference is that they
aren't applied immediately by dpkg-source, but by the <literal>build</literal>
rule of <filename>debian/rules</filename>.  Conversely, they are reverted in
the <literal>clean</literal> rule.
</para>
<para>
<command>dbs</command> is one of the more popular approaches to this.  It does
all of the above, and provides a facility for creating new and updating old
patches.  See the package <systemitem role="package">dbs</systemitem> for more
information and <systemitem role="package">hello-dbs</systemitem> for an
example.
</para>
<para>
<command>dpatch</command> also provides these facilities, but it's intended to
be even easier to use.  See the package <systemitem
role="package">dpatch</systemitem> for documentation and examples (in
<filename>/usr/share/doc/dpatch</filename>).
</para>
</section>

<section id="multiple-binary">
<title>Multiple binary packages</title>
<para>
A single source package will often build several binary packages, either to
provide several flavors of the same software (e.g., the <systemitem
role="package">vim</systemitem> source package) or to make several small
packages instead of a big one (e.g., so the user can install only the subset
needed, and thus save some disk space).
</para>
<para>
The second case can be easily managed in <filename>debian/rules</filename>.
You just need to move the appropriate files from the build directory into the
package's temporary trees.  You can do this using <command>install</command> or
<command>dh_install</command> from <systemitem
role="package">debhelper</systemitem>.  Be sure to check the different
permutations of the various packages, ensuring that you have the inter-package
dependencies set right in <filename>debian/control</filename>.
</para>
<para>
The first case is a bit more difficult since it involves multiple recompiles of
the same software but with different configuration options.  The <systemitem
role="package">vim</systemitem> source package is an example of how to manage
this using an hand-crafted <filename>debian/rules</filename> file.
</para>
<!-- FIXME: Find a good debhelper example with multiple configure/make
     cycles -->
</section>

</section>

<section id="bpp-debian-control">
<title>Best practices for <filename>debian/control</filename></title>
<para>
The following practices are relevant to the <filename>debian/control</filename>
file.  They supplement the <ulink
url="&url-debian-policy;ch-binary.html#s-descriptions">Policy
on package descriptions</ulink>.
</para>
<para>
The description of the package, as defined by the corresponding field in the
<filename>control</filename> file, contains both the package synopsis and the
long description for the package.  <xref linkend="bpp-desc-basics"/> describes
common guidelines for both parts of the package description.  Following that,
<xref linkend="bpp-pkg-synopsis"/> provides guidelines specific to the
synopsis, and <xref linkend="bpp-pkg-desc"/> contains guidelines specific to
the description.
</para>
<section id="bpp-desc-basics">
<title>General guidelines for package descriptions</title>
<para>
The package description should be written for the average likely user, the
average person who will use and benefit from the package.  For instance,
development packages are for developers, and can be technical in their
language.  More general-purpose applications, such as editors, should be
written for a less technical user.
</para>
<para>
Our review of package descriptions lead us to conclude that most package
descriptions are technical, that is, are not written to make sense for
non-technical users.  Unless your package really is only for technical users,
this is a problem.
</para>
<para>
How do you write for non-technical users?  Avoid jargon.  Avoid referring to
other applications or frameworks that the user might not be familiar with —
GNOME or KDE is fine, since users are probably familiar with these terms, but
GTK+ is probably not.  Try not to assume any knowledge at all.  If you must use
technical terms, introduce them.
</para>
<para>
Be objective.  Package descriptions are not the place for advocating your
package, no matter how much you love it.  Remember that the reader may not care
about the same things you care about.
</para>
<para>
References to the names of any other software packages, protocol names,
standards, or specifications should use their canonical forms, if one exists.
For example, use X Window System, X11, or X; not X Windows, X-Windows, or X
Window.  Use GTK+, not GTK or gtk.  Use GNOME, not Gnome.  Use PostScript, not
Postscript or postscript.
</para>
<para>
If you are having problems writing your description, you may wish to send it
along to &email-debian-l10n-english; and request feedback.
</para>
</section>

<section id="bpp-pkg-synopsis">
<title>The package synopsis, or short description</title>
<para>
The synopsis line (the short description) should be concise.  It must not
repeat the package's name (this is policy).
</para>
<para>
It's a good idea to think of the synopsis as an appositive clause, not a full
sentence.  An appositive clause is defined in WordNet as a grammatical relation
between a word and a noun phrase that follows, e.g., Rudolph the red-nosed
reindeer.  The appositive clause here is red-nosed reindeer.  Since the
synopsis is a clause, rather than a full sentence, we recommend that it neither
start with a capital nor end with a full stop (period).  It should also not
begin with an article, either definite (the) or indefinite (a or an).
</para>
<para>
It might help to imagine that the synopsis is combined with the package name in
the following way:
</para>
<screen>
<replaceable>package-name</replaceable> is a <replaceable>synopsis</replaceable>.
</screen>
<para>
Alternatively, it might make sense to think of it as
</para>
<screen>
<replaceable>package-name</replaceable> is <replaceable>synopsis</replaceable>.
</screen>
<para>
or, if the package name itself is a plural (such as developers-tools)
</para>
<screen>
<replaceable>package-name</replaceable> are <replaceable>synopsis</replaceable>.
</screen>
<para>
This way of forming a sentence from the package name and synopsis should be
considered as a heuristic and not a strict rule.  There are some cases where it
doesn't make sense to try to form a sentence.
</para>
</section>

<section id="bpp-pkg-desc">
<title>The long description</title>
<para>
The long description is the primary information available to the user about a
package before they install it.  It should provide all the information needed
to let the user decide whether to install the package.  Assume that the user
has already read the package synopsis.
</para>
<para>
The long description should consist of full and complete sentences.
</para>
<para>
The first paragraph of the long description should answer the following
questions: what does the package do?  what task does it help the user
accomplish?  It is important to describe this in a non-technical way, unless of
course the audience for the package is necessarily technical.
</para>
<para>
The following paragraphs should answer the following questions: Why do I as a
user need this package?  What other features does the package have?  What
outstanding features and deficiencies are there compared to other packages
(e.g., if you need X, use Y instead)?  Is this package related to other
packages in some way that is not handled by the package manager (e.g., this is
the client for the foo server)?
</para>
<para>
Be careful to avoid spelling and grammar mistakes.  Ensure that you spell-check
it.  Both <command>ispell</command> and <command>aspell</command> have special
modes for checking <filename>debian/control</filename> files:
</para>
<screen>
ispell -d american -g debian/control
</screen>
<screen>
aspell -d en -D -c debian/control
</screen>
<para>
Users usually expect these questions to be answered in the package description:
</para>
<itemizedlist>
<listitem>
<para>
What does the package do?  If it is an add-on to another package, then the
short description of the package we are an add-on to should be put in here.
</para>
</listitem>
<listitem>
<para>
Why should I want this package?  This is related to the above, but not the same
(this is a mail user agent; this is cool, fast, interfaces with PGP and LDAP
and IMAP, has features X, Y, and Z).
</para>
</listitem>
<listitem>
<para>
If this package should not be installed directly, but is pulled in by another
package, this should be mentioned.
</para>
</listitem>
<listitem>
<para>
If the package is experimental, or there are other reasons it should not be
used, if there are other packages that should be used instead, it should be
here as well.
</para>
</listitem>
<listitem>
<para>
How is this package different from the competition?  Is it a better
implementation?  more features?  different features?  Why should I choose this
package.
</para>
</listitem>
<!-- FIXME: what's this?
(the second questions is about the class of packages, and
this about this particular package, if you have information related to both).
-->
</itemizedlist>
</section>

<section id="bpp-upstream-info">
<title>Upstream home page</title>
<para>
We recommend that you add the URL for the package's home page in the
<literal>Homepage</literal> field of the <literal>Source</literal> section
in <filename>debian/control</filename>.  Adding this information in the
package description itself is considered deprecated.
</para>
</section>

<section id="bpp-vcs">
<title>Version Control System location</title>
<para>
There are additional fields for the location of the Version Control System in
<filename>debian/control</filename>.
</para>
<section id="s6.2.5.1">
<title>Vcs-Browser</title>
<para>
Value of this field should be a <literal>http://</literal> URL pointing to a
web-browsable copy of the Version Control System repository used to maintain
the given package, if available.
</para>
<para>
The information is meant to be useful for the final user, willing to browse the
latest work done on the package (e.g.  when looking for the patch fixing a bug
tagged as <literal>pending</literal> in the bug tracking system).
</para>
</section>

<section id="s6.2.5.2">
<title>Vcs-*</title>
<para>
Value of this field should be a string identifying unequivocally the location
of the Version Control System repository used to maintain the given package, if
available.  <literal>*</literal> identify the Version Control System; currently
the following systems are supported by the package tracking system:
<literal>arch</literal>, <literal>bzr</literal> (Bazaar),
<literal>cvs</literal>, <literal>darcs</literal>, <literal>git</literal>,
<literal>hg</literal> (Mercurial), <literal>mtn</literal> (Monotone),
<literal>svn</literal> (Subversion).  It is allowed to specify different VCS
fields for the same package: they will all be shown in the PTS web interface.
</para>
<para>
The information is meant to be useful for a user knowledgeable in the given
Version Control System and willing to build the current version of a package
from the VCS sources.  Other uses of this information might include automatic
building of the latest VCS version of the given package.  To this end the
location pointed to by the field should better be version agnostic and point to
the main branch (for VCSs supporting such a concept).  Also, the location
pointed to should be accessible to the final user; fulfilling this requirement
might imply pointing to an anonymous access of the repository instead of
pointing to an SSH-accessible version of the same.
</para>
<para>
In the following example, an instance of the field for a Subversion repository
of the <systemitem role="package">vim</systemitem> package is shown.  Note how
the URL is in the <literal>svn://</literal> scheme (instead of
<literal>svn+ssh://</literal>) and how it points to the
<filename>trunk/</filename> branch.  The use of the
<literal>Vcs-Browser</literal> and <literal>Homepage</literal> fields
described above is also shown.
</para>
<screen>
  Source: vim
  Section: editors
  Priority: optional
  &lt;snip&gt;
  Vcs-Svn: svn://svn.debian.org/svn/pkg-vim/trunk/packages/vim
  Vcs-Browser: http://svn.debian.org/wsvn/pkg-vim/trunk/packages/vim
  Homepage: http://www.vim.org
</screen>
</section>

</section>

</section>

<section id="bpp-debian-changelog">
<title>Best practices for <filename>debian/changelog</filename></title>
<para>
The following practices supplement the <ulink
url="&url-debian-policy;ch-docs.html#s-changelogs">Policy
on changelog files</ulink>.
</para>
<section id="bpp-changelog-do">
<title>Writing useful changelog entries</title>
<para>
The changelog entry for a package revision documents changes in that revision,
and only them.  Concentrate on describing significant and user-visible changes
that were made since the last version.
</para>
<para>
Focus on <emphasis>what</emphasis> was changed — who, how and when are
usually less important.  Having said that, remember to politely attribute
people who have provided notable help in making the package (e.g., those who
have sent in patches).
</para>
<para>
There's no need to elaborate the trivial and obvious changes.  You can also
aggregate several changes in one entry.  On the other hand, don't be overly
terse if you have undertaken a major change.  Be especially clear if there are
changes that affect the behaviour of the program.  For further explanations,
use the <filename>README.Debian</filename> file.
</para>
<para>
Use common English so that the majority of readers can comprehend it.  Avoid
abbreviations, tech-speak and jargon when explaining changes that close bugs,
especially for bugs filed by users that did not strike you as particularly
technically savvy.  Be polite, don't swear.
</para>
<para>
It is sometimes desirable to prefix changelog entries with the names of the
files that were changed.  However, there's no need to explicitly list each and
every last one of the changed files, especially if the change was small or
repetitive.  You may use wildcards.
</para>
<para>
When referring to bugs, don't assume anything.  Say what the problem was, how
it was fixed, and append the closes: #nnnnn string.  See <xref
linkend="upload-bugfix"/> for more information.
</para>
</section>

<section id="bpp-changelog-misconceptions">
<title>Common misconceptions about changelog entries</title>
<para>
The changelog entries should <emphasis role="strong">not</emphasis> document
generic packaging issues (Hey, if you're looking for foo.conf, it's in
/etc/blah/.), since administrators and users are supposed to be at least
remotely acquainted with how such things are generally arranged on Debian
systems.  Do, however, mention if you change the location of a configuration
file.
</para>
<para>
The only bugs closed with a changelog entry should be those that are actually
fixed in the same package revision.  Closing unrelated bugs in the changelog is
bad practice.  See <xref linkend="upload-bugfix"/> .
</para>
<para>
The changelog entries should <emphasis role="strong">not</emphasis> be used for
random discussion with bug reporters (I don't see segfaults when starting foo
with option bar; send in more info), general statements on life, the universe
and everything (sorry this upload took me so long, but I caught the flu), or
pleas for help (the bug list on this package is huge, please lend me a hand).
Such things usually won't be noticed by their target audience, but may annoy
people who wish to read information about actual changes in the package.  See
<xref linkend="bug-answering"/> for more information on how to use the bug
tracking system.
</para>
<para>
It is an old tradition to acknowledge bugs fixed in non-maintainer uploads in
the first changelog entry of the proper maintainer upload.  As we have version
tracking now, it is enough to keep the NMUed changelog entries and just mention
this fact in your own changelog entry.
</para>
</section>

<section id="bpp-changelog-errors">
<title>Common errors in changelog entries</title>
<para>
The following examples demonstrate some common errors or examples of bad style
in changelog entries.
</para>
<screen>
  * Fixed all outstanding bugs.
</screen>
<para>
This doesn't tell readers anything too useful, obviously.
</para>
<screen>
  * Applied patch from Jane Random.
</screen>
<para>
What was the patch about?
</para>
<screen>
  * Late night install target overhaul.
</screen>
<para>
Overhaul which accomplished what?  Is the mention of late night supposed to
remind us that we shouldn't trust that code?
</para>
<screen>
  * Fix vsync FU w/ ancient CRTs.
</screen>
<para>
Too many acronyms, and it's not overly clear what the, uh, fsckup (oops, a
curse word!) was actually about, or how it was fixed.
</para>
<screen>
  * This is not a bug, closes: #nnnnnn.
</screen>
<para>
First of all, there's absolutely no need to upload the package to convey this
information; instead, use the bug tracking system.  Secondly, there's no
explanation as to why the report is not a bug.
</para>
<screen>
  * Has been fixed for ages, but I forgot to close; closes: #54321.
</screen>
<para>
If for some reason you didn't mention the bug number in a previous changelog
entry, there's no problem, just close the bug normally in the BTS.  There's no
need to touch the changelog file, presuming the description of the fix is
already in (this applies to the fixes by the upstream authors/maintainers as
well, you don't have to track bugs that they fixed ages ago in your changelog).
</para>
<screen>
  * Closes: #12345, #12346, #15432
</screen>
<para>
Where's the description?  If you can't think of a descriptive message, start by
inserting the title of each different bug.
</para>
</section>

<section id="bpp-news-debian">
<title>Supplementing changelogs with NEWS.Debian files</title>
<para>
Important news about changes in a package can also be put in NEWS.Debian files.
The news will be displayed by tools like apt-listchanges, before all the rest
of the changelogs.  This is the preferred means to let the user know about
significant changes in a package.  It is better than using debconf notes since
it is less annoying and the user can go back and refer to the NEWS.Debian file
after the install.  And it's better than listing major changes in
README.Debian, since the user can easily miss such notes.
</para>
<para>
The file format is the same as a debian changelog file, but leave off the
asterisks and describe each news item with a full paragraph when necessary
rather than the more concise summaries that would go in a changelog.  It's a
good idea to run your file through dpkg-parsechangelog to check its formatting
as it will not be automatically checked during build as the changelog is.  Here
is an example of a real NEWS.Debian file:
</para>
<screen>
cron (3.0pl1-74) unstable; urgency=low

    The checksecurity script is no longer included with the cron package:
    it now has its own package, checksecurity. If you liked the
    functionality provided with that script, please install the new
    package.

 -- Steve Greenland &lt;stevegr@debian.org&gt;  Sat,  6 Sep 2003 17:15:03 -0500
</screen>
<para>
The NEWS.Debian file is installed as
/usr/share/doc/&lt;package&gt;/NEWS.Debian.gz.  It is compressed, and always
has that name even in Debian native packages.  If you use debhelper,
dh_installchangelogs will install debian/NEWS files for you.
</para>
<para>
Unlike changelog files, you need not update NEWS.Debian files with every
release.  Only update them if you have something particularly newsworthy that
user should know about.  If you have no news at all, there's no need to ship a
NEWS.Debian file in your package.  No news is good news!
</para>
</section>

</section>

<!--
<section id="pkg-mgmt-cvs">
<title>Managing a package with CVS</title>
<para>
FIXME: presentation of cvs-buildpackage, updating sources
via CVS (debian/rules refresh).
<ulink url="&url-devel-docs;cvs_packages">"&url-devel-docs;cvs_packages"</ulink>
</para>
</section>
-->

<section id="bpp-debian-maint-scripts">
<title>Best practices for maintainer scripts</title>
<para>
Maintainer scripts include the files <filename>debian/postinst</filename>,
<filename>debian/preinst</filename>, <filename>debian/prerm</filename> and
<filename>debian/postrm</filename>.  These scripts take care of any package
installation or deinstallation setup which isn't handled merely by the creation
or removal of files and directories.  The following instructions supplement the
<ulink url="&url-debian-policy;">Debian Policy</ulink>.
</para>
<para>
Maintainer scripts must be idempotent.  That means that you need to make sure
nothing bad will happen if the script is called twice where it would usually be
called once.
</para>
<para>
Standard input and output may be redirected (e.g.  into pipes) for logging
purposes, so don't rely on them being a tty.
</para>
<para>
All prompting or interactive configuration should be kept to a minimum.  When
it is necessary, you should use the <systemitem
role="package">debconf</systemitem> package for the interface.  Remember that
prompting in any case can only be in the <literal>configure</literal> stage of
the <filename>postinst</filename> script.
</para>
<para>
Keep the maintainer scripts as simple as possible.  We suggest you use pure
POSIX shell scripts.  Remember, if you do need any bash features, the
maintainer script must have a bash shebang line.  POSIX shell or Bash are
preferred to Perl, since they enable <systemitem
role="package">debhelper</systemitem> to easily add bits to the scripts.
</para>
<para>
If you change your maintainer scripts, be sure to test package removal, double
installation, and purging.  Be sure that a purged package is completely gone,
that is, it must remove any files created, directly or indirectly, in any
maintainer script.
</para>
<para>
If you need to check for the existence of a command, you should use something
like
</para>
<programlisting>if [ -x /usr/sbin/install-docs ]; then ...</programlisting>
<para>
If you don't wish to hard-code the path of a command in your maintainer script,
the following POSIX-compliant shell function may help:
</para>
&example-pathfind;
<para>
You can use this function to search <literal>$PATH</literal> for a command
name, passed as an argument.  It returns true (zero) if the command was found,
and false if not.  This is really the most portable way, since <literal>command
-v</literal>, <command>type</command>, and <command>which</command> are not
POSIX.
</para>
<para>
While <command>which</command> is an acceptable alternative, since it is from
the required <systemitem role="package">debianutils</systemitem> package, it's
not on the root partition.  That is, it's in <filename>/usr/bin</filename>
rather than <filename>/bin</filename>, so one can't use it in scripts which are
run before the <filename>/usr</filename> partition is mounted.  Most scripts
won't have this problem, though.
</para>
</section>

<section id="bpp-config-mgmt">
<title>Configuration management with <systemitem role="package">debconf</systemitem></title>
<para>
<systemitem role="package">Debconf</systemitem> is a configuration management
system which can be used by all the various packaging scripts
(<filename>postinst</filename> mainly) to request feedback from the user
concerning how to configure the package.  Direct user interactions must now be
avoided in favor of <systemitem role="package">debconf</systemitem>
interaction.  This will enable non-interactive installations in the future.
</para>
<para>
Debconf is a great tool but it is often poorly used.  Many common mistakes are
listed in the <citerefentry> <refentrytitle>debconf-devel</refentrytitle>
<manvolnum>7</manvolnum> </citerefentry> man page.  It is something that you
must read if you decide to use debconf.  Also, we document some best practices
here.
</para>
<para>
These guidelines include some writing style and typography recommendations,
general considerations about debconf usage as well as more specific
recommendations for some parts of the distribution (the installation system for
instance).
</para>
<section id="s6.5.1">
<title>Do not abuse debconf</title>
<para>
Since debconf appeared in Debian, it has been widely abused and several
criticisms received by the Debian distribution come from debconf abuse with the
need of answering a wide bunch of questions before getting any little thing
installed.
</para>
<para>
Keep usage notes to what they belong: the NEWS.Debian, or README.Debian file.
Only use notes for important notes which may directly affect the package
usability.  Remember that notes will always block the install until confirmed
or bother the user by email.
</para>
<para>
Carefully choose the questions priorities in maintainer scripts.  See
<citerefentry> <refentrytitle>debconf-devel</refentrytitle>
<manvolnum>7</manvolnum> </citerefentry> for details about priorities.  Most
questions should use medium and low priorities.
</para>
</section>

<section id="s6.5.2">
<title>General recommendations for authors and translators</title>
<section id="s6.5.2.1">
<title>Write correct English</title>
<para>
Most Debian package maintainers are not native English speakers.  So, writing
properly phrased templates may not be easy for them.
</para>
<para>
Please use (and abuse) &email-debian-l10n-english; mailing
list.  Have your templates proofread.
</para>
<para>
Badly written templates give a poor image of your package, of your work...or
even of Debian itself.
</para>
<para>
Avoid technical jargon as much as possible.  If some terms sound common to you,
they may be impossible to understand for others.  If you cannot avoid them, try
to explain them (use the extended description).  When doing so, try to balance
between verbosity and simplicity.
</para>
</section>

<section id="s6.5.2.2">
<title>Be kind to translators</title>
<para>
Debconf templates may be translated.  Debconf, along with its sister package
<command>po-debconf</command> offers a simple framework for getting templates
translated by translation teams or even individuals.
</para>
<para>
Please use gettext-based templates.  Install <systemitem
role="package">po-debconf</systemitem> on your development system and read its
documentation (man po-debconf is a good start).
</para>
<para>
Avoid changing templates too often.  Changing templates text induces more work
to translators which will get their translation fuzzied.  If you plan changes
to your original templates, please contact translators.  Most active
translators are very responsive and getting their work included along with your
modified templates will save you additional uploads.  If you use gettext-based
templates, the translator's name and e-mail addresses are mentioned in the po
files headers.
</para>
<para>
The use of the <command>podebconf-report-po</command> from the po-debconf
package is highly recommended to warn translators which have incomplete
translations and request them for updates.
</para>
<para>
If in doubt, you may also contact the translation team for a given language
(debian-l10n-xxxxx@&lists-host;), or the
&email-debian-i18n; mailing list.
</para>
<para>
Calls for translations posted to &email-debian-i18n; with the
<filename>debian/po/templates.pot</filename> file attached or referenced in a
URL are encouraged.  Be sure to mentions in these calls for new translations
which languages you have existing translations for, in order to avoid duplicate
work.
</para>
</section>

<section id="s6.5.2.3">
<title>Unfuzzy complete translations when correcting typos and spelling</title>
<para>
When the text of a debconf template is corrected and you are <emphasis
role="strong">sure</emphasis> that the change does <emphasis
role="strong">not</emphasis> affect translations, please be kind to translators
and unfuzzy their translations.
</para>
<para>
If you don't do so, the whole template will not be translated as long as a
translator will send you an update.
</para>
<para>
To <emphasis role="strong">unfuzzy</emphasis> translations, you can proceed the
following way:
</para>
<orderedlist numeration="arabic">
<listitem>
<para>
Put all incomplete PO files out of the way.  You can check the completeness by
using (needs the <systemitem role="package">gettext</systemitem> package
installed):
</para>
<programlisting>for i in debian/po/*po; do echo -n $i: ; msgfmt -o /dev/null
--statistics $i; done</programlisting>
</listitem>
<listitem>
<para>
move all files which report either fuzzy strings to a temporary place.  Files
which report no fuzzy strings (only translated and untranslated) will be kept
in place.
</para>
</listitem>
<listitem>
<para>
now <emphasis role="strong">and now only</emphasis>, modify the template for
the typos and check again that translation are not impacted (typos, spelling
errors, sometimes typographical corrections are usually OK)
</para>
</listitem>
<listitem>
<para>
run <command>debconf-updatepo</command>.  This will fuzzy all strings you
modified in translations.  You can see this by running the above again
</para>
</listitem>
<listitem>
<para>
use the following command:
</para>
<programlisting>for i in debian/po/*po; do msgattrib --output-file=$i --clear-fuzzy $i; done</programlisting>
</listitem>
<listitem>
<para>
move back to debian/po the files which showed fuzzy strings in the first step
</para>
</listitem>
<listitem>
<para>
run <command>debconf-updatepo</command> again
</para>
</listitem>
</orderedlist>
</section>

<section id="s6.5.2.4">
<title>Do not make assumptions about interfaces</title>
<para>
Templates text should not make reference to widgets belonging to some debconf
interfaces.  Sentences like If you answer Yes...  have no meaning for users of
graphical interfaces which use checkboxes for boolean questions.
</para>
<para>
String templates should also avoid mentioning the default values in their
description.  First, because this is redundant with the values seen by the
users.  Also, because these default values may be different from the maintainer
choices (for instance, when the debconf database was preseeded).
</para>
<para>
More generally speaking, try to avoid referring to user actions.  Just give
facts.
</para>
</section>

<section id="s6.5.2.5">
<title>Do not use first person</title>
<para>
You should avoid the use of first person (I will do this...  or We
recommend...).  The computer is not a person and the Debconf templates do not
speak for the Debian developers.  You should use neutral construction.  Those
of you who already wrote scientific publications, just write your templates
like you would write a scientific paper.  However, try using action voice if
still possible, like Enable this if ...  instead of This can be enabled if ....
</para>
</section>

<section id="s6.5.2.6">
<title>Be gender neutral</title>
<para>
The world is made of men and women.  Please use gender-neutral constructions in
your writing.
</para>
</section>

</section>

<section id="s6.5.3">
<title>Templates fields definition</title>
<para>
This part gives some information which is mostly taken from the <citerefentry>
<refentrytitle>debconf-devel</refentrytitle> <manvolnum>7</manvolnum>
</citerefentry> manual page.
</para>
<section id="s6.5.3.1">
<title>Type</title>
<section id="s6.5.3.1.1">
<title>string:</title>
<para>
Results in a free-form input field that the user can type any string into.
</para>
</section>

<section id="s6.5.3.1.2">
<title>password:</title>
<para>
Prompts the user for a password.  Use this with caution; be aware that the
password the user enters will be written to debconf's database.  You should
probably clean that value out of the database as soon as is possible.
</para>
</section>

<section id="s6.5.3.1.3">
<title>boolean:</title>
<para>
A true/false choice.  Remember: true/false, <emphasis role="strong">not
yes/no</emphasis>...
</para>
</section>

<section id="s6.5.3.1.4">
<title>select:</title>
<para>
A choice between one of a number of values.  The choices must be specified in a
field named 'Choices'.  Separate the possible values with commas and spaces,
like this: Choices: yes, no, maybe
</para>
</section>

<section id="s6.5.3.1.5">
<title>multiselect:</title>
<para>
Like the select data type, except the user can choose any number of items from
the choices list (or chose none of them).
</para>
</section>

<section id="s6.5.3.1.6">
<title>note:</title>
<para>
Rather than being a question per se, this datatype indicates a note that can be
displayed to the user.  It should be used only for important notes that the
user really should see, since debconf will go to great pains to make sure the
user sees it; halting the install for them to press a key, and even mailing the
note to them in some cases.
</para>
</section>

<section id="s6.5.3.1.7">
<title>text:</title>
<para>
This type is now considered obsolete: don't use it.
</para>
</section>

<section id="s6.5.3.1.8">
<title>error:</title>
<para>
This type is designed to handle error messages.  It is mostly similar to the
note type.  Frontends may present it differently (for instance, the dialog
frontend of cdebconf draws a red screen instead of the usual blue one).
</para>
<para>
It is recommended to use this type for any message that needs user attention
for a correction of any kind.
</para>
</section>

</section>

<section id="s6.5.3.2">
<title>Description: short and extended description</title>
<para>
Template descriptions have two parts: short and extended.  The short
description is in the Description: line of the template.
</para>
<para>
The short description should be kept short (50 characters or so) so that it may
be accomodated by most debconf interfaces.  Keeping it short also helps
translators, as usually translations tend to end up being longer than the
original.
</para>
<para>
The short description should be able to stand on its own.  Some interfaces do
not show the long description by default, or only if the user explicitely asks
for it or even do not show it at all.  Avoid things like What do you want to
do?
</para>
<para>
The short description does not necessarily have to be a full sentence.  This is
part of the keep it short and efficient recommendation.
</para>
<para>
The extended description should not repeat the short description word for word.
If you can't think up a long description, then first, think some more.  Post to
debian-devel.  Ask for help.  Take a writing class!  That extended description
is important.  If after all that you still can't come up with anything, leave
it blank.
</para>
<para>
The extended description should use complete sentences.  Paragraphs should be
kept short for improved readability.  Do not mix two ideas in the same
paragraph but rather use another paragraph.
</para>
<para>
Don't be too verbose.  User tend to ignore too long screens.  20 lines are by
experience a border you shouldn't cross, because that means that in the
classical dialog interface, people will need to scroll, and lot of people just
don't do that.
</para>
<para>
The extended description should <emphasis role="strong">never</emphasis>
include a question.
</para>
<para>
For specific rules depending on templates type (string, boolean, etc.), please
read below.
</para>
</section>

<section id="s6.5.3.3">
<title>Choices</title>
<para>
This field should be used for Select and Multiselect types.  It contains the
possible choices which will be presented to users.  These choices should be
separated by commas.
</para>
</section>

<section id="s6.5.3.4">
<title>Default</title>
<para>
This field is optional.  It contains the default answer for string, select and
multiselect templates.  For multiselect templates, it may contain a
comma-separated list of choices.
</para>
</section>

</section>

<section id="s6.5.4">
<title>Templates fields specific style guide</title>
<section id="s6.5.4.1">
<title>Type field</title>
<para>
No specific indication except: use the appropriate type by referring to the
previous section.
</para>
</section>

<section id="s6.5.4.2">
<title>Description field</title>
<para>
Below are specific instructions for properly writing the Description (short and
extended) depending on the template type.
</para>
<section id="s6.5.4.2.1">
<title>String/password templates</title>
<itemizedlist>
<listitem>
<para>
The short description is a prompt and <emphasis role="strong">not</emphasis> a
title.  Avoid question style prompts (IP Address?) in favour of opened prompts
(IP address:).  The use of colons is recommended.
</para>
</listitem>
<listitem>
<para>
The extended description is a complement to the short description.  In the
extended part, explain what is being asked, rather than ask the same question
again using longer words.  Use complete sentences.  Terse writing style is
strongly discouraged.
</para>
</listitem>
</itemizedlist>
</section>

<section id="s6.5.4.2.2">
<title>Boolean templates</title>
<itemizedlist>
<listitem>
<para>
The short description should be phrased in the form of a question which should
be kept short and should generally end with a question mark.  Terse writing
style is permitted and even encouraged if the question is rather long (remember
that translations are often longer than original versions)
</para>
</listitem>
<listitem>
<para>
Again, please avoid referring to specific interface widgets.  A common mistake
for such templates is if you answer Yes-type constructions.
</para>
</listitem>
</itemizedlist>
</section>

<section id="s6.5.4.2.3">
<title>Select/Multiselect</title>
<itemizedlist>
<listitem>
<para>
The short description is a prompt and <emphasis role="strong">not</emphasis> a
title.  Do <emphasis role="strong">not</emphasis> use useless Please choose...
constructions.  Users are clever enough to figure out they have to choose
something...:)
</para>
</listitem>
<listitem>
<para>
The extended description will complete the short description.  It may refer to
the available choices.  It may also mention that the user may choose more than
one of the available choices, if the template is a multiselect one (although
the interface often makes this clear).
</para>
</listitem>
</itemizedlist>
</section>

<section id="s6.5.4.2.4">
<title>Notes</title>
<itemizedlist>
<listitem>
<para>
The short description should be considered to be a *title*.
</para>
</listitem>
<listitem>
<para>
The extended description is what will be displayed as a more detailed
explanation of the note.  Phrases, no terse writing style.
</para>
</listitem>
<listitem>
<para>
<emphasis role="strong">Do not abuse debconf.</emphasis> Notes are the most
common way to abuse debconf.  As written in debconf-devel manual page: it's
best to use them only for warning about very serious problems.  The NEWS.Debian
or README.Debian files are the appropriate location for a lot of notes.  If, by
reading this, you consider converting your Note type templates to entries in
NEWS/Debian or README.Debian, plus consider keeping existing translations for
the future.
</para>
</listitem>
</itemizedlist>
</section>

</section>

<section id="s6.5.4.3">
<title>Choices field</title>
<para>
If the Choices are likely to change often, please consider using the __Choices
trick.  This will split each individual choice into a single string, which will
considerably help translators for doing their work.
</para>
</section>

<section id="s6.5.4.4">
<title>Default field</title>
<para>
If the default value, for a select template, is likely to vary depending on the
user language (for instance, if the choice is a language choice), please use
the _DefaultChoice trick.
</para>
<para>
This special field allow translators to put the most appropriate choice
according to their own language.  It will become the default choice when their
language is used while your own mentioned Default Choice will be used chan
using English.
</para>
<para>
Example, taken from the geneweb package templates:
</para>
<screen>
Template: geneweb/lang
Type: select
__Choices: Afrikaans (af), Bulgarian (bg), Catalan (ca), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), English (en), Esperanto (eo), Estonian (et), Finnish (fi), French (fr), German (de), Hebrew (he), Icelandic (is), Italian (it), Latvian (lv), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv)
# This is the default choice. Translators may put their own language here
# instead of the default.
# WARNING : you MUST use the ENGLISH FORM of your language
# For instance, the french translator will need to put French (fr) here.
_DefaultChoice: English (en)[ translators, please see comment in PO files]
_Description: Geneweb default language:
</screen>
<para>
Note the use of brackets which allow internal comments in debconf fields.  Also
note the use of comments which will show up in files the translators will work
with.
</para>
<para>
The comments are needed as the DefaultChoice trick is a bit confusing: the
translators may put their own choice
</para>
</section>

<section id="s6.5.4.5">
<title>Default field</title>
<para>
Do NOT use empty default field.  If you don't want to use default values, do
not use Default at all.
</para>
<para>
If you use po-debconf (and you <emphasis role="strong">should</emphasis>, see
2.2), consider making this field translatable, if you think it may be
translated.
</para>
<para>
If the default value may vary depending on language/country (for instance the
default value for a language choice), consider using the special _DefaultChoice
type documented in <citerefentry> <refentrytitle>po-debconf</refentrytitle>
<manvolnum>7</manvolnum> </citerefentry>).
</para>
</section>

</section>

</section>

<section id="bpp-i18n">
<title>Internationalization</title>
<section id="bpp-i18n-debconf">
<title>Handling debconf translations</title>
<para>
Like porters, translators have a difficult task.  They work on many packages
and must collaborate with many different maintainers.  Moreover, most of the
time, they are not native English speakers, so you may need to be particularly
patient with them.
</para>
<para>
The goal of <systemitem role="package">debconf</systemitem> was to make
packages configuration easier for maintainers and for users.  Originally,
translation of debconf templates was handled with
<command>debconf-mergetemplate</command>.  However, that technique is now
deprecated; the best way to accomplish <systemitem
role="package">debconf</systemitem> internationalization is by using the
<systemitem role="package">po-debconf</systemitem> package.  This method is
easier both for maintainer and translators; transition scripts are provided.
</para>
<para>
Using <systemitem role="package">po-debconf</systemitem>, the translation is
stored in <filename>po</filename> files (drawing from
<command>gettext</command> translation techniques).  Special template files
contain the original messages and mark which fields are translatable.  When you
change the value of a translatable field, by calling
<command>debconf-updatepo</command>, the translation is marked as needing
attention from the translators.  Then, at build time, the
<command>dh_installdebconf</command> program takes care of all the needed magic
to add the template along with the up-to-date translations into the binary
packages.  Refer to the <citerefentry>
<refentrytitle>po-debconf</refentrytitle> <manvolnum>7</manvolnum>
</citerefentry> manual page for details.
</para>
</section>

<section id="bpp-i18n-docs">
<title>Internationalized documentation</title>
<para>
Internationalizing documentation is crucial for users, but a lot of labor.
There's no way to eliminate all that work, but you can make things easier for
translators.
</para>
<para>
If you maintain documentation of any size, its easier for translators if they
have access to a source control system.  That lets translators see the
differences between two versions of the documentation, so, for instance, they
can see what needs to be retranslated.  It is recommended that the translated
documentation maintain a note about what source control revision the
translation is based on.  An interesting system is provided by <ulink
url="&url-i18n-doc-check;">doc-check</ulink> in the
<systemitem role="package">boot-floppies</systemitem> package, which shows an
overview of the translation status for any given language, using structured
comments for the current revision of the file to be translated and, for a
translated file, the revision of the original file the translation is based on.
You might wish to adapt and provide that in your CVS area.
</para>
<para>
If you maintain XML or SGML documentation, we suggest that you isolate any
language-independent information and define those as entities in a separate
file which is included by all the different translations.  This makes it much
easier, for instance, to keep URLs up to date across multiple files.
</para>
</section>

</section>

<section id="bpp-common-situations">
<title>Common packaging situations</title>
<!--
<section id="bpp-kernel">
<title>Kernel modules/patches</title>
<para>
FIXME: Heavy use of kernel-package. provide files in
/etc/modutils/ for module configuration.
</para>
</section>
-->
<section id="bpp-autotools">
<title>Packages using <command>autoconf</command>/<command>automake</command></title>
<para>
Keeping <command>autoconf</command>'s <filename>config.sub</filename> and
<filename>config.guess</filename> files up to date is critical for porters,
especially on more volatile architectures.  Some very good packaging practices
for any package using <command>autoconf</command> and/or
<command>automake</command> have been synthesized in
&file-bpp-autotools; from the
<systemitem role="package">autotools-dev</systemitem> package.  You're strongly
encouraged to read this file and to follow the given recommendations.
</para>
</section>

<section id="bpp-libraries">
<title>Libraries</title>
<para>
Libraries are always difficult to package for various reasons.  The policy
imposes many constraints to ease their maintenance and to make sure upgrades
are as simple as possible when a new upstream version comes out.  Breakage in a
library can result in dozens of dependent packages breaking.
</para>
<para>
Good practices for library packaging have been grouped in <ulink
url="&url-libpkg-guide;">the library
packaging guide</ulink>.
</para>
</section>

<section id="bpp-docs">
<title>Documentation</title>
<para>
Be sure to follow the <ulink
url="&url-debian-policy;ch-docs.html">Policy on
documentation</ulink>.
</para>
<para>
If your package contains documentation built from XML or SGML, we recommend you
not ship the XML or SGML source in the binary package(s).  If users want the
source of the documentation, they should retrieve the source package.
</para>
<para>
Policy specifies that documentation should be shipped in HTML format.  We also
recommend shipping documentation in PDF and plain text format if convenient and
if output of reasonable quality is possible.  However, it is generally not
appropriate to ship plain text versions of documentation whose source format is
HTML.
</para>
<para>
Major shipped manuals should register themselves with <systemitem
role="package">doc-base</systemitem> on installation.  See the <systemitem
role="package">doc-base</systemitem> package documentation for more
information.
</para>
</section>

<section id="bpp-other">
<title>Specific types of packages</title>
<para>
Several specific types of packages have special sub-policies and corresponding
packaging rules and practices:
</para>
<itemizedlist>
<listitem>
<para>
Perl related packages have a <ulink
url="&url-perl-policy;">Perl
policy</ulink>, some examples of packages following that policy are <systemitem
role="package">libdbd-pg-perl</systemitem> (binary perl module) or <systemitem
role="package">libmldbm-perl</systemitem> (arch independent perl module).
</para>
</listitem>
<listitem>
<para>
Python related packages have their python policy; see
&file-python-policy; in the <systemitem
role="package">python</systemitem> package.
</para>
</listitem>
<listitem>
<para>
Emacs related packages have the <ulink
url="&url-emacs-policy;">emacs
policy</ulink>.
</para>
</listitem>
<listitem>
<para>
Java related packages have their <ulink
url="&url-java-policy;">java
policy</ulink>.
</para>
</listitem>
<listitem>
<para>
Ocaml related packages have their own policy, found in
&file-ocaml-policy; from the <systemitem
role="package">ocaml</systemitem> package.  A good example is the <systemitem
role="package">camlzip</systemitem> source package.
</para>
</listitem>
<listitem>
<para>
Packages providing XML or SGML DTDs should conform to the recommendations found
in the <systemitem role="package">sgml-base-doc</systemitem> package.
</para>
</listitem>
<listitem>
<para>
Lisp packages should register themselves with <systemitem
role="package">common-lisp-controller</systemitem>, about which see
&file-lisp-controller;.
</para>
</listitem>
<!-- TODO: mozilla extension policy, once that becomes available -->
</itemizedlist>
</section>

<!--
<section id="custom-config-files">
<title>Custom configuration files</title>
<para>
FIXME: speak of "ucf", explain solution with a template,
explain conf.d directories
</para>
</section>
<section id="config-with-db">
<title>Use of an external database</title>
<para>
FIXME: The software may require a database that you need to setup.
But the database may be local or distant. Thus you can't depend
on a database server but just on the corresponding library.

sympa may be an example package
</para>
</section>
-->

<section id="bpp-archindepdata">
<title>Architecture-independent data</title>
<para>
It is not uncommon to have a large amount of architecture-independent data
packaged with a program.  For example, audio files, a collection of icons,
wallpaper patterns, or other graphic files.  If the size of this data is
negligible compared to the size of the rest of the package, it's probably best
to keep it all in a single package.
</para>
<para>
However, if the size of the data is considerable, consider splitting it out
into a separate, architecture-independent package (_all.deb).  By doing this,
you avoid needless duplication of the same data into eleven or more .debs, one
per each architecture.  While this adds some extra overhead into the
<filename>Packages</filename> files, it saves a lot of disk space on Debian
mirrors.  Separating out architecture-independent data also reduces processing
time of <command>lintian</command> (see <xref
linkend="tools-lint"/> ) when run over the entire Debian archive.
</para>
</section>

<section id="bpp-locale">
<title>Needing a certain locale during build</title>
<para>
If you need a certain locale during build, you can create a temporary file via
this trick:
</para>
<para>
If you set <varname>LOCPATH</varname> to the equivalent of <filename>/usr/lib/locale</filename>, and <varname>LC_ALL</varname> to the name
of the locale you generate, you should get what you want without being root.
Something like this:
</para>
<screen>
LOCALE_PATH=debian/tmpdir/usr/lib/locale
LOCALE_NAME=en_IN
LOCALE_CHARSET=UTF-8

mkdir -p $LOCALE_PATH
localedef -i $LOCALE_NAME.$LOCALE_CHARSET -f $LOCALE_CHARSET $LOCALE_PATH/$LOCALE_NAME.$LOCALE_CHARSET

# Using the locale
LOCPATH=$LOCALE_PATH LC_ALL=$LOCALE_NAME.$LOCALE_CHARSET date
</screen>
</section>

<section id="bpp-transition">
<title>Make transition packages deborphan compliant</title>
<para>
Deborphan is a program for helping users to detect which packages can safely be
removed from the system, i.e.  the ones that have no packages depending on
them.  The default operation is to search only within the libs and oldlibs
sections, to hunt down unused libraries.  But when passed the right argument,
it tries to catch other useless packages.
</para>
<para>
For example, with --guess-dummy, deborphan tries to search all transitional
packages which were needed for upgrade but which can now safely be removed.
For that, it looks for the string dummy or transitional in their short
description.
</para>
<para>
So, when you are creating such a package, please make sure to add this text to
your short description.  If you are looking for examples, just run:
<command>apt-cache search .|grep dummy</command> or
<command>apt-cache search .|grep transitional</command>.
</para>
</section>

<section id="bpp-origtargz">
<title>Best practices for <filename>orig.tar.gz</filename> files</title>
<para>
There are two kinds of original source tarballs: Pristine source and repackaged
upstream source.
</para>
<section id="pristinesource">
<title>Pristine source</title>
<para>
The defining characteristic of a pristine source tarball is that the
.orig.tar.gz file is byte-for-byte identical to a tarball officially
distributed by the upstream author.  <footnote><para> We cannot prevent
upstream authors from changing the tarball they distribute without also
incrementing the version number, so there can be no guarantee that a pristine
tarball is identical to what upstream <emphasis>currently</emphasis>
distributing at any point in time.  All that can be expected is that it is
identical to something that upstream once <emphasis>did</emphasis> distribute.
If a difference arises later (say, if upstream notices that he wasn't using
maximal comression in his original distribution and then
re-<literal>gzip</literal>s it), that's just too bad.  Since there is no good
way to upload a new .orig.tar.gz for the same version, there is not even any
point in treating this situation as a bug.  </para> </footnote> This makes it
possible to use checksums to easily verify that all changes between Debian's
version and upstream's are contained in the Debian diff.  Also, if the original
source is huge, upstream authors and others who already have the upstream
tarball can save download time if they want to inspect your packaging in
detail.
</para>
<para>
There is no universally accepted guidelines that upstream authors follow
regarding to the directory structure inside their tarball, but
<command>dpkg-source</command> is nevertheless able to deal with most upstream
tarballs as pristine source.  Its strategy is equivalent to the following:
</para>
<orderedlist numeration="arabic">
<listitem>
<para>
It unpacks the tarball in an empty temporary directory by doing
</para>
<screen>
zcat path/to/&lt;packagename&gt;_&lt;upstream-version&gt;.orig.tar.gz | tar xf -
</screen>
</listitem>
<listitem>
<para>
If, after this, the temporary directory contains nothing but one directory and
no other files, <command>dpkg-source</command> renames that directory to
<literal>&lt;packagename&gt;-&lt;upstream-version&gt;(.orig)</literal>.  The
name of the top-level directory in the tarball does not matter, and is
forgotten.
</para>
</listitem>
<listitem>
<para>
Otherwise, the upstream tarball must have been packaged without a common
top-level directory (shame on the upstream author!).  In this case,
<command>dpkg-source</command> renames the temporary directory
<emphasis>itself</emphasis> to
<literal>&lt;packagename&gt;-&lt;upstream-version&gt;(.orig)</literal>.
</para>
</listitem>
</orderedlist>
</section>

<section id="repackagedorigtargz">
<title>Repackaged upstream source</title>
<para>
You <emphasis role="strong">should</emphasis> upload packages with a pristine
source tarball if possible, but there are various reasons why it might not be
possible.  This is the case if upstream does not distribute the source as
gzipped tar at all, or if upstream's tarball contains non-DFSG-free material
that you must remove before uploading.
</para>
<para>
In these cases the developer must construct a suitable .orig.tar.gz file
himself.  We refer to such a tarball as a repackaged upstream source.  Note
that a repackaged upstream source is different from a Debian-native package.  A
repackaged source still comes with Debian-specific changes in a separate
<literal>.diff.gz</literal> and still has a version number composed of
<literal>&lt;upstream-version&gt;</literal> and
<literal>&lt;debian-revision&gt;</literal>.
</para>
<para>
There may be cases where it is desirable to repackage the source even though
upstream distributes a <literal>.tar.gz</literal> that could in principle be
used in its pristine form.  The most obvious is if
<emphasis>significant</emphasis> space savings can be achieved by recompressing
the tar archive or by removing genuinely useless cruft from the upstream
archive.  Use your own discretion here, but be prepared to defend your decision
if you repackage source that could have been pristine.
</para>
<para>
A repackaged .orig.tar.gz
</para>
<orderedlist numeration="arabic">
<listitem>
<para>
<emphasis role="strong">must</emphasis> contain detailed information how the
repackaged source was obtained, and how this can be reproduced in the
<filename>debian/copyright</filename>.  It is also a good idea to provide a
<literal>get-orig-source</literal> target in your
<filename>debian/rules</filename> file that repeats the process, as described
in the Policy Manual, <ulink
url="&url-debian-policy;ch-source.html#s-debianrules">Main
building script: debian/rules</ulink>.
</para>
</listitem>
<listitem>
<para>
<emphasis role="strong">should not</emphasis> contain any file that does not
come from the upstream author(s), or whose contents has been changed by you.
<footnote><para> As a special exception, if the omission of non-free files
would lead to the source failing to build without assistance from the Debian
diff, it might be appropriate to instead edit the files, omitting only the
non-free parts of them, and/or explain the situation in a README.Debian-source
<!-- or similarly named -->
file in the root of the source tree.  But in that case please also urge the
upstream author to make the non-free components easier seperable from the rest
of the source.  </para> </footnote>
</para>
</listitem>
<listitem>
<para>
<emphasis role="strong">should</emphasis>, except where impossible for legal
reasons, preserve the entire building and portablility infrastructure provided
by the upstream author.  For example, it is not a sufficient reason for
omitting a file that it is used only when building on MS-DOS.  Similarly, a
Makefile provided by upstream should not be omitted even if the first thing
your <filename>debian/rules</filename> does is to overwrite it by running a
configure script.
</para>
<para>
(<emphasis>Rationale:</emphasis> It is common for Debian users who need to
build software for non-Debian platforms to fetch the source from a Debian
mirror rather than trying to locate a canonical upstream distribution point).
</para>
</listitem>
<listitem>
<para>
<emphasis role="strong">should</emphasis> use
<literal>&lt;packagename&gt;-&lt;upstream-version&gt;.orig</literal> as the
name of the top-level directory in its tarball.  This makes it possible to
distinguish pristine tarballs from repackaged ones.
</para>
</listitem>
<listitem>
<para>
<emphasis role="strong">should</emphasis> be gzipped with maximal compression.
</para>
</listitem>
</orderedlist>
<para>
The canonical way to meet the latter two points is to let <literal>dpkg-source
-b</literal> construct the repackaged tarball from an unpacked directory.
</para>
</section>

<section id="changed-binfiles">
<title>Changing binary files in <literal>diff.gz</literal></title>
<para>
Sometimes it is necessary to change binary files contained in the original
tarball, or to add binary files that are not in it.  If this is done by simply
copying the files into the debianized source tree,
<command>dpkg-source</command> will not be able to handle this.  On the other
hand, according to the guidelines given above, you cannot include such a
changed binary file in a repackaged <filename>orig.tar.gz</filename>.  Instead,
include the file in the <filename>debian</filename> directory in
<command>uuencode</command>d (or similar) form <footnote><para> The file should
have a name that makes it clear which binary file it encodes.  Usually, some
postfix indicating the encoding should be appended to the original filename.
Note that you don't need to depend on <systemitem
role="package">sharutils</systemitem> to get the <command>uudecode</command>
program if you use <command>perl</command>'s <literal>pack</literal> function.
The code could look like
</para>
&example-uu;
</footnote>.  The file would then be
decoded and copied to its place during the build process.  Thus the change will
be visible quite easy.
</para>
<para>
Some packages use <command>dbs</command> to manage patches to their upstream
source, and always create a new <literal>orig.tar.gz</literal> file that
contains the real <literal>orig.tar.gz</literal> in its toplevel directory.
This is questionable with respect to the preference for pristine source.  On
the other hand, it is easy to modify or add binary files in this case: Just put
them into the newly created <literal>orig.tar.gz</literal> file, besides the
real one, and copy them to the right place during the build process.
</para>
</section>

</section>

<section id="bpp-dbg">
<title>Best practices for debug packages</title>
<para>
A debug package is a package with a name ending in -dbg, that contains
additional information that gdb can use.  Since Debian binaries are stripped by
default, debugging information, including function names and line numbers, is
otherwise not available when running gdb on Debian binaries.  Debug packages
allow users who need this additional debugging information to install it,
without bloating a regular system with the information.
</para>
<para>
It is up to a package's maintainer whether to create a debug package or not.
Maintainers are encouraged to create debug packages for library packages, since
this can aid in debugging many programs linked to a library.  In general, debug
packages do not need to be added for all programs; doing so would bloat the
archive.  But if a maintainer finds that users often need a debugging version
of a program, it can be worthwhile to make a debug package for it.  Programs
that are core infrastructure, such as apache and the X server are also good
candidates for debug packages.
</para>
<para>
Some debug packages may contain an entire special debugging build of a library
or other binary, but most of them can save space and build time by instead
containing separated debugging symbols that gdb can find and load on the fly
when debugging a program or library.  The convention in Debian is to keep these
symbols in <filename>/usr/lib/debug/path</filename>, where
<emphasis>path</emphasis> is the path to the executable or library.  For
example, debugging symbols for <filename>/usr/bin/foo</filename> go in
<filename>/usr/lib/debug/usr/bin/foo</filename>, and debugging symbols for
<filename>/usr/lib/libfoo.so.1</filename> go in
<filename>/usr/lib/debug/usr/lib/libfoo.so.1</filename>.
</para>
<para>
The debugging symbols can be extracted from an object file using objcopy
--only-keep-debug.  Then the object file can be stripped, and objcopy
--add-gnu-debuglink used to specify the path to the debugging symbol file.
<citerefentry> <refentrytitle>objcopy</refentrytitle> <manvolnum>1</manvolnum>
</citerefentry> explains in detail how this works.
</para>
<para>
The dh_strip command in debhelper supports creating debug packages, and can
take care of using objcopy to separate out the debugging symbols for you.  If
your package uses debhelper, all you need to do is call dh_strip
--dbg-package=libfoo-dbg, and add an entry to debian/control for the debug
package.
</para>
<para>
Note that the Debian package should depend on the package that it provides
debugging symbols for, and this dependency should be versioned.  For example:
</para>
<screen>
Depends: libfoo-dbg (= ${binary:Version})
</screen>
</section>

</section>

</chapter>

